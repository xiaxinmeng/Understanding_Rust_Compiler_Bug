{"sha": "98815742cf2e914ee0d7142a02322cf939c47834", "node_id": "C_kwDOAAsO6NoAKDk4ODE1NzQyY2YyZTkxNGVlMGQ3MTQyYTAyMzIyY2Y5MzljNDc4MzQ", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-10-18T11:23:49Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-11-06T14:32:59Z"}, "message": "std: remove lock wrappers in `sys_common`", "tree": {"sha": "1915c9196da26046e81dddcd90950d1d9c39913c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1915c9196da26046e81dddcd90950d1d9c39913c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98815742cf2e914ee0d7142a02322cf939c47834", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmNnxZsACgkQcE4BSbAZ\nSzxwgw/+Mb22AXkcq5YEroHhnz7AKA8hU7cGJypFQWRHOH4YpwUrGfp3zXUA3tIX\nMmLfAkieh56/A/mnqJfD65eQvQaWVaLkwKxa2WJRUh30wp98BuSpwzG4px+ICkum\n1pJV5ay3P8rSf80NajusDUxAcUR/qSUj3811C/+iPzQ8XW6bnmX4j0a6IyuarQHw\n5NFDK53SrC4tYbe+ifp0wOkh9u6cFSCs7cAHlg00chuT4YDAm5fcNqXLzmZE1wFf\nPgisA2S20misbLrAomJirwvcY9O508AqSKA4M/Wag9jnRPht7LDmxBUXoubql49+\nUBxjMAtoXvCxRnXsoBqXHV2ClG5+jIs2/qhVgioQOeok3xzRbWZlxgq+8rEs0Y8k\n5GzwHc2YdYCLWjTCCMvVG4vF+lOj9E09yTecQxfQubzCN6LoKqiyT8AOmcA4loDX\naQhS72WaRxqwChiqJ9K2f9gJWMQL2FOK+9YBZHU1XyCqy+v2CKdGpgB8/LX4oX9+\nOVXsD6gFSLBtR2JoD+SW7GSZpMgpWwYoUkjEI3e5pSUTSf/Rexh/uBDNNPIkYLTY\nktI8st4RS5f3RIGPvOFXJITKb6kcMo9KAA2FhLM5G8XU4u1V90CgEFsQ+EM2szwD\nfMjDvQQNJ8f78pbrCuzawiRebY0aueki2kEeh9svgcf9F6LgmmE=\n=0T7M\n-----END PGP SIGNATURE-----", "payload": "tree 1915c9196da26046e81dddcd90950d1d9c39913c\nparent 534ddc6166a9031b0c269544929d68f2539ea7a0\nauthor joboet <jonasboettiger@icloud.com> 1666092229 +0200\ncommitter joboet <jonasboettiger@icloud.com> 1667745179 +0100\n\nstd: remove lock wrappers in `sys_common`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98815742cf2e914ee0d7142a02322cf939c47834", "html_url": "https://github.com/rust-lang/rust/commit/98815742cf2e914ee0d7142a02322cf939c47834", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98815742cf2e914ee0d7142a02322cf939c47834/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "534ddc6166a9031b0c269544929d68f2539ea7a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/534ddc6166a9031b0c269544929d68f2539ea7a0", "html_url": "https://github.com/rust-lang/rust/commit/534ddc6166a9031b0c269544929d68f2539ea7a0"}], "stats": {"total": 1057, "additions": 404, "deletions": 653}, "files": [{"sha": "76a1b4a2a86cd461679f1ec152f49f7375a4ee66", "filename": "library/std/src/sync/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -3,7 +3,7 @@ mod tests;\n \n use crate::fmt;\n use crate::sync::{mutex, poison, LockResult, MutexGuard, PoisonError};\n-use crate::sys_common::condvar as sys;\n+use crate::sys::locks as sys;\n use crate::time::{Duration, Instant};\n \n /// A type indicating whether a timed wait on a condition variable returned"}, {"sha": "065045f442069feaa75a5d6b46e7b5a707af2b33", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -5,7 +5,7 @@ use crate::cell::UnsafeCell;\n use crate::fmt;\n use crate::ops::{Deref, DerefMut};\n use crate::sync::{poison, LockResult, TryLockError, TryLockResult};\n-use crate::sys_common::mutex as sys;\n+use crate::sys::locks as sys;\n \n /// A mutual exclusion primitive useful for protecting shared data\n ///\n@@ -163,7 +163,7 @@ use crate::sys_common::mutex as sys;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Mutex\")]\n pub struct Mutex<T: ?Sized> {\n-    inner: sys::MovableMutex,\n+    inner: sys::Mutex,\n     poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n@@ -217,11 +217,7 @@ impl<T> Mutex<T> {\n     #[rustc_const_stable(feature = \"const_locks\", since = \"1.63.0\")]\n     #[inline]\n     pub const fn new(t: T) -> Mutex<T> {\n-        Mutex {\n-            inner: sys::MovableMutex::new(),\n-            poison: poison::Flag::new(),\n-            data: UnsafeCell::new(t),\n-        }\n+        Mutex { inner: sys::Mutex::new(), poison: poison::Flag::new(), data: UnsafeCell::new(t) }\n     }\n }\n \n@@ -264,7 +260,7 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<'_, T>> {\n         unsafe {\n-            self.inner.raw_lock();\n+            self.inner.lock();\n             MutexGuard::new(self)\n         }\n     }\n@@ -526,7 +522,7 @@ impl<T: ?Sized> Drop for MutexGuard<'_, T> {\n     fn drop(&mut self) {\n         unsafe {\n             self.lock.poison.done(&self.poison);\n-            self.lock.inner.raw_unlock();\n+            self.lock.inner.unlock();\n         }\n     }\n }\n@@ -545,7 +541,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for MutexGuard<'_, T> {\n     }\n }\n \n-pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::MovableMutex {\n+pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n     &guard.lock.inner\n }\n "}, {"sha": "7c409cb3e9776e62aab48049f830d81105ff707d", "filename": "library/std/src/sync/rwlock.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -6,7 +6,7 @@ use crate::fmt;\n use crate::ops::{Deref, DerefMut};\n use crate::ptr::NonNull;\n use crate::sync::{poison, LockResult, TryLockError, TryLockResult};\n-use crate::sys_common::rwlock as sys;\n+use crate::sys::locks as sys;\n \n /// A reader-writer lock\n ///\n@@ -78,7 +78,7 @@ use crate::sys_common::rwlock as sys;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"RwLock\")]\n pub struct RwLock<T: ?Sized> {\n-    inner: sys::MovableRwLock,\n+    inner: sys::RwLock,\n     poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n@@ -109,7 +109,7 @@ pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n     // `NonNull` is also covariant over `T`, just like we would have with `&T`. `NonNull`\n     // is preferable over `const* T` to allow for niche optimization.\n     data: NonNull<T>,\n-    inner_lock: &'a sys::MovableRwLock,\n+    inner_lock: &'a sys::RwLock,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -158,11 +158,7 @@ impl<T> RwLock<T> {\n     #[rustc_const_stable(feature = \"const_locks\", since = \"1.63.0\")]\n     #[inline]\n     pub const fn new(t: T) -> RwLock<T> {\n-        RwLock {\n-            inner: sys::MovableRwLock::new(),\n-            poison: poison::Flag::new(),\n-            data: UnsafeCell::new(t),\n-        }\n+        RwLock { inner: sys::RwLock::new(), poison: poison::Flag::new(), data: UnsafeCell::new(t) }\n     }\n }\n "}, {"sha": "6811fadb0188cd5d922e67803262f7676ce81c8a", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -51,9 +51,9 @@ pub mod locks {\n     mod futex_condvar;\n     mod futex_mutex;\n     mod futex_rwlock;\n-    pub(crate) use futex_condvar::MovableCondvar;\n-    pub(crate) use futex_mutex::{MovableMutex, Mutex};\n-    pub(crate) use futex_rwlock::{MovableRwLock, RwLock};\n+    pub(crate) use futex_condvar::Condvar;\n+    pub(crate) use futex_mutex::Mutex;\n+    pub(crate) use futex_rwlock::RwLock;\n }\n \n use crate::io::ErrorKind;"}, {"sha": "f70aa434e48348b3b5289a52cdbc632d2f625b2e", "filename": "library/std/src/sys/itron/condvar.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -12,18 +12,13 @@ pub struct Condvar {\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n-pub type MovableCondvar = Condvar;\n-\n impl Condvar {\n     #[inline]\n     pub const fn new() -> Condvar {\n         Condvar { waiters: SpinMutex::new(waiter_queue::WaiterQueue::new()) }\n     }\n \n-    #[inline]\n-    pub unsafe fn init(&mut self) {}\n-\n-    pub unsafe fn notify_one(&self) {\n+    pub fn notify_one(&self) {\n         self.waiters.with_locked(|waiters| {\n             if let Some(task) = waiters.pop_front() {\n                 // Unpark the task\n@@ -39,7 +34,7 @@ impl Condvar {\n         });\n     }\n \n-    pub unsafe fn notify_all(&self) {\n+    pub fn notify_all(&self) {\n         self.waiters.with_locked(|waiters| {\n             while let Some(task) = waiters.pop_front() {\n                 // Unpark the task"}, {"sha": "f2eed8e771c40ece6fd04b090ae918c3843f694b", "filename": "library/std/src/sys/itron/mutex.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -11,8 +11,6 @@ pub struct Mutex {\n     mtx: SpinIdOnceCell<()>,\n }\n \n-pub type MovableMutex = Mutex;\n-\n /// Create a mutex object. This function never panics.\n fn new_mtx() -> Result<abi::ID, ItronError> {\n     ItronError::err_if_negative(unsafe {\n@@ -39,7 +37,7 @@ impl Mutex {\n         }\n     }\n \n-    pub unsafe fn lock(&self) {\n+    pub fn lock(&self) {\n         let mtx = self.raw();\n         expect_success(unsafe { abi::loc_mtx(mtx) }, &\"loc_mtx\");\n     }\n@@ -49,7 +47,7 @@ impl Mutex {\n         expect_success_aborting(unsafe { abi::unl_mtx(mtx) }, &\"unl_mtx\");\n     }\n \n-    pub unsafe fn try_lock(&self) -> bool {\n+    pub fn try_lock(&self) -> bool {\n         let mtx = self.raw();\n         match unsafe { abi::ploc_mtx(mtx) } {\n             abi::E_TMOUT => false,"}, {"sha": "aa1174664aeb0966deae0b3343ee063f01e0e6ab", "filename": "library/std/src/sys/sgx/condvar.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -4,42 +4,43 @@ use crate::time::Duration;\n \n use super::waitqueue::{SpinMutex, WaitQueue, WaitVariable};\n \n+/// FIXME: `UnsafeList` is not movable.\n+struct AllocatedCondvar(SpinMutex<WaitVariable<()>>);\n+\n pub struct Condvar {\n-    inner: SpinMutex<WaitVariable<()>>,\n+    inner: LazyBox<AllocatedCondvar>,\n }\n \n-pub(crate) type MovableCondvar = LazyBox<Condvar>;\n-\n-impl LazyInit for Condvar {\n+impl LazyInit for AllocatedCondvar {\n     fn init() -> Box<Self> {\n-        Box::new(Self::new())\n+        Box::new(AllocatedCondvar(SpinMutex::new(WaitVariable::new(()))))\n     }\n }\n \n impl Condvar {\n     pub const fn new() -> Condvar {\n-        Condvar { inner: SpinMutex::new(WaitVariable::new(())) }\n+        Condvar { inner: LazyBox::new() }\n     }\n \n     #[inline]\n-    pub unsafe fn notify_one(&self) {\n-        let _ = WaitQueue::notify_one(self.inner.lock());\n+    pub fn notify_one(&self) {\n+        let _ = WaitQueue::notify_one(self.inner.0.lock());\n     }\n \n     #[inline]\n-    pub unsafe fn notify_all(&self) {\n-        let _ = WaitQueue::notify_all(self.inner.lock());\n+    pub fn notify_all(&self) {\n+        let _ = WaitQueue::notify_all(self.inner.0.lock());\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {\n-        let guard = self.inner.lock();\n+        let guard = self.inner.0.lock();\n         WaitQueue::wait(guard, || unsafe { mutex.unlock() });\n-        unsafe { mutex.lock() }\n+        mutex.lock()\n     }\n \n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        let success = WaitQueue::wait_timeout(&self.inner, dur, || unsafe { mutex.unlock() });\n-        unsafe { mutex.lock() };\n+        let success = WaitQueue::wait_timeout(&self.inner.0, dur, || unsafe { mutex.unlock() });\n+        mutex.lock();\n         success\n     }\n }"}, {"sha": "0dbf020ebe06af53bd12e53de14d655aa89001a4", "filename": "library/std/src/sys/sgx/mutex.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -1,28 +1,28 @@\n use super::waitqueue::{try_lock_or_false, SpinMutex, WaitQueue, WaitVariable};\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n \n+/// FIXME: `UnsafeList` is not movable.\n+struct AllocatedMutex(SpinMutex<WaitVariable<bool>>);\n+\n pub struct Mutex {\n-    inner: SpinMutex<WaitVariable<bool>>,\n+    inner: LazyBox<AllocatedMutex>,\n }\n \n-// not movable: see UnsafeList implementation\n-pub(crate) type MovableMutex = LazyBox<Mutex>;\n-\n-impl LazyInit for Mutex {\n+impl LazyInit for AllocatedMutex {\n     fn init() -> Box<Self> {\n-        Box::new(Self::new())\n+        Box::new(AllocatedMutex(SpinMutex::new(WaitVariable::new(false))))\n     }\n }\n \n // Implementation according to \u201cOperating Systems: Three Easy Pieces\u201d, chapter 28\n impl Mutex {\n     pub const fn new() -> Mutex {\n-        Mutex { inner: SpinMutex::new(WaitVariable::new(false)) }\n+        Mutex { inner: LazyBox::new() }\n     }\n \n     #[inline]\n-    pub unsafe fn lock(&self) {\n-        let mut guard = self.inner.lock();\n+    pub fn lock(&self) {\n+        let mut guard = self.inner.0.lock();\n         if *guard.lock_var() {\n             // Another thread has the lock, wait\n             WaitQueue::wait(guard, || {})\n@@ -35,7 +35,7 @@ impl Mutex {\n \n     #[inline]\n     pub unsafe fn unlock(&self) {\n-        let guard = self.inner.lock();\n+        let guard = self.inner.0.lock();\n         if let Err(mut guard) = WaitQueue::notify_one(guard) {\n             // No other waiters, unlock\n             *guard.lock_var_mut() = false;\n@@ -45,8 +45,8 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        let mut guard = try_lock_or_false!(self.inner);\n+    pub fn try_lock(&self) -> bool {\n+        let mut guard = try_lock_or_false!(self.inner.0);\n         if *guard.lock_var() {\n             // Another thread has the lock\n             false"}, {"sha": "d89de18ca5ff8f8295c5e958a655091b3a5aaf1a", "filename": "library/std/src/sys/sgx/rwlock.rs", "status": "modified", "additions": 44, "deletions": 34, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -7,42 +7,45 @@ use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n use super::waitqueue::{\n     try_lock_or_false, NotifiedTcs, SpinMutex, SpinMutexGuard, WaitQueue, WaitVariable,\n };\n-use crate::mem;\n+use crate::alloc::Layout;\n \n-pub struct RwLock {\n+struct AllocatedRwLock {\n     readers: SpinMutex<WaitVariable<Option<NonZeroUsize>>>,\n     writer: SpinMutex<WaitVariable<bool>>,\n }\n \n-pub(crate) type MovableRwLock = LazyBox<RwLock>;\n+pub struct RwLock {\n+    inner: LazyBox<AllocatedRwLock>,\n+}\n \n-impl LazyInit for RwLock {\n+impl LazyInit for AllocatedRwLock {\n     fn init() -> Box<Self> {\n-        Box::new(Self::new())\n+        Box::new(AllocatedRwLock {\n+            readers: SpinMutex::new(WaitVariable::new(None)),\n+            writer: SpinMutex::new(WaitVariable::new(false)),\n+        })\n     }\n }\n \n-// Check at compile time that RwLock size matches C definition (see test_c_rwlock_initializer below)\n-//\n-// # Safety\n-// Never called, as it is a compile time check.\n-#[allow(dead_code)]\n-unsafe fn rw_lock_size_assert(r: RwLock) {\n-    unsafe { mem::transmute::<RwLock, [u8; 144]>(r) };\n-}\n+// Check at compile time that RwLock's size and alignment matches the C definition\n+// in libunwind (see also `test_c_rwlock_initializer` in `tests`).\n+const _: () = {\n+    let rust = Layout::new::<RwLock>();\n+    let c = Layout::new::<*mut ()>();\n+    assert!(rust.size() == c.size());\n+    assert!(rust.align() == c.align());\n+};\n \n impl RwLock {\n     pub const fn new() -> RwLock {\n-        RwLock {\n-            readers: SpinMutex::new(WaitVariable::new(None)),\n-            writer: SpinMutex::new(WaitVariable::new(false)),\n-        }\n+        RwLock { inner: LazyBox::new() }\n     }\n \n     #[inline]\n-    pub unsafe fn read(&self) {\n-        let mut rguard = self.readers.lock();\n-        let wguard = self.writer.lock();\n+    pub fn read(&self) {\n+        let lock = &*self.inner;\n+        let mut rguard = lock.readers.lock();\n+        let wguard = lock.writer.lock();\n         if *wguard.lock_var() || !wguard.queue_empty() {\n             // Another thread has or is waiting for the write lock, wait\n             drop(wguard);\n@@ -57,8 +60,9 @@ impl RwLock {\n \n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        let mut rguard = try_lock_or_false!(self.readers);\n-        let wguard = try_lock_or_false!(self.writer);\n+        let lock = &*self.inner;\n+        let mut rguard = try_lock_or_false!(lock.readers);\n+        let wguard = try_lock_or_false!(lock.writer);\n         if *wguard.lock_var() || !wguard.queue_empty() {\n             // Another thread has or is waiting for the write lock\n             false\n@@ -71,9 +75,10 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn write(&self) {\n-        let rguard = self.readers.lock();\n-        let mut wguard = self.writer.lock();\n+    pub fn write(&self) {\n+        let lock = &*self.inner;\n+        let rguard = lock.readers.lock();\n+        let mut wguard = lock.writer.lock();\n         if *wguard.lock_var() || rguard.lock_var().is_some() {\n             // Another thread has the lock, wait\n             drop(rguard);\n@@ -86,9 +91,10 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n-        let rguard = try_lock_or_false!(self.readers);\n-        let mut wguard = try_lock_or_false!(self.writer);\n+    pub fn try_write(&self) -> bool {\n+        let lock = &*self.inner;\n+        let rguard = try_lock_or_false!(lock.readers);\n+        let mut wguard = try_lock_or_false!(lock.writer);\n         if *wguard.lock_var() || rguard.lock_var().is_some() {\n             // Another thread has the lock\n             false\n@@ -122,8 +128,9 @@ impl RwLock {\n \n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        let rguard = self.readers.lock();\n-        let wguard = self.writer.lock();\n+        let lock = &*self.inner;\n+        let rguard = lock.readers.lock();\n+        let wguard = lock.writer.lock();\n         unsafe { self.__read_unlock(rguard, wguard) };\n     }\n \n@@ -158,17 +165,19 @@ impl RwLock {\n \n     #[inline]\n     pub unsafe fn write_unlock(&self) {\n-        let rguard = self.readers.lock();\n-        let wguard = self.writer.lock();\n+        let lock = &*self.inner;\n+        let rguard = lock.readers.lock();\n+        let wguard = lock.writer.lock();\n         unsafe { self.__write_unlock(rguard, wguard) };\n     }\n \n     // only used by __rust_rwlock_unlock below\n     #[inline]\n     #[cfg_attr(test, allow(dead_code))]\n     unsafe fn unlock(&self) {\n-        let rguard = self.readers.lock();\n-        let wguard = self.writer.lock();\n+        let lock = &*self.inner;\n+        let rguard = lock.readers.lock();\n+        let wguard = lock.writer.lock();\n         if *wguard.lock_var() == true {\n             unsafe { self.__write_unlock(rguard, wguard) };\n         } else {\n@@ -201,6 +210,7 @@ pub unsafe extern \"C\" fn __rust_rwlock_wrlock(p: *mut RwLock) -> i32 {\n     unsafe { (*p).write() };\n     return 0;\n }\n+\n #[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_rwlock_unlock(p: *mut RwLock) -> i32 {"}, {"sha": "5fd6670afd4356db2de86376bbd38a00d5d54850", "filename": "library/std/src/sys/sgx/rwlock/tests.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -1,22 +1,12 @@\n use super::*;\n+use crate::ptr;\n \n // Verify that the byte pattern libunwind uses to initialize an RwLock is\n // equivalent to the value of RwLock::new(). If the value changes,\n // `src/UnwindRustSgx.h` in libunwind needs to be changed too.\n #[test]\n fn test_c_rwlock_initializer() {\n-    #[rustfmt::skip]\n-    const C_RWLOCK_INIT: &[u8] = &[\n-        /* 0x00 */ 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x10 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x20 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x30 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x40 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x50 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x60 */ 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x70 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-        /* 0x80 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n-    ];\n+    const C_RWLOCK_INIT: *mut () = ptr::null_mut();\n \n     // For the test to work, we need the padding/unused bytes in RwLock to be\n     // initialized as 0. In practice, this is the case with statics.\n@@ -26,6 +16,6 @@ fn test_c_rwlock_initializer() {\n         // If the assertion fails, that not necessarily an issue with the value\n         // of C_RWLOCK_INIT. It might just be an issue with the way padding\n         // bytes are initialized in the test code.\n-        assert_eq!(&crate::mem::transmute_copy::<_, [u8; 144]>(&RUST_RWLOCK_INIT), C_RWLOCK_INIT);\n+        assert_eq!(crate::mem::transmute_copy::<_, *mut ()>(&RUST_RWLOCK_INIT), C_RWLOCK_INIT);\n     };\n }"}, {"sha": "ecb4eb83b9b05efa66e40fe48f3e98c9af930585", "filename": "library/std/src/sys/solid/rwlock.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Frwlock.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -12,8 +12,6 @@ pub struct RwLock {\n     rwl: SpinIdOnceCell<()>,\n }\n \n-pub type MovableRwLock = RwLock;\n-\n // Safety: `num_readers` is protected by `mtx_num_readers`\n unsafe impl Send for RwLock {}\n unsafe impl Sync for RwLock {}\n@@ -37,13 +35,13 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn read(&self) {\n+    pub fn read(&self) {\n         let rwl = self.raw();\n         expect_success(unsafe { abi::rwl_loc_rdl(rwl) }, &\"rwl_loc_rdl\");\n     }\n \n     #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n+    pub fn try_read(&self) -> bool {\n         let rwl = self.raw();\n         match unsafe { abi::rwl_ploc_rdl(rwl) } {\n             abi::E_TMOUT => false,\n@@ -55,13 +53,13 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn write(&self) {\n+    pub fn write(&self) {\n         let rwl = self.raw();\n         expect_success(unsafe { abi::rwl_loc_wrl(rwl) }, &\"rwl_loc_wrl\");\n     }\n \n     #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n+    pub fn try_write(&self) -> bool {\n         let rwl = self.raw();\n         match unsafe { abi::rwl_ploc_wrl(rwl) } {\n             abi::E_TMOUT => false,"}, {"sha": "5d89e5a13fd366fec28cd38e7d02c3c1b7ec0720", "filename": "library/std/src/sys/unix/locks/fuchsia_mutex.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -53,8 +53,6 @@ const CONTESTED_BIT: u32 = 1;\n // This can never be a valid `zx_handle_t`.\n const UNLOCKED: u32 = 0;\n \n-pub type MovableMutex = Mutex;\n-\n pub struct Mutex {\n     futex: AtomicU32,\n }\n@@ -86,23 +84,27 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        let thread_self = zx_thread_self();\n+    pub fn try_lock(&self) -> bool {\n+        let thread_self = unsafe { zx_thread_self() };\n         self.futex.compare_exchange(UNLOCKED, to_state(thread_self), Acquire, Relaxed).is_ok()\n     }\n \n     #[inline]\n-    pub unsafe fn lock(&self) {\n-        let thread_self = zx_thread_self();\n+    pub fn lock(&self) {\n+        let thread_self = unsafe { zx_thread_self() };\n         if let Err(state) =\n             self.futex.compare_exchange(UNLOCKED, to_state(thread_self), Acquire, Relaxed)\n         {\n-            self.lock_contested(state, thread_self);\n+            unsafe {\n+                self.lock_contested(state, thread_self);\n+            }\n         }\n     }\n \n+    /// # Safety\n+    /// `thread_self` must be the handle for the current thread.\n     #[cold]\n-    fn lock_contested(&self, mut state: u32, thread_self: zx_handle_t) {\n+    unsafe fn lock_contested(&self, mut state: u32, thread_self: zx_handle_t) {\n         let owned_state = mark_contested(to_state(thread_self));\n         loop {\n             // Mark the mutex as contested if it is not already."}, {"sha": "4bd65dd25c2921c5a91a05013b3ce99346f247f6", "filename": "library/std/src/sys/unix/locks/futex_condvar.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -3,8 +3,6 @@ use crate::sync::atomic::{AtomicU32, Ordering::Relaxed};\n use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n use crate::time::Duration;\n \n-pub type MovableCondvar = Condvar;\n-\n pub struct Condvar {\n     // The value of this atomic is simply incremented on every notification.\n     // This is used by `.wait()` to not miss any notifications after\n@@ -21,12 +19,12 @@ impl Condvar {\n     // All the memory orderings here are `Relaxed`,\n     // because synchronization is done by unlocking and locking the mutex.\n \n-    pub unsafe fn notify_one(&self) {\n+    pub fn notify_one(&self) {\n         self.futex.fetch_add(1, Relaxed);\n         futex_wake(&self.futex);\n     }\n \n-    pub unsafe fn notify_all(&self) {\n+    pub fn notify_all(&self) {\n         self.futex.fetch_add(1, Relaxed);\n         futex_wake_all(&self.futex);\n     }"}, {"sha": "c01229586c30201c51cad01cbd328f1986f330f2", "filename": "library/std/src/sys/unix/locks/futex_mutex.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -4,8 +4,6 @@ use crate::sync::atomic::{\n };\n use crate::sys::futex::{futex_wait, futex_wake};\n \n-pub type MovableMutex = Mutex;\n-\n pub struct Mutex {\n     /// 0: unlocked\n     /// 1: locked, no other threads waiting\n@@ -20,12 +18,12 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n+    pub fn try_lock(&self) -> bool {\n         self.futex.compare_exchange(0, 1, Acquire, Relaxed).is_ok()\n     }\n \n     #[inline]\n-    pub unsafe fn lock(&self) {\n+    pub fn lock(&self) {\n         if self.futex.compare_exchange(0, 1, Acquire, Relaxed).is_err() {\n             self.lock_contended();\n         }"}, {"sha": "aa0de900238f5466bb664ada645da0b066982779", "filename": "library/std/src/sys/unix/locks/futex_rwlock.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -4,8 +4,6 @@ use crate::sync::atomic::{\n };\n use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n \n-pub type MovableRwLock = RwLock;\n-\n pub struct RwLock {\n     // The state consists of a 30-bit reader counter, a 'readers waiting' flag, and a 'writers waiting' flag.\n     // Bits 0..30:\n@@ -70,14 +68,14 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n+    pub fn try_read(&self) -> bool {\n         self.state\n             .fetch_update(Acquire, Relaxed, |s| is_read_lockable(s).then(|| s + READ_LOCKED))\n             .is_ok()\n     }\n \n     #[inline]\n-    pub unsafe fn read(&self) {\n+    pub fn read(&self) {\n         let state = self.state.load(Relaxed);\n         if !is_read_lockable(state)\n             || self\n@@ -144,14 +142,14 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n+    pub fn try_write(&self) -> bool {\n         self.state\n             .fetch_update(Acquire, Relaxed, |s| is_unlocked(s).then(|| s + WRITE_LOCKED))\n             .is_ok()\n     }\n \n     #[inline]\n-    pub unsafe fn write(&self) {\n+    pub fn write(&self) {\n         if self.state.compare_exchange_weak(0, WRITE_LOCKED, Acquire, Relaxed).is_err() {\n             self.write_contended();\n         }"}, {"sha": "b2e0e49ad736d6e00a3e394d998d9c6a8e59e547", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -10,22 +10,22 @@ cfg_if::cfg_if! {\n         mod futex_mutex;\n         mod futex_rwlock;\n         mod futex_condvar;\n-        pub(crate) use futex_mutex::{Mutex, MovableMutex};\n-        pub(crate) use futex_rwlock::MovableRwLock;\n-        pub(crate) use futex_condvar::MovableCondvar;\n+        pub(crate) use futex_mutex::Mutex;\n+        pub(crate) use futex_rwlock::RwLock;\n+        pub(crate) use futex_condvar::Condvar;\n     } else if #[cfg(target_os = \"fuchsia\")] {\n         mod fuchsia_mutex;\n         mod futex_rwlock;\n         mod futex_condvar;\n-        pub(crate) use fuchsia_mutex::{Mutex, MovableMutex};\n-        pub(crate) use futex_rwlock::MovableRwLock;\n-        pub(crate) use futex_condvar::MovableCondvar;\n+        pub(crate) use fuchsia_mutex::Mutex;\n+        pub(crate) use futex_rwlock::RwLock;\n+        pub(crate) use futex_condvar::Condvar;\n     } else {\n         mod pthread_mutex;\n         mod pthread_rwlock;\n         mod pthread_condvar;\n-        pub(crate) use pthread_mutex::{Mutex, MovableMutex};\n-        pub(crate) use pthread_rwlock::MovableRwLock;\n-        pub(crate) use pthread_condvar::MovableCondvar;\n+        pub(crate) use pthread_mutex::Mutex;\n+        pub(crate) use pthread_rwlock::RwLock;\n+        pub(crate) use pthread_condvar::Condvar;\n     }\n }"}, {"sha": "1ddb09905db2cfa0f3002535eb8729c3400310b9", "filename": "library/std/src/sys/unix/locks/pthread_condvar.rs", "status": "modified", "additions": 91, "deletions": 88, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -1,99 +1,122 @@\n use crate::cell::UnsafeCell;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicPtr, Ordering::Relaxed};\n use crate::sys::locks::{pthread_mutex, Mutex};\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n use crate::time::Duration;\n \n+struct AllocatedCondvar(UnsafeCell<libc::pthread_cond_t>);\n+\n pub struct Condvar {\n-    inner: UnsafeCell<libc::pthread_cond_t>,\n+    inner: LazyBox<AllocatedCondvar>,\n+    mutex: AtomicPtr<libc::pthread_mutex_t>,\n }\n \n-pub(crate) type MovableCondvar = LazyBox<Condvar>;\n-\n-unsafe impl Send for Condvar {}\n-unsafe impl Sync for Condvar {}\n-\n const TIMESPEC_MAX: libc::timespec =\n     libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n \n fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n     if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n }\n \n-impl LazyInit for Condvar {\n+#[inline]\n+fn raw(c: &Condvar) -> *mut libc::pthread_cond_t {\n+    c.inner.0.get()\n+}\n+\n+unsafe impl Send for AllocatedCondvar {}\n+unsafe impl Sync for AllocatedCondvar {}\n+\n+impl LazyInit for AllocatedCondvar {\n     fn init() -> Box<Self> {\n-        let mut condvar = Box::new(Self::new());\n-        unsafe { condvar.init() };\n+        let condvar = Box::new(AllocatedCondvar(UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER)));\n+\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(\n+                target_os = \"macos\",\n+                target_os = \"ios\",\n+                target_os = \"watchos\",\n+                target_os = \"l4re\",\n+                target_os = \"android\",\n+                target_os = \"redox\"\n+            ))] {\n+                // `pthread_condattr_setclock` is unfortunately not supported on these platforms.\n+            } else if #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))] {\n+                // NOTE: ESP-IDF's PTHREAD_COND_INITIALIZER support is not released yet\n+                // So on that platform, init() should always be called\n+                // Moreover, that platform does not have pthread_condattr_setclock support,\n+                // hence that initialization should be skipped as well\n+                //\n+                // Similar story for the 3DS (horizon).\n+                let r = unsafe { libc::pthread_cond_init(condvar.0.get(), crate::ptr::null()) };\n+                assert_eq!(r, 0);\n+            } else {\n+                use crate::mem::MaybeUninit;\n+                let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n+                let r = unsafe { libc::pthread_condattr_init(attr.as_mut_ptr()) };\n+                assert_eq!(r, 0);\n+                let r = unsafe { libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC) };\n+                assert_eq!(r, 0);\n+                let r = unsafe { libc::pthread_cond_init(condvar.0.get(), attr.as_ptr()) };\n+                assert_eq!(r, 0);\n+                let r = unsafe { libc::pthread_condattr_destroy(attr.as_mut_ptr()) };\n+                assert_eq!(r, 0);\n+            }\n+        }\n+\n         condvar\n     }\n }\n \n-impl Condvar {\n-    pub const fn new() -> Condvar {\n-        // Might be moved and address is changing it is better to avoid\n-        // initialization of potentially opaque OS data before it landed\n-        Condvar { inner: UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER) }\n+impl Drop for AllocatedCondvar {\n+    #[inline]\n+    fn drop(&mut self) {\n+        let r = unsafe { libc::pthread_cond_destroy(self.0.get()) };\n+        if cfg!(target_os = \"dragonfly\") {\n+            // On DragonFly pthread_cond_destroy() returns EINVAL if called on\n+            // a condvar that was just initialized with\n+            // libc::PTHREAD_COND_INITIALIZER. Once it is used or\n+            // pthread_cond_init() is called, this behaviour no longer occurs.\n+            debug_assert!(r == 0 || r == libc::EINVAL);\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n     }\n+}\n \n-    #[cfg(any(\n-        target_os = \"macos\",\n-        target_os = \"ios\",\n-        target_os = \"watchos\",\n-        target_os = \"l4re\",\n-        target_os = \"android\",\n-        target_os = \"redox\"\n-    ))]\n-    unsafe fn init(&mut self) {}\n-\n-    // NOTE: ESP-IDF's PTHREAD_COND_INITIALIZER support is not released yet\n-    // So on that platform, init() should always be called\n-    // Moreover, that platform does not have pthread_condattr_setclock support,\n-    // hence that initialization should be skipped as well\n-    //\n-    // Similar story for the 3DS (horizon).\n-    #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))]\n-    unsafe fn init(&mut self) {\n-        let r = libc::pthread_cond_init(self.inner.get(), crate::ptr::null());\n-        assert_eq!(r, 0);\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar { inner: LazyBox::new(), mutex: AtomicPtr::new(ptr::null_mut()) }\n     }\n \n-    #[cfg(not(any(\n-        target_os = \"macos\",\n-        target_os = \"ios\",\n-        target_os = \"watchos\",\n-        target_os = \"l4re\",\n-        target_os = \"android\",\n-        target_os = \"redox\",\n-        target_os = \"espidf\",\n-        target_os = \"horizon\"\n-    )))]\n-    unsafe fn init(&mut self) {\n-        use crate::mem::MaybeUninit;\n-        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n-        let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_cond_init(self.inner.get(), attr.as_ptr());\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n-        assert_eq!(r, 0);\n+    #[inline]\n+    fn verify(&self, mutex: *mut libc::pthread_mutex_t) {\n+        // Relaxed is okay here because we never read through `self.addr`, and only use it to\n+        // compare addresses.\n+        match self.mutex.compare_exchange(ptr::null_mut(), mutex, Relaxed, Relaxed) {\n+            Ok(_) => {}                // Stored the address\n+            Err(n) if n == mutex => {} // Lost a race to store the same address\n+            _ => panic!(\"attempted to use a condition variable with two mutexes\"),\n+        }\n     }\n \n     #[inline]\n-    pub unsafe fn notify_one(&self) {\n-        let r = libc::pthread_cond_signal(self.inner.get());\n+    pub fn notify_one(&self) {\n+        let r = unsafe { libc::pthread_cond_signal(raw(self)) };\n         debug_assert_eq!(r, 0);\n     }\n \n     #[inline]\n-    pub unsafe fn notify_all(&self) {\n-        let r = libc::pthread_cond_broadcast(self.inner.get());\n+    pub fn notify_all(&self) {\n+        let r = unsafe { libc::pthread_cond_broadcast(raw(self)) };\n         debug_assert_eq!(r, 0);\n     }\n \n     #[inline]\n     pub unsafe fn wait(&self, mutex: &Mutex) {\n-        let r = libc::pthread_cond_wait(self.inner.get(), pthread_mutex::raw(mutex));\n+        let mutex = pthread_mutex::raw(mutex);\n+        self.verify(mutex);\n+        let r = libc::pthread_cond_wait(raw(self), mutex);\n         debug_assert_eq!(r, 0);\n     }\n \n@@ -112,6 +135,9 @@ impl Condvar {\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         use crate::mem;\n \n+        let mutex = pthread_mutex::raw(mutex);\n+        self.verify(mutex);\n+\n         let mut now: libc::timespec = mem::zeroed();\n         let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n         assert_eq!(r, 0);\n@@ -127,7 +153,7 @@ impl Condvar {\n         let timeout =\n             sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n \n-        let r = libc::pthread_cond_timedwait(self.inner.get(), pthread_mutex::raw(mutex), &timeout);\n+        let r = libc::pthread_cond_timedwait(raw(self), mutex, &timeout);\n         assert!(r == libc::ETIMEDOUT || r == 0);\n         r == 0\n     }\n@@ -144,9 +170,11 @@ impl Condvar {\n         target_os = \"horizon\"\n     ))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n-        use crate::ptr;\n         use crate::time::Instant;\n \n+        let mutex = pthread_mutex::raw(mutex);\n+        self.verify(mutex);\n+\n         // 1000 years\n         let max_dur = Duration::from_secs(1000 * 365 * 86400);\n \n@@ -187,36 +215,11 @@ impl Condvar {\n             .unwrap_or(TIMESPEC_MAX);\n \n         // And wait!\n-        let r = libc::pthread_cond_timedwait(self.inner.get(), pthread_mutex::raw(mutex), &timeout);\n+        let r = libc::pthread_cond_timedwait(raw(self), mutex, &timeout);\n         debug_assert!(r == libc::ETIMEDOUT || r == 0);\n \n         // ETIMEDOUT is not a totally reliable method of determining timeout due\n         // to clock shifts, so do the check ourselves\n         stable_now.elapsed() < dur\n     }\n-\n-    #[inline]\n-    #[cfg(not(target_os = \"dragonfly\"))]\n-    unsafe fn destroy(&mut self) {\n-        let r = libc::pthread_cond_destroy(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    #[cfg(target_os = \"dragonfly\")]\n-    unsafe fn destroy(&mut self) {\n-        let r = libc::pthread_cond_destroy(self.inner.get());\n-        // On DragonFly pthread_cond_destroy() returns EINVAL if called on\n-        // a condvar that was just initialized with\n-        // libc::PTHREAD_COND_INITIALIZER. Once it is used or\n-        // pthread_cond_init() is called, this behaviour no longer occurs.\n-        debug_assert!(r == 0 || r == libc::EINVAL);\n-    }\n-}\n-\n-impl Drop for Condvar {\n-    #[inline]\n-    fn drop(&mut self) {\n-        unsafe { self.destroy() };\n-    }\n }"}, {"sha": "a1155a808aaf461e4e5b2814e88276f402eae146", "filename": "library/std/src/sys/unix/locks/pthread_mutex.rs", "status": "modified", "additions": 65, "deletions": 69, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -3,56 +3,24 @@ use crate::mem::{forget, MaybeUninit};\n use crate::sys::cvt_nz;\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n \n+struct AllocatedMutex(UnsafeCell<libc::pthread_mutex_t>);\n+\n pub struct Mutex {\n-    inner: UnsafeCell<libc::pthread_mutex_t>,\n+    inner: LazyBox<AllocatedMutex>,\n }\n \n-pub(crate) type MovableMutex = LazyBox<Mutex>;\n-\n #[inline]\n pub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n-    m.inner.get()\n+    m.inner.0.get()\n }\n \n-unsafe impl Send for Mutex {}\n-unsafe impl Sync for Mutex {}\n+unsafe impl Send for AllocatedMutex {}\n+unsafe impl Sync for AllocatedMutex {}\n \n-impl LazyInit for Mutex {\n+impl LazyInit for AllocatedMutex {\n     fn init() -> Box<Self> {\n-        let mut mutex = Box::new(Self::new());\n-        unsafe { mutex.init() };\n-        mutex\n-    }\n-\n-    fn destroy(mutex: Box<Self>) {\n-        // We're not allowed to pthread_mutex_destroy a locked mutex,\n-        // so check first if it's unlocked.\n-        if unsafe { mutex.try_lock() } {\n-            unsafe { mutex.unlock() };\n-            drop(mutex);\n-        } else {\n-            // The mutex is locked. This happens if a MutexGuard is leaked.\n-            // In this case, we just leak the Mutex too.\n-            forget(mutex);\n-        }\n-    }\n-\n-    fn cancel_init(_: Box<Self>) {\n-        // In this case, we can just drop it without any checks,\n-        // since it cannot have been locked yet.\n-    }\n-}\n+        let mutex = Box::new(AllocatedMutex(UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER)));\n \n-impl Mutex {\n-    pub const fn new() -> Mutex {\n-        // Might be moved to a different address, so it is better to avoid\n-        // initialization of potentially opaque OS data before it landed.\n-        // Be very careful using this newly constructed `Mutex`, reentrant\n-        // locking is undefined behavior until `init` is called!\n-        Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n-    }\n-    #[inline]\n-    unsafe fn init(&mut self) {\n         // Issue #33770\n         //\n         // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n@@ -77,49 +45,77 @@ impl Mutex {\n         // references, we instead create the mutex with type\n         // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n         // re-lock it from the same thread, thus avoiding undefined behavior.\n-        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n-        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n-        let attr = PthreadMutexAttr(&mut attr);\n-        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL))\n+        unsafe {\n+            let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+            cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n+            let attr = PthreadMutexAttr(&mut attr);\n+            cvt_nz(libc::pthread_mutexattr_settype(\n+                attr.0.as_mut_ptr(),\n+                libc::PTHREAD_MUTEX_NORMAL,\n+            ))\n             .unwrap();\n-        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();\n+            cvt_nz(libc::pthread_mutex_init(mutex.0.get(), attr.0.as_ptr())).unwrap();\n+        }\n+\n+        mutex\n     }\n-    #[inline]\n-    pub unsafe fn lock(&self) {\n-        let r = libc::pthread_mutex_lock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n+\n+    fn destroy(mutex: Box<Self>) {\n+        // We're not allowed to pthread_mutex_destroy a locked mutex,\n+        // so check first if it's unlocked.\n+        if unsafe { libc::pthread_mutex_trylock(mutex.0.get()) == 0 } {\n+            unsafe { libc::pthread_mutex_destroy(mutex.0.get()) };\n+            drop(mutex);\n+        } else {\n+            // The mutex is locked. This happens if a MutexGuard is leaked.\n+            // In this case, we just leak the Mutex too.\n+            forget(mutex);\n+        }\n     }\n+\n+    fn cancel_init(_: Box<Self>) {\n+        // In this case, we can just drop it without any checks,\n+        // since it cannot have been locked yet.\n+    }\n+}\n+\n+impl Drop for AllocatedMutex {\n     #[inline]\n-    pub unsafe fn unlock(&self) {\n-        let r = libc::pthread_mutex_unlock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n+    fn drop(&mut self) {\n+        let r = unsafe { libc::pthread_mutex_destroy(self.0.get()) };\n+        if cfg!(target_os = \"dragonfly\") {\n+            // On DragonFly pthread_mutex_destroy() returns EINVAL if called on a\n+            // mutex that was just initialized with libc::PTHREAD_MUTEX_INITIALIZER.\n+            // Once it is used (locked/unlocked) or pthread_mutex_init() is called,\n+            // this behaviour no longer occurs.\n+            debug_assert!(r == 0 || r == libc::EINVAL);\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n     }\n+}\n+\n+impl Mutex {\n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        libc::pthread_mutex_trylock(self.inner.get()) == 0\n+    pub const fn new() -> Mutex {\n+        Mutex { inner: LazyBox::new() }\n     }\n+\n     #[inline]\n-    #[cfg(not(target_os = \"dragonfly\"))]\n-    unsafe fn destroy(&mut self) {\n-        let r = libc::pthread_mutex_destroy(self.inner.get());\n+    pub unsafe fn lock(&self) {\n+        let r = libc::pthread_mutex_lock(raw(self));\n         debug_assert_eq!(r, 0);\n     }\n+\n     #[inline]\n-    #[cfg(target_os = \"dragonfly\")]\n-    unsafe fn destroy(&mut self) {\n-        let r = libc::pthread_mutex_destroy(self.inner.get());\n-        // On DragonFly pthread_mutex_destroy() returns EINVAL if called on a\n-        // mutex that was just initialized with libc::PTHREAD_MUTEX_INITIALIZER.\n-        // Once it is used (locked/unlocked) or pthread_mutex_init() is called,\n-        // this behaviour no longer occurs.\n-        debug_assert!(r == 0 || r == libc::EINVAL);\n+    pub unsafe fn unlock(&self) {\n+        let r = libc::pthread_mutex_unlock(raw(self));\n+        debug_assert_eq!(r, 0);\n     }\n-}\n \n-impl Drop for Mutex {\n     #[inline]\n-    fn drop(&mut self) {\n-        unsafe { self.destroy() };\n+    pub unsafe fn try_lock(&self) -> bool {\n+        libc::pthread_mutex_trylock(raw(self)) == 0\n     }\n }\n "}, {"sha": "04662be9d8275e514d61cf7126e17bfdda1a9b20", "filename": "library/std/src/sys/unix/locks/pthread_rwlock.rs", "status": "modified", "additions": 85, "deletions": 63, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_rwlock.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -3,20 +3,26 @@ use crate::mem::forget;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n \n-pub struct RwLock {\n+struct AllocatedRwLock {\n     inner: UnsafeCell<libc::pthread_rwlock_t>,\n     write_locked: UnsafeCell<bool>, // guarded by the `inner` RwLock\n     num_readers: AtomicUsize,\n }\n \n-pub(crate) type MovableRwLock = LazyBox<RwLock>;\n+unsafe impl Send for AllocatedRwLock {}\n+unsafe impl Sync for AllocatedRwLock {}\n \n-unsafe impl Send for RwLock {}\n-unsafe impl Sync for RwLock {}\n+pub struct RwLock {\n+    inner: LazyBox<AllocatedRwLock>,\n+}\n \n-impl LazyInit for RwLock {\n+impl LazyInit for AllocatedRwLock {\n     fn init() -> Box<Self> {\n-        Box::new(Self::new())\n+        Box::new(AllocatedRwLock {\n+            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n+            write_locked: UnsafeCell::new(false),\n+            num_readers: AtomicUsize::new(0),\n+        })\n     }\n \n     fn destroy(mut rwlock: Box<Self>) {\n@@ -35,17 +41,39 @@ impl LazyInit for RwLock {\n     }\n }\n \n+impl AllocatedRwLock {\n+    #[inline]\n+    unsafe fn raw_unlock(&self) {\n+        let r = libc::pthread_rwlock_unlock(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+}\n+\n+impl Drop for AllocatedRwLock {\n+    fn drop(&mut self) {\n+        let r = unsafe { libc::pthread_rwlock_destroy(self.inner.get()) };\n+        // On DragonFly pthread_rwlock_destroy() returns EINVAL if called on a\n+        // rwlock that was just initialized with\n+        // libc::PTHREAD_RWLOCK_INITIALIZER. Once it is used (locked/unlocked)\n+        // or pthread_rwlock_init() is called, this behaviour no longer occurs.\n+        if cfg!(target_os = \"dragonfly\") {\n+            debug_assert!(r == 0 || r == libc::EINVAL);\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n+    }\n+}\n+\n impl RwLock {\n+    #[inline]\n     pub const fn new() -> RwLock {\n-        RwLock {\n-            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n-            write_locked: UnsafeCell::new(false),\n-            num_readers: AtomicUsize::new(0),\n-        }\n+        RwLock { inner: LazyBox::new() }\n     }\n+\n     #[inline]\n-    pub unsafe fn read(&self) {\n-        let r = libc::pthread_rwlock_rdlock(self.inner.get());\n+    pub fn read(&self) {\n+        let lock = &*self.inner;\n+        let r = unsafe { libc::pthread_rwlock_rdlock(lock.inner.get()) };\n \n         // According to POSIX, when a thread tries to acquire this read lock\n         // while it already holds the write lock\n@@ -62,112 +90,106 @@ impl RwLock {\n         // got the write lock more than once, or got a read and a write lock.\n         if r == libc::EAGAIN {\n             panic!(\"rwlock maximum reader count exceeded\");\n-        } else if r == libc::EDEADLK || (r == 0 && *self.write_locked.get()) {\n+        } else if r == libc::EDEADLK || (r == 0 && unsafe { *lock.write_locked.get() }) {\n             // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n             // data races.\n             if r == 0 {\n                 // `pthread_rwlock_rdlock` succeeded when it should not have.\n-                self.raw_unlock();\n+                unsafe {\n+                    lock.raw_unlock();\n+                }\n             }\n             panic!(\"rwlock read lock would result in deadlock\");\n         } else {\n             // POSIX does not make guarantees about all the errors that may be returned.\n             // See issue #94705 for more details.\n             assert_eq!(r, 0, \"unexpected error during rwlock read lock: {:?}\", r);\n-            self.num_readers.fetch_add(1, Ordering::Relaxed);\n+            lock.num_readers.fetch_add(1, Ordering::Relaxed);\n         }\n     }\n+\n     #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n-        let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n+    pub fn try_read(&self) -> bool {\n+        let lock = &*self.inner;\n+        let r = unsafe { libc::pthread_rwlock_tryrdlock(lock.inner.get()) };\n         if r == 0 {\n-            if *self.write_locked.get() {\n+            if unsafe { *lock.write_locked.get() } {\n                 // `pthread_rwlock_tryrdlock` succeeded when it should not have.\n-                self.raw_unlock();\n+                unsafe {\n+                    lock.raw_unlock();\n+                }\n                 false\n             } else {\n-                self.num_readers.fetch_add(1, Ordering::Relaxed);\n+                lock.num_readers.fetch_add(1, Ordering::Relaxed);\n                 true\n             }\n         } else {\n             false\n         }\n     }\n+\n     #[inline]\n-    pub unsafe fn write(&self) {\n-        let r = libc::pthread_rwlock_wrlock(self.inner.get());\n+    pub fn write(&self) {\n+        let lock = &*self.inner;\n+        let r = unsafe { libc::pthread_rwlock_wrlock(lock.inner.get()) };\n         // See comments above for why we check for EDEADLK and write_locked. For the same reason,\n         // we also need to check that there are no readers (tracked in `num_readers`).\n         if r == libc::EDEADLK\n-            || (r == 0 && *self.write_locked.get())\n-            || self.num_readers.load(Ordering::Relaxed) != 0\n+            || (r == 0 && unsafe { *lock.write_locked.get() })\n+            || lock.num_readers.load(Ordering::Relaxed) != 0\n         {\n             // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n             // data races.\n             if r == 0 {\n                 // `pthread_rwlock_wrlock` succeeded when it should not have.\n-                self.raw_unlock();\n+                unsafe {\n+                    lock.raw_unlock();\n+                }\n             }\n             panic!(\"rwlock write lock would result in deadlock\");\n         } else {\n             // According to POSIX, for a properly initialized rwlock this can only\n             // return EDEADLK or 0. We rely on that.\n             debug_assert_eq!(r, 0);\n         }\n-        *self.write_locked.get() = true;\n+\n+        unsafe {\n+            *lock.write_locked.get() = true;\n+        }\n     }\n+\n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n+        let lock = &*self.inner;\n+        let r = libc::pthread_rwlock_trywrlock(lock.inner.get());\n         if r == 0 {\n-            if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n+            if *lock.write_locked.get() || lock.num_readers.load(Ordering::Relaxed) != 0 {\n                 // `pthread_rwlock_trywrlock` succeeded when it should not have.\n-                self.raw_unlock();\n+                lock.raw_unlock();\n                 false\n             } else {\n-                *self.write_locked.get() = true;\n+                *lock.write_locked.get() = true;\n                 true\n             }\n         } else {\n             false\n         }\n     }\n-    #[inline]\n-    unsafe fn raw_unlock(&self) {\n-        let r = libc::pthread_rwlock_unlock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n+\n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        debug_assert!(!*self.write_locked.get());\n-        self.num_readers.fetch_sub(1, Ordering::Relaxed);\n-        self.raw_unlock();\n-    }\n-    #[inline]\n-    pub unsafe fn write_unlock(&self) {\n-        debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n-        debug_assert!(*self.write_locked.get());\n-        *self.write_locked.get() = false;\n-        self.raw_unlock();\n+        let lock = &*self.inner;\n+        debug_assert!(!*lock.write_locked.get());\n+        lock.num_readers.fetch_sub(1, Ordering::Relaxed);\n+        lock.raw_unlock();\n     }\n-    #[inline]\n-    unsafe fn destroy(&mut self) {\n-        let r = libc::pthread_rwlock_destroy(self.inner.get());\n-        // On DragonFly pthread_rwlock_destroy() returns EINVAL if called on a\n-        // rwlock that was just initialized with\n-        // libc::PTHREAD_RWLOCK_INITIALIZER. Once it is used (locked/unlocked)\n-        // or pthread_rwlock_init() is called, this behaviour no longer occurs.\n-        if cfg!(target_os = \"dragonfly\") {\n-            debug_assert!(r == 0 || r == libc::EINVAL);\n-        } else {\n-            debug_assert_eq!(r, 0);\n-        }\n-    }\n-}\n \n-impl Drop for RwLock {\n     #[inline]\n-    fn drop(&mut self) {\n-        unsafe { self.destroy() };\n+    pub unsafe fn write_unlock(&self) {\n+        let lock = &*self.inner;\n+        debug_assert_eq!(lock.num_readers.load(Ordering::Relaxed), 0);\n+        debug_assert!(*lock.write_locked.get());\n+        *lock.write_locked.get() = false;\n+        lock.raw_unlock();\n     }\n }"}, {"sha": "3f0943b50ee4d98160947d7f85baa6f9a449c73f", "filename": "library/std/src/sys/unsupported/locks/condvar.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fcondvar.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -3,8 +3,6 @@ use crate::time::Duration;\n \n pub struct Condvar {}\n \n-pub type MovableCondvar = Condvar;\n-\n impl Condvar {\n     #[inline]\n     #[rustc_const_stable(feature = \"const_locks\", since = \"1.63.0\")]\n@@ -13,10 +11,10 @@ impl Condvar {\n     }\n \n     #[inline]\n-    pub unsafe fn notify_one(&self) {}\n+    pub fn notify_one(&self) {}\n \n     #[inline]\n-    pub unsafe fn notify_all(&self) {}\n+    pub fn notify_all(&self) {}\n \n     pub unsafe fn wait(&self, _mutex: &Mutex) {\n         panic!(\"condvar wait not supported\")"}, {"sha": "0e0f9eccb213704b10f8766eaa434c1b82d49eb5", "filename": "library/std/src/sys/unsupported/locks/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmod.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -1,6 +1,6 @@\n mod condvar;\n mod mutex;\n mod rwlock;\n-pub use condvar::{Condvar, MovableCondvar};\n-pub use mutex::{MovableMutex, Mutex};\n-pub use rwlock::MovableRwLock;\n+pub use condvar::Condvar;\n+pub use mutex::Mutex;\n+pub use rwlock::RwLock;"}, {"sha": "4a13c55fb8bec01e47ec413bbc2f1f8af97ddbd9", "filename": "library/std/src/sys/unsupported/locks/mutex.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -5,8 +5,6 @@ pub struct Mutex {\n     locked: Cell<bool>,\n }\n \n-pub type MovableMutex = Mutex;\n-\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {} // no threads on this platform\n \n@@ -18,7 +16,7 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn lock(&self) {\n+    pub fn lock(&self) {\n         assert_eq!(self.locked.replace(true), false, \"cannot recursively acquire mutex\");\n     }\n \n@@ -28,7 +26,7 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n+    pub fn try_lock(&self) -> bool {\n         self.locked.replace(true) == false\n     }\n }"}, {"sha": "789ef9b29e52a3dc55a9c809dfc294db78530c32", "filename": "library/std/src/sys/unsupported/locks/rwlock.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Frwlock.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -5,8 +5,6 @@ pub struct RwLock {\n     mode: Cell<isize>,\n }\n \n-pub type MovableRwLock = RwLock;\n-\n unsafe impl Send for RwLock {}\n unsafe impl Sync for RwLock {} // no threads on this platform\n \n@@ -18,7 +16,7 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn read(&self) {\n+    pub fn read(&self) {\n         let m = self.mode.get();\n         if m >= 0 {\n             self.mode.set(m + 1);\n@@ -28,7 +26,7 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n+    pub fn try_read(&self) -> bool {\n         let m = self.mode.get();\n         if m >= 0 {\n             self.mode.set(m + 1);\n@@ -39,14 +37,14 @@ impl RwLock {\n     }\n \n     #[inline]\n-    pub unsafe fn write(&self) {\n+    pub fn write(&self) {\n         if self.mode.replace(-1) != 0 {\n             rtabort!(\"rwlock locked for reading\")\n         }\n     }\n \n     #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n+    pub fn try_write(&self) -> bool {\n         if self.mode.get() == 0 {\n             self.mode.set(-1);\n             true"}, {"sha": "d68c3e5f1dfbfaf281d0139c40bc2d337672b661", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -55,9 +55,9 @@ cfg_if::cfg_if! {\n             mod futex_condvar;\n             mod futex_mutex;\n             mod futex_rwlock;\n-            pub(crate) use futex_condvar::{Condvar, MovableCondvar};\n-            pub(crate) use futex_mutex::{Mutex, MovableMutex};\n-            pub(crate) use futex_rwlock::MovableRwLock;\n+            pub(crate) use futex_condvar::Condvar;\n+            pub(crate) use futex_mutex::Mutex;\n+            pub(crate) use futex_rwlock::RwLock;\n         }\n         #[path = \"atomics/futex.rs\"]\n         pub mod futex;"}, {"sha": "66fafa2c00b00fdc50ba41a7fe58d8465427c9bc", "filename": "library/std/src/sys/windows/locks/condvar.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fcondvar.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -8,8 +8,6 @@ pub struct Condvar {\n     inner: UnsafeCell<c::CONDITION_VARIABLE>,\n }\n \n-pub type MovableCondvar = Condvar;\n-\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n@@ -41,12 +39,12 @@ impl Condvar {\n     }\n \n     #[inline]\n-    pub unsafe fn notify_one(&self) {\n-        c::WakeConditionVariable(self.inner.get())\n+    pub fn notify_one(&self) {\n+        unsafe { c::WakeConditionVariable(self.inner.get()) }\n     }\n \n     #[inline]\n-    pub unsafe fn notify_all(&self) {\n-        c::WakeAllConditionVariable(self.inner.get())\n+    pub fn notify_all(&self) {\n+        unsafe { c::WakeAllConditionVariable(self.inner.get()) }\n     }\n }"}, {"sha": "0e0f9eccb213704b10f8766eaa434c1b82d49eb5", "filename": "library/std/src/sys/windows/locks/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmod.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -1,6 +1,6 @@\n mod condvar;\n mod mutex;\n mod rwlock;\n-pub use condvar::{Condvar, MovableCondvar};\n-pub use mutex::{MovableMutex, Mutex};\n-pub use rwlock::MovableRwLock;\n+pub use condvar::Condvar;\n+pub use mutex::Mutex;\n+pub use rwlock::RwLock;"}, {"sha": "ef2f84082cd5ce8da5d6d390947872c27b9a6dc9", "filename": "library/std/src/sys/windows/locks/mutex.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmutex.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -21,9 +21,6 @@ pub struct Mutex {\n     srwlock: UnsafeCell<c::SRWLOCK>,\n }\n \n-// Windows SRW Locks are movable (while not borrowed).\n-pub type MovableMutex = Mutex;\n-\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n@@ -39,13 +36,15 @@ impl Mutex {\n     }\n \n     #[inline]\n-    pub unsafe fn lock(&self) {\n-        c::AcquireSRWLockExclusive(raw(self));\n+    pub fn lock(&self) {\n+        unsafe {\n+            c::AcquireSRWLockExclusive(raw(self));\n+        }\n     }\n \n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        c::TryAcquireSRWLockExclusive(raw(self)) != 0\n+    pub fn try_lock(&self) -> bool {\n+        unsafe { c::TryAcquireSRWLockExclusive(raw(self)) != 0 }\n     }\n \n     #[inline]"}, {"sha": "e69415baac42be22578975b723854757fd173e29", "filename": "library/std/src/sys/windows/locks/rwlock.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Frwlock.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -5,8 +5,6 @@ pub struct RwLock {\n     inner: UnsafeCell<c::SRWLOCK>,\n }\n \n-pub type MovableRwLock = RwLock;\n-\n unsafe impl Send for RwLock {}\n unsafe impl Sync for RwLock {}\n \n@@ -16,20 +14,20 @@ impl RwLock {\n         RwLock { inner: UnsafeCell::new(c::SRWLOCK_INIT) }\n     }\n     #[inline]\n-    pub unsafe fn read(&self) {\n-        c::AcquireSRWLockShared(self.inner.get())\n+    pub fn read(&self) {\n+        unsafe { c::AcquireSRWLockShared(self.inner.get()) }\n     }\n     #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n-        c::TryAcquireSRWLockShared(self.inner.get()) != 0\n+    pub fn try_read(&self) -> bool {\n+        unsafe { c::TryAcquireSRWLockShared(self.inner.get()) != 0 }\n     }\n     #[inline]\n-    pub unsafe fn write(&self) {\n-        c::AcquireSRWLockExclusive(self.inner.get())\n+    pub fn write(&self) {\n+        unsafe { c::AcquireSRWLockExclusive(self.inner.get()) }\n     }\n     #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n-        c::TryAcquireSRWLockExclusive(self.inner.get()) != 0\n+    pub fn try_write(&self) -> bool {\n+        unsafe { c::TryAcquireSRWLockExclusive(self.inner.get()) != 0 }\n     }\n     #[inline]\n     pub unsafe fn read_unlock(&self) {"}, {"sha": "8bc5b24115d1686b767dce76c9356c0ed24b2354", "filename": "library/std/src/sys_common/condvar.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/534ddc6166a9031b0c269544929d68f2539ea7a0/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534ddc6166a9031b0c269544929d68f2539ea7a0/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs?ref=534ddc6166a9031b0c269544929d68f2539ea7a0", "patch": "@@ -1,57 +0,0 @@\n-use crate::sys::locks as imp;\n-use crate::sys_common::mutex::MovableMutex;\n-use crate::time::Duration;\n-\n-mod check;\n-\n-type CondvarCheck = <imp::MovableMutex as check::CondvarCheck>::Check;\n-\n-/// An OS-based condition variable.\n-pub struct Condvar {\n-    inner: imp::MovableCondvar,\n-    check: CondvarCheck,\n-}\n-\n-impl Condvar {\n-    /// Creates a new condition variable for use.\n-    #[inline]\n-    #[rustc_const_stable(feature = \"const_locks\", since = \"1.63.0\")]\n-    pub const fn new() -> Self {\n-        Self { inner: imp::MovableCondvar::new(), check: CondvarCheck::new() }\n-    }\n-\n-    /// Signals one waiter on this condition variable to wake up.\n-    #[inline]\n-    pub fn notify_one(&self) {\n-        unsafe { self.inner.notify_one() };\n-    }\n-\n-    /// Awakens all current waiters on this condition variable.\n-    #[inline]\n-    pub fn notify_all(&self) {\n-        unsafe { self.inner.notify_all() };\n-    }\n-\n-    /// Waits for a signal on the specified mutex.\n-    ///\n-    /// Behavior is undefined if the mutex is not locked by the current thread.\n-    ///\n-    /// May panic if used with more than one mutex.\n-    #[inline]\n-    pub unsafe fn wait(&self, mutex: &MovableMutex) {\n-        self.check.verify(mutex);\n-        self.inner.wait(mutex.raw())\n-    }\n-\n-    /// Waits for a signal on the specified mutex with a timeout duration\n-    /// specified by `dur` (a relative time into the future).\n-    ///\n-    /// Behavior is undefined if the mutex is not locked by the current thread.\n-    ///\n-    /// May panic if used with more than one mutex.\n-    #[inline]\n-    pub unsafe fn wait_timeout(&self, mutex: &MovableMutex, dur: Duration) -> bool {\n-        self.check.verify(mutex);\n-        self.inner.wait_timeout(mutex.raw(), dur)\n-    }\n-}"}, {"sha": "4ac9e62bf869568e4995979cfbeb2b7db8d7c849", "filename": "library/std/src/sys_common/condvar/check.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/534ddc6166a9031b0c269544929d68f2539ea7a0/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534ddc6166a9031b0c269544929d68f2539ea7a0/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs?ref=534ddc6166a9031b0c269544929d68f2539ea7a0", "patch": "@@ -1,58 +0,0 @@\n-use crate::ptr;\n-use crate::sync::atomic::{AtomicPtr, Ordering};\n-use crate::sys::locks as imp;\n-use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n-use crate::sys_common::mutex::MovableMutex;\n-\n-pub trait CondvarCheck {\n-    type Check;\n-}\n-\n-/// For boxed mutexes, a `Condvar` will check it's only ever used with the same\n-/// mutex, based on its (stable) address.\n-impl<T: LazyInit> CondvarCheck for LazyBox<T> {\n-    type Check = SameMutexCheck;\n-}\n-\n-pub struct SameMutexCheck {\n-    addr: AtomicPtr<()>,\n-}\n-\n-#[allow(dead_code)]\n-impl SameMutexCheck {\n-    pub const fn new() -> Self {\n-        Self { addr: AtomicPtr::new(ptr::null_mut()) }\n-    }\n-    pub fn verify(&self, mutex: &MovableMutex) {\n-        let addr = mutex.raw() as *const imp::Mutex as *const () as *mut _;\n-        // Relaxed is okay here because we never read through `self.addr`, and only use it to\n-        // compare addresses.\n-        match self.addr.compare_exchange(\n-            ptr::null_mut(),\n-            addr,\n-            Ordering::Relaxed,\n-            Ordering::Relaxed,\n-        ) {\n-            Ok(_) => {}               // Stored the address\n-            Err(n) if n == addr => {} // Lost a race to store the same address\n-            _ => panic!(\"attempted to use a condition variable with two mutexes\"),\n-        }\n-    }\n-}\n-\n-/// Unboxed mutexes may move, so `Condvar` can not require its address to stay\n-/// constant.\n-impl CondvarCheck for imp::Mutex {\n-    type Check = NoCheck;\n-}\n-\n-pub struct NoCheck;\n-\n-#[allow(dead_code)]\n-impl NoCheck {\n-    #[rustc_const_stable(feature = \"const_locks\", since = \"1.63.0\")]\n-    pub const fn new() -> Self {\n-        Self\n-    }\n-    pub fn verify(&self, _: &MovableMutex) {}\n-}"}, {"sha": "069b13e9d85ea4b6fd5b6bdc7631d608e7f46f0f", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -21,16 +21,13 @@\n mod tests;\n \n pub mod backtrace;\n-pub mod condvar;\n pub mod fs;\n pub mod io;\n pub mod lazy_box;\n pub mod memchr;\n-pub mod mutex;\n pub mod once;\n pub mod process;\n pub mod remutex;\n-pub mod rwlock;\n pub mod thread;\n pub mod thread_info;\n pub mod thread_local_dtor;"}, {"sha": "98046f20f896a9e48c4e12b235520aeeaccc3049", "filename": "library/std/src/sys_common/mutex.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/534ddc6166a9031b0c269544929d68f2539ea7a0/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534ddc6166a9031b0c269544929d68f2539ea7a0/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs?ref=534ddc6166a9031b0c269544929d68f2539ea7a0", "patch": "@@ -1,50 +0,0 @@\n-use crate::sys::locks as imp;\n-\n-/// An OS-based mutual exclusion lock.\n-///\n-/// This mutex cleans up its resources in its `Drop` implementation, may safely\n-/// be moved (when not borrowed), and does not cause UB when used reentrantly.\n-///\n-/// This mutex does not implement poisoning.\n-///\n-/// This is either a wrapper around `LazyBox<imp::Mutex>` or `imp::Mutex`,\n-/// depending on the platform. It is boxed on platforms where `imp::Mutex` may\n-/// not be moved.\n-pub struct MovableMutex(imp::MovableMutex);\n-\n-unsafe impl Sync for MovableMutex {}\n-\n-impl MovableMutex {\n-    /// Creates a new mutex.\n-    #[inline]\n-    #[rustc_const_stable(feature = \"const_locks\", since = \"1.63.0\")]\n-    pub const fn new() -> Self {\n-        Self(imp::MovableMutex::new())\n-    }\n-\n-    pub(super) fn raw(&self) -> &imp::Mutex {\n-        &self.0\n-    }\n-\n-    /// Locks the mutex blocking the current thread until it is available.\n-    #[inline]\n-    pub fn raw_lock(&self) {\n-        unsafe { self.0.lock() }\n-    }\n-\n-    /// Attempts to lock the mutex without blocking, returning whether it was\n-    /// successfully acquired or not.\n-    #[inline]\n-    pub fn try_lock(&self) -> bool {\n-        unsafe { self.0.try_lock() }\n-    }\n-\n-    /// Unlocks the mutex.\n-    ///\n-    /// Behavior is undefined if the current thread does not actually hold the\n-    /// mutex.\n-    #[inline]\n-    pub unsafe fn raw_unlock(&self) {\n-        self.0.unlock()\n-    }\n-}"}, {"sha": "4c054da64714cf1ecd1fe9e136854dde7eb08c0d", "filename": "library/std/src/sys_common/remutex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98815742cf2e914ee0d7142a02322cf939c47834/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs?ref=98815742cf2e914ee0d7142a02322cf939c47834", "patch": "@@ -1,11 +1,11 @@\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n \n-use super::mutex as sys;\n use crate::cell::UnsafeCell;\n use crate::ops::Deref;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n use crate::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n+use crate::sys::locks as sys;\n \n /// A re-entrant mutual exclusion\n ///\n@@ -39,7 +39,7 @@ use crate::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n /// synchronization is left to the mutex, making relaxed memory ordering for\n /// the `owner` field fine in all cases.\n pub struct ReentrantMutex<T> {\n-    mutex: sys::MovableMutex,\n+    mutex: sys::Mutex,\n     owner: AtomicUsize,\n     lock_count: UnsafeCell<u32>,\n     data: T,\n@@ -74,7 +74,7 @@ impl<T> ReentrantMutex<T> {\n     /// Creates a new reentrant mutex in an unlocked state.\n     pub const fn new(t: T) -> ReentrantMutex<T> {\n         ReentrantMutex {\n-            mutex: sys::MovableMutex::new(),\n+            mutex: sys::Mutex::new(),\n             owner: AtomicUsize::new(0),\n             lock_count: UnsafeCell::new(0),\n             data: t,\n@@ -100,7 +100,7 @@ impl<T> ReentrantMutex<T> {\n             if self.owner.load(Relaxed) == this_thread {\n                 self.increment_lock_count();\n             } else {\n-                self.mutex.raw_lock();\n+                self.mutex.lock();\n                 self.owner.store(this_thread, Relaxed);\n                 debug_assert_eq!(*self.lock_count.get(), 0);\n                 *self.lock_count.get() = 1;\n@@ -162,7 +162,7 @@ impl<T> Drop for ReentrantMutexGuard<'_, T> {\n             *self.lock.lock_count.get() -= 1;\n             if *self.lock.lock_count.get() == 0 {\n                 self.lock.owner.store(0, Relaxed);\n-                self.lock.mutex.raw_unlock();\n+                self.lock.mutex.unlock();\n             }\n         }\n     }"}, {"sha": "042981dac60b4eb7028b1d3f546fafdc1902e0f2", "filename": "library/std/src/sys_common/rwlock.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/534ddc6166a9031b0c269544929d68f2539ea7a0/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534ddc6166a9031b0c269544929d68f2539ea7a0/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs?ref=534ddc6166a9031b0c269544929d68f2539ea7a0", "patch": "@@ -1,71 +0,0 @@\n-use crate::sys::locks as imp;\n-\n-/// An OS-based reader-writer lock.\n-///\n-/// This rwlock cleans up its resources in its `Drop` implementation and may\n-/// safely be moved (when not borrowed).\n-///\n-/// This rwlock does not implement poisoning.\n-///\n-/// This is either a wrapper around `LazyBox<imp::RwLock>` or `imp::RwLock`,\n-/// depending on the platform. It is boxed on platforms where `imp::RwLock` may\n-/// not be moved.\n-pub struct MovableRwLock(imp::MovableRwLock);\n-\n-impl MovableRwLock {\n-    /// Creates a new reader-writer lock for use.\n-    #[inline]\n-    #[rustc_const_stable(feature = \"const_locks\", since = \"1.63.0\")]\n-    pub const fn new() -> Self {\n-        Self(imp::MovableRwLock::new())\n-    }\n-\n-    /// Acquires shared access to the underlying lock, blocking the current\n-    /// thread to do so.\n-    #[inline]\n-    pub fn read(&self) {\n-        unsafe { self.0.read() }\n-    }\n-\n-    /// Attempts to acquire shared access to this lock, returning whether it\n-    /// succeeded or not.\n-    ///\n-    /// This function does not block the current thread.\n-    #[inline]\n-    pub fn try_read(&self) -> bool {\n-        unsafe { self.0.try_read() }\n-    }\n-\n-    /// Acquires write access to the underlying lock, blocking the current thread\n-    /// to do so.\n-    #[inline]\n-    pub fn write(&self) {\n-        unsafe { self.0.write() }\n-    }\n-\n-    /// Attempts to acquire exclusive access to this lock, returning whether it\n-    /// succeeded or not.\n-    ///\n-    /// This function does not block the current thread.\n-    #[inline]\n-    pub fn try_write(&self) -> bool {\n-        unsafe { self.0.try_write() }\n-    }\n-\n-    /// Unlocks previously acquired shared access to this lock.\n-    ///\n-    /// Behavior is undefined if the current thread does not have shared access.\n-    #[inline]\n-    pub unsafe fn read_unlock(&self) {\n-        self.0.read_unlock()\n-    }\n-\n-    /// Unlocks previously acquired exclusive access to this lock.\n-    ///\n-    /// Behavior is undefined if the current thread does not currently have\n-    /// exclusive access.\n-    #[inline]\n-    pub unsafe fn write_unlock(&self) {\n-        self.0.write_unlock()\n-    }\n-}"}]}