{"sha": "dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNzdjNWViZTgwZDhlOGZlMDhiOWJhMDU4NTljMDRmNGRiYjk5Y2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T05:45:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T05:45:35Z"}, "message": "Auto merge of #34032 - jseyfried:load_macros_in_expansion, r=nrc\n\nSupport `#[macro_use]` on macro-expanded crates\n\nThis PR loads macros from `#[macro_use]` crates during expansion so that\n - macro-expanded `#[macro_use]` crates work (fixes #33936, fixes #28071), and\n - macros imported from crates have the same scope as macros imported from modules.\n\nThis is a [breaking-change]. For example, this will break:\n```rust\nmacro_rules! m {\n    () => { #[macro_use(foo)] extern crate core; } //~ ERROR imported macro not found\n}\nm!();\n```\nAlso, this will break:\n```rust\nmacro_rules! try { () => {} }\n// #[macro_use] mod bar { macro_rules! try { ... } } //< ... just like this would ...\nfn main() { try!(); } //< ... making this an error\n```\n\nr? @nrc", "tree": {"sha": "af17b87c2f0a96ae5d184d750ddcb96e88fa095d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af17b87c2f0a96ae5d184d750ddcb96e88fa095d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "html_url": "https://github.com/rust-lang/rust/commit/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb4b3fb7f97924919f072ec9a360bdf943218dbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb4b3fb7f97924919f072ec9a360bdf943218dbf", "html_url": "https://github.com/rust-lang/rust/commit/bb4b3fb7f97924919f072ec9a360bdf943218dbf"}, {"sha": "dbf0326ddc041e772b5ab07b19e893e8955bf934", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf0326ddc041e772b5ab07b19e893e8955bf934", "html_url": "https://github.com/rust-lang/rust/commit/dbf0326ddc041e772b5ab07b19e893e8955bf934"}], "stats": {"total": 196, "additions": 99, "deletions": 97}, "files": [{"sha": "386496b071d901e986e0064bf1f832c11cdb6bb8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "patch": "@@ -604,10 +604,6 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n         syntax::std_inject::maybe_inject_crates_ref(krate, sess.opts.alt_std_name.clone())\n     });\n \n-    let macros = time(time_passes,\n-                      \"macro loading\",\n-                      || macro_import::read_macro_defs(sess, &cstore, &krate, crate_name));\n-\n     let mut addl_plugins = Some(addl_plugins);\n     let registrars = time(time_passes, \"plugin loading\", || {\n         plugin::load::load_plugins(sess,\n@@ -696,13 +692,14 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n             recursion_limit: sess.recursion_limit.get(),\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n         };\n+        let mut loader = macro_import::MacroLoader::new(sess, &cstore, crate_name);\n         let mut ecx = syntax::ext::base::ExtCtxt::new(&sess.parse_sess,\n                                                       krate.config.clone(),\n                                                       cfg,\n-                                                      &mut feature_gated_cfgs);\n+                                                      &mut feature_gated_cfgs,\n+                                                      &mut loader);\n         syntax_ext::register_builtins(&mut ecx.syntax_env);\n         let (ret, macro_names) = syntax::ext::expand::expand_crate(ecx,\n-                                                                   macros,\n                                                                    syntax_exts,\n                                                                    krate);\n         if cfg!(windows) {"}, {"sha": "1c7d37709c2205f0d4808ceffca00fdce951b07a", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 18, "deletions": 57, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "patch": "@@ -20,24 +20,19 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ast;\n use syntax::attr;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n use syntax::attr::AttrMetaMethods;\n+use syntax::ext;\n \n-struct MacroLoader<'a> {\n+pub struct MacroLoader<'a> {\n     sess: &'a Session,\n-    span_whitelist: HashSet<Span>,\n     reader: CrateReader<'a>,\n-    macros: Vec<ast::MacroDef>,\n }\n \n impl<'a> MacroLoader<'a> {\n-    fn new(sess: &'a Session, cstore: &'a CStore, crate_name: &str) -> MacroLoader<'a> {\n+    pub fn new(sess: &'a Session, cstore: &'a CStore, crate_name: &str) -> MacroLoader<'a> {\n         MacroLoader {\n             sess: sess,\n-            span_whitelist: HashSet::new(),\n             reader: CrateReader::new(sess, cstore, crate_name),\n-            macros: vec![],\n         }\n     }\n }\n@@ -46,48 +41,15 @@ pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n     span_err!(a, b, E0467, \"bad macro reexport\");\n }\n \n-/// Read exported macros.\n-pub fn read_macro_defs(sess: &Session,\n-                       cstore: &CStore,\n-                       krate: &ast::Crate,\n-                       crate_name: &str)\n-                       -> Vec<ast::MacroDef>\n-{\n-    let mut loader = MacroLoader::new(sess, cstore, crate_name);\n-\n-    // We need to error on `#[macro_use] extern crate` when it isn't at the\n-    // crate root, because `$crate` won't work properly. Identify these by\n-    // spans, because the crate map isn't set up yet.\n-    for item in &krate.module.items {\n-        if let ast::ItemKind::ExternCrate(_) = item.node {\n-            loader.span_whitelist.insert(item.span);\n-        }\n-    }\n-\n-    visit::walk_crate(&mut loader, krate);\n-\n-    loader.macros\n-}\n-\n pub type MacroSelection = HashMap<token::InternedString, Span>;\n \n-// note that macros aren't expanded yet, and therefore macros can't add macro imports.\n-impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        // We're only interested in `extern crate`.\n-        match item.node {\n-            ast::ItemKind::ExternCrate(_) => {}\n-            _ => {\n-                visit::walk_item(self, item);\n-                return;\n-            }\n-        }\n-\n+impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n+    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<ast::MacroDef> {\n         // Parse the attributes relating to macros.\n         let mut import = Some(HashMap::new());  // None => load all\n         let mut reexport = HashMap::new();\n \n-        for attr in &item.attrs {\n+        for attr in &extern_crate.attrs {\n             let mut used = true;\n             match &attr.name()[..] {\n                 \"macro_use\" => {\n@@ -130,36 +92,33 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n             }\n         }\n \n-        self.load_macros(item, import, reexport)\n-    }\n-\n-    fn visit_mac(&mut self, _: &ast::Mac) {\n-        // bummer... can't see macro imports inside macros.\n-        // do nothing.\n+        self.load_macros(extern_crate, allows_macros, import, reexport)\n     }\n }\n \n impl<'a> MacroLoader<'a> {\n     fn load_macros<'b>(&mut self,\n                        vi: &ast::Item,\n+                       allows_macros: bool,\n                        import: Option<MacroSelection>,\n-                       reexport: MacroSelection) {\n+                       reexport: MacroSelection)\n+                       -> Vec<ast::MacroDef> {\n         if let Some(sel) = import.as_ref() {\n             if sel.is_empty() && reexport.is_empty() {\n-                return;\n+                return Vec::new();\n             }\n         }\n \n-        if !self.span_whitelist.contains(&vi.span) {\n+        if !allows_macros {\n             span_err!(self.sess, vi.span, E0468,\n                       \"an `extern crate` loading macros must be at the crate root\");\n-            return;\n+            return Vec::new();\n         }\n \n-        let macros = self.reader.read_exported_macros(vi);\n+        let mut macros = Vec::new();\n         let mut seen = HashSet::new();\n \n-        for mut def in macros {\n+        for mut def in self.reader.read_exported_macros(vi) {\n             let name = def.ident.name.as_str();\n \n             def.use_locally = match import.as_ref() {\n@@ -170,7 +129,7 @@ impl<'a> MacroLoader<'a> {\n             def.allow_internal_unstable = attr::contains_name(&def.attrs,\n                                                               \"allow_internal_unstable\");\n             debug!(\"load_macros: loaded: {:?}\", def);\n-            self.macros.push(def);\n+            macros.push(def);\n             seen.insert(name);\n         }\n \n@@ -189,5 +148,7 @@ impl<'a> MacroLoader<'a> {\n                           \"reexported macro not found\");\n             }\n         }\n+\n+        macros\n     }\n }"}, {"sha": "95624a433730a96d3b931f62edd92334b0b014e2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "patch": "@@ -536,6 +536,17 @@ fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n     syntax_expanders\n }\n \n+pub trait MacroLoader {\n+    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<ast::MacroDef>;\n+}\n+\n+pub struct DummyMacroLoader;\n+impl MacroLoader for DummyMacroLoader {\n+    fn load_crate(&mut self, _: &ast::Item, _: bool) -> Vec<ast::MacroDef> {\n+        Vec::new()\n+    }\n+}\n+\n /// One of these is made during expansion and incrementally updated as we go;\n /// when a macro expansion occurs, the resulting nodes have the backtrace()\n /// -> expn_info of their expansion context stored into their span.\n@@ -546,6 +557,7 @@ pub struct ExtCtxt<'a> {\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n     pub feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>,\n+    pub loader: &'a mut MacroLoader,\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub exported_macros: Vec<ast::MacroDef>,\n@@ -561,7 +573,9 @@ pub struct ExtCtxt<'a> {\n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n                ecfg: expand::ExpansionConfig<'a>,\n-               feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>) -> ExtCtxt<'a> {\n+               feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>,\n+               loader: &'a mut MacroLoader)\n+               -> ExtCtxt<'a> {\n         let env = initial_syntax_expander_table(&ecfg);\n         ExtCtxt {\n             parse_sess: parse_sess,\n@@ -572,6 +586,7 @@ impl<'a> ExtCtxt<'a> {\n             crate_root: None,\n             feature_gated_cfgs: feature_gated_cfgs,\n             exported_macros: Vec::new(),\n+            loader: loader,\n             syntax_env: env,\n             recursion_count: 0,\n \n@@ -925,4 +940,10 @@ impl SyntaxEnv {\n         let last_chain_index = self.chain.len() - 1;\n         &mut self.chain[last_chain_index].info\n     }\n+\n+    pub fn is_crate_root(&mut self) -> bool {\n+        // The first frame is pushed in `SyntaxEnv::new()` and the second frame is\n+        // pushed when folding the crate root pseudo-module (c.f. noop_fold_crate).\n+        self.chain.len() == 2\n+    }\n }"}, {"sha": "15d192b59b81ea5cb8abce588abaeb4c93818f3d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "patch": "@@ -726,13 +726,11 @@ fn expand_annotatable(a: Annotatable,\n     let new_items: SmallVector<Annotatable> = match a {\n         Annotatable::Item(it) => match it.node {\n             ast::ItemKind::Mac(..) => {\n-                let new_items: SmallVector<P<ast::Item>> = it.and_then(|it| match it.node {\n+                it.and_then(|it| match it.node {\n                     ItemKind::Mac(mac) =>\n                         expand_mac_invoc(mac, Some(it.ident), it.attrs, it.span, fld),\n                     _ => unreachable!(),\n-                });\n-\n-                new_items.into_iter().map(|i| Annotatable::Item(i)).collect()\n+                })\n             }\n             ast::ItemKind::Mod(_) | ast::ItemKind::ForeignMod(_) => {\n                 let valid_ident =\n@@ -748,10 +746,19 @@ fn expand_annotatable(a: Annotatable,\n                 if valid_ident {\n                     fld.cx.mod_pop();\n                 }\n-                result.into_iter().map(|i| Annotatable::Item(i)).collect()\n+                result\n             },\n-            _ => noop_fold_item(it, fld).into_iter().map(|i| Annotatable::Item(i)).collect(),\n-        },\n+            ast::ItemKind::ExternCrate(_) => {\n+                // We need to error on `#[macro_use] extern crate` when it isn't at the\n+                // crate root, because `$crate` won't work properly.\n+                let allows_macros = fld.cx.syntax_env.is_crate_root();\n+                for def in fld.cx.loader.load_crate(&it, allows_macros) {\n+                    fld.cx.insert_macro(def);\n+                }\n+                SmallVector::one(it)\n+            },\n+            _ => noop_fold_item(it, fld),\n+        }.into_iter().map(|i| Annotatable::Item(i)).collect(),\n \n         Annotatable::TraitItem(it) => match it.node {\n             ast::TraitItemKind::Method(_, Some(_)) => {\n@@ -1137,8 +1144,6 @@ impl<'feat> ExpansionConfig<'feat> {\n }\n \n pub fn expand_crate(mut cx: ExtCtxt,\n-                    // these are the macros being imported to this crate:\n-                    imported_macros: Vec<ast::MacroDef>,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> (Crate, HashSet<Name>) {\n     if std_inject::no_core(&c) {\n@@ -1151,10 +1156,6 @@ pub fn expand_crate(mut cx: ExtCtxt,\n     let ret = {\n         let mut expander = MacroExpander::new(&mut cx);\n \n-        for def in imported_macros {\n-            expander.cx.insert_macro(def);\n-        }\n-\n         for (name, extension) in user_exts {\n             expander.cx.syntax_env.insert(name, extension);\n         }\n@@ -1220,7 +1221,7 @@ mod tests {\n     use ast;\n     use ast::Name;\n     use codemap;\n-    use ext::base::ExtCtxt;\n+    use ext::base::{ExtCtxt, DummyMacroLoader};\n     use ext::mtwt;\n     use fold::Folder;\n     use parse;\n@@ -1291,9 +1292,9 @@ mod tests {\n             src,\n             Vec::new(), &sess).unwrap();\n         // should fail:\n-        let mut gated_cfgs = vec![];\n-        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs);\n-        expand_crate(ecx, vec![], vec![], crate_ast);\n+        let (mut gated_cfgs, mut loader) = (vec![], DummyMacroLoader);\n+        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs, &mut loader);\n+        expand_crate(ecx, vec![], crate_ast);\n     }\n \n     // make sure that macros can't escape modules\n@@ -1306,9 +1307,9 @@ mod tests {\n             \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess).unwrap();\n-        let mut gated_cfgs = vec![];\n-        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs);\n-        expand_crate(ecx, vec![], vec![], crate_ast);\n+        let (mut gated_cfgs, mut loader) = (vec![], DummyMacroLoader);\n+        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs, &mut loader);\n+        expand_crate(ecx, vec![], crate_ast);\n     }\n \n     // macro_use modules should allow macros to escape\n@@ -1320,18 +1321,18 @@ mod tests {\n             \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess).unwrap();\n-        let mut gated_cfgs = vec![];\n-        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs);\n-        expand_crate(ecx, vec![], vec![], crate_ast);\n+        let (mut gated_cfgs, mut loader) = (vec![], DummyMacroLoader);\n+        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs, &mut loader);\n+        expand_crate(ecx, vec![], crate_ast);\n     }\n \n     fn expand_crate_str(crate_str: String) -> ast::Crate {\n         let ps = parse::ParseSess::new();\n         let crate_ast = panictry!(string_to_parser(&ps, crate_str).parse_crate_mod());\n         // the cfg argument actually does matter, here...\n-        let mut gated_cfgs = vec![];\n-        let ecx = ExtCtxt::new(&ps, vec![], test_ecfg(), &mut gated_cfgs);\n-        expand_crate(ecx, vec![], vec![], crate_ast).0\n+        let (mut gated_cfgs, mut loader) = (vec![], DummyMacroLoader);\n+        let ecx = ExtCtxt::new(&ps, vec![], test_ecfg(), &mut gated_cfgs, &mut loader);\n+        expand_crate(ecx, vec![], crate_ast).0\n     }\n \n     // find the pat_ident paths in a crate"}, {"sha": "2ac4aac65debe4ecfcd3f0f2fc9bfde2b7a3cd10", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "patch": "@@ -25,7 +25,7 @@ use codemap;\n use errors;\n use config;\n use entry::{self, EntryPointType};\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, DummyMacroLoader};\n use ext::build::AstBuilder;\n use ext::expand::ExpansionConfig;\n use fold::Folder;\n@@ -271,12 +271,14 @@ fn generate_test_harness(sess: &ParseSess,\n     let krate = cleaner.fold_crate(krate);\n \n     let mut feature_gated_cfgs = vec![];\n+    let mut loader = DummyMacroLoader;\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,\n         ext_cx: ExtCtxt::new(sess, vec![],\n                              ExpansionConfig::default(\"test\".to_string()),\n-                             &mut feature_gated_cfgs),\n+                             &mut feature_gated_cfgs,\n+                             &mut loader),\n         path: Vec::new(),\n         testfns: Vec::new(),\n         reexport_test_harness_main: reexport_test_harness_main,"}, {"sha": "98ed3e7145bc85f9cf6d72ab64cb927ee3937429", "filename": "src/test/compile-fail-fulldeps/expanded-macro-use.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Ftest%2Fcompile-fail-fulldeps%2Fexpanded-macro-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Ftest%2Fcompile-fail-fulldeps%2Fexpanded-macro-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fexpanded-macro-use.rs?ref=dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private)]\n+macro_rules! m {\n+    () => { #[macro_use] extern crate syntax; }\n+}\n+m!();\n+\n+fn main() {\n+    help!(); //~ ERROR unexpected end of macro invocation\n+}"}, {"sha": "ca896266411de0b5f3bc74db2e743385b6b20b96", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "patch": "@@ -21,10 +21,11 @@ use syntax::print::pprust;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n+    let mut loader = syntax::ext::base::DummyMacroLoader;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut Vec::new());\n+        &mut Vec::new(), &mut loader);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "fa6ee98317a940aa9231118e05ba7fa684b85483", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "patch": "@@ -23,11 +23,11 @@ use syntax::print::pprust;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n-    let mut feature_gated_cfgs = vec![];\n+    let (mut feature_gated_cfgs, mut loader) = (vec![], syntax::ext::base::DummyMacroLoader);\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut feature_gated_cfgs);\n+        &mut feature_gated_cfgs, &mut loader);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "efc1989a4fba2cf74e04c71377c63e9a3a93fa93", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "patch": "@@ -20,11 +20,11 @@ use syntax::parse::token::intern;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n-    let mut feature_gated_cfgs = vec![];\n+    let (mut feature_gated_cfgs, mut loader) = (vec![], syntax::ext::base::DummyMacroLoader);\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut feature_gated_cfgs);\n+        &mut feature_gated_cfgs, &mut loader);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}]}