{"sha": "aa97448caf49ee25271a5ad58482283404b9144f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhOTc0NDhjYWY0OWVlMjUyNzFhNWFkNTg0ODIyODM0MDRiOTE0NGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-13T03:30:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-13T03:30:20Z"}, "message": "Auto merge of #59151 - Centril:rollup, r=Centril\n\nRollup of 16 pull requests\n\nSuccessful merges:\n\n - #58829 (librustc_interface: Update scoped-tls to 1.0)\n - #58876 (Parse lifetimes that start with a number and give specific error)\n - #58908 (Update rand version)\n - #58998 (Fix documentation of from_ne_bytes and from_le_bytes)\n - #59056 (Use lifetime contravariance to elide more lifetimes in core+alloc+std)\n - #59057 (Standardize `Range*` documentation)\n - #59080 (Fix incorrect links in librustc_codegen_llvm documentation)\n - #59083 (Fix #54822 and associated faulty tests)\n - #59093 (Remove precompute_in_scope_traits_hashes)\n - #59101 (Reduces Code Repetitions like `!n >> amt`)\n - #59121 (impl FromIterator for Result: Use assert_eq! instead of assert!)\n - #59124 (Replace assert with assert_eq)\n - #59129 (Visit impl Trait for dead_code lint)\n - #59130 (Note that NonNull does not launder shared references for mutation)\n - #59132 (ignore higher-ranked object bound conditions created by WF)\n - #59138 (Simplify Iterator::{min, max})\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a7eefc25327ab135d272d3464e8ed88ac09def91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7eefc25327ab135d272d3464e8ed88ac09def91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa97448caf49ee25271a5ad58482283404b9144f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa97448caf49ee25271a5ad58482283404b9144f", "html_url": "https://github.com/rust-lang/rust/commit/aa97448caf49ee25271a5ad58482283404b9144f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa97448caf49ee25271a5ad58482283404b9144f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8860f217dda287600b2b2f1812d3026aa0d35d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8860f217dda287600b2b2f1812d3026aa0d35d4", "html_url": "https://github.com/rust-lang/rust/commit/f8860f217dda287600b2b2f1812d3026aa0d35d4"}, {"sha": "73feddb9d4509498e9aeb4075a1f1c24b6bad962", "url": "https://api.github.com/repos/rust-lang/rust/commits/73feddb9d4509498e9aeb4075a1f1c24b6bad962", "html_url": "https://github.com/rust-lang/rust/commit/73feddb9d4509498e9aeb4075a1f1c24b6bad962"}], "stats": {"total": 893, "additions": 526, "deletions": 367}, "files": [{"sha": "39ecc880097e3a9d62049c0d517ba58ce5790e36", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -2747,7 +2747,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_fs_util 0.0.0\",\n@@ -2778,7 +2778,7 @@ dependencies = [\n  \"rustc_resolve 0.0.0\",\n  \"rustc_traits 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n- \"scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\","}, {"sha": "9bce142b483f22f06c996aa8269a20eb19c7d59b", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -489,7 +489,7 @@ impl<T: ?Sized> From<Box<T>> for Pin<Box<T>> {\n }\n \n #[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\n-impl<'a, T: Copy> From<&'a [T]> for Box<[T]> {\n+impl<T: Copy> From<&[T]> for Box<[T]> {\n     /// Converts a `&[T]` into a `Box<[T]>`\n     ///\n     /// This conversion allocates on the heap\n@@ -503,15 +503,15 @@ impl<'a, T: Copy> From<&'a [T]> for Box<[T]> {\n     ///\n     /// println!(\"{:?}\", boxed_slice);\n     /// ```\n-    fn from(slice: &'a [T]) -> Box<[T]> {\n+    fn from(slice: &[T]) -> Box<[T]> {\n         let mut boxed = unsafe { RawVec::with_capacity(slice.len()).into_box() };\n         boxed.copy_from_slice(slice);\n         boxed\n     }\n }\n \n #[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\n-impl<'a> From<&'a str> for Box<str> {\n+impl From<&str> for Box<str> {\n     /// Converts a `&str` into a `Box<str>`\n     ///\n     /// This conversion allocates on the heap\n@@ -523,7 +523,7 @@ impl<'a> From<&'a str> for Box<str> {\n     /// println!(\"{}\", boxed);\n     /// ```\n     #[inline]\n-    fn from(s: &'a str) -> Box<str> {\n+    fn from(s: &str) -> Box<str> {\n         unsafe { from_boxed_utf8_unchecked(Box::from(s.as_bytes())) }\n     }\n }"}, {"sha": "68eecd97ea11ad1996f42eecbfb3441cb335d249", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -1145,15 +1145,15 @@ impl<T> From<T> for Rc<T> {\n }\n \n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n-impl<'a, T: Clone> From<&'a [T]> for Rc<[T]> {\n+impl<T: Clone> From<&[T]> for Rc<[T]> {\n     #[inline]\n     fn from(v: &[T]) -> Rc<[T]> {\n         <Self as RcFromSlice<T>>::from_slice(v)\n     }\n }\n \n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n-impl<'a> From<&'a str> for Rc<str> {\n+impl From<&str> for Rc<str> {\n     #[inline]\n     fn from(v: &str) -> Rc<str> {\n         let rc = Rc::<[u8]>::from(v.as_bytes());"}, {"sha": "a3e2098695f70c851478c99be85bd59947d51a6d", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -2172,9 +2172,9 @@ impl AsRef<[u8]> for String {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a str> for String {\n+impl From<&str> for String {\n     #[inline]\n-    fn from(s: &'a str) -> String {\n+    fn from(s: &str) -> String {\n         s.to_owned()\n     }\n }"}, {"sha": "cd62c3e05244c4399693864ee51fef8311b13c14", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -2182,25 +2182,25 @@ impl<T> AsMut<[T]> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: Clone> From<&'a [T]> for Vec<T> {\n+impl<T: Clone> From<&[T]> for Vec<T> {\n     #[cfg(not(test))]\n-    fn from(s: &'a [T]) -> Vec<T> {\n+    fn from(s: &[T]) -> Vec<T> {\n         s.to_vec()\n     }\n     #[cfg(test)]\n-    fn from(s: &'a [T]) -> Vec<T> {\n+    fn from(s: &[T]) -> Vec<T> {\n         crate::slice::to_vec(s)\n     }\n }\n \n #[stable(feature = \"vec_from_mut\", since = \"1.19.0\")]\n-impl<'a, T: Clone> From<&'a mut [T]> for Vec<T> {\n+impl<T: Clone> From<&mut [T]> for Vec<T> {\n     #[cfg(not(test))]\n-    fn from(s: &'a mut [T]) -> Vec<T> {\n+    fn from(s: &mut [T]) -> Vec<T> {\n         s.to_vec()\n     }\n     #[cfg(test)]\n-    fn from(s: &'a mut [T]) -> Vec<T> {\n+    fn from(s: &mut [T]) -> Vec<T> {\n         crate::slice::to_vec(s)\n     }\n }\n@@ -2231,8 +2231,8 @@ impl<T> From<Vec<T>> for Box<[T]> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a str> for Vec<u8> {\n-    fn from(s: &'a str) -> Vec<u8> {\n+impl From<&str> for Vec<u8> {\n+    fn from(s: &str) -> Vec<u8> {\n         From::from(s.as_bytes())\n     }\n }"}, {"sha": "dcd9ce6dad756b669fafdaf60ae750516095805d", "filename": "src/libcore/array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -139,7 +139,7 @@ macro_rules! array_impls {\n             }\n \n             #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-            impl<'a, T> TryFrom<&'a [T]> for [T; $N] where T: Copy {\n+            impl<T> TryFrom<&[T]> for [T; $N] where T: Copy {\n                 type Error = TryFromSliceError;\n \n                 fn try_from(slice: &[T]) -> Result<[T; $N], TryFromSliceError> {"}, {"sha": "825bd368bdf1d944edb3bb807b93a4d70104a18c", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -35,7 +35,7 @@ fn scatter(x: i32) -> i32 { (x * 31) % 127 }\n fn bench_max_by_key(b: &mut Bencher) {\n     b.iter(|| {\n         let it = 0..100;\n-        it.max_by_key(|&x| scatter(x))\n+        it.map(black_box).max_by_key(|&x| scatter(x))\n     })\n }\n \n@@ -56,7 +56,7 @@ fn bench_max_by_key2(b: &mut Bencher) {\n fn bench_max(b: &mut Bencher) {\n     b.iter(|| {\n         let it = 0..100;\n-        it.map(scatter).max()\n+        it.map(black_box).map(scatter).max()\n     })\n }\n "}, {"sha": "94bed3708369a6999699553eb024a8c0aa465578", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -1004,26 +1004,26 @@ mod impls {\n     // & pointers\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: & &B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: & &B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialOrd<&B> for &A where A: PartialOrd<B> {\n         #[inline]\n-        fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n+        fn partial_cmp(&self, other: &&B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n         }\n         #[inline]\n-        fn lt(&self, other: & &'b B) -> bool { PartialOrd::lt(*self, *other) }\n+        fn lt(&self, other: & &B) -> bool { PartialOrd::lt(*self, *other) }\n         #[inline]\n-        fn le(&self, other: & &'b B) -> bool { PartialOrd::le(*self, *other) }\n+        fn le(&self, other: & &B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: & &'b B) -> bool { PartialOrd::ge(*self, *other) }\n+        fn ge(&self, other: & &B) -> bool { PartialOrd::ge(*self, *other) }\n         #[inline]\n-        fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n+        fn gt(&self, other: & &B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<A: ?Sized> Ord for &A where A: Ord {\n@@ -1036,26 +1036,26 @@ mod impls {\n     // &mut pointers\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&mut B> for &mut A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialOrd<&mut B> for &mut A where A: PartialOrd<B> {\n         #[inline]\n-        fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n+        fn partial_cmp(&self, other: &&mut B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n         }\n         #[inline]\n-        fn lt(&self, other: &&'b mut B) -> bool { PartialOrd::lt(*self, *other) }\n+        fn lt(&self, other: &&mut B) -> bool { PartialOrd::lt(*self, *other) }\n         #[inline]\n-        fn le(&self, other: &&'b mut B) -> bool { PartialOrd::le(*self, *other) }\n+        fn le(&self, other: &&mut B) -> bool { PartialOrd::le(*self, *other) }\n         #[inline]\n-        fn ge(&self, other: &&'b mut B) -> bool { PartialOrd::ge(*self, *other) }\n+        fn ge(&self, other: &&mut B) -> bool { PartialOrd::ge(*self, *other) }\n         #[inline]\n-        fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n+        fn gt(&self, other: &&mut B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<A: ?Sized> Ord for &mut A where A: Ord {\n@@ -1066,18 +1066,18 @@ mod impls {\n     impl<A: ?Sized> Eq for &mut A where A: Eq {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&mut B> for &A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &mut A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: &&'b B) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&B) -> bool { PartialEq::ne(*self, *other) }\n     }\n }"}, {"sha": "b5c20582986b262368344a8df54b27b495c59f5d", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -37,21 +37,21 @@ macro_rules! forward_ref_binop {\n         }\n \n         #[$attr]\n-        impl<'a> $imp<&'a $u> for $t {\n+        impl $imp<&$u> for $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n             #[inline]\n-            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n                 $imp::$method(self, *other)\n             }\n         }\n \n         #[$attr]\n-        impl<'a, 'b> $imp<&'a $u> for &'b $t {\n+        impl $imp<&$u> for &$t {\n             type Output = <$t as $imp<$u>>::Output;\n \n             #[inline]\n-            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n                 $imp::$method(*self, *other)\n             }\n         }\n@@ -67,9 +67,9 @@ macro_rules! forward_ref_op_assign {\n     };\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n         #[$attr]\n-        impl<'a> $imp<&'a $u> for $t {\n+        impl $imp<&$u> for $t {\n             #[inline]\n-            fn $method(&mut self, other: &'a $u) {\n+            fn $method(&mut self, other: &$u) {\n                 $imp::$method(self, *other);\n             }\n         }"}, {"sha": "ca7feed0712d1e72cc76faa39aec7c1a82f632f8", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 19, "deletions": 56, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -2008,12 +2008,7 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |_, x, _, y| *x <= *y)\n-            .map(|(_, x)| x)\n+        self.max_by(Ord::cmp)\n     }\n \n     /// Returns the minimum element of an iterator.\n@@ -2038,12 +2033,7 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // only switch to y if it is strictly smaller, to\n-                     // preserve stability.\n-                     |_, x, _, y| *x > *y)\n-            .map(|(_, x)| x)\n+        self.min_by(Ord::cmp)\n     }\n \n     /// Returns the element that gives the maximum value from the\n@@ -2062,15 +2052,11 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+    fn max_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n-        select_fold1(self,\n-                     f,\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |x_p, _, y_p, _| x_p <= y_p)\n-            .map(|(_, x)| x)\n+        // switch to y even if it is only equal, to preserve stability.\n+        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p <= y_p).map(|(_, x)| x)\n     }\n \n     /// Returns the element that gives the maximum value with respect to the\n@@ -2092,12 +2078,8 @@ pub trait Iterator {\n     fn max_by<F>(self, mut compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |_, x, _, y| Ordering::Greater != compare(x, y))\n-            .map(|(_, x)| x)\n+        // switch to y even if it is only equal, to preserve stability.\n+        select_fold1(self, |x, y| compare(x, y) != Ordering::Greater)\n     }\n \n     /// Returns the element that gives the minimum value from the\n@@ -2115,15 +2097,11 @@ pub trait Iterator {\n     /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+    fn min_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n-        select_fold1(self,\n-                     f,\n-                     // only switch to y if it is strictly smaller, to\n-                     // preserve stability.\n-                     |x_p, _, y_p, _| x_p > y_p)\n-            .map(|(_, x)| x)\n+        // only switch to y if it is strictly smaller, to preserve stability.\n+        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p > y_p).map(|(_, x)| x)\n     }\n \n     /// Returns the element that gives the minimum value with respect to the\n@@ -2145,12 +2123,8 @@ pub trait Iterator {\n     fn min_by<F>(self, mut compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is strictly smaller, to\n-                     // preserve stability.\n-                     |_, x, _, y| Ordering::Greater == compare(x, y))\n-            .map(|(_, x)| x)\n+        // only switch to y if it is strictly smaller, to preserve stability.\n+        select_fold1(self, |x, y| compare(x, y) == Ordering::Greater)\n     }\n \n \n@@ -2693,34 +2667,23 @@ pub trait Iterator {\n     }\n }\n \n-/// Select an element from an iterator based on the given \"projection\"\n-/// and \"comparison\" function.\n+/// Select an element from an iterator based on the given \"comparison\"\n+/// function.\n ///\n /// This is an idiosyncratic helper to try to factor out the\n /// commonalities of {max,min}{,_by}. In particular, this avoids\n /// having to implement optimizations several times.\n #[inline]\n-fn select_fold1<I, B, FProj, FCmp>(mut it: I,\n-                                   mut f_proj: FProj,\n-                                   mut f_cmp: FCmp) -> Option<(B, I::Item)>\n-    where I: Iterator,\n-          FProj: FnMut(&I::Item) -> B,\n-          FCmp: FnMut(&B, &I::Item, &B, &I::Item) -> bool\n+fn select_fold1<I, F>(mut it: I, mut f: F) -> Option<I::Item>\n+    where\n+        I: Iterator,\n+        F: FnMut(&I::Item, &I::Item) -> bool,\n {\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n     it.next().map(|first| {\n-        let first_p = f_proj(&first);\n-\n-        it.fold((first_p, first), |(sel_p, sel), x| {\n-            let x_p = f_proj(&x);\n-            if f_cmp(&sel_p, &sel, &x_p, &x) {\n-                (x_p, x)\n-            } else {\n-                (sel_p, sel)\n-            }\n-        })\n+        it.fold(first, |sel, x| if f(&sel, &x) { x } else { sel })\n     })\n }\n "}, {"sha": "d93cfbc2a28acd571b4a621af2aa2875ffc58844", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -1979,10 +1979,10 @@ When starting from a slice rather than an array, fallible conversion APIs can be\n ```\n use std::convert::TryInto;\n \n-fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n     let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n     *input = rest;\n-    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\n }\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n@@ -2020,10 +2020,10 @@ When starting from a slice rather than an array, fallible conversion APIs can be\n ```\n use std::convert::TryInto;\n \n-fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n     let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n     *input = rest;\n-    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\n }\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n@@ -3695,10 +3695,10 @@ When starting from a slice rather than an array, fallible conversion APIs can be\n ```\n use std::convert::TryInto;\n \n-fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n     let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n     *input = rest;\n-    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\n }\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n@@ -3736,10 +3736,10 @@ When starting from a slice rather than an array, fallible conversion APIs can be\n ```\n use std::convert::TryInto;\n \n-fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n     let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n     *input = rest;\n-    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\n }\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]"}, {"sha": "81a8d001dd9cb4237d256eb9b470c5ece38012c7", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -26,11 +26,13 @@ use hash::{Hash, Hasher};\n /// Used as a [slicing index], `RangeFull` produces the full array as a slice.\n ///\n /// ```\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ .. ], [0,1,2,3]);  // RangeFull\n-/// assert_eq!(arr[ ..3], [0,1,2  ]);\n-/// assert_eq!(arr[1.. ], [  1,2,3]);\n-/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);  // RangeFull\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n ///\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n@@ -60,11 +62,13 @@ impl fmt::Debug for RangeFull {\n /// assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n /// assert_eq!(3 + 4 + 5, (3..6).sum());\n ///\n-/// let arr = ['a', 'b', 'c', 'd'];\n-/// assert_eq!(arr[ .. ], ['a', 'b', 'c', 'd']);\n-/// assert_eq!(arr[ ..3], ['a', 'b', 'c',    ]);\n-/// assert_eq!(arr[1.. ], [     'b', 'c', 'd']);\n-/// assert_eq!(arr[1..3], [     'b', 'c'     ]);  // Range\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);  // Range\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n #[doc(alias = \"..\")]\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n@@ -160,11 +164,13 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n /// assert_eq!((2..), std::ops::RangeFrom { start: 2 });\n /// assert_eq!(2 + 3 + 4, (2..).take(3).sum());\n ///\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ .. ], [0,1,2,3]);\n-/// assert_eq!(arr[ ..3], [0,1,2  ]);\n-/// assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n-/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);  // RangeFrom\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n ///\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n@@ -240,11 +246,13 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n /// elements before the index indicated by `end`.\n ///\n /// ```\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ .. ], [0,1,2,3]);\n-/// assert_eq!(arr[ ..3], [0,1,2  ]);  // RangeTo\n-/// assert_eq!(arr[1.. ], [  1,2,3]);\n-/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);  // RangeTo\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n ///\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n@@ -312,9 +320,13 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// assert_eq!((3..=5), std::ops::RangeInclusive::new(3, 5));\n /// assert_eq!(3 + 4 + 5, (3..=5).sum());\n ///\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ ..=2], [0,1,2  ]);\n-/// assert_eq!(arr[1..=2], [  1,2  ]);  // RangeInclusive\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);  // RangeInclusive\n /// ```\n #[doc(alias = \"..=\")]\n #[derive(Clone)]  // not Copy -- see #27186\n@@ -569,9 +581,13 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// array elements up to and including the index indicated by `end`.\n ///\n /// ```\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ ..=2], [0,1,2  ]);  // RangeToInclusive\n-/// assert_eq!(arr[1..=2], [  1,2  ]);\n+/// let arr = [0, 1, 2, 3, 4];\n+/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n+/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n+/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);  // RangeToInclusive\n+/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n+/// assert_eq!(arr[1.. 3], [  1,2    ]);\n+/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n ///\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n@@ -676,7 +692,7 @@ pub enum Bound<T> {\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n /// `RangeBounds` is implemented by Rust's built-in range types, produced\n-/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n+/// by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.\n pub trait RangeBounds<T: ?Sized> {\n     /// Start index bound.\n     ///"}, {"sha": "a9a029d606d6f84315931b1b69381dfe663c1de4", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -2837,15 +2837,15 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<'a, T: ?Sized> From<&'a mut T> for Unique<T> {\n-    fn from(reference: &'a mut T) -> Self {\n+impl<T: ?Sized> From<&mut T> for Unique<T> {\n+    fn from(reference: &mut T) -> Self {\n         unsafe { Unique { pointer: reference as *mut T, _marker: PhantomData } }\n     }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<'a, T: ?Sized> From<&'a T> for Unique<T> {\n-    fn from(reference: &'a T) -> Self {\n+impl<T: ?Sized> From<&T> for Unique<T> {\n+    fn from(reference: &T) -> Self {\n         unsafe { Unique { pointer: reference as *const T, _marker: PhantomData } }\n     }\n }\n@@ -2874,6 +2874,16 @@ impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n /// Usually this won't be necessary; covariance is correct for most safe abstractions,\n /// such as Box, Rc, Arc, Vec, and LinkedList. This is the case because they\n /// provide a public API that follows the normal shared XOR mutable rules of Rust.\n+///\n+/// Notice that `NonNull<T>` has a `From` instance for `&T`. However, this does\n+/// not change the fact that mutating through a (pointer derived from a) shared\n+/// reference is undefined behavior unless the mutation happens inside an\n+/// [`UnsafeCell<T>`]. The same goes for creating a mutable reference from a shared\n+/// reference. When using this `From` instance without an `UnsafeCell<T>`,\n+/// it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`\n+/// is never used for mutation.\n+///\n+/// [`UnsafeCell<T>`]: ../cell/struct.UnsafeCell.html\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n #[repr(transparent)]\n #[rustc_layout_scalar_valid_range_start(1)]\n@@ -3049,17 +3059,17 @@ impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<'a, T: ?Sized> From<&'a mut T> for NonNull<T> {\n+impl<T: ?Sized> From<&mut T> for NonNull<T> {\n     #[inline]\n-    fn from(reference: &'a mut T) -> Self {\n+    fn from(reference: &mut T) -> Self {\n         unsafe { NonNull { pointer: reference as *mut T } }\n     }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<'a, T: ?Sized> From<&'a T> for NonNull<T> {\n+impl<T: ?Sized> From<&T> for NonNull<T> {\n     #[inline]\n-    fn from(reference: &'a T) -> Self {\n+    fn from(reference: &T) -> Self {\n         unsafe { NonNull { pointer: reference as *const T } }\n     }\n }"}, {"sha": "2bd6b536301e8de10241cbbbf0e74a7b2777ad8a", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -1200,7 +1200,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|x: &u32|\n     ///     x.checked_add(1).ok_or(\"Overflow!\")\n     /// ).collect();\n-    /// assert!(res == Ok(vec![2, 3]));\n+    /// assert_eq!(res, Ok(vec![2, 3]));\n     /// ```\n     #[inline]\n     fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {"}, {"sha": "10fcf8b76ccb4bd7c8e47a8d842bcd03feecc678", "filename": "src/libcore/tests/fmt/num.rs", "status": "modified", "additions": 118, "deletions": 118, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -3,146 +3,146 @@ fn test_format_int() {\n     // Formatting integers should select the right implementation based off\n     // the type of the argument. Also, hex/octal/binary should be defined\n     // for integers, but they shouldn't emit the negative sign.\n-    assert!(format!(\"{}\", 1isize) == \"1\");\n-    assert!(format!(\"{}\", 1i8) == \"1\");\n-    assert!(format!(\"{}\", 1i16) == \"1\");\n-    assert!(format!(\"{}\", 1i32) == \"1\");\n-    assert!(format!(\"{}\", 1i64) == \"1\");\n-    assert!(format!(\"{}\", -1isize) == \"-1\");\n-    assert!(format!(\"{}\", -1i8) == \"-1\");\n-    assert!(format!(\"{}\", -1i16) == \"-1\");\n-    assert!(format!(\"{}\", -1i32) == \"-1\");\n-    assert!(format!(\"{}\", -1i64) == \"-1\");\n-    assert!(format!(\"{:?}\", 1isize) == \"1\");\n-    assert!(format!(\"{:?}\", 1i8) == \"1\");\n-    assert!(format!(\"{:?}\", 1i16) == \"1\");\n-    assert!(format!(\"{:?}\", 1i32) == \"1\");\n-    assert!(format!(\"{:?}\", 1i64) == \"1\");\n-    assert!(format!(\"{:b}\", 1isize) == \"1\");\n-    assert!(format!(\"{:b}\", 1i8) == \"1\");\n-    assert!(format!(\"{:b}\", 1i16) == \"1\");\n-    assert!(format!(\"{:b}\", 1i32) == \"1\");\n-    assert!(format!(\"{:b}\", 1i64) == \"1\");\n-    assert!(format!(\"{:x}\", 1isize) == \"1\");\n-    assert!(format!(\"{:x}\", 1i8) == \"1\");\n-    assert!(format!(\"{:x}\", 1i16) == \"1\");\n-    assert!(format!(\"{:x}\", 1i32) == \"1\");\n-    assert!(format!(\"{:x}\", 1i64) == \"1\");\n-    assert!(format!(\"{:X}\", 1isize) == \"1\");\n-    assert!(format!(\"{:X}\", 1i8) == \"1\");\n-    assert!(format!(\"{:X}\", 1i16) == \"1\");\n-    assert!(format!(\"{:X}\", 1i32) == \"1\");\n-    assert!(format!(\"{:X}\", 1i64) == \"1\");\n-    assert!(format!(\"{:o}\", 1isize) == \"1\");\n-    assert!(format!(\"{:o}\", 1i8) == \"1\");\n-    assert!(format!(\"{:o}\", 1i16) == \"1\");\n-    assert!(format!(\"{:o}\", 1i32) == \"1\");\n-    assert!(format!(\"{:o}\", 1i64) == \"1\");\n+    assert_eq!(format!(\"{}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{}\", -1isize), \"-1\");\n+    assert_eq!(format!(\"{}\", -1i8), \"-1\");\n+    assert_eq!(format!(\"{}\", -1i16), \"-1\");\n+    assert_eq!(format!(\"{}\", -1i32), \"-1\");\n+    assert_eq!(format!(\"{}\", -1i64), \"-1\");\n+    assert_eq!(format!(\"{:?}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1isize), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1i8), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1i16), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1i32), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1i64), \"1\");\n \n-    assert!(format!(\"{}\", 1usize) == \"1\");\n-    assert!(format!(\"{}\", 1u8) == \"1\");\n-    assert!(format!(\"{}\", 1u16) == \"1\");\n-    assert!(format!(\"{}\", 1u32) == \"1\");\n-    assert!(format!(\"{}\", 1u64) == \"1\");\n-    assert!(format!(\"{:?}\", 1usize) == \"1\");\n-    assert!(format!(\"{:?}\", 1u8) == \"1\");\n-    assert!(format!(\"{:?}\", 1u16) == \"1\");\n-    assert!(format!(\"{:?}\", 1u32) == \"1\");\n-    assert!(format!(\"{:?}\", 1u64) == \"1\");\n-    assert!(format!(\"{:b}\", 1usize) == \"1\");\n-    assert!(format!(\"{:b}\", 1u8) == \"1\");\n-    assert!(format!(\"{:b}\", 1u16) == \"1\");\n-    assert!(format!(\"{:b}\", 1u32) == \"1\");\n-    assert!(format!(\"{:b}\", 1u64) == \"1\");\n-    assert!(format!(\"{:x}\", 1usize) == \"1\");\n-    assert!(format!(\"{:x}\", 1u8) == \"1\");\n-    assert!(format!(\"{:x}\", 1u16) == \"1\");\n-    assert!(format!(\"{:x}\", 1u32) == \"1\");\n-    assert!(format!(\"{:x}\", 1u64) == \"1\");\n-    assert!(format!(\"{:X}\", 1usize) == \"1\");\n-    assert!(format!(\"{:X}\", 1u8) == \"1\");\n-    assert!(format!(\"{:X}\", 1u16) == \"1\");\n-    assert!(format!(\"{:X}\", 1u32) == \"1\");\n-    assert!(format!(\"{:X}\", 1u64) == \"1\");\n-    assert!(format!(\"{:o}\", 1usize) == \"1\");\n-    assert!(format!(\"{:o}\", 1u8) == \"1\");\n-    assert!(format!(\"{:o}\", 1u16) == \"1\");\n-    assert!(format!(\"{:o}\", 1u32) == \"1\");\n-    assert!(format!(\"{:o}\", 1u64) == \"1\");\n+    assert_eq!(format!(\"{}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{:?}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{:b}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{:x}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{:X}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1usize), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1u8), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1u16), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1u32), \"1\");\n+    assert_eq!(format!(\"{:o}\", 1u64), \"1\");\n \n     // Test a larger number\n-    assert!(format!(\"{:b}\", 55) == \"110111\");\n-    assert!(format!(\"{:o}\", 55) == \"67\");\n-    assert!(format!(\"{}\", 55) == \"55\");\n-    assert!(format!(\"{:x}\", 55) == \"37\");\n-    assert!(format!(\"{:X}\", 55) == \"37\");\n+    assert_eq!(format!(\"{:b}\", 55), \"110111\");\n+    assert_eq!(format!(\"{:o}\", 55), \"67\");\n+    assert_eq!(format!(\"{}\", 55), \"55\");\n+    assert_eq!(format!(\"{:x}\", 55), \"37\");\n+    assert_eq!(format!(\"{:X}\", 55), \"37\");\n }\n \n #[test]\n fn test_format_int_zero() {\n-    assert!(format!(\"{}\", 0) == \"0\");\n-    assert!(format!(\"{:?}\", 0) == \"0\");\n-    assert!(format!(\"{:b}\", 0) == \"0\");\n-    assert!(format!(\"{:o}\", 0) == \"0\");\n-    assert!(format!(\"{:x}\", 0) == \"0\");\n-    assert!(format!(\"{:X}\", 0) == \"0\");\n+    assert_eq!(format!(\"{}\", 0), \"0\");\n+    assert_eq!(format!(\"{:?}\", 0), \"0\");\n+    assert_eq!(format!(\"{:b}\", 0), \"0\");\n+    assert_eq!(format!(\"{:o}\", 0), \"0\");\n+    assert_eq!(format!(\"{:x}\", 0), \"0\");\n+    assert_eq!(format!(\"{:X}\", 0), \"0\");\n \n-    assert!(format!(\"{}\", 0u32) == \"0\");\n-    assert!(format!(\"{:?}\", 0u32) == \"0\");\n-    assert!(format!(\"{:b}\", 0u32) == \"0\");\n-    assert!(format!(\"{:o}\", 0u32) == \"0\");\n-    assert!(format!(\"{:x}\", 0u32) == \"0\");\n-    assert!(format!(\"{:X}\", 0u32) == \"0\");\n+    assert_eq!(format!(\"{}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:?}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:b}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:o}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:x}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:X}\", 0u32), \"0\");\n }\n \n #[test]\n fn test_format_int_flags() {\n-    assert!(format!(\"{:3}\", 1) == \"  1\");\n-    assert!(format!(\"{:>3}\", 1) == \"  1\");\n-    assert!(format!(\"{:>+3}\", 1) == \" +1\");\n-    assert!(format!(\"{:<3}\", 1) == \"1  \");\n-    assert!(format!(\"{:#}\", 1) == \"1\");\n-    assert!(format!(\"{:#x}\", 10) == \"0xa\");\n-    assert!(format!(\"{:#X}\", 10) == \"0xA\");\n-    assert!(format!(\"{:#5x}\", 10) == \"  0xa\");\n-    assert!(format!(\"{:#o}\", 10) == \"0o12\");\n-    assert!(format!(\"{:08x}\", 10) == \"0000000a\");\n-    assert!(format!(\"{:8x}\", 10) == \"       a\");\n-    assert!(format!(\"{:<8x}\", 10) == \"a       \");\n-    assert!(format!(\"{:>8x}\", 10) == \"       a\");\n-    assert!(format!(\"{:#08x}\", 10) == \"0x00000a\");\n-    assert!(format!(\"{:08}\", -10) == \"-0000010\");\n-    assert!(format!(\"{:x}\", !0u8) == \"ff\");\n-    assert!(format!(\"{:X}\", !0u8) == \"FF\");\n-    assert!(format!(\"{:b}\", !0u8) == \"11111111\");\n-    assert!(format!(\"{:o}\", !0u8) == \"377\");\n-    assert!(format!(\"{:#x}\", !0u8) == \"0xff\");\n-    assert!(format!(\"{:#X}\", !0u8) == \"0xFF\");\n-    assert!(format!(\"{:#b}\", !0u8) == \"0b11111111\");\n-    assert!(format!(\"{:#o}\", !0u8) == \"0o377\");\n+    assert_eq!(format!(\"{:3}\", 1), \"  1\");\n+    assert_eq!(format!(\"{:>3}\", 1), \"  1\");\n+    assert_eq!(format!(\"{:>+3}\", 1), \" +1\");\n+    assert_eq!(format!(\"{:<3}\", 1), \"1  \");\n+    assert_eq!(format!(\"{:#}\", 1), \"1\");\n+    assert_eq!(format!(\"{:#x}\", 10), \"0xa\");\n+    assert_eq!(format!(\"{:#X}\", 10), \"0xA\");\n+    assert_eq!(format!(\"{:#5x}\", 10), \"  0xa\");\n+    assert_eq!(format!(\"{:#o}\", 10), \"0o12\");\n+    assert_eq!(format!(\"{:08x}\", 10), \"0000000a\");\n+    assert_eq!(format!(\"{:8x}\", 10), \"       a\");\n+    assert_eq!(format!(\"{:<8x}\", 10), \"a       \");\n+    assert_eq!(format!(\"{:>8x}\", 10), \"       a\");\n+    assert_eq!(format!(\"{:#08x}\", 10), \"0x00000a\");\n+    assert_eq!(format!(\"{:08}\", -10), \"-0000010\");\n+    assert_eq!(format!(\"{:x}\", !0u8), \"ff\");\n+    assert_eq!(format!(\"{:X}\", !0u8), \"FF\");\n+    assert_eq!(format!(\"{:b}\", !0u8), \"11111111\");\n+    assert_eq!(format!(\"{:o}\", !0u8), \"377\");\n+    assert_eq!(format!(\"{:#x}\", !0u8), \"0xff\");\n+    assert_eq!(format!(\"{:#X}\", !0u8), \"0xFF\");\n+    assert_eq!(format!(\"{:#b}\", !0u8), \"0b11111111\");\n+    assert_eq!(format!(\"{:#o}\", !0u8), \"0o377\");\n }\n \n #[test]\n fn test_format_int_sign_padding() {\n-    assert!(format!(\"{:+5}\", 1) == \"   +1\");\n-    assert!(format!(\"{:+5}\", -1) == \"   -1\");\n-    assert!(format!(\"{:05}\", 1) == \"00001\");\n-    assert!(format!(\"{:05}\", -1) == \"-0001\");\n-    assert!(format!(\"{:+05}\", 1) == \"+0001\");\n-    assert!(format!(\"{:+05}\", -1) == \"-0001\");\n+    assert_eq!(format!(\"{:+5}\", 1), \"   +1\");\n+    assert_eq!(format!(\"{:+5}\", -1), \"   -1\");\n+    assert_eq!(format!(\"{:05}\", 1), \"00001\");\n+    assert_eq!(format!(\"{:05}\", -1), \"-0001\");\n+    assert_eq!(format!(\"{:+05}\", 1), \"+0001\");\n+    assert_eq!(format!(\"{:+05}\", -1), \"-0001\");\n }\n \n #[test]\n fn test_format_int_twos_complement() {\n-    use core::{i8, i16, i32, i64};\n-    assert!(format!(\"{}\", i8::MIN) == \"-128\");\n-    assert!(format!(\"{}\", i16::MIN) == \"-32768\");\n-    assert!(format!(\"{}\", i32::MIN) == \"-2147483648\");\n-    assert!(format!(\"{}\", i64::MIN) == \"-9223372036854775808\");\n+    use core::{i16, i32, i64, i8};\n+    assert_eq!(format!(\"{}\", i8::MIN), \"-128\");\n+    assert_eq!(format!(\"{}\", i16::MIN), \"-32768\");\n+    assert_eq!(format!(\"{}\", i32::MIN), \"-2147483648\");\n+    assert_eq!(format!(\"{}\", i64::MIN), \"-9223372036854775808\");\n }\n \n #[test]\n fn test_format_debug_hex() {\n-    assert!(format!(\"{:02x?}\", b\"Foo\\0\") == \"[46, 6f, 6f, 00]\");\n-    assert!(format!(\"{:02X?}\", b\"Foo\\0\") == \"[46, 6F, 6F, 00]\");\n+    assert_eq!(format!(\"{:02x?}\", b\"Foo\\0\"), \"[46, 6f, 6f, 00]\");\n+    assert_eq!(format!(\"{:02X?}\", b\"Foo\\0\"), \"[46, 6F, 6F, 00]\");\n }"}, {"sha": "a9db9b35d8d80e3be984a78d7b385d7243b48e98", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -1082,12 +1082,39 @@ fn test_iterator_product_result() {\n     assert_eq!(v.iter().cloned().product::<Result<i32, _>>(), Err(()));\n }\n \n+/// A wrapper struct that implements `Eq` and `Ord` based on the wrapped\n+/// integer modulo 3. Used to test that `Iterator::max` and `Iterator::min`\n+/// return the correct element if some of them are equal.\n+#[derive(Debug)]\n+struct Mod3(i32);\n+\n+impl PartialEq for Mod3 {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0 % 3 == other.0 % 3\n+    }\n+}\n+\n+impl Eq for Mod3 {}\n+\n+impl PartialOrd for Mod3 {\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Mod3 {\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        (self.0 % 3).cmp(&(other.0 % 3))\n+    }\n+}\n+\n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(v[..4].iter().cloned().max(), Some(3));\n     assert_eq!(v.iter().cloned().max(), Some(10));\n     assert_eq!(v[..0].iter().cloned().max(), None);\n+    assert_eq!(v.iter().cloned().map(Mod3).max().map(|x| x.0), Some(8));\n }\n \n #[test]\n@@ -1096,6 +1123,7 @@ fn test_iterator_min() {\n     assert_eq!(v[..4].iter().cloned().min(), Some(0));\n     assert_eq!(v.iter().cloned().min(), Some(0));\n     assert_eq!(v[..0].iter().cloned().min(), None);\n+    assert_eq!(v.iter().cloned().map(Mod3).min().map(|x| x.0), Some(0));\n }\n \n #[test]"}, {"sha": "94de999c25da81843fe95ae8889034faa3094bee", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -3,7 +3,7 @@\n // from live codes are live, and everything else is dead.\n \n use crate::hir::Node;\n-use crate::hir::{self, PatKind};\n+use crate::hir::{self, PatKind, TyKind};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n \n@@ -282,6 +282,17 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         self.handle_definition(path.def);\n         intravisit::walk_path(self, path);\n     }\n+\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        match ty.node {\n+            TyKind::Def(item_id, _) => {\n+                let item = self.tcx.hir().expect_item(item_id.id);\n+                intravisit::walk_item(self, item);\n+            }\n+            _ => ()\n+        }\n+        intravisit::walk_ty(self, ty);\n+    }\n }\n \n fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,"}, {"sha": "8c684c0775ee367cc4b9849410006eb9cbea5d59", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -275,6 +275,8 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                 self.selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n         }\n \n+        debug!(\"process_obligation: obligation = {:?}\", obligation);\n+\n         match obligation.predicate {\n             ty::Predicate::Trait(ref data) => {\n                 let trait_obligation = obligation.with(data.clone());"}, {"sha": "08b595c5eaa5aa1e7665860ea171e3e1521af6c0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -1443,16 +1443,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // This method exercises the `in_scope_traits_map` query for all possible\n-    // values so that we have their fingerprints available in the DepGraph.\n-    // This is only required as long as we still use the old dependency tracking\n-    // which needs to have the fingerprints of all input nodes beforehand.\n-    pub fn precompute_in_scope_traits_hashes(self) {\n-        for &def_index in self.trait_map.keys() {\n-            self.in_scope_traits_map(def_index);\n-        }\n-    }\n-\n     pub fn serialize_query_result_cache<E>(self,\n                                            encoder: &mut E)\n                                            -> Result<(), E::Error>"}, {"sha": "fa35416cdd4982fd50f11376e006635eb97d111e", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -482,8 +482,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         //\n         // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n         // am looking forward to the future here.\n-\n-        if !data.has_escaping_bound_vars() {\n+        if !data.has_escaping_bound_vars() && !region.has_escaping_bound_vars() {\n             let implicit_bounds =\n                 object_region_bounds(self.infcx.tcx, data);\n "}, {"sha": "daccfc9b242f924da3e63444abd4c2c1b029334a", "filename": "src/librustc_codegen_llvm/debuginfo/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -1,21 +1,21 @@\n //! # Debug Info Module\n //!\n //! This module serves the purpose of generating debug symbols. We use LLVM's\n-//! [source level debugging](http://!llvm.org/docs/SourceLevelDebugging.html)\n+//! [source level debugging](https://llvm.org/docs/SourceLevelDebugging.html)\n //! features for generating the debug information. The general principle is\n //! this:\n //!\n //! Given the right metadata in the LLVM IR, the LLVM code generator is able to\n //! create DWARF debug symbols for the given code. The\n-//! [metadata](http://!llvm.org/docs/LangRef.html#metadata-type) is structured\n+//! [metadata](https://llvm.org/docs/LangRef.html#metadata-type) is structured\n //! much like DWARF *debugging information entries* (DIE), representing type\n //! information such as datatype layout, function signatures, block layout,\n //! variable location and scope information, etc. It is the purpose of this\n //! module to generate correct metadata and insert it into the LLVM IR.\n //!\n //! As the exact format of metadata trees may change between different LLVM\n //! versions, we now use LLVM\n-//! [DIBuilder](http://!llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n+//! [DIBuilder](https://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n //! to create metadata where possible. This will hopefully ease the adaption of\n //! this module to future LLVM versions.\n //!"}, {"sha": "df971ec5bdb85c9d0740a3afc5eef44f3db05a31", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -12,7 +12,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n-rand = \"0.5\"\n+rand = \"0.6\"\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "255a3899d1183e23b9e5af9c0acd011e5a6997fc", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -21,7 +21,6 @@ pub fn dep_graph_tcx_init<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n \n     tcx.allocate_metadata_dep_nodes();\n-    tcx.precompute_in_scope_traits_hashes();\n }\n \n type WorkProductMap = FxHashMap<WorkProductId, WorkProduct>;"}, {"sha": "294e23dc6177c74b7eba6a8bc50d8e910766f60f", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -12,7 +12,7 @@ crate-type = [\"dylib\"]\n log = \"0.4\"\n rustc-rayon = \"0.1.1\"\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n-scoped-tls = { version = \"0.1.1\", features = [\"nightly\"] }\n+scoped-tls = \"1.0\"\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "d60a0941b5979048653a32b293a469049daf40a9", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -19,6 +19,7 @@ use rustc::ty;\n use rustc::ty::layout::{Integer, IntegerExt, Size};\n use syntax::attr::{SignedInt, UnsignedInt};\n use rustc::hir::RangeEnd;\n+use rustc::mir::interpret::truncate;\n \n use std::mem;\n \n@@ -115,14 +116,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ty::Int(ity) => {\n                         // FIXME(49937): refactor these bit manipulations into interpret.\n                         let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n-                        let max = !0u128 >> (128 - size.bits());\n+                        let max = truncate(u128::max_value(), size);\n                         let bias = 1u128 << (size.bits() - 1);\n                         (Some((0, max, size)), bias)\n                     }\n                     ty::Uint(uty) => {\n                         // FIXME(49937): refactor these bit manipulations into interpret.\n                         let size = Integer::from_attr(&tcx, UnsignedInt(uty)).size();\n-                        let max = !0u128 >> (128 - size.bits());\n+                        let max = truncate(u128::max_value(), size);\n                         (Some((0, max, size)), 0)\n                     }\n                     _ => (None, 0),"}, {"sha": "f79bf4e999d5492dc158cca4a8ae47f29fa7a441", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -917,7 +917,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let param_env = ty::ParamEnv::empty();\n+        let param_env = tcx.param_env(impl_c.def_id);\n         let inh = Inherited::new(infcx, impl_c.def_id);\n         let infcx = &inh.infcx;\n "}, {"sha": "f2111f2d9e0281f60b838fe650a2fea579b1879a", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -850,7 +850,7 @@ impl<T, S> Default for HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+impl<T, S> BitOr<&HashSet<T, S>> for &HashSet<T, S>\n     where T: Eq + Hash + Clone,\n           S: BuildHasher + Default\n {\n@@ -882,7 +882,7 @@ impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+impl<T, S> BitAnd<&HashSet<T, S>> for &HashSet<T, S>\n     where T: Eq + Hash + Clone,\n           S: BuildHasher + Default\n {\n@@ -914,7 +914,7 @@ impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+impl<T, S> BitXor<&HashSet<T, S>> for &HashSet<T, S>\n     where T: Eq + Hash + Clone,\n           S: BuildHasher + Default\n {\n@@ -946,7 +946,7 @@ impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+impl<T, S> Sub<&HashSet<T, S>> for &HashSet<T, S>\n     where T: Eq + Hash + Clone,\n           S: BuildHasher + Default\n {"}, {"sha": "3eb289501cb0fd080ccea3d7f3df479ede4ef8eb", "filename": "src/libstd/error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -337,7 +337,7 @@ impl From<String> for Box<dyn Error> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b> From<&'b str> for Box<dyn Error + Send + Sync + 'a> {\n+impl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n     /// Converts a [`str`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n     /// # Examples\n@@ -351,13 +351,13 @@ impl<'a, 'b> From<&'b str> for Box<dyn Error + Send + Sync + 'a> {\n     /// assert!(\n     ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n     /// ```\n-    fn from(err: &'b str) -> Box<dyn Error + Send + Sync + 'a> {\n+    fn from(err: &str) -> Box<dyn Error + Send + Sync + 'a> {\n         From::from(String::from(err))\n     }\n }\n \n #[stable(feature = \"string_box_error\", since = \"1.6.0\")]\n-impl<'a> From<&'a str> for Box<dyn Error> {\n+impl From<&str> for Box<dyn Error> {\n     /// Converts a [`str`] into a box of dyn [`Error`].\n     ///\n     /// # Examples\n@@ -370,7 +370,7 @@ impl<'a> From<&'a str> for Box<dyn Error> {\n     /// let a_boxed_error = Box::<Error>::from(a_str_error);\n     /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n     /// ```\n-    fn from(err: &'a str) -> Box<dyn Error> {\n+    fn from(err: &str) -> Box<dyn Error> {\n         From::from(String::from(err))\n     }\n }"}, {"sha": "ad3f45bfadaf4df0903fb4b5ec469f76fcf99053", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -690,8 +690,8 @@ impl<'a> From<Cow<'a, CStr>> for CString {\n }\n \n #[stable(feature = \"box_from_c_str\", since = \"1.17.0\")]\n-impl<'a> From<&'a CStr> for Box<CStr> {\n-    fn from(s: &'a CStr) -> Box<CStr> {\n+impl From<&CStr> for Box<CStr> {\n+    fn from(s: &CStr) -> Box<CStr> {\n         let boxed: Box<[u8]> = Box::from(s.to_bytes_with_nul());\n         unsafe { Box::from_raw(Box::into_raw(boxed) as *mut CStr) }\n     }\n@@ -767,7 +767,7 @@ impl From<CString> for Arc<CStr> {\n }\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n-impl<'a> From<&'a CStr> for Arc<CStr> {\n+impl From<&CStr> for Arc<CStr> {\n     #[inline]\n     fn from(s: &CStr) -> Arc<CStr> {\n         let arc: Arc<[u8]> = Arc::from(s.to_bytes_with_nul());\n@@ -789,7 +789,7 @@ impl From<CString> for Rc<CStr> {\n }\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n-impl<'a> From<&'a CStr> for Rc<CStr> {\n+impl From<&CStr> for Rc<CStr> {\n     #[inline]\n     fn from(s: &CStr) -> Rc<CStr> {\n         let rc: Rc<[u8]> = Rc::from(s.to_bytes_with_nul());\n@@ -1268,8 +1268,8 @@ impl ToOwned for CStr {\n }\n \n #[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n-impl<'a> From<&'a CStr> for CString {\n-    fn from(s: &'a CStr) -> CString {\n+impl From<&CStr> for CString {\n+    fn from(s: &CStr) -> CString {\n         s.to_owned()\n     }\n }"}, {"sha": "3a0590021c917bc1cdaf6e7fa69ba590c926c926", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -357,8 +357,8 @@ impl From<String> for OsString {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized + AsRef<OsStr>> From<&'a T> for OsString {\n-    fn from(s: &'a T) -> OsString {\n+impl<T: ?Sized + AsRef<OsStr>> From<&T> for OsString {\n+    fn from(s: &T) -> OsString {\n         s.as_ref().to_os_string()\n     }\n }\n@@ -421,8 +421,8 @@ impl PartialEq<OsString> for str {\n }\n \n #[stable(feature = \"os_str_str_ref_eq\", since = \"1.29.0\")]\n-impl<'a> PartialEq<&'a str> for OsString {\n-    fn eq(&self, other: &&'a str) -> bool {\n+impl PartialEq<&str> for OsString {\n+    fn eq(&self, other: &&str) -> bool {\n         **self == **other\n     }\n }\n@@ -656,8 +656,8 @@ impl OsStr {\n }\n \n #[stable(feature = \"box_from_os_str\", since = \"1.17.0\")]\n-impl<'a> From<&'a OsStr> for Box<OsStr> {\n-    fn from(s: &'a OsStr) -> Box<OsStr> {\n+impl From<&OsStr> for Box<OsStr> {\n+    fn from(s: &OsStr) -> Box<OsStr> {\n         let rw = Box::into_raw(s.inner.into_box()) as *mut OsStr;\n         unsafe { Box::from_raw(rw) }\n     }\n@@ -707,7 +707,7 @@ impl From<OsString> for Arc<OsStr> {\n }\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n-impl<'a> From<&'a OsStr> for Arc<OsStr> {\n+impl From<&OsStr> for Arc<OsStr> {\n     #[inline]\n     fn from(s: &OsStr) -> Arc<OsStr> {\n         let arc = s.inner.into_arc();\n@@ -729,7 +729,7 @@ impl From<OsString> for Rc<OsStr> {\n }\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n-impl<'a> From<&'a OsStr> for Rc<OsStr> {\n+impl From<&OsStr> for Rc<OsStr> {\n     #[inline]\n     fn from(s: &OsStr) -> Rc<OsStr> {\n         let rc = s.inner.into_rc();"}, {"sha": "ea3fcd8ce28597df108ef63dd077a81c4245240f", "filename": "src/libstd/path.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -1456,8 +1456,8 @@ impl PathBuf {\n }\n \n #[stable(feature = \"box_from_path\", since = \"1.17.0\")]\n-impl<'a> From<&'a Path> for Box<Path> {\n-    fn from(path: &'a Path) -> Box<Path> {\n+impl From<&Path> for Box<Path> {\n+    fn from(path: &Path) -> Box<Path> {\n         let boxed: Box<OsStr> = path.inner.into();\n         let rw = Box::into_raw(boxed) as *mut Path;\n         unsafe { Box::from_raw(rw) }\n@@ -1494,8 +1494,8 @@ impl Clone for Box<Path> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized + AsRef<OsStr>> From<&'a T> for PathBuf {\n-    fn from(s: &'a T) -> PathBuf {\n+impl<T: ?Sized + AsRef<OsStr>> From<&T> for PathBuf {\n+    fn from(s: &T) -> PathBuf {\n         PathBuf::from(s.as_ref().to_os_string())\n     }\n }\n@@ -1630,7 +1630,7 @@ impl From<PathBuf> for Arc<Path> {\n }\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n-impl<'a> From<&'a Path> for Arc<Path> {\n+impl From<&Path> for Arc<Path> {\n     /// Converts a Path into a Rc by copying the Path data into a new Rc buffer.\n     #[inline]\n     fn from(s: &Path) -> Arc<Path> {\n@@ -1650,7 +1650,7 @@ impl From<PathBuf> for Rc<Path> {\n }\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n-impl<'a> From<&'a Path> for Rc<Path> {\n+impl From<&Path> for Rc<Path> {\n     /// Converts a Path into a Rc by copying the Path data into a new Rc buffer.\n     #[inline]\n     fn from(s: &Path) -> Rc<Path> {"}, {"sha": "6d2a4962ab44467959c8914341a42db69339d70d", "filename": "src/libstd/sys/cloudabi/shims/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -297,10 +297,10 @@ impl Iterator for LookupHost {\n     }\n }\n \n-impl<'a> TryFrom<&'a str> for LookupHost {\n+impl TryFrom<&str> for LookupHost {\n     type Error = io::Error;\n \n-    fn try_from(_v: &'a str) -> io::Result<LookupHost> {\n+    fn try_from(_v: &str) -> io::Result<LookupHost> {\n         unsupported()\n     }\n }"}, {"sha": "dbaa140ed8a0f9c39a1aa940b6cb0c5367999ced", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -35,7 +35,7 @@ impl Iterator for LookupHost {\n     }\n }\n \n-impl<'a> TryFrom<&'a str> for LookupHost {\n+impl TryFrom<&str> for LookupHost {\n     type Error = io::Error;\n \n     fn try_from(s: &str) -> io::Result<LookupHost> {"}, {"sha": "e5e42e3d0b04867cb5309797df653cbaa10e0800", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -420,10 +420,10 @@ impl Iterator for LookupHost {\n     }\n }\n \n-impl<'a> TryFrom<&'a str> for LookupHost {\n+impl TryFrom<&str> for LookupHost {\n     type Error = io::Error;\n \n-    fn try_from(v: &'a str) -> io::Result<LookupHost> {\n+    fn try_from(v: &str) -> io::Result<LookupHost> {\n         LookupHost::new(v.to_owned())\n     }\n }"}, {"sha": "b9e725371a36edcd9494779549f54777e193df34", "filename": "src/libstd/sys/unix/l4re.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -447,10 +447,10 @@ pub mod net {\n     unsafe impl Send for LookupHost {}\n \n \n-    impl<'a> TryFrom<&'a str> for LookupHost {\n+    impl TryFrom<&str> for LookupHost {\n         type Error = io::Error;\n \n-        fn try_from(_v: &'a str) -> io::Result<LookupHost> {\n+        fn try_from(_v: &str) -> io::Result<LookupHost> {\n             unimpl!();\n         }\n     }"}, {"sha": "a2ea2dfbbc0326d13a12f1a86212d110354d12b5", "filename": "src/libstd/sys/wasm/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -298,10 +298,10 @@ impl Iterator for LookupHost {\n     }\n }\n \n-impl<'a> TryFrom<&'a str> for LookupHost {\n+impl TryFrom<&str> for LookupHost {\n     type Error = io::Error;\n \n-    fn try_from(_v: &'a str) -> io::Result<LookupHost> {\n+    fn try_from(_v: &str) -> io::Result<LookupHost> {\n         unsupported()\n     }\n }"}, {"sha": "b9505aaa69ba59b4785ac9546fd1c1c66bc0c639", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -157,7 +157,7 @@ impl Drop for LookupHost {\n     }\n }\n \n-impl<'a> TryFrom<&'a str> for LookupHost {\n+impl TryFrom<&str> for LookupHost {\n     type Error = io::Error;\n \n     fn try_from(s: &str) -> io::Result<LookupHost> {"}, {"sha": "01e3b2929031896a97fdcec9a0b058e8d94b3f93", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -1423,15 +1423,17 @@ impl<'a> StringReader<'a> {\n \n                 // If the character is an ident start not followed by another single\n                 // quote, then this is a lifetime name:\n-                if ident_start(Some(c2)) && !self.ch_is('\\'') {\n+                if (ident_start(Some(c2)) || c2.is_numeric()) && !self.ch_is('\\'') {\n                     while ident_continue(self.ch) {\n                         self.bump();\n                     }\n                     // lifetimes shouldn't end with a single quote\n                     // if we find one, then this is an invalid character literal\n                     if self.ch_is('\\'') {\n-                        self.err_span_(start_with_quote, self.next_pos,\n-                                \"character literal may only contain one codepoint\");\n+                        self.err_span_(\n+                            start_with_quote,\n+                            self.next_pos,\n+                            \"character literal may only contain one codepoint\");\n                         self.bump();\n                         return Ok(token::Literal(token::Err(Symbol::intern(\"??\")), None))\n \n@@ -1444,6 +1446,15 @@ impl<'a> StringReader<'a> {\n                         self.mk_ident(&format!(\"'{}\", lifetime_name))\n                     });\n \n+                    if c2.is_numeric() {\n+                        // this is a recovered lifetime written `'1`, error but accept it\n+                        self.err_span_(\n+                            start_with_quote,\n+                            self.pos,\n+                            \"lifetimes cannot start with a number\",\n+                        );\n+                    }\n+\n                     return Ok(token::Lifetime(ident));\n                 }\n \n@@ -1873,6 +1884,7 @@ fn is_block_doc_comment(s: &str) -> bool {\n     res\n }\n \n+/// Determine whether `c` is a valid start for an ident.\n fn ident_start(c: Option<char>) -> bool {\n     let c = match c {\n         Some(c) => c,"}, {"sha": "498e315b5c83cf4cef698f15596353ee8612eed8", "filename": "src/test/ui/associated-const/associated-const-generic-obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-generic-obligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-generic-obligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-generic-obligations.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -12,7 +12,7 @@ trait Bar: Foo {\n \n impl<T: Foo> Bar for T {\n     const FROM: &'static str = \"foo\";\n-    //~^ ERROR the trait bound `T: Foo` is not satisfied [E0277]\n+    //~^ ERROR implemented const `FROM` has an incompatible type for trait [E0326]\n }\n \n fn main() {}"}, {"sha": "eeee26a75671f062f261caad1ad139a4038c98a8", "filename": "src/test/ui/associated-const/associated-const-generic-obligations.stderr", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-generic-obligations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-generic-obligations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-generic-obligations.stderr?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -1,11 +1,15 @@\n-error[E0277]: the trait bound `T: Foo` is not satisfied\n-  --> $DIR/associated-const-generic-obligations.rs:14:5\n+error[E0326]: implemented const `FROM` has an incompatible type for trait\n+  --> $DIR/associated-const-generic-obligations.rs:14:17\n    |\n+LL |     const FROM: Self::Out;\n+   |                 --------- type in trait\n+...\n LL |     const FROM: &'static str = \"foo\";\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `T`\n+   |                 ^^^^^^^^^^^^ expected associated type, found reference\n    |\n-   = help: consider adding a `where T: Foo` bound\n+   = note: expected type `<T as Foo>::Out`\n+              found type `&'static str`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0326`."}, {"sha": "0ce46d312afef865384080ab5011269b954719a9", "filename": "src/test/ui/associated-const/associated-const-trait-bound.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-trait-bound.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -0,0 +1,21 @@\n+// compile-pass\n+\n+trait ConstDefault {\n+    const DEFAULT: Self;\n+}\n+\n+trait Foo: Sized {}\n+\n+trait FooExt: Foo {\n+    type T: ConstDefault;\n+}\n+\n+trait Bar<F: FooExt> {\n+    const T: F::T;\n+}\n+\n+impl<F: FooExt> Bar<F> for () {\n+    const T: F::T = <F::T as ConstDefault>::DEFAULT;\n+}\n+\n+fn main() {}"}, {"sha": "df11800731c72bb3d1b661c0f54911767190bcb4", "filename": "src/test/ui/generator/issue-53548-1.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fgenerator%2Fissue-53548-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fgenerator%2Fissue-53548-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-53548-1.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -0,0 +1,20 @@\n+// A variant of #53548 that does not actually require generators,\n+// but which encountered the same ICE/error. See `issue-53548.rs`\n+// for details.\n+//\n+// compile-pass\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+trait Trait: 'static {}\n+\n+struct Store<C> {\n+    inner: Rc<RefCell<Option<C>>>,\n+}\n+\n+fn main() {\n+    let store = Store::<Box<for<'a> fn(&(dyn Trait + 'a))>> {\n+        inner: Default::default(),\n+    };\n+}"}, {"sha": "00fdb91faab760fd6ad19928f6ab1d3f5459daf3", "filename": "src/test/ui/generator/issue-53548.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fgenerator%2Fissue-53548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fgenerator%2Fissue-53548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-53548.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -0,0 +1,39 @@\n+// Regression test for #53548. The `Box<dyn Trait>` type below is\n+// expanded to `Box<dyn Trait + 'static>`, but the generator \"witness\"\n+// that results is `for<'r> { Box<dyn Trait + 'r> }`. The WF code was\n+// encountering an ICE (when debug-assertions were enabled) and an\n+// unexpected compilation error (without debug-asserions) when trying\n+// to process this `'r` region bound. In particular, to be WF, the\n+// region bound must meet the requirements of the trait, and hence we\n+// got `for<'r> { 'r: 'static }`. This would ICE because the `Binder`\n+// constructor we were using was assering that no higher-ranked\n+// regions were involved (because the WF code is supposed to skip\n+// those). The error (if debug-asserions were disabled) came because\n+// we obviously cannot prove that `'r: 'static` for any region `'r`.\n+// Pursuant with our \"lazy WF\" strategy for higher-ranked regions, the\n+// fix is not to require that `for<'r> { 'r: 'static }` holds (this is\n+// also analogous to what we would do for higher-ranked regions\n+// appearing within the trait in other positions).\n+//\n+// compile-pass\n+\n+#![feature(generators)]\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+trait Trait: 'static {}\n+\n+struct Store<C> {\n+    inner: Rc<RefCell<Option<C>>>,\n+}\n+\n+fn main() {\n+    Box::new(static move || {\n+        let store = Store::<Box<dyn Trait>> {\n+            inner: Default::default(),\n+        };\n+        yield ();\n+    });\n+}\n+"}, {"sha": "a2736d97308afcadd7ae6b1ce8416e8e7400f120", "filename": "src/test/ui/lint/lint-dead-code-impl-trait.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Flint%2Flint-dead-code-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Flint%2Flint-dead-code-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-dead-code-impl-trait.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -0,0 +1,18 @@\n+#![deny(dead_code)]\n+\n+trait Trait {\n+    type Type;\n+}\n+\n+impl Trait for () {\n+    type Type = ();\n+}\n+\n+type Used = ();\n+type Unused = (); //~ ERROR type alias is never used\n+\n+fn foo() -> impl Trait<Type = Used> {}\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "61d0954bf31466dc61b05e628356d90f3873eb95", "filename": "src/test/ui/lint/lint-dead-code-impl-trait.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Flint%2Flint-dead-code-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Flint%2Flint-dead-code-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-dead-code-impl-trait.stderr?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -0,0 +1,14 @@\n+error: type alias is never used: `Unused`\n+  --> $DIR/lint-dead-code-impl-trait.rs:12:1\n+   |\n+LL | type Unused = ();\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-dead-code-impl-trait.rs:1:9\n+   |\n+LL | #![deny(dead_code)]\n+   |         ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "31dc58185e90ab0bb38d941c68c74915e785438d", "filename": "src/test/ui/nll/trait-associated-constant.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -9,24 +9,23 @@ trait Anything<'a: 'b, 'b> {\n     const AC: Option<&'b str>;\n }\n \n-struct OKStruct { }\n+struct OKStruct1 { }\n \n-impl<'a: 'b, 'b> Anything<'a, 'b> for OKStruct {\n+impl<'a: 'b, 'b> Anything<'a, 'b> for OKStruct1 {\n     const AC: Option<&'b str> = None;\n }\n \n-struct FailStruct1 { }\n+struct FailStruct { }\n \n-impl<'a: 'b, 'b, 'c> Anything<'a, 'b> for FailStruct1 {\n+impl<'a: 'b, 'b, 'c> Anything<'a, 'b> for FailStruct {\n     const AC: Option<&'c str> = None;\n     //~^ ERROR: mismatched types\n }\n \n-struct FailStruct2 { }\n+struct OKStruct2 { }\n \n-impl<'a: 'b, 'b> Anything<'a, 'b> for FailStruct2 {\n+impl<'a: 'b, 'b> Anything<'a, 'b> for OKStruct2 {\n     const AC: Option<&'a str> = None;\n-    //~^ ERROR: mismatched types\n }\n \n fn main() {}"}, {"sha": "f39f668e2329a5c61ad69b7eb5008321335e29a9", "filename": "src/test/ui/nll/trait-associated-constant.stderr", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -9,33 +9,14 @@ LL |     const AC: Option<&'c str> = None;\n note: the lifetime 'c as defined on the impl at 20:18...\n   --> $DIR/trait-associated-constant.rs:20:18\n    |\n-LL | impl<'a: 'b, 'b, 'c> Anything<'a, 'b> for FailStruct1 {\n+LL | impl<'a: 'b, 'b, 'c> Anything<'a, 'b> for FailStruct {\n    |                  ^^\n note: ...does not necessarily outlive the lifetime 'b as defined on the impl at 20:14\n   --> $DIR/trait-associated-constant.rs:20:14\n    |\n-LL | impl<'a: 'b, 'b, 'c> Anything<'a, 'b> for FailStruct1 {\n+LL | impl<'a: 'b, 'b, 'c> Anything<'a, 'b> for FailStruct {\n    |              ^^\n \n-error[E0308]: mismatched types\n-  --> $DIR/trait-associated-constant.rs:28:5\n-   |\n-LL |     const AC: Option<&'a str> = None;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected type `std::option::Option<&'b str>`\n-              found type `std::option::Option<&'a str>`\n-note: the lifetime 'a as defined on the impl at 27:6...\n-  --> $DIR/trait-associated-constant.rs:27:6\n-   |\n-LL | impl<'a: 'b, 'b> Anything<'a, 'b> for FailStruct2 {\n-   |      ^^\n-note: ...does not necessarily outlive the lifetime 'b as defined on the impl at 27:14\n-  --> $DIR/trait-associated-constant.rs:27:14\n-   |\n-LL | impl<'a: 'b, 'b> Anything<'a, 'b> for FailStruct2 {\n-   |              ^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "2d82354c62cca706fa9c17c35ed5b5f7e3575034", "filename": "src/test/ui/parser/numeric-lifetime.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fparser%2Fnumeric-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fparser%2Fnumeric-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnumeric-lifetime.rs?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -0,0 +1,8 @@\n+struct S<'1> { s: &'1 usize }\n+//~^ ERROR lifetimes cannot start with a number\n+//~| ERROR lifetimes cannot start with a number\n+fn main() {\n+    // verify that the parse error doesn't stop type checking\n+    let x: usize = \"\";\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "4018b24aac17590e35f84c65f185e150e806323e", "filename": "src/test/ui/parser/numeric-lifetime.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fparser%2Fnumeric-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa97448caf49ee25271a5ad58482283404b9144f/src%2Ftest%2Fui%2Fparser%2Fnumeric-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnumeric-lifetime.stderr?ref=aa97448caf49ee25271a5ad58482283404b9144f", "patch": "@@ -0,0 +1,24 @@\n+error: lifetimes cannot start with a number\n+  --> $DIR/numeric-lifetime.rs:1:10\n+   |\n+LL | struct S<'1> { s: &'1 usize }\n+   |          ^^\n+\n+error: lifetimes cannot start with a number\n+  --> $DIR/numeric-lifetime.rs:1:20\n+   |\n+LL | struct S<'1> { s: &'1 usize }\n+   |                    ^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-lifetime.rs:6:20\n+   |\n+LL |     let x: usize = \"\";\n+   |                    ^^ expected usize, found reference\n+   |\n+   = note: expected type `usize`\n+              found type `&'static str`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}