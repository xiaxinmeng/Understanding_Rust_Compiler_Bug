{"sha": "e2c821d35ee5cb5211f92480a53b409b2b2c359e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYzgyMWQzNWVlNWNiNTIxMWY5MjQ4MGE1M2I0MDliMmIyYzM1OWU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-04-16T15:05:06Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-04-24T17:59:44Z"}, "message": "syntax: Make static/super/self/Self keywords + special ident cleanup", "tree": {"sha": "f4abbb16e9b02d26998e05a3566402f92233c852", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4abbb16e9b02d26998e05a3566402f92233c852"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2c821d35ee5cb5211f92480a53b409b2b2c359e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2c821d35ee5cb5211f92480a53b409b2b2c359e", "html_url": "https://github.com/rust-lang/rust/commit/e2c821d35ee5cb5211f92480a53b409b2b2c359e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2c821d35ee5cb5211f92480a53b409b2b2c359e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "546c052d225d41cd31f610e87a20f15cd0fa8e3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/546c052d225d41cd31f610e87a20f15cd0fa8e3c", "html_url": "https://github.com/rust-lang/rust/commit/546c052d225d41cd31f610e87a20f15cd0fa8e3c"}], "stats": {"total": 326, "additions": 138, "deletions": 188}, "files": [{"sha": "ae8ef00eb6a506172ffdf9a2059cc1d36fa5e579", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -867,7 +867,7 @@ pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span,\n     let config = folder.fold_meta_items(config);\n \n     let crate_mod = folder.fold_item(hir::Item {\n-        name: token::special_idents::invalid.name,\n+        name: token::special_idents::Invalid.name,\n         attrs: attrs,\n         id: DUMMY_NODE_ID,\n         vis: hir::Public,"}, {"sha": "04bd32732b6f68c827645f1db5e989aba07405de", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -2211,7 +2211,7 @@ impl<'a> State<'a> {\n                 match input.pat.node {\n                     PatKind::Ident(_, ref path1, _) if\n                         path1.node.name ==\n-                            parse::token::special_idents::invalid.name => {\n+                            parse::token::special_idents::Invalid.name => {\n                         // Do nothing.\n                     }\n                     _ => {"}, {"sha": "63eebd9d5ab7b5be9bd9df36988d01a133736e9a", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -125,7 +125,7 @@ use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n use syntax::codemap::{BytePos, original_sp, Span};\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::keywords;\n use syntax::ptr::P;\n \n use hir::Expr;\n@@ -1578,7 +1578,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self.\n                 let name = path1.node;\n-                if name != special_idents::self_.name {\n+                if name != keywords::SelfValue.ident.name {\n                     if !self.warn_about_unused(sp, p_id, entry_ln, var) {\n                         if self.live_on_entry(entry_ln, var).is_none() {\n                             self.report_dead_assign(p_id, sp, var, true);"}, {"sha": "54986a629f007297d093e74ecf87ea970859445b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-        if lifetime_ref.name == special_idents::static_lifetime.name {\n+        if lifetime_ref.name == special_idents::StaticLifetime.name {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;\n         }\n@@ -672,9 +672,8 @@ impl<'a> LifetimeContext<'a> {\n         for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n \n-            let special_idents = [special_idents::static_lifetime];\n             for lifetime in lifetimes {\n-                if special_idents.iter().any(|&i| i.name == lifetime.lifetime.name) {\n+                if lifetime.lifetime.name == special_idents::StaticLifetime.name {\n                     span_err!(self.sess, lifetime.lifetime.span, E0262,\n                         \"invalid lifetime parameter name: `{}`\", lifetime.lifetime.name);\n                 }"}, {"sha": "a5220cfbf8a91550bb121bb2a229f288e5d2975f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -44,7 +44,7 @@ use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::parse::token::{self, special_idents};\n+use syntax::parse::token::{self, keywords};\n \n use hir;\n \n@@ -1069,7 +1069,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn mk_self_type(&self) -> Ty<'tcx> {\n-        self.mk_param(subst::SelfSpace, 0, special_idents::type_self.name)\n+        self.mk_param(subst::SelfSpace, 0, keywords::SelfType.ident.name)\n     }\n \n     pub fn mk_param_from_def(&self, def: &ty::TypeParameterDef) -> Ty<'tcx> {"}, {"sha": "623595b36cc381e85177d757d013d1584d88992a", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -24,7 +24,7 @@ use std::ops;\n use std::mem;\n use syntax::abi;\n use syntax::ast::{self, Name};\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::keywords;\n \n use serialize::{Decodable, Decoder};\n \n@@ -533,7 +533,7 @@ impl ParamTy {\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(subst::SelfSpace, 0, special_idents::type_self.name)\n+        ParamTy::new(subst::SelfSpace, 0, keywords::SelfType.ident.name)\n     }\n \n     pub fn for_def(def: &ty::TypeParameterDef) -> ParamTy {"}, {"sha": "bc09cfdb5837c09aa1ea85604c6b85cb0d88be66", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -62,7 +62,7 @@ use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, Pos};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::parse::token::{self, special_names, special_idents};\n+use syntax::parse::token::{self, keywords, special_idents};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc::hir::intravisit::{self, FnKind, Visitor};\n@@ -1954,8 +1954,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // plain insert (no renaming, types are not currently hygienic....)\n-        let name = special_names::type_self;\n-        self_type_rib.bindings.insert(name, self_def);\n+        self_type_rib.bindings.insert(keywords::SelfType.ident.name, self_def);\n         self.type_ribs.push(self_type_rib);\n         f(self);\n         if !self.resolved {\n@@ -2195,11 +2194,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             \"type name\"\n                         };\n \n-                        let self_type_name = special_idents::type_self.name;\n                         let is_invalid_self_type_name = path.segments.len() > 0 &&\n                                                         maybe_qself.is_none() &&\n                                                         path.segments[0].identifier.name ==\n-                                                        self_type_name;\n+                                                        keywords::SelfType.ident.name;\n                         if is_invalid_self_type_name {\n                             resolve_error(self,\n                                           ty.span,\n@@ -2643,7 +2641,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                           namespace: Namespace,\n                           record_used: bool)\n                           -> Option<LocalDef> {\n-        if identifier.name == special_idents::invalid.name {\n+        if identifier.name == special_idents::Invalid.name {\n             return Some(LocalDef::from_def(Def::Err));\n         }\n \n@@ -3074,7 +3072,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 false // Stop advancing\n                             });\n \n-                            if method_scope && special_names::self_.as_str() == &path_name[..] {\n+                            if method_scope &&\n+                                    &path_name[..] == keywords::SelfValue.ident.name.as_str() {\n                                 resolve_error(self,\n                                               expr.span,\n                                               ResolutionError::SelfNotAvailableInStaticMethod);\n@@ -3612,7 +3611,7 @@ fn module_to_string(module: Module) -> String {\n             }\n             BlockParentLink(ref module, _) => {\n                 // danger, shouldn't be ident?\n-                names.push(special_idents::opaque.name);\n+                names.push(token::intern(\"<opaque>\"));\n                 collect_mod(names, module);\n             }\n         }"}, {"sha": "6118033e1fd6e2a4573fd5470bc00ea603aef891", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -1011,7 +1011,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                                 span: sub_span.expect(\"No span found for use\"),\n                                 id: item.id,\n                                 mod_id: mod_id,\n-                                name: ident.name.to_string(),\n+                                name: ident.to_string(),\n                                 scope: self.cur_scope\n                             }.normalize(&self.tcx));\n                         }\n@@ -1075,7 +1075,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 if !self.span.filter_generated(alias_span, item.span) {\n                     self.dumper.extern_crate(item.span, ExternCrateData {\n                         id: item.id,\n-                        name: item.ident.name.to_string(),\n+                        name: item.ident.to_string(),\n                         crate_num: cnum,\n                         location: location,\n                         span: alias_span.expect(\"No span found for extern crate\"),"}, {"sha": "d5d58c81b4f4e258ac5b7171b93d809a200b9e3c", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -286,7 +286,7 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                         alloca: lltemp,\n                         address_operations: &ops\n                     };\n-                    declare_local(bcx, token::special_idents::invalid.name,\n+                    declare_local(bcx, token::special_idents::Invalid.name,\n                                   tupled_arg_ty, scope, variable_access,\n                                   VariableKind::ArgumentVariable(arg_index + i + 1),\n                                   bcx.fcx().span.unwrap_or(DUMMY_SP));"}, {"sha": "d3baa349d76db9afdf245ae92d5fbaf02f318af5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -1313,7 +1313,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             let trait_node_id = tcx.map.as_local_node_id(trait_did).unwrap();\n             match find_bound_for_assoc_item(this,\n                                             trait_node_id,\n-                                            token::special_idents::type_self.name,\n+                                            token::keywords::SelfType.ident.name,\n                                             assoc_name,\n                                             span) {\n                 Ok(bound) => bound,"}, {"sha": "d63cabb1f93957a5b3b09dd2e2bc9745fbf3bd05", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -2851,7 +2851,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 method_ty\n             }\n             Err(error) => {\n-                if method_name.node != special_idents::invalid.name {\n+                if method_name.node != special_idents::Invalid.name {\n                     method::report_error(fcx, method_name.span, expr_t,\n                                          method_name.node, Some(rcvr), error);\n                 }\n@@ -2990,7 +2990,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let msg = format!(\"field `{}` of struct `{}` is private\", field.node, struct_path);\n             fcx.tcx().sess.span_err(expr.span, &msg);\n             fcx.write_ty(expr.id, field_ty);\n-        } else if field.node == special_idents::invalid.name {\n+        } else if field.node == special_idents::Invalid.name {\n             fcx.write_error(expr.id);\n         } else if method::exists(fcx, field.span, field.node, expr_t, expr.id) {\n             fcx.type_error_struct(field.span,\n@@ -3780,7 +3780,7 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n                     method::MethodError::PrivateMatch(def) => Some(def),\n                     _ => None,\n                 };\n-                if item_name != special_idents::invalid.name {\n+                if item_name != special_idents::Invalid.name {\n                     method::report_error(fcx, span, ty, item_name, None, error);\n                 }\n                 def"}, {"sha": "ad411396be096bd3afd626887c2adab3f5ea882c", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -24,7 +24,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::codemap::{Span};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::parse::token::{special_idents};\n+use syntax::parse::token::keywords;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir;\n \n@@ -472,7 +472,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         let name = match space {\n             TypeSpace => ast_generics.ty_params[index].name,\n-            SelfSpace => special_idents::type_self.name,\n+            SelfSpace => keywords::SelfType.ident.name,\n             FnSpace => bug!(\"Fn space occupied?\"),\n         };\n "}, {"sha": "d2b50a0da119f2de2e69444a4c15f683ea4af6ba", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -93,7 +93,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::keywords;\n use syntax::ptr::P;\n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit;\n@@ -1655,7 +1655,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let def = ty::TypeParameterDef {\n         space: SelfSpace,\n         index: 0,\n-        name: special_idents::type_self.name,\n+        name: keywords::SelfType.ident.name,\n         def_id: ccx.tcx.map.local_def_id(param_id),\n         default_def_id: ccx.tcx.map.local_def_id(parent),\n         default: None,"}, {"sha": "d1c155fb97dea59920aa54db1fdf1b53d7de269d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -31,7 +31,7 @@ use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap;\n use syntax::codemap::{DUMMY_SP, Pos, Spanned};\n-use syntax::parse::token::{self, InternedString, special_idents};\n+use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n \n use rustc_trans::back::link;\n@@ -2666,7 +2666,7 @@ fn resolve_type(cx: &DocContext,\n             hir::TyFloat(ast::FloatTy::F64) => return Primitive(F64),\n         },\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(special_idents::type_self.name.to_string());\n+            return Generic(keywords::SelfType.ident.to_string());\n         }\n         Def::SelfTy(..) | Def::TyParam(..) => true,\n         _ => false,"}, {"sha": "6bcd8085315a279edbdd243b46fbb91d408f9a59", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -93,7 +93,7 @@ impl Ident {\n     pub fn new(name: Name, ctxt: SyntaxContext) -> Ident {\n         Ident {name: name, ctxt: ctxt}\n     }\n-    pub fn with_empty_ctxt(name: Name) -> Ident {\n+    pub const fn with_empty_ctxt(name: Name) -> Ident {\n         Ident {name: name, ctxt: EMPTY_CTXT}\n     }\n }"}, {"sha": "c234ea3afebe49b949a61fc879a467b9cd1309c2", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -13,7 +13,7 @@ use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n use attr;\n use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n use ext::base::ExtCtxt;\n-use parse::token::special_idents;\n+use parse::token::{keywords, special_idents};\n use parse::token::InternedString;\n use parse::token;\n use ptr::P;\n@@ -602,7 +602,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     fn expr_self(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_ident(span, special_idents::self_)\n+        self.expr_ident(span, keywords::SelfValue.ident)\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n@@ -1132,7 +1132,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item> {\n         P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n-            ident: special_idents::invalid,\n+            ident: special_idents::Invalid,\n             attrs: vec![],\n             node: ast::ItemKind::Use(vp),\n             vis: vis,"}, {"sha": "3fe4913b5bba90d9c8b979f2c9ccf707ad760f7d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -380,7 +380,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n \n             Some(rc) => match *rc {\n                 NormalTT(ref expander, tt_span, allow_internal_unstable) => {\n-                    if ident.name != parse::token::special_idents::invalid.name {\n+                    if ident.name != parse::token::special_idents::Invalid.name {\n                         fld.cx\n                             .span_err(path_span,\n                                       &format!(\"macro {}! expects no ident argument, given '{}'\",\n@@ -401,7 +401,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     expander.expand(fld.cx, span, &marked_before[..])\n                 }\n                 IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n-                    if ident.name == parse::token::special_idents::invalid.name {\n+                    if ident.name == parse::token::special_idents::Invalid.name {\n                         fld.cx.span_err(path_span,\n                                         &format!(\"macro {}! expects an ident argument\",\n                                                 extname));\n@@ -420,7 +420,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     expander.expand(fld.cx, span, ident, marked_tts)\n                 }\n                 MacroRulesTT => {\n-                    if ident.name == parse::token::special_idents::invalid.name {\n+                    if ident.name == parse::token::special_idents::Invalid.name {\n                         fld.cx.span_err(path_span, \"macro_rules! expects an ident argument\");\n                         return SmallVector::zero();\n                     }\n@@ -893,7 +893,7 @@ fn expand_annotatable(a: Annotatable,\n             }\n             ast::ItemKind::Mod(_) | ast::ItemKind::ForeignMod(_) => {\n                 let valid_ident =\n-                    it.ident.name != parse::token::special_idents::invalid.name;\n+                    it.ident.name != parse::token::special_idents::Invalid.name;\n \n                 if valid_ident {\n                     fld.cx.mod_push(it.ident);\n@@ -1807,7 +1807,7 @@ mod tests {\n \n     // run one of the renaming tests\n     fn run_renaming_test(t: &RenamingTest, test_idx: usize) {\n-        let invalid_name = token::special_idents::invalid.name;\n+        let invalid_name = token::special_idents::Invalid.name;\n         let (teststr, bound_connections, bound_ident_check) = match *t {\n             (ref str,ref conns, bic) => (str.to_string(), conns.clone(), bic)\n         };"}, {"sha": "41d3991aee809a4feddf47314a6f486544e41dbf", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -17,7 +17,7 @@ use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::parse;\n use parse::lexer::new_tt_reader;\n use parse::parser::{Parser, Restrictions};\n-use parse::token::{self, special_idents, gensym_ident, NtTT, Token};\n+use parse::token::{self, gensym_ident, NtTT, Token};\n use parse::token::Token::*;\n use print;\n use ptr::P;\n@@ -244,8 +244,8 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     // $( $lhs:tt => $rhs:tt );+\n     // ...quasiquoting this would be nice.\n     // These spans won't matter, anyways\n-    let match_lhs_tok = MatchNt(lhs_nm, special_idents::tt);\n-    let match_rhs_tok = MatchNt(rhs_nm, special_idents::tt);\n+    let match_lhs_tok = MatchNt(lhs_nm, token::str_to_ident(\"tt\"));\n+    let match_rhs_tok = MatchNt(rhs_nm, token::str_to_ident(\"tt\"));\n     let argument_gram = vec!(\n         TokenTree::Sequence(DUMMY_SP,\n                    Rc::new(ast::SequenceRepetition {"}, {"sha": "ad95b96363efe9abfde29dc267c5b5fb8c0ee95f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -1015,7 +1015,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n     let config = folder.fold_meta_items(config);\n \n     let mut items = folder.fold_item(P(ast::Item {\n-        ident: token::special_idents::invalid,\n+        ident: token::special_idents::Invalid,\n         attrs: attrs,\n         id: ast::DUMMY_NODE_ID,\n         vis: ast::Visibility::Public,"}, {"sha": "f38720c3e5006aa52a1a16d02878bd71b66c631c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -25,6 +25,7 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(associated_consts)]\n+#![feature(const_fn)]\n #![feature(filling_drop)]\n #![feature(libc)]\n #![feature(rustc_private)]"}, {"sha": "2c82cbcb6c66a656123a37e918315924e922b2f5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -292,7 +292,7 @@ impl TokenType {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", Parser::token_to_string(t)),\n             TokenType::Operator => \"an operator\".to_string(),\n-            TokenType::Keyword(kw) => format!(\"`{}`\", kw.to_name()),\n+            TokenType::Keyword(kw) => format!(\"`{}`\", kw.ident.name),\n         }\n     }\n }\n@@ -562,9 +562,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        if !self.restrictions.contains(Restrictions::ALLOW_MODULE_PATHS) {\n-            self.check_strict_keywords();\n-        }\n+        self.check_used_keywords();\n         self.check_reserved_keywords();\n         match self.token {\n             token::Ident(i) => {\n@@ -658,8 +656,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Signal an error if the given string is a strict keyword\n-    pub fn check_strict_keywords(&mut self) {\n-        if self.token.is_strict_keyword() {\n+    pub fn check_used_keywords(&mut self) {\n+        if self.token.is_used_keyword() {\n             let token_str = self.this_token_to_string();\n             let span = self.span;\n             self.span_err(span,\n@@ -1553,7 +1551,7 @@ impl<'a> Parser<'a> {\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n             let sp = self.last_span;\n-            let spanned = Spanned { span: sp, node: special_idents::invalid };\n+            let spanned = Spanned { span: sp, node: special_idents::Invalid };\n             P(Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable),\n@@ -2335,7 +2333,7 @@ impl<'a> Parser<'a> {\n                     }\n                     hi = self.last_span.hi;\n                 } else if self.token.is_keyword(keywords::Let) {\n-                    // Catch this syntax error here, instead of in `check_strict_keywords`, so\n+                    // Catch this syntax error here, instead of in `check_used_keywords`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n                     let mut db = self.fatal(\"expected expression, found statement (`let`)\");\n                     db.note(\"variable declaration using `let` is a statement\");\n@@ -2618,7 +2616,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n \n                     let dot_pos = self.last_span.hi;\n-                    e = self.parse_dot_suffix(special_idents::invalid,\n+                    e = self.parse_dot_suffix(special_idents::Invalid,\n                                               mk_sp(dot_pos, dot_pos),\n                                               e, lo)?;\n                   }\n@@ -2696,7 +2694,7 @@ impl<'a> Parser<'a> {\n         };\n         // continue by trying to parse the `:ident` after `$name`\n         if self.token == token::Colon && self.look_ahead(1, |t| t.is_ident() &&\n-                                                                !t.is_strict_keyword() &&\n+                                                                !t.is_used_keyword() &&\n                                                                 !t.is_reserved_keyword()) {\n             self.bump();\n             sp = mk_sp(sp.lo, self.span.hi);\n@@ -3942,7 +3940,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n \n             let id = match self.token {\n-                token::OpenDelim(_) => token::special_idents::invalid, // no special identifier\n+                token::OpenDelim(_) => token::special_idents::Invalid, // no special identifier\n                 _ => self.parse_ident()?,\n             };\n \n@@ -3954,7 +3952,7 @@ impl<'a> Parser<'a> {\n                 _ => {\n                     // we only expect an ident if we didn't parse one\n                     // above.\n-                    let ident_str = if id.name == token::special_idents::invalid.name {\n+                    let ident_str = if id.name == token::special_idents::Invalid.name {\n                         \"identifier, \"\n                     } else {\n                         \"\"\n@@ -3980,7 +3978,7 @@ impl<'a> Parser<'a> {\n                 MacStmtStyle::NoBraces\n             };\n \n-            if id.name == token::special_idents::invalid.name {\n+            if id.name == token::special_idents::Invalid.name {\n                 let mac = P(spanned(lo, hi, Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT }));\n                 let stmt = StmtKind::Mac(mac, style, attrs.into_thin_attrs());\n                 spanned(lo, hi, stmt)\n@@ -4610,8 +4608,10 @@ impl<'a> Parser<'a> {\n \n     fn expect_self_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token {\n-            token::Ident(id) if id.name == special_idents::self_.name => {\n+            token::Ident(id) if id.name == keywords::SelfValue.ident.name => {\n                 self.bump();\n+                // The hygiene context of `id` needs to be preserved here,\n+                // so we can't just return `SelfValue.ident`.\n                 Ok(id)\n             },\n             _ => {\n@@ -4696,7 +4696,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                 }\n                 // error case, making bogus self ident:\n-                SelfKind::Value(special_idents::self_)\n+                SelfKind::Value(keywords::SelfValue.ident)\n             }\n             token::Ident(..) => {\n                 if self.token.is_keyword(keywords::SelfValue) {\n@@ -4971,7 +4971,7 @@ impl<'a> Parser<'a> {\n             if delim != token::Brace {\n                 self.expect(&token::Semi)?\n             }\n-            Ok((token::special_idents::invalid, vec![], ast::ImplItemKind::Macro(m)))\n+            Ok((token::special_idents::Invalid, vec![], ast::ImplItemKind::Macro(m)))\n         } else {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n@@ -5066,7 +5066,7 @@ impl<'a> Parser<'a> {\n \n             self.expect(&token::OpenDelim(token::Brace))?;\n             self.expect(&token::CloseDelim(token::Brace))?;\n-            Ok((special_idents::invalid,\n+            Ok((special_idents::Invalid,\n              ItemKind::DefaultImpl(unsafety, opt_trait.unwrap()), None))\n         } else {\n             if opt_trait.is_some() {\n@@ -5082,7 +5082,7 @@ impl<'a> Parser<'a> {\n                 impl_items.push(self.parse_impl_item()?);\n             }\n \n-            Ok((special_idents::invalid,\n+            Ok((special_idents::Invalid,\n              ItemKind::Impl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n              Some(attrs)))\n         }\n@@ -5260,7 +5260,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse defaultness: DEFAULT or nothing\n     fn parse_defaultness(&mut self) -> PResult<'a, Defaultness> {\n-        if self.eat_contextual_keyword(special_idents::DEFAULT) {\n+        if self.eat_contextual_keyword(special_idents::Default) {\n             Ok(Defaultness::Default)\n         } else {\n             Ok(Defaultness::Final)\n@@ -5588,7 +5588,7 @@ impl<'a> Parser<'a> {\n         };\n         Ok(self.mk_item(lo,\n                      last_span.hi,\n-                     special_idents::invalid,\n+                     special_idents::Invalid,\n                      ItemKind::ForeignMod(m),\n                      visibility,\n                      attrs))\n@@ -5727,7 +5727,7 @@ impl<'a> Parser<'a> {\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n-                                    token::special_idents::invalid,\n+                                    token::special_idents::Invalid,\n                                     item_,\n                                     visibility,\n                                     attrs);\n@@ -6018,7 +6018,7 @@ impl<'a> Parser<'a> {\n             let id = if self.token.is_ident() {\n                 self.parse_ident()?\n             } else {\n-                token::special_idents::invalid // no special identifier\n+                token::special_idents::Invalid // no special identifier\n             };\n             // eat a matched-delimiter token tree:\n             let delim = self.expect_open_delim()?;"}, {"sha": "449a226874030cad03f6cedb74f15f7a6247a6ec", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 54, "deletions": 105, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -271,47 +271,39 @@ impl Token {\n     /// Returns `true` if the token is a given keyword, `kw`.\n     pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n         match *self {\n-            Ident(id) => id.name == kw.to_name(),\n+            Ident(id) => id.name == kw.ident.name,\n             _ => false,\n         }\n     }\n \n     pub fn is_path_segment_keyword(&self) -> bool {\n         match *self {\n-            Ident(id) => id.name == SUPER_KEYWORD_NAME ||\n-                         id.name == SELF_KEYWORD_NAME ||\n-                         id.name == SELF_TYPE_KEYWORD_NAME,\n+            Ident(id) => id.name == keywords::Super.ident.name ||\n+                         id.name == keywords::SelfValue.ident.name ||\n+                         id.name == keywords::SelfType.ident.name,\n             _ => false,\n         }\n     }\n \n-    /// Returns `true` if the token is either a strict or reserved keyword.\n+    /// Returns `true` if the token is either a used or reserved keyword.\n     pub fn is_any_keyword(&self) -> bool {\n         match *self {\n-            Ident(id) => id.name == SELF_KEYWORD_NAME ||\n-                         id.name == STATIC_KEYWORD_NAME ||\n-                         id.name == SUPER_KEYWORD_NAME ||\n-                         id.name == SELF_TYPE_KEYWORD_NAME ||\n-                         id.name >= STRICT_KEYWORD_START &&\n+            Ident(id) => id.name >= USED_KEYWORD_START &&\n                          id.name <= RESERVED_KEYWORD_FINAL,\n             _ => false\n         }\n     }\n \n-    /// Returns `true` if the token is either a strict keyword.\n-    pub fn is_strict_keyword(&self) -> bool {\n+    /// Returns `true` if the token is a used keyword.\n+    pub fn is_used_keyword(&self) -> bool {\n         match *self {\n-            Ident(id) => id.name == SELF_KEYWORD_NAME ||\n-                         id.name == STATIC_KEYWORD_NAME ||\n-                         id.name == SUPER_KEYWORD_NAME ||\n-                         id.name == SELF_TYPE_KEYWORD_NAME ||\n-                         id.name >= STRICT_KEYWORD_START &&\n-                         id.name <= STRICT_KEYWORD_FINAL,\n+            Ident(id) => id.name >= USED_KEYWORD_START &&\n+                         id.name <= USED_KEYWORD_FINAL,\n             _ => false,\n         }\n     }\n \n-    /// Returns `true` if the token is either a keyword reserved for possible future use.\n+    /// Returns `true` if the token is a keyword reserved for possible future use.\n     pub fn is_reserved_keyword(&self) -> bool {\n         match *self {\n             Ident(id) => id.name >= RESERVED_KEYWORD_START &&\n@@ -378,7 +370,6 @@ impl fmt::Debug for Nonterminal {\n     }\n }\n \n-\n // Get the first \"argument\"\n macro_rules! first {\n     ( $first:expr, $( $remainder:expr, )* ) => ( $first )\n@@ -392,122 +383,85 @@ macro_rules! last {\n \n // In this macro, there is the requirement that the name (the number) must be monotonically\n // increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n-// except starting from the next number instead of zero, and with the additional exception that\n-// special identifiers are *also* allowed (they are deduplicated in the important place, the\n-// interner), an exception which is demonstrated by \"static\" and \"self\".\n+// except starting from the next number instead of zero.\n macro_rules! declare_special_idents_and_keywords {(\n     // So now, in these rules, why is each definition parenthesised?\n     // Answer: otherwise we get a spurious local ambiguity bug on the \"}\"\n     pub mod special_idents {\n-        $( ($si_name:expr, $si_static:ident, $si_str:expr); )*\n+        $( ($si_index: expr, $si_const: ident, $si_str: expr); )*\n     }\n \n     pub mod keywords {\n-        'strict:\n-        $( ($sk_name:expr, $sk_variant:ident, $sk_str:expr); )*\n+        'used:\n+        $( ($ukw_index: expr, $ukw_const: ident, $ukw_str: expr); )*\n         'reserved:\n-        $( ($rk_name:expr, $rk_variant:ident, $rk_str:expr); )*\n+        $( ($rkw_index: expr, $rkw_const: ident, $rkw_str: expr); )*\n     }\n ) => {\n-    const STRICT_KEYWORD_START: ast::Name = first!($( ast::Name($sk_name), )*);\n-    const STRICT_KEYWORD_FINAL: ast::Name = last!($( ast::Name($sk_name), )*);\n-    const RESERVED_KEYWORD_START: ast::Name = first!($( ast::Name($rk_name), )*);\n-    const RESERVED_KEYWORD_FINAL: ast::Name = last!($( ast::Name($rk_name), )*);\n+    const USED_KEYWORD_START: ast::Name = first!($( ast::Name($ukw_index), )*);\n+    const USED_KEYWORD_FINAL: ast::Name = last!($( ast::Name($ukw_index), )*);\n+    const RESERVED_KEYWORD_START: ast::Name = first!($( ast::Name($rkw_index), )*);\n+    const RESERVED_KEYWORD_FINAL: ast::Name = last!($( ast::Name($rkw_index), )*);\n \n     pub mod special_idents {\n         use ast;\n         $(\n             #[allow(non_upper_case_globals)]\n-            pub const $si_static: ast::Ident = ast::Ident {\n-                name: ast::Name($si_name),\n-                ctxt: ast::EMPTY_CTXT,\n-            };\n-         )*\n-    }\n-\n-    pub mod special_names {\n-        use ast;\n-        $(\n-            #[allow(non_upper_case_globals)]\n-            pub const $si_static: ast::Name = ast::Name($si_name);\n+            pub const $si_const: ast::Ident = ast::Ident::with_empty_ctxt(ast::Name($si_index));\n         )*\n     }\n \n-    /// All the valid words that have meaning in the Rust language.\n-    ///\n-    /// Rust keywords are either 'strict' or 'reserved'.  Strict keywords may not\n-    /// appear as identifiers at all. Reserved keywords are not used anywhere in\n-    /// the language and may not appear as identifiers.\n+    /// Rust keywords are either 'used' in the language or 'reserved' for future use.\n     pub mod keywords {\n-        pub use self::Keyword::*;\n         use ast;\n-\n-        #[derive(Copy, Clone, PartialEq, Eq)]\n-        pub enum Keyword {\n-            $( $sk_variant, )*\n-            $( $rk_variant, )*\n-        }\n-\n-        impl Keyword {\n-            pub fn to_name(&self) -> ast::Name {\n-                match *self {\n-                    $( $sk_variant => ast::Name($sk_name), )*\n-                    $( $rk_variant => ast::Name($rk_name), )*\n-                }\n-            }\n+        #[derive(Clone, Copy, PartialEq, Eq)]\n+        pub struct Keyword {\n+            pub ident: ast::Ident,\n         }\n+        $(\n+            #[allow(non_upper_case_globals)]\n+            pub const $ukw_const: Keyword = Keyword {\n+                ident: ast::Ident::with_empty_ctxt(ast::Name($ukw_index))\n+            };\n+        )*\n+        $(\n+            #[allow(non_upper_case_globals)]\n+            pub const $rkw_const: Keyword = Keyword {\n+                ident: ast::Ident::with_empty_ctxt(ast::Name($rkw_index))\n+            };\n+        )*\n     }\n \n     fn mk_fresh_ident_interner() -> IdentInterner {\n-        let mut init_vec = Vec::new();\n-        $(init_vec.push($si_str);)*\n-        $(init_vec.push($sk_str);)*\n-        $(init_vec.push($rk_str);)*\n-        interner::StrInterner::prefill(&init_vec[..])\n+        interner::StrInterner::prefill(&[$($si_str,)* $($ukw_str,)* $($rkw_str,)*])\n     }\n }}\n \n-// If the special idents get renumbered, remember to modify these two as appropriate\n-pub const SELF_KEYWORD_NAME: ast::Name = ast::Name(SELF_KEYWORD_NAME_NUM);\n-const STATIC_KEYWORD_NAME: ast::Name = ast::Name(STATIC_KEYWORD_NAME_NUM);\n-pub const SUPER_KEYWORD_NAME: ast::Name = ast::Name(SUPER_KEYWORD_NAME_NUM);\n-const SELF_TYPE_KEYWORD_NAME: ast::Name = ast::Name(SELF_TYPE_KEYWORD_NAME_NUM);\n-\n-pub const SELF_KEYWORD_NAME_NUM: u32 = 1;\n-const STATIC_KEYWORD_NAME_NUM: u32 = 2;\n-const SUPER_KEYWORD_NAME_NUM: u32 = 3;\n-const SELF_TYPE_KEYWORD_NAME_NUM: u32 = 10;\n-\n // NB: leaving holes in the ident table is bad! a different ident will get\n // interned with the id from the hole, but it will be between the min and max\n // of the reserved words, and thus tagged as \"reserved\".\n \n declare_special_idents_and_keywords! {\n     pub mod special_idents {\n-        // These ones are statics\n-        (0,                          invalid,                \"\");\n-        (super::SELF_KEYWORD_NAME_NUM,   self_,              \"self\");\n-        (super::STATIC_KEYWORD_NAME_NUM, statik,             \"static\");\n-        (super::SUPER_KEYWORD_NAME_NUM, super_,              \"super\");\n-        (4,                          static_lifetime,        \"'static\");\n-\n-        // for matcher NTs\n-        (5,                          tt,                     \"tt\");\n-        (6,                          matchers,               \"matchers\");\n-\n-        // outside of libsyntax\n-        (7,                          clownshoe_abi,          \"__rust_abi\");\n-        (8,                          opaque,                 \"<opaque>\");\n-        (9,                          __unused1,              \"<__unused1>\");\n-        (super::SELF_TYPE_KEYWORD_NAME_NUM, type_self,       \"Self\");\n-        (11,                         prelude_import,         \"prelude_import\");\n-        (12,                         DEFAULT,                \"default\");\n+        // Special identifiers\n+        (0,                          Invalid,        \"\");\n+        (1,                          __Unused1,      \"<__unused1>\");\n+        (2,                          __Unused2,      \"<__unused2>\");\n+        (3,                          __Unused3,      \"<__unused3>\");\n+        (4,                          __Unused4,      \"<__unused4>\");\n+        (5,                          __Unused5,      \"<__unused5>\");\n+        (6,                          Union,          \"union\");\n+        (7,                          Default,        \"default\");\n+        (8,                          StaticLifetime, \"'static\");\n     }\n \n     pub mod keywords {\n-        // These ones are variants of the Keyword enum\n-\n-        'strict:\n+        // Keywords\n+        'used:\n+        (9,                          Static,     \"static\");\n+        (10,                         Super,      \"super\");\n+        (11,                         SelfValue,  \"self\");\n+        (12,                         SelfType,   \"Self\");\n         (13,                         As,         \"as\");\n         (14,                         Break,      \"break\");\n         (15,                         Crate,      \"crate\");\n@@ -529,12 +483,7 @@ declare_special_idents_and_keywords! {\n         (31,                         Pub,        \"pub\");\n         (32,                         Ref,        \"ref\");\n         (33,                         Return,     \"return\");\n-        // Static and Self are also special idents (prefill de-dupes)\n-        (super::STATIC_KEYWORD_NAME_NUM, Static, \"static\");\n-        (super::SELF_KEYWORD_NAME_NUM, SelfValue, \"self\");\n-        (super::SELF_TYPE_KEYWORD_NAME_NUM, SelfType, \"Self\");\n         (34,                         Struct,     \"struct\");\n-        (super::SUPER_KEYWORD_NAME_NUM, Super,   \"super\");\n         (35,                         True,       \"true\");\n         (36,                         Trait,      \"trait\");\n         (37,                         Type,       \"type\");"}, {"sha": "d5318e32aa8d18deadbf1122ea9b930570888f7a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -2959,7 +2959,7 @@ impl<'a> State<'a> {\n                 match input.pat.node {\n                     PatKind::Ident(_, ref path1, _) if\n                         path1.node.name ==\n-                            parse::token::special_idents::invalid.name => {\n+                            parse::token::special_idents::Invalid.name => {\n                         // Do nothing.\n                     }\n                     _ => {"}, {"sha": "1d640d7435315a0214d339632ab6947fd70a9959", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -148,7 +148,7 @@ impl fold::Folder for PreludeInjector {\n         let vp = P(codemap::dummy_spanned(ast::ViewPathGlob(prelude_path)));\n         mod_.items.insert(0, P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n-            ident: special_idents::invalid,\n+            ident: special_idents::Invalid,\n             node: ast::ItemKind::Use(vp),\n             attrs: vec![ast::Attribute {\n                 span: self.span,\n@@ -157,7 +157,9 @@ impl fold::Folder for PreludeInjector {\n                     style: ast::AttrStyle::Outer,\n                     value: P(ast::MetaItem {\n                         span: self.span,\n-                        node: ast::MetaItemKind::Word(special_idents::prelude_import.name.as_str()),\n+                        node: ast::MetaItemKind::Word(\n+                            token::intern_and_get_ident(\"prelude_import\")\n+                        ),\n                     }),\n                     is_sugared_doc: false,\n                 },"}, {"sha": "f464eb9bf972ae61aab555e1eb8899a4ed92c757", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -116,7 +116,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n     fn fold_item(&mut self, i: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         let ident = i.ident;\n-        if ident.name != token::special_idents::invalid.name {\n+        if ident.name != token::special_idents::Invalid.name {\n             self.cx.path.push(ident);\n         }\n         debug!(\"current path: {}\", path_name_i(&self.cx.path));\n@@ -160,7 +160,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             ast::ItemKind::Mod(..) => fold::noop_fold_item(i, self),\n             _ => SmallVector::one(i),\n         };\n-        if ident.name != token::special_idents::invalid.name {\n+        if ident.name != token::special_idents::Invalid.name {\n             self.cx.path.pop();\n         }\n         res\n@@ -453,7 +453,7 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n         (ast::ItemKind::Use(\n             P(nospan(ast::ViewPathSimple(id_test,\n                                          path_node(vec!(id_test)))))),\n-         ast::Visibility::Public, token::special_idents::invalid)\n+         ast::Visibility::Public, token::special_idents::Invalid)\n     } else {\n         (ast::ItemKind::ExternCrate(None), ast::Visibility::Inherited, id_test)\n     };\n@@ -545,7 +545,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n \n         P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n-            ident: token::special_idents::invalid,\n+            ident: token::special_idents::Invalid,\n             attrs: vec![],\n             node: ast::ItemKind::Use(P(use_path)),\n             vis: ast::Visibility::Inherited,\n@@ -590,7 +590,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n     let struct_type = ecx.ty_path(ecx.path(sp, vec![ecx.ident_of(\"self\"),\n                                                     ecx.ident_of(\"test\"),\n                                                     ecx.ident_of(\"TestDescAndFn\")]));\n-    let static_lt = ecx.lifetime(sp, token::special_idents::static_lifetime.name);\n+    let static_lt = ecx.lifetime(sp, token::special_idents::StaticLifetime.name);\n     // &'static [self::test::TestDescAndFn]\n     let static_type = ecx.ty_rptr(sp,\n                                   ecx.ty(sp, ast::TyKind::Vec(struct_type)),"}, {"sha": "b117b383120ab2fa02e47cf664e911f3baa46313", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -202,7 +202,7 @@ use syntax::codemap::Span;\n use syntax::errors::Handler;\n use syntax::util::move_map::MoveMap;\n use syntax::parse::token::{intern, InternedString};\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::{keywords, special_idents};\n use syntax::ptr::P;\n \n use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n@@ -635,7 +635,7 @@ impl<'a> TraitDef<'a> {\n \n         cx.item(\n             self.span,\n-            special_idents::invalid,\n+            special_idents::Invalid,\n             a,\n             ast::ItemKind::Impl(unsafety,\n                                 ast::ImplPolarity::Positive,\n@@ -866,7 +866,7 @@ impl<'a> MethodDef<'a> {\n             // creating fresh self id\n             _ => Some(ast::Arg::new_self(trait_.span,\n                                          ast::Mutability::Immutable,\n-                                         special_idents::self_))\n+                                         keywords::SelfValue.ident))\n         };\n         let args = {\n             let args = arg_types.into_iter().map(|(name, ty)| {"}, {"sha": "972983c25386b2decf05e09a4c266448d86ae7aa", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -19,7 +19,7 @@ use syntax::ast::{Expr,Generics,Ident};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{Span,respan};\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::keywords;\n use syntax::ptr::P;\n \n /// The types of pointers\n@@ -264,15 +264,15 @@ pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n-            (self_path, respan(span, ast::SelfKind::Value(special_idents::self_)))\n+            (self_path, respan(span, ast::SelfKind::Value(keywords::SelfValue.ident)))\n         }\n         Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n-                        ast::SelfKind::Region(lt, mutbl, special_idents::self_)\n+                        ast::SelfKind::Region(lt, mutbl, keywords::SelfValue.ident)\n                     }\n                     Raw(_) => cx.span_bug(span, \"attempted to use *self in deriving definition\")\n                 });"}, {"sha": "828f4a72e1fe9c01012fededbfa212c66e05f42f", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c821d35ee5cb5211f92480a53b409b2b2c359e/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=e2c821d35ee5cb5211f92480a53b409b2b2c359e", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let sp = piece_ty.span;\n         let ty = ecx.ty_rptr(sp,\n             ecx.ty(sp, ast::TyKind::Vec(piece_ty)),\n-            Some(ecx.lifetime(sp, special_idents::static_lifetime.name)),\n+            Some(ecx.lifetime(sp, special_idents::StaticLifetime.name)),\n             ast::Mutability::Immutable);\n         let slice = ecx.expr_vec_slice(sp, pieces);\n         // static instead of const to speed up codegen by not requiring this to be inlined\n@@ -475,7 +475,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n-        let static_lifetime = self.ecx.lifetime(self.fmtsp, special_idents::static_lifetime.name);\n+        let static_lifetime = self.ecx.lifetime(self.fmtsp, special_idents::StaticLifetime.name);\n         let piece_ty = self.ecx.ty_rptr(\n                 self.fmtsp,\n                 self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),"}]}