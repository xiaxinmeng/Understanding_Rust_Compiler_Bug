{"sha": "c53210c5501b60165b6eb8487268e3833191316a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MzIxMGM1NTAxYjYwMTY1YjZlYjg0ODcyNjhlMzgzMzE5MTMxNmE=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-03-16T22:12:42Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-15T16:25:21Z"}, "message": "Make the necessary changes to support concurrency in Miri.", "tree": {"sha": "e12432769834de57176d0a3521a94ab9acb9a463", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e12432769834de57176d0a3521a94ab9acb9a463"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c53210c5501b60165b6eb8487268e3833191316a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c53210c5501b60165b6eb8487268e3833191316a", "html_url": "https://github.com/rust-lang/rust/commit/c53210c5501b60165b6eb8487268e3833191316a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c53210c5501b60165b6eb8487268e3833191316a/comments", "author": null, "committer": null, "parents": [{"sha": "df768c5c8fcb361c4dc94b4c776d6a78c12862e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/df768c5c8fcb361c4dc94b4c776d6a78c12862e1", "html_url": "https://github.com/rust-lang/rust/commit/df768c5c8fcb361c4dc94b4c776d6a78c12862e1"}], "stats": {"total": 192, "additions": 135, "deletions": 57}, "files": [{"sha": "3c3618f390c6160fd505122a420e27437c0689f2", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -50,7 +50,7 @@ impl Error for ConstEvalErrKind {}\n /// Turn an interpreter error into something to report to the user.\n /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n /// Should be called only if the error is actually going to to be reported!\n-pub fn error_to_const_error<'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n+pub fn error_to_const_error<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>(\n     ecx: &InterpCx<'mir, 'tcx, M>,\n     mut error: InterpErrorInfo<'tcx>,\n ) -> ConstEvalErr<'tcx> {"}, {"sha": "41ca753e79c9f6afc294ee6302d4f844b54d623e", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -19,7 +19,7 @@ use crate::interpret::{\n \n use super::error::*;\n \n-impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter> {\n+impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n     /// Evaluate a const function where all arguments (if any) are zero-sized types.\n     /// The evaluation is memoized thanks to the query system.\n     ///\n@@ -86,12 +86,15 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter> {\n }\n \n /// Extra machine state for CTFE, and the Machine instance\n-pub struct CompileTimeInterpreter {\n+pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     /// For now, the number of terminators that can be evaluated before we throw a resource\n     /// exhuastion error.\n     ///\n     /// Setting this to `0` disables the limit and allows the interpreter to run forever.\n     pub steps_remaining: usize,\n+\n+    /// The virtual call stack.\n+    pub(crate) stack: Vec<Frame<'mir, 'tcx, (), ()>>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -100,9 +103,9 @@ pub struct MemoryExtra {\n     pub(super) can_access_statics: bool,\n }\n \n-impl CompileTimeInterpreter {\n+impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n     pub(super) fn new(const_eval_limit: usize) -> Self {\n-        CompileTimeInterpreter { steps_remaining: const_eval_limit }\n+        CompileTimeInterpreter { steps_remaining: const_eval_limit, stack: Vec::new() }\n     }\n }\n \n@@ -156,7 +159,8 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n }\n \n-crate type CompileTimeEvalContext<'mir, 'tcx> = InterpCx<'mir, 'tcx, CompileTimeInterpreter>;\n+crate type CompileTimeEvalContext<'mir, 'tcx> =\n+    InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n \n impl interpret::MayLeak for ! {\n     #[inline(always)]\n@@ -166,7 +170,7 @@ impl interpret::MayLeak for ! {\n     }\n }\n \n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n     type MemoryKind = !;\n     type PointerTag = ();\n     type ExtraFnVal = !;\n@@ -186,6 +190,20 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n         false\n     }\n \n+    #[inline(always)]\n+    fn stack(\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n+        &ecx.machine.stack\n+    }\n+\n+    #[inline(always)]\n+    fn stack_mut(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n+        &mut ecx.machine.stack\n+    }\n+\n     #[inline(always)]\n     fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         false // for now, we don't enforce validity"}, {"sha": "256d7eccc065ba1df18ad5db7e55e48d53964057", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc_span::symbol::sym;\n use rustc_target::abi::{LayoutOf, Size, Variants};\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn cast(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,"}, {"sha": "7166503c8a832aa50ed484b5004fa952e12b884b", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -39,9 +39,6 @@ pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// The virtual memory system.\n     pub memory: Memory<'mir, 'tcx, M>,\n \n-    /// The virtual call stack.\n-    pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>>,\n-\n     /// A cache for deduplicating vtables\n     pub(super) vtables:\n         FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Pointer<M::PointerTag>>,\n@@ -295,7 +292,7 @@ pub(super) fn from_known_layout<'tcx>(\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxtAt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -307,7 +304,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             tcx,\n             param_env,\n             memory: Memory::new(tcx, memory_extra),\n-            stack: Vec::new(),\n             vtables: FxHashMap::default(),\n         }\n     }\n@@ -348,23 +344,29 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline(always)]\n     pub fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>] {\n-        &self.stack\n+        M::stack(self)\n+    }\n+\n+    #[inline(always)]\n+    pub fn stack_mut(&mut self) -> &mut Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>> {\n+        M::stack_mut(self)\n     }\n \n     #[inline(always)]\n     pub fn cur_frame(&self) -> usize {\n-        assert!(!self.stack.is_empty());\n-        self.stack.len() - 1\n+        let stack = self.stack();\n+        assert!(!stack.is_empty());\n+        stack.len() - 1\n     }\n \n     #[inline(always)]\n     pub fn frame(&self) -> &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra> {\n-        self.stack.last().expect(\"no call frames exist\")\n+        self.stack().last().expect(\"no call frames exist\")\n     }\n \n     #[inline(always)]\n     pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra> {\n-        self.stack.last_mut().expect(\"no call frames exist\")\n+        self.stack_mut().last_mut().expect(\"no call frames exist\")\n     }\n \n     #[inline(always)]\n@@ -595,7 +597,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n-        if !self.stack.is_empty() {\n+        if !self.stack().is_empty() {\n             info!(\"PAUSING({}) {}\", self.cur_frame(), self.frame().instance);\n         }\n         ::log_settings::settings().indentation += 1;\n@@ -614,7 +616,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             extra: (),\n         };\n         let frame = M::init_frame_extra(self, pre_frame)?;\n-        self.stack.push(frame);\n+        self.stack_mut().push(frame);\n \n         // don't allocate at all for trivial constants\n         if body.local_decls.len() > 1 {\n@@ -649,7 +651,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         M::after_stack_push(self)?;\n         info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n \n-        if self.stack.len() > *self.tcx.sess.recursion_limit.get() {\n+        if self.stack().len() > *self.tcx.sess.recursion_limit.get() {\n             throw_exhaust!(StackFrameLimitReached)\n         } else {\n             Ok(())\n@@ -719,7 +721,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         );\n \n         ::log_settings::settings().indentation -= 1;\n-        let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n+        let frame =\n+            self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n \n         // Now where do we jump next?\n \n@@ -734,7 +737,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         if !cleanup {\n-            assert!(self.stack.is_empty(), \"only the topmost frame should ever be leaked\");\n+            assert!(self.stack().is_empty(), \"only the topmost frame should ever be leaked\");\n             assert!(next_block.is_none(), \"tried to skip cleanup when we have a next block!\");\n             assert!(!unwinding, \"tried to skip cleanup during unwinding\");\n             // Leak the locals, skip validation, skip machine hook.\n@@ -783,7 +786,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n-        if !self.stack.is_empty() {\n+        if !self.stack().is_empty() {\n             info!(\n                 \"CONTINUING({}) {} (unwinding = {})\",\n                 self.cur_frame(),\n@@ -899,7 +902,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 write!(msg, \":\").unwrap();\n \n-                match self.stack[frame].locals[local].value {\n+                match self.stack()[frame].locals[local].value {\n                     LocalValue::Dead => write!(msg, \" is dead\").unwrap(),\n                     LocalValue::Uninitialized => write!(msg, \" is uninitialized\").unwrap(),\n                     LocalValue::Live(Operand::Indirect(mplace)) => match mplace.ptr {"}, {"sha": "3b8b76e2562cff47e5d062b7cf8d91dedd372987", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -148,7 +148,7 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> InternVisitor<'rt, 'mir\n     }\n }\n \n-impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n+impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     for InternVisitor<'rt, 'mir, 'tcx, M>\n {\n     type V = MPlaceTy<'tcx>;\n@@ -284,7 +284,10 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n     ignore_interior_mut_in_const_validation: bool,\n-) -> InterpResult<'tcx> {\n+) -> InterpResult<'tcx>\n+where\n+    'tcx: 'mir,\n+{\n     let tcx = ecx.tcx;\n     let (base_mutability, base_intern_mode) = match intern_kind {\n         // `static mut` doesn't care about interior mutability, it's mutable anyway"}, {"sha": "c8bf328ce8eeedbc5611b2ce1472b0816a0756d9", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -73,7 +73,7 @@ crate fn eval_nullary_intrinsic<'tcx>(\n     })\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,"}, {"sha": "91b046d7bb264c4ebbb685e85189f0f242ccf7a6", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -10,11 +10,11 @@ use crate::interpret::{\n     MPlaceTy, MemoryKind, Scalar,\n };\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Walks up the callstack from the intrinsic's callsite, searching for the first callsite in a\n     /// frame which is not `#[track_caller]`.\n     crate fn find_closest_untracked_caller_location(&self) -> Span {\n-        self.stack\n+        self.stack()\n             .iter()\n             .rev()\n             // Find first non-`#[track_caller]` frame."}, {"sha": "14acaf8260713dea613b00020ec57e86f036bfd9", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -120,6 +120,16 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Whether memory accesses should be alignment-checked.\n     fn enforce_alignment(memory_extra: &Self::MemoryExtra) -> bool;\n \n+    /// Borrow the current thread's stack.\n+    fn stack(\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>];\n+\n+    /// Mutably borrow the current thread's stack.\n+    fn stack_mut(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n+\n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n@@ -230,6 +240,20 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         id\n     }\n \n+    /// In Rust, thread locals are just special statics. Therefore, the compiler\n+    /// uses the same code for allocating both. However, in Miri we want to have\n+    /// a property that each allocation has a unique id and, therefore, we\n+    /// generate a fresh allocation id for each thread. This function takes a\n+    /// potentially thread local allocation id and resolves the original static\n+    /// allocation id that can be used to compute the value of the static.\n+    #[inline]\n+    fn resolve_thread_local_allocation_id(\n+        _memory_extra: &Self::MemoryExtra,\n+        id: AllocId,\n+    ) -> AllocId {\n+        id\n+    }\n+\n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra."}, {"sha": "20158b9c1b6cc242a4eed87e8f29f70a0d53c272", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -429,7 +429,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n-        let alloc = tcx.alloc_map.lock().get(id);\n+        let alloc =\n+            tcx.alloc_map.lock().get(M::resolve_thread_local_allocation_id(memory_extra, id));\n         let (alloc, def_id) = match alloc {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n@@ -592,7 +593,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // # Statics\n         // Can't do this in the match argument, we may get cycle errors since the lock would\n         // be held throughout the match.\n-        let alloc = self.tcx.alloc_map.lock().get(id);\n+        let alloc =\n+            self.tcx.alloc_map.lock().get(M::resolve_thread_local_allocation_id(&self.extra, id));\n         match alloc {\n             Some(GlobalAlloc::Static(did)) => {\n                 // Use size and align of the type."}, {"sha": "b86a98d85984e57c3a5a41012f949470964c5436", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -208,7 +208,7 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Normalice `place.ptr` to a `Pointer` if this is a place and not a ZST.\n     /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n     #[inline]\n@@ -439,7 +439,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let op = match *place {\n             Place::Ptr(mplace) => Operand::Indirect(mplace),\n-            Place::Local { frame, local } => *self.access_local(&self.stack[frame], local, None)?,\n+            Place::Local { frame, local } => {\n+                *self.access_local(&self.stack()[frame], local, None)?\n+            }\n         };\n         Ok(OpTy { op, layout: place.layout })\n     }"}, {"sha": "d651267f82b7943e38e43189186592267a75c5f9", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -9,7 +9,7 @@ use rustc_target::abi::LayoutOf;\n \n use super::{ImmTy, Immediate, InterpCx, Machine, PlaceTy};\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n     pub fn binop_with_overflow(\n@@ -45,7 +45,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "12a600f23c2cef06a7d07e5ddd24040279149ca4", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -283,7 +283,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n }\n \n // separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n-impl<'mir, 'tcx, Tag, M> InterpCx<'mir, 'tcx, M>\n+impl<'mir, 'tcx: 'mir, Tag, M> InterpCx<'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n     Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n@@ -755,7 +755,7 @@ where\n         // but not factored as a separate function.\n         let mplace = match dest.place {\n             Place::Local { frame, local } => {\n-                match self.stack[frame].locals[local].access_mut()? {\n+                match self.stack_mut()[frame].locals[local].access_mut()? {\n                     Ok(local) => {\n                         // Local can be updated in-place.\n                         *local = LocalValue::Live(Operand::Immediate(src));\n@@ -985,14 +985,15 @@ where\n     ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n-                match self.stack[frame].locals[local].access_mut()? {\n+                match self.stack_mut()[frame].locals[local].access_mut()? {\n                     Ok(&mut local_val) => {\n                         // We need to make an allocation.\n \n                         // We need the layout of the local.  We can NOT use the layout we got,\n                         // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n-                        let local_layout = self.layout_of_local(&self.stack[frame], local, None)?;\n+                        let local_layout =\n+                            self.layout_of_local(&self.stack()[frame], local, None)?;\n                         // We also need to support unsized types, and hence cannot use `allocate`.\n                         let (size, align) = self\n                             .size_and_align_of(meta, local_layout)?\n@@ -1008,7 +1009,7 @@ where\n                         }\n                         // Now we can call `access_mut` again, asserting it goes well,\n                         // and actually overwrite things.\n-                        *self.stack[frame].locals[local].access_mut().unwrap().unwrap() =\n+                        *self.stack_mut()[frame].locals[local].access_mut().unwrap().unwrap() =\n                             LocalValue::Live(Operand::Indirect(mplace));\n                         (mplace, Some(size))\n                     }"}, {"sha": "cce204353d3a698315294bb17431dd740fe274ea", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -29,7 +29,7 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn run(&mut self) -> InterpResult<'tcx> {\n         while self.step()? {}\n         Ok(())\n@@ -42,7 +42,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This is marked `#inline(always)` to work around adverserial codegen when `opt-level = 3`\n     #[inline(always)]\n     pub fn step(&mut self) -> InterpResult<'tcx, bool> {\n-        if self.stack.is_empty() {\n+        if self.stack().is_empty() {\n             return Ok(false);\n         }\n \n@@ -126,7 +126,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             LlvmInlineAsm { .. } => throw_unsup_format!(\"inline assembly is not supported\"),\n         }\n \n-        self.stack[frame_idx].stmt += 1;\n+        self.stack_mut()[frame_idx].stmt += 1;\n         Ok(())\n     }\n \n@@ -278,7 +278,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.set_span(terminator.source_info.span);\n \n         self.eval_terminator(terminator)?;\n-        if !self.stack.is_empty() {\n+        if !self.stack().is_empty() {\n             if let Some(block) = self.frame().block {\n                 info!(\"// executing {:?}\", block);\n             }"}, {"sha": "7d587bab64a7497984db626cc7d40a7d54b3f362", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -11,7 +11,7 @@ use super::{\n     FnVal, ImmTy, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, PlaceTy, StackPopCleanup,\n };\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub(super) fn eval_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n@@ -372,7 +372,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 match res {\n                     Err(err) => {\n-                        self.stack.pop();\n+                        self.stack_mut().pop();\n                         Err(err)\n                     }\n                     Ok(()) => Ok(()),"}, {"sha": "7edd787c986bd9a943a4b9be96d1609ce858dc32", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -6,7 +6,7 @@ use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size};\n \n use super::{FnVal, InterpCx, Machine, MemoryKind};\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///"}, {"sha": "a4944bdcc0b4dd5fbb7ab5a006c54663a518bd19", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -177,7 +177,7 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     ecx: &'rt InterpCx<'mir, 'tcx, M>,\n }\n \n-impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M> {\n+impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M> {\n     fn aggregate_field_path_elem(&mut self, layout: TyAndLayout<'tcx>, field: usize) -> PathElem {\n         // First, check if we are projecting to a variant.\n         match layout.variants {\n@@ -604,7 +604,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n     }\n }\n \n-impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n+impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     for ValidityVisitor<'rt, 'mir, 'tcx, M>\n {\n     type V = OpTy<'tcx, M::PointerTag>;\n@@ -806,7 +806,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn validate_operand_internal(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,"}, {"sha": "e0e733dc40874bfc6b7e228cca41b35e3f5f6822", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -35,7 +35,7 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n \n // Operands and memory-places are both values.\n // Places in general are not due to `place_field` having to do `force_allocation`.\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::PointerTag> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n     fn layout(&self) -> TyAndLayout<'tcx> {\n         self.layout\n@@ -73,7 +73,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx, M::PointerTag> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n+    for MPlaceTy<'tcx, M::PointerTag>\n+{\n     #[inline(always)]\n     fn layout(&self) -> TyAndLayout<'tcx> {\n         self.layout"}, {"sha": "b7d7fc29f3040275dfe4c5adca2761993d5ce383", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53210c5501b60165b6eb8487268e3833191316a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c53210c5501b60165b6eb8487268e3833191316a", "patch": "@@ -158,9 +158,18 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n     }\n }\n \n-struct ConstPropMachine;\n+struct ConstPropMachine<'mir, 'tcx> {\n+    /// The virtual call stack.\n+    stack: Vec<Frame<'mir, 'tcx, (), ()>>,\n+}\n \n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n+impl<'mir, 'tcx> ConstPropMachine<'mir, 'tcx> {\n+    fn new() -> Self {\n+        Self { stack: Vec::new() }\n+    }\n+}\n+\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx> {\n     type MemoryKind = !;\n     type PointerTag = ();\n     type ExtraFnVal = !;\n@@ -178,6 +187,20 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         false\n     }\n \n+    #[inline(always)]\n+    fn stack(\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n+        &ecx.machine.stack\n+    }\n+\n+    #[inline(always)]\n+    fn stack_mut(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n+        &mut ecx.machine.stack\n+    }\n+\n     #[inline(always)]\n     fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         false\n@@ -300,7 +323,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'mir, 'tcx> {\n-    ecx: InterpCx<'mir, 'tcx, ConstPropMachine>,\n+    ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     can_const_prop: IndexVec<Local, ConstPropMode>,\n     param_env: ParamEnv<'tcx>,\n@@ -349,7 +372,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id).with_reveal_all();\n \n         let span = tcx.def_span(def_id);\n-        let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine, ());\n+        let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine::new(), ());\n         let can_const_prop = CanConstProp::check(body);\n \n         let ret = ecx"}]}