{"sha": "471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MWRkNTJkNzcxMGRjYWQ1ZmVjMGNkNzMxYjgzNmIwMmJhNGE4ZjQ=", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-07-19T20:15:44Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-07-19T20:15:44Z"}, "message": "Fix merge conflict with recent PR", "tree": {"sha": "4f7a1b7fcf01c8fb5c255a5af32b3906b44d38fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f7a1b7fcf01c8fb5c255a5af32b3906b44d38fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "html_url": "https://github.com/rust-lang/rust/commit/471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e88220f86749d88e53c5dbaa421dcaba1889f86c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e88220f86749d88e53c5dbaa421dcaba1889f86c", "html_url": "https://github.com/rust-lang/rust/commit/e88220f86749d88e53c5dbaa421dcaba1889f86c"}, {"sha": "d7f94516345a36ddfcd68cbdf1df835d356795c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7f94516345a36ddfcd68cbdf1df835d356795c3", "html_url": "https://github.com/rust-lang/rust/commit/d7f94516345a36ddfcd68cbdf1df835d356795c3"}], "stats": {"total": 4328, "additions": 3039, "deletions": 1289}, "files": [{"sha": "34a33eca3f40b7c635b79dfbf7b1bc0f416c8497", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -2821,6 +2821,13 @@ dependencies = [\n  \"rls-span\",\n ]\n \n+[[package]]\n+name = \"rust-demangler\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc-demangle\",\n+]\n+\n [[package]]\n name = \"rustbook\"\n version = \"0.1.0\""}, {"sha": "9429e063b51106e35e9d19aa6eb89a91e242eba4", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -17,6 +17,7 @@ members = [\n   \"src/tools/remote-test-client\",\n   \"src/tools/remote-test-server\",\n   \"src/tools/rust-installer\",\n+  \"src/tools/rust-demangler\",\n   \"src/tools/cargo\",\n   \"src/tools/rustdoc\",\n   \"src/tools/rls\","}, {"sha": "70e5f6ac26fc13c8b0479192cff2f9df709e3639", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -370,6 +370,7 @@ impl<'a> Builder<'a> {\n                 tool::Cargo,\n                 tool::Rls,\n                 tool::RustAnalyzer,\n+                tool::RustDemangler,\n                 tool::Rustdoc,\n                 tool::Clippy,\n                 tool::CargoClippy,"}, {"sha": "b76d80aa509a5c6d353c3f48df176177b714d62c", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1022,6 +1022,10 @@ impl Step for Compiletest {\n             cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler));\n         }\n \n+        if mode == \"run-make\" && suite.ends_with(\"fulldeps\") {\n+            cmd.arg(\"--rust-demangler-path\").arg(builder.tool_exe(Tool::RustDemangler));\n+        }\n+\n         cmd.arg(\"--src-base\").arg(builder.src.join(\"src/test\").join(suite));\n         cmd.arg(\"--build-base\").arg(testdir(builder, compiler.host).join(suite));\n         cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));"}, {"sha": "fe3f1e78029d7679aa9983b1ee5e334a61b76c79", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -361,6 +361,7 @@ bootstrap_tool!(\n     Compiletest, \"src/tools/compiletest\", \"compiletest\", is_unstable_tool = true;\n     BuildManifest, \"src/tools/build-manifest\", \"build-manifest\";\n     RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\";\n+    RustDemangler, \"src/tools/rust-demangler\", \"rust-demangler\";\n     RustInstaller, \"src/tools/rust-installer\", \"fabricate\", is_external_tool = true;\n     RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\";\n     ExpandYamlAnchors, \"src/tools/expand-yaml-anchors\", \"expand-yaml-anchors\";"}, {"sha": "9a051caa0667881dc49ee425bf295a4cde1d3c5f", "filename": "src/ci/docker/host-x86_64/dist-i686-linux/Dockerfile", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-linux%2FDockerfile?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1,34 +1,44 @@\n-FROM centos:5\n+# We use Debian 6 (glibc 2.11, kernel 2.6.32) as a common base for other\n+# distros that still need Rust support: RHEL 6 (glibc 2.12, kernel 2.6.32) and\n+# SLES 11 SP4 (glibc 2.11, kernel 3.0).\n+FROM debian:6\n \n WORKDIR /build\n \n-# Centos 5 is EOL and is no longer available from the usual mirrors, so switch\n-# to http://vault.centos.org/\n-RUN sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/fastestmirror.conf\n-RUN sed -i 's/mirrorlist/#mirrorlist/' /etc/yum.repos.d/*.repo\n-RUN sed -i 's|#\\(baseurl.*\\)mirror.centos.org/centos/$releasever|\\1vault.centos.org/5.11|' /etc/yum.repos.d/*.repo\n+# Debian 6 is EOL and no longer available from the usual mirrors,\n+# so we'll need to switch to http://archive.debian.org/\n+RUN sed -i '/updates/d' /etc/apt/sources.list && \\\n+    sed -i 's/httpredir/archive/' /etc/apt/sources.list\n \n-RUN yum upgrade -y && yum install -y \\\n-      curl \\\n+RUN apt-get update && \\\n+    apt-get install --allow-unauthenticated -y --no-install-recommends \\\n+      automake \\\n       bzip2 \\\n+      ca-certificates \\\n+      curl \\\n+      file \\\n+      g++ \\\n+      g++-multilib \\\n       gcc \\\n-      gcc-c++ \\\n+      gcc-multilib \\\n+      git \\\n+      lib32z1-dev \\\n+      libedit-dev \\\n+      libncurses-dev \\\n       make \\\n-      glibc-devel \\\n+      patch \\\n       perl \\\n-      zlib-devel \\\n-      file \\\n-      xz \\\n-      which \\\n-      pkgconfig \\\n+      pkg-config \\\n+      unzip \\\n       wget \\\n-      autoconf \\\n-      gettext\n+      xz-utils \\\n+      zlib1g-dev\n \n ENV PATH=/rustroot/bin:$PATH\n-ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n+ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib32:/rustroot/lib\n ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n WORKDIR /tmp\n+RUN mkdir /home/user\n COPY host-x86_64/dist-x86_64-linux/shared.sh /tmp/\n \n # We need a build of openssl which supports SNI to download artifacts from\n@@ -38,14 +48,14 @@ COPY host-x86_64/dist-x86_64-linux/shared.sh /tmp/\n COPY host-x86_64/dist-x86_64-linux/build-openssl.sh /tmp/\n RUN ./build-openssl.sh\n \n-# The `curl` binary on CentOS doesn't support SNI which is needed for fetching\n+# The `curl` binary on Debian 6 doesn't support SNI which is needed for fetching\n # some https urls we have, so install a new version of libcurl + curl which is\n # using the openssl we just built previously.\n #\n # Note that we also disable a bunch of optional features of curl that we don't\n # really need.\n COPY host-x86_64/dist-x86_64-linux/build-curl.sh /tmp/\n-RUN ./build-curl.sh\n+RUN ./build-curl.sh && apt-get remove -y curl\n \n # binutils < 2.22 has a bug where the 32-bit executables it generates\n # immediately segfault in Rust, so we need to install our own binutils.\n@@ -54,40 +64,24 @@ RUN ./build-curl.sh\n COPY host-x86_64/dist-x86_64-linux/build-binutils.sh /tmp/\n RUN ./build-binutils.sh\n \n-# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n-# only has 2.6.4, so build our own\n-COPY host-x86_64/dist-x86_64-linux/build-cmake.sh /tmp/\n-RUN ./build-cmake.sh\n-\n-# Need a newer version of gcc than centos has to compile LLVM nowadays\n+# Need at least GCC 5.1 to compile LLVM nowadays\n COPY host-x86_64/dist-x86_64-linux/build-gcc.sh /tmp/\n-RUN ./build-gcc.sh\n+RUN ./build-gcc.sh && apt-get remove -y gcc g++\n \n-# CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n+# Debian 6 has Python 2.6 by default, but LLVM needs 2.7+\n COPY host-x86_64/dist-x86_64-linux/build-python.sh /tmp/\n RUN ./build-python.sh\n \n-# Now build LLVM+Clang 7, afterwards configuring further compilations to use the\n+# LLVM needs cmake 3.4.3 or higher, and is planning to raise to 3.13.4.\n+COPY host-x86_64/dist-x86_64-linux/build-cmake.sh /tmp/\n+RUN ./build-cmake.sh\n+\n+# Now build LLVM+Clang, afterwards configuring further compilations to use the\n # clang/clang++ compilers.\n-COPY host-x86_64/dist-x86_64-linux/build-clang.sh host-x86_64/dist-x86_64-linux/llvm-project-centos.patch /tmp/\n+COPY host-x86_64/dist-x86_64-linux/build-clang.sh /tmp/\n RUN ./build-clang.sh\n ENV CC=clang CXX=clang++\n \n-# Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n-# cloning, so download and build it here.\n-COPY host-x86_64/dist-x86_64-linux/build-git.sh /tmp/\n-RUN ./build-git.sh\n-\n-# for sanitizers, we need kernel headers files newer than the ones CentOS ships\n-# with so we install newer ones here\n-COPY host-x86_64/dist-x86_64-linux/build-headers.sh /tmp/\n-RUN ./build-headers.sh\n-\n-# OpenSSL requires a more recent version of perl\n-# with so we install newer ones here\n-COPY host-x86_64/dist-x86_64-linux/build-perl.sh /tmp/\n-RUN ./build-perl.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n@@ -117,4 +111,11 @@ ENV CFLAGS -mstackrealign\n # libcurl, instead it should compile its own.\n ENV LIBCURL_NO_PKG_CONFIG 1\n \n+# There was a bad interaction between \"old\" 32-bit binaries on current 64-bit\n+# kernels with selinux enabled, where ASLR mmap would sometimes choose a low\n+# address and then block it for being below `vm.mmap_min_addr` -> `EACCES`.\n+# This is probably a kernel bug, but setting `ulimit -Hs` works around it.\n+# See also `src/ci/run.sh` where this takes effect.\n+ENV SET_HARD_RLIMIT_STACK 1\n+\n ENV DIST_REQUIRE_ALL_TOOLS 1"}, {"sha": "1f0978c0082c5898166955a5dba385dc8deb62f4", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1,34 +1,44 @@\n-FROM centos:5\n+# We use Debian 6 (glibc 2.11, kernel 2.6.32) as a common base for other\n+# distros that still need Rust support: RHEL 6 (glibc 2.12, kernel 2.6.32) and\n+# SLES 11 SP4 (glibc 2.11, kernel 3.0).\n+FROM debian:6\n \n WORKDIR /build\n \n-# Centos 5 is EOL and is no longer available from the usual mirrors, so switch\n-# to http://vault.centos.org/\n-RUN sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/fastestmirror.conf\n-RUN sed -i 's/mirrorlist/#mirrorlist/' /etc/yum.repos.d/*.repo\n-RUN sed -i 's|#\\(baseurl.*\\)mirror.centos.org/centos/$releasever|\\1vault.centos.org/5.11|' /etc/yum.repos.d/*.repo\n+# Debian 6 is EOL and no longer available from the usual mirrors,\n+# so we'll need to switch to http://archive.debian.org/\n+RUN sed -i '/updates/d' /etc/apt/sources.list && \\\n+    sed -i 's/httpredir/archive/' /etc/apt/sources.list\n \n-RUN yum upgrade -y && yum install -y \\\n-      curl \\\n+RUN apt-get update && \\\n+    apt-get install --allow-unauthenticated -y --no-install-recommends \\\n+      automake \\\n       bzip2 \\\n+      ca-certificates \\\n+      curl \\\n+      file \\\n+      g++ \\\n+      g++-multilib \\\n       gcc \\\n-      gcc-c++ \\\n+      gcc-multilib \\\n+      git \\\n+      lib32z1-dev \\\n+      libedit-dev \\\n+      libncurses-dev \\\n       make \\\n-      glibc-devel \\\n+      patch \\\n       perl \\\n-      zlib-devel \\\n-      file \\\n-      xz \\\n-      which \\\n-      pkgconfig \\\n+      pkg-config \\\n+      unzip \\\n       wget \\\n-      autoconf \\\n-      gettext\n+      xz-utils \\\n+      zlib1g-dev\n \n ENV PATH=/rustroot/bin:$PATH\n-ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n+ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib32:/rustroot/lib\n ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n WORKDIR /tmp\n+RUN mkdir /home/user\n COPY host-x86_64/dist-x86_64-linux/shared.sh /tmp/\n \n # We need a build of openssl which supports SNI to download artifacts from\n@@ -38,14 +48,14 @@ COPY host-x86_64/dist-x86_64-linux/shared.sh /tmp/\n COPY host-x86_64/dist-x86_64-linux/build-openssl.sh /tmp/\n RUN ./build-openssl.sh\n \n-# The `curl` binary on CentOS doesn't support SNI which is needed for fetching\n+# The `curl` binary on Debian 6 doesn't support SNI which is needed for fetching\n # some https urls we have, so install a new version of libcurl + curl which is\n # using the openssl we just built previously.\n #\n # Note that we also disable a bunch of optional features of curl that we don't\n # really need.\n COPY host-x86_64/dist-x86_64-linux/build-curl.sh /tmp/\n-RUN ./build-curl.sh\n+RUN ./build-curl.sh && apt-get remove -y curl\n \n # binutils < 2.22 has a bug where the 32-bit executables it generates\n # immediately segfault in Rust, so we need to install our own binutils.\n@@ -54,40 +64,24 @@ RUN ./build-curl.sh\n COPY host-x86_64/dist-x86_64-linux/build-binutils.sh /tmp/\n RUN ./build-binutils.sh\n \n-# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n-# only has 2.6.4, so build our own\n-COPY host-x86_64/dist-x86_64-linux/build-cmake.sh /tmp/\n-RUN ./build-cmake.sh\n-\n-# Build a version of gcc capable of building LLVM 6\n+# Need at least GCC 5.1 to compile LLVM nowadays\n COPY host-x86_64/dist-x86_64-linux/build-gcc.sh /tmp/\n-RUN ./build-gcc.sh\n+RUN ./build-gcc.sh && apt-get remove -y gcc g++\n \n-# CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n+# Debian 6 has Python 2.6 by default, but LLVM needs 2.7+\n COPY host-x86_64/dist-x86_64-linux/build-python.sh /tmp/\n RUN ./build-python.sh\n \n-# Now build LLVM+Clang 7, afterwards configuring further compilations to use the\n+# LLVM needs cmake 3.4.3 or higher, and is planning to raise to 3.13.4.\n+COPY host-x86_64/dist-x86_64-linux/build-cmake.sh /tmp/\n+RUN ./build-cmake.sh\n+\n+# Now build LLVM+Clang, afterwards configuring further compilations to use the\n # clang/clang++ compilers.\n-COPY host-x86_64/dist-x86_64-linux/build-clang.sh host-x86_64/dist-x86_64-linux/llvm-project-centos.patch /tmp/\n+COPY host-x86_64/dist-x86_64-linux/build-clang.sh /tmp/\n RUN ./build-clang.sh\n ENV CC=clang CXX=clang++\n \n-# Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n-# cloning, so download and build it here.\n-COPY host-x86_64/dist-x86_64-linux/build-git.sh /tmp/\n-RUN ./build-git.sh\n-\n-# for sanitizers, we need kernel headers files newer than the ones CentOS ships\n-# with so we install newer ones here\n-COPY host-x86_64/dist-x86_64-linux/build-headers.sh /tmp/\n-RUN ./build-headers.sh\n-\n-# OpenSSL requires a more recent version of perl\n-# with so we install newer ones here\n-COPY host-x86_64/dist-x86_64-linux/build-perl.sh /tmp/\n-RUN ./build-perl.sh\n-\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n "}, {"sha": "2c00a628a1d350e764dbd51b534167a808e98c00", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-clang.sh", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-clang.sh?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -12,9 +12,6 @@ cd llvm-project\n curl -L https://github.com/llvm/llvm-project/archive/$LLVM.tar.gz | \\\n   tar xzf - --strip-components=1\n \n-yum install -y patch\n-patch -Np1 < ../llvm-project-centos.patch\n-\n mkdir clang-build\n cd clang-build\n "}, {"sha": "e17831a1afee56da93229799ff3ac6ae2113c005", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-cmake.sh", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-cmake.sh", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-cmake.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-cmake.sh?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -3,14 +3,15 @@\n set -ex\n source shared.sh\n \n-curl https://cmake.org/files/v3.6/cmake-3.6.3.tar.gz | tar xzf -\n+CMAKE=3.13.4\n+curl -L https://github.com/Kitware/CMake/releases/download/v$CMAKE/cmake-$CMAKE.tar.gz | tar xzf -\n \n mkdir cmake-build\n cd cmake-build\n-hide_output ../cmake-3.6.3/configure --prefix=/rustroot\n+hide_output ../cmake-$CMAKE/configure --prefix=/rustroot\n hide_output make -j10\n hide_output make install\n \n cd ..\n rm -rf cmake-build\n-rm -rf cmake-3.6.3\n+rm -rf cmake-$CMAKE"}, {"sha": "a60c6be9f322211ad3be6371c2809dc1169236cc", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-curl.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-curl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-curl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-curl.sh?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -36,4 +36,3 @@ hide_output make install\n cd ..\n rm -rf curl-build\n rm -rf curl-$VERSION\n-yum erase -y curl"}, {"sha": "9d7461ebee32b4a86de019254bf6eab3ed9497aa", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-gcc.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -37,4 +37,3 @@ ln -s gcc /rustroot/bin/cc\n cd ..\n rm -rf gcc-build\n rm -rf gcc-$GCC\n-yum erase -y gcc gcc-c++ binutils"}, {"sha": "5231aa2e7661979f0ff006deeb5093682900311e", "filename": "src/ci/run.sh", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -20,6 +20,18 @@ if [ -f /proc/sys/kernel/core_pattern ]; then\n   ulimit -c unlimited\n fi\n \n+# There was a bad interaction between \"old\" 32-bit binaries on current 64-bit\n+# kernels with selinux enabled, where ASLR mmap would sometimes choose a low\n+# address and then block it for being below `vm.mmap_min_addr` -> `EACCES`.\n+# This is probably a kernel bug, but setting `ulimit -Hs` works around it.\n+# See also `dist-i686-linux` where this setting is enabled.\n+if [ \"$SET_HARD_RLIMIT_STACK\" = \"1\" ]; then\n+  rlimit_stack=$(ulimit -Ss)\n+  if [ \"$rlimit_stack\" != \"\" ]; then\n+    ulimit -Hs \"$rlimit_stack\"\n+  fi\n+fi\n+\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n "}, {"sha": "d2f4278d0d0e0a817d51246c971265c4056c6103", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -47,9 +47,9 @@ use UnderflowResult::*;\n /// any other key, as determined by the [`Ord`] trait, changes while it is in the map. This is\n /// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n ///\n-/// [`Ord`]: ../../std/cmp/trait.Ord.html\n-/// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Ord`]: core::cmp::Ord\n+/// [`Cell`]: core::cell::Cell\n+/// [`RefCell`]: core::cell::RefCell\n ///\n /// # Examples\n ///\n@@ -256,8 +256,7 @@ where\n /// This `struct` is created by the [`iter`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`iter`]: struct.BTreeMap.html#method.iter\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`iter`]: BTreeMap::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     range: Range<'a, K, V>,\n@@ -276,8 +275,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Iter<'_, K, V> {\n /// This `struct` is created by the [`iter_mut`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`iter_mut`]: struct.BTreeMap.html#method.iter_mut\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`iter_mut`]: BTreeMap::iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n@@ -290,8 +288,7 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// This `struct` is created by the [`into_iter`] method on [`BTreeMap`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n-/// [`into_iter`]: struct.BTreeMap.html#method.into_iter\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`into_iter`]: IntoIterator::into_iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     front: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n@@ -315,8 +312,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n /// This `struct` is created by the [`keys`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`keys`]: struct.BTreeMap.html#method.keys\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`keys`]: BTreeMap::keys\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -334,8 +330,7 @@ impl<K: fmt::Debug, V> fmt::Debug for Keys<'_, K, V> {\n /// This `struct` is created by the [`values`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`values`]: struct.BTreeMap.html#method.values\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`values`]: BTreeMap::values\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -353,8 +348,7 @@ impl<K, V: fmt::Debug> fmt::Debug for Values<'_, K, V> {\n /// This `struct` is created by the [`values_mut`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`values_mut`]: struct.BTreeMap.html#method.values_mut\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`values_mut`]: BTreeMap::values_mut\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n #[derive(Debug)]\n pub struct ValuesMut<'a, K: 'a, V: 'a> {\n@@ -366,8 +360,7 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n /// This `struct` is created by the [`range`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`range`]: struct.BTreeMap.html#method.range\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`range`]: BTreeMap::range\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, K: 'a, V: 'a> {\n     front: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n@@ -386,8 +379,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Range<'_, K, V> {\n /// This `struct` is created by the [`range_mut`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`range_mut`]: struct.BTreeMap.html#method.range_mut\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`range_mut`]: BTreeMap::range_mut\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n     front: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n@@ -412,8 +404,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n ///\n /// This `enum` is constructed from the [`entry`] method on [`BTreeMap`].\n ///\n-/// [`BTreeMap`]: struct.BTreeMap.html\n-/// [`entry`]: struct.BTreeMap.html#method.entry\n+/// [`entry`]: BTreeMap::entry\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// A vacant entry."}, {"sha": "35f4ef1d9b4c7a3750e15cd76bfe714833b632a2", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -22,9 +22,9 @@ use super::Recover;\n /// to any other item, as determined by the [`Ord`] trait, changes while it is in the set. This is\n /// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n ///\n-/// [`Ord`]: ../../std/cmp/trait.Ord.html\n-/// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Ord`]: core::cmp::Ord\n+/// [`Cell`]: core::cell::Cell\n+/// [`RefCell`]: core::cell::RefCell\n ///\n /// # Examples\n ///"}, {"sha": "339592728ac24b012451fb6ce5999afcfe458c28", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -240,8 +240,6 @@ impl str {\n     /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n     /// replaces them with the replacement string slice.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -280,8 +278,6 @@ impl str {\n     /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n     /// replaces them with the replacement string slice at most `count` times.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -324,8 +320,6 @@ impl str {\n     /// the case, this function returns a [`String`] instead of modifying the\n     /// parameter in-place.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -411,8 +405,6 @@ impl str {\n     /// the case, this function returns a [`String`] instead of modifying the\n     /// parameter in-place.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -459,8 +451,7 @@ impl str {\n \n     /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    /// [`Box<str>`]: boxed/struct.Box.html\n+    /// [`Box<str>`]: Box\n     ///\n     /// # Examples\n     ///\n@@ -485,8 +476,6 @@ impl str {\n     ///\n     /// This function will panic if the capacity would overflow.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -525,7 +514,7 @@ impl str {\n     /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s.to_ascii_uppercase());\n     /// ```\n     ///\n-    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// [`make_ascii_uppercase`]: str::make_ascii_uppercase\n     /// [`to_uppercase`]: #method.to_uppercase\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n@@ -555,7 +544,7 @@ impl str {\n     /// assert_eq!(\"gr\u00fc\u00dfe, j\u00fcrgen \u2764\", s.to_ascii_lowercase());\n     /// ```\n     ///\n-    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// [`make_ascii_lowercase`]: str::make_ascii_lowercase\n     /// [`to_lowercase`]: #method.to_lowercase\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]"}, {"sha": "1c3879c40c2f94c384009967e4c5e5a73bdb5bde", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 45, "deletions": 87, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -4,8 +4,6 @@\n //! [`ToString`]s, and several error types that may result from working with\n //! [`String`]s.\n //!\n-//! [`ToString`]: trait.ToString.html\n-//!\n //! # Examples\n //!\n //! There are multiple ways to create a new [`String`] from a string literal:\n@@ -20,8 +18,6 @@\n //! You can create a new [`String`] from an existing one by concatenating with\n //! `+`:\n //!\n-//! [`String`]: struct.String.html\n-//!\n //! ```\n //! let s = \"Hello\".to_string();\n //!\n@@ -67,11 +63,11 @@ use crate::vec::Vec;\n /// contents of the string. It has a close relationship with its borrowed\n /// counterpart, the primitive [`str`].\n ///\n-/// [`str`]: ../../std/primitive.str.html\n-///\n /// # Examples\n ///\n-/// You can create a `String` from a literal string with [`String::from`]:\n+/// You can create a `String` from [a literal string][str] with [`String::from`]:\n+///\n+/// [`String::from`]: From::from\n ///\n /// ```\n /// let hello = String::from(\"Hello, world!\");\n@@ -87,10 +83,8 @@ use crate::vec::Vec;\n /// hello.push_str(\"orld!\");\n /// ```\n ///\n-/// [`String::from`]: #method.from\n-/// [`char`]: ../../std/primitive.char.html\n-/// [`push`]: #method.push\n-/// [`push_str`]: #method.push_str\n+/// [`push`]: String::push\n+/// [`push_str`]: String::push_str\n ///\n /// If you have a vector of UTF-8 bytes, you can create a `String` from it with\n /// the [`from_utf8`] method:\n@@ -105,7 +99,7 @@ use crate::vec::Vec;\n /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n /// ```\n ///\n-/// [`from_utf8`]: #method.from_utf8\n+/// [`from_utf8`]: String::from_utf8\n ///\n /// # UTF-8\n ///\n@@ -128,8 +122,8 @@ use crate::vec::Vec;\n /// The [`bytes`] and [`chars`] methods return iterators over the first\n /// two, respectively.\n ///\n-/// [`bytes`]: #method.bytes\n-/// [`chars`]: #method.chars\n+/// [`bytes`]: str::bytes\n+/// [`chars`]: str::chars\n ///\n /// # Deref\n ///\n@@ -215,9 +209,9 @@ use crate::vec::Vec;\n /// assert_eq!(String::from(\"Once upon a time...\"), s);\n /// ```\n ///\n-/// [`as_ptr`]: #method.as_ptr\n-/// [`len`]: #method.len\n-/// [`capacity`]: #method.capacity\n+/// [`as_ptr`]: str::as_ptr\n+/// [`len`]: String::len\n+/// [`capacity`]: String::capacity\n ///\n /// If a `String` has enough capacity, adding elements to it will not\n /// re-allocate. For example, consider this program:\n@@ -259,7 +253,7 @@ use crate::vec::Vec;\n /// }\n /// ```\n ///\n-/// [`with_capacity`]: #method.with_capacity\n+/// [`with_capacity`]: String::with_capacity\n ///\n /// We end up with a different output:\n ///\n@@ -274,9 +268,9 @@ use crate::vec::Vec;\n ///\n /// Here, there's no need to allocate more memory inside the loop.\n ///\n-/// [`&str`]: ../../std/primitive.str.html\n-/// [`Deref`]: ../../std/ops/trait.Deref.html\n-/// [`as_str()`]: struct.String.html#method.as_str\n+/// [`&str`]: str\n+/// [`Deref`]: core::ops::Deref\n+/// [`as_str()`]: String::as_str\n #[derive(PartialOrd, Eq, Ord)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"string_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -291,20 +285,18 @@ pub struct String {\n /// [`into_bytes`] method will give back the byte vector that was used in the\n /// conversion attempt.\n ///\n-/// [`from_utf8`]: struct.String.html#method.from_utf8\n-/// [`String`]: struct.String.html\n-/// [`into_bytes`]: struct.FromUtf8Error.html#method.into_bytes\n+/// [`from_utf8`]: String::from_utf8\n+/// [`into_bytes`]: FromUtf8Error::into_bytes\n ///\n /// The [`Utf8Error`] type provided by [`std::str`] represents an error that may\n /// occur when converting a slice of [`u8`]s to a [`&str`]. In this sense, it's\n /// an analogue to `FromUtf8Error`, and you can get one from a `FromUtf8Error`\n /// through the [`utf8_error`] method.\n ///\n-/// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n-/// [`std::str`]: ../../std/str/index.html\n-/// [`u8`]: ../../std/primitive.u8.html\n-/// [`&str`]: ../../std/primitive.str.html\n-/// [`utf8_error`]: #method.utf8_error\n+/// [`Utf8Error`]: core::str::Utf8Error\n+/// [`std::str`]: core::str\n+/// [`&str`]: str\n+/// [`utf8_error`]: Self::utf8_error\n ///\n /// # Examples\n ///\n@@ -330,9 +322,7 @@ pub struct FromUtf8Error {\n ///\n /// This type is the error type for the [`from_utf16`] method on [`String`].\n ///\n-/// [`from_utf16`]: struct.String.html#method.from_utf16\n-/// [`String`]: struct.String.html\n-///\n+/// [`from_utf16`]: String::from_utf16\n /// # Examples\n ///\n /// Basic usage:\n@@ -358,7 +348,7 @@ impl String {\n     /// consider the [`with_capacity`] method to prevent excessive\n     /// re-allocation.\n     ///\n-    /// [`with_capacity`]: #method.with_capacity\n+    /// [`with_capacity`]: String::with_capacity\n     ///\n     /// # Examples\n     ///\n@@ -383,12 +373,12 @@ impl String {\n     /// appending a bunch of data to the `String`, reducing the number of\n     /// reallocations it needs to do.\n     ///\n-    /// [`capacity`]: #method.capacity\n+    /// [`capacity`]: String::capacity\n     ///\n     /// If the given capacity is `0`, no allocation will occur, and this method\n     /// is identical to the [`new`] method.\n     ///\n-    /// [`new`]: #method.new\n+    /// [`new`]: String::new\n     ///\n     /// # Examples\n     ///\n@@ -479,15 +469,10 @@ impl String {\n     /// See the docs for [`FromUtf8Error`] for more details on what you can do\n     /// with this error.\n     ///\n-    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n-    /// [`String`]: struct.String.html\n-    /// [`u8`]: ../../std/primitive.u8.html\n-    /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n-    /// [`&str`]: ../../std/primitive.str.html\n-    /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n-    /// [`into_bytes`]: struct.String.html#method.into_bytes\n-    /// [`FromUtf8Error`]: struct.FromUtf8Error.html\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+    /// [`from_utf8_unchecked`]: String::from_utf8_unchecked\n+    /// [`Vec<u8>`]: crate::vec::Vec\n+    /// [`&str`]: str\n+    /// [`into_bytes`]: String::into_bytes\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n@@ -506,24 +491,23 @@ impl String {\n     /// `from_utf8_lossy()` will replace any invalid UTF-8 sequences with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD], which looks like this: \ufffd\n     ///\n-    /// [`u8`]: ../../std/primitive.u8.html\n     /// [byteslice]: ../../std/primitive.slice.html\n-    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n+    /// [U+FFFD]: core::char::REPLACEMENT_CHARACTER\n     ///\n     /// If you are sure that the byte slice is valid UTF-8, and you don't want\n     /// to incur the overhead of the conversion, there is an unsafe version\n     /// of this function, [`from_utf8_unchecked`], which has the same behavior\n     /// but skips the checks.\n     ///\n-    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n+    /// [`from_utf8_unchecked`]: String::from_utf8_unchecked\n     ///\n     /// This function returns a [`Cow<'a, str>`]. If our byte slice is invalid\n     /// UTF-8, then we need to insert the replacement characters, which will\n     /// change the size of the string, and hence, require a `String`. But if\n     /// it's already valid UTF-8, we don't need a new allocation. This return\n     /// type allows us to handle both cases.\n     ///\n-    /// [`Cow<'a, str>`]: ../../std/borrow/enum.Cow.html\n+    /// [`Cow<'a, str>`]: crate::borrow::Cow\n     ///\n     /// # Examples\n     ///\n@@ -583,8 +567,6 @@ impl String {\n     /// Decode a UTF-16 encoded vector `v` into a `String`, returning [`Err`]\n     /// if `v` contains any invalid data.\n     ///\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -623,9 +605,9 @@ impl String {\n     /// `from_utf16_lossy` returns a `String` since the UTF-16 to UTF-8\n     /// conversion requires a memory allocation.\n     ///\n-    /// [`from_utf8_lossy`]: #method.from_utf8_lossy\n-    /// [`Cow<'a, str>`]: ../borrow/enum.Cow.html\n-    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n+    /// [`from_utf8_lossy`]: String::from_utf8_lossy\n+    /// [`Cow<'a, str>`]: crate::borrow::Cow\n+    /// [U+FFFD]: core::char::REPLACEMENT_CHARACTER\n     ///\n     /// # Examples\n     ///\n@@ -659,7 +641,7 @@ impl String {\n     /// into a `String` with the [`from_raw_parts`] function, allowing\n     /// the destructor to perform the cleanup.\n     ///\n-    /// [`from_raw_parts`]: #method.from_raw_parts\n+    /// [`from_raw_parts`]: String::from_raw_parts\n     ///\n     /// # Examples\n     ///\n@@ -732,7 +714,7 @@ impl String {\n     ///\n     /// See the safe version, [`from_utf8`], for more details.\n     ///\n-    /// [`from_utf8`]: struct.String.html#method.from_utf8\n+    /// [`from_utf8`]: String::from_utf8\n     ///\n     /// # Safety\n     ///\n@@ -867,8 +849,7 @@ impl String {\n     ///\n     /// Panics if the new capacity overflows [`usize`].\n     ///\n-    /// [`reserve_exact`]: struct.String.html#method.reserve_exact\n-    /// [`usize`]: ../../std/primitive.usize.html\n+    /// [`reserve_exact`]: String::reserve_exact\n     ///\n     /// # Examples\n     ///\n@@ -911,7 +892,7 @@ impl String {\n     /// Consider using the [`reserve`] method unless you absolutely know\n     /// better than the allocator.\n     ///\n-    /// [`reserve`]: #method.reserve\n+    /// [`reserve`]: String::reserve\n     ///\n     /// # Panics\n     ///\n@@ -1076,8 +1057,6 @@ impl String {\n \n     /// Appends the given [`char`] to the end of this `String`.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1104,7 +1083,7 @@ impl String {\n     ///\n     /// The inverse of this method is [`from_utf8`].\n     ///\n-    /// [`from_utf8`]: #method.from_utf8\n+    /// [`from_utf8`]: String::from_utf8\n     ///\n     /// # Examples\n     ///\n@@ -1133,8 +1112,6 @@ impl String {\n     ///\n     /// Panics if `new_len` does not lie on a [`char`] boundary.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1159,8 +1136,6 @@ impl String {\n     ///\n     /// Returns [`None`] if this `String` is empty.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1195,8 +1170,6 @@ impl String {\n     /// Panics if `idx` is larger than or equal to the `String`'s length,\n     /// or if it does not lie on a [`char`] boundary.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1297,8 +1270,6 @@ impl String {\n     /// Panics if `idx` is larger than the `String`'s length, or if it does not\n     /// lie on a [`char`] boundary.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1346,8 +1317,6 @@ impl String {\n     /// Panics if `idx` is larger than the `String`'s length, or if it does not\n     /// lie on a [`char`] boundary.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1507,8 +1476,6 @@ impl String {\n     /// Panics if the starting point or end point do not lie on a [`char`]\n     /// boundary, or if they're out of bounds.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1567,9 +1534,6 @@ impl String {\n     /// Panics if the starting point or end point do not lie on a [`char`]\n     /// boundary, or if they're out of bounds.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    /// [`Vec::splice`]: ../../std/vec/struct.Vec.html#method.splice\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1610,9 +1574,6 @@ impl String {\n     ///\n     /// This will drop any excess capacity.\n     ///\n-    /// [`Box`]: ../../std/boxed/struct.Box.html\n-    /// [`str`]: ../../std/primitive.str.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1680,10 +1641,8 @@ impl FromUtf8Error {\n     /// an analogue to `FromUtf8Error`. See its documentation for more details\n     /// on using it.\n     ///\n-    /// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n-    /// [`std::str`]: ../../std/str/index.html\n-    /// [`u8`]: ../../std/primitive.u8.html\n-    /// [`&str`]: ../../std/primitive.str.html\n+    /// [`std::str`]: core::str\n+    /// [`&str`]: str\n     ///\n     /// # Examples\n     ///\n@@ -2187,7 +2146,7 @@ impl ops::DerefMut for String {\n ///\n /// This alias exists for backwards compatibility, and may be eventually deprecated.\n ///\n-/// [`Infallible`]: ../../core/convert/enum.Infallible.html\n+/// [`Infallible`]: core::convert::Infallible\n #[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n pub type ParseError = core::convert::Infallible;\n \n@@ -2207,7 +2166,7 @@ impl FromStr for String {\n /// [`Display`] should be implemented instead, and you get the `ToString`\n /// implementation for free.\n ///\n-/// [`Display`]: ../../std/fmt/trait.Display.html\n+/// [`Display`]: fmt::Display\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ToString {\n     /// Converts the given value to a `String`.\n@@ -2465,8 +2424,7 @@ impl fmt::Write for String {\n /// This struct is created by the [`drain`] method on [`String`]. See its\n /// documentation for more.\n ///\n-/// [`drain`]: struct.String.html#method.drain\n-/// [`String`]: struct.String.html\n+/// [`drain`]: String::drain\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a> {\n     /// Will be used as &'a mut String in the destructor"}, {"sha": "3116815f5d655a03461d6cfbc19f19a056aa78ec", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -45,7 +45,8 @@ use crate::intrinsics;\n /// ```\n #[inline]\n #[stable(feature = \"unreachable\", since = \"1.27.0\")]\n-pub unsafe fn unreachable_unchecked() -> ! {\n+#[rustc_const_unstable(feature = \"const_unreachable_unchecked\", issue = \"53188\")]\n+pub const unsafe fn unreachable_unchecked() -> ! {\n     // SAFETY: the safety contract for `intrinsics::unreachable` must\n     // be upheld by the caller.\n     unsafe { intrinsics::unreachable() }"}, {"sha": "049f51fb1035a3d2a3ea4496135eff651a85fa51", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -932,6 +932,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::hint::unreachable_unchecked`](../../std/hint/fn.unreachable_unchecked.html).\n+    #[rustc_const_unstable(feature = \"const_unreachable_unchecked\", issue = \"53188\")]\n     pub fn unreachable() -> !;\n \n     /// Informs the optimizer that a condition is always true.\n@@ -1957,15 +1958,23 @@ extern \"rust-intrinsic\" {\n     /// Internal placeholder for injecting code coverage counters when the \"instrument-coverage\"\n     /// option is enabled. The placeholder is replaced with `llvm.instrprof.increment` during code\n     /// generation.\n+    #[cfg(not(bootstrap))]\n     #[lang = \"count_code_region\"]\n-    pub fn count_code_region(index: u32, start_byte_pos: u32, end_byte_pos: u32);\n+    pub fn count_code_region(\n+        function_source_hash: u64,\n+        index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n \n     /// Internal marker for code coverage expressions, injected into the MIR when the\n     /// \"instrument-coverage\" option is enabled. This intrinsic is not converted into a\n     /// backend intrinsic call, but its arguments are extracted during the production of a\n     /// \"coverage map\", which is injected into the generated code, as additional data.\n     /// This marker identifies a code region and two other counters or counter expressions\n     /// whose sum is the number of times the code region was executed.\n+    #[cfg(not(bootstrap))]\n+    #[lang = \"coverage_counter_add\"]\n     pub fn coverage_counter_add(\n         index: u32,\n         left_index: u32,\n@@ -1977,6 +1986,8 @@ extern \"rust-intrinsic\" {\n     /// This marker identifies a code region and two other counters or counter expressions\n     /// whose difference is the number of times the code region was executed.\n     /// (See `coverage_counter_add` for more information.)\n+    #[cfg(not(bootstrap))]\n+    #[lang = \"coverage_counter_subtract\"]\n     pub fn coverage_counter_subtract(\n         index: u32,\n         left_index: u32,"}, {"sha": "2e443064706d239117b7890ee3f74ff07daaa3bd", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -92,6 +92,7 @@\n #![feature(const_slice_ptr_len)]\n #![feature(const_type_name)]\n #![feature(const_likely)]\n+#![feature(const_unreachable_unchecked)]\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]\n #![feature(doc_cfg)]"}, {"sha": "790ec4bd24f8dcab225c7a3c52ee4550f497e270", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -4,7 +4,7 @@\n //!\n //! For more details, see the [`std::str`] module.\n //!\n-//! [`std::str`]: ../../std/str/index.html\n+//! [`std::str`]: self\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -163,13 +163,11 @@ Section: Creating a string\n /// Errors which can occur when attempting to interpret a sequence of [`u8`]\n /// as a string.\n ///\n-/// [`u8`]: ../../std/primitive.u8.html\n-///\n /// As such, the `from_utf8` family of functions and methods for both [`String`]s\n /// and [`&str`]s make use of this error, for example.\n ///\n /// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n-/// [`&str`]: ../../std/str/fn.from_utf8.html\n+/// [`&str`]: from_utf8\n ///\n /// # Examples\n ///"}, {"sha": "3d6f4f5971a62db2a88b3657a26008ade27732c4", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -9,3 +9,7 @@ pub use self::poll::Poll;\n mod wake;\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::wake::{Context, RawWaker, RawWakerVTable, Waker};\n+\n+mod ready;\n+#[unstable(feature = \"ready_macro\", issue = \"70922\")]\n+pub use ready::ready;"}, {"sha": "d4e733eb2bcf52668466933ba6555b92d77a29cb", "filename": "src/libcore/task/ready.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Ftask%2Fready.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibcore%2Ftask%2Fready.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fready.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,60 @@\n+/// Extracts the successful type of a `Poll<T>`.\n+///\n+/// This macro bakes in propagation of `Pending` signals by returning early.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(future_readiness_fns)]\n+/// #![feature(ready_macro)]\n+///\n+/// use core::task::{ready, Context, Poll};\n+/// use core::future::{self, Future};\n+/// use core::pin::Pin;\n+///\n+/// pub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {\n+///     let mut fut = future::ready(42);\n+///     let fut = Pin::new(&mut fut);\n+///\n+///     let num = ready!(fut.poll(cx));\n+///     # drop(num);\n+///     // ... use num\n+///\n+///     Poll::Ready(())\n+/// }\n+/// ```\n+///\n+/// The `ready!` call expands to:\n+///\n+/// ```\n+/// # #![feature(future_readiness_fns)]\n+/// # #![feature(ready_macro)]\n+/// #\n+/// # use core::task::{Context, Poll};\n+/// # use core::future::{self, Future};\n+/// # use core::pin::Pin;\n+/// #\n+/// # pub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {\n+///     # let mut fut = future::ready(42);\n+///     # let fut = Pin::new(&mut fut);\n+///     #\n+/// let num = match fut.poll(cx) {\n+///     Poll::Ready(t) => t,\n+///     Poll::Pending => return Poll::Pending,\n+/// };\n+///     # drop(num);\n+///     # // ... use num\n+///     #\n+///     # Poll::Ready(())\n+/// # }\n+/// ```\n+#[unstable(feature = \"ready_macro\", issue = \"70922\")]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro ready($e:expr) {\n+    match $e {\n+        $crate::task::Poll::Ready(t) => t,\n+        $crate::task::Poll::Pending => {\n+            return $crate::task::Poll::Pending;\n+        }\n+    }\n+}"}, {"sha": "227a87ff8199495c2b8a9549c2bd44a1b827c777", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -133,6 +133,9 @@ fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n         return;\n     }\n \n+    // FIXME(richkadel): Make sure probestack plays nice with `-Z instrument-coverage`\n+    // or disable it if not, similar to above early exits.\n+\n     // Flag our internal `__rust_probestack` function as the stack probe symbol.\n     // This is defined in the `compiler-builtins` crate for each architecture.\n     llvm::AddFunctionAttrStringValue("}, {"sha": "b19199b9cfabd5bc80beb7dbc6fc167f3af7e0df", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -144,17 +144,18 @@ pub fn compile_codegen_unit(\n                 }\n             }\n \n+            // Finalize code coverage by injecting the coverage map. Note, the coverage map will\n+            // also be added to the `llvm.used` variable, created next.\n+            if cx.sess().opts.debugging_opts.instrument_coverage {\n+                cx.coverageinfo_finalize();\n+            }\n+\n             // Create the llvm.used variable\n             // This variable has type [N x i8*] and is stored in the llvm.metadata section\n             if !cx.used_statics().borrow().is_empty() {\n                 cx.create_used_variable()\n             }\n \n-            // Finalize code coverage by injecting the coverage map\n-            if cx.sess().opts.debugging_opts.instrument_coverage {\n-                cx.coverageinfo_finalize();\n-            }\n-\n             // Finalize debuginfo\n             if cx.sess().opts.debuginfo != DebugInfo::None {\n                 cx.debuginfo_finalize();"}, {"sha": "d58aad340a1dcbc57044edd5f0b473098b84cfbd", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1060,7 +1060,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             fn_name, hash, num_counters, index\n         );\n \n-        let llfn = unsafe { llvm::LLVMRustGetInstrprofIncrementIntrinsic(self.cx().llmod) };\n+        let llfn = unsafe { llvm::LLVMRustGetInstrProfIncrementIntrinsic(self.cx().llmod) };\n         let args = &[fn_name, hash, num_counters, index];\n         let args = self.check_call(\"call\", llfn, args);\n "}, {"sha": "c954415f19f346c080508c8df49bc1aa29f83ed7", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -493,10 +493,14 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n             }\n \n             if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n-                // This static will be stored in the llvm.used variable which is an array of i8*\n-                let cast = llvm::LLVMConstPointerCast(g, self.type_i8p());\n-                self.used_statics.borrow_mut().push(cast);\n+                self.add_used_global(g);\n             }\n         }\n     }\n+\n+    /// Add a global value to a list to be stored in the `llvm.used` variable, an array of i8*.\n+    fn add_used_global(&self, global: &'ll Value) {\n+        let cast = unsafe { llvm::LLVMConstPointerCast(global, self.type_i8p()) };\n+        self.used_statics.borrow_mut().push(cast);\n+    }\n }"}, {"sha": "7f48b1d864c7ca2256aa7334273812b9e72632e2", "filename": "src/librustc_codegen_llvm/coverageinfo/mapgen.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,274 @@\n+use crate::llvm;\n+\n+use crate::common::CodegenCx;\n+use crate::coverageinfo;\n+\n+use log::debug;\n+use rustc_codegen_ssa::coverageinfo::map::*;\n+use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, MiscMethods};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_llvm::RustString;\n+use rustc_middle::ty::Instance;\n+use rustc_middle::{bug, mir};\n+\n+use std::collections::BTreeMap;\n+use std::ffi::CString;\n+use std::path::PathBuf;\n+\n+// FIXME(richkadel): Complete all variations of generating and exporting the coverage map to LLVM.\n+// The current implementation is an initial foundation with basic capabilities (Counters, but not\n+// CounterExpressions, etc.).\n+\n+/// Generates and exports the Coverage Map.\n+///\n+/// This Coverage Map complies with Coverage Mapping Format version 3 (zero-based encoded as 2),\n+/// as defined at [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format)\n+/// and published in Rust's current (July 2020) fork of LLVM. This version is supported by the\n+/// LLVM coverage tools (`llvm-profdata` and `llvm-cov`) bundled with Rust's fork of LLVM.\n+///\n+/// Consequently, Rust's bundled version of Clang also generates Coverage Maps compliant with\n+/// version 3. Clang's implementation of Coverage Map generation was referenced when implementing\n+/// this Rust version, and though the format documentation is very explicit and detailed, some\n+/// undocumented details in Clang's implementation (that may or may not be important) were also\n+/// replicated for Rust's Coverage Map.\n+pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n+    let mut coverage_writer = CoverageMappingWriter::new(cx);\n+\n+    let function_coverage_map = cx.coverage_context().take_function_coverage_map();\n+\n+    // Encode coverage mappings and generate function records\n+    let mut function_records = Vec::<&'ll llvm::Value>::new();\n+    let coverage_mappings_buffer = llvm::build_byte_buffer(|coverage_mappings_buffer| {\n+        for (instance, function_coverage) in function_coverage_map.into_iter() {\n+            if let Some(function_record) = coverage_writer.write_function_mappings_and_record(\n+                instance,\n+                function_coverage,\n+                coverage_mappings_buffer,\n+            ) {\n+                function_records.push(function_record);\n+            }\n+        }\n+    });\n+\n+    // Encode all filenames covered in this module, ordered by `file_id`\n+    let filenames_buffer = llvm::build_byte_buffer(|filenames_buffer| {\n+        coverageinfo::write_filenames_section_to_buffer(\n+            &coverage_writer.filenames,\n+            filenames_buffer,\n+        );\n+    });\n+\n+    if coverage_mappings_buffer.len() > 0 {\n+        // Generate the LLVM IR representation of the coverage map and store it in a well-known\n+        // global constant.\n+        coverage_writer.write_coverage_map(\n+            function_records,\n+            filenames_buffer,\n+            coverage_mappings_buffer,\n+        );\n+    }\n+}\n+\n+struct CoverageMappingWriter<'a, 'll, 'tcx> {\n+    cx: &'a CodegenCx<'ll, 'tcx>,\n+    filenames: Vec<CString>,\n+    filename_to_index: FxHashMap<CString, u32>,\n+}\n+\n+impl<'a, 'll, 'tcx> CoverageMappingWriter<'a, 'll, 'tcx> {\n+    fn new(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n+        Self { cx, filenames: Vec::new(), filename_to_index: FxHashMap::<CString, u32>::default() }\n+    }\n+\n+    /// For the given function, get the coverage region data, stream it to the given buffer, and\n+    /// then generate and return a new function record.\n+    fn write_function_mappings_and_record(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        mut function_coverage: FunctionCoverage,\n+        coverage_mappings_buffer: &RustString,\n+    ) -> Option<&'ll llvm::Value> {\n+        let cx = self.cx;\n+        let coverageinfo: &mir::CoverageInfo = cx.tcx.coverageinfo(instance.def_id());\n+        debug!(\n+            \"Generate coverage map for: {:?}, num_counters: {}, num_expressions: {}\",\n+            instance, coverageinfo.num_counters, coverageinfo.num_expressions\n+        );\n+        debug_assert!(coverageinfo.num_counters > 0);\n+\n+        let regions_in_file_order = function_coverage.regions_in_file_order(cx.sess().source_map());\n+        if regions_in_file_order.len() == 0 {\n+            return None;\n+        }\n+\n+        // Stream the coverage mapping regions for the function (`instance`) to the buffer, and\n+        // compute the data byte size used.\n+        let old_len = coverage_mappings_buffer.len();\n+        self.regions_to_mappings(regions_in_file_order, coverage_mappings_buffer);\n+        let mapping_data_size = coverage_mappings_buffer.len() - old_len;\n+        debug_assert!(mapping_data_size > 0);\n+\n+        let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n+        let name_ref = coverageinfo::compute_hash(&mangled_function_name);\n+        let function_source_hash = function_coverage.source_hash();\n+\n+        // Generate and return the function record\n+        let name_ref_val = cx.const_u64(name_ref);\n+        let mapping_data_size_val = cx.const_u32(mapping_data_size as u32);\n+        let func_hash_val = cx.const_u64(function_source_hash);\n+        Some(cx.const_struct(\n+            &[name_ref_val, mapping_data_size_val, func_hash_val],\n+            /*packed=*/ true,\n+        ))\n+    }\n+\n+    /// For each coverage region, extract its coverage data from the earlier coverage analysis.\n+    /// Use LLVM APIs to convert the data into buffered bytes compliant with the LLVM Coverage\n+    /// Mapping format.\n+    fn regions_to_mappings(\n+        &mut self,\n+        regions_in_file_order: BTreeMap<PathBuf, BTreeMap<CoverageLoc, (usize, CoverageKind)>>,\n+        coverage_mappings_buffer: &RustString,\n+    ) {\n+        let mut virtual_file_mapping = Vec::new();\n+        let mut mapping_regions = coverageinfo::SmallVectorCounterMappingRegion::new();\n+        let mut expressions = coverageinfo::SmallVectorCounterExpression::new();\n+\n+        for (file_id, (file_path, file_coverage_regions)) in\n+            regions_in_file_order.into_iter().enumerate()\n+        {\n+            let file_id = file_id as u32;\n+            let filename = CString::new(file_path.to_string_lossy().to_string())\n+                .expect(\"null error converting filename to C string\");\n+            debug!(\"  file_id: {} = '{:?}'\", file_id, filename);\n+            let filenames_index = match self.filename_to_index.get(&filename) {\n+                Some(index) => *index,\n+                None => {\n+                    let index = self.filenames.len() as u32;\n+                    self.filenames.push(filename.clone());\n+                    self.filename_to_index.insert(filename, index);\n+                    index\n+                }\n+            };\n+            virtual_file_mapping.push(filenames_index);\n+\n+            let mut mapping_indexes = vec![0 as u32; file_coverage_regions.len()];\n+            for (mapping_index, (region_id, _)) in file_coverage_regions.values().enumerate() {\n+                mapping_indexes[*region_id] = mapping_index as u32;\n+            }\n+\n+            for (region_loc, (region_id, region_kind)) in file_coverage_regions.into_iter() {\n+                let mapping_index = mapping_indexes[region_id];\n+                match region_kind {\n+                    CoverageKind::Counter => {\n+                        debug!(\n+                            \"  Counter {}, file_id: {}, region_loc: {}\",\n+                            mapping_index, file_id, region_loc\n+                        );\n+                        mapping_regions.push_from(\n+                            mapping_index,\n+                            file_id,\n+                            region_loc.start_line,\n+                            region_loc.start_col,\n+                            region_loc.end_line,\n+                            region_loc.end_col,\n+                        );\n+                    }\n+                    CoverageKind::CounterExpression(lhs, op, rhs) => {\n+                        debug!(\n+                            \"  CounterExpression {} = {} {:?} {}, file_id: {}, region_loc: {:?}\",\n+                            mapping_index, lhs, op, rhs, file_id, region_loc,\n+                        );\n+                        mapping_regions.push_from(\n+                            mapping_index,\n+                            file_id,\n+                            region_loc.start_line,\n+                            region_loc.start_col,\n+                            region_loc.end_line,\n+                            region_loc.end_col,\n+                        );\n+                        expressions.push_from(op, lhs, rhs);\n+                    }\n+                    CoverageKind::Unreachable => {\n+                        debug!(\n+                            \"  Unreachable region, file_id: {}, region_loc: {:?}\",\n+                            file_id, region_loc,\n+                        );\n+                        bug!(\"Unreachable region not expected and not yet handled!\")\n+                        // FIXME(richkadel): implement and call\n+                        //   mapping_regions.push_from(...) for unreachable regions\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Encode and append the current function's coverage mapping data\n+        coverageinfo::write_mapping_to_buffer(\n+            virtual_file_mapping,\n+            expressions,\n+            mapping_regions,\n+            coverage_mappings_buffer,\n+        );\n+    }\n+\n+    fn write_coverage_map(\n+        self,\n+        function_records: Vec<&'ll llvm::Value>,\n+        filenames_buffer: Vec<u8>,\n+        mut coverage_mappings_buffer: Vec<u8>,\n+    ) {\n+        let cx = self.cx;\n+\n+        // Concatenate the encoded filenames and encoded coverage mappings, and add additional zero\n+        // bytes as-needed to ensure 8-byte alignment.\n+        let mut coverage_size = coverage_mappings_buffer.len();\n+        let filenames_size = filenames_buffer.len();\n+        let remaining_bytes =\n+            (filenames_size + coverage_size) % coverageinfo::COVMAP_VAR_ALIGN_BYTES;\n+        if remaining_bytes > 0 {\n+            let pad = coverageinfo::COVMAP_VAR_ALIGN_BYTES - remaining_bytes;\n+            coverage_mappings_buffer.append(&mut [0].repeat(pad));\n+            coverage_size += pad;\n+        }\n+        let filenames_and_coverage_mappings = [filenames_buffer, coverage_mappings_buffer].concat();\n+        let filenames_and_coverage_mappings_val =\n+            cx.const_bytes(&filenames_and_coverage_mappings[..]);\n+\n+        debug!(\n+            \"cov map: n_records = {}, filenames_size = {}, coverage_size = {}, 0-based version = {}\",\n+            function_records.len(),\n+            filenames_size,\n+            coverage_size,\n+            coverageinfo::mapping_version()\n+        );\n+\n+        // Create the coverage data header\n+        let n_records_val = cx.const_u32(function_records.len() as u32);\n+        let filenames_size_val = cx.const_u32(filenames_size as u32);\n+        let coverage_size_val = cx.const_u32(coverage_size as u32);\n+        let version_val = cx.const_u32(coverageinfo::mapping_version());\n+        let cov_data_header_val = cx.const_struct(\n+            &[n_records_val, filenames_size_val, coverage_size_val, version_val],\n+            /*packed=*/ false,\n+        );\n+\n+        // Create the function records array\n+        let name_ref_from_u64 = cx.type_i64();\n+        let mapping_data_size_from_u32 = cx.type_i32();\n+        let func_hash_from_u64 = cx.type_i64();\n+        let function_record_ty = cx.type_struct(\n+            &[name_ref_from_u64, mapping_data_size_from_u32, func_hash_from_u64],\n+            /*packed=*/ true,\n+        );\n+        let function_records_val = cx.const_array(function_record_ty, &function_records[..]);\n+\n+        // Create the complete LLVM coverage data value to add to the LLVM IR\n+        let cov_data_val = cx.const_struct(\n+            &[cov_data_header_val, function_records_val, filenames_and_coverage_mappings_val],\n+            /*packed=*/ false,\n+        );\n+\n+        // Save the coverage data value to LLVM IR\n+        coverageinfo::save_map_to_mod(cx, cov_data_val);\n+    }\n+}"}, {"sha": "76894bcd6c1b1c4a63c8b1bcc8c0ef859a629b58", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 204, "deletions": 62, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1,88 +1,67 @@\n+use crate::llvm;\n+\n use crate::builder::Builder;\n use crate::common::CodegenCx;\n+\n+use libc::c_uint;\n use log::debug;\n use rustc_codegen_ssa::coverageinfo::map::*;\n-use rustc_codegen_ssa::traits::{CoverageInfoBuilderMethods, CoverageInfoMethods};\n+use rustc_codegen_ssa::traits::{\n+    BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, StaticMethods,\n+};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_llvm::RustString;\n use rustc_middle::ty::Instance;\n \n use std::cell::RefCell;\n+use std::ffi::CString;\n+\n+pub mod mapgen;\n+\n+const COVMAP_VAR_ALIGN_BYTES: usize = 8;\n \n /// A context object for maintaining all state needed by the coverageinfo module.\n pub struct CrateCoverageContext<'tcx> {\n     // Coverage region data for each instrumented function identified by DefId.\n-    pub(crate) coverage_regions: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverageRegions>>,\n+    pub(crate) function_coverage_map: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverage>>,\n }\n \n impl<'tcx> CrateCoverageContext<'tcx> {\n     pub fn new() -> Self {\n-        Self { coverage_regions: Default::default() }\n+        Self { function_coverage_map: Default::default() }\n     }\n-}\n \n-/// Generates and exports the Coverage Map.\n-// FIXME(richkadel): Actually generate and export the coverage map to LLVM.\n-// The current implementation is actually just debug messages to show the data is available.\n-pub fn finalize(cx: &CodegenCx<'_, '_>) {\n-    let coverage_regions = &*cx.coverage_context().coverage_regions.borrow();\n-    for instance in coverage_regions.keys() {\n-        let coverageinfo = cx.tcx.coverageinfo(instance.def_id());\n-        debug_assert!(coverageinfo.num_counters > 0);\n-        debug!(\n-            \"Generate coverage map for: {:?}, hash: {}, num_counters: {}\",\n-            instance, coverageinfo.hash, coverageinfo.num_counters\n-        );\n-        let function_coverage_regions = &coverage_regions[instance];\n-        for (index, region) in function_coverage_regions.indexed_regions() {\n-            match region.kind {\n-                CoverageKind::Counter => debug!(\n-                    \"  Counter {}, for {}..{}\",\n-                    index, region.coverage_span.start_byte_pos, region.coverage_span.end_byte_pos\n-                ),\n-                CoverageKind::CounterExpression(lhs, op, rhs) => debug!(\n-                    \"  CounterExpression {} = {} {:?} {}, for {}..{}\",\n-                    index,\n-                    lhs,\n-                    op,\n-                    rhs,\n-                    region.coverage_span.start_byte_pos,\n-                    region.coverage_span.end_byte_pos\n-                ),\n-            }\n-        }\n-        for unreachable in function_coverage_regions.unreachable_regions() {\n-            debug!(\n-                \"  Unreachable code region: {}..{}\",\n-                unreachable.start_byte_pos, unreachable.end_byte_pos\n-            );\n-        }\n+    pub fn take_function_coverage_map(&self) -> FxHashMap<Instance<'tcx>, FunctionCoverage> {\n+        self.function_coverage_map.replace(FxHashMap::default())\n     }\n }\n \n impl CoverageInfoMethods for CodegenCx<'ll, 'tcx> {\n     fn coverageinfo_finalize(&self) {\n-        finalize(self)\n+        mapgen::finalize(self)\n     }\n }\n \n impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,\n+        function_source_hash: u64,\n         index: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n         debug!(\n-            \"adding counter to coverage map: instance={:?}, index={}, byte range {}..{}\",\n-            instance, index, start_byte_pos, end_byte_pos,\n-        );\n-        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n-        coverage_regions.entry(instance).or_default().add_counter(\n-            index,\n-            start_byte_pos,\n-            end_byte_pos,\n+            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, index={}, byte range {}..{}\",\n+            instance, function_source_hash, index, start_byte_pos, end_byte_pos,\n         );\n+        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n+        coverage_regions\n+            .entry(instance)\n+            .or_insert_with(|| {\n+                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n+            })\n+            .add_counter(function_source_hash, index, start_byte_pos, end_byte_pos);\n     }\n \n     fn add_counter_expression_region(\n@@ -96,18 +75,16 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         end_byte_pos: u32,\n     ) {\n         debug!(\n-            \"adding counter expression to coverage map: instance={:?}, index={}, {} {:?} {}, byte range {}..{}\",\n+            \"adding counter expression to coverage_regions: instance={:?}, index={}, {} {:?} {}, byte range {}..{}\",\n             instance, index, lhs, op, rhs, start_byte_pos, end_byte_pos,\n         );\n-        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n-        coverage_regions.entry(instance).or_default().add_counter_expression(\n-            index,\n-            lhs,\n-            op,\n-            rhs,\n-            start_byte_pos,\n-            end_byte_pos,\n-        );\n+        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n+        coverage_regions\n+            .entry(instance)\n+            .or_insert_with(|| {\n+                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n+            })\n+            .add_counter_expression(index, lhs, op, rhs, start_byte_pos, end_byte_pos);\n     }\n \n     fn add_unreachable_region(\n@@ -117,10 +94,175 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         end_byte_pos: u32,\n     ) {\n         debug!(\n-            \"adding unreachable code to coverage map: instance={:?}, byte range {}..{}\",\n+            \"adding unreachable code to coverage_regions: instance={:?}, byte range {}..{}\",\n             instance, start_byte_pos, end_byte_pos,\n         );\n-        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n-        coverage_regions.entry(instance).or_default().add_unreachable(start_byte_pos, end_byte_pos);\n+        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n+        coverage_regions\n+            .entry(instance)\n+            .or_insert_with(|| {\n+                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n+            })\n+            .add_unreachable(start_byte_pos, end_byte_pos);\n+    }\n+}\n+\n+/// This struct wraps an opaque reference to the C++ template instantiation of\n+/// `llvm::SmallVector<coverage::CounterExpression>`. Each `coverage::CounterExpression` object is\n+/// constructed from primative-typed arguments, and pushed to the `SmallVector`, in the C++\n+/// implementation of `LLVMRustCoverageSmallVectorCounterExpressionAdd()` (see\n+/// `src/rustllvm/CoverageMappingWrapper.cpp`).\n+pub struct SmallVectorCounterExpression<'a> {\n+    pub raw: &'a mut llvm::coverageinfo::SmallVectorCounterExpression<'a>,\n+}\n+\n+impl SmallVectorCounterExpression<'a> {\n+    pub fn new() -> Self {\n+        SmallVectorCounterExpression {\n+            raw: unsafe { llvm::LLVMRustCoverageSmallVectorCounterExpressionCreate() },\n+        }\n+    }\n+\n+    pub fn as_ptr(&self) -> *const llvm::coverageinfo::SmallVectorCounterExpression<'a> {\n+        self.raw\n+    }\n+\n+    pub fn push_from(\n+        &mut self,\n+        kind: rustc_codegen_ssa::coverageinfo::CounterOp,\n+        left_index: u32,\n+        right_index: u32,\n+    ) {\n+        unsafe {\n+            llvm::LLVMRustCoverageSmallVectorCounterExpressionAdd(\n+                &mut *(self.raw as *mut _),\n+                kind,\n+                left_index,\n+                right_index,\n+            )\n+        }\n+    }\n+}\n+\n+impl Drop for SmallVectorCounterExpression<'a> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustCoverageSmallVectorCounterExpressionDispose(&mut *(self.raw as *mut _));\n+        }\n+    }\n+}\n+\n+/// This struct wraps an opaque reference to the C++ template instantiation of\n+/// `llvm::SmallVector<coverage::CounterMappingRegion>`. Each `coverage::CounterMappingRegion`\n+/// object is constructed from primative-typed arguments, and pushed to the `SmallVector`, in the\n+/// C++ implementation of `LLVMRustCoverageSmallVectorCounterMappingRegionAdd()` (see\n+/// `src/rustllvm/CoverageMappingWrapper.cpp`).\n+pub struct SmallVectorCounterMappingRegion<'a> {\n+    pub raw: &'a mut llvm::coverageinfo::SmallVectorCounterMappingRegion<'a>,\n+}\n+\n+impl SmallVectorCounterMappingRegion<'a> {\n+    pub fn new() -> Self {\n+        SmallVectorCounterMappingRegion {\n+            raw: unsafe { llvm::LLVMRustCoverageSmallVectorCounterMappingRegionCreate() },\n+        }\n+    }\n+\n+    pub fn as_ptr(&self) -> *const llvm::coverageinfo::SmallVectorCounterMappingRegion<'a> {\n+        self.raw\n+    }\n+\n+    pub fn push_from(\n+        &mut self,\n+        index: u32,\n+        file_id: u32,\n+        line_start: u32,\n+        column_start: u32,\n+        line_end: u32,\n+        column_end: u32,\n+    ) {\n+        unsafe {\n+            llvm::LLVMRustCoverageSmallVectorCounterMappingRegionAdd(\n+                &mut *(self.raw as *mut _),\n+                index,\n+                file_id,\n+                line_start,\n+                column_start,\n+                line_end,\n+                column_end,\n+            )\n+        }\n+    }\n+}\n+\n+impl Drop for SmallVectorCounterMappingRegion<'a> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustCoverageSmallVectorCounterMappingRegionDispose(\n+                &mut *(self.raw as *mut _),\n+            );\n+        }\n+    }\n+}\n+\n+pub(crate) fn write_filenames_section_to_buffer(filenames: &Vec<CString>, buffer: &RustString) {\n+    let c_str_vec = filenames.iter().map(|cstring| cstring.as_ptr()).collect::<Vec<_>>();\n+    unsafe {\n+        llvm::LLVMRustCoverageWriteFilenamesSectionToBuffer(\n+            c_str_vec.as_ptr(),\n+            c_str_vec.len(),\n+            buffer,\n+        );\n+    }\n+}\n+\n+pub(crate) fn write_mapping_to_buffer(\n+    virtual_file_mapping: Vec<u32>,\n+    expressions: SmallVectorCounterExpression<'_>,\n+    mapping_regions: SmallVectorCounterMappingRegion<'_>,\n+    buffer: &RustString,\n+) {\n+    unsafe {\n+        llvm::LLVMRustCoverageWriteMappingToBuffer(\n+            virtual_file_mapping.as_ptr(),\n+            virtual_file_mapping.len() as c_uint,\n+            expressions.as_ptr(),\n+            mapping_regions.as_ptr(),\n+            buffer,\n+        );\n     }\n }\n+\n+pub(crate) fn compute_hash(name: &str) -> u64 {\n+    let name = CString::new(name).expect(\"null error converting hashable name to C string\");\n+    unsafe { llvm::LLVMRustCoverageComputeHash(name.as_ptr()) }\n+}\n+\n+pub(crate) fn mapping_version() -> u32 {\n+    unsafe { llvm::LLVMRustCoverageMappingVersion() }\n+}\n+\n+pub(crate) fn save_map_to_mod<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    cov_data_val: &'ll llvm::Value,\n+) {\n+    let covmap_var_name = llvm::build_string(|s| unsafe {\n+        llvm::LLVMRustCoverageWriteMappingVarNameToString(s);\n+    })\n+    .expect(\"Rust Coverage Mapping var name failed UTF-8 conversion\");\n+    debug!(\"covmap var name: {:?}\", covmap_var_name);\n+\n+    let covmap_section_name = llvm::build_string(|s| unsafe {\n+        llvm::LLVMRustCoverageWriteSectionNameToString(cx.llmod, s);\n+    })\n+    .expect(\"Rust Coverage section name failed UTF-8 conversion\");\n+    debug!(\"covmap section name: {:?}\", covmap_section_name);\n+\n+    let llglobal = llvm::add_global(cx.llmod, cx.val_ty(cov_data_val), &covmap_var_name);\n+    llvm::set_initializer(llglobal, cov_data_val);\n+    llvm::set_global_constant(llglobal, true);\n+    llvm::set_linkage(llglobal, llvm::Linkage::InternalLinkage);\n+    llvm::set_section(llglobal, &covmap_section_name);\n+    llvm::set_alignment(llglobal, COVMAP_VAR_ALIGN_BYTES);\n+    cx.add_used_global(llglobal);\n+}"}, {"sha": "63ec8031483fed508f50f03fa06d6d29284f627a", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -90,45 +90,64 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &Vec<Operand<'tcx>>,\n         caller_instance: ty::Instance<'tcx>,\n     ) -> bool {\n-        match intrinsic {\n-            sym::count_code_region => {\n-                use coverage::count_code_region_args::*;\n-                self.add_counter_region(\n-                    caller_instance,\n-                    op_to_u32(&args[COUNTER_INDEX]),\n-                    op_to_u32(&args[START_BYTE_POS]),\n-                    op_to_u32(&args[END_BYTE_POS]),\n-                );\n-                true // Also inject the counter increment in the backend\n-            }\n-            sym::coverage_counter_add | sym::coverage_counter_subtract => {\n-                use coverage::coverage_counter_expression_args::*;\n-                self.add_counter_expression_region(\n-                    caller_instance,\n-                    op_to_u32(&args[COUNTER_EXPRESSION_INDEX]),\n-                    op_to_u32(&args[LEFT_INDEX]),\n-                    if intrinsic == sym::coverage_counter_add {\n-                        CounterOp::Add\n-                    } else {\n-                        CounterOp::Subtract\n-                    },\n-                    op_to_u32(&args[RIGHT_INDEX]),\n-                    op_to_u32(&args[START_BYTE_POS]),\n-                    op_to_u32(&args[END_BYTE_POS]),\n-                );\n-                false // Does not inject backend code\n-            }\n-            sym::coverage_unreachable => {\n-                use coverage::coverage_unreachable_args::*;\n-                self.add_unreachable_region(\n-                    caller_instance,\n-                    op_to_u32(&args[START_BYTE_POS]),\n-                    op_to_u32(&args[END_BYTE_POS]),\n-                );\n-                false // Does not inject backend code\n+        if self.tcx.sess.opts.debugging_opts.instrument_coverage {\n+            // Add the coverage information from the MIR to the Codegen context. Some coverage\n+            // intrinsics are used only to pass along the coverage information (returns `false`\n+            // for `is_codegen_intrinsic()`), but `count_code_region` is also converted into an\n+            // LLVM intrinsic to increment a coverage counter.\n+            match intrinsic {\n+                sym::count_code_region => {\n+                    use coverage::count_code_region_args::*;\n+                    self.add_counter_region(\n+                        caller_instance,\n+                        op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n+                        op_to_u32(&args[COUNTER_INDEX]),\n+                        op_to_u32(&args[START_BYTE_POS]),\n+                        op_to_u32(&args[END_BYTE_POS]),\n+                    );\n+                    return true; // Also inject the counter increment in the backend\n+                }\n+                sym::coverage_counter_add | sym::coverage_counter_subtract => {\n+                    use coverage::coverage_counter_expression_args::*;\n+                    self.add_counter_expression_region(\n+                        caller_instance,\n+                        op_to_u32(&args[COUNTER_EXPRESSION_INDEX]),\n+                        op_to_u32(&args[LEFT_INDEX]),\n+                        if intrinsic == sym::coverage_counter_add {\n+                            CounterOp::Add\n+                        } else {\n+                            CounterOp::Subtract\n+                        },\n+                        op_to_u32(&args[RIGHT_INDEX]),\n+                        op_to_u32(&args[START_BYTE_POS]),\n+                        op_to_u32(&args[END_BYTE_POS]),\n+                    );\n+                    return false; // Does not inject backend code\n+                }\n+                sym::coverage_unreachable => {\n+                    use coverage::coverage_unreachable_args::*;\n+                    self.add_unreachable_region(\n+                        caller_instance,\n+                        op_to_u32(&args[START_BYTE_POS]),\n+                        op_to_u32(&args[END_BYTE_POS]),\n+                    );\n+                    return false; // Does not inject backend code\n+                }\n+                _ => {}\n+            }\n+        } else {\n+            // NOT self.tcx.sess.opts.debugging_opts.instrument_coverage\n+            if intrinsic == sym::count_code_region {\n+                // An external crate may have been pre-compiled with coverage instrumentation, and\n+                // some references from the current crate to the external crate might carry along\n+                // the call terminators to coverage intrinsics, like `count_code_region` (for\n+                // example, when instantiating a generic function). If the current crate has\n+                // `instrument_coverage` disabled, the `count_code_region` call terminators should\n+                // be ignored.\n+                return false; // Do not inject coverage counters inlined from external crates\n             }\n-            _ => true, // Unhandled intrinsics should be passed to `codegen_intrinsic_call()`\n         }\n+        true // Unhandled intrinsics should be passed to `codegen_intrinsic_call()`\n     }\n \n     fn codegen_intrinsic_call(\n@@ -197,12 +216,13 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let coverageinfo = tcx.coverageinfo(caller_instance.def_id());\n                 let mangled_fn = tcx.symbol_name(caller_instance);\n                 let (mangled_fn_name, _len_val) = self.const_str(Symbol::intern(mangled_fn.name));\n-                let hash = self.const_u64(coverageinfo.hash);\n                 let num_counters = self.const_u32(coverageinfo.num_counters);\n                 use coverage::count_code_region_args::*;\n+                let hash = args[FUNCTION_SOURCE_HASH].immediate();\n                 let index = args[COUNTER_INDEX].immediate();\n                 debug!(\n-                    \"count_code_region to LLVM intrinsic instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n+                    \"translating Rust intrinsic `count_code_region()` to LLVM intrinsic: \\\n+                    instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n                     mangled_fn.name, hash, num_counters, index,\n                 );\n                 self.instrprof_increment(mangled_fn_name, hash, num_counters, index)\n@@ -2222,3 +2242,7 @@ fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n fn op_to_u32<'tcx>(op: &Operand<'tcx>) -> u32 {\n     Operand::scalar_from_const(op).to_u32().expect(\"Scalar is u32\")\n }\n+\n+fn op_to_u64<'tcx>(op: &Operand<'tcx>) -> u64 {\n+    Operand::scalar_from_const(op).to_u64().expect(\"Scalar is u64\")\n+}"}, {"sha": "9784beaa079de7f2b892b710ad730ec129fc325e", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1,6 +1,8 @@\n #![allow(non_camel_case_types)]\n #![allow(non_upper_case_globals)]\n \n+use super::coverageinfo::{SmallVectorCounterExpression, SmallVectorCounterMappingRegion};\n+\n use super::debuginfo::{\n     DIArray, DIBasicType, DIBuilder, DICompositeType, DIDerivedType, DIDescriptor, DIEnumerator,\n     DIFile, DIFlags, DIGlobalVariableExpression, DILexicalBlock, DINameSpace, DISPFlags, DIScope,\n@@ -650,6 +652,16 @@ pub struct Linker<'a>(InvariantOpaque<'a>);\n pub type DiagnosticHandler = unsafe extern \"C\" fn(&DiagnosticInfo, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(&SMDiagnostic, *const c_void, c_uint);\n \n+pub mod coverageinfo {\n+    use super::InvariantOpaque;\n+\n+    #[repr(C)]\n+    pub struct SmallVectorCounterExpression<'a>(InvariantOpaque<'a>);\n+\n+    #[repr(C)]\n+    pub struct SmallVectorCounterMappingRegion<'a>(InvariantOpaque<'a>);\n+}\n+\n pub mod debuginfo {\n     use super::{InvariantOpaque, Metadata};\n     use bitflags::bitflags;\n@@ -1365,7 +1377,7 @@ extern \"C\" {\n \n     // Miscellaneous instructions\n     pub fn LLVMBuildPhi(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMRustGetInstrprofIncrementIntrinsic(M: &Module) -> &'a Value;\n+    pub fn LLVMRustGetInstrProfIncrementIntrinsic(M: &Module) -> &'a Value;\n     pub fn LLVMRustBuildCall(\n         B: &Builder<'a>,\n         Fn: &'a Value,\n@@ -1633,6 +1645,58 @@ extern \"C\" {\n         ConstraintsLen: size_t,\n     ) -> bool;\n \n+    pub fn LLVMRustCoverageSmallVectorCounterExpressionCreate()\n+    -> &'a mut SmallVectorCounterExpression<'a>;\n+    pub fn LLVMRustCoverageSmallVectorCounterExpressionDispose(\n+        Container: &'a mut SmallVectorCounterExpression<'a>,\n+    );\n+    pub fn LLVMRustCoverageSmallVectorCounterExpressionAdd(\n+        Container: &mut SmallVectorCounterExpression<'a>,\n+        Kind: rustc_codegen_ssa::coverageinfo::CounterOp,\n+        LeftIndex: c_uint,\n+        RightIndex: c_uint,\n+    );\n+\n+    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionCreate()\n+    -> &'a mut SmallVectorCounterMappingRegion<'a>;\n+    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionDispose(\n+        Container: &'a mut SmallVectorCounterMappingRegion<'a>,\n+    );\n+    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionAdd(\n+        Container: &mut SmallVectorCounterMappingRegion<'a>,\n+        Index: c_uint,\n+        FileID: c_uint,\n+        LineStart: c_uint,\n+        ColumnStart: c_uint,\n+        LineEnd: c_uint,\n+        ColumnEnd: c_uint,\n+    );\n+\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustCoverageWriteFilenamesSectionToBuffer(\n+        Filenames: *const *const c_char,\n+        FilenamesLen: size_t,\n+        BufferOut: &RustString,\n+    );\n+\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustCoverageWriteMappingToBuffer(\n+        VirtualFileMappingIDs: *const c_uint,\n+        NumVirtualFileMappingIDs: c_uint,\n+        Expressions: *const SmallVectorCounterExpression<'_>,\n+        MappingRegions: *const SmallVectorCounterMappingRegion<'_>,\n+        BufferOut: &RustString,\n+    );\n+\n+    pub fn LLVMRustCoverageComputeHash(Name: *const c_char) -> u64;\n+\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustCoverageWriteSectionNameToString(M: &Module, Str: &RustString);\n+\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustCoverageWriteMappingVarNameToString(Str: &RustString);\n+\n+    pub fn LLVMRustCoverageMappingVersion() -> u32;\n     pub fn LLVMRustDebugMetadataVersion() -> u32;\n     pub fn LLVMRustVersionMajor() -> u32;\n     pub fn LLVMRustVersionMinor() -> u32;"}, {"sha": "c09e3659f80a20053b6819df530bee4d783b78f8", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -12,7 +12,7 @@ use libc::c_uint;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_llvm::RustString;\n use std::cell::RefCell;\n-use std::ffi::CStr;\n+use std::ffi::{CStr, CString};\n use std::str::FromStr;\n use std::string::FromUtf8Error;\n \n@@ -189,6 +189,42 @@ pub fn mk_section_iter(llof: &ffi::ObjectFile) -> SectionIter<'_> {\n     unsafe { SectionIter { llsi: LLVMGetSections(llof) } }\n }\n \n+pub fn set_section(llglobal: &Value, section_name: &str) {\n+    let section_name_cstr = CString::new(section_name).expect(\"unexpected CString error\");\n+    unsafe {\n+        LLVMSetSection(llglobal, section_name_cstr.as_ptr());\n+    }\n+}\n+\n+pub fn add_global<'a>(llmod: &'a Module, ty: &'a Type, name: &str) -> &'a Value {\n+    let name_cstr = CString::new(name).expect(\"unexpected CString error\");\n+    unsafe { LLVMAddGlobal(llmod, ty, name_cstr.as_ptr()) }\n+}\n+\n+pub fn set_initializer(llglobal: &Value, constant_val: &Value) {\n+    unsafe {\n+        LLVMSetInitializer(llglobal, constant_val);\n+    }\n+}\n+\n+pub fn set_global_constant(llglobal: &Value, is_constant: bool) {\n+    unsafe {\n+        LLVMSetGlobalConstant(llglobal, if is_constant { ffi::True } else { ffi::False });\n+    }\n+}\n+\n+pub fn set_linkage(llglobal: &Value, linkage: Linkage) {\n+    unsafe {\n+        LLVMRustSetLinkage(llglobal, linkage);\n+    }\n+}\n+\n+pub fn set_alignment(llglobal: &Value, bytes: usize) {\n+    unsafe {\n+        ffi::LLVMSetAlignment(llglobal, bytes as c_uint);\n+    }\n+}\n+\n /// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n pub fn get_param(llfn: &Value, index: c_uint) -> &Value {\n     unsafe {\n@@ -225,6 +261,12 @@ pub fn build_string(f: impl FnOnce(&RustString)) -> Result<String, FromUtf8Error\n     String::from_utf8(sr.bytes.into_inner())\n }\n \n+pub fn build_byte_buffer(f: impl FnOnce(&RustString)) -> Vec<u8> {\n+    let sr = RustString { bytes: RefCell::new(Vec::new()) };\n+    f(&sr);\n+    sr.bytes.into_inner()\n+}\n+\n pub fn twine_to_string(tr: &Twine) -> String {\n     unsafe {\n         build_string(|s| LLVMRustWriteTwineToString(tr, s)).expect(\"got a non-UTF8 Twine from LLVM\")"}, {"sha": "2d65282ce7798751268970eb62534bf7349201b6", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1659,7 +1659,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     // FIXME: Order dependent, applies to the following objects. Where should it be placed?\n     // Try to strip as much out of the generated object by removing unused\n     // sections if possible. See more comments in linker.rs\n-    if !sess.opts.cg.link_dead_code {\n+    if sess.opts.cg.link_dead_code != Some(true) {\n         let keep_metadata = crate_type == CrateType::Dylib;\n         cmd.gc_sections(keep_metadata);\n     }\n@@ -1695,7 +1695,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     );\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n-    if sess.opts.cg.profile_generate.enabled() {\n+    if sess.opts.cg.profile_generate.enabled() || sess.opts.debugging_opts.instrument_coverage {\n         cmd.pgo_gen();\n     }\n "}, {"sha": "e64aafa599fd8ae39d63af34fbb8808cd810090e", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -28,9 +28,7 @@ use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n pub fn disable_localization(linker: &mut Command) {\n     // No harm in setting both env vars simultaneously.\n     // Unix-style linkers.\n-    // We use an UTF-8 locale, as the generic C locale disables support for non-ASCII\n-    // bytes in filenames on some platforms.\n-    linker.env(\"LC_ALL\", \"en_US.UTF-8\");\n+    linker.env(\"LC_ALL\", \"C\");\n     // MSVC's `link.exe`.\n     linker.env(\"VSLANG\", \"1033\");\n }"}, {"sha": "7d742e7a7afd2b35a613fb20f1b9569f2133507b", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -203,6 +203,17 @@ fn exported_symbols_provider_local(\n         }));\n     }\n \n+    if tcx.sess.opts.debugging_opts.instrument_coverage {\n+        // Similar to PGO profiling, preserve symbols used by LLVM InstrProf coverage profiling.\n+        const COVERAGE_WEAK_SYMBOLS: [&str; 3] =\n+            [\"__llvm_profile_filename\", \"__llvm_coverage_mapping\", \"__llvm_covmap\"];\n+\n+        symbols.extend(COVERAGE_WEAK_SYMBOLS.iter().map(|sym| {\n+            let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(tcx, sym));\n+            (exported_symbol, SymbolExportLevel::C)\n+        }));\n+    }\n+\n     if tcx.sess.opts.debugging_opts.sanitizer.contains(SanitizerSet::MEMORY) {\n         // Similar to profiling, preserve weak msan symbol during LTO.\n         const MSAN_WEAK_SYMBOLS: [&str; 2] = [\"__msan_track_origins\", \"__msan_keep_going\"];"}, {"sha": "a8ffef8bc5b6b2fae298aac14e5cdd8509bc45e9", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 241, "deletions": 35, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1,83 +1,289 @@\n-use rustc_data_structures::fx::FxHashMap;\n-use std::collections::hash_map;\n-use std::slice;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_middle::mir;\n+use rustc_span::source_map::{Pos, SourceFile, SourceMap};\n+use rustc_span::{BytePos, FileName, RealFileName};\n+\n+use std::cmp::{Ord, Ordering};\n+use std::collections::BTreeMap;\n+use std::fmt;\n+use std::path::PathBuf;\n \n #[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n pub enum CounterOp {\n-    Add,\n+    // Note the order (and therefore the default values) is important. With the attribute\n+    // `#[repr(C)]`, this enum matches the layout of the LLVM enum defined for the nested enum,\n+    // `llvm::coverage::CounterExpression::ExprKind`, as shown in the following source snippet:\n+    // https://github.com/rust-lang/llvm-project/blob/f208b70fbc4dee78067b3c5bd6cb92aa3ba58a1e/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L146\n     Subtract,\n+    Add,\n }\n \n+#[derive(Copy, Clone, Debug)]\n pub enum CoverageKind {\n     Counter,\n     CounterExpression(u32, CounterOp, u32),\n+    Unreachable,\n }\n \n-pub struct CoverageSpan {\n+#[derive(Clone, Debug)]\n+pub struct CoverageRegion {\n+    pub kind: CoverageKind,\n     pub start_byte_pos: u32,\n     pub end_byte_pos: u32,\n }\n \n-pub struct CoverageRegion {\n-    pub kind: CoverageKind,\n-    pub coverage_span: CoverageSpan,\n+impl CoverageRegion {\n+    pub fn source_loc(&self, source_map: &SourceMap) -> Option<(Lrc<SourceFile>, CoverageLoc)> {\n+        let (start_file, start_line, start_col) =\n+            lookup_file_line_col(source_map, BytePos::from_u32(self.start_byte_pos));\n+        let (end_file, end_line, end_col) =\n+            lookup_file_line_col(source_map, BytePos::from_u32(self.end_byte_pos));\n+        let start_file_path = match &start_file.name {\n+            FileName::Real(RealFileName::Named(path)) => path,\n+            _ => {\n+                bug!(\"start_file_path should be a RealFileName, but it was: {:?}\", start_file.name)\n+            }\n+        };\n+        let end_file_path = match &end_file.name {\n+            FileName::Real(RealFileName::Named(path)) => path,\n+            _ => bug!(\"end_file_path should be a RealFileName, but it was: {:?}\", end_file.name),\n+        };\n+        if start_file_path == end_file_path {\n+            Some((start_file, CoverageLoc { start_line, start_col, end_line, end_col }))\n+        } else {\n+            None\n+            // FIXME(richkadel): There seems to be a problem computing the file location in\n+            // some cases. I need to investigate this more. When I generate and show coverage\n+            // for the example binary in the crates.io crate `json5format`, I had a couple of\n+            // notable problems:\n+            //\n+            //   1. I saw a lot of coverage spans in `llvm-cov show` highlighting regions in\n+            //      various comments (not corresponding to rustdoc code), indicating a possible\n+            //      problem with the byte_pos-to-source-map implementation.\n+            //\n+            //   2. And (perhaps not related) when I build the aforementioned example binary with:\n+            //      `RUST_FLAGS=\"-Zinstrument-coverage\" cargo build --example formatjson5`\n+            //      and then run that binary with\n+            //      `LLVM_PROFILE_FILE=\"formatjson5.profraw\" ./target/debug/examples/formatjson5 \\\n+            //      some.json5` for some reason the binary generates *TWO* `.profraw` files. One\n+            //      named `default.profraw` and the other named `formatjson5.profraw` (the expected\n+            //      name, in this case).\n+            //\n+            // If the byte range conversion is wrong, fix it. But if it\n+            // is right, then it is possible for the start and end to be in different files.\n+            // Can I do something other than ignore coverages that span multiple files?\n+            //\n+            // If I can resolve this, remove the \"Option<>\" result type wrapper\n+            // `regions_in_file_order()` accordingly.\n+        }\n+    }\n+}\n+\n+impl Default for CoverageRegion {\n+    fn default() -> Self {\n+        Self {\n+            // The default kind (Unreachable) is a placeholder that will be overwritten before\n+            // backend codegen.\n+            kind: CoverageKind::Unreachable,\n+            start_byte_pos: 0,\n+            end_byte_pos: 0,\n+        }\n+    }\n+}\n+\n+/// A source code region used with coverage information.\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct CoverageLoc {\n+    /// The (1-based) line number of the region start.\n+    pub start_line: u32,\n+    /// The (1-based) column number of the region start.\n+    pub start_col: u32,\n+    /// The (1-based) line number of the region end.\n+    pub end_line: u32,\n+    /// The (1-based) column number of the region end.\n+    pub end_col: u32,\n+}\n+\n+impl Ord for CoverageLoc {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        (self.start_line, &self.start_col, &self.end_line, &self.end_col).cmp(&(\n+            other.start_line,\n+            &other.start_col,\n+            &other.end_line,\n+            &other.end_col,\n+        ))\n+    }\n+}\n+\n+impl PartialOrd for CoverageLoc {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl fmt::Display for CoverageLoc {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Customize debug format, and repeat the file name, so generated location strings are\n+        // \"clickable\" in many IDEs.\n+        write!(f, \"{}:{} - {}:{}\", self.start_line, self.start_col, self.end_line, self.end_col)\n+    }\n+}\n+\n+fn lookup_file_line_col(source_map: &SourceMap, byte_pos: BytePos) -> (Lrc<SourceFile>, u32, u32) {\n+    let found = source_map\n+        .lookup_line(byte_pos)\n+        .expect(\"should find coverage region byte position in source\");\n+    let file = found.sf;\n+    let line_pos = file.line_begin_pos(byte_pos);\n+\n+    // Use 1-based indexing.\n+    let line = (found.line + 1) as u32;\n+    let col = (byte_pos - line_pos).to_u32() + 1;\n+\n+    (file, line, col)\n }\n \n /// Collects all of the coverage regions associated with (a) injected counters, (b) counter\n /// expressions (additions or subtraction), and (c) unreachable regions (always counted as zero),\n /// for a given Function. Counters and counter expressions are indexed because they can be operands\n-/// in an expression.\n+/// in an expression. This struct also stores the `function_source_hash`, computed during\n+/// instrumentation and forwarded with counters.\n ///\n /// Note, it's important to distinguish the `unreachable` region type from what LLVM's refers to as\n /// a \"gap region\" (or \"gap area\"). A gap region is a code region within a counted region (either\n /// counter or expression), but the line or lines in the gap region are not executable (such as\n /// lines with only whitespace or comments). According to LLVM Code Coverage Mapping documentation,\n /// \"A count for a gap area is only used as the line execution count if there are no other regions\n /// on a line.\"\n-#[derive(Default)]\n-pub struct FunctionCoverageRegions {\n-    indexed: FxHashMap<u32, CoverageRegion>,\n-    unreachable: Vec<CoverageSpan>,\n+pub struct FunctionCoverage {\n+    source_hash: u64,\n+    counters: Vec<CoverageRegion>,\n+    expressions: Vec<CoverageRegion>,\n+    unreachable: Vec<CoverageRegion>,\n+    translated: bool,\n }\n \n-impl FunctionCoverageRegions {\n-    pub fn add_counter(&mut self, index: u32, start_byte_pos: u32, end_byte_pos: u32) {\n-        self.indexed.insert(\n-            index,\n-            CoverageRegion {\n-                kind: CoverageKind::Counter,\n-                coverage_span: CoverageSpan { start_byte_pos, end_byte_pos },\n-            },\n-        );\n+impl FunctionCoverage {\n+    pub fn with_coverageinfo<'tcx>(coverageinfo: &'tcx mir::CoverageInfo) -> Self {\n+        Self {\n+            source_hash: 0, // will be set with the first `add_counter()`\n+            counters: vec![CoverageRegion::default(); coverageinfo.num_counters as usize],\n+            expressions: vec![CoverageRegion::default(); coverageinfo.num_expressions as usize],\n+            unreachable: Vec::new(),\n+            translated: false,\n+        }\n     }\n \n-    pub fn add_counter_expression(\n+    /// Adds a code region to be counted by an injected counter intrinsic. Return a counter ID\n+    /// for the call.\n+    pub fn add_counter(\n         &mut self,\n+        source_hash: u64,\n         index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    ) {\n+        self.source_hash = source_hash;\n+        self.counters[index as usize] =\n+            CoverageRegion { kind: CoverageKind::Counter, start_byte_pos, end_byte_pos };\n+    }\n+\n+    pub fn add_counter_expression(\n+        &mut self,\n+        translated_index: u32,\n         lhs: u32,\n         op: CounterOp,\n         rhs: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n-        self.indexed.insert(\n-            index,\n-            CoverageRegion {\n-                kind: CoverageKind::CounterExpression(lhs, op, rhs),\n-                coverage_span: CoverageSpan { start_byte_pos, end_byte_pos },\n-            },\n-        );\n+        let index = u32::MAX - translated_index;\n+        // Counter expressions start with \"translated indexes\", descending from `u32::MAX`, so\n+        // the range of expression indexes is disjoint from the range of counter indexes. This way,\n+        // both counters and expressions can be operands in other expressions.\n+        //\n+        // Once all counters have been added, the final \"region index\" for an expression is\n+        // `counters.len() + expression_index` (where `expression_index` is its index in\n+        // `self.expressions`), and the expression operands (`lhs` and `rhs`) can be converted to\n+        // final \"region index\" references by the same conversion, after subtracting from\n+        // `u32::MAX`.\n+        self.expressions[index as usize] = CoverageRegion {\n+            kind: CoverageKind::CounterExpression(lhs, op, rhs),\n+            start_byte_pos,\n+            end_byte_pos,\n+        };\n     }\n \n     pub fn add_unreachable(&mut self, start_byte_pos: u32, end_byte_pos: u32) {\n-        self.unreachable.push(CoverageSpan { start_byte_pos, end_byte_pos });\n+        self.unreachable.push(CoverageRegion {\n+            kind: CoverageKind::Unreachable,\n+            start_byte_pos,\n+            end_byte_pos,\n+        });\n+    }\n+\n+    pub fn source_hash(&self) -> u64 {\n+        self.source_hash\n+    }\n+\n+    fn regions(&'a mut self) -> impl Iterator<Item = &'a CoverageRegion> {\n+        assert!(self.source_hash != 0);\n+        self.ensure_expressions_translated();\n+        self.counters.iter().chain(self.expressions.iter().chain(self.unreachable.iter()))\n     }\n \n-    pub fn indexed_regions(&self) -> hash_map::Iter<'_, u32, CoverageRegion> {\n-        self.indexed.iter()\n+    pub fn regions_in_file_order(\n+        &'a mut self,\n+        source_map: &SourceMap,\n+    ) -> BTreeMap<PathBuf, BTreeMap<CoverageLoc, (usize, CoverageKind)>> {\n+        let mut regions_in_file_order = BTreeMap::new();\n+        for (region_id, region) in self.regions().enumerate() {\n+            if let Some((source_file, region_loc)) = region.source_loc(source_map) {\n+                // FIXME(richkadel): `region.source_loc()` sometimes fails with two different\n+                // filenames for the start and end byte position. This seems wrong, but for\n+                // now, if encountered, the region is skipped. If resolved, convert the result\n+                // to a non-option value so regions are never skipped.\n+                let real_file_path = match &(*source_file).name {\n+                    FileName::Real(RealFileName::Named(path)) => path.clone(),\n+                    _ => bug!(\"coverage mapping expected only real, named files\"),\n+                };\n+                let file_coverage_regions =\n+                    regions_in_file_order.entry(real_file_path).or_insert_with(|| BTreeMap::new());\n+                file_coverage_regions.insert(region_loc, (region_id, region.kind));\n+            }\n+        }\n+        regions_in_file_order\n     }\n \n-    pub fn unreachable_regions(&self) -> slice::Iter<'_, CoverageSpan> {\n-        self.unreachable.iter()\n+    /// A one-time translation of expression operands is needed, for any operands referencing\n+    /// other CounterExpressions. CounterExpression operands get an initial operand ID that is\n+    /// computed by the simple translation: `u32::max - expression_index` because, when created,\n+    /// the total number of Counters is not yet known. This function recomputes region indexes\n+    /// for expressions so they start with the next region index after the last counter index.\n+    fn ensure_expressions_translated(&mut self) {\n+        if !self.translated {\n+            self.translated = true;\n+            let start = self.counters.len() as u32;\n+            assert!(\n+                (start as u64 + self.expressions.len() as u64) < u32::MAX as u64,\n+                \"the number of counters and counter expressions in a single function exceeds {}\",\n+                u32::MAX\n+            );\n+            for region in self.expressions.iter_mut() {\n+                match region.kind {\n+                    CoverageKind::CounterExpression(lhs, op, rhs) => {\n+                        let lhs = to_region_index(start, lhs);\n+                        let rhs = to_region_index(start, rhs);\n+                        region.kind = CoverageKind::CounterExpression(lhs, op, rhs);\n+                    }\n+                    _ => bug!(\"expressions must only contain CounterExpression kinds\"),\n+                }\n+            }\n+        }\n     }\n }\n+\n+fn to_region_index(start: u32, index: u32) -> u32 {\n+    if index < start { index } else { start + (u32::MAX - index) }\n+}"}, {"sha": "1b9faa42484f1ad536a21b3ccdc35e9a5b9f70d4", "filename": "src/librustc_codegen_ssa/traits/coverageinfo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -10,6 +10,7 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,\n+        function_source_hash: u64,\n         index: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,"}, {"sha": "817fc02d166a35ba9dff5e61e3087e9628d59c3b", "filename": "src/librustc_codegen_ssa/traits/statics.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -5,6 +5,18 @@ use rustc_target::abi::Align;\n pub trait StaticMethods: BackendTypes {\n     fn static_addr_of(&self, cv: Self::Value, align: Align, kind: Option<&str>) -> Self::Value;\n     fn codegen_static(&self, def_id: DefId, is_mutable: bool);\n+\n+    /// Mark the given global value as \"used\", to prevent a backend from potentially removing a\n+    /// static variable that may otherwise appear unused.\n+    ///\n+    /// Static variables in Rust can be annotated with the `#[used]` attribute to direct the `rustc`\n+    /// compiler to mark the variable as a \"used global\".\n+    ///\n+    /// ```no_run\n+    /// #[used]\n+    /// static FOO: u32 = 0;\n+    /// ```\n+    fn add_used_global(&self, global: Self::Value);\n }\n \n pub trait StaticBuilderMethods: BackendTypes {"}, {"sha": "bbbd8359f0126b229ccf8f6f9bd79082a8819c2b", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -554,7 +554,7 @@ E0770: include_str!(\"./error_codes/E0770.md\"),\n //  E0420, merged into 532\n //  E0421, merged into 531\n //  E0427, merged into 530\n-    E0456, // plugin `..` is not available for triple `..`\n+//  E0456, // plugin `..` is not available for triple `..`\n     E0457, // plugin `..` only found in rlib format, but must be available...\n     E0460, // found possibly newer version of crate `..`\n     E0461, // couldn't find crate `..` with expected target triple .."}, {"sha": "91db58054b61fde3e8a5d8b497d4a07b8a32b109", "filename": "src/librustc_hir/fake_lang_items.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_hir%2Ffake_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_hir%2Ffake_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Ffake_lang_items.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,37 @@\n+//! Validity checking for fake lang items\n+\n+use crate::def_id::DefId;\n+use crate::{lang_items, LangItem, LanguageItems};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::symbol::{sym, Symbol};\n+\n+use lazy_static::lazy_static;\n+\n+macro_rules! fake_lang_items {\n+    ($($item:ident, $name:ident, $method:ident;)*) => (\n+\n+lazy_static! {\n+    pub static ref FAKE_ITEMS_REFS: FxHashMap<Symbol, LangItem> = {\n+        let mut map = FxHashMap::default();\n+        $(map.insert(sym::$name, lang_items::$item);)*\n+        map\n+    };\n+}\n+\n+impl LanguageItems {\n+    pub fn is_fake_lang_item(&self, item_def_id: DefId) -> bool {\n+        let did = Some(item_def_id);\n+\n+        $(self.$method() == did)||*\n+    }\n+}\n+\n+) }\n+\n+fake_lang_items! {\n+//  Variant name,                      Symbol,                    Method name,\n+    CountCodeRegionFnLangItem,         count_code_region,         count_code_region_fn;\n+    CoverageCounterAddFnLangItem,      coverage_counter_add,      coverage_counter_add_fn;\n+    CoverageCounterSubtractFnLangItem, coverage_counter_subtract, coverage_counter_subtract_fn;\n+}"}, {"sha": "4b71407acfb8cf44c57f7b202dd6900b13174326", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -276,8 +276,6 @@ language_item_table! {\n \n     StartFnLangItem,               sym::start,              start_fn,                Target::Fn;\n \n-    CountCodeRegionFnLangItem,     sym::count_code_region,  count_code_region_fn,    Target::Fn;\n-\n     EhPersonalityLangItem,         sym::eh_personality,     eh_personality,          Target::Fn;\n     EhCatchTypeinfoLangItem,       sym::eh_catch_typeinfo,  eh_catch_typeinfo,       Target::Static;\n \n@@ -295,4 +293,9 @@ language_item_table! {\n     TerminationTraitLangItem,      sym::termination,        termination,             Target::Trait;\n \n     TryTraitLangItem,              kw::Try,                 try_trait,               Target::Trait;\n+\n+    // language items related to source code coverage instrumentation (-Zinstrument-coverage)\n+    CountCodeRegionFnLangItem,         sym::count_code_region,         count_code_region_fn,         Target::Fn;\n+    CoverageCounterAddFnLangItem,      sym::coverage_counter_add,      coverage_counter_add_fn,      Target::Fn;\n+    CoverageCounterSubtractFnLangItem, sym::coverage_counter_subtract, coverage_counter_subtract_fn, Target::Fn;\n }"}, {"sha": "52131cb3d3d4cab03a12ae46f2ef769aaa9b93f0", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -17,6 +17,7 @@ mod arena;\n pub mod def;\n pub mod definitions;\n pub use rustc_span::def_id;\n+pub mod fake_lang_items;\n mod hir;\n pub mod hir_id;\n pub mod intravisit;"}, {"sha": "3c549b88523684fa812623d87bfb0aa48fdd9614", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -401,7 +401,7 @@ fn test_codegen_options_tracking_hash() {\n     untracked!(incremental, Some(String::from(\"abc\")));\n     // `link_arg` is omitted because it just forwards to `link_args`.\n     untracked!(link_args, vec![String::from(\"abc\"), String::from(\"def\")]);\n-    untracked!(link_dead_code, true);\n+    untracked!(link_dead_code, Some(true));\n     untracked!(linker, Some(PathBuf::from(\"linker\")));\n     untracked!(linker_flavor, Some(LinkerFlavor::Gcc));\n     untracked!(no_stack_check, true);"}, {"sha": "78e27b10ec657e35f83d37d51256f567aa0d5986", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -104,8 +104,16 @@ fn main() {\n         optional_components.push(\"riscv\");\n     }\n \n-    let required_components =\n-        &[\"ipo\", \"bitreader\", \"bitwriter\", \"linker\", \"asmparser\", \"lto\", \"instrumentation\"];\n+    let required_components = &[\n+        \"ipo\",\n+        \"bitreader\",\n+        \"bitwriter\",\n+        \"linker\",\n+        \"asmparser\",\n+        \"lto\",\n+        \"coverage\",\n+        \"instrumentation\",\n+    ];\n \n     let components = output(Command::new(&llvm_config).arg(\"--components\"));\n     let mut components = components.split_whitespace().collect::<Vec<_>>();\n@@ -169,6 +177,7 @@ fn main() {\n     cfg.file(\"../rustllvm/PassWrapper.cpp\")\n         .file(\"../rustllvm/RustWrapper.cpp\")\n         .file(\"../rustllvm/ArchiveWrapper.cpp\")\n+        .file(\"../rustllvm/CoverageMappingWrapper.cpp\")\n         .file(\"../rustllvm/Linker.cpp\")\n         .cpp(true)\n         .cpp_link_stdlib(None) // we handle this below"}, {"sha": "9d23397ade08e80e170bd9b41ebce4e72c5c7982", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -13,6 +13,12 @@ pub struct RustString {\n     pub bytes: RefCell<Vec<u8>>,\n }\n \n+impl RustString {\n+    pub fn len(&self) -> usize {\n+        self.bytes.borrow().len()\n+    }\n+}\n+\n /// Appending to a Rust string -- used by RawRustStringOstream.\n #[no_mangle]\n #[allow(improper_ctypes_definitions)]"}, {"sha": "0d2101cb2cb0821f5bec673e3580f00f6291f4b1", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 78, "deletions": 105, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1,22 +1,20 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::locator::{CrateLocator, CratePaths};\n+use crate::dynamic_lib::DynamicLibrary;\n+use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n use rustc_ast::expand::allocator::{global_allocator_spans, AllocatorKind};\n use rustc_ast::{ast, attr};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::struct_span_err;\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::cstore::DepKind;\n-use rustc_middle::middle::cstore::{\n-    CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn,\n-};\n+use rustc_middle::middle::cstore::{CrateSource, DepKind, ExternCrate};\n+use rustc_middle::middle::cstore::{ExternCrateSource, MetadataLoaderDyn};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, CrateType, ExternLocation};\n use rustc_session::lint;\n@@ -31,7 +29,7 @@ use rustc_target::spec::{PanicStrategy, TargetTriple};\n use log::{debug, info, log_enabled};\n use proc_macro::bridge::client::ProcMacro;\n use std::path::Path;\n-use std::{cmp, fs};\n+use std::{cmp, env, fs};\n \n #[derive(Clone)]\n pub struct CStore {\n@@ -69,18 +67,6 @@ enum LoadResult {\n     Loaded(Library),\n }\n \n-enum LoadError<'a> {\n-    LocatorError(CrateLocator<'a>),\n-}\n-\n-impl<'a> LoadError<'a> {\n-    fn report(self) -> ! {\n-        match self {\n-            LoadError::LocatorError(locator) => locator.report_errs(),\n-        }\n-    }\n-}\n-\n /// A reference to `CrateMetadata` that can also give access to whole crate store when necessary.\n #[derive(Clone, Copy)]\n crate struct CrateMetadataRef<'a> {\n@@ -280,60 +266,43 @@ impl<'a> CrateLoader<'a> {\n         ret\n     }\n \n-    fn verify_no_symbol_conflicts(&self, span: Span, root: &CrateRoot<'_>) {\n+    fn verify_no_symbol_conflicts(&self, root: &CrateRoot<'_>) -> Result<(), CrateError> {\n         // Check for (potential) conflicts with the local crate\n         if self.local_crate_name == root.name()\n             && self.sess.local_crate_disambiguator() == root.disambiguator()\n         {\n-            struct_span_err!(\n-                self.sess,\n-                span,\n-                E0519,\n-                \"the current crate is indistinguishable from one of its \\\n-                         dependencies: it has the same crate-name `{}` and was \\\n-                         compiled with the same `-C metadata` arguments. This \\\n-                         will result in symbol conflicts between the two.\",\n-                root.name()\n-            )\n-            .emit()\n+            return Err(CrateError::SymbolConflictsCurrent(root.name()));\n         }\n \n         // Check for conflicts with any crate loaded so far\n+        let mut res = Ok(());\n         self.cstore.iter_crate_data(|_, other| {\n             if other.name() == root.name() && // same crate-name\n-               other.disambiguator() == root.disambiguator() &&  // same crate-disambiguator\n+               other.disambiguator() == root.disambiguator() && // same crate-disambiguator\n                other.hash() != root.hash()\n             {\n                 // but different SVH\n-                struct_span_err!(\n-                    self.sess,\n-                    span,\n-                    E0523,\n-                    \"found two different crates with name `{}` that are \\\n-                         not distinguished by differing `-C metadata`. This \\\n-                         will result in symbol conflicts between the two.\",\n-                    root.name()\n-                )\n-                .emit();\n+                res = Err(CrateError::SymbolConflictsOthers(root.name()));\n             }\n         });\n+\n+        res\n     }\n \n     fn register_crate(\n         &mut self,\n         host_lib: Option<Library>,\n         root: Option<&CratePaths>,\n-        span: Span,\n         lib: Library,\n         dep_kind: DepKind,\n         name: Symbol,\n-    ) -> CrateNum {\n+    ) -> Result<CrateNum, CrateError> {\n         let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n \n         let Library { source, metadata } = lib;\n         let crate_root = metadata.get_root();\n         let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash());\n-        self.verify_no_symbol_conflicts(span, &crate_root);\n+        self.verify_no_symbol_conflicts(&crate_root)?;\n \n         let private_dep =\n             self.sess.opts.externs.get(&name.as_str()).map(|e| e.is_private_dep).unwrap_or(false);\n@@ -353,7 +322,7 @@ impl<'a> CrateLoader<'a> {\n             &crate_paths\n         };\n \n-        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n+        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, dep_kind)?;\n \n         let raw_proc_macros = if crate_root.is_proc_macro_crate() {\n             let temp_root;\n@@ -365,7 +334,7 @@ impl<'a> CrateLoader<'a> {\n                 None => (&source, &crate_root),\n             };\n             let dlsym_dylib = dlsym_source.dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n-            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator(), span))\n+            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator())?)\n         } else {\n             None\n         };\n@@ -386,14 +355,14 @@ impl<'a> CrateLoader<'a> {\n             ),\n         );\n \n-        cnum\n+        Ok(cnum)\n     }\n \n     fn load_proc_macro<'b>(\n         &self,\n         locator: &mut CrateLocator<'b>,\n         path_kind: PathKind,\n-    ) -> Option<(LoadResult, Option<Library>)>\n+    ) -> Result<Option<(LoadResult, Option<Library>)>, CrateError>\n     where\n         'a: 'b,\n     {\n@@ -408,8 +377,11 @@ impl<'a> CrateLoader<'a> {\n         let (locator, target_result) = if self.sess.opts.debugging_opts.dual_proc_macros {\n             proc_macro_locator.reset();\n             let result = match self.load(&mut proc_macro_locator)? {\n-                LoadResult::Previous(cnum) => return Some((LoadResult::Previous(cnum), None)),\n-                LoadResult::Loaded(library) => Some(LoadResult::Loaded(library)),\n+                Some(LoadResult::Previous(cnum)) => {\n+                    return Ok(Some((LoadResult::Previous(cnum), None)));\n+                }\n+                Some(LoadResult::Loaded(library)) => Some(LoadResult::Loaded(library)),\n+                None => return Ok(None),\n             };\n             locator.hash = locator.host_hash;\n             // Use the locator when looking for the host proc macro crate, as that is required\n@@ -427,9 +399,12 @@ impl<'a> CrateLoader<'a> {\n         locator.triple = TargetTriple::from_triple(config::host_triple());\n         locator.filesearch = self.sess.host_filesearch(path_kind);\n \n-        let host_result = self.load(locator)?;\n+        let host_result = match self.load(locator)? {\n+            Some(host_result) => host_result,\n+            None => return Ok(None),\n+        };\n \n-        Some(if self.sess.opts.debugging_opts.dual_proc_macros {\n+        Ok(Some(if self.sess.opts.debugging_opts.dual_proc_macros {\n             let host_result = match host_result {\n                 LoadResult::Previous(..) => {\n                     panic!(\"host and target proc macros must be loaded in lock-step\")\n@@ -439,7 +414,7 @@ impl<'a> CrateLoader<'a> {\n             (target_result.unwrap(), Some(host_result))\n         } else {\n             (host_result, None)\n-        })\n+        }))\n     }\n \n     fn resolve_crate<'b>(\n@@ -452,25 +427,20 @@ impl<'a> CrateLoader<'a> {\n         if dep.is_none() {\n             self.used_extern_options.insert(name);\n         }\n-        if !name.as_str().is_ascii() {\n-            self.sess\n-                .struct_span_err(\n-                    span,\n-                    &format!(\"cannot load a crate with a non-ascii name `{}`\", name,),\n-                )\n-                .emit();\n-        }\n-        self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n+        self.maybe_resolve_crate(name, dep_kind, dep)\n+            .unwrap_or_else(|err| err.report(self.sess, span))\n     }\n \n     fn maybe_resolve_crate<'b>(\n         &'b mut self,\n         name: Symbol,\n-        span: Span,\n         mut dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n-    ) -> Result<CrateNum, LoadError<'b>> {\n+    ) -> Result<CrateNum, CrateError> {\n         info!(\"resolving crate `{}`\", name);\n+        if !name.as_str().is_ascii() {\n+            return Err(CrateError::NonAsciiName(name));\n+        }\n         let (root, hash, host_hash, extra_filename, path_kind) = match dep {\n             Some((root, dep)) => (\n                 Some(root),\n@@ -494,18 +464,20 @@ impl<'a> CrateLoader<'a> {\n                 extra_filename,\n                 false, // is_host\n                 path_kind,\n-                span,\n                 root,\n                 Some(false), // is_proc_macro\n             );\n \n-            self.load(&mut locator)\n-                .map(|r| (r, None))\n-                .or_else(|| {\n+            match self.load(&mut locator)? {\n+                Some(res) => (res, None),\n+                None => {\n                     dep_kind = DepKind::MacrosOnly;\n-                    self.load_proc_macro(&mut locator, path_kind)\n-                })\n-                .ok_or_else(move || LoadError::LocatorError(locator))?\n+                    match self.load_proc_macro(&mut locator, path_kind)? {\n+                        Some(res) => res,\n+                        None => return Err(locator.into_error()),\n+                    }\n+                }\n+            }\n         };\n \n         match result {\n@@ -518,14 +490,17 @@ impl<'a> CrateLoader<'a> {\n                 Ok(cnum)\n             }\n             (LoadResult::Loaded(library), host_library) => {\n-                Ok(self.register_crate(host_library, root, span, library, dep_kind, name))\n+                self.register_crate(host_library, root, library, dep_kind, name)\n             }\n             _ => panic!(),\n         }\n     }\n \n-    fn load(&self, locator: &mut CrateLocator<'_>) -> Option<LoadResult> {\n-        let library = locator.maybe_load_library_crate()?;\n+    fn load(&self, locator: &mut CrateLocator<'_>) -> Result<Option<LoadResult>, CrateError> {\n+        let library = match locator.maybe_load_library_crate()? {\n+            Some(library) => library,\n+            None => return Ok(None),\n+        };\n \n         // In the case that we're loading a crate, but not matching\n         // against a hash, we could load a crate which has the same hash\n@@ -536,7 +511,7 @@ impl<'a> CrateLoader<'a> {\n         // don't want to match a host crate against an equivalent target one\n         // already loaded.\n         let root = library.metadata.get_root();\n-        if locator.triple == self.sess.opts.target_triple {\n+        Ok(Some(if locator.triple == self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n                 if data.name() == root.name() && root.hash() == data.hash() {\n@@ -545,10 +520,10 @@ impl<'a> CrateLoader<'a> {\n                     result = LoadResult::Previous(cnum);\n                 }\n             });\n-            Some(result)\n+            result\n         } else {\n-            Some(LoadResult::Loaded(library))\n-        }\n+            LoadResult::Loaded(library)\n+        }))\n     }\n \n     fn update_extern_crate(&self, cnum: CrateNum, extern_crate: ExternCrate) {\n@@ -569,53 +544,51 @@ impl<'a> CrateLoader<'a> {\n         crate_root: &CrateRoot<'_>,\n         metadata: &MetadataBlob,\n         krate: CrateNum,\n-        span: Span,\n         dep_kind: DepKind,\n-    ) -> CrateNumMap {\n+    ) -> Result<CrateNumMap, CrateError> {\n         debug!(\"resolving deps of external crate\");\n         if crate_root.is_proc_macro_crate() {\n-            return CrateNumMap::new();\n+            return Ok(CrateNumMap::new());\n         }\n \n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        std::iter::once(krate)\n-            .chain(crate_root.decode_crate_deps(metadata).map(|dep| {\n-                info!(\n-                    \"resolving dep crate {} hash: `{}` extra filename: `{}`\",\n-                    dep.name, dep.hash, dep.extra_filename\n-                );\n-                let dep_kind = match dep_kind {\n-                    DepKind::MacrosOnly => DepKind::MacrosOnly,\n-                    _ => dep.kind,\n-                };\n-                self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep)))\n-            }))\n-            .collect()\n+        let deps = crate_root.decode_crate_deps(metadata);\n+        let mut crate_num_map = CrateNumMap::with_capacity(1 + deps.len());\n+        crate_num_map.push(krate);\n+        for dep in deps {\n+            info!(\n+                \"resolving dep crate {} hash: `{}` extra filename: `{}`\",\n+                dep.name, dep.hash, dep.extra_filename\n+            );\n+            let dep_kind = match dep_kind {\n+                DepKind::MacrosOnly => DepKind::MacrosOnly,\n+                _ => dep.kind,\n+            };\n+            let cnum = self.maybe_resolve_crate(dep.name, dep_kind, Some((root, &dep)))?;\n+            crate_num_map.push(cnum);\n+        }\n+        Ok(crate_num_map)\n     }\n \n     fn dlsym_proc_macros(\n         &self,\n         path: &Path,\n         disambiguator: CrateDisambiguator,\n-        span: Span,\n-    ) -> &'static [ProcMacro] {\n-        use crate::dynamic_lib::DynamicLibrary;\n-        use std::env;\n-\n+    ) -> Result<&'static [ProcMacro], CrateError> {\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n         let lib = match DynamicLibrary::open(&path) {\n             Ok(lib) => lib,\n-            Err(err) => self.sess.span_fatal(span, &err),\n+            Err(s) => return Err(CrateError::DlOpen(s)),\n         };\n \n         let sym = self.sess.generate_proc_macro_decls_symbol(disambiguator);\n         let decls = unsafe {\n             let sym = match lib.symbol(&sym) {\n                 Ok(f) => f,\n-                Err(err) => self.sess.span_fatal(span, &err),\n+                Err(s) => return Err(CrateError::DlSym(s)),\n             };\n             *(sym as *const &[ProcMacro])\n         };\n@@ -624,7 +597,7 @@ impl<'a> CrateLoader<'a> {\n         // since the library can make things that will live arbitrarily long.\n         std::mem::forget(lib);\n \n-        decls\n+        Ok(decls)\n     }\n \n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n@@ -952,7 +925,7 @@ impl<'a> CrateLoader<'a> {\n         cnum\n     }\n \n-    pub fn maybe_process_path_extern(&mut self, name: Symbol, span: Span) -> Option<CrateNum> {\n-        self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()\n+    pub fn maybe_process_path_extern(&mut self, name: Symbol) -> Option<CrateNum> {\n+        self.maybe_resolve_crate(name, DepKind::Explicit, None).ok()\n     }\n }"}, {"sha": "371ec4cd91148686345129677de65ed4b2735503", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 372, "deletions": 382, "changes": 754, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -216,9 +216,10 @@ use crate::creader::Library;\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder};\n+use rustc_errors::struct_span_err;\n use rustc_middle::middle::cstore::{CrateSource, MetadataLoader};\n use rustc_session::config::{self, CrateType};\n use rustc_session::filesearch::{FileDoesntMatch, FileMatches, FileSearch};\n@@ -228,25 +229,12 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::{Target, TargetTriple};\n \n-use std::cmp;\n-use std::fmt;\n-use std::fs;\n-use std::io::{self, Read};\n-use std::ops::Deref;\n-use std::path::{Path, PathBuf};\n-use std::time::Instant;\n-\n use flate2::read::DeflateDecoder;\n-\n-use rustc_data_structures::owning_ref::OwningRef;\n-\n use log::{debug, info, warn};\n-\n-#[derive(Clone)]\n-struct CrateMismatch {\n-    path: PathBuf,\n-    got: String,\n-}\n+use std::io::{Read, Result as IoResult, Write};\n+use std::ops::Deref;\n+use std::path::{Path, PathBuf};\n+use std::{cmp, fmt, fs};\n \n #[derive(Clone)]\n crate struct CrateLocator<'a> {\n@@ -263,7 +251,6 @@ crate struct CrateLocator<'a> {\n     pub target: &'a Target,\n     pub triple: TargetTriple,\n     pub filesearch: FileSearch<'a>,\n-    span: Span,\n     root: Option<&'a CratePaths>,\n     pub is_proc_macro: Option<bool>,\n \n@@ -275,6 +262,7 @@ crate struct CrateLocator<'a> {\n     rejected_via_filename: Vec<CrateMismatch>,\n }\n \n+#[derive(Clone)]\n crate struct CratePaths {\n     name: Symbol,\n     source: CrateSource,\n@@ -287,7 +275,7 @@ impl CratePaths {\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-enum CrateFlavor {\n+crate enum CrateFlavor {\n     Rlib,\n     Rmeta,\n     Dylib,\n@@ -313,7 +301,6 @@ impl<'a> CrateLocator<'a> {\n         extra_filename: Option<&'a str>,\n         is_host: bool,\n         path_kind: PathKind,\n-        span: Span,\n         root: Option<&'a CratePaths>,\n         is_proc_macro: Option<bool>,\n     ) -> CrateLocator<'a> {\n@@ -349,7 +336,6 @@ impl<'a> CrateLocator<'a> {\n             } else {\n                 sess.target_filesearch(path_kind)\n             },\n-            span,\n             root,\n             is_proc_macro,\n             rejected_via_hash: Vec::new(),\n@@ -368,166 +354,30 @@ impl<'a> CrateLocator<'a> {\n         self.rejected_via_filename.clear();\n     }\n \n-    crate fn maybe_load_library_crate(&mut self) -> Option<Library> {\n+    crate fn maybe_load_library_crate(&mut self) -> Result<Option<Library>, CrateError> {\n         if !self.exact_paths.is_empty() {\n             return self.find_commandline_library();\n         }\n         let mut seen_paths = FxHashSet::default();\n-        match self.extra_filename {\n-            Some(s) => self\n-                .find_library_crate(s, &mut seen_paths)\n-                .or_else(|| self.find_library_crate(\"\", &mut seen_paths)),\n-            None => self.find_library_crate(\"\", &mut seen_paths),\n-        }\n-    }\n-\n-    crate fn report_errs(self) -> ! {\n-        let add = match self.root {\n-            None => String::new(),\n-            Some(r) => format!(\" which `{}` depends on\", r.name),\n-        };\n-        let mut msg = \"the following crate versions were found:\".to_string();\n-        let mut err = if !self.rejected_via_hash.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0460,\n-                \"found possibly newer version of crate `{}`{}\",\n-                self.crate_name,\n-                add\n-            );\n-            err.note(\"perhaps that crate needs to be recompiled?\");\n-            let mismatches = self.rejected_via_hash.iter();\n-            for &CrateMismatch { ref path, .. } in mismatches {\n-                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.crate_name, path.display()));\n-            }\n-            match self.root {\n-                None => {}\n-                Some(r) => {\n-                    for path in r.source.paths() {\n-                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.name, path.display()));\n-                    }\n-                }\n-            }\n-            err.note(&msg);\n-            err\n-        } else if !self.rejected_via_triple.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0461,\n-                \"couldn't find crate `{}` \\\n-                                            with expected target triple {}{}\",\n-                self.crate_name,\n-                self.triple,\n-                add\n-            );\n-            let mismatches = self.rejected_via_triple.iter();\n-            for &CrateMismatch { ref path, ref got } in mismatches {\n-                msg.push_str(&format!(\n-                    \"\\ncrate `{}`, target triple {}: {}\",\n-                    self.crate_name,\n-                    got,\n-                    path.display()\n-                ));\n-            }\n-            err.note(&msg);\n-            err\n-        } else if !self.rejected_via_kind.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0462,\n-                \"found staticlib `{}` instead of rlib or dylib{}\",\n-                self.crate_name,\n-                add\n-            );\n-            err.help(\"please recompile that crate using --crate-type lib\");\n-            let mismatches = self.rejected_via_kind.iter();\n-            for &CrateMismatch { ref path, .. } in mismatches {\n-                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.crate_name, path.display()));\n-            }\n-            err.note(&msg);\n-            err\n-        } else if !self.rejected_via_version.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0514,\n-                \"found crate `{}` compiled by an incompatible version \\\n-                                            of rustc{}\",\n-                self.crate_name,\n-                add\n-            );\n-            err.help(&format!(\n-                \"please recompile that crate using this compiler ({})\",\n-                rustc_version()\n-            ));\n-            let mismatches = self.rejected_via_version.iter();\n-            for &CrateMismatch { ref path, ref got } in mismatches {\n-                msg.push_str(&format!(\n-                    \"\\ncrate `{}` compiled by {}: {}\",\n-                    self.crate_name,\n-                    got,\n-                    path.display()\n-                ));\n-            }\n-            err.note(&msg);\n-            err\n-        } else {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0463,\n-                \"can't find crate for `{}`{}\",\n-                self.crate_name,\n-                add\n-            );\n-\n-            if (self.crate_name == sym::std || self.crate_name == sym::core)\n-                && self.triple != TargetTriple::from_triple(config::host_triple())\n-            {\n-                err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n-            } else if self.crate_name == sym::profiler_builtins {\n-                err.note(&\"the compiler may have been built without the profiler runtime\");\n-            }\n-            err.span_label(self.span, \"can't find crate\");\n-            err\n-        };\n-\n-        if !self.rejected_via_filename.is_empty() {\n-            let dylibname = self.dylibname();\n-            let mismatches = self.rejected_via_filename.iter();\n-            for &CrateMismatch { ref path, .. } in mismatches {\n-                err.note(&format!(\n-                    \"extern location for {} is of an unknown type: {}\",\n-                    self.crate_name,\n-                    path.display()\n-                ))\n-                .help(&format!(\n-                    \"file name should be lib*.rlib or {}*.{}\",\n-                    dylibname.0, dylibname.1\n-                ));\n+        if let Some(extra_filename) = self.extra_filename {\n+            if let library @ Some(_) = self.find_library_crate(extra_filename, &mut seen_paths)? {\n+                return Ok(library);\n             }\n         }\n-\n-        err.emit();\n-        self.sess.abort_if_errors();\n-        unreachable!();\n+        self.find_library_crate(\"\", &mut seen_paths)\n     }\n \n     fn find_library_crate(\n         &mut self,\n         extra_prefix: &str,\n         seen_paths: &mut FxHashSet<PathBuf>,\n-    ) -> Option<Library> {\n-        let dypair = self.dylibname();\n-        let staticpair = self.staticlibname();\n-\n+    ) -> Result<Option<Library>, CrateError> {\n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = format!(\"{}{}{}\", dypair.0, self.crate_name, extra_prefix);\n+        let dylib_prefix =\n+            format!(\"{}{}{}\", self.target.options.dll_prefix, self.crate_name, extra_prefix);\n         let rlib_prefix = format!(\"lib{}{}\", self.crate_name, extra_prefix);\n-        let staticlib_prefix = format!(\"{}{}{}\", staticpair.0, self.crate_name, extra_prefix);\n+        let staticlib_prefix =\n+            format!(\"{}{}{}\", self.target.options.staticlib_prefix, self.crate_name, extra_prefix);\n \n         let mut candidates: FxHashMap<_, (FxHashMap<_, _>, FxHashMap<_, _>, FxHashMap<_, _>)> =\n             Default::default();\n@@ -555,10 +405,18 @@ impl<'a> CrateLocator<'a> {\n                 (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n             } else if file.starts_with(&rlib_prefix) && file.ends_with(\".rmeta\") {\n                 (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n-            } else if file.starts_with(&dylib_prefix) && file.ends_with(&dypair.1) {\n-                (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], CrateFlavor::Dylib)\n+            } else if file.starts_with(&dylib_prefix)\n+                && file.ends_with(&self.target.options.dll_suffix)\n+            {\n+                (\n+                    &file\n+                        [(dylib_prefix.len())..(file.len() - self.target.options.dll_suffix.len())],\n+                    CrateFlavor::Dylib,\n+                )\n             } else {\n-                if file.starts_with(&staticlib_prefix) && file.ends_with(&staticpair.1) {\n+                if file.starts_with(&staticlib_prefix)\n+                    && file.ends_with(&self.target.options.staticlib_suffix)\n+                {\n                     staticlibs\n                         .push(CrateMismatch { path: spf.path.clone(), got: \"static\".to_string() });\n                 }\n@@ -567,26 +425,18 @@ impl<'a> CrateLocator<'a> {\n \n             info!(\"lib candidate: {}\", spf.path.display());\n \n-            let hash_str = hash.to_string();\n-            let slot = candidates.entry(hash_str).or_default();\n-            let (ref mut rlibs, ref mut rmetas, ref mut dylibs) = *slot;\n+            let (rlibs, rmetas, dylibs) = candidates.entry(hash.to_string()).or_default();\n             fs::canonicalize(&spf.path)\n                 .map(|p| {\n                     if seen_paths.contains(&p) {\n                         return FileDoesntMatch;\n                     };\n                     seen_paths.insert(p.clone());\n                     match found_kind {\n-                        CrateFlavor::Rlib => {\n-                            rlibs.insert(p, kind);\n-                        }\n-                        CrateFlavor::Rmeta => {\n-                            rmetas.insert(p, kind);\n-                        }\n-                        CrateFlavor::Dylib => {\n-                            dylibs.insert(p, kind);\n-                        }\n-                    }\n+                        CrateFlavor::Rlib => rlibs.insert(p, kind),\n+                        CrateFlavor::Rmeta => rmetas.insert(p, kind),\n+                        CrateFlavor::Dylib => dylibs.insert(p, kind),\n+                    };\n                     FileMatches\n                 })\n                 .unwrap_or(FileDoesntMatch)\n@@ -603,7 +453,7 @@ impl<'a> CrateLocator<'a> {\n         // search is being performed for.\n         let mut libraries = FxHashMap::default();\n         for (_hash, (rlibs, rmetas, dylibs)) in candidates {\n-            if let Some((svh, lib)) = self.extract_lib(rlibs, rmetas, dylibs) {\n+            if let Some((svh, lib)) = self.extract_lib(rlibs, rmetas, dylibs)? {\n                 libraries.insert(svh, lib);\n             }\n         }\n@@ -612,39 +462,9 @@ impl<'a> CrateLocator<'a> {\n         // what we've got and figure out if we found multiple candidates for\n         // libraries or not.\n         match libraries.len() {\n-            0 => None,\n-            1 => Some(libraries.into_iter().next().unwrap().1),\n-            _ => {\n-                let mut err = struct_span_err!(\n-                    self.sess,\n-                    self.span,\n-                    E0464,\n-                    \"multiple matching crates for `{}`\",\n-                    self.crate_name\n-                );\n-                let candidates = libraries\n-                    .iter()\n-                    .filter_map(|(_, lib)| {\n-                        let crate_name = &lib.metadata.get_root().name().as_str();\n-                        match &(&lib.source.dylib, &lib.source.rlib) {\n-                            &(&Some((ref pd, _)), &Some((ref pr, _))) => Some(format!(\n-                                \"\\ncrate `{}`: {}\\n{:>padding$}\",\n-                                crate_name,\n-                                pd.display(),\n-                                pr.display(),\n-                                padding = 8 + crate_name.len()\n-                            )),\n-                            &(&Some((ref p, _)), &None) | &(&None, &Some((ref p, _))) => {\n-                                Some(format!(\"\\ncrate `{}`: {}\", crate_name, p.display()))\n-                            }\n-                            &(&None, &None) => None,\n-                        }\n-                    })\n-                    .collect::<String>();\n-                err.note(&format!(\"candidates:{}\", candidates));\n-                err.emit();\n-                None\n-            }\n+            0 => Ok(None),\n+            1 => Ok(Some(libraries.into_iter().next().unwrap().1)),\n+            _ => Err(CrateError::MultipleMatchingCrates(self.crate_name, libraries)),\n         }\n     }\n \n@@ -653,16 +473,16 @@ impl<'a> CrateLocator<'a> {\n         rlibs: FxHashMap<PathBuf, PathKind>,\n         rmetas: FxHashMap<PathBuf, PathKind>,\n         dylibs: FxHashMap<PathBuf, PathKind>,\n-    ) -> Option<(Svh, Library)> {\n+    ) -> Result<Option<(Svh, Library)>, CrateError> {\n         let mut slot = None;\n         // Order here matters, rmeta should come first. See comment in\n         // `extract_one` below.\n         let source = CrateSource {\n-            rmeta: self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot),\n-            rlib: self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot),\n-            dylib: self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot),\n+            rmeta: self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot)?,\n+            rlib: self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot)?,\n+            dylib: self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot)?,\n         };\n-        slot.map(|(svh, metadata)| (svh, Library { source, metadata }))\n+        Ok(slot.map(|(svh, metadata)| (svh, Library { source, metadata })))\n     }\n \n     fn needs_crate_flavor(&self, flavor: CrateFlavor) -> bool {\n@@ -698,10 +518,7 @@ impl<'a> CrateLocator<'a> {\n         m: FxHashMap<PathBuf, PathKind>,\n         flavor: CrateFlavor,\n         slot: &mut Option<(Svh, MetadataBlob)>,\n-    ) -> Option<(PathBuf, PathKind)> {\n-        let mut ret: Option<(PathBuf, PathKind)> = None;\n-        let mut error = 0;\n-\n+    ) -> Result<Option<(PathBuf, PathKind)>, CrateError> {\n         // If we are producing an rlib, and we've already loaded metadata, then\n         // we should not attempt to discover further crate sources (unless we're\n         // locating a proc macro; exact logic is in needs_crate_flavor). This means\n@@ -718,13 +535,14 @@ impl<'a> CrateLocator<'a> {\n         // from the other crate sources.\n         if slot.is_some() {\n             if m.is_empty() || !self.needs_crate_flavor(flavor) {\n-                return None;\n+                return Ok(None);\n             } else if m.len() == 1 {\n-                return Some(m.into_iter().next().unwrap());\n+                return Ok(Some(m.into_iter().next().unwrap()));\n             }\n         }\n \n-        let mut err: Option<DiagnosticBuilder<'_>> = None;\n+        let mut ret: Option<(PathBuf, PathKind)> = None;\n+        let mut err_data: Option<Vec<PathBuf>> = None;\n         for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let (hash, metadata) =\n@@ -744,30 +562,18 @@ impl<'a> CrateLocator<'a> {\n                 };\n             // If we see multiple hashes, emit an error about duplicate candidates.\n             if slot.as_ref().map_or(false, |s| s.0 != hash) {\n-                let mut e = struct_span_err!(\n-                    self.sess,\n-                    self.span,\n-                    E0465,\n-                    \"multiple {} candidates for `{}` found\",\n-                    flavor,\n-                    self.crate_name\n-                );\n-                e.span_note(\n-                    self.span,\n-                    &format!(r\"candidate #1: {}\", ret.as_ref().unwrap().0.display()),\n-                );\n-                if let Some(ref mut e) = err {\n-                    e.emit();\n+                if let Some(candidates) = err_data {\n+                    return Err(CrateError::MultipleCandidates(\n+                        self.crate_name,\n+                        flavor,\n+                        candidates,\n+                    ));\n                 }\n-                err = Some(e);\n-                error = 1;\n+                err_data = Some(vec![ret.as_ref().unwrap().0.clone()]);\n                 *slot = None;\n             }\n-            if error > 0 {\n-                error += 1;\n-                err.as_mut()\n-                    .unwrap()\n-                    .span_note(self.span, &format!(r\"candidate #{}: {}\", error, lib.display()));\n+            if let Some(candidates) = &mut err_data {\n+                candidates.push(lib);\n                 continue;\n             }\n \n@@ -790,7 +596,7 @@ impl<'a> CrateLocator<'a> {\n             // As a result, we favor the sysroot crate here. Note that the\n             // candidates are all canonicalized, so we canonicalize the sysroot\n             // as well.\n-            if let Some((ref prev, _)) = ret {\n+            if let Some((prev, _)) = &ret {\n                 let sysroot = &self.sess.sysroot;\n                 let sysroot = sysroot.canonicalize().unwrap_or_else(|_| sysroot.to_path_buf());\n                 if prev.starts_with(&sysroot) {\n@@ -801,11 +607,10 @@ impl<'a> CrateLocator<'a> {\n             ret = Some((lib, kind));\n         }\n \n-        if error > 0 {\n-            err.unwrap().emit();\n-            None\n+        if let Some(candidates) = err_data {\n+            Err(CrateError::MultipleCandidates(self.crate_name, flavor, candidates))\n         } else {\n-            ret\n+            Ok(ret)\n         }\n     }\n \n@@ -860,97 +665,60 @@ impl<'a> CrateLocator<'a> {\n         Some(hash)\n     }\n \n-    // Returns the corresponding (prefix, suffix) that files need to have for\n-    // dynamic libraries\n-    fn dylibname(&self) -> (String, String) {\n-        let t = &self.target;\n-        (t.options.dll_prefix.clone(), t.options.dll_suffix.clone())\n-    }\n-\n-    // Returns the corresponding (prefix, suffix) that files need to have for\n-    // static libraries\n-    fn staticlibname(&self) -> (String, String) {\n-        let t = &self.target;\n-        (t.options.staticlib_prefix.clone(), t.options.staticlib_suffix.clone())\n-    }\n-\n-    fn find_commandline_library(&mut self) -> Option<Library> {\n+    fn find_commandline_library(&mut self) -> Result<Option<Library>, CrateError> {\n         // First, filter out all libraries that look suspicious. We only accept\n         // files which actually exist that have the correct naming scheme for\n         // rlibs/dylibs.\n-        let sess = self.sess;\n-        let dylibname = self.dylibname();\n         let mut rlibs = FxHashMap::default();\n         let mut rmetas = FxHashMap::default();\n         let mut dylibs = FxHashMap::default();\n-        {\n-            let crate_name = self.crate_name;\n-            let rejected_via_filename = &mut self.rejected_via_filename;\n-            let locs = self.exact_paths.iter().filter(|loc| {\n-                if !loc.exists() {\n-                    sess.err(&format!(\n-                        \"extern location for {} does not exist: {}\",\n-                        crate_name,\n-                        loc.display()\n-                    ));\n-                    return false;\n-                }\n-                let file = match loc.file_name().and_then(|s| s.to_str()) {\n-                    Some(file) => file,\n-                    None => {\n-                        sess.err(&format!(\n-                            \"extern location for {} is not a file: {}\",\n-                            crate_name,\n-                            loc.display()\n-                        ));\n-                        return false;\n-                    }\n-                };\n-                if file.starts_with(\"lib\") && (file.ends_with(\".rlib\") || file.ends_with(\".rmeta\"))\n-                {\n-                    return true;\n-                } else {\n-                    let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(&prefix[..]) && file.ends_with(&suffix[..]) {\n-                        return true;\n-                    }\n+        for loc in &self.exact_paths {\n+            if !loc.exists() {\n+                return Err(CrateError::ExternLocationNotExist(self.crate_name, loc.clone()));\n+            }\n+            let file = match loc.file_name().and_then(|s| s.to_str()) {\n+                Some(file) => file,\n+                None => {\n+                    return Err(CrateError::ExternLocationNotFile(self.crate_name, loc.clone()));\n                 }\n+            };\n \n-                rejected_via_filename\n-                    .push(CrateMismatch { path: (*loc).clone(), got: String::new() });\n-\n-                false\n-            });\n-\n-            // Now that we have an iterator of good candidates, make sure\n-            // there's at most one rlib and at most one dylib.\n-            for loc in locs {\n+            if file.starts_with(\"lib\") && (file.ends_with(\".rlib\") || file.ends_with(\".rmeta\"))\n+                || file.starts_with(&self.target.options.dll_prefix)\n+                    && file.ends_with(&self.target.options.dll_suffix)\n+            {\n+                // Make sure there's at most one rlib and at most one dylib.\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n                     rlibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 } else if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rmeta\") {\n                     rmetas.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 } else {\n                     dylibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 }\n+            } else {\n+                self.rejected_via_filename\n+                    .push(CrateMismatch { path: loc.clone(), got: String::new() });\n             }\n-        };\n+        }\n \n         // Extract the dylib/rlib/rmeta triple.\n-        self.extract_lib(rlibs, rmetas, dylibs).map(|(_, lib)| lib)\n+        Ok(self.extract_lib(rlibs, rmetas, dylibs)?.map(|(_, lib)| lib))\n     }\n-}\n \n-// Just a small wrapper to time how long reading metadata takes.\n-fn get_metadata_section(\n-    target: &Target,\n-    flavor: CrateFlavor,\n-    filename: &Path,\n-    loader: &dyn MetadataLoader,\n-) -> Result<MetadataBlob, String> {\n-    let start = Instant::now();\n-    let ret = get_metadata_section_imp(target, flavor, filename, loader);\n-    info!(\"reading {:?} => {:?}\", filename.file_name().unwrap(), start.elapsed());\n-    ret\n+    crate fn into_error(self) -> CrateError {\n+        CrateError::LocatorCombined(CombinedLocatorError {\n+            crate_name: self.crate_name,\n+            root: self.root.cloned(),\n+            triple: self.triple,\n+            dll_prefix: self.target.options.dll_prefix.clone(),\n+            dll_suffix: self.target.options.dll_suffix.clone(),\n+            rejected_via_hash: self.rejected_via_hash,\n+            rejected_via_triple: self.rejected_via_triple,\n+            rejected_via_kind: self.rejected_via_kind,\n+            rejected_via_version: self.rejected_via_version,\n+            rejected_via_filename: self.rejected_via_filename,\n+        })\n+    }\n }\n \n /// A trivial wrapper for `Mmap` that implements `StableDeref`.\n@@ -966,7 +734,7 @@ impl Deref for StableDerefMmap {\n \n unsafe impl stable_deref_trait::StableDeref for StableDerefMmap {}\n \n-fn get_metadata_section_imp(\n+fn get_metadata_section(\n     target: &Target,\n     flavor: CrateFlavor,\n     filename: &Path,\n@@ -1026,12 +794,19 @@ pub fn find_plugin_registrar(\n     metadata_loader: &dyn MetadataLoader,\n     span: Span,\n     name: Symbol,\n-) -> Option<(PathBuf, CrateDisambiguator)> {\n+) -> (PathBuf, CrateDisambiguator) {\n+    match find_plugin_registrar_impl(sess, metadata_loader, name) {\n+        Ok(res) => res,\n+        Err(err) => err.report(sess, span),\n+    }\n+}\n+\n+fn find_plugin_registrar_impl<'a>(\n+    sess: &'a Session,\n+    metadata_loader: &dyn MetadataLoader,\n+    name: Symbol,\n+) -> Result<(PathBuf, CrateDisambiguator), CrateError> {\n     info!(\"find plugin registrar `{}`\", name);\n-    let target_triple = sess.opts.target_triple.clone();\n-    let host_triple = TargetTriple::from_triple(config::host_triple());\n-    let is_cross = target_triple != host_triple;\n-    let mut target_only = false;\n     let mut locator = CrateLocator::new(\n         sess,\n         metadata_loader,\n@@ -1041,57 +816,16 @@ pub fn find_plugin_registrar(\n         None, // extra_filename\n         true, // is_host\n         PathKind::Crate,\n-        span,\n         None, // root\n         None, // is_proc_macro\n     );\n \n-    let library = locator.maybe_load_library_crate().or_else(|| {\n-        if !is_cross {\n-            return None;\n-        }\n-        // Try loading from target crates. This will abort later if we\n-        // try to load a plugin registrar function,\n-        target_only = true;\n-\n-        locator.target = &sess.target.target;\n-        locator.triple = target_triple;\n-        locator.filesearch = sess.target_filesearch(PathKind::Crate);\n-\n-        locator.maybe_load_library_crate()\n-    });\n-    let library = match library {\n-        Some(l) => l,\n-        None => locator.report_errs(),\n-    };\n-\n-    if target_only {\n-        let message = format!(\n-            \"plugin `{}` is not available for triple `{}` (only found {})\",\n-            name,\n-            config::host_triple(),\n-            sess.opts.target_triple\n-        );\n-        struct_span_err!(sess, span, E0456, \"{}\", &message).emit();\n-        return None;\n-    }\n-\n-    match library.source.dylib {\n-        Some(dylib) => Some((dylib.0, library.metadata.get_root().disambiguator())),\n-        None => {\n-            struct_span_err!(\n-                sess,\n-                span,\n-                E0457,\n-                \"plugin `{}` only found in rlib format, but must be available \\\n-                        in dylib format\",\n-                name\n-            )\n-            .emit();\n-            // No need to abort because the loading code will just ignore this\n-            // empty dylib.\n-            None\n-        }\n+    match locator.maybe_load_library_crate()? {\n+        Some(library) => match library.source.dylib {\n+            Some(dylib) => Ok((dylib.0, library.metadata.get_root().disambiguator())),\n+            None => Err(CrateError::NonDylibPlugin(name)),\n+        },\n+        None => Err(locator.into_error()),\n     }\n }\n \n@@ -1100,8 +834,8 @@ pub fn list_file_metadata(\n     target: &Target,\n     path: &Path,\n     metadata_loader: &dyn MetadataLoader,\n-    out: &mut dyn io::Write,\n-) -> io::Result<()> {\n+    out: &mut dyn Write,\n+) -> IoResult<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") {\n         CrateFlavor::Rlib\n@@ -1115,3 +849,259 @@ pub fn list_file_metadata(\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }\n }\n+\n+// ------------------------------------------ Error reporting -------------------------------------\n+\n+#[derive(Clone)]\n+struct CrateMismatch {\n+    path: PathBuf,\n+    got: String,\n+}\n+\n+/// Candidate rejection reasons collected during crate search.\n+/// If no candidate is accepted, then these reasons are presented to the user,\n+/// otherwise they are ignored.\n+crate struct CombinedLocatorError {\n+    crate_name: Symbol,\n+    root: Option<CratePaths>,\n+    triple: TargetTriple,\n+    dll_prefix: String,\n+    dll_suffix: String,\n+    rejected_via_hash: Vec<CrateMismatch>,\n+    rejected_via_triple: Vec<CrateMismatch>,\n+    rejected_via_kind: Vec<CrateMismatch>,\n+    rejected_via_version: Vec<CrateMismatch>,\n+    rejected_via_filename: Vec<CrateMismatch>,\n+}\n+\n+crate enum CrateError {\n+    NonAsciiName(Symbol),\n+    ExternLocationNotExist(Symbol, PathBuf),\n+    ExternLocationNotFile(Symbol, PathBuf),\n+    MultipleCandidates(Symbol, CrateFlavor, Vec<PathBuf>),\n+    MultipleMatchingCrates(Symbol, FxHashMap<Svh, Library>),\n+    SymbolConflictsCurrent(Symbol),\n+    SymbolConflictsOthers(Symbol),\n+    DlOpen(String),\n+    DlSym(String),\n+    LocatorCombined(CombinedLocatorError),\n+    NonDylibPlugin(Symbol),\n+}\n+\n+impl CrateError {\n+    crate fn report(self, sess: &Session, span: Span) -> ! {\n+        let mut err = match self {\n+            CrateError::NonAsciiName(crate_name) => sess.struct_span_err(\n+                span,\n+                &format!(\"cannot load a crate with a non-ascii name `{}`\", crate_name),\n+            ),\n+            CrateError::ExternLocationNotExist(crate_name, loc) => sess.struct_span_err(\n+                span,\n+                &format!(\"extern location for {} does not exist: {}\", crate_name, loc.display()),\n+            ),\n+            CrateError::ExternLocationNotFile(crate_name, loc) => sess.struct_span_err(\n+                span,\n+                &format!(\"extern location for {} is not a file: {}\", crate_name, loc.display()),\n+            ),\n+            CrateError::MultipleCandidates(crate_name, flavor, candidates) => {\n+                let mut err = struct_span_err!(\n+                    sess,\n+                    span,\n+                    E0465,\n+                    \"multiple {} candidates for `{}` found\",\n+                    flavor,\n+                    crate_name,\n+                );\n+                for (i, candidate) in candidates.iter().enumerate() {\n+                    err.span_note(span, &format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n+                }\n+                err\n+            }\n+            CrateError::MultipleMatchingCrates(crate_name, libraries) => {\n+                let mut err = struct_span_err!(\n+                    sess,\n+                    span,\n+                    E0464,\n+                    \"multiple matching crates for `{}`\",\n+                    crate_name\n+                );\n+                let candidates = libraries\n+                    .iter()\n+                    .filter_map(|(_, lib)| {\n+                        let crate_name = &lib.metadata.get_root().name().as_str();\n+                        match (&lib.source.dylib, &lib.source.rlib) {\n+                            (Some((pd, _)), Some((pr, _))) => Some(format!(\n+                                \"\\ncrate `{}`: {}\\n{:>padding$}\",\n+                                crate_name,\n+                                pd.display(),\n+                                pr.display(),\n+                                padding = 8 + crate_name.len()\n+                            )),\n+                            (Some((p, _)), None) | (None, Some((p, _))) => {\n+                                Some(format!(\"\\ncrate `{}`: {}\", crate_name, p.display()))\n+                            }\n+                            (None, None) => None,\n+                        }\n+                    })\n+                    .collect::<String>();\n+                err.note(&format!(\"candidates:{}\", candidates));\n+                err\n+            }\n+            CrateError::SymbolConflictsCurrent(root_name) => struct_span_err!(\n+                sess,\n+                span,\n+                E0519,\n+                \"the current crate is indistinguishable from one of its dependencies: it has the \\\n+                 same crate-name `{}` and was compiled with the same `-C metadata` arguments. \\\n+                 This will result in symbol conflicts between the two.\",\n+                root_name,\n+            ),\n+            CrateError::SymbolConflictsOthers(root_name) => struct_span_err!(\n+                sess,\n+                span,\n+                E0523,\n+                \"found two different crates with name `{}` that are not distinguished by differing \\\n+                 `-C metadata`. This will result in symbol conflicts between the two.\",\n+                root_name,\n+            ),\n+            CrateError::DlOpen(s) | CrateError::DlSym(s) => sess.struct_span_err(span, &s),\n+            CrateError::LocatorCombined(locator) => {\n+                let crate_name = locator.crate_name;\n+                let add = match &locator.root {\n+                    None => String::new(),\n+                    Some(r) => format!(\" which `{}` depends on\", r.name),\n+                };\n+                let mut msg = \"the following crate versions were found:\".to_string();\n+                let mut err = if !locator.rejected_via_hash.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0460,\n+                        \"found possibly newer version of crate `{}`{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+                    err.note(\"perhaps that crate needs to be recompiled?\");\n+                    let mismatches = locator.rejected_via_hash.iter();\n+                    for CrateMismatch { path, .. } in mismatches {\n+                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n+                    }\n+                    if let Some(r) = locator.root {\n+                        for path in r.source.paths() {\n+                            msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.name, path.display()));\n+                        }\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else if !locator.rejected_via_triple.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0461,\n+                        \"couldn't find crate `{}` with expected target triple {}{}\",\n+                        crate_name,\n+                        locator.triple,\n+                        add,\n+                    );\n+                    let mismatches = locator.rejected_via_triple.iter();\n+                    for CrateMismatch { path, got } in mismatches {\n+                        msg.push_str(&format!(\n+                            \"\\ncrate `{}`, target triple {}: {}\",\n+                            crate_name,\n+                            got,\n+                            path.display(),\n+                        ));\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else if !locator.rejected_via_kind.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0462,\n+                        \"found staticlib `{}` instead of rlib or dylib{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+                    err.help(\"please recompile that crate using --crate-type lib\");\n+                    let mismatches = locator.rejected_via_kind.iter();\n+                    for CrateMismatch { path, .. } in mismatches {\n+                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else if !locator.rejected_via_version.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0514,\n+                        \"found crate `{}` compiled by an incompatible version of rustc{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+                    err.help(&format!(\n+                        \"please recompile that crate using this compiler ({})\",\n+                        rustc_version(),\n+                    ));\n+                    let mismatches = locator.rejected_via_version.iter();\n+                    for CrateMismatch { path, got } in mismatches {\n+                        msg.push_str(&format!(\n+                            \"\\ncrate `{}` compiled by {}: {}\",\n+                            crate_name,\n+                            got,\n+                            path.display(),\n+                        ));\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0463,\n+                        \"can't find crate for `{}`{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+\n+                    if (crate_name == sym::std || crate_name == sym::core)\n+                        && locator.triple != TargetTriple::from_triple(config::host_triple())\n+                    {\n+                        err.note(&format!(\"the `{}` target may not be installed\", locator.triple));\n+                    } else if crate_name == sym::profiler_builtins {\n+                        err.note(&\"the compiler may have been built without the profiler runtime\");\n+                    }\n+                    err.span_label(span, \"can't find crate\");\n+                    err\n+                };\n+\n+                if !locator.rejected_via_filename.is_empty() {\n+                    let mismatches = locator.rejected_via_filename.iter();\n+                    for CrateMismatch { path, .. } in mismatches {\n+                        err.note(&format!(\n+                            \"extern location for {} is of an unknown type: {}\",\n+                            crate_name,\n+                            path.display(),\n+                        ))\n+                        .help(&format!(\n+                            \"file name should be lib*.rlib or {}*.{}\",\n+                            locator.dll_prefix, locator.dll_suffix\n+                        ));\n+                    }\n+                }\n+                err\n+            }\n+            CrateError::NonDylibPlugin(crate_name) => struct_span_err!(\n+                sess,\n+                span,\n+                E0457,\n+                \"plugin `{}` only found in rlib format, but must be available in dylib format\",\n+                crate_name,\n+            ),\n+        };\n+\n+        err.emit();\n+        sess.abort_if_errors();\n+        unreachable!();\n+    }\n+}"}, {"sha": "1e06dadfa24532bbc5f3651679c4c57c3b9d21c6", "filename": "src/librustc_middle/mir/coverage/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -2,9 +2,10 @@\n \n /// Positional arguments to `libcore::count_code_region()`\n pub mod count_code_region_args {\n-    pub const COUNTER_INDEX: usize = 0;\n-    pub const START_BYTE_POS: usize = 1;\n-    pub const END_BYTE_POS: usize = 2;\n+    pub const FUNCTION_SOURCE_HASH: usize = 0;\n+    pub const COUNTER_INDEX: usize = 1;\n+    pub const START_BYTE_POS: usize = 2;\n+    pub const END_BYTE_POS: usize = 3;\n }\n \n /// Positional arguments to `libcore::coverage_counter_add()` and"}, {"sha": "1ad5008d28a987f264550781c599d21debf8bebb", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> MonoItem<'tcx> {\n             .debugging_opts\n             .inline_in_all_cgus\n             .unwrap_or_else(|| tcx.sess.opts.optimize != OptLevel::No)\n-            && !tcx.sess.opts.cg.link_dead_code;\n+            && tcx.sess.opts.cg.link_dead_code != Some(true);\n \n         match *self {\n             MonoItem::Fn(ref instance) => {"}, {"sha": "6ce5d61fbed1b82dcd710540511f874d32e38dc0", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -400,13 +400,11 @@ pub struct DestructuredConst<'tcx> {\n /// `InstrumentCoverage` MIR pass and can be retrieved via the `coverageinfo` query.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct CoverageInfo {\n-    /// A hash value that can be used by the consumer of the coverage profile data to detect\n-    /// changes to the instrumented source of the associated MIR body (typically, for an\n-    /// individual function).\n-    pub hash: u64,\n-\n     /// The total number of coverage region counters added to the MIR `Body`.\n     pub num_counters: u32,\n+\n+    /// The total number of coverage region counter expressions added to the MIR `Body`.\n+    pub num_expressions: u32,\n }\n \n impl<'tcx> TyCtxt<'tcx> {"}, {"sha": "5836fc9c95a80af6cb330c332a4446f3094665e6", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -95,6 +95,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let (dest, ret) = match ret {\n             None => match intrinsic_name {\n                 sym::transmute => throw_ub_format!(\"transmuting to uninhabited type\"),\n+                sym::unreachable => throw_ub!(Unreachable),\n                 sym::abort => M::abort(self)?,\n                 // Unsupported diverging intrinsic.\n                 _ => return Ok(false),"}, {"sha": "6162651db14a0b8d8780a5fadd6e32351eaa5f74", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -161,7 +161,7 @@ where\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n     // more freedom to optimize.\n-    if !tcx.sess.opts.cg.link_dead_code {\n+    if tcx.sess.opts.cg.link_dead_code != Some(true) {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n         internalize_symbols(tcx, &mut post_inlining, inlining_map);\n     }\n@@ -906,7 +906,7 @@ fn collect_and_partition_mono_items(\n             }\n         }\n         None => {\n-            if tcx.sess.opts.cg.link_dead_code {\n+            if tcx.sess.opts.cg.link_dead_code == Some(true) {\n                 MonoItemCollectionMode::Eager\n             } else {\n                 MonoItemCollectionMode::Lazy"}, {"sha": "9933a975e4dac194f98fe19a806e203280a6bdc9", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 204, "deletions": 56, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -35,46 +35,64 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> Coverage\n     // represents a single function. Validate and/or correct if inlining (which should be disabled\n     // if -Zinstrument-coverage is enabled) and/or monomorphization invalidates these assumptions.\n     let count_code_region_fn = tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None);\n+    let coverage_counter_add_fn =\n+        tcx.require_lang_item(lang_items::CoverageCounterAddFnLangItem, None);\n+    let coverage_counter_subtract_fn =\n+        tcx.require_lang_item(lang_items::CoverageCounterSubtractFnLangItem, None);\n \n     // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n     // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n     // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n     // not work; but computing the num_counters by adding `1` to the highest index (for a given\n     // instrumented function) is valid.\n+    //\n+    // `num_expressions` is the number of counter expressions added to the MIR body. Both\n+    // `num_counters` and `num_expressions` are used to initialize new vectors, during backend\n+    // code generate, to lookup counters and expressions by their simple u32 indexes.\n     let mut num_counters: u32 = 0;\n-    for terminator in traversal::preorder(mir_body)\n-        .map(|(_, data)| (data, count_code_region_fn))\n-        .filter_map(terminators_that_call_given_fn)\n+    let mut num_expressions: u32 = 0;\n+    for terminator in\n+        traversal::preorder(mir_body).map(|(_, data)| data).filter_map(call_terminators)\n     {\n-        if let TerminatorKind::Call { args, .. } = &terminator.kind {\n-            let index_arg = args.get(count_code_region_args::COUNTER_INDEX).expect(\"arg found\");\n-            let index =\n-                mir::Operand::scalar_from_const(index_arg).to_u32().expect(\"index arg is u32\");\n-            num_counters = std::cmp::max(num_counters, index + 1);\n-        }\n-    }\n-    let hash = if num_counters > 0 { hash_mir_source(tcx, mir_def_id) } else { 0 };\n-    CoverageInfo { num_counters, hash }\n-}\n-\n-fn terminators_that_call_given_fn(\n-    (data, fn_def_id): (&'tcx BasicBlockData<'tcx>, DefId),\n-) -> Option<&'tcx Terminator<'tcx>> {\n-    if let Some(terminator) = &data.terminator {\n-        if let TerminatorKind::Call { func: Operand::Constant(func), .. } = &terminator.kind {\n-            if let FnDef(called_fn_def_id, _) = func.literal.ty.kind {\n-                if called_fn_def_id == fn_def_id {\n-                    return Some(&terminator);\n+        if let TerminatorKind::Call { func: Operand::Constant(func), args, .. } = &terminator.kind {\n+            match func.literal.ty.kind {\n+                FnDef(id, _) if id == count_code_region_fn => {\n+                    let index_arg =\n+                        args.get(count_code_region_args::COUNTER_INDEX).expect(\"arg found\");\n+                    let counter_index = mir::Operand::scalar_from_const(index_arg)\n+                        .to_u32()\n+                        .expect(\"index arg is u32\");\n+                    num_counters = std::cmp::max(num_counters, counter_index + 1);\n+                }\n+                FnDef(id, _)\n+                    if id == coverage_counter_add_fn || id == coverage_counter_subtract_fn =>\n+                {\n+                    let index_arg = args\n+                        .get(coverage_counter_expression_args::COUNTER_EXPRESSION_INDEX)\n+                        .expect(\"arg found\");\n+                    let translated_index = mir::Operand::scalar_from_const(index_arg)\n+                        .to_u32()\n+                        .expect(\"index arg is u32\");\n+                    // Counter expressions start with \"translated indexes\", descending from\n+                    // `u32::MAX`, so the range of expression indexes is disjoint from the range of\n+                    // counter indexes. This way, both counters and expressions can be operands in\n+                    // other expressions.\n+                    let expression_index = u32::MAX - translated_index;\n+                    num_expressions = std::cmp::max(num_expressions, expression_index + 1);\n                 }\n+                _ => {}\n             }\n         }\n     }\n-    None\n+    CoverageInfo { num_counters, num_expressions }\n }\n \n-struct Instrumentor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    num_counters: u32,\n+fn call_terminators(data: &'tcx BasicBlockData<'tcx>) -> Option<&'tcx Terminator<'tcx>> {\n+    let terminator = data.terminator();\n+    match terminator.kind {\n+        TerminatorKind::Call { .. } => Some(terminator),\n+        _ => None,\n+    }\n }\n \n impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n@@ -83,42 +101,106 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n             // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n             // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n             if src.promoted.is_none() {\n-                debug!(\n-                    \"instrumenting {:?}, span: {}\",\n-                    src.def_id(),\n-                    tcx.sess.source_map().span_to_string(mir_body.span)\n-                );\n-                Instrumentor::new(tcx).inject_counters(mir_body);\n+                Instrumentor::new(tcx, src, mir_body).inject_counters();\n             }\n         }\n     }\n }\n \n-impl<'tcx> Instrumentor<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        Self { tcx, num_counters: 0 }\n+/// Distinguishes the expression operators.\n+enum Op {\n+    Add,\n+    Subtract,\n+}\n+\n+struct Instrumentor<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    mir_def_id: DefId,\n+    mir_body: &'a mut mir::Body<'tcx>,\n+    hir_body: &'tcx rustc_hir::Body<'tcx>,\n+    function_source_hash: Option<u64>,\n+    num_counters: u32,\n+    num_expressions: u32,\n+}\n+\n+impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, mir_body: &'a mut mir::Body<'tcx>) -> Self {\n+        let mir_def_id = src.def_id();\n+        let hir_body = hir_body(tcx, mir_def_id);\n+        Self {\n+            tcx,\n+            mir_def_id,\n+            mir_body,\n+            hir_body,\n+            function_source_hash: None,\n+            num_counters: 0,\n+            num_expressions: 0,\n+        }\n     }\n \n+    /// Counter IDs start from zero and go up.\n     fn next_counter(&mut self) -> u32 {\n+        assert!(self.num_counters < u32::MAX - self.num_expressions);\n         let next = self.num_counters;\n         self.num_counters += 1;\n         next\n     }\n \n-    fn inject_counters(&mut self, mir_body: &mut mir::Body<'tcx>) {\n+    /// Expression IDs start from u32::MAX and go down because a CounterExpression can reference\n+    /// (add or subtract counts) of both Counter regions and CounterExpression regions. The indexes\n+    /// of each type of region must be contiguous, but also must be unique across both sets.\n+    /// The expression IDs are eventually translated into region indexes (starting after the last\n+    /// counter index, for the given function), during backend code generation, by the helper method\n+    /// `rustc_codegen_ssa::coverageinfo::map::FunctionCoverage::translate_expressions()`.\n+    fn next_expression(&mut self) -> u32 {\n+        assert!(self.num_counters < u32::MAX - self.num_expressions);\n+        let next = u32::MAX - self.num_expressions;\n+        self.num_expressions += 1;\n+        next\n+    }\n+\n+    fn function_source_hash(&mut self) -> u64 {\n+        match self.function_source_hash {\n+            Some(hash) => hash,\n+            None => {\n+                let hash = hash_mir_source(self.tcx, self.hir_body);\n+                self.function_source_hash.replace(hash);\n+                hash\n+            }\n+        }\n+    }\n+\n+    fn inject_counters(&mut self) {\n+        let body_span = self.hir_body.value.span;\n+        debug!(\n+            \"instrumenting {:?}, span: {}\",\n+            self.mir_def_id,\n+            self.tcx.sess.source_map().span_to_string(body_span)\n+        );\n+\n         // FIXME(richkadel): As a first step, counters are only injected at the top of each\n         // function. The complete solution will inject counters at each conditional code branch.\n-        let code_region = mir_body.span;\n         let next_block = START_BLOCK;\n-        self.inject_counter(mir_body, code_region, next_block);\n+        self.inject_counter(body_span, next_block);\n+\n+        // FIXME(richkadel): The next step to implement source based coverage analysis will be\n+        // instrumenting branches within functions, and some regions will be counted by \"counter\n+        // expression\". The function to inject counter expression is implemented. Replace this\n+        // \"fake use\" with real use.\n+        let fake_use = false;\n+        if fake_use {\n+            let add = false;\n+            if add {\n+                self.inject_counter_expression(body_span, next_block, 1, Op::Add, 2);\n+            } else {\n+                self.inject_counter_expression(body_span, next_block, 1, Op::Subtract, 2);\n+            }\n+        }\n     }\n \n-    fn inject_counter(\n-        &mut self,\n-        mir_body: &mut mir::Body<'tcx>,\n-        code_region: Span,\n-        next_block: BasicBlock,\n-    ) {\n+    fn inject_counter(&mut self, code_region: Span, next_block: BasicBlock) -> u32 {\n+        let counter_id = self.next_counter();\n+        let function_source_hash = self.function_source_hash();\n         let injection_point = code_region.shrink_to_lo();\n \n         let count_code_region_fn = function_handle(\n@@ -127,50 +209,113 @@ impl<'tcx> Instrumentor<'tcx> {\n             injection_point,\n         );\n \n-        let index = self.next_counter();\n-\n         let mut args = Vec::new();\n \n         use count_code_region_args::*;\n+        debug_assert_eq!(FUNCTION_SOURCE_HASH, args.len());\n+        args.push(self.const_u64(function_source_hash, injection_point));\n+\n         debug_assert_eq!(COUNTER_INDEX, args.len());\n-        args.push(self.const_u32(index, injection_point));\n+        args.push(self.const_u32(counter_id, injection_point));\n \n         debug_assert_eq!(START_BYTE_POS, args.len());\n         args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n \n         debug_assert_eq!(END_BYTE_POS, args.len());\n         args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n \n-        let mut patch = MirPatch::new(mir_body);\n+        self.inject_call(count_code_region_fn, args, injection_point, next_block);\n \n-        let temp = patch.new_temp(self.tcx.mk_unit(), code_region);\n-        let new_block = patch.new_block(placeholder_block(code_region));\n+        counter_id\n+    }\n+\n+    fn inject_counter_expression(\n+        &mut self,\n+        code_region: Span,\n+        next_block: BasicBlock,\n+        lhs: u32,\n+        op: Op,\n+        rhs: u32,\n+    ) -> u32 {\n+        let expression_id = self.next_expression();\n+        let injection_point = code_region.shrink_to_lo();\n+\n+        let count_code_region_fn = function_handle(\n+            self.tcx,\n+            self.tcx.require_lang_item(\n+                match op {\n+                    Op::Add => lang_items::CoverageCounterAddFnLangItem,\n+                    Op::Subtract => lang_items::CoverageCounterSubtractFnLangItem,\n+                },\n+                None,\n+            ),\n+            injection_point,\n+        );\n+\n+        let mut args = Vec::new();\n+\n+        use coverage_counter_expression_args::*;\n+        debug_assert_eq!(COUNTER_EXPRESSION_INDEX, args.len());\n+        args.push(self.const_u32(expression_id, injection_point));\n+\n+        debug_assert_eq!(LEFT_INDEX, args.len());\n+        args.push(self.const_u32(lhs, injection_point));\n+\n+        debug_assert_eq!(RIGHT_INDEX, args.len());\n+        args.push(self.const_u32(rhs, injection_point));\n+\n+        debug_assert_eq!(START_BYTE_POS, args.len());\n+        args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n+\n+        debug_assert_eq!(END_BYTE_POS, args.len());\n+        args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n+\n+        self.inject_call(count_code_region_fn, args, injection_point, next_block);\n+\n+        expression_id\n+    }\n+\n+    fn inject_call(\n+        &mut self,\n+        func: Operand<'tcx>,\n+        args: Vec<Operand<'tcx>>,\n+        fn_span: Span,\n+        next_block: BasicBlock,\n+    ) {\n+        let mut patch = MirPatch::new(self.mir_body);\n+\n+        let temp = patch.new_temp(self.tcx.mk_unit(), fn_span);\n+        let new_block = patch.new_block(placeholder_block(fn_span));\n         patch.patch_terminator(\n             new_block,\n             TerminatorKind::Call {\n-                func: count_code_region_fn,\n+                func,\n                 args,\n                 // new_block will swapped with the next_block, after applying patch\n                 destination: Some((Place::from(temp), new_block)),\n                 cleanup: None,\n                 from_hir_call: false,\n-                fn_span: injection_point,\n+                fn_span,\n             },\n         );\n \n         patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n         patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n \n-        patch.apply(mir_body);\n+        patch.apply(self.mir_body);\n \n         // To insert the `new_block` in front of the first block in the counted branch (the\n         // `next_block`), just swap the indexes, leaving the rest of the graph unchanged.\n-        mir_body.basic_blocks_mut().swap(next_block, new_block);\n+        self.mir_body.basic_blocks_mut().swap(next_block, new_block);\n     }\n \n     fn const_u32(&self, value: u32, span: Span) -> Operand<'tcx> {\n         Operand::const_from_scalar(self.tcx, self.tcx.types.u32, Scalar::from_u32(value), span)\n     }\n+\n+    fn const_u64(&self, value: u64, span: Span) -> Operand<'tcx> {\n+        Operand::const_from_scalar(self.tcx, self.tcx.types.u64, Scalar::from_u64(value), span)\n+    }\n }\n \n fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Operand<'tcx> {\n@@ -192,10 +337,13 @@ fn placeholder_block(span: Span) -> BasicBlockData<'tcx> {\n     }\n }\n \n-fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> u64 {\n+fn hir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx rustc_hir::Body<'tcx> {\n     let hir_node = tcx.hir().get_if_local(def_id).expect(\"DefId is local\");\n     let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n-    let hir_body = tcx.hir().body(fn_body_id);\n+    tcx.hir().body(fn_body_id)\n+}\n+\n+fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n     let mut hcx = tcx.create_no_span_stable_hashing_context();\n     hash(&mut hcx, &hir_body.value).to_smaller_hash()\n }"}, {"sha": "3b11fb379625f717b78521c34de778f7d69d04c0", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -3,14 +3,13 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::fake_lang_items::FAKE_ITEMS_REFS;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::lang_items;\n-use rustc_hir::lang_items::ITEM_REFS;\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n use rustc_middle::middle::lang_items::required;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n-use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n@@ -77,15 +76,14 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n             if self.items.require(item).is_err() {\n                 self.items.missing.push(item);\n             }\n-        } else if name == sym::count_code_region {\n-            // `core::intrinsics::code_count_region()` is (currently) the only `extern` lang item\n-            // that is never actually linked. It is not a `weak_lang_item` that can be registered\n-            // when used, and should be registered here instead.\n-            if let Some((item_index, _)) = ITEM_REFS.get(&name).cloned() {\n-                if self.items.items[item_index].is_none() {\n-                    let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n-                    self.items.items[item_index] = Some(item_def_id);\n-                }\n+        } else if let Some(&item) = FAKE_ITEMS_REFS.get(&name) {\n+            // Ensure \"fake lang items\" are registered. These are `extern` lang items that are\n+            // injected into the MIR automatically (such as source code coverage counters), but are\n+            // never actually linked; therefore, unlike \"weak lang items\", they cannot by registered\n+            // when used, because they never appear to be used.\n+            if self.items.items[item as usize].is_none() {\n+                let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n+                self.items.items[item as usize] = Some(item_def_id);\n             }\n         } else {\n             struct_span_err!(self.tcx.sess, span, E0264, \"unknown external lang item: `{}`\", name)"}, {"sha": "62a87b47a2f74e7215a85d1310841273289f7a16", "filename": "src/librustc_plugin_impl/load.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_plugin_impl%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_plugin_impl%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fload.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -55,13 +55,11 @@ fn load_plugin(\n     metadata_loader: &dyn MetadataLoader,\n     ident: Ident,\n ) {\n-    let registrar = locator::find_plugin_registrar(sess, metadata_loader, ident.span, ident.name);\n-\n-    if let Some((lib, disambiguator)) = registrar {\n-        let symbol = sess.generate_plugin_registrar_symbol(disambiguator);\n-        let fun = dylink_registrar(sess, ident.span, lib, symbol);\n-        plugins.push(fun);\n-    }\n+    let (lib, disambiguator) =\n+        locator::find_plugin_registrar(sess, metadata_loader, ident.span, ident.name);\n+    let symbol = sess.generate_plugin_registrar_symbol(disambiguator);\n+    let fun = dylink_registrar(sess, ident.span, lib, symbol);\n+    plugins.push(fun);\n }\n \n // Dynamically link a registrar function into the compiler process."}, {"sha": "a7a005bdeb9f2e3b59b2d0796c2947bc6ae6dddd", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -859,9 +859,7 @@ impl<'a> Resolver<'a> {\n                     // otherwise cause duplicate suggestions.\n                     continue;\n                 }\n-                if let Some(crate_id) =\n-                    self.crate_loader.maybe_process_path_extern(ident.name, ident.span)\n-                {\n+                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name) {\n                     let crate_root =\n                         self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                     suggestions.extend(self.lookup_import_candidates_from_module("}, {"sha": "9323c15a94109b9cdb6ad278051bcc451719cb8d", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -760,10 +760,8 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                         if !module.no_implicit_prelude {\n                             let extern_prelude = self.r.extern_prelude.clone();\n                             names.extend(extern_prelude.iter().flat_map(|(ident, _)| {\n-                                self.r\n-                                    .crate_loader\n-                                    .maybe_process_path_extern(ident.name, ident.span)\n-                                    .and_then(|crate_id| {\n+                                self.r.crate_loader.maybe_process_path_extern(ident.name).and_then(\n+                                    |crate_id| {\n                                         let crate_mod = Res::Def(\n                                             DefKind::Mod,\n                                             DefId { krate: crate_id, index: CRATE_DEF_INDEX },\n@@ -774,7 +772,8 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                                         } else {\n                                             None\n                                         }\n-                                    })\n+                                    },\n+                                )\n                             }));\n \n                             if let Some(prelude) = self.r.prelude {"}, {"sha": "da39f79efcd3bc487d8889a90a4d4bab146e8b29", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -2957,7 +2957,7 @@ impl<'a> Resolver<'a> {\n                 let crate_id = if !speculative {\n                     self.crate_loader.process_path_extern(ident.name, ident.span)\n                 } else {\n-                    self.crate_loader.maybe_process_path_extern(ident.name, ident.span)?\n+                    self.crate_loader.maybe_process_path_extern(ident.name)?\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 Some("}, {"sha": "839ffa5785adacb372b7068475b3998ebe25e49f", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1707,6 +1707,31 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         );\n     }\n \n+    if debugging_opts.instrument_coverage {\n+        if cg.profile_generate.enabled() || cg.profile_use.is_some() {\n+            early_error(\n+                error_format,\n+                \"option `-Z instrument-coverage` is not compatible with either `-C profile-use` \\\n+                or `-C profile-generate`\",\n+            );\n+        }\n+\n+        // `-Z instrument-coverage` implies:\n+        //   * `-Z symbol-mangling-version=v0` - to ensure consistent and reversable name mangling.\n+        //     Note, LLVM coverage tools can analyze coverage over multiple runs, including some\n+        //     changes to source code; so mangled names must be consistent across compilations.\n+        //   * `-C link-dead-code` - so unexecuted code is still counted as zero, rather than be\n+        //     optimized out. Note that instrumenting dead code can be explicitly disabled with:\n+        //         `-Z instrument-coverage -C link-dead-code=no`.\n+        debugging_opts.symbol_mangling_version = SymbolManglingVersion::V0;\n+        if cg.link_dead_code == None {\n+            // FIXME(richkadel): Investigate if the `instrument-coverage` implementation can\n+            // inject [\"zero counters\"](https://llvm.org/docs/CoverageMappingFormat.html#counter)\n+            // in the coverage map when \"dead code\" is removed, rather than forcing `link-dead-code`.\n+            cg.link_dead_code = Some(true);\n+        }\n+    }\n+\n     if !cg.embed_bitcode {\n         match cg.lto {\n             LtoCli::No | LtoCli::Unspecified => {}"}, {"sha": "8c1f6a77497407fe269b5ada524926ce56f37d0e", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -715,7 +715,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"a single extra argument to append to the linker invocation (can be used several times)\"),\n     link_args: Vec<String> = (Vec::new(), parse_list, [UNTRACKED],\n         \"extra arguments to append to the linker invocation (space separated)\"),\n-    link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n+    link_dead_code: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n         \"keep dead code at link time (useful for code coverage) (default: no)\"),\n     linker: Option<PathBuf> = (None, parse_opt_pathbuf, [UNTRACKED],\n         \"system linker to link outputs with\"),\n@@ -880,10 +880,12 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         (such as entering an empty infinite loop) by inserting llvm.sideeffect \\\n         (default: no)\"),\n     instrument_coverage: bool = (false, parse_bool, [TRACKED],\n-        \"instrument the generated code with LLVM code region counters to (in the \\\n-        future) generate coverage reports; disables/overrides some optimization \\\n-        options (note, the compiler build config must include `profiler = true`) \\\n-        (default: no)\"),\n+        \"instrument the generated code to support LLVM source-based code coverage \\\n+        reports (note, the compiler build config must include `profiler = true`, \\\n+        and is mutually exclusive with `-C profile-generate`/`-C profile-use`); \\\n+        implies `-C link-dead-code` (unless explicitly disabled)` and\n+        `-Z symbol-mangling-version=v0`; and disables/overrides some optimization \\\n+        options (default: no)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "4ad95e95e9a86a68fe5e30eebf489878e3067909", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1357,6 +1357,20 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n         );\n     }\n \n+    // FIXME(richkadel): See `src/test/run-make-fulldeps/instrument-coverage/Makefile`. After\n+    // compiling with `-Zinstrument-coverage`, the resulting binary generates a segfault during\n+    // the program's exit process (likely while attempting to generate the coverage stats in\n+    // the \"*.profraw\" file). An investigation to resolve the problem on Windows is ongoing,\n+    // but until this is resolved, the option is disabled on Windows, and the test is skipped\n+    // when targeting `MSVC`.\n+    if sess.opts.debugging_opts.instrument_coverage && sess.target.target.options.is_like_msvc {\n+        sess.warn(\n+            \"Rust source-based code coverage instrumentation (with `-Z instrument-coverage`) \\\n+            is not yet supported on Windows when targeting MSVC. The resulting binaries will \\\n+            still be instrumented for experimentation purposes, but may not execute correctly.\",\n+        );\n+    }\n+\n     const ASAN_SUPPORTED_TARGETS: &[&str] = &[\n         \"aarch64-fuchsia\",\n         \"aarch64-unknown-linux-gnu\","}, {"sha": "d53033ba3ba2043d79e4330df412e17455f5f782", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -676,6 +676,7 @@ supported_targets! {\n     (\"powerpc64-wrs-vxworks\", powerpc64_wrs_vxworks),\n \n     (\"mipsel-sony-psp\", mipsel_sony_psp),\n+    (\"thumbv4t-none-eabi\", thumbv4t_none_eabi),\n }\n \n /// Everything `rustc` knows about how to compile for a specific target."}, {"sha": "31417b0154759faa03b14f51e61fc522ca407890", "filename": "src/librustc_target/spec/thumbv4t_none_eabi.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_target%2Fspec%2Fthumbv4t_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_target%2Fspec%2Fthumbv4t_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fthumbv4t_none_eabi.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,62 @@\n+//! Targets the ARMv4T, with code as `t32` code by default.\n+//!\n+//! Primarily of use for the GBA, but usable with other devices too.\n+//!\n+//! Please ping @Lokathor if changes are needed.\n+//!\n+//! This target profile assumes that you have the ARM binutils in your path (specifically the linker, `arm-none-eabi-ld`). They can be obtained for free for all major OSes from the ARM developer's website, and they may also be available in your system's package manager. Unfortunately, the standard linker that Rust uses (`lld`) only supports as far back as `ARMv5TE`, so we must use the GNU `ld` linker.\n+//!\n+//! **Important:** This target profile **does not** specify a linker script. You just get the default link script when you build a binary for this target. The default link script is very likely wrong, so you should use `-Clink-arg=-Tmy_script.ld` to override that with a correct linker script.\n+\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"thumbv4t-none-eabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        target_os: \"none\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"\".to_string(),\n+        arch: \"arm\".to_string(),\n+        /* Data layout args are '-' separated:\n+         * little endian\n+         * stack is 64-bit aligned (EABI)\n+         * pointers are 32-bit\n+         * i64 must be 64-bit aligned (EABI)\n+         * mangle names with ELF style\n+         * native integers are 32-bit\n+         * All other elements are default\n+         */\n+        data_layout: \"e-S64-p:32:32-i64:64-m:e-n32\".to_string(),\n+        linker_flavor: LinkerFlavor::Ld,\n+        options: TargetOptions {\n+            linker: Some(\"arm-none-eabi-ld\".to_string()),\n+            linker_is_gnu: true,\n+\n+            // extra args passed to the external assembler (assuming `arm-none-eabi-as`):\n+            // * activate t32/a32 interworking\n+            // * use arch ARMv4T\n+            // * use little-endian\n+            asm_args: vec![\n+                \"-mthumb-interwork\".to_string(),\n+                \"-march=armv4t\".to_string(),\n+                \"-mlittle-endian\".to_string(),\n+            ],\n+\n+            // minimum extra features, these cannot be disabled via -C\n+            features: \"+soft-float,+strict-align\".to_string(),\n+\n+            main_needs_argc_argv: false,\n+\n+            // No thread-local storage (just use a static Cell)\n+            has_elf_tls: false,\n+\n+            // don't have atomic compare-and-swap\n+            atomic_cas: false,\n+\n+            ..super::thumb_base::opts()\n+        },\n+    })\n+}"}, {"sha": "a09edf575c8072b17370bd3461048b8eb58b1e99", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -386,7 +386,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             }\n \n             sym::count_code_region => {\n-                (0, vec![tcx.types.u32, tcx.types.u32, tcx.types.u32], tcx.mk_unit())\n+                (0, vec![tcx.types.u64, tcx.types.u32, tcx.types.u32, tcx.types.u32], tcx.mk_unit())\n             }\n \n             sym::coverage_counter_add | sym::coverage_counter_subtract => ("}, {"sha": "ecfaaeace513e329873de16187a83875b0c5a4c4", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 71, "deletions": 20, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -59,6 +59,7 @@\n //! The `#[global_allocator]` can only be used once in a crate\n //! or its recursive dependencies.\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use core::intrinsics;\n@@ -158,7 +159,9 @@ unsafe impl AllocRef for System {\n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n-            GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+            // SAFETY: The safety guarantees are explained in the documentation\n+            // for the `GlobalAlloc` trait and its `dealloc` method.\n+            unsafe { GlobalAlloc::dealloc(self, ptr.as_ptr(), layout) }\n         }\n     }\n \n@@ -184,16 +187,36 @@ unsafe impl AllocRef for System {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if layout.size() == 0 => {\n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                    // SAFETY: The new size and layout alignement guarantees\n+                    // are transfered to the caller (they come from parameters).\n+                    //\n+                    // See the preconditions for `Layout::from_size_align` to\n+                    // see what must be checked.\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 self.alloc(new_layout, init)\n             }\n             ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size > size` or something similar.\n-                intrinsics::assume(new_size > size);\n-                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                let memory =\n-                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                init.init_offset(memory, size);\n+                // SAFETY:\n+                //\n+                // The safety guarantees are explained in the documentation\n+                // for the `GlobalAlloc` trait and its `dealloc` method.\n+                //\n+                // `realloc` probably checks for `new_size > size` or something\n+                // similar.\n+                //\n+                // For the guarantees about `init_offset`, see its documentation:\n+                // `ptr` is assumed valid (and checked for non-NUL) and\n+                // `memory.size` is set to `new_size` so the offset being `size`\n+                // is valid.\n+                let memory = unsafe {\n+                    intrinsics::assume(new_size > size);\n+                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                    let memory =\n+                        MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n+                    init.init_offset(memory, size);\n+                    memory\n+                };\n                 Ok(memory)\n             }\n         }\n@@ -220,14 +243,28 @@ unsafe impl AllocRef for System {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if new_size == 0 => {\n-                self.dealloc(ptr, layout);\n+                // SAFETY: see `GlobalAlloc::dealloc` for the guarantees that\n+                // must be respected. `ptr` and `layout` are parameters and so\n+                // those guarantees must be checked by the caller.\n+                unsafe { self.dealloc(ptr, layout) };\n                 Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n             }\n             ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size < size` or something similar.\n-                intrinsics::assume(new_size < size);\n-                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n+                // SAFETY:\n+                //\n+                // See `GlobalAlloc::realloc` for more informations about the\n+                // guarantees expected by this method. `ptr`, `layout` and\n+                // `new_size` are parameters and the responsability for their\n+                // correctness is left to the caller.\n+                //\n+                // `realloc` probably checks for `new_size < size` or something\n+                // similar.\n+                let memory = unsafe {\n+                    intrinsics::assume(new_size < size);\n+                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size }\n+                };\n+                Ok(memory)\n             }\n         }\n     }\n@@ -300,13 +337,19 @@ pub mod __default_lib_allocator {\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_alloc(size: usize, align: usize) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc(layout)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::alloc`.\n+        unsafe {\n+            let layout = Layout::from_size_align_unchecked(size, align);\n+            System.alloc(layout)\n+        }\n     }\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_dealloc(ptr: *mut u8, size: usize, align: usize) {\n-        System.dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::dealloc`.\n+        unsafe { System.dealloc(ptr, Layout::from_size_align_unchecked(size, align)) }\n     }\n \n     #[rustc_std_internal_symbol]\n@@ -316,13 +359,21 @@ pub mod __default_lib_allocator {\n         align: usize,\n         new_size: usize,\n     ) -> *mut u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-        System.realloc(ptr, old_layout, new_size)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::realloc`.\n+        unsafe {\n+            let old_layout = Layout::from_size_align_unchecked(old_size, align);\n+            System.realloc(ptr, old_layout, new_size)\n+        }\n     }\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_alloc_zeroed(size: usize, align: usize) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc_zeroed(layout)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::alloc_zeroed`.\n+        unsafe {\n+            let layout = Layout::from_size_align_unchecked(size, align);\n+            System.alloc_zeroed(layout)\n+        }\n     }\n }"}, {"sha": "7b48deee1abdf73f013f49637742fc7e13424d46", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 19, "deletions": 68, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -148,14 +148,11 @@ use crate::sys;\n /// The easiest way to use `HashMap` with a custom key type is to derive [`Eq`] and [`Hash`].\n /// We must also derive [`PartialEq`].\n ///\n-/// [`Eq`]: ../../std/cmp/trait.Eq.html\n-/// [`Hash`]: ../../std/hash/trait.Hash.html\n-/// [`PartialEq`]: ../../std/cmp/trait.PartialEq.html\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n-/// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`default`]: #method.default\n-/// [`with_hasher`]: #method.with_hasher\n-/// [`with_capacity_and_hasher`]: #method.with_capacity_and_hasher\n+/// [`RefCell`]: crate::cell::RefCell\n+/// [`Cell`]: crate::cell::Cell\n+/// [`default`]: Default::default\n+/// [`with_hasher`]: Self::with_hasher\n+/// [`with_capacity_and_hasher`]: Self::with_capacity_and_hasher\n /// [`fnv`]: https://crates.io/crates/fnv\n ///\n /// ```\n@@ -264,8 +261,6 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// let mut map = HashMap::with_hasher(s);\n     /// map.insert(1, 2);\n     /// ```\n-    ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n@@ -296,8 +291,6 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n     /// map.insert(1, 2);\n     /// ```\n-    ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {\n@@ -524,8 +517,6 @@ impl<K, V, S> HashMap<K, V, S> {\n \n     /// Returns a reference to the map's [`BuildHasher`].\n     ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -556,8 +547,6 @@ where\n     ///\n     /// Panics if the new allocation size overflows [`usize`].\n     ///\n-    /// [`usize`]: ../../std/primitive.usize.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -676,9 +665,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -705,9 +691,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -734,9 +717,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -763,9 +743,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -797,8 +774,7 @@ where\n     /// types that can be `==` without being identical. See the [module-level\n     /// documentation] for more.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [module-level documentation]: index.html#insert-and-complex-keys\n+    /// [module-level documentation]: crate::collections#insert-and-complex-keys\n     ///\n     /// # Examples\n     ///\n@@ -826,9 +802,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -856,9 +829,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1040,8 +1010,7 @@ where\n /// This `struct` is created by the [`iter`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`iter`]: struct.HashMap.html#method.iter\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`iter`]: HashMap::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     base: base::Iter<'a, K, V>,\n@@ -1068,8 +1037,7 @@ impl<K: Debug, V: Debug> fmt::Debug for Iter<'_, K, V> {\n /// This `struct` is created by the [`iter_mut`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`iter_mut`]: struct.HashMap.html#method.iter_mut\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`iter_mut`]: HashMap::iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     base: base::IterMut<'a, K, V>,\n@@ -1088,8 +1056,7 @@ impl<'a, K, V> IterMut<'a, K, V> {\n /// This `struct` is created by the [`into_iter`] method on [`HashMap`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n-/// [`into_iter`]: struct.HashMap.html#method.into_iter\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`into_iter`]: IntoIterator::into_iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     base: base::IntoIter<K, V>,\n@@ -1108,8 +1075,7 @@ impl<K, V> IntoIter<K, V> {\n /// This `struct` is created by the [`keys`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`keys`]: struct.HashMap.html#method.keys\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`keys`]: HashMap::keys\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -1136,8 +1102,7 @@ impl<K: Debug, V> fmt::Debug for Keys<'_, K, V> {\n /// This `struct` is created by the [`values`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`values`]: struct.HashMap.html#method.values\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`values`]: HashMap::values\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -1164,8 +1129,7 @@ impl<K, V: Debug> fmt::Debug for Values<'_, K, V> {\n /// This `struct` is created by the [`drain`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`drain`]: struct.HashMap.html#method.drain\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`drain`]: HashMap::drain\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n     base: base::Drain<'a, K, V>,\n@@ -1184,8 +1148,7 @@ impl<'a, K, V> Drain<'a, K, V> {\n /// This `struct` is created by the [`values_mut`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`values_mut`]: struct.HashMap.html#method.values_mut\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`values_mut`]: HashMap::values_mut\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n pub struct ValuesMut<'a, K: 'a, V: 'a> {\n     inner: IterMut<'a, K, V>,\n@@ -1195,7 +1158,7 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n ///\n /// See the [`HashMap::raw_entry_mut`] docs for usage examples.\n ///\n-/// [`HashMap::raw_entry_mut`]: struct.HashMap.html#method.raw_entry_mut\n+/// [`HashMap::raw_entry_mut`]: HashMap::raw_entry_mut\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n@@ -1209,9 +1172,8 @@ pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n /// This `enum` is constructed through the [`raw_entry_mut`] method on [`HashMap`],\n /// then calling one of the methods of that [`RawEntryBuilderMut`].\n ///\n-/// [`HashMap`]: struct.HashMap.html\n /// [`Entry`]: enum.Entry.html\n-/// [`raw_entry_mut`]: struct.HashMap.html#method.raw_entry_mut\n+/// [`raw_entry_mut`]: HashMap::raw_entry_mut\n /// [`RawEntryBuilderMut`]: struct.RawEntryBuilderMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n@@ -1223,17 +1185,13 @@ pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n \n /// A view into an occupied entry in a `HashMap`.\n /// It is part of the [`RawEntryMut`] enum.\n-///\n-/// [`RawEntryMut`]: enum.RawEntryMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n     base: base::RawOccupiedEntryMut<'a, K, V>,\n }\n \n /// A view into a vacant entry in a `HashMap`.\n /// It is part of the [`RawEntryMut`] enum.\n-///\n-/// [`RawEntryMut`]: enum.RawEntryMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     base: base::RawVacantEntryMut<'a, K, V, S>,\n@@ -1243,7 +1201,7 @@ pub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n ///\n /// See the [`HashMap::raw_entry`] docs for usage examples.\n ///\n-/// [`HashMap::raw_entry`]: struct.HashMap.html#method.raw_entry\n+/// [`HashMap::raw_entry`]: HashMap::raw_entry\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n     map: &'a HashMap<K, V, S>,\n@@ -1597,8 +1555,7 @@ impl<K, V, S> Debug for RawEntryBuilder<'_, K, V, S> {\n ///\n /// This `enum` is constructed from the [`entry`] method on [`HashMap`].\n ///\n-/// [`HashMap`]: struct.HashMap.html\n-/// [`entry`]: struct.HashMap.html#method.entry\n+/// [`entry`]: HashMap::entry\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied entry.\n@@ -2156,7 +2113,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// If you need a reference to the `OccupiedEntry` which may outlive the\n     /// destruction of the `Entry` value, see [`into_mut`].\n     ///\n-    /// [`into_mut`]: #method.into_mut\n+    /// [`into_mut`]: Self::into_mut\n     ///\n     /// # Examples\n     ///\n@@ -2189,7 +2146,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     ///\n     /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n     ///\n-    /// [`get_mut`]: #method.get_mut\n+    /// [`get_mut`]: Self::get_mut\n     ///\n     /// # Examples\n     ///\n@@ -2475,9 +2432,6 @@ where\n /// [`Hasher`], but the hashers created by two different `RandomState`\n /// instances are unlikely to produce the same result for the same values.\n ///\n-/// [`HashMap`]: struct.HashMap.html\n-/// [`Hasher`]: ../../hash/trait.Hasher.html\n-///\n /// # Examples\n ///\n /// ```\n@@ -2547,9 +2501,6 @@ impl BuildHasher for RandomState {\n ///\n /// The internal algorithm is not specified, and so it and its hashes should\n /// not be relied upon over releases.\n-///\n-/// [`RandomState`]: struct.RandomState.html\n-/// [`Hasher`]: ../../hash/trait.Hasher.html\n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n #[allow(deprecated)]\n #[derive(Clone, Debug)]"}, {"sha": "10bf917daea4680534d685b4ba7678b98974d6f3", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 9, "deletions": 38, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -98,12 +98,8 @@ use super::map::{self, HashMap, Keys, RandomState};\n /// // use the values stored in the set\n /// ```\n ///\n-/// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`Eq`]: ../../std/cmp/trait.Eq.html\n-/// [`Hash`]: ../../std/hash/trait.Hash.html\n-/// [`HashMap`]: struct.HashMap.html\n-/// [`PartialEq`]: ../../std/cmp/trait.PartialEq.html\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`RefCell`]: crate::cell::RefCell\n+/// [`Cell`]: crate::cell::Cell\n #[derive(Clone)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"hashset_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -286,8 +282,6 @@ impl<T, S> HashSet<T, S> {\n     /// let mut set = HashSet::with_hasher(s);\n     /// set.insert(2);\n     /// ```\n-    ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hasher: S) -> HashSet<T, S> {\n@@ -318,8 +312,6 @@ impl<T, S> HashSet<T, S> {\n     /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n     /// set.insert(1);\n     /// ```\n-    ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {\n@@ -328,8 +320,6 @@ impl<T, S> HashSet<T, S> {\n \n     /// Returns a reference to the set's [`BuildHasher`].\n     ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -577,9 +567,6 @@ where\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n@@ -605,9 +592,6 @@ where\n     /// assert_eq!(set.get(&2), Some(&2));\n     /// assert_eq!(set.get(&4), None);\n     /// ```\n-    ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[inline]\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n@@ -849,9 +833,6 @@ where\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n@@ -877,9 +858,6 @@ where\n     /// assert_eq!(set.take(&2), Some(2));\n     /// assert_eq!(set.take(&2), None);\n     /// ```\n-    ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[inline]\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n@@ -1153,8 +1131,7 @@ where\n /// This `struct` is created by the [`iter`] method on [`HashSet`].\n /// See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`iter`]: struct.HashSet.html#method.iter\n+/// [`iter`]: HashSet::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a> {\n     iter: Keys<'a, K, ()>,\n@@ -1165,8 +1142,7 @@ pub struct Iter<'a, K: 'a> {\n /// This `struct` is created by the [`into_iter`] method on [`HashSet`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`into_iter`]: struct.HashSet.html#method.into_iter\n+/// [`into_iter`]: IntoIterator::into_iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n     iter: map::IntoIter<K, ()>,\n@@ -1177,8 +1153,7 @@ pub struct IntoIter<K> {\n /// This `struct` is created by the [`drain`] method on [`HashSet`].\n /// See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`drain`]: struct.HashSet.html#method.drain\n+/// [`drain`]: HashSet::drain\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n     iter: map::Drain<'a, K, ()>,\n@@ -1189,8 +1164,7 @@ pub struct Drain<'a, K: 'a> {\n /// This `struct` is created by the [`intersection`] method on [`HashSet`].\n /// See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`intersection`]: struct.HashSet.html#method.intersection\n+/// [`intersection`]: HashSet::intersection\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n@@ -1204,8 +1178,7 @@ pub struct Intersection<'a, T: 'a, S: 'a> {\n /// This `struct` is created by the [`difference`] method on [`HashSet`].\n /// See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`difference`]: struct.HashSet.html#method.difference\n+/// [`difference`]: HashSet::difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n@@ -1219,8 +1192,7 @@ pub struct Difference<'a, T: 'a, S: 'a> {\n /// This `struct` is created by the [`symmetric_difference`] method on\n /// [`HashSet`]. See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`symmetric_difference`]: struct.HashSet.html#method.symmetric_difference\n+/// [`symmetric_difference`]: HashSet::symmetric_difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n     iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>,\n@@ -1231,8 +1203,7 @@ pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n /// This `struct` is created by the [`union`] method on [`HashSet`].\n /// See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`union`]: struct.HashSet.html#method.union\n+/// [`union`]: HashSet::union\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T: 'a, S: 'a> {\n     iter: Chain<Iter<'a, T>, Difference<'a, T, S>>,"}, {"sha": "da25a0ede729d1fd3c66b1819fda6e91d17aa3bb", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1551,6 +1551,27 @@ impl ops::Index<ops::RangeFull> for CString {\n     }\n }\n \n+#[stable(feature = \"cstr_range_from\", since = \"1.47.0\")]\n+impl ops::Index<ops::RangeFrom<usize>> for CStr {\n+    type Output = CStr;\n+\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &CStr {\n+        let bytes = self.to_bytes_with_nul();\n+        // we need to manually check the starting index to account for the null\n+        // byte, since otherwise we could get an empty string that doesn't end\n+        // in a null.\n+        if index.start < bytes.len() {\n+            unsafe { CStr::from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n+        } else {\n+            panic!(\n+                \"index out of bounds: the len is {} but the index is {}\",\n+                bytes.len(),\n+                index.start\n+            );\n+        }\n+    }\n+}\n+\n #[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n impl AsRef<CStr> for CStr {\n     #[inline]\n@@ -1747,4 +1768,21 @@ mod tests {\n \n         assert_eq!(CSTR.to_str().unwrap(), \"Hello, world!\");\n     }\n+\n+    #[test]\n+    fn cstr_index_from() {\n+        let original = b\"Hello, world!\\0\";\n+        let cstr = CStr::from_bytes_with_nul(original).unwrap();\n+        let result = CStr::from_bytes_with_nul(&original[7..]).unwrap();\n+\n+        assert_eq!(&cstr[7..], result);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn cstr_index_from_empty() {\n+        let original = b\"Hello, world!\\0\";\n+        let cstr = CStr::from_bytes_with_nul(original).unwrap();\n+        let _ = &cstr[original.len()..];\n+    }\n }"}, {"sha": "797318d95b7775f3d5e13011acc9401da7cfb1ee", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 51, "deletions": 90, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -238,25 +238,14 @@\n //! contract. The implementation of many of these functions are subject to change over\n //! time and may call fewer or more syscalls/library functions.\n //!\n-//! [`Read`]: trait.Read.html\n-//! [`Write`]: trait.Write.html\n-//! [`Seek`]: trait.Seek.html\n-//! [`BufRead`]: trait.BufRead.html\n-//! [`File`]: ../fs/struct.File.html\n-//! [`TcpStream`]: ../net/struct.TcpStream.html\n-//! [`Vec<T>`]: ../vec/struct.Vec.html\n-//! [`BufReader`]: struct.BufReader.html\n-//! [`BufWriter`]: struct.BufWriter.html\n-//! [`Write::write`]: trait.Write.html#tymethod.write\n-//! [`io::stdout`]: fn.stdout.html\n-//! [`println!`]: ../macro.println.html\n-//! [`Lines`]: struct.Lines.html\n-//! [`io::Result`]: type.Result.html\n+//! [`File`]: crate::fs::File\n+//! [`TcpStream`]: crate::net::TcpStream\n+//! [`Vec<T>`]: crate::vec::Vec\n+//! [`io::stdout`]: stdout\n+//! [`io::Result`]: crate::io::Result\n //! [`?` operator]: ../../book/appendix-02-operators.html\n-//! [`Read::read`]: trait.Read.html#tymethod.read\n-//! [`Result`]: ../result/enum.Result.html\n-//! [`.unwrap()`]: ../result/enum.Result.html#method.unwrap\n-// ignore-tidy-filelength\n+//! [`Result`]: crate::result::Result\n+//! [`.unwrap()`]: crate::result::Result::unwrap\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -491,12 +480,10 @@ where\n /// }\n /// ```\n ///\n-/// [`read()`]: trait.Read.html#tymethod.read\n-/// [`std::io`]: ../../std/io/index.html\n-/// [`File`]: ../fs/struct.File.html\n-/// [`BufRead`]: trait.BufRead.html\n-/// [`BufReader`]: struct.BufReader.html\n-/// [`&str`]: ../../std/primitive.str.html\n+/// [`read()`]: Read::read\n+/// [`&str`]: str\n+/// [`std::io`]: self\n+/// [`File`]: crate::fs::File\n /// [slice]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(spotlight)]\n@@ -535,7 +522,7 @@ pub trait Read {\n     /// before calling `read`. Calling `read` with an uninitialized `buf` (of the kind one\n     /// obtains via [`MaybeUninit<T>`]) is not safe, and can lead to undefined behavior.\n     ///\n-    /// [`MaybeUninit<T>`]: ../mem/union.MaybeUninit.html\n+    /// [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n     ///\n     /// # Errors\n     ///\n@@ -550,10 +537,8 @@ pub trait Read {\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`Ok(n)`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`File`]: ../fs/struct.File.html\n+    /// [`Ok(n)`]: Ok\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -620,9 +605,6 @@ pub trait Read {\n     /// This method is unsafe because a `Read`er could otherwise return a\n     /// non-zeroing `Initializer` from another `Read` type without an `unsafe`\n     /// block.\n-    ///\n-    /// [`Initializer::nop()`]: ../../std/io/struct.Initializer.html#method.nop\n-    /// [`Initializer`]: ../../std/io/struct.Initializer.html\n     #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n@@ -652,10 +634,9 @@ pub trait Read {\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`read()`]: trait.Read.html#tymethod.read\n-    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`File`]: ../fs/struct.File.html\n+    /// [`read()`]: Read::read\n+    /// [`Ok(0)`]: Ok\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -675,7 +656,7 @@ pub trait Read {\n     /// (See also the [`std::fs::read`] convenience function for reading from a\n     /// file.)\n     ///\n-    /// [`std::fs::read`]: ../fs/fn.read.html\n+    /// [`std::fs::read`]: crate::fs::read\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n         read_to_end(self, buf)\n@@ -693,13 +674,13 @@ pub trait Read {\n     ///\n     /// See [`read_to_end`][readtoend] for other error semantics.\n     ///\n-    /// [readtoend]: #method.read_to_end\n+    /// [readtoend]: Self::read_to_end\n     ///\n     /// # Examples\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [file]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -718,7 +699,7 @@ pub trait Read {\n     /// (See also the [`std::fs::read_to_string`] convenience function for\n     /// reading from a file.)\n     ///\n-    /// [`std::fs::read_to_string`]: ../fs/fn.read_to_string.html\n+    /// [`std::fs::read_to_string`]: crate::fs::read_to_string\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n         // Note that we do *not* call `.read_to_end()` here. We are passing\n@@ -767,9 +748,7 @@ pub trait Read {\n     /// [`File`]s implement `Read`:\n     ///\n     /// [`read`]: Read::read\n-    /// [`File`]: ../fs/struct.File.html\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`ErrorKind::UnexpectedEof`]: ../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -814,7 +793,7 @@ pub trait Read {\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [file]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -858,14 +837,10 @@ pub trait Read {\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n-    /// [`Iterator`]: ../../std/iter/trait.Iterator.html\n-    /// [`Result`]: ../../std/result/enum.Result.html\n-    /// [`io::Error`]: ../../std/io/struct.Error.html\n-    /// [`u8`]: ../../std/primitive.u8.html\n-    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [file]: crate::fs::File\n+    /// [`Iterator`]: crate::iter::Iterator\n+    /// [`Result`]: crate::result::Result\n+    /// [`io::Error`]: self::Error\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -899,7 +874,7 @@ pub trait Read {\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [file]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -938,9 +913,9 @@ pub trait Read {\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`File`]: ../fs/struct.File.html\n-    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`read()`]: trait.Read.html#tymethod.read\n+    /// [`File`]: crate::fs::File\n+    /// [`Ok(0)`]: Ok\n+    /// [`read()`]: Read::read\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -1236,8 +1211,8 @@ impl Initializer {\n /// throughout [`std::io`] take and provide types which implement the `Write`\n /// trait.\n ///\n-/// [`write`]: #tymethod.write\n-/// [`flush`]: #tymethod.flush\n+/// [`write`]: Self::write\n+/// [`flush`]: Self::flush\n /// [`std::io`]: index.html\n ///\n /// # Examples\n@@ -1263,7 +1238,7 @@ impl Initializer {\n /// The trait also provides convenience methods like [`write_all`], which calls\n /// `write` in a loop until its entire input has been written.\n ///\n-/// [`write_all`]: #method.write_all\n+/// [`write_all`]: Self::write_all\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(spotlight)]\n pub trait Write {\n@@ -1295,10 +1270,6 @@ pub trait Write {\n     /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the\n     /// write operation should be retried if there is nothing else to do.\n     ///\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`Ok(n)`]:  ../../std/result/enum.Result.html#variant.Ok\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -1384,8 +1355,7 @@ pub trait Write {\n     /// This function will return the first error of\n     /// non-[`ErrorKind::Interrupted`] kind that [`write`] returns.\n     ///\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`write`]: #tymethod.write\n+    /// [`write`]: Self::write\n     ///\n     /// # Examples\n     ///\n@@ -1426,8 +1396,7 @@ pub trait Write {\n     ///\n     /// If the buffer contains no data, this will never call [`write_vectored`].\n     ///\n-    /// [`write_vectored`]: #method.write_vectored\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`write_vectored`]: Self::write_vectored\n     ///\n     /// # Notes\n     ///\n@@ -1483,19 +1452,16 @@ pub trait Write {\n     /// encountered.\n     ///\n     /// This method is primarily used to interface with the\n-    /// [`format_args!`][formatargs] macro, but it is rare that this should\n-    /// explicitly be called. The [`write!`][write] macro should be favored to\n+    /// [`format_args!()`] macro, but it is rare that this should\n+    /// explicitly be called. The [`write!()`] macro should be favored to\n     /// invoke this method instead.\n     ///\n-    /// [formatargs]: ../macro.format_args.html\n-    /// [write]: ../macro.write.html\n-    ///\n     /// This function internally uses the [`write_all`][writeall] method on\n     /// this trait and hence will continuously write data so long as no errors\n     /// are received. This also means that partial writes are not indicated in\n     /// this signature.\n     ///\n-    /// [writeall]: #method.write_all\n+    /// [writeall]: Self::write_all\n     ///\n     /// # Errors\n     ///\n@@ -1592,7 +1558,7 @@ pub trait Write {\n ///\n /// [`File`][file]s implement `Seek`:\n ///\n-/// [file]: ../fs/struct.File.html\n+/// [file]: crate::fs::File\n ///\n /// ```no_run\n /// use std::io;\n@@ -1792,9 +1758,9 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> R\n /// [`BufReader`] to the rescue!\n ///\n /// [`BufReader`]: struct.BufReader.html\n-/// [`File`]: ../fs/struct.File.html\n-/// [`read_line`]: #method.read_line\n-/// [`lines`]: #method.lines\n+/// [`File`]: crate::fs::File\n+/// [`read_line`]: Self::read_line\n+/// [`lines`]: Self::lines\n /// [`Read`]: trait.Read.html\n ///\n /// ```no_run\n@@ -1826,7 +1792,7 @@ pub trait BufRead: Read {\n     /// be called with the number of bytes that are consumed from this buffer to\n     /// ensure that the bytes are never returned twice.\n     ///\n-    /// [`consume`]: #tymethod.consume\n+    /// [`consume`]: Self::consume\n     ///\n     /// An empty buffer returned indicates that the stream has reached EOF.\n     ///\n@@ -1876,7 +1842,7 @@ pub trait BufRead: Read {\n     /// Since `consume()` is meant to be used with [`fill_buf`],\n     /// that method's example includes an example of `consume()`.\n     ///\n-    /// [`fill_buf`]: #tymethod.fill_buf\n+    /// [`fill_buf`]: Self::fill_buf\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn consume(&mut self, amt: usize);\n \n@@ -1900,7 +1866,7 @@ pub trait BufRead: Read {\n     /// If an I/O error is encountered then all bytes read so far will be\n     /// present in `buf` and its length will have been adjusted appropriately.\n     ///\n-    /// [`fill_buf`]: #tymethod.fill_buf\n+    /// [`fill_buf`]: Self::fill_buf\n     /// [`ErrorKind::Interrupted`]: enum.ErrorKind.html#variant.Interrupted\n     ///\n     /// # Examples\n@@ -1965,7 +1931,7 @@ pub trait BufRead: Read {\n     /// error is encountered then `buf` may contain some bytes already read in\n     /// the event that all data read so far was valid UTF-8.\n     ///\n-    /// [`read_until`]: #method.read_until\n+    /// [`read_until`]: Self::read_until\n     ///\n     /// # Examples\n     ///\n@@ -2018,9 +1984,9 @@ pub trait BufRead: Read {\n     /// This function will yield errors whenever [`read_until`] would have\n     /// also yielded an error.\n     ///\n-    /// [`io::Result`]: type.Result.html\n-    /// [`Vec<u8>`]: ../vec/struct.Vec.html\n-    /// [`read_until`]: #method.read_until\n+    /// [`io::Result`]: self::Result\n+    /// [`Vec<u8>`]: crate::vec::Vec\n+    /// [`read_until`]: Self::read_until\n     ///\n     /// # Examples\n     ///\n@@ -2055,17 +2021,14 @@ pub trait BufRead: Read {\n     /// [`io::Result`]`<`[`String`]`>`. Each string returned will *not* have a newline\n     /// byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.\n     ///\n-    /// [`io::Result`]: type.Result.html\n-    /// [`String`]: ../string/struct.String.html\n+    /// [`io::Result`]: self::Result\n     ///\n     /// # Examples\n     ///\n     /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n     /// this example, we use [`Cursor`] to iterate over all the lines in a byte\n     /// slice.\n     ///\n-    /// [`Cursor`]: struct.Cursor.html\n-    ///\n     /// ```\n     /// use std::io::{self, BufRead};\n     ///\n@@ -2256,8 +2219,6 @@ impl<T> Take<T> {\n     /// This instance may reach `EOF` after reading fewer bytes than indicated by\n     /// this method if the underlying [`Read`] instance reaches EOF.\n     ///\n-    /// [`Read`]: ../../std/io/trait.Read.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run"}, {"sha": "d985f10ccb486489fe65680c495e9127b851dbd7", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 180, "deletions": 3, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1497,11 +1497,188 @@ mod super_keyword {}\n \n #[doc(keyword = \"trait\")]\n //\n-/// A common interface for a class of types.\n+/// A common interface for a group of types.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// A `trait` is like an interface that data types can implement. When a type\n+/// implements a trait it can be treated abstractly as that trait using generics\n+/// or trait objects.\n ///\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// Traits can be made up of three varieties of associated items:\n+///\n+/// - functions and methods\n+/// - types\n+/// - constants\n+///\n+/// Traits may also contain additional type parameters. Those type parameters\n+/// or the trait itself can be constrained by other traits.\n+///\n+/// Traits can serve as markers or carry other logical semantics that\n+/// aren't expressed through their items. When a type implements that\n+/// trait it is promising to uphold its contract. [`Send`] and [`Sync`] are two\n+/// such marker traits present in the standard library.\n+///\n+/// See the [Reference][Ref-Traits] for a lot more information on traits.\n+///\n+/// # Examples\n+///\n+/// Traits are declared using the `trait` keyword. Types can implement them\n+/// using [`impl`] `Trait` [`for`] `Type`:\n+///\n+/// ```rust\n+/// trait Zero {\n+///     const ZERO: Self;\n+///     fn is_zero(&self) -> bool;\n+/// }\n+///\n+/// impl Zero for i32 {\n+///     const ZERO: Self = 0;\n+///\n+///     fn is_zero(&self) -> bool {\n+///         *self == Self::ZERO\n+///     }\n+/// }\n+///\n+/// assert_eq!(i32::ZERO, 0);\n+/// assert!(i32::ZERO.is_zero());\n+/// assert!(!4.is_zero());\n+/// ```\n+///\n+/// With an associated type:\n+///\n+/// ```rust\n+/// trait Builder {\n+///     type Built;\n+///\n+///     fn build(&self) -> Self::Built;\n+/// }\n+/// ```\n+///\n+/// Traits can be generic, with constraints or without:\n+///\n+/// ```rust\n+/// trait MaybeFrom<T> {\n+///     fn maybe_from(value: T) -> Option<Self>\n+///     where\n+///         Self: Sized;\n+/// }\n+/// ```\n+///\n+/// Traits can build upon the requirements of other traits. In the example\n+/// below `Iterator` is a **supertrait** and `ThreeIterator` is a **subtrait**:\n+///\n+/// ```rust\n+/// trait ThreeIterator: std::iter::Iterator {\n+///     fn next_three(&mut self) -> Option<[Self::Item; 3]>;\n+/// }\n+/// ```\n+///\n+/// Traits can be used in functions, as parameters:\n+///\n+/// ```rust\n+/// # #![allow(dead_code)]\n+/// fn debug_iter<I: Iterator>(it: I) where I::Item: std::fmt::Debug {\n+///     for elem in it {\n+///         println!(\"{:#?}\", elem);\n+///     }\n+/// }\n+///\n+/// // u8_len_1, u8_len_2 and u8_len_3 are equivalent\n+///\n+/// fn u8_len_1(val: impl Into<Vec<u8>>) -> usize {\n+///     val.into().len()\n+/// }\n+///\n+/// fn u8_len_2<T: Into<Vec<u8>>>(val: T) -> usize {\n+///     val.into().len()\n+/// }\n+///\n+/// fn u8_len_3<T>(val: T) -> usize\n+/// where\n+///     T: Into<Vec<u8>>,\n+/// {\n+///     val.into().len()\n+/// }\n+/// ```\n+///\n+/// Or as return types:\n+///\n+/// ```rust\n+/// # #![allow(dead_code)]\n+/// fn from_zero_to(v: u8) -> impl Iterator<Item = u8> {\n+///     (0..v).into_iter()\n+/// }\n+/// ```\n+///\n+/// The use of the [`impl`] keyword in this position allows the function writer\n+/// to hide the concrete type as an implementation detail which can change\n+/// without breaking user's code.\n+///\n+/// # Trait objects\n+///\n+/// A *trait object* is an opaque value of another type that implements a set of\n+/// traits. A trait object implements all specified traits as well as their\n+/// supertraits (if any).\n+///\n+/// The syntax is the following: `dyn BaseTrait + AutoTrait1 + ... AutoTraitN`.\n+/// Only one `BaseTrait` can be used so this will not compile:\n+///\n+/// ```rust,compile_fail,E0225\n+/// trait A {}\n+/// trait B {}\n+///\n+/// let _: Box<dyn A + B>;\n+/// ```\n+///\n+/// Neither will this, which is a syntax error:\n+///\n+/// ```rust,compile_fail\n+/// trait A {}\n+/// trait B {}\n+///\n+/// let _: Box<dyn A + dyn B>;\n+/// ```\n+///\n+/// On the other hand, this is correct:\n+///\n+/// ```rust\n+/// trait A {}\n+///\n+/// let _: Box<dyn A + Send + Sync>;\n+/// ```\n+///\n+/// The [Reference][Ref-Trait-Objects] has more information about trait objects,\n+/// their limitations and the differences between editions.\n+///\n+/// # Unsafe traits\n+///\n+/// Some traits may be unsafe to implement. Using the [`unsafe`] keyword in\n+/// front of the trait's declaration is used to mark this:\n+///\n+/// ```rust\n+/// unsafe trait UnsafeTrait {}\n+///\n+/// unsafe impl UnsafeTrait for i32 {}\n+/// ```\n+///\n+/// # Differences between the 2015 and 2018 editions\n+///\n+/// In the 2015 edition parameters pattern where not needed for traits:\n+///\n+/// ```rust,edition2015\n+/// trait Tr {\n+///     fn f(i32);\n+/// }\n+/// ```\n+///\n+/// This behavior is no longer valid in edition 2018.\n+///\n+/// [`for`]: keyword.for.html\n+/// [`impl`]: keyword.impl.html\n+/// [`unsafe`]: keyword.unsafe.html\n+/// [`Send`]: marker/trait.Send.html\n+/// [`Sync`]: marker/trait.Sync.html\n+/// [Ref-Traits]: ../reference/items/traits.html\n+/// [Ref-Trait-Objects]: ../reference/types/trait-object.html\n mod trait_keyword {}\n \n #[doc(keyword = \"true\")]"}, {"sha": "11b8f953be46008c0a8cd05c3e62da77e8a4ea03", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -305,6 +305,7 @@\n #![feature(ptr_internals)]\n #![feature(raw)]\n #![feature(raw_ref_macros)]\n+#![feature(ready_macro)]\n #![feature(renamed_spin_loop)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]"}, {"sha": "0f349dfa3021611fdb3513aa9b87b2fd9f912bd1", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -84,12 +84,12 @@ impl Command {\n                 Ok(0) => return Ok((p, ours)),\n                 Ok(8) => {\n                     let (errno, footer) = bytes.split_at(4);\n-                    assert!(\n-                        combine(CLOEXEC_MSG_FOOTER) == combine(footer.try_into().unwrap()),\n+                    assert_eq!(\n+                        CLOEXEC_MSG_FOOTER, footer,\n                         \"Validation on the CLOEXEC pipe failed: {:?}\",\n                         bytes\n                     );\n-                    let errno = combine(errno.try_into().unwrap());\n+                    let errno = i32::from_be_bytes(errno.try_into().unwrap());\n                     assert!(p.wait().is_ok(), \"wait() should either return Ok or panic\");\n                     return Err(Error::from_raw_os_error(errno));\n                 }\n@@ -105,10 +105,6 @@ impl Command {\n                 }\n             }\n         }\n-\n-        fn combine(arr: [u8; 4]) -> i32 {\n-            i32::from_be_bytes(arr)\n-        }\n     }\n \n     pub fn exec(&mut self, default: Stdio) -> io::Error {"}, {"sha": "c6c4cdb5562f87a2b347d9f3721e6410227a1ac9", "filename": "src/rustllvm/CoverageMappingWrapper.cpp", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Frustllvm%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Frustllvm%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FCoverageMappingWrapper.cpp?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,115 @@\n+#include \"rustllvm.h\"\n+#include \"llvm/ProfileData/Coverage/CoverageMapping.h\"\n+#include \"llvm/ProfileData/Coverage/CoverageMappingWriter.h\"\n+#include \"llvm/ProfileData/InstrProf.h\"\n+#include \"llvm/ADT/ArrayRef.h\"\n+\n+#include <iostream>\n+\n+using namespace llvm;\n+\n+extern \"C\" SmallVectorTemplateBase<coverage::CounterExpression>\n+    *LLVMRustCoverageSmallVectorCounterExpressionCreate() {\n+  return new SmallVector<coverage::CounterExpression, 32>();\n+}\n+\n+extern \"C\" void LLVMRustCoverageSmallVectorCounterExpressionDispose(\n+    SmallVectorTemplateBase<coverage::CounterExpression> *Vector) {\n+  delete Vector;\n+}\n+\n+extern \"C\" void LLVMRustCoverageSmallVectorCounterExpressionAdd(\n+    SmallVectorTemplateBase<coverage::CounterExpression> *Expressions,\n+    coverage::CounterExpression::ExprKind Kind,\n+    unsigned LeftIndex,\n+    unsigned RightIndex) {\n+  auto LHS = coverage::Counter::getCounter(LeftIndex);\n+  auto RHS = coverage::Counter::getCounter(RightIndex);\n+  Expressions->push_back(coverage::CounterExpression { Kind, LHS, RHS });\n+}\n+\n+extern \"C\" SmallVectorTemplateBase<coverage::CounterMappingRegion>\n+    *LLVMRustCoverageSmallVectorCounterMappingRegionCreate() {\n+  return new SmallVector<coverage::CounterMappingRegion, 32>();\n+}\n+\n+extern \"C\" void LLVMRustCoverageSmallVectorCounterMappingRegionDispose(\n+    SmallVectorTemplateBase<coverage::CounterMappingRegion> *Vector) {\n+  delete Vector;\n+}\n+\n+extern \"C\" void LLVMRustCoverageSmallVectorCounterMappingRegionAdd(\n+    SmallVectorTemplateBase<coverage::CounterMappingRegion> *MappingRegions,\n+    unsigned Index,\n+    unsigned FileID,\n+    unsigned LineStart,\n+    unsigned ColumnStart,\n+    unsigned LineEnd,\n+    unsigned ColumnEnd) {\n+  auto Counter = coverage::Counter::getCounter(Index);\n+  MappingRegions->push_back(coverage::CounterMappingRegion::makeRegion(\n+           Counter, FileID, LineStart,\n+           ColumnStart, LineEnd, ColumnEnd));\n+\n+  // FIXME(richkadel): As applicable, implement additional CounterMappingRegion types using the\n+  // static method alternatives to `coverage::CounterMappingRegion::makeRegion`:\n+  //\n+  //   makeExpansion(unsigned FileID, unsigned ExpandedFileID, unsigned LineStart,\n+  //                 unsigned ColumnStart, unsigned LineEnd, unsigned ColumnEnd) {\n+  //   makeSkipped(unsigned FileID, unsigned LineStart, unsigned ColumnStart,\n+  //               unsigned LineEnd, unsigned ColumnEnd) {\n+  //   makeGapRegion(Counter Count, unsigned FileID, unsigned LineStart,\n+  //                 unsigned ColumnStart, unsigned LineEnd, unsigned ColumnEnd) {\n+}\n+\n+extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n+    const char* const Filenames[],\n+    size_t FilenamesLen,\n+    RustStringRef BufferOut) {\n+  SmallVector<StringRef,32> FilenameRefs;\n+  for (size_t i = 0; i < FilenamesLen; i++) {\n+    FilenameRefs.push_back(StringRef(Filenames[i]));\n+  }\n+  auto FilenamesWriter = coverage::CoverageFilenamesSectionWriter(\n+    makeArrayRef(FilenameRefs));\n+  RawRustStringOstream OS(BufferOut);\n+  FilenamesWriter.write(OS);\n+}\n+\n+extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n+    const unsigned *VirtualFileMappingIDs,\n+    unsigned NumVirtualFileMappingIDs,\n+    const SmallVectorImpl<coverage::CounterExpression> *Expressions,\n+    SmallVectorImpl<coverage::CounterMappingRegion> *MappingRegions,\n+    RustStringRef BufferOut) {\n+  auto CoverageMappingWriter = coverage::CoverageMappingWriter(\n+    makeArrayRef(VirtualFileMappingIDs, NumVirtualFileMappingIDs),\n+    makeArrayRef(*Expressions),\n+    MutableArrayRef<coverage::CounterMappingRegion> { *MappingRegions });\n+  RawRustStringOstream OS(BufferOut);\n+  CoverageMappingWriter.write(OS);\n+}\n+\n+extern \"C\" uint64_t LLVMRustCoverageComputeHash(const char *Name) {\n+  StringRef NameRef(Name);\n+  return IndexedInstrProf::ComputeHash(NameRef);\n+}\n+\n+extern \"C\" void LLVMRustCoverageWriteSectionNameToString(LLVMModuleRef M,\n+                                                         RustStringRef Str) {\n+  Triple TargetTriple(unwrap(M)->getTargetTriple());\n+  auto name = getInstrProfSectionName(IPSK_covmap,\n+                                      TargetTriple.getObjectFormat());\n+  RawRustStringOstream OS(Str);\n+  OS << name;\n+}\n+\n+extern \"C\" void LLVMRustCoverageWriteMappingVarNameToString(RustStringRef Str) {\n+  auto name = getCoverageMappingVarName();\n+  RawRustStringOstream OS(Str);\n+  OS << name;\n+}\n+\n+extern \"C\" uint32_t LLVMRustCoverageMappingVersion() {\n+  return coverage::CovMapVersion::CurrentVersion;\n+}"}, {"sha": "667bf4a2ded37e7931df99735435f05eef8cbda0", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1395,7 +1395,7 @@ extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n       FTy, Callee, makeArrayRef(unwrap(Args), NumArgs), Bundles));\n }\n \n-extern \"C\" LLVMValueRef LLVMRustGetInstrprofIncrementIntrinsic(LLVMModuleRef M) {\n+extern \"C\" LLVMValueRef LLVMRustGetInstrProfIncrementIntrinsic(LLVMModuleRef M) {\n   return wrap(llvm::Intrinsic::getDeclaration(unwrap(M),\n               (llvm::Intrinsic::ID)llvm::Intrinsic::instrprof_increment));\n }"}, {"sha": "57b8664d3b6058d1050790354cb0a5fc89cc16ca", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -3,6 +3,7 @@\n #include \"llvm-c/Object.h\"\n #include \"llvm/ADT/ArrayRef.h\"\n #include \"llvm/ADT/DenseSet.h\"\n+#include \"llvm/ADT/SmallVector.h\"\n #include \"llvm/ADT/Triple.h\"\n #include \"llvm/Analysis/Lint.h\"\n #include \"llvm/Analysis/Passes.h\""}, {"sha": "d3cb5aaaeba89095fed6fbae4ac5cdfc7427d8ac", "filename": "src/test/compile-fail/empty-extern-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1,4 +1,4 @@\n // compile-flags: --extern std=\n-// error-pattern: can't find crate for `std`\n+// error-pattern: extern location for std does not exist\n \n fn main() {}"}, {"sha": "e7fef4622b1c6cb09e791cd3586dea2049d5978c", "filename": "src/test/mir-opt/instrument_coverage/rustc.bar.InstrumentCoverage.diff", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -3,34 +3,40 @@\n   \n   fn bar() -> bool {\n       let mut _0: bool;                    // return place in scope 0 at $DIR/instrument_coverage.rs:18:13: 18:17\n-+     let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++     let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n   \n       bb0: {\n-+         StorageLive(_1);                 // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n-+         _1 = const std::intrinsics::count_code_region(const 0_u32, const 484_u32, const 513_u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++         StorageLive(_1);                 // scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n++         _1 = const std::intrinsics::count_code_region(const 10208505205182607101_u64, const 0_u32, const 501_u32, const 513_u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:18: 18:18\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: u64\n++                                          // + val: Value(Scalar(0x8dabe565aaa2aefd))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n++                                          // + literal: Const { ty: u64, val: Value(Scalar(0x8dabe565aaa2aefd)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x000001e4))\n++                                          // + val: Value(Scalar(0x000001f5))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001e4)) }\n++                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001f5)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000201))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + span: $DIR/instrument_coverage.rs:18:18: 18:18\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000201)) }\n +     }\n + "}, {"sha": "51378c216da641b9d2958a6def88f14c62a971ed", "filename": "src/test/mir-opt/instrument_coverage/rustc.main.InstrumentCoverage.diff", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -6,35 +6,41 @@\n       let mut _1: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n       let mut _2: bool;                    // in scope 0 at $DIR/instrument_coverage.rs:11:12: 11:17\n       let mut _3: !;                       // in scope 0 at $DIR/instrument_coverage.rs:11:18: 13:10\n-+     let mut _4: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++     let mut _4: ();                      // in scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n   \n       bb0: {\n -         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n-+         StorageLive(_4);                 // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n-+         _4 = const std::intrinsics::count_code_region(const 0_u32, const 387_u32, const 465_u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++         StorageLive(_4);                 // scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n++         _4 = const std::intrinsics::count_code_region(const 16004455475339839479_u64, const 0_u32, const 397_u32, const 465_u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:11: 9:11\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // ty::Const\n++                                          // + ty: u64\n++                                          // + val: Value(Scalar(0xde1b3f75a72fc7f7))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n++                                          // + literal: Const { ty: u64, val: Value(Scalar(0xde1b3f75a72fc7f7)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n-+                                          // + val: Value(Scalar(0x00000183))\n++                                          // + val: Value(Scalar(0x0000018d))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n-+                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000183)) }\n++                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x0000018d)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x000001d1))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + span: $DIR/instrument_coverage.rs:9:11: 9:11\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001d1)) }\n       }\n   "}, {"sha": "df47305b547a82e7070dd9f126b65b68e1ea1ef8", "filename": "src/test/run-make-fulldeps/instrument-coverage/Makefile", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2FMakefile?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,57 @@\n+# needs-profiler-support\n+# ignore-msvc\n+\n+# FIXME(richkadel): Debug the following problem, and reenable on Windows (by\n+# removing the `# ignore-msvc` directive above). The current implementation\n+# generates a segfault when running the instrumented `main` executable,\n+# after the `main` program code executes, but before the process terminates.\n+# This most likely points to a problem generating the LLVM \"main.profraw\"\n+# file.\n+\n+-include ../tools.mk\n+\n+# This test makes sure that LLVM coverage maps are genereated in LLVM IR.\n+\n+COMMON_FLAGS=-Zinstrument-coverage\n+\n+all:\n+\t# Compile the test program with instrumentation, and also generate LLVM IR\n+\t$(RUSTC) $(COMMON_FLAGS) main.rs\n+\n+\t# Run it in order to generate some profiling data,\n+\t# with `LLVM_PROFILE_FILE=<profdata_file>` environment variable set to\n+\t# output the coverage stats for this run.\n+\tLLVM_PROFILE_FILE=\"$(TMPDIR)\"/main.profraw \\\n+\t  $(call RUN,main)\n+\n+\t# Postprocess the profiling data so it can be used by the llvm-cov tool\n+\t\"$(LLVM_BIN_DIR)\"/llvm-profdata merge --sparse \\\n+\t  \"$(TMPDIR)\"/main.profraw \\\n+\t\t-o \"$(TMPDIR)\"/main.profdata\n+\n+\t# Generate a coverage report using `llvm-cov show`. The output ordering\n+\t# can be non-deterministic, so ignore the return status. If the test fails\n+\t# when comparing the JSON `export`, the `show` output may be useful when\n+\t# debugging.\n+\t\"$(LLVM_BIN_DIR)\"/llvm-cov show \\\n+\t  --Xdemangler=\"$(RUST_DEMANGLER)\" \\\n+\t  --show-line-counts-or-regions \\\n+\t  --instr-profile=\"$(TMPDIR)\"/main.profdata \\\n+\t\t$(call BIN,\"$(TMPDIR)\"/main) \\\n+\t\t> \"$(TMPDIR)\"/actual_show_coverage.txt\n+\n+\t# Compare the show coverage output\n+\t$(DIFF) typical_show_coverage.txt \"$(TMPDIR)\"/actual_show_coverage.txt || \\\n+\t  >&2 echo 'diff failed for `llvm-cov show` (might not be an error)'\n+\n+\t# Generate a coverage report in JSON, using `llvm-cov export`, and fail if\n+\t# there are differences from the expected output.\n+\t\"$(LLVM_BIN_DIR)\"/llvm-cov export \\\n+\t  --summary-only \\\n+\t  --instr-profile=\"$(TMPDIR)\"/main.profdata \\\n+\t\t$(call BIN,\"$(TMPDIR)\"/main) \\\n+\t\t| \"$(PYTHON)\" prettify_json.py \\\n+\t\t> \"$(TMPDIR)\"/actual_export_coverage.json\n+\n+\t# Check that the exported JSON coverage data matches what we expect\n+\t$(DIFF) expected_export_coverage.json \"$(TMPDIR)\"/actual_export_coverage.json"}, {"sha": "9d739a89114e2c37f359977e4ca0fb6e9e09df92", "filename": "src/test/run-make-fulldeps/instrument-coverage/expected_export_coverage.json", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fexpected_export_coverage.json", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fexpected_export_coverage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fexpected_export_coverage.json?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,59 @@\n+{\n+  \"data\": [\n+    {\n+      \"files\": [\n+        {\n+          \"filename\": \"main.rs\",\n+          \"summary\": {\n+            \"functions\": {\n+              \"count\": 7,\n+              \"covered\": 5,\n+              \"percent\": 71.42857142857143\n+            },\n+            \"instantiations\": {\n+              \"count\": 8,\n+              \"covered\": 6,\n+              \"percent\": 75\n+            },\n+            \"lines\": {\n+              \"count\": 30,\n+              \"covered\": 25,\n+              \"percent\": 83.33333333333334\n+            },\n+            \"regions\": {\n+              \"count\": 7,\n+              \"covered\": 5,\n+              \"notcovered\": 2,\n+              \"percent\": 71.42857142857143\n+            }\n+          }\n+        }\n+      ],\n+      \"totals\": {\n+        \"functions\": {\n+          \"count\": 7,\n+          \"covered\": 5,\n+          \"percent\": 71.42857142857143\n+        },\n+        \"instantiations\": {\n+          \"count\": 8,\n+          \"covered\": 6,\n+          \"percent\": 75\n+        },\n+        \"lines\": {\n+          \"count\": 30,\n+          \"covered\": 25,\n+          \"percent\": 83.33333333333334\n+        },\n+        \"regions\": {\n+          \"count\": 7,\n+          \"covered\": 5,\n+          \"notcovered\": 2,\n+          \"percent\": 71.42857142857143\n+        }\n+      }\n+    }\n+  ],\n+  \"type\": \"llvm.coverage.json.export\",\n+  \"version\": \"2.0.0\"\n+}"}, {"sha": "358c25677ae1d1561f528d395e563852e898f17f", "filename": "src/test/run-make-fulldeps/instrument-coverage/main.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fmain.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,38 @@\n+pub fn will_be_called() -> &'static str {\n+    let val = \"called\";\n+    println!(\"{}\", val);\n+    val\n+}\n+\n+pub fn will_not_be_called() -> bool {\n+    println!(\"should not have been called\");\n+    false\n+}\n+\n+pub fn print<T>(left: &str, value: T, right: &str)\n+where\n+    T: std::fmt::Display,\n+{\n+    println!(\"{}{}{}\", left, value, right);\n+}\n+\n+pub fn wrap_with<F, T>(inner: T, should_wrap: bool, wrapper: F)\n+where\n+    F: FnOnce(&T)\n+{\n+    if should_wrap {\n+        wrapper(&inner)\n+    }\n+}\n+\n+fn main() {\n+    let less = 1;\n+    let more = 100;\n+\n+    if less < more {\n+        wrap_with(will_be_called(), less < more, |inner| print(\" ***\", inner, \"*** \"));\n+        wrap_with(will_be_called(), more < less, |inner| print(\" ***\", inner, \"*** \"));\n+    } else {\n+        wrap_with(will_not_be_called(), true, |inner| print(\"wrapped result is: \", inner, \"\"));\n+    }\n+}"}, {"sha": "ed9279841f70e5929208cd14a21616cc6969876a", "filename": "src/test/run-make-fulldeps/instrument-coverage/prettify_json.py", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fprettify_json.py", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fprettify_json.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fprettify_json.py?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,9 @@\n+#!/usr/bin/env python\n+\n+import sys\n+import json\n+\n+# Try to decode line in order to ensure it is a valid JSON document\n+for line in sys.stdin:\n+    parsed = json.loads(line)\n+    print (json.dumps(parsed, indent=2, separators=(',', ': '), sort_keys=True))"}, {"sha": "9c593d0809d484ce3dfc1cf934148496b1ce8b07", "filename": "src/test/run-make-fulldeps/instrument-coverage/typical_show_coverage.txt", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftypical_show_coverage.txt", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftypical_show_coverage.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftypical_show_coverage.txt?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,55 @@\n+    1|      2|pub fn will_be_called() -> &'static str {\n+    2|      2|    let val = \"called\";\n+    3|      2|    println!(\"{}\", val);\n+    4|      2|    val\n+    5|      2|}\n+    6|       |\n+    7|      0|pub fn will_not_be_called() -> bool {\n+    8|      0|    println!(\"should not have been called\");\n+    9|      0|    false\n+   10|      0|}\n+   11|       |\n+   12|       |pub fn print<T>(left: &str, value: T, right: &str)\n+   13|       |where\n+   14|       |    T: std::fmt::Display,\n+   15|      1|{\n+   16|      1|    println!(\"{}{}{}\", left, value, right);\n+   17|      1|}\n+   18|       |\n+   19|       |pub fn wrap_with<F, T>(inner: T, should_wrap: bool, wrapper: F)\n+   20|       |where\n+   21|       |    F: FnOnce(&T)\n+   22|      2|{\n+   23|      2|    if should_wrap {\n+   24|      2|        wrapper(&inner)\n+   25|      2|    }\n+   26|      2|}\n+  ------------------\n+  | main[317d481089b8c8fe]::wrap_with::<main[317d481089b8c8fe]::main::{closure#0}, &str>:\n+  |   22|      1|{\n+  |   23|      1|    if should_wrap {\n+  |   24|      1|        wrapper(&inner)\n+  |   25|      1|    }\n+  |   26|      1|}\n+  ------------------\n+  | main[317d481089b8c8fe]::wrap_with::<main[317d481089b8c8fe]::main::{closure#1}, &str>:\n+  |   22|      1|{\n+  |   23|      1|    if should_wrap {\n+  |   24|      1|        wrapper(&inner)\n+  |   25|      1|    }\n+  |   26|      1|}\n+  ------------------\n+   27|       |\n+   28|      1|fn main() {\n+   29|      1|    let less = 1;\n+   30|      1|    let more = 100;\n+   31|      1|\n+   32|      1|    if less < more {\n+   33|      1|        wrap_with(will_be_called(), less < more, |inner| print(\" ***\", inner, \"*** \"));\n+   34|      1|        wrap_with(will_be_called(), more < less, |inner| print(\" ***\", inner, \"*** \"));\n+                                                                       ^0\n+   35|      1|    } else {\n+   36|      1|        wrap_with(will_not_be_called(), true, |inner| print(\"wrapped result is: \", inner, \"\"));\n+   37|      1|    }\n+   38|      1|}\n+"}, {"sha": "8b885f1dc6d58e387669c4eb83a83bd6e3eeecbc", "filename": "src/test/run-make-fulldeps/tools.mk", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -18,6 +18,9 @@ endif\n HTMLDOCCK := '$(PYTHON)' '$(S)/src/etc/htmldocck.py'\n CGREP := \"$(S)/src/etc/cat-and-grep.sh\"\n \n+# diff with common flags for multi-platform diffs against text output\n+DIFF := diff -u --strip-trailing-cr\n+\n # This is the name of the binary we will generate and run; use this\n # e.g. for `$(CC) -o $(RUN_BINFILE)`.\n RUN_BINFILE = $(TMPDIR)/$(1)"}, {"sha": "1fd514c6173290945a775d5873b56f72124593a8", "filename": "src/test/ui-fulldeps/macro-crate-rlib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1,10 +1,8 @@\n // aux-build:rlib-crate-test.rs\n-// ignore-tidy-linelength\n // ignore-cross-compile gives a different error message\n \n #![feature(plugin)]\n #![plugin(rlib_crate_test)]\n-//~^ ERROR: plugin `rlib_crate_test` only found in rlib format, but must be available in dylib format\n-//~| WARN use of deprecated attribute `plugin`: compiler plugins are deprecated\n+//~^ ERROR: plugin `rlib_crate_test` only found in rlib format, but must be available in dylib\n \n fn main() {}"}, {"sha": "7b31f28a26e7d3555411b265c23af8d0fd6fb50c", "filename": "src/test/ui-fulldeps/macro-crate-rlib.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.stderr?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1,16 +1,8 @@\n error[E0457]: plugin `rlib_crate_test` only found in rlib format, but must be available in dylib format\n-  --> $DIR/macro-crate-rlib.rs:6:11\n+  --> $DIR/macro-crate-rlib.rs:5:11\n    |\n LL | #![plugin(rlib_crate_test)]\n    |           ^^^^^^^^^^^^^^^\n \n-warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/macro-crate-rlib.rs:6:1\n-   |\n-LL | #![plugin(rlib_crate_test)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "ccc05fdf100e7872e8b195c594a77707425020c6", "filename": "src/test/ui/const-generics/issues/issue-62878.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,11 @@\n+#![feature(const_generics)] //~ WARN the feature `const_generics` is incomplete\n+\n+fn foo<const N: usize, const A: [u8; N]>() {}\n+//~^ ERROR the type of const parameters must not\n+\n+fn main() {\n+    foo::<_, {[1]}>();\n+    //~^ ERROR wrong number of const arguments\n+    //~| ERROR wrong number of type arguments\n+    //~| ERROR mismatched types\n+}"}, {"sha": "fe0990d8241fa6a7cbe414e73b29c98b97483f66", "filename": "src/test/ui/const-generics/issues/issue-62878.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.stderr?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,37 @@\n+error[E0770]: the type of const parameters must not depend on other generic parameters\n+  --> $DIR/issue-62878.rs:3:38\n+   |\n+LL | fn foo<const N: usize, const A: [u8; N]>() {}\n+   |                                      ^ the type must not depend on the parameter `N`\n+\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-62878.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n+\n+error[E0107]: wrong number of const arguments: expected 2, found 1\n+  --> $DIR/issue-62878.rs:7:5\n+   |\n+LL |     foo::<_, {[1]}>();\n+   |     ^^^^^^^^^^^^^^^ expected 2 const arguments\n+\n+error[E0107]: wrong number of type arguments: expected 0, found 1\n+  --> $DIR/issue-62878.rs:7:11\n+   |\n+LL |     foo::<_, {[1]}>();\n+   |           ^ unexpected type argument\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-62878.rs:7:15\n+   |\n+LL |     foo::<_, {[1]}>();\n+   |               ^^^ expected `usize`, found array `[{integer}; 1]`\n+\n+error: aborting due to 4 previous errors; 1 warning emitted\n+\n+Some errors have detailed explanations: E0107, E0308, E0770.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "cfed6e5deb99956864ba0a861a01cb0520e0b366", "filename": "src/test/ui/consts/const_unsafe_unreachable.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(const_fn)]\n+#![feature(const_unreachable_unchecked)]\n+\n+const unsafe fn foo(x: bool) -> bool {\n+    match x {\n+        true => true,\n+        false => std::hint::unreachable_unchecked(),\n+    }\n+}\n+\n+const BAR: bool = unsafe { foo(true) };\n+\n+fn main() {\n+  assert_eq!(BAR, true);\n+}"}, {"sha": "11920d852e02feaffc2c6d0d8c05f06399084d3a", "filename": "src/test/ui/consts/const_unsafe_unreachable_ub.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,20 @@\n+// build-fail\n+\n+#![feature(const_fn)]\n+#![feature(const_unreachable_unchecked)]\n+\n+const unsafe fn foo(x: bool) -> bool {\n+    match x {\n+        true => true,\n+        false => std::hint::unreachable_unchecked(),\n+    }\n+}\n+\n+#[warn(const_err)]\n+const BAR: bool = unsafe { foo(false) };\n+\n+fn main() {\n+  assert_eq!(BAR, true);\n+  //~^ ERROR E0080\n+  //~| ERROR erroneous constant\n+}"}, {"sha": "3ef8043a54d8877d503e9e8be65a55ef26223d31", "filename": "src/test/ui/consts/const_unsafe_unreachable_ub.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,44 @@\n+warning: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/hint.rs:LL:COL\n+   |\n+LL |     unsafe { intrinsics::unreachable() }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |              |\n+   |              entering unreachable code\n+   |              inside `std::hint::unreachable_unchecked` at $SRC_DIR/libcore/hint.rs:LL:COL\n+   |              inside `foo` at $DIR/const_unsafe_unreachable_ub.rs:9:18\n+   |              inside `BAR` at $DIR/const_unsafe_unreachable_ub.rs:14:28\n+   | \n+  ::: $DIR/const_unsafe_unreachable_ub.rs:14:1\n+   |\n+LL | const BAR: bool = unsafe { foo(false) };\n+   | ----------------------------------------\n+   |\n+note: the lint level is defined here\n+  --> $DIR/const_unsafe_unreachable_ub.rs:13:8\n+   |\n+LL | #[warn(const_err)]\n+   |        ^^^^^^^^^\n+\n+error[E0080]: evaluation of constant expression failed\n+  --> $DIR/const_unsafe_unreachable_ub.rs:17:3\n+   |\n+LL |   assert_eq!(BAR, true);\n+   |   ^^^^^^^^^^^---^^^^^^^^\n+   |              |\n+   |              referenced constant has errors\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: erroneous constant used\n+  --> $DIR/const_unsafe_unreachable_ub.rs:17:3\n+   |\n+LL |   assert_eq!(BAR, true);\n+   |   ^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "3ba124159e0002d41d448fa6bc885da5ffc118ad", "filename": "src/test/ui/extern/extern-prelude-no-speculative.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fextern%2Fextern-prelude-no-speculative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Fextern%2Fextern-prelude-no-speculative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-prelude-no-speculative.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n #![allow(unused_variables)]\n-// compile-flags: --extern LooksLikeExternCrate\n+// compile-flags: --extern LooksLikeExternCrate=/path/to/nowhere\n \n mod m {\n     pub struct LooksLikeExternCrate;"}, {"sha": "310545b92d5492d23f7d698790a9dfdcbe47001e", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -1,6 +1,5 @@\n #![feature(non_ascii_idents)]\n \n extern crate \u044c\u0430\u0433; //~ ERROR cannot load a crate with a non-ascii name `\u044c\u0430\u0433`\n-//~| ERROR can't find crate for `\u044c\u0430\u0433`\n \n fn main() {}"}, {"sha": "11108f2fb86789ce88b273be499e3a7c0a54b750", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-1.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -4,12 +4,5 @@ error: cannot load a crate with a non-ascii name `\u044c\u0430\u0433`\n LL | extern crate \u044c\u0430\u0433;\n    | ^^^^^^^^^^^^^^^^^\n \n-error[E0463]: can't find crate for `\u044c\u0430\u0433`\n-  --> $DIR/crate_name_nonascii_forbidden-1.rs:3:1\n-   |\n-LL | extern crate \u044c\u0430\u0433;\n-   | ^^^^^^^^^^^^^^^^^ can't find crate\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0463`."}, {"sha": "0249848b35ac0b12621a0b0739ba1e1dcd72f53f", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -3,7 +3,5 @@\n #![feature(non_ascii_idents)]\n \n use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz; //~  ERROR cannot load a crate with a non-ascii name `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n-                   //~| can't find crate for `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n-\n \n fn main() {}"}, {"sha": "8d3548ed33dcf8a70047df8c8cb1cbbe97382eab", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-2.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -4,12 +4,5 @@ error: cannot load a crate with a non-ascii name `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n LL | use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz;\n    |     ^^^^^^^^\n \n-error[E0463]: can't find crate for `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n-  --> $DIR/crate_name_nonascii_forbidden-2.rs:5:5\n-   |\n-LL | use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz;\n-   |     ^^^^^^^^ can't find crate\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0463`."}, {"sha": "5f7373be6594636540e3ba6845bbd5e8a4505cf8", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -186,6 +186,9 @@ pub struct Config {\n     /// The rustdoc executable.\n     pub rustdoc_path: Option<PathBuf>,\n \n+    /// The rust-demangler executable.\n+    pub rust_demangler_path: Option<PathBuf>,\n+\n     /// The Python executable to use for LLDB.\n     pub lldb_python: String,\n "}, {"sha": "07eba22c6eeb3a048f0a0322bfd492217ce389d2", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -53,6 +53,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         .reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\")\n         .reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\")\n         .optopt(\"\", \"rustdoc-path\", \"path to rustdoc to use for compiling\", \"PATH\")\n+        .optopt(\"\", \"rust-demangler-path\", \"path to rust-demangler to use in tests\", \"PATH\")\n         .reqopt(\"\", \"lldb-python\", \"path to python to use for doc tests\", \"PATH\")\n         .reqopt(\"\", \"docck-python\", \"path to python to use for doc tests\", \"PATH\")\n         .optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\")\n@@ -182,6 +183,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         run_lib_path: make_absolute(opt_path(matches, \"run-lib-path\")),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n         rustdoc_path: matches.opt_str(\"rustdoc-path\").map(PathBuf::from),\n+        rust_demangler_path: matches.opt_str(\"rust-demangler-path\").map(PathBuf::from),\n         lldb_python: matches.opt_str(\"lldb-python\").unwrap(),\n         docck_python: matches.opt_str(\"docck-python\").unwrap(),\n         valgrind_path: matches.opt_str(\"valgrind-path\"),\n@@ -246,6 +248,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"run_lib_path: {:?}\", config.run_lib_path));\n     logv(c, format!(\"rustc_path: {:?}\", config.rustc_path.display()));\n     logv(c, format!(\"rustdoc_path: {:?}\", config.rustdoc_path));\n+    logv(c, format!(\"rust_demangler_path: {:?}\", config.rust_demangler_path));\n     logv(c, format!(\"src_base: {:?}\", config.src_base.display()));\n     logv(c, format!(\"build_base: {:?}\", config.build_base.display()));\n     logv(c, format!(\"stage_id: {}\", config.stage_id));\n@@ -479,6 +482,8 @@ fn common_inputs_stamp(config: &Config) -> Stamp {\n         stamp.add_path(&rustdoc_path);\n         stamp.add_path(&rust_src_dir.join(\"src/etc/htmldocck.py\"));\n     }\n+    // FIXME(richkadel): Do I need to add an `if let Some(rust_demangler_path) contribution to the\n+    // stamp here as well?\n \n     // Compiletest itself.\n     stamp.add_dir(&rust_src_dir.join(\"src/tools/compiletest/\"));"}, {"sha": "f09f7621aa170ebc453b0508ee89f0fddaae0acf", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -2739,6 +2739,10 @@ impl<'test> TestCx<'test> {\n             cmd.env(\"RUSTDOC\", cwd.join(rustdoc));\n         }\n \n+        if let Some(ref rust_demangler) = self.config.rust_demangler_path {\n+            cmd.env(\"RUST_DEMANGLER\", cwd.join(rust_demangler));\n+        }\n+\n         if let Some(ref node) = self.config.nodejs {\n             cmd.env(\"NODE\", node);\n         }"}, {"sha": "194318d7a59b5ec5c9ed56fd8df5f6ae4310084a", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -23,6 +23,32 @@ use std::rc::Rc;\n \n use crate::Redirect::*;\n \n+// Add linkcheck exceptions here\n+// If at all possible you should use intra-doc links to avoid linkcheck issues. These\n+// are cases where that does not work\n+// [(generated_documentation_page, &[broken_links])]\n+const LINKCHECK_EXCEPTIONS: &[(&str, &[&str])] = &[\n+    // These are methods on slice, and `Self` does not work on primitive impls\n+    // in intra-doc links (primitive impls are weird)\n+    // https://github.com/rust-lang/rust/issues/62834 is necessary to be\n+    // able to link to slices\n+    (\n+        \"std/io/struct.IoSlice.html\",\n+        &[\n+            \"#method.as_mut_ptr\",\n+            \"#method.sort_by_key\",\n+            \"#method.make_ascii_uppercase\",\n+            \"#method.make_ascii_lowercase\",\n+        ],\n+    ),\n+    // These try to link to std::collections, but are defined in alloc\n+    // https://github.com/rust-lang/rust/issues/74481\n+    (\"std/collections/btree_map/struct.BTreeMap.html\", &[\"#insert-and-complex-keys\"]),\n+    (\"std/collections/btree_set/struct.BTreeSet.html\", &[\"#insert-and-complex-keys\"]),\n+    (\"alloc/collections/btree_map/struct.BTreeMap.html\", &[\"#insert-and-complex-keys\"]),\n+    (\"alloc/collections/btree_set/struct.BTreeSet.html\", &[\"#insert-and-complex-keys\"]),\n+];\n+\n macro_rules! t {\n     ($e:expr) => {\n         match $e {\n@@ -111,35 +137,20 @@ fn walk(cache: &mut Cache, root: &Path, dir: &Path, errors: &mut bool) {\n     }\n }\n \n+fn is_exception(file: &Path, link: &str) -> bool {\n+    if let Some(entry) = LINKCHECK_EXCEPTIONS.iter().find(|&(f, _)| file.ends_with(f)) {\n+        entry.1.contains(&link)\n+    } else {\n+        false\n+    }\n+}\n+\n fn check(cache: &mut Cache, root: &Path, file: &Path, errors: &mut bool) -> Option<PathBuf> {\n     // Ignore non-HTML files.\n     if file.extension().and_then(|s| s.to_str()) != Some(\"html\") {\n         return None;\n     }\n \n-    // Unfortunately we're not 100% full of valid links today to we need a few\n-    // exceptions to get this past `make check` today.\n-    // FIXME(#32129)\n-    if file.ends_with(\"std/io/struct.IoSlice.html\")\n-        || file.ends_with(\"std/string/struct.String.html\")\n-    {\n-        return None;\n-    }\n-    // FIXME(#32553)\n-    if file.ends_with(\"alloc/string/struct.String.html\") {\n-        return None;\n-    }\n-    // FIXME(#32130)\n-    if file.ends_with(\"alloc/collections/btree_map/struct.BTreeMap.html\")\n-        || file.ends_with(\"alloc/collections/btree_set/struct.BTreeSet.html\")\n-        || file.ends_with(\"std/collections/btree_map/struct.BTreeMap.html\")\n-        || file.ends_with(\"std/collections/btree_set/struct.BTreeSet.html\")\n-        || file.ends_with(\"std/collections/hash_map/struct.HashMap.html\")\n-        || file.ends_with(\"std/collections/hash_set/struct.HashSet.html\")\n-    {\n-        return None;\n-    }\n-\n     let res = load_file(cache, root, file, SkipRedirect);\n     let (pretty_file, contents) = match res {\n         Ok(res) => res,\n@@ -254,17 +265,20 @@ fn check(cache: &mut Cache, root: &Path, file: &Path, errors: &mut bool) -> Opti\n                 let entry = &mut cache.get_mut(&pretty_path).unwrap();\n                 entry.parse_ids(&pretty_path, &contents, errors);\n \n-                if !entry.ids.contains(*fragment) {\n+                if !entry.ids.contains(*fragment) && !is_exception(file, &format!(\"#{}\", fragment))\n+                {\n                     *errors = true;\n                     print!(\"{}:{}: broken link fragment \", pretty_file.display(), i + 1);\n                     println!(\"`#{}` pointing to `{}`\", fragment, pretty_path.display());\n                 };\n             }\n         } else {\n-            *errors = true;\n-            print!(\"{}:{}: broken link - \", pretty_file.display(), i + 1);\n             let pretty_path = path.strip_prefix(root).unwrap_or(&path);\n-            println!(\"{}\", pretty_path.display());\n+            if !is_exception(file, pretty_path.to_str().unwrap()) {\n+                *errors = true;\n+                print!(\"{}:{}: broken link - \", pretty_file.display(), i + 1);\n+                println!(\"{}\", pretty_path.display());\n+            }\n         }\n     });\n     Some(pretty_file)"}, {"sha": "0b8d974d2558adc9be243833e51733234ab662de", "filename": "src/tools/rust-demangler/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Frust-demangler%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Frust-demangler%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-demangler%2FCargo.toml?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rust-demangler\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[dependencies]\n+rustc-demangle = \"0.1\"\n+\n+[[bin]]\n+name = \"rust-demangler\"\n+path = \"main.rs\""}, {"sha": "a9f1011c450a9b67ac2d0b23aae2546dfd45d186", "filename": "src/tools/rust-demangler/main.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Frust-demangler%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Frust-demangler%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-demangler%2Fmain.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -0,0 +1,39 @@\n+//! Demangles rustc mangled names.\n+//!\n+//! This tool uses https://crates.io/crates/rustc-demangle to convert an input buffer of\n+//! newline-separated mangled names into their demangled translations.\n+//!\n+//! This tool can be leveraged by other applications that support third-party demanglers.\n+//! It takes a list of mangled names (one per line) on standard input, and prints a corresponding\n+//! list of demangled names. The tool is designed to support other programs that can leverage a\n+//! third-party demangler, such as `llvm-cov`, via the `-Xdemangler=<path-to-demangler>` option.\n+//!\n+//! To use `rust-demangler`, first build the tool with:\n+//!\n+//! ```shell\n+//! $ ./x.py build rust-demangler\n+//! ```\n+//!\n+//! Then, with `llvm-cov` for example, add the `-Xdemangler=...` option:\n+//!\n+//! ```shell\n+//! $ TARGET=\"${PWD}/build/x86_64-unknown-linux-gnu\"\n+//! $ \"${TARGET}\"/llvm/bin/llvm-cov show --Xdemangler=\"${TARGET}\"/stage0-tools-bin/rust-demangler \\\n+//!   --instr-profile=main.profdata ./main --show-line-counts-or-regions\n+//! ```\n+\n+use rustc_demangle::demangle;\n+use std::io::{self, Read, Write};\n+\n+fn main() -> io::Result<()> {\n+    let mut buffer = String::new();\n+    io::stdin().read_to_string(&mut buffer)?;\n+    let lines = buffer.lines();\n+    let mut demangled = Vec::new();\n+    for mangled in lines {\n+        demangled.push(demangle(mangled).to_string());\n+    }\n+    demangled.push(\"\".to_string());\n+    io::stdout().write_all(demangled.join(\"\\n\").as_bytes())?;\n+    Ok(())\n+}"}, {"sha": "51f135d37616125ad1b2e4a18aacf28631327c30", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471dd52d7710dcad5fec0cd731b836b02ba4a8f4/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=471dd52d7710dcad5fec0cd731b836b02ba4a8f4", "patch": "@@ -8,11 +8,11 @@ use std::path::Path;\n \n // A few of those error codes can't be tested but all the others can and *should* be tested!\n const EXEMPTED_FROM_TEST: &[&str] = &[\n-    \"E0183\", \"E0227\", \"E0279\", \"E0280\", \"E0311\", \"E0313\", \"E0314\", \"E0315\", \"E0377\", \"E0456\",\n-    \"E0461\", \"E0462\", \"E0464\", \"E0465\", \"E0472\", \"E0473\", \"E0474\", \"E0475\", \"E0476\", \"E0479\",\n-    \"E0480\", \"E0481\", \"E0482\", \"E0483\", \"E0484\", \"E0485\", \"E0486\", \"E0487\", \"E0488\", \"E0489\",\n-    \"E0514\", \"E0519\", \"E0523\", \"E0553\", \"E0554\", \"E0570\", \"E0629\", \"E0630\", \"E0640\", \"E0717\",\n-    \"E0727\", \"E0729\",\n+    \"E0183\", \"E0227\", \"E0279\", \"E0280\", \"E0311\", \"E0313\", \"E0314\", \"E0315\", \"E0377\", \"E0461\",\n+    \"E0462\", \"E0464\", \"E0465\", \"E0472\", \"E0473\", \"E0474\", \"E0475\", \"E0476\", \"E0479\", \"E0480\",\n+    \"E0481\", \"E0482\", \"E0483\", \"E0484\", \"E0485\", \"E0486\", \"E0487\", \"E0488\", \"E0489\", \"E0514\",\n+    \"E0519\", \"E0523\", \"E0553\", \"E0554\", \"E0570\", \"E0629\", \"E0630\", \"E0640\", \"E0717\", \"E0727\",\n+    \"E0729\",\n ];\n \n // Some error codes don't have any tests apparently..."}]}