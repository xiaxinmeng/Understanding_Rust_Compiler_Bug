{"sha": "aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139", "node_id": "C_kwDOAAsO6NoAKGFmZjZjYjAwODA0YWUwM2VlMDljOGE2YzNlMTVjZmExYWUyM2IxMzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-08T12:02:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-08T12:02:38Z"}, "message": "Auto merge of #14282 - Veykril:rustc_private-proc-macro, r=Veykril\n\nfix: Load proc-macros for rustc_private crates\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/13591\n\nVerified that this makes things work in the clippy repo (like resolving `sym` things for example)", "tree": {"sha": "52f1e0e6c45a9eb18eeb3936cf28c912e3a853b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52f1e0e6c45a9eb18eeb3936cf28c912e3a853b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139", "html_url": "https://github.com/rust-lang/rust/commit/aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9d97b644977830e28c1fe2bd99ccf93b023b89e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9d97b644977830e28c1fe2bd99ccf93b023b89e", "html_url": "https://github.com/rust-lang/rust/commit/a9d97b644977830e28c1fe2bd99ccf93b023b89e"}, {"sha": "c9786484c51657a291571763595327e77cc594e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9786484c51657a291571763595327e77cc594e3", "html_url": "https://github.com/rust-lang/rust/commit/c9786484c51657a291571763595327e77cc594e3"}], "stats": {"total": 120, "additions": 98, "deletions": 22}, "files": [{"sha": "6930ed83731b10adbdf828b0211b9ba6895efb70", "filename": "crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 77, "deletions": 3, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139", "patch": "@@ -15,13 +15,13 @@ use std::{\n \n use cargo_metadata::{camino::Utf8Path, Message};\n use la_arena::ArenaMap;\n-use paths::AbsPathBuf;\n+use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashMap;\n use semver::Version;\n use serde::Deserialize;\n \n use crate::{\n-    cfg_flag::CfgFlag, CargoConfig, CargoFeatures, CargoWorkspace, InvocationLocation,\n+    cfg_flag::CfgFlag, utf8_stdout, CargoConfig, CargoFeatures, CargoWorkspace, InvocationLocation,\n     InvocationStrategy, Package,\n };\n \n@@ -250,7 +250,7 @@ impl WorkspaceBuildScripts {\n \n         if tracing::enabled!(tracing::Level::INFO) {\n             for package in workspace.packages() {\n-                let package_build_data = &mut outputs[package];\n+                let package_build_data = &outputs[package];\n                 if !package_build_data.is_unchanged() {\n                     tracing::info!(\n                         \"{}: {:?}\",\n@@ -378,6 +378,80 @@ impl WorkspaceBuildScripts {\n     pub(crate) fn get_output(&self, idx: Package) -> Option<&BuildScriptOutput> {\n         self.outputs.get(idx)\n     }\n+\n+    pub(crate) fn rustc_crates(\n+        rustc: &CargoWorkspace,\n+        current_dir: &AbsPath,\n+        extra_env: &FxHashMap<String, String>,\n+    ) -> Self {\n+        let mut bs = WorkspaceBuildScripts::default();\n+        for p in rustc.packages() {\n+            bs.outputs.insert(p, BuildScriptOutput::default());\n+        }\n+        let res = (|| {\n+            let target_libdir = (|| {\n+                let mut cargo_config = Command::new(toolchain::cargo());\n+                cargo_config.envs(extra_env);\n+                cargo_config\n+                    .current_dir(current_dir)\n+                    .args([\"rustc\", \"-Z\", \"unstable-options\", \"--print\", \"target-libdir\"])\n+                    .env(\"RUSTC_BOOTSTRAP\", \"1\");\n+                if let Ok(it) = utf8_stdout(cargo_config) {\n+                    return Ok(it);\n+                }\n+                let mut cmd = Command::new(toolchain::rustc());\n+                cmd.envs(extra_env);\n+                cmd.args([\"--print\", \"target-libdir\"]);\n+                utf8_stdout(cmd)\n+            })()?;\n+\n+            let target_libdir = AbsPathBuf::try_from(PathBuf::from(target_libdir))\n+                .map_err(|_| anyhow::format_err!(\"target-libdir was not an absolute path\"))?;\n+            tracing::info!(\"Loading rustc proc-macro paths from {}\", target_libdir.display());\n+\n+            let proc_macro_dylibs: Vec<(String, AbsPathBuf)> = std::fs::read_dir(target_libdir)?\n+                .filter_map(|entry| {\n+                    let dir_entry = entry.ok()?;\n+                    if dir_entry.file_type().ok()?.is_file() {\n+                        let path = dir_entry.path();\n+                        tracing::info!(\"p{:?}\", path);\n+                        let extension = path.extension()?;\n+                        if extension == \"dll\" || extension == \"so\" {\n+                            let name = path.file_stem()?.to_str()?.split_once('-')?.0.to_owned();\n+                            let path = AbsPathBuf::try_from(path).ok()?;\n+                            return Some((name, path));\n+                        }\n+                    }\n+                    None\n+                })\n+                .collect();\n+            for p in rustc.packages() {\n+                if let Some((_, path)) =\n+                    proc_macro_dylibs.iter().find(|(name, _)| *name == rustc[p].name)\n+                {\n+                    bs.outputs[p].proc_macro_dylib_path = Some(path.clone());\n+                }\n+            }\n+\n+            if tracing::enabled!(tracing::Level::INFO) {\n+                for package in rustc.packages() {\n+                    let package_build_data = &bs.outputs[package];\n+                    if !package_build_data.is_unchanged() {\n+                        tracing::info!(\n+                            \"{}: {:?}\",\n+                            rustc[package].manifest.parent().display(),\n+                            package_build_data,\n+                        );\n+                    }\n+                }\n+            }\n+            Ok(())\n+        })();\n+        if let Err::<_, anyhow::Error>(e) = res {\n+            bs.error = Some(e.to_string());\n+        }\n+        bs\n+    }\n }\n \n // FIXME: Find a better way to know if it is a dylib."}, {"sha": "99578f425c86d2b5aacf4731ca83e905a4d3ea2f", "filename": "crates/project-model/src/sysroot.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139", "patch": "@@ -88,23 +88,17 @@ impl Sysroot {\n     }\n \n     pub fn discover_with_src_override(\n-        dir: &AbsPath,\n+        current_dir: &AbsPath,\n         extra_env: &FxHashMap<String, String>,\n         src: AbsPathBuf,\n     ) -> Result<Sysroot> {\n-        tracing::debug!(\"discovering sysroot for {}\", dir.display());\n-        let sysroot_dir = discover_sysroot_dir(dir, extra_env)?;\n+        tracing::debug!(\"discovering sysroot for {}\", current_dir.display());\n+        let sysroot_dir = discover_sysroot_dir(current_dir, extra_env)?;\n         Ok(Sysroot::load(sysroot_dir, src))\n     }\n \n-    pub fn discover_rustc(\n-        cargo_toml: &ManifestPath,\n-        extra_env: &FxHashMap<String, String>,\n-    ) -> Option<ManifestPath> {\n-        tracing::debug!(\"discovering rustc source for {}\", cargo_toml.display());\n-        let current_dir = cargo_toml.parent();\n-        let sysroot_dir = discover_sysroot_dir(current_dir, extra_env).ok()?;\n-        get_rustc_src(&sysroot_dir)\n+    pub fn discover_rustc(&self) -> Option<ManifestPath> {\n+        get_rustc_src(&self.root)\n     }\n \n     pub fn with_sysroot_dir(sysroot_dir: AbsPathBuf) -> Result<Sysroot> {"}, {"sha": "faa6816fdc203c95122310ce84cc9681b34b7c39", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=aff6cb00804ae03ee09c8a6c3e15cfa1ae23b139", "patch": "@@ -70,7 +70,7 @@ pub enum ProjectWorkspace {\n         cargo: CargoWorkspace,\n         build_scripts: WorkspaceBuildScripts,\n         sysroot: Option<Sysroot>,\n-        rustc: Option<CargoWorkspace>,\n+        rustc: Option<(CargoWorkspace, WorkspaceBuildScripts)>,\n         /// Holds cfg flags for the current target. We get those by running\n         /// `rustc --print cfg`.\n         ///\n@@ -116,7 +116,7 @@ impl fmt::Debug for ProjectWorkspace {\n                 .field(\"sysroot\", &sysroot.is_some())\n                 .field(\n                     \"n_rustc_compiler_crates\",\n-                    &rustc.as_ref().map_or(0, |rc| rc.packages().len()),\n+                    &rustc.as_ref().map_or(0, |(rc, _)| rc.packages().len()),\n                 )\n                 .field(\"n_rustc_cfg\", &rustc_cfg.len())\n                 .field(\"n_cfg_overrides\", &cfg_overrides.len())\n@@ -243,7 +243,7 @@ impl ProjectWorkspace {\n                 let rustc_dir = match &config.rustc_source {\n                     Some(RustcSource::Path(path)) => ManifestPath::try_from(path.clone()).ok(),\n                     Some(RustcSource::Discover) => {\n-                        Sysroot::discover_rustc(&cargo_toml, &config.extra_env)\n+                        sysroot.as_ref().and_then(Sysroot::discover_rustc)\n                     }\n                     None => None,\n                 };\n@@ -257,7 +257,15 @@ impl ProjectWorkspace {\n                             config,\n                             progress,\n                         ) {\n-                            Ok(meta) => Some(CargoWorkspace::new(meta)),\n+                            Ok(meta) => {\n+                                let workspace = CargoWorkspace::new(meta);\n+                                let buildscripts = WorkspaceBuildScripts::rustc_crates(\n+                                    &workspace,\n+                                    cargo_toml.parent(),\n+                                    &config.extra_env,\n+                                );\n+                                Some((workspace, buildscripts))\n+                            }\n                             Err(e) => {\n                                 tracing::error!(\n                                     %e,\n@@ -531,7 +539,7 @@ impl ProjectWorkspace {\n                         PackageRoot { is_local, include, exclude }\n                     })\n                     .chain(mk_sysroot(sysroot.as_ref(), Some(cargo.workspace_root())))\n-                    .chain(rustc.iter().flat_map(|rustc| {\n+                    .chain(rustc.iter().flat_map(|(rustc, _)| {\n                         rustc.packages().map(move |krate| PackageRoot {\n                             is_local: false,\n                             include: vec![rustc[krate].manifest.parent().to_path_buf()],\n@@ -559,7 +567,7 @@ impl ProjectWorkspace {\n                 sysroot_package_len + project.n_crates()\n             }\n             ProjectWorkspace::Cargo { cargo, sysroot, rustc, .. } => {\n-                let rustc_package_len = rustc.as_ref().map_or(0, |it| it.packages().len());\n+                let rustc_package_len = rustc.as_ref().map_or(0, |(it, _)| it.packages().len());\n                 let sysroot_package_len = sysroot.as_ref().map_or(0, |it| it.crates().len());\n                 cargo.packages().len() + sysroot_package_len + rustc_package_len\n             }\n@@ -778,7 +786,7 @@ fn project_json_to_crate_graph(\n fn cargo_to_crate_graph(\n     load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-    rustc: &Option<CargoWorkspace>,\n+    rustc: &Option<(CargoWorkspace, WorkspaceBuildScripts)>,\n     cargo: &CargoWorkspace,\n     sysroot: Option<&Sysroot>,\n     rustc_cfg: Vec<CfgFlag>,\n@@ -924,7 +932,7 @@ fn cargo_to_crate_graph(\n     if has_private {\n         // If the user provided a path to rustc sources, we add all the rustc_private crates\n         // and create dependencies on them for the crates which opt-in to that\n-        if let Some(rustc_workspace) = rustc {\n+        if let Some((rustc_workspace, build_scripts)) = rustc {\n             handle_rustc_crates(\n                 &mut crate_graph,\n                 &mut pkg_to_lib_crate,"}]}