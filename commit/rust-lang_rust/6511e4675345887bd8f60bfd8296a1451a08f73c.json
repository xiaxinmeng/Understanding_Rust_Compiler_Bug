{"sha": "6511e4675345887bd8f60bfd8296a1451a08f73c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MTFlNDY3NTM0NTg4N2JkOGY2MGJmZDgyOTZhMTQ1MWEwOGY3M2M=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-10-25T15:35:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-10-25T15:35:51Z"}, "message": "std: Optimize thread park/unpark implementation\n\nThis is an adaptation of alexcrichton/futures-rs#597 for the standard library.\nThe goal here is to avoid locking a mutex on the \"fast path\" for thread\npark/unpark where you're waking up a thread that isn't sleeping or otherwise\ntrying to park a thread that's already been notified. Mutex performance varies\nquite a bit across platforms so this should provide a nice consistent speed\nboost for the fast path of these functions.", "tree": {"sha": "35a52e833d3b227c38f3676f11a689f0feefdd83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35a52e833d3b227c38f3676f11a689f0feefdd83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6511e4675345887bd8f60bfd8296a1451a08f73c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6511e4675345887bd8f60bfd8296a1451a08f73c", "html_url": "https://github.com/rust-lang/rust/commit/6511e4675345887bd8f60bfd8296a1451a08f73c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6511e4675345887bd8f60bfd8296a1451a08f73c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2478052f88db8c8526ee2dc4a382da91eefc76c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2478052f88db8c8526ee2dc4a382da91eefc76c", "html_url": "https://github.com/rust-lang/rust/commit/b2478052f88db8c8526ee2dc4a382da91eefc76c"}], "stats": {"total": 87, "additions": 72, "deletions": 15}, "files": [{"sha": "28a33c7ec1465d04d70ae8e5624cab7b5099be86", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 72, "deletions": 15, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6511e4675345887bd8f60bfd8296a1451a08f73c/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6511e4675345887bd8f60bfd8296a1451a08f73c/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=6511e4675345887bd8f60bfd8296a1451a08f73c", "patch": "@@ -171,6 +171,8 @@ use panic;\n use panicking;\n use str;\n use sync::{Mutex, Condvar, Arc};\n+use sync::atomic::AtomicUsize;\n+use sync::atomic::Ordering::SeqCst;\n use sys::thread as imp;\n use sys_common::mutex;\n use sys_common::thread_info;\n@@ -694,6 +696,11 @@ pub fn sleep(dur: Duration) {\n     imp::Thread::sleep(dur)\n }\n \n+// constants for park/unpark\n+const EMPTY: usize = 0;\n+const PARKED: usize = 1;\n+const NOTIFIED: usize = 2;\n+\n /// Blocks unless or until the current thread's token is made available.\n ///\n /// A call to `park` does not guarantee that the thread will remain parked\n@@ -771,11 +778,27 @@ pub fn sleep(dur: Duration) {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn park() {\n     let thread = current();\n-    let mut guard = thread.inner.lock.lock().unwrap();\n-    while !*guard {\n-        guard = thread.inner.cvar.wait(guard).unwrap();\n+\n+    // If we were previously notified then we consume this notification and\n+    // return quickly.\n+    if thread.inner.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+        return\n+    }\n+\n+    // Otherwise we need to coordinate going to sleep\n+    let mut m = thread.inner.lock.lock().unwrap();\n+    match thread.inner.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+        Ok(_) => {}\n+        Err(NOTIFIED) => return, // notified after we locked\n+        Err(_) => panic!(\"inconsistent park state\"),\n+    }\n+    loop {\n+        m = thread.inner.cvar.wait(m).unwrap();\n+        match thread.inner.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst) {\n+            Ok(_) => return, // got a notification\n+            Err(_) => {} // spurious wakeup, go back to sleep\n+        }\n     }\n-    *guard = false;\n }\n \n /// Use [`park_timeout`].\n@@ -842,12 +865,30 @@ pub fn park_timeout_ms(ms: u32) {\n #[stable(feature = \"park_timeout\", since = \"1.4.0\")]\n pub fn park_timeout(dur: Duration) {\n     let thread = current();\n-    let mut guard = thread.inner.lock.lock().unwrap();\n-    if !*guard {\n-        let (g, _) = thread.inner.cvar.wait_timeout(guard, dur).unwrap();\n-        guard = g;\n+\n+    // Like `park` above we have a fast path for an already-notified thread, and\n+    // afterwards we start coordinating for a sleep.\n+    // return quickly.\n+    if thread.inner.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+        return\n+    }\n+    let m = thread.inner.lock.lock().unwrap();\n+    match thread.inner.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+        Ok(_) => {}\n+        Err(NOTIFIED) => return, // notified after we locked\n+        Err(_) => panic!(\"inconsistent park_timeout state\"),\n+    }\n+\n+    // Wait with a timeout, and if we spuriously wake up or otherwise wake up\n+    // from a notification we just want to unconditionally set the state back to\n+    // empty, either consuming a notification or un-flagging ourselves as\n+    // parked.\n+    let (_m, _result) = thread.inner.cvar.wait_timeout(m, dur).unwrap();\n+    match thread.inner.state.swap(EMPTY, SeqCst) {\n+        NOTIFIED => {} // got a notification, hurray!\n+        PARKED => {} // no notification, alas\n+        n => panic!(\"inconsistent park_timeout state: {}\", n),\n     }\n-    *guard = false;\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -914,7 +955,10 @@ impl ThreadId {\n struct Inner {\n     name: Option<CString>,      // Guaranteed to be UTF-8\n     id: ThreadId,\n-    lock: Mutex<bool>,          // true when there is a buffered unpark\n+\n+    // state for thread park/unpark\n+    state: AtomicUsize,\n+    lock: Mutex<()>,\n     cvar: Condvar,\n }\n \n@@ -958,7 +1002,8 @@ impl Thread {\n             inner: Arc::new(Inner {\n                 name: cname,\n                 id: ThreadId::new(),\n-                lock: Mutex::new(false),\n+                state: AtomicUsize::new(EMPTY),\n+                lock: Mutex::new(()),\n                 cvar: Condvar::new(),\n             })\n         }\n@@ -998,10 +1043,22 @@ impl Thread {\n     /// [park]: fn.park.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unpark(&self) {\n-        let mut guard = self.inner.lock.lock().unwrap();\n-        if !*guard {\n-            *guard = true;\n-            self.inner.cvar.notify_one();\n+        loop {\n+            match self.inner.state.compare_exchange(EMPTY, NOTIFIED, SeqCst, SeqCst) {\n+                Ok(_) => return, // no one was waiting\n+                Err(NOTIFIED) => return, // already unparked\n+                Err(PARKED) => {} // gotta go wake someone up\n+                _ => panic!(\"inconsistent state in unpark\"),\n+            }\n+\n+            // Coordinate wakeup through the mutex and a condvar notification\n+            let _lock = self.inner.lock.lock().unwrap();\n+            match self.inner.state.compare_exchange(PARKED, NOTIFIED, SeqCst, SeqCst) {\n+                Ok(_) => return self.inner.cvar.notify_one(),\n+                Err(NOTIFIED) => return, // a different thread unparked\n+                Err(EMPTY) => {} // parked thread went away, try again\n+                _ => panic!(\"inconsistent state in unpark\"),\n+            }\n         }\n     }\n "}]}