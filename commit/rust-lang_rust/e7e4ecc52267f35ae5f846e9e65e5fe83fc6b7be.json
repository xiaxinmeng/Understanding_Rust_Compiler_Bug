{"sha": "e7e4ecc52267f35ae5f846e9e65e5fe83fc6b7be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZTRlY2M1MjI2N2YzNWFlNWY4NDZlOWU2NWU1ZmU4M2ZjNmI3YmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-16T01:18:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-16T01:18:48Z"}, "message": "Auto merge of #30740 - bluss:ascii-is-the-best, r=brson\n\nAdd fast path for ASCII in UTF-8 validation\n\nThis speeds up the ASCII case (and long stretches of ASCII in otherwise\nmixed UTF-8 data) when checking UTF-8 validity.\n\nBenchmark results suggest that on purely ASCII input, we can improve\nthroughput (megabytes verified / second) by a factor of 13 to 14 (smallish input).\nOn XML and mostly English language input (en.wikipedia XML dump),\nthroughput improves by a factor 7 (large input).\n\nOn mostly non-ASCII input, performance increases slightly or is the\nsame.\n\nThe UTF-8 validation is rewritten to use indexed access; since all\naccess is preceded by a (mandatory for validation) length check, bounds\nchecks are statically elided by LLVM and this formulation is in fact the best\nfor performance. A previous version had losses due to slice to iterator\nconversions.\n\nA large credit to Bj\u00f6rn Steinbrink who improved this patch immensely,\nwriting this second version.\n\nBenchmark results on x86-64 (Sandy Bridge) compiled with -C opt-level=3.\n\nOld code is `regular`, this PR is called `fast`.\n\nDatasets:\n\n- `ascii` is just ASCII (2.5 kB)\n- `cyr` is cyrillic script with ascii spaces (5 kB)\n- `dewik10` is 10MB of a de.wikipedia XML dump\n- `enwik8` is 100MB of an en.wikipedia XML dump\n- `jawik10` is 10MB of a ja.wikipedia XML dump\n\n```\ntest from_utf8_ascii_fast        ... bench:         140 ns/iter (+/- 4) = 18221 MB/s\ntest from_utf8_ascii_regular     ... bench:       1,932 ns/iter (+/- 19) = 1320 MB/s\ntest from_utf8_cyr_fast          ... bench:      10,025 ns/iter (+/- 245) = 511 MB/s\ntest from_utf8_cyr_regular       ... bench:      10,944 ns/iter (+/- 795) = 468 MB/s\ntest from_utf8_dewik10_fast      ... bench:   6,017,909 ns/iter (+/- 105,755) = 1740 MB/s\ntest from_utf8_dewik10_regular   ... bench:  11,669,493 ns/iter (+/- 264,045) = 891 MB/s\ntest from_utf8_enwik8_fast       ... bench:  14,085,692 ns/iter (+/- 1,643,316) = 7000 MB/s\ntest from_utf8_enwik8_regular    ... bench:  93,657,410 ns/iter (+/- 5,353,353) = 1000 MB/s\ntest from_utf8_jawik10_fast      ... bench:  29,154,073 ns/iter (+/- 4,659,534) = 340 MB/s\ntest from_utf8_jawik10_regular   ... bench:  29,112,917 ns/iter (+/- 2,475,123) = 340 MB/s\n```\n\nCo-authored-by: Bj\u00f6rn Steinbrink <bsteinbr@gmail.com>", "tree": {"sha": "ff27a26becab647a909343046ac1b2d66d3e8c29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff27a26becab647a909343046ac1b2d66d3e8c29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7e4ecc52267f35ae5f846e9e65e5fe83fc6b7be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e4ecc52267f35ae5f846e9e65e5fe83fc6b7be", "html_url": "https://github.com/rust-lang/rust/commit/e7e4ecc52267f35ae5f846e9e65e5fe83fc6b7be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7e4ecc52267f35ae5f846e9e65e5fe83fc6b7be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cee9463d24ee3e5682888aa4ddfbcfc01a1f5e83", "url": "https://api.github.com/repos/rust-lang/rust/commits/cee9463d24ee3e5682888aa4ddfbcfc01a1f5e83", "html_url": "https://github.com/rust-lang/rust/commit/cee9463d24ee3e5682888aa4ddfbcfc01a1f5e83"}, {"sha": "cadcd70775cf42b2add2526026a0a06c1ced411c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cadcd70775cf42b2add2526026a0a06c1ced411c", "html_url": "https://github.com/rust-lang/rust/commit/cadcd70775cf42b2add2526026a0a06c1ced411c"}], "stats": {"total": 99, "additions": 72, "deletions": 27}, "files": [{"sha": "0fde70aacdca9b5821c26a8048d867ebbc19289d", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7e4ecc52267f35ae5f846e9e65e5fe83fc6b7be/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e4ecc52267f35ae5f846e9e65e5fe83fc6b7be/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=e7e4ecc52267f35ae5f846e9e65e5fe83fc6b7be", "patch": "@@ -479,6 +479,18 @@ fn test_is_utf8() {\n     assert!(from_utf8(&[0xF4, 0x8F, 0xBF, 0xBF]).is_ok());\n }\n \n+#[test]\n+fn from_utf8_mostly_ascii() {\n+    // deny invalid bytes embedded in long stretches of ascii\n+    for i in 32..64 {\n+        let mut data = [0; 128];\n+        data[i] = 0xC0;\n+        assert!(from_utf8(&data).is_err());\n+        data[i] = 0xC2;\n+        assert!(from_utf8(&data).is_err());\n+    }\n+}\n+\n #[test]\n fn test_is_utf16() {\n     use rustc_unicode::str::is_utf16;"}, {"sha": "d85212d25e792ee285149c6a79d250dedf1d9830", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 60, "deletions": 27, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e7e4ecc52267f35ae5f846e9e65e5fe83fc6b7be/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e4ecc52267f35ae5f846e9e65e5fe83fc6b7be/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=e7e4ecc52267f35ae5f846e9e65e5fe83fc6b7be", "patch": "@@ -32,6 +32,7 @@ use option::Option::{self, None, Some};\n use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n+use usize;\n \n pub mod pattern;\n \n@@ -240,7 +241,7 @@ impl Utf8Error {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n-    try!(run_utf8_validation_iterator(&mut v.iter()));\n+    try!(run_utf8_validation(v));\n     Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n@@ -1074,46 +1075,44 @@ unsafe fn cmp_slice(a: &str, b: &str, len: usize) -> i32 {\n }\n \n /*\n-Section: Misc\n+Section: UTF-8 validation\n */\n \n+// use truncation to fit u64 into usize\n+const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n+\n+/// Return `true` if any byte in the word `x` is nonascii (>= 128).\n+#[inline]\n+fn contains_nonascii(x: usize) -> bool {\n+    (x & NONASCII_MASK) != 0\n+}\n+\n /// Walk through `iter` checking that it's a valid UTF-8 sequence,\n /// returning `true` in that case, or, if it is invalid, `false` with\n /// `iter` reset such that it is pointing at the first byte in the\n /// invalid sequence.\n #[inline(always)]\n-fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n-                                -> Result<(), Utf8Error> {\n-    let whole = iter.as_slice();\n-    loop {\n-        // save the current thing we're pointing at.\n-        let old = iter.clone();\n-\n-        // restore the iterator we had at the start of this codepoint.\n+fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n+    let mut offset = 0;\n+    let len = v.len();\n+    while offset < len {\n+        let old_offset = offset;\n         macro_rules! err { () => {{\n-            *iter = old.clone();\n             return Err(Utf8Error {\n-                valid_up_to: whole.len() - iter.as_slice().len()\n+                valid_up_to: old_offset\n             })\n         }}}\n \n-        macro_rules! next { () => {\n-            match iter.next() {\n-                Some(a) => *a,\n-                // we needed data, but there was none: error!\n-                None => err!(),\n+        macro_rules! next { () => {{\n+            offset += 1;\n+            // we needed data, but there was none: error!\n+            if offset >= len {\n+                err!()\n             }\n-        }}\n-\n-        let first = match iter.next() {\n-            Some(&b) => b,\n-            // we're at the end of the iterator and a codepoint\n-            // boundary at the same time, so this string is valid.\n-            None => return Ok(())\n-        };\n+            v[offset]\n+        }}}\n \n-        // ASCII characters are always valid, so only large\n-        // bytes need more examination.\n+        let first = v[offset];\n         if first >= 128 {\n             let w = UTF8_CHAR_WIDTH[first as usize];\n             let second = next!();\n@@ -1156,8 +1155,42 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n                 }\n                 _ => err!()\n             }\n+            offset += 1;\n+        } else {\n+            // Ascii case, try to skip forward quickly.\n+            // When the pointer is aligned, read 2 words of data per iteration\n+            // until we find a word containing a non-ascii byte.\n+            const BYTES_PER_ITERATION: usize = 2 * usize::BYTES;\n+            let ptr = v.as_ptr();\n+            let align = (ptr as usize + offset) & (usize::BYTES - 1);\n+            if align == 0 {\n+                if len >= BYTES_PER_ITERATION {\n+                    while offset <= len - BYTES_PER_ITERATION {\n+                        unsafe {\n+                            let u = *(ptr.offset(offset as isize) as *const usize);\n+                            let v = *(ptr.offset((offset + usize::BYTES) as isize) as *const usize);\n+\n+                            // break if there is a nonascii byte\n+                            let zu = contains_nonascii(u);\n+                            let zv = contains_nonascii(v);\n+                            if zu || zv {\n+                                break;\n+                            }\n+                        }\n+                        offset += BYTES_PER_ITERATION;\n+                    }\n+                }\n+                // step from the point where the wordwise loop stopped\n+                while offset < len && v[offset] < 128 {\n+                    offset += 1;\n+                }\n+            } else {\n+                offset += 1;\n+            }\n         }\n     }\n+\n+    Ok(())\n }\n \n // https://tools.ietf.org/html/rfc3629"}]}