{"sha": "2fe7bfe4d2de9942449d3656317e66bc9ec50204", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZTdiZmU0ZDJkZTk5NDI0NDlkMzY1NjMxN2U2NmJjOWVjNTAyMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T07:06:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T07:06:46Z"}, "message": "auto merge of #12162 : eddyb/rust/ast-map-cheap-path, r=nikomatsakis", "tree": {"sha": "102565f152f0d47243af95253a7f673ecaf214e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/102565f152f0d47243af95253a7f673ecaf214e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fe7bfe4d2de9942449d3656317e66bc9ec50204", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fe7bfe4d2de9942449d3656317e66bc9ec50204", "html_url": "https://github.com/rust-lang/rust/commit/2fe7bfe4d2de9942449d3656317e66bc9ec50204", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fe7bfe4d2de9942449d3656317e66bc9ec50204/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d6fef674dccae39f52aabfe0f77503f2d7fe464", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d6fef674dccae39f52aabfe0f77503f2d7fe464", "html_url": "https://github.com/rust-lang/rust/commit/8d6fef674dccae39f52aabfe0f77503f2d7fe464"}, {"sha": "a02b10a0621adfe36eb3cc2e46f45fc7ccdb7ea2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a02b10a0621adfe36eb3cc2e46f45fc7ccdb7ea2", "html_url": "https://github.com/rust-lang/rust/commit/a02b10a0621adfe36eb3cc2e46f45fc7ccdb7ea2"}], "stats": {"total": 4556, "additions": 1985, "deletions": 2571}, "files": [{"sha": "e0353cb1fb6b5e5f05ba9ac8b693956d2b68c7dc", "filename": "src/libfourcc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -74,7 +74,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n \n     let little = match endian {\n         None => false,\n-        Some(Ident{ident, span}) => match token::get_ident(ident.name).get() {\n+        Some(Ident{ident, span}) => match token::get_ident(ident).get() {\n             \"little\" => true,\n             \"big\" => false,\n             \"target\" => target_endian_little(cx, sp),"}, {"sha": "09fda8d6fec156272997d888e6b37acc00ac586b", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 52, "deletions": 78, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -38,11 +38,12 @@ use serialize::hex::ToHex;\n use extra::tempfile::TempDir;\n use syntax::abi;\n use syntax::ast;\n-use syntax::ast_map::{PathMod, PathName, PathPrettyName};\n+use syntax::ast_map::{PathElem, PathElems, PathName};\n use syntax::ast_map;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::crateid::CrateId;\n+use syntax::parse::token;\n \n #[deriving(Clone, Eq, TotalOrd, TotalEq)]\n pub enum OutputType {\n@@ -531,11 +532,8 @@ fn truncated_hash_result(symbol_hasher: &mut Sha256) -> ~str {\n \n \n // This calculates STH for a symbol, as defined above\n-pub fn symbol_hash(tcx: ty::ctxt,\n-                   symbol_hasher: &mut Sha256,\n-                   t: ty::t,\n-                   link_meta: &LinkMeta)\n-                   -> ~str {\n+fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &mut Sha256,\n+               t: ty::t, link_meta: &LinkMeta) -> ~str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -551,13 +549,10 @@ pub fn symbol_hash(tcx: ty::ctxt,\n     hash\n }\n \n-pub fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> ~str {\n-    {\n-        let type_hashcodes = ccx.type_hashcodes.borrow();\n-        match type_hashcodes.get().find(&t) {\n-            Some(h) => return h.to_str(),\n-            None => {}\n-        }\n+fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> ~str {\n+    match ccx.type_hashcodes.borrow().get().find(&t) {\n+        Some(h) => return h.to_str(),\n+        None => {}\n     }\n \n     let mut type_hashcodes = ccx.type_hashcodes.borrow_mut();\n@@ -615,8 +610,9 @@ pub fn sanitize(s: &str) -> ~str {\n     return result;\n }\n \n-pub fn mangle(sess: Session, ss: ast_map::Path,\n-              hash: Option<&str>, vers: Option<&str>) -> ~str {\n+pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n+                                      hash: Option<&str>,\n+                                      vers: Option<&str>) -> ~str {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n     //\n@@ -625,49 +621,27 @@ pub fn mangle(sess: Session, ss: ast_map::Path,\n     // when using unix's linker. Perhaps one day when we just use a linker from LLVM\n     // we won't need to do this name mangling. The problem with name mangling is\n     // that it seriously limits the available characters. For example we can't\n-    // have things like @T or ~[T] in symbol names when one would theoretically\n+    // have things like &T or ~[T] in symbol names when one would theoretically\n     // want them for things like impls of traits on that type.\n     //\n     // To be able to work on all platforms and get *some* reasonable output, we\n     // use C++ name-mangling.\n \n     let mut n = ~\"_ZN\"; // _Z == Begin name-sequence, N == nested\n \n-    let push = |n: &mut ~str, s: &str| {\n+    fn push(n: &mut ~str, s: &str) {\n         let sani = sanitize(s);\n         n.push_str(format!(\"{}{}\", sani.len(), sani));\n-    };\n+    }\n \n     // First, connect each component with <len, name> pairs.\n-    for s in ss.iter() {\n-        match *s {\n-            PathName(s) | PathMod(s) | PathPrettyName(s, _) => {\n-                push(&mut n, sess.str_of(s))\n-            }\n-        }\n+    for e in path {\n+        push(&mut n, token::get_name(e.name()).get().as_slice())\n     }\n \n-    // next, if any identifiers are \"pretty\" and need extra information tacked\n-    // on, then use the hash to generate two unique characters. For now\n-    // hopefully 2 characters is enough to avoid collisions.\n-    static EXTRA_CHARS: &'static str =\n-        \"abcdefghijklmnopqrstuvwxyz\\\n-         ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-         0123456789\";\n-    let mut hash = match hash { Some(s) => s.to_owned(), None => ~\"\" };\n-    for s in ss.iter() {\n-        match *s {\n-            PathPrettyName(_, extra) => {\n-                let hi = (extra >> 32) as u32 as uint;\n-                let lo = extra as u32 as uint;\n-                hash.push_char(EXTRA_CHARS[hi % EXTRA_CHARS.len()] as char);\n-                hash.push_char(EXTRA_CHARS[lo % EXTRA_CHARS.len()] as char);\n-            }\n-            _ => {}\n-        }\n-    }\n-    if hash.len() > 0 {\n-        push(&mut n, hash);\n+    match hash {\n+        Some(s) => push(&mut n, s),\n+        None => {}\n     }\n     match vers {\n         Some(s) => push(&mut n, s),\n@@ -678,10 +652,7 @@ pub fn mangle(sess: Session, ss: ast_map::Path,\n     n\n }\n \n-pub fn exported_name(sess: Session,\n-                     path: ast_map::Path,\n-                     hash: &str,\n-                     vers: &str) -> ~str {\n+pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> ~str {\n     // The version will get mangled to have a leading '_', but it makes more\n     // sense to lead with a 'v' b/c this is a version...\n     let vers = if vers.len() > 0 && !char::is_XID_start(vers.char_at(0)) {\n@@ -690,53 +661,56 @@ pub fn exported_name(sess: Session,\n         vers.to_owned()\n     };\n \n-    mangle(sess, path, Some(hash), Some(vers.as_slice()))\n+    mangle(path, Some(hash), Some(vers.as_slice()))\n }\n \n-pub fn mangle_exported_name(ccx: &CrateContext,\n-                            path: ast_map::Path,\n-                            t: ty::t) -> ~str {\n-    let hash = get_symbol_hash(ccx, t);\n-    return exported_name(ccx.sess, path,\n-                         hash,\n-                         ccx.link_meta.crateid.version_or_default());\n+pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n+                            t: ty::t, id: ast::NodeId) -> ~str {\n+    let mut hash = get_symbol_hash(ccx, t);\n+\n+    // Paths can be completely identical for different nodes,\n+    // e.g. `fn foo() { { fn a() {} } { fn a() {} } }`, so we\n+    // generate unique characters from the node id. For now\n+    // hopefully 3 characters is enough to avoid collisions.\n+    static EXTRA_CHARS: &'static str =\n+        \"abcdefghijklmnopqrstuvwxyz\\\n+         ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+         0123456789\";\n+    let id = id as uint;\n+    let extra1 = id % EXTRA_CHARS.len();\n+    let id = id / EXTRA_CHARS.len();\n+    let extra2 = id % EXTRA_CHARS.len();\n+    let id = id / EXTRA_CHARS.len();\n+    let extra3 = id % EXTRA_CHARS.len();\n+    hash.push_char(EXTRA_CHARS[extra1] as char);\n+    hash.push_char(EXTRA_CHARS[extra2] as char);\n+    hash.push_char(EXTRA_CHARS[extra3] as char);\n+\n+    exported_name(path, hash, ccx.link_meta.crateid.version_or_default())\n }\n \n pub fn mangle_internal_name_by_type_only(ccx: &CrateContext,\n                                          t: ty::t,\n                                          name: &str) -> ~str {\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n+    let path = [PathName(token::intern(name)),\n+                PathName(token::intern(s))];\n     let hash = get_symbol_hash(ccx, t);\n-    return mangle(ccx.sess,\n-                  ~[PathName(ccx.sess.ident_of(name)),\n-                    PathName(ccx.sess.ident_of(s))],\n-                  Some(hash.as_slice()),\n-                  None);\n+    mangle(ast_map::Values(path.iter()), Some(hash.as_slice()), None)\n }\n \n pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n                                             t: ty::t,\n                                             name: &str) -> ~str {\n     let s = ppaux::ty_to_str(ccx.tcx, t);\n+    let path = [PathName(token::intern(s)),\n+                gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n-    let (_, name) = gensym_name(name);\n-    return mangle(ccx.sess,\n-                  ~[PathName(ccx.sess.ident_of(s)), name],\n-                  Some(hash.as_slice()),\n-                  None);\n-}\n-\n-pub fn mangle_internal_name_by_path_and_seq(ccx: &CrateContext,\n-                                            mut path: ast_map::Path,\n-                                            flav: &str) -> ~str {\n-    let (_, name) = gensym_name(flav);\n-    path.push(name);\n-    mangle(ccx.sess, path, None, None)\n+    mangle(ast_map::Values(path.iter()), Some(hash.as_slice()), None)\n }\n \n-pub fn mangle_internal_name_by_path(ccx: &CrateContext,\n-                                    path: ast_map::Path) -> ~str {\n-    mangle(ccx.sess, path, None, None)\n+pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> ~str {\n+    mangle(path.chain(Some(gensym_name(flav)).move_iter()), None, None)\n }\n \n pub fn output_lib_filename(lm: &LinkMeta) -> ~str {"}, {"sha": "cbc72b5a918754d299018336010bad7797c7c4c2", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -264,7 +264,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                                 |_| middle::resolve_lifetime::krate(sess, krate));\n \n     time(time_passes, \"looking for entry point\", (),\n-         |_| middle::entry::find_entry_point(sess, krate, ast_map));\n+         |_| middle::entry::find_entry_point(sess, krate, &ast_map));\n \n     sess.macro_registrar_fn.with_mut(|r| *r =\n         time(time_passes, \"looking for macro registrar\", (), |_|\n@@ -288,7 +288,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n          middle::const_eval::process_crate(krate, ty_cx));\n \n     time(time_passes, \"const checking\", (), |_|\n-         middle::check_const::check_crate(sess, krate, ast_map, def_map,\n+         middle::check_const::check_crate(sess, krate, def_map,\n                                           method_map, ty_cx));\n \n     let maps = (external_exports, last_private_map);\n@@ -638,7 +638,6 @@ pub fn pretty_print_input(sess: Session,\n     let mut rdr = MemReader::new(src.as_bytes().to_owned());\n     let stdout = io::stdout();\n     pprust::print_crate(sess.codemap,\n-                        token::get_ident_interner(),\n                         sess.span_diagnostic,\n                         &krate,\n                         source_name(input),\n@@ -1135,7 +1134,6 @@ pub fn early_error(msg: &str) -> ! {\n pub fn list_metadata(sess: Session, path: &Path,\n                      out: &mut io::Writer) -> io::IoResult<()> {\n     metadata::loader::list_file_metadata(\n-        token::get_ident_interner(),\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out)\n }\n "}, {"sha": "aff89974ca6a84994b81dd7d94e57e3b8d5795d5", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -22,9 +22,7 @@ use syntax::ast::{IntTy, UintTy};\n use syntax::codemap::Span;\n use syntax::diagnostic;\n use syntax::parse::ParseSess;\n-use syntax::{ast, codemap};\n-use syntax::abi;\n-use syntax::parse::token;\n+use syntax::{abi, ast, codemap};\n use syntax;\n \n use std::cell::{Cell, RefCell};\n@@ -301,23 +299,6 @@ impl Session_ {\n     pub fn show_span(&self) -> bool {\n         self.debugging_opt(SHOW_SPAN)\n     }\n-\n-    // DEPRECATED. This function results in a lot of allocations when they\n-    // are not necessary.\n-    pub fn str_of(&self, id: ast::Ident) -> ~str {\n-        let string = token::get_ident(id.name);\n-        string.get().to_str()\n-    }\n-\n-    // pointless function, now...\n-    pub fn ident_of(&self, st: &str) -> ast::Ident {\n-        token::str_to_ident(st)\n-    }\n-\n-    // pointless function, now...\n-    pub fn intr(&self) -> @syntax::parse::token::IdentInterner {\n-        token::get_ident_interner()\n-    }\n }\n \n /// Some reasonable defaults"}, {"sha": "750d09c2d1784d227e3497c6e842a1f32fe05f93", "filename": "src/librustc/front/assign_node_ids_and_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -25,5 +25,5 @@ impl ast_map::FoldOps for NodeIdAssigner {\n }\n \n pub fn assign_node_ids_and_map(sess: Session, krate: ast::Crate) -> (ast::Crate, ast_map::Map) {\n-    ast_map::map_crate(sess.diagnostic(), krate, NodeIdAssigner { sess: sess })\n+    ast_map::map_crate(krate, NodeIdAssigner { sess: sess })\n }"}, {"sha": "52553af53c76d17c7a4bfb34b884cee8dd70d4e4", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -99,10 +99,7 @@ impl Context {\n \n impl Visitor<()> for Context {\n     fn visit_ident(&mut self, sp: Span, id: ast::Ident, _: ()) {\n-        let string = token::get_ident(id.name);\n-        let s = string.get();\n-\n-        if !s.is_ascii() {\n+        if !token::get_ident(id).get().is_ascii() {\n             self.gate_feature(\"non_ascii_idents\", sp,\n                               \"non-ascii idents are not fully supported.\");\n         }\n@@ -196,29 +193,29 @@ impl Visitor<()> for Context {\n         let msg = \" is not stable enough for use and are subject to change\";\n \n \n-        if id == self.sess.ident_of(\"macro_rules\") {\n+        if id == token::str_to_ident(\"macro_rules\") {\n             self.gate_feature(\"macro_rules\", path.span, \"macro definitions are \\\n                 not stable enough for use and are subject to change\");\n         }\n \n-        else if id == self.sess.ident_of(\"asm\") {\n+        else if id == token::str_to_ident(\"asm\") {\n             self.gate_feature(\"asm\", path.span, \"inline assembly is not \\\n                 stable enough for use and is subject to change\");\n         }\n \n-        else if id == self.sess.ident_of(\"log_syntax\") {\n+        else if id == token::str_to_ident(\"log_syntax\") {\n             self.gate_feature(\"log_syntax\", path.span, \"`log_syntax!` is not \\\n                 stable enough for use and is subject to change\");\n         }\n \n-        else if id == self.sess.ident_of(\"trace_macros\") {\n+        else if id == token::str_to_ident(\"trace_macros\") {\n             self.gate_feature(\"trace_macros\", path.span, \"`trace_macros` is not \\\n                 stable enough for use and is subject to change\");\n         }\n \n         else {\n             for &quote in quotes.iter() {\n-                if id == self.sess.ident_of(quote) {\n+                if id == token::str_to_ident(quote) {\n                   self.gate_feature(\"quote\", path.span, quote + msg);\n                 }\n             }"}, {"sha": "f4bc1c1906353bfe50e95530055ec045f6ea9c40", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -73,7 +73,7 @@ pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n impl fold::Folder for StandardLibraryInjector {\n     fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n         let mut vis = ~[ast::ViewItem {\n-            node: ast::ViewItemExternMod(self.sess.ident_of(\"std\"),\n+            node: ast::ViewItemExternMod(token::str_to_ident(\"std\"),\n                                          with_version(\"std\"),\n                                          ast::DUMMY_NODE_ID),\n             attrs: ~[\n@@ -90,15 +90,15 @@ impl fold::Folder for StandardLibraryInjector {\n \n         if use_uv(&krate) && !self.sess.building_library.get() {\n             vis.push(ast::ViewItem {\n-                node: ast::ViewItemExternMod(self.sess.ident_of(\"green\"),\n+                node: ast::ViewItemExternMod(token::str_to_ident(\"green\"),\n                                              with_version(\"green\"),\n                                              ast::DUMMY_NODE_ID),\n                 attrs: ~[],\n                 vis: ast::Inherited,\n                 span: DUMMY_SP\n             });\n             vis.push(ast::ViewItem {\n-                node: ast::ViewItemExternMod(self.sess.ident_of(\"rustuv\"),\n+                node: ast::ViewItemExternMod(token::str_to_ident(\"rustuv\"),\n                                              with_version(\"rustuv\"),\n                                              ast::DUMMY_NODE_ID),\n                 attrs: ~[],\n@@ -163,12 +163,12 @@ impl fold::Folder for PreludeInjector {\n             global: false,\n             segments: ~[\n                 ast::PathSegment {\n-                    identifier: self.sess.ident_of(\"std\"),\n+                    identifier: token::str_to_ident(\"std\"),\n                     lifetimes: opt_vec::Empty,\n                     types: opt_vec::Empty,\n                 },\n                 ast::PathSegment {\n-                    identifier: self.sess.ident_of(\"prelude\"),\n+                    identifier: token::str_to_ident(\"prelude\"),\n                     lifetimes: opt_vec::Empty,\n                     types: opt_vec::Empty,\n                 },"}, {"sha": "819f96a391bbfac4f05b94677d706906d6a7f38d", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -289,7 +289,7 @@ mod __test {\n */\n \n fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n-    let id_extra = cx.sess.ident_of(\"extra\");\n+    let id_extra = token::str_to_ident(\"extra\");\n     let vi = if cx.is_extra {\n         ast::ViewItemUse(\n             ~[@nospan(ast::ViewPathSimple(id_extra,\n@@ -337,16 +337,15 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n         attr::mk_attr(attr::mk_word_item(resolve_unexported_str));\n \n     let item = ast::Item {\n-        ident: cx.sess.ident_of(\"__test\"),\n+        ident: token::str_to_ident(\"__test\"),\n         attrs: ~[resolve_unexported_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: item_,\n         vis: ast::Public,\n         span: DUMMY_SP,\n      };\n \n-    debug!(\"Synthetic test module:\\n{}\\n\",\n-           pprust::item_to_str(&item, cx.sess.intr()));\n+    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_str(&item));\n \n     return @item;\n }"}, {"sha": "48ec199ed004e8bd0ec47f5443dc07dc7387ca7e", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 111, "deletions": 115, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -13,88 +13,88 @@ use syntax::crateid::CrateId;\n \n // EBML enum definitions and utils shared by the encoder and decoder\n \n-pub static tag_items: uint = 0x02u;\n+pub static tag_items: uint = 0x00;\n \n-pub static tag_paths_data_name: uint = 0x04u;\n+pub static tag_paths_data_name: uint = 0x01;\n \n-pub static tag_def_id: uint = 0x07u;\n+pub static tag_def_id: uint = 0x02;\n \n-pub static tag_items_data: uint = 0x08u;\n+pub static tag_items_data: uint = 0x03;\n \n-pub static tag_items_data_item: uint = 0x09u;\n+pub static tag_items_data_item: uint = 0x04;\n \n-pub static tag_items_data_item_family: uint = 0x0au;\n+pub static tag_items_data_item_family: uint = 0x05;\n \n-pub static tag_items_data_item_ty_param_bounds: uint = 0x0bu;\n+pub static tag_items_data_item_ty_param_bounds: uint = 0x06;\n \n-pub static tag_items_data_item_type: uint = 0x0cu;\n+pub static tag_items_data_item_type: uint = 0x07;\n \n-pub static tag_items_data_item_symbol: uint = 0x0du;\n+pub static tag_items_data_item_symbol: uint = 0x08;\n \n-pub static tag_items_data_item_variant: uint = 0x0eu;\n+pub static tag_items_data_item_variant: uint = 0x09;\n \n-pub static tag_items_data_parent_item: uint = 0x0fu;\n+pub static tag_items_data_parent_item: uint = 0x0a;\n \n-pub static tag_items_data_item_is_tuple_struct_ctor: uint = 0x10u;\n+pub static tag_items_data_item_is_tuple_struct_ctor: uint = 0x0b;\n \n-pub static tag_index: uint = 0x11u;\n+pub static tag_index: uint = 0x0c;\n \n-pub static tag_index_buckets: uint = 0x12u;\n+pub static tag_index_buckets: uint = 0x0d;\n \n-pub static tag_index_buckets_bucket: uint = 0x13u;\n+pub static tag_index_buckets_bucket: uint = 0x0e;\n \n-pub static tag_index_buckets_bucket_elt: uint = 0x14u;\n+pub static tag_index_buckets_bucket_elt: uint = 0x0f;\n \n-pub static tag_index_table: uint = 0x15u;\n+pub static tag_index_table: uint = 0x10;\n \n-pub static tag_meta_item_name_value: uint = 0x18u;\n+pub static tag_meta_item_name_value: uint = 0x11;\n \n-pub static tag_meta_item_name: uint = 0x19u;\n+pub static tag_meta_item_name: uint = 0x12;\n \n-pub static tag_meta_item_value: uint = 0x20u;\n+pub static tag_meta_item_value: uint = 0x13;\n \n-pub static tag_attributes: uint = 0x21u;\n+pub static tag_attributes: uint = 0x14;\n \n-pub static tag_attribute: uint = 0x22u;\n+pub static tag_attribute: uint = 0x15;\n \n-pub static tag_meta_item_word: uint = 0x23u;\n+pub static tag_meta_item_word: uint = 0x16;\n \n-pub static tag_meta_item_list: uint = 0x24u;\n+pub static tag_meta_item_list: uint = 0x17;\n \n // The list of crates that this crate depends on\n-pub static tag_crate_deps: uint = 0x25u;\n+pub static tag_crate_deps: uint = 0x18;\n \n // A single crate dependency\n-pub static tag_crate_dep: uint = 0x26u;\n+pub static tag_crate_dep: uint = 0x19;\n \n-pub static tag_crate_hash: uint = 0x28u;\n+pub static tag_crate_hash: uint = 0x1a;\n \n-pub static tag_parent_item: uint = 0x29u;\n+pub static tag_parent_item: uint = 0x1b;\n \n-pub static tag_crate_dep_name: uint = 0x2au;\n-pub static tag_crate_dep_hash: uint = 0x2bu;\n-pub static tag_crate_dep_vers: uint = 0x2cu;\n+pub static tag_crate_dep_name: uint = 0x1c;\n+pub static tag_crate_dep_hash: uint = 0x1d;\n+pub static tag_crate_dep_vers: uint = 0x1e;\n \n-pub static tag_mod_impl: uint = 0x30u;\n+pub static tag_mod_impl: uint = 0x1f;\n \n-pub static tag_item_trait_method: uint = 0x31u;\n+pub static tag_item_trait_method: uint = 0x20;\n \n-pub static tag_item_trait_ref: uint = 0x32u;\n-pub static tag_item_super_trait_ref: uint = 0x33u;\n+pub static tag_item_trait_ref: uint = 0x21;\n+pub static tag_item_super_trait_ref: uint = 0x22;\n \n // discriminator value for variants\n-pub static tag_disr_val: uint = 0x34u;\n-\n-// used to encode ast_map::Path and ast_map::PathElem\n-pub static tag_path: uint = 0x40u;\n-pub static tag_path_len: uint = 0x41u;\n-pub static tag_path_elem_mod: uint = 0x42u;\n-pub static tag_path_elem_name: uint = 0x43u;\n-pub static tag_item_field: uint = 0x44u;\n-pub static tag_struct_mut: uint = 0x45u;\n-\n-pub static tag_item_variances: uint = 0x46;\n-pub static tag_mod_impl_trait: uint = 0x47u;\n+pub static tag_disr_val: uint = 0x23;\n+\n+// used to encode ast_map::PathElem\n+pub static tag_path: uint = 0x24;\n+pub static tag_path_len: uint = 0x25;\n+pub static tag_path_elem_mod: uint = 0x26;\n+pub static tag_path_elem_name: uint = 0x27;\n+pub static tag_item_field: uint = 0x28;\n+pub static tag_struct_mut: uint = 0x29;\n+\n+pub static tag_item_variances: uint = 0x2a;\n+pub static tag_mod_impl_trait: uint = 0x2b;\n /*\n   trait items contain tag_item_trait_method elements,\n   impl items contain tag_item_impl_method elements, and classes\n@@ -103,47 +103,47 @@ pub static tag_mod_impl_trait: uint = 0x47u;\n   both, tag_item_trait_method and tag_item_impl_method have to be two\n   different tags.\n  */\n-pub static tag_item_impl_method: uint = 0x48u;\n-pub static tag_item_trait_method_explicit_self: uint = 0x4b;\n-pub static tag_item_trait_method_self_ty_region: uint = 0x4c;\n+pub static tag_item_impl_method: uint = 0x2c;\n+pub static tag_item_trait_method_explicit_self: uint = 0x2d;\n+pub static tag_item_trait_method_self_ty_region: uint = 0x2e;\n \n \n // Reexports are found within module tags. Each reexport contains def_ids\n // and names.\n-pub static tag_items_data_item_reexport: uint = 0x4d;\n-pub static tag_items_data_item_reexport_def_id: uint = 0x4e;\n-pub static tag_items_data_item_reexport_name: uint = 0x4f;\n+pub static tag_items_data_item_reexport: uint = 0x2f;\n+pub static tag_items_data_item_reexport_def_id: uint = 0x30;\n+pub static tag_items_data_item_reexport_name: uint = 0x31;\n \n // used to encode crate_ctxt side tables\n #[deriving(Eq)]\n #[repr(uint)]\n-pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n-    tag_ast = 0x50,\n-\n-    tag_tree = 0x51,\n-\n-    tag_id_range = 0x52,\n-\n-    tag_table = 0x53,\n-    tag_table_id = 0x54,\n-    tag_table_val = 0x55,\n-    tag_table_def = 0x56,\n-    tag_table_node_type = 0x57,\n-    tag_table_node_type_subst = 0x58,\n-    tag_table_freevars = 0x59,\n-    tag_table_tcache = 0x5a,\n-    tag_table_param_defs = 0x5b,\n-    tag_table_mutbl = 0x5d,\n-    tag_table_last_use = 0x5e,\n-    tag_table_spill = 0x5f,\n-    tag_table_method_map = 0x60,\n-    tag_table_vtable_map = 0x61,\n-    tag_table_adjustments = 0x62,\n-    tag_table_moves_map = 0x63,\n-    tag_table_capture_map = 0x64\n+pub enum astencode_tag { // Reserves 0x32 -- 0x45\n+    tag_ast = 0x32,\n+\n+    tag_tree = 0x33,\n+\n+    tag_id_range = 0x34,\n+\n+    tag_table = 0x35,\n+    tag_table_id = 0x36,\n+    tag_table_val = 0x37,\n+    tag_table_def = 0x38,\n+    tag_table_node_type = 0x39,\n+    tag_table_node_type_subst = 0x3a,\n+    tag_table_freevars = 0x3b,\n+    tag_table_tcache = 0x3c,\n+    tag_table_param_defs = 0x3d,\n+    tag_table_mutbl = 0x3e,\n+    tag_table_last_use = 0x3f,\n+    tag_table_spill = 0x40,\n+    tag_table_method_map = 0x41,\n+    tag_table_vtable_map = 0x42,\n+    tag_table_adjustments = 0x43,\n+    tag_table_moves_map = 0x44,\n+    tag_table_capture_map = 0x45\n }\n-static first_astencode_tag : uint = tag_ast as uint;\n-static last_astencode_tag : uint = tag_table_capture_map as uint;\n+static first_astencode_tag: uint = tag_ast as uint;\n+static last_astencode_tag: uint = tag_table_capture_map as uint;\n impl astencode_tag {\n     pub fn from_uint(value : uint) -> Option<astencode_tag> {\n         let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;\n@@ -153,9 +153,9 @@ impl astencode_tag {\n     }\n }\n \n-pub static tag_item_trait_method_sort: uint = 0x70;\n+pub static tag_item_trait_method_sort: uint = 0x46;\n \n-pub static tag_item_impl_type_basename: uint = 0x71;\n+pub static tag_item_impl_type_basename: uint = 0x47;\n \n // Language items are a top-level directory (for speed). Hierarchy:\n //\n@@ -164,50 +164,46 @@ pub static tag_item_impl_type_basename: uint = 0x71;\n //   - tag_lang_items_item_id: u32\n //   - tag_lang_items_item_node_id: u32\n \n-pub static tag_lang_items: uint = 0x72;\n-pub static tag_lang_items_item: uint = 0x73;\n-pub static tag_lang_items_item_id: uint = 0x74;\n-pub static tag_lang_items_item_node_id: uint = 0x75;\n+pub static tag_lang_items: uint = 0x48;\n+pub static tag_lang_items_item: uint = 0x49;\n+pub static tag_lang_items_item_id: uint = 0x4a;\n+pub static tag_lang_items_item_node_id: uint = 0x4b;\n \n-pub static tag_item_unnamed_field: uint = 0x76;\n-pub static tag_items_data_item_struct_ctor: uint = 0x77;\n-pub static tag_items_data_item_visibility: uint = 0x78;\n+pub static tag_item_unnamed_field: uint = 0x4c;\n+pub static tag_items_data_item_struct_ctor: uint = 0x4d;\n+pub static tag_items_data_item_visibility: uint = 0x4e;\n \n-pub static tag_link_args: uint = 0x79;\n-pub static tag_link_args_arg: uint = 0x7a;\n+pub static tag_link_args: uint = 0x4f;\n+pub static tag_link_args_arg: uint = 0x50;\n \n-pub static tag_item_method_tps: uint = 0x7b;\n-pub static tag_item_method_fty: uint = 0x7c;\n+pub static tag_item_method_tps: uint = 0x51;\n+pub static tag_item_method_fty: uint = 0x52;\n \n-pub static tag_mod_child: uint = 0x7d;\n-pub static tag_misc_info: uint = 0x7e;\n-pub static tag_misc_info_crate_items: uint = 0x7f;\n+pub static tag_mod_child: uint = 0x53;\n+pub static tag_misc_info: uint = 0x54;\n+pub static tag_misc_info_crate_items: uint = 0x55;\n \n-pub static tag_item_method_provided_source: uint = 0x80;\n-pub static tag_item_impl_vtables: uint = 0x81;\n+pub static tag_item_method_provided_source: uint = 0x56;\n+pub static tag_item_impl_vtables: uint = 0x57;\n \n-pub static tag_impls: uint = 0x82;\n-pub static tag_impls_impl: uint = 0x83;\n+pub static tag_impls: uint = 0x58;\n+pub static tag_impls_impl: uint = 0x59;\n \n-pub static tag_items_data_item_inherent_impl: uint = 0x84;\n-pub static tag_items_data_item_extension_impl: uint = 0x85;\n+pub static tag_items_data_item_inherent_impl: uint = 0x5a;\n+pub static tag_items_data_item_extension_impl: uint = 0x5b;\n \n-pub static tag_path_elem_pretty_name: uint = 0x86;\n-pub static tag_path_elem_pretty_name_ident: uint = 0x87;\n-pub static tag_path_elem_pretty_name_extra: uint = 0x88;\n+pub static tag_region_param_def: uint = 0x5c;\n+pub static tag_region_param_def_ident: uint = 0x5d;\n+pub static tag_region_param_def_def_id: uint = 0x5e;\n \n-pub static tag_region_param_def: uint = 0x100;\n-pub static tag_region_param_def_ident: uint = 0x101;\n-pub static tag_region_param_def_def_id: uint = 0x102;\n+pub static tag_native_libraries: uint = 0x5f;\n+pub static tag_native_libraries_lib: uint = 0x60;\n+pub static tag_native_libraries_name: uint = 0x61;\n+pub static tag_native_libraries_kind: uint = 0x62;\n \n-pub static tag_native_libraries: uint = 0x103;\n-pub static tag_native_libraries_lib: uint = 0x104;\n-pub static tag_native_libraries_name: uint = 0x105;\n-pub static tag_native_libraries_kind: uint = 0x106;\n-\n-pub static tag_macro_registrar_fn: uint = 0x110;\n-pub static tag_exported_macros: uint = 0x111;\n-pub static tag_macro_def: uint = 0x112;\n+pub static tag_macro_registrar_fn: uint = 0x63;\n+pub static tag_exported_macros: uint = 0x64;\n+pub static tag_macro_def: uint = 0x65;\n \n #[deriving(Clone)]\n pub struct LinkMeta {"}, {"sha": "a80ac38e8ae05b03ef75d3ad44870a719f7a3c82", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -167,10 +167,10 @@ struct CrateInfo {\n \n fn extract_crate_info(i: &ast::ViewItem) -> Option<CrateInfo> {\n     match i.node {\n-        ast::ViewItemExternMod(ref ident, ref path_opt, id) => {\n-            let ident = token::get_ident(ident.name);\n+        ast::ViewItemExternMod(ident, ref path_opt, id) => {\n+            let ident = token::get_ident(ident);\n             debug!(\"resolving extern mod stmt. ident: {:?} path_opt: {:?}\",\n-                   ident.get(), path_opt);\n+                   ident, path_opt);\n             let (name, version) = match *path_opt {\n                 Some((ref path_str, _)) => {\n                     let crateid: Option<CrateId> = from_str(path_str.get());\n@@ -282,16 +282,16 @@ fn visit_item(e: &Env, i: &ast::Item) {\n     }\n }\n \n-fn existing_match(e: &Env, name: ~str, version: ~str, hash: &str) -> Option<ast::CrateNum> {\n+fn existing_match(e: &Env, name: &str, version: &str, hash: &str) -> Option<ast::CrateNum> {\n     let crate_cache = e.crate_cache.borrow();\n     for c in crate_cache.get().iter() {\n         let crateid_version = match c.crateid.version {\n             None => ~\"0.0\",\n             Some(ref ver) => ver.to_str(),\n         };\n-        if (name.is_empty() || c.crateid.name == name) &&\n-            (version.is_empty() || crateid_version == version) &&\n-            (hash.is_empty() || c.hash.as_slice() == hash) {\n+        if (name.is_empty() || name == c.crateid.name) &&\n+            (version.is_empty() || version == crateid_version) &&\n+            (hash.is_empty() || hash == c.hash) {\n             return Some(c.cnum);\n         }\n     }\n@@ -305,13 +305,13 @@ fn resolve_crate(e: &mut Env,\n                  hash: ~str,\n                  span: Span)\n               -> ast::CrateNum {\n-    match existing_match(e, name.clone(), version.clone(), hash.clone()) {\n+    match existing_match(e, name, version, hash) {\n       None => {\n         let load_ctxt = loader::Context {\n             sess: e.sess,\n             span: span,\n             ident: ident,\n-            name: name.clone(),\n+            name: name,\n             version: version,\n             hash: hash,\n             os: e.os,\n@@ -342,7 +342,7 @@ fn resolve_crate(e: &mut Env,\n         let cnum_map = resolve_crate_deps(e, metadata.as_slice());\n \n         let cmeta = @cstore::crate_metadata {\n-            name: name,\n+            name: load_ctxt.name,\n             data: metadata,\n             cnum_map: cnum_map,\n             cnum: cnum\n@@ -372,13 +372,13 @@ fn resolve_crate_deps(e: &mut Env, cdata: &[u8]) -> cstore::cnum_map {\n     let r = decoder::get_crate_deps(cdata);\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n-        let cname_str = token::get_ident(dep.name.name);\n+        let cname_str = token::get_ident(dep.name);\n         debug!(\"resolving dep crate {} ver: {} hash: {}\",\n                cname_str, dep.vers, dep.hash);\n         match existing_match(e,\n-                             cname_str.get().to_str(),\n-                             dep.vers.clone(),\n-                             dep.hash.clone()) {\n+                             cname_str.get(),\n+                             dep.vers,\n+                             dep.hash) {\n           Some(local_cnum) => {\n             debug!(\"already have it\");\n             // We've already seen this crate"}, {"sha": "7b0c900fceaab64f8705587146d48db23abffc6c", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -23,6 +23,7 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::diagnostic::expect;\n+use syntax::parse::token;\n \n pub struct StaticMethodInfo {\n     ident: ast::Ident,\n@@ -84,15 +85,14 @@ pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n                                           callback)\n }\n \n-pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> ast_map::Path {\n+pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> ~[ast_map::PathElem] {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     let path = decoder::get_item_path(cdata, def.node);\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    vec::append(~[ast_map::PathMod(tcx.sess.ident_of(\n-        cdata.name))], path)\n+    vec::append(~[ast_map::PathMod(token::intern(cdata.name))], path)\n }\n \n pub enum found_ast {\n@@ -105,12 +105,11 @@ pub enum found_ast {\n // not marked for inlining, then the AST will not be present and hence none\n // will be returned.\n pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::DefId,\n-                          decode_inlined_item: decoder::decode_inlined_item)\n+                          decode_inlined_item: decoder::DecodeInlinedItem)\n                        -> found_ast {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::maybe_get_item_ast(cdata, tcx, def.node,\n-                                decode_inlined_item)\n+    decoder::maybe_get_item_ast(cdata, tcx, def.node, decode_inlined_item)\n }\n \n pub fn get_enum_variants(tcx: ty::ctxt, def: ast::DefId)"}, {"sha": "44aa9c841013621161fdb60aa235acc1db07c876", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 43, "deletions": 68, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -37,10 +37,10 @@ use serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;\n use syntax::parse::token::{IdentInterner, special_idents};\n+use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ast;\n use syntax::codemap;\n-use syntax::parse::token;\n \n type Cmd = @crate_metadata;\n \n@@ -96,7 +96,7 @@ fn find_item<'a>(item_id: ast::NodeId, items: ebml::Doc<'a>) -> ebml::Doc<'a> {\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-pub fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> ebml::Doc<'a> {\n+fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> ebml::Doc<'a> {\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     find_item(item_id, items)\n }\n@@ -258,15 +258,13 @@ fn item_ty_param_defs(item: ebml::Doc,\n     Rc::new(bounds)\n }\n \n-fn item_region_param_defs(item_doc: ebml::Doc,\n-                          tcx: ty::ctxt,\n-                          cdata: Cmd)\n+fn item_region_param_defs(item_doc: ebml::Doc, cdata: Cmd)\n                           -> Rc<~[ty::RegionParameterDef]> {\n     let mut v = ~[];\n     reader::tagged_docs(item_doc, tag_region_param_def, |rp_doc| {\n             let ident_str_doc = reader::get_doc(rp_doc,\n                                                 tag_region_param_def_ident);\n-            let ident = item_name(tcx.sess.intr(), ident_str_doc);\n+            let ident = item_name(token::get_ident_interner(), ident_str_doc);\n             let def_id_doc = reader::get_doc(rp_doc,\n                                              tag_region_param_def_def_id);\n             let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n@@ -296,7 +294,7 @@ fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::DefId] {\n     return ids;\n }\n \n-pub fn item_path(item_doc: ebml::Doc) -> ast_map::Path {\n+fn item_path(item_doc: ebml::Doc) -> ~[ast_map::PathElem] {\n     let path_doc = reader::get_doc(item_doc, tag_path);\n \n     let len_doc = reader::get_doc(path_doc, tag_path_len);\n@@ -305,30 +303,21 @@ pub fn item_path(item_doc: ebml::Doc) -> ast_map::Path {\n     let mut result = vec::with_capacity(len);\n     reader::docs(path_doc, |tag, elt_doc| {\n         if tag == tag_path_elem_mod {\n-            let str = elt_doc.as_str_slice();\n-            result.push(ast_map::PathMod(token::str_to_ident(str)));\n+            let s = elt_doc.as_str_slice();\n+            result.push(ast_map::PathMod(token::intern(s)));\n         } else if tag == tag_path_elem_name {\n-            let str = elt_doc.as_str_slice();\n-            result.push(ast_map::PathName(token::str_to_ident(str)));\n-        } else if tag == tag_path_elem_pretty_name {\n-            let name_doc = reader::get_doc(elt_doc,\n-                                           tag_path_elem_pretty_name_ident);\n-            let extra_doc = reader::get_doc(elt_doc,\n-                                            tag_path_elem_pretty_name_extra);\n-            let str = name_doc.as_str_slice();\n-            let extra = reader::doc_as_u64(extra_doc);\n-            result.push(ast_map::PathPrettyName(token::str_to_ident(str),\n-                                                extra));\n+            let s = elt_doc.as_str_slice();\n+            result.push(ast_map::PathName(token::intern(s)));\n         } else {\n             // ignore tag_path_len element\n         }\n         true\n     });\n \n-    return result;\n+    result\n }\n \n-fn item_name(intr: @IdentInterner, item: ebml::Doc) -> ast::Ident {\n+fn item_name(intr: &IdentInterner, item: ebml::Doc) -> ast::Ident {\n     let name = reader::get_doc(item, tag_paths_data_name);\n     let string = name.as_str_slice();\n     match intr.find_equiv(&string) {\n@@ -337,7 +326,7 @@ fn item_name(intr: @IdentInterner, item: ebml::Doc) -> ast::Ident {\n     }\n }\n \n-pub fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n+fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n@@ -383,22 +372,14 @@ pub fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     }\n }\n \n-pub fn lookup_def(cnum: ast::CrateNum, data: &[u8], did_: ast::DefId) ->\n-   ast::Def {\n-    let item = lookup_item(did_.node, data);\n-    let did = ast::DefId { krate: cnum, node: did_.node };\n-    // We treat references to enums as references to types.\n-    return def_like_to_def(item_to_def_like(item, did, cnum));\n-}\n-\n pub fn get_trait_def(cdata: Cmd,\n                      item_id: ast::NodeId,\n                      tcx: ty::ctxt) -> ty::TraitDef\n {\n     let item_doc = lookup_item(item_id, cdata.data());\n     let tp_defs = item_ty_param_defs(item_doc, tcx, cdata,\n                                      tag_items_data_item_ty_param_bounds);\n-    let rp_defs = item_region_param_defs(item_doc, tcx, cdata);\n+    let rp_defs = item_region_param_defs(item_doc, cdata);\n     let mut bounds = ty::EmptyBuiltinBounds();\n     // Collect the builtin bounds from the encoded supertraits.\n     // FIXME(#8559): They should be encoded directly.\n@@ -427,7 +408,7 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n                       cdata);\n \n     let tp_defs = item_ty_param_defs(item, tcx, cdata, tag_items_data_item_ty_param_bounds);\n-    let rp_defs = item_region_param_defs(item, tcx, cdata);\n+    let rp_defs = item_region_param_defs(item, cdata);\n \n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: tp_defs,\n@@ -682,41 +663,37 @@ pub fn each_top_level_item_of_crate(intr: @IdentInterner,\n                                 callback)\n }\n \n-pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> ast_map::Path {\n+pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> ~[ast_map::PathElem] {\n     item_path(lookup_item(id, cdata.data()))\n }\n \n-pub type decode_inlined_item<'a> = 'a |cdata: @cstore::crate_metadata,\n-                                             tcx: ty::ctxt,\n-                                             path: ast_map::Path,\n-                                             par_doc: ebml::Doc|\n-                                             -> Option<ast::InlinedItem>;\n+pub type DecodeInlinedItem<'a> = 'a |cdata: @cstore::crate_metadata,\n+                                     tcx: ty::ctxt,\n+                                     path: ~[ast_map::PathElem],\n+                                     par_doc: ebml::Doc|\n+                                     -> Result<ast::InlinedItem, ~[ast_map::PathElem]>;\n \n-pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt,\n-                          id: ast::NodeId,\n-                          decode_inlined_item: decode_inlined_item)\n-                       -> csearch::found_ast {\n+pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt, id: ast::NodeId,\n+                          decode_inlined_item: DecodeInlinedItem)\n+                          -> csearch::found_ast {\n     debug!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data());\n-    let path = {\n-        let item_path = item_path(item_doc);\n-        item_path.init().to_owned()\n-    };\n-    match decode_inlined_item(cdata, tcx, /*bad*/path.clone(), item_doc) {\n-      Some(ref ii) => csearch::found(*ii),\n-      None => {\n-        match item_parent_item(item_doc) {\n-          Some(did) => {\n-            let did = translate_def_id(cdata, did);\n-            let parent_item = lookup_item(did.node, cdata.data());\n-            match decode_inlined_item(cdata, tcx, path, parent_item) {\n-              Some(ref ii) => csearch::found_parent(did, *ii),\n-              None => csearch::not_found\n+    let path = item_path(item_doc).init().to_owned();\n+    match decode_inlined_item(cdata, tcx, path, item_doc) {\n+        Ok(ref ii) => csearch::found(*ii),\n+        Err(path) => {\n+            match item_parent_item(item_doc) {\n+                Some(did) => {\n+                    let did = translate_def_id(cdata, did);\n+                    let parent_item = lookup_item(did.node, cdata.data());\n+                    match decode_inlined_item(cdata, tcx, path, parent_item) {\n+                        Ok(ref ii) => csearch::found_parent(did, *ii),\n+                        Err(_) => csearch::not_found\n+                    }\n+                }\n+                None => csearch::not_found\n             }\n-          }\n-          None => csearch::not_found\n         }\n-      }\n     }\n }\n \n@@ -835,7 +812,7 @@ pub fn get_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n     let name = item_name(intr, method_doc);\n     let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n                                              tag_item_method_tps);\n-    let rp_defs = item_region_param_defs(method_doc, tcx, cdata);\n+    let rp_defs = item_region_param_defs(method_doc, cdata);\n     let fty = doc_method_fty(method_doc, tcx, cdata);\n     let vis = item_visibility(method_doc);\n     let explicit_self = get_explicit_self(method_doc);\n@@ -1109,13 +1086,13 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n     return attrs;\n }\n \n-fn list_crate_attributes(intr: @IdentInterner, md: ebml::Doc, hash: &str,\n+fn list_crate_attributes(md: ebml::Doc, hash: &str,\n                          out: &mut io::Writer) -> io::IoResult<()> {\n     if_ok!(write!(out, \"=Crate Attributes ({})=\\n\", hash));\n \n     let r = get_attributes(md);\n     for attr in r.iter() {\n-        if_ok!(write!(out, \"{}\\n\", pprust::attribute_to_str(attr, intr)));\n+        if_ok!(write!(out, \"{}\\n\", pprust::attribute_to_str(attr)));\n     }\n \n     write!(out, \"\\n\\n\")\n@@ -1158,11 +1135,10 @@ fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n \n     let r = get_crate_deps(data);\n     for dep in r.iter() {\n-        let string = token::get_ident(dep.name.name);\n         if_ok!(write!(out,\n                       \"{} {}-{}-{}\\n\",\n                       dep.cnum,\n-                      string.get(),\n+                      token::get_ident(dep.name),\n                       dep.hash,\n                       dep.vers));\n     }\n@@ -1185,11 +1161,10 @@ pub fn get_crate_vers(data: &[u8]) -> ~str {\n     }\n }\n \n-pub fn list_crate_metadata(intr: @IdentInterner, bytes: &[u8],\n-                           out: &mut io::Writer) -> io::IoResult<()> {\n+pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n-    if_ok!(list_crate_attributes(intr, md, hash, out));\n+    if_ok!(list_crate_attributes(md, hash, out));\n     list_crate_deps(bytes, out)\n }\n "}, {"sha": "5fb3f48bd6e32e567126b5ba957dd659146bfa59", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 150, "deletions": 225, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -28,10 +28,10 @@ use std::cell::{Cell, RefCell};\n use std::hashmap::{HashMap, HashSet};\n use std::io::MemWriter;\n use std::str;\n-use std::vec;\n use syntax::abi::AbiSet;\n use syntax::ast::*;\n use syntax::ast;\n+use syntax::ast_map::{PathElem, PathElems};\n use syntax::ast_map;\n use syntax::ast_util::*;\n use syntax::ast_util;\n@@ -57,10 +57,9 @@ pub enum InlinedItemRef<'a> {\n     IIForeignRef(&'a ast::ForeignItem)\n }\n \n-pub type encode_inlined_item<'a> = 'a |ecx: &EncodeContext,\n-                                       ebml_w: &mut writer::Encoder,\n-                                       path: &[ast_map::PathElem],\n-                                       ii: InlinedItemRef|;\n+pub type EncodeInlinedItem<'a> = 'a |ecx: &EncodeContext,\n+                                     ebml_w: &mut writer::Encoder,\n+                                     ii: InlinedItemRef|;\n \n pub struct EncodeParams<'a> {\n     diag: @SpanHandler,\n@@ -70,7 +69,7 @@ pub struct EncodeParams<'a> {\n     non_inlineable_statics: &'a RefCell<HashSet<ast::NodeId>>,\n     link_meta: &'a LinkMeta,\n     cstore: @cstore::CStore,\n-    encode_inlined_item: encode_inlined_item<'a>,\n+    encode_inlined_item: EncodeInlinedItem<'a>,\n     reachable: @RefCell<HashSet<ast::NodeId>>,\n     codemap: @codemap::CodeMap,\n }\n@@ -100,7 +99,7 @@ pub struct EncodeContext<'a> {\n     non_inlineable_statics: &'a RefCell<HashSet<ast::NodeId>>,\n     link_meta: &'a LinkMeta,\n     cstore: &'a cstore::CStore,\n-    encode_inlined_item: encode_inlined_item<'a>,\n+    encode_inlined_item: EncodeInlinedItem<'a>,\n     type_abbrevs: abbrev_map,\n     reachable: @RefCell<HashSet<ast::NodeId>>,\n     codemap: @codemap::CodeMap,\n@@ -111,17 +110,12 @@ pub fn reachable(ecx: &EncodeContext, id: NodeId) -> bool {\n     reachable.get().contains(&id)\n }\n \n-fn encode_name(ecx: &EncodeContext,\n-               ebml_w: &mut writer::Encoder,\n-               name: Ident) {\n-    ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n+fn encode_name(ebml_w: &mut writer::Encoder, name: Ident) {\n+    ebml_w.wr_tagged_str(tag_paths_data_name, token::get_ident(name).get());\n }\n \n-fn encode_impl_type_basename(ecx: &EncodeContext,\n-                             ebml_w: &mut writer::Encoder,\n-                             name: Ident) {\n-    ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n-                         ecx.tcx.sess.str_of(name));\n+fn encode_impl_type_basename(ebml_w: &mut writer::Encoder, name: Ident) {\n+    ebml_w.wr_tagged_str(tag_item_impl_type_basename, token::get_ident(name).get());\n }\n \n pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: DefId) {\n@@ -188,13 +182,12 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n }\n \n fn encode_region_param_defs(ebml_w: &mut writer::Encoder,\n-                            ecx: &EncodeContext,\n                             params: &[ty::RegionParameterDef]) {\n     for param in params.iter() {\n         ebml_w.start_tag(tag_region_param_def);\n \n         ebml_w.start_tag(tag_region_param_def_ident);\n-        encode_name(ecx, ebml_w, param.ident);\n+        encode_name(ebml_w, param.ident);\n         ebml_w.end_tag();\n \n         ebml_w.wr_tagged_str(tag_region_param_def_def_id,\n@@ -218,7 +211,7 @@ fn encode_bounds_and_type(ebml_w: &mut writer::Encoder,\n                           tpt: &ty::ty_param_bounds_and_ty) {\n     encode_ty_type_param_defs(ebml_w, ecx, tpt.generics.type_param_defs(),\n                               tag_items_data_item_ty_param_bounds);\n-    encode_region_param_defs(ebml_w, ecx, tpt.generics.region_param_defs());\n+    encode_region_param_defs(ebml_w, tpt.generics.region_param_defs());\n     encode_type(ecx, ebml_w, tpt.ty);\n }\n \n@@ -311,15 +304,14 @@ fn encode_parent_item(ebml_w: &mut writer::Encoder, id: DefId) {\n     ebml_w.end_tag();\n }\n \n-fn encode_struct_fields(ecx: &EncodeContext,\n-                             ebml_w: &mut writer::Encoder,\n-                             def: @StructDef) {\n+fn encode_struct_fields(ebml_w: &mut writer::Encoder,\n+                        def: @StructDef) {\n     for f in def.fields.iter() {\n         match f.node.kind {\n             NamedField(ident, vis) => {\n                ebml_w.start_tag(tag_item_field);\n                encode_struct_field_family(ebml_w, vis);\n-               encode_name(ecx, ebml_w, ident);\n+               encode_name(ebml_w, ident);\n                encode_def_id(ebml_w, local_def(f.node.id));\n                ebml_w.end_tag();\n             }\n@@ -336,7 +328,6 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             ebml_w: &mut writer::Encoder,\n                             id: NodeId,\n                             variants: &[P<Variant>],\n-                            path: &[ast_map::PathElem],\n                             index: @RefCell<~[entry<i64>]>,\n                             generics: &ast::Generics) {\n     debug!(\"encode_enum_variant_info(id={:?})\", id);\n@@ -360,7 +351,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             ast::TupleVariantKind(_) => encode_family(ebml_w, 'v'),\n             ast::StructVariantKind(_) => encode_family(ebml_w, 'V')\n         }\n-        encode_name(ecx, ebml_w, variant.node.name);\n+        encode_name(ebml_w, variant.node.name);\n         encode_parent_item(ebml_w, local_def(id));\n         encode_visibility(ebml_w, variant.node.vis);\n         encode_attributes(ebml_w, variant.node.attrs);\n@@ -371,9 +362,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             }\n             ast::TupleVariantKind(_) => {},\n             ast::StructVariantKind(def) => {\n-                let idx = encode_info_for_struct(ecx, ebml_w, path,\n-                                         def.fields, index);\n-                encode_struct_fields(ecx, ebml_w, def);\n+                let idx = encode_info_for_struct(ecx, ebml_w, def.fields, index);\n+                encode_struct_fields(ebml_w, def);\n                 let bkts = create_index(idx);\n                 encode_index(ebml_w, bkts, write_i64);\n             }\n@@ -384,60 +374,40 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         }\n         encode_bounds_and_type(ebml_w, ecx,\n                                &lookup_item_type(ecx.tcx, def_id));\n-        encode_path(ecx, ebml_w, path,\n-                    ast_map::PathName(variant.node.name));\n+\n+        ecx.tcx.map.with_path(variant.node.id, |path| encode_path(ebml_w, path));\n         ebml_w.end_tag();\n         disr_val += 1;\n         i += 1;\n     }\n }\n \n-fn encode_path(ecx: &EncodeContext,\n-               ebml_w: &mut writer::Encoder,\n-               path: &[ast_map::PathElem],\n-               name: ast_map::PathElem) {\n-    fn encode_path_elem(ecx: &EncodeContext,\n-                       ebml_w: &mut writer::Encoder,\n-                       elt: ast_map::PathElem) {\n-        match elt {\n-            ast_map::PathMod(n) => {\n-                ebml_w.wr_tagged_str(tag_path_elem_mod, ecx.tcx.sess.str_of(n));\n-            }\n-            ast_map::PathName(n) => {\n-                ebml_w.wr_tagged_str(tag_path_elem_name, ecx.tcx.sess.str_of(n));\n-            }\n-            ast_map::PathPrettyName(n, extra) => {\n-                ebml_w.start_tag(tag_path_elem_pretty_name);\n-                ebml_w.wr_tagged_str(tag_path_elem_pretty_name_ident,\n-                                     ecx.tcx.sess.str_of(n));\n-                ebml_w.wr_tagged_u64(tag_path_elem_pretty_name_extra, extra);\n-                ebml_w.end_tag();\n-            }\n-        }\n-    }\n-\n+fn encode_path<PI: Iterator<PathElem> + Clone>(ebml_w: &mut writer::Encoder,\n+                                               mut path: PI) {\n     ebml_w.start_tag(tag_path);\n-    ebml_w.wr_tagged_u32(tag_path_len, (path.len() + 1) as u32);\n-    for pe in path.iter() {\n-        encode_path_elem(ecx, ebml_w, *pe);\n+    ebml_w.wr_tagged_u32(tag_path_len, path.clone().len() as u32);\n+    for pe in path {\n+        let tag = match pe {\n+            ast_map::PathMod(_) => tag_path_elem_mod,\n+            ast_map::PathName(_) => tag_path_elem_name\n+        };\n+        ebml_w.wr_tagged_str(tag, token::get_name(pe.name()).get());\n     }\n-    encode_path_elem(ecx, ebml_w, name);\n     ebml_w.end_tag();\n }\n \n-fn encode_reexported_static_method(ecx: &EncodeContext,\n-                                   ebml_w: &mut writer::Encoder,\n+fn encode_reexported_static_method(ebml_w: &mut writer::Encoder,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: DefId,\n                                    method_ident: Ident) {\n     debug!(\"(encode reexported static method) {}::{}\",\n-            exp.name, ecx.tcx.sess.str_of(method_ident));\n+            exp.name, token::get_ident(method_ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n     ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n     ebml_w.wr_str(def_to_str(method_def_id));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_items_data_item_reexport_name);\n-    ebml_w.wr_str(format!(\"{}::{}\", exp.name, ecx.tcx.sess.str_of(method_ident)));\n+    ebml_w.wr_str(format!(\"{}::{}\", exp.name, token::get_ident(method_ident)));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n@@ -453,8 +423,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n             for &base_impl in implementations.get().iter() {\n                 for &m in base_impl.methods.iter() {\n                     if m.explicit_self == ast::SelfStatic {\n-                        encode_reexported_static_method(ecx, ebml_w, exp,\n-                                                        m.def_id, m.ident);\n+                        encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n                     }\n                 }\n             }\n@@ -474,8 +443,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n         Some(methods) => {\n             for &m in methods.iter() {\n                 if m.explicit_self == ast::SelfStatic {\n-                    encode_reexported_static_method(ecx, ebml_w, exp,\n-                                                    m.def_id, m.ident);\n+                    encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n                 }\n             }\n \n@@ -487,11 +455,22 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n \n fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n-                                    mod_path: &[ast_map::PathElem],\n+                                    mod_path: PathElems,\n                                     exp: &middle::resolve::Export2) {\n-    match ecx.tcx.items.find(exp.def_id.node) {\n-        Some(ast_map::NodeItem(item, path)) => {\n-            let original_name = token::get_ident(item.ident.name);\n+    match ecx.tcx.map.find(exp.def_id.node) {\n+        Some(ast_map::NodeItem(item)) => {\n+            let original_name = token::get_ident(item.ident);\n+\n+            let path_differs = ecx.tcx.map.with_path(exp.def_id.node, |path| {\n+                let (mut a, mut b) = (path, mod_path.clone());\n+                loop {\n+                    match (a.next(), b.next()) {\n+                        (None, None) => return true,\n+                        (None, _) | (_, None) => return false,\n+                        (Some(x), Some(y)) => if x != y { return false },\n+                    }\n+                }\n+            });\n \n             //\n             // We don't need to reexport static methods on items\n@@ -503,7 +482,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n             // encoded metadata for static methods relative to Bar,\n             // but not yet for Foo.\n             //\n-            if mod_path != *path || original_name.get() != exp.name {\n+            if path_differs || original_name.get() != exp.name {\n                 if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n                     if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n                         debug!(\"(encode reexported static methods) {} \\\n@@ -558,7 +537,7 @@ fn each_auxiliary_node_id(item: @Item, callback: |NodeId| -> bool) -> bool {\n fn encode_reexports(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     id: NodeId,\n-                    path: &[ast_map::PathElem]) {\n+                    path: PathElems) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n     let reexports2 = ecx.reexports2.borrow();\n     match reexports2.get().find(&id) {\n@@ -579,7 +558,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                 ebml_w.wr_str(exp.name);\n                 ebml_w.end_tag();\n                 ebml_w.end_tag();\n-                encode_reexported_static_methods(ecx, ebml_w, path, exp);\n+                encode_reexported_static_methods(ecx, ebml_w, path.clone(), exp);\n             }\n         }\n         None => {\n@@ -593,13 +572,13 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        md: &Mod,\n                        id: NodeId,\n-                       path: &[ast_map::PathElem],\n+                       path: PathElems,\n                        name: Ident,\n                        vis: Visibility) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n-    encode_name(ecx, ebml_w, name);\n+    encode_name(ebml_w, name);\n     debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n@@ -620,9 +599,8 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl {} \\\n                         ({:?}/{:?})\",\n-                        ecx.tcx.sess.str_of(ident),\n-                        did,\n-                        ast_map::node_id_to_str(ecx.tcx.items, did, token::get_ident_interner()));\n+                        token::get_ident(ident),\n+                        did, ecx.tcx.map.node_to_str(did));\n \n                 ebml_w.start_tag(tag_mod_impl);\n                 ebml_w.wr_str(def_to_str(local_def(did)));\n@@ -632,7 +610,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         }\n     }\n \n-    encode_path(ecx, ebml_w, path, ast_map::PathMod(name));\n+    encode_path(ebml_w, path.clone());\n     encode_visibility(ebml_w, vis);\n \n     // Encode the reexports of this module, if this module is public.\n@@ -709,7 +687,6 @@ fn encode_provided_source(ebml_w: &mut writer::Encoder,\n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n-                          path: &[ast_map::PathElem],\n                           fields: &[StructField],\n                           global_index: @RefCell<~[entry<i64>]>)\n                           -> ~[entry<i64>] {\n@@ -736,10 +713,9 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         }\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing {} {}\",\n-               tcx.sess.str_of(nm), id);\n+               token::get_ident(nm), id);\n         encode_struct_field_family(ebml_w, vis);\n-        encode_name(ecx, ebml_w, nm);\n-        encode_path(ecx, ebml_w, path, ast_map::PathName(nm));\n+        encode_name(ebml_w, nm);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n         encode_def_id(ebml_w, local_def(id));\n         ebml_w.end_tag();\n@@ -749,7 +725,6 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n \n fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut writer::Encoder,\n-                               path: &[ast_map::PathElem],\n                                name: ast::Ident,\n                                ctor_id: NodeId,\n                                index: @RefCell<~[entry<i64>]>,\n@@ -767,9 +742,9 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     encode_family(ebml_w, 'f');\n     encode_bounds_and_type(ebml_w, ecx,\n                            &lookup_item_type(ecx.tcx, local_def(ctor_id)));\n-    encode_name(ecx, ebml_w, name);\n+    encode_name(ebml_w, name);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, ctor_id));\n-    encode_path(ecx, ebml_w, path, ast_map::PathName(name));\n+    ecx.tcx.map.with_path(ctor_id, |path| encode_path(ebml_w, path));\n     encode_parent_item(ebml_w, local_def(struct_id));\n \n     let item_symbols = ecx.item_symbols.borrow();\n@@ -790,7 +765,7 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            method_ty: &ty::Method) {\n     encode_def_id(ebml_w, method_ty.def_id);\n-    encode_name(ecx, ebml_w, method_ty.ident);\n+    encode_name(ebml_w, method_ty.ident);\n     encode_ty_type_param_defs(ebml_w, ecx,\n                               method_ty.generics.type_param_defs(),\n                               tag_item_method_tps);\n@@ -810,13 +785,13 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n fn encode_info_for_method(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           m: &ty::Method,\n-                          impl_path: &[ast_map::PathElem],\n+                          impl_path: PathElems,\n                           is_default_impl: bool,\n                           parent_id: NodeId,\n                           ast_method_opt: Option<@Method>) {\n \n     debug!(\"encode_info_for_method: {:?} {}\", m.def_id,\n-           ecx.tcx.sess.str_of(m.ident));\n+           token::get_ident(m.ident));\n     ebml_w.start_tag(tag_items_data_item);\n \n     encode_method_ty_fields(ecx, ebml_w, m);\n@@ -826,19 +801,18 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     let tpt = lookup_item_type(ecx.tcx, m.def_id);\n     encode_bounds_and_type(ebml_w, ecx, &tpt);\n \n-    encode_path(ecx, ebml_w, impl_path, ast_map::PathName(m.ident));\n+    let elem = ast_map::PathName(m.ident.name);\n+    encode_path(ebml_w, impl_path.chain(Some(elem).move_iter()));\n     match ast_method_opt {\n         Some(ast_method) => encode_attributes(ebml_w, ast_method.attrs),\n         None => ()\n     }\n \n     for &ast_method in ast_method_opt.iter() {\n         let num_params = tpt.generics.type_param_defs().len();\n-        if num_params > 0u || is_default_impl\n-            || should_inline(ast_method.attrs) {\n+        if num_params > 0u || is_default_impl || should_inline(ast_method.attrs) {\n             (ecx.encode_inlined_item)(\n-                ecx, ebml_w, impl_path,\n-                IIMethodRef(local_def(parent_id), false, ast_method));\n+                ecx, ebml_w, IIMethodRef(local_def(parent_id), false, ast_method));\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n@@ -912,7 +886,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: &Item,\n                         index: @RefCell<~[entry<i64>]>,\n-                        path: &[ast_map::PathElem],\n+                        path: PathElems,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n@@ -941,18 +915,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n-        encode_name(ecx, ebml_w, item.ident);\n-        let elt = ast_map::PathPrettyName(item.ident, item.id as u64);\n-        encode_path(ecx, ebml_w, path, elt);\n+        encode_name(ebml_w, item.ident);\n+        encode_path(ebml_w, path);\n \n-        let non_inlineable;\n-        {\n-            let non_inlineable_statics = ecx.non_inlineable_statics.borrow();\n-            non_inlineable = non_inlineable_statics.get().contains(&item.id);\n-        }\n+        let inlineable = !ecx.non_inlineable_statics.borrow().get().contains(&item.id);\n \n-        if !non_inlineable {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, IIItemRef(item));\n+        if inlineable {\n+            (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n         }\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n@@ -964,11 +933,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(ebml_w, purity_fn_family(purity));\n         let tps_len = generics.ty_params.len();\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n+        encode_name(ebml_w, item.ident);\n+        encode_path(ebml_w, path);\n         encode_attributes(ebml_w, item.attrs);\n         if tps_len > 0u || should_inline(item.attrs) {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, IIItemRef(item));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n         } else {\n             encode_symbol(ecx, ebml_w, item.id);\n         }\n@@ -990,8 +959,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'n');\n-        encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n+        encode_name(ebml_w, item.ident);\n+        encode_path(ebml_w, path);\n \n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n@@ -1008,8 +977,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'y');\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n+        encode_name(ebml_w, item.ident);\n+        encode_path(ebml_w, path);\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n@@ -1021,13 +990,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(ebml_w, 't');\n         encode_item_variances(ebml_w, ecx, item.id);\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ecx, ebml_w, item.ident);\n+        encode_name(ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n-        (ecx.encode_inlined_item)(ecx, ebml_w, path, IIItemRef(item));\n-        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n+        (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n+        encode_path(ebml_w, path);\n \n         // Encode inherent implementations for this enumeration.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n@@ -1039,7 +1008,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  ebml_w,\n                                  item.id,\n                                  (*enum_definition).variants,\n-                                 path,\n                                  index,\n                                  generics);\n       }\n@@ -1048,7 +1016,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n            class itself */\n-        let idx = encode_info_for_struct(ecx, ebml_w, path,\n+        let idx = encode_info_for_struct(ecx, ebml_w,\n                                          struct_def.fields, index);\n \n         /* Index the class*/\n@@ -1061,17 +1029,17 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n \n         encode_item_variances(ebml_w, ecx, item.id);\n-        encode_name(ecx, ebml_w, item.ident);\n+        encode_name(ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n-        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n+        encode_path(ebml_w, path.clone());\n         encode_visibility(ebml_w, vis);\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(ecx, ebml_w, struct_def);\n+        encode_struct_fields(ebml_w, struct_def);\n \n-        (ecx.encode_inlined_item)(ecx, ebml_w, path, IIItemRef(item));\n+        (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n@@ -1081,22 +1049,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_index(ebml_w, bkts, write_i64);\n         ebml_w.end_tag();\n \n-        // If this is a tuple- or enum-like struct, encode the type of the\n-        // constructor.\n-        if struct_def.fields.len() > 0 &&\n-                struct_def.fields[0].node.kind == ast::UnnamedField {\n-            let ctor_id = match struct_def.ctor_id {\n-                Some(ctor_id) => ctor_id,\n-                None => ecx.tcx.sess.bug(\"struct def didn't have ctor id\"),\n-            };\n-\n-            encode_info_for_struct_ctor(ecx,\n-                                        ebml_w,\n-                                        path,\n-                                        item.ident,\n-                                        ctor_id,\n-                                        index,\n-                                        def_id.node);\n+        // If this is a tuple-like struct, encode the type of the constructor.\n+        match struct_def.ctor_id {\n+            Some(ctor_id) => {\n+                encode_info_for_struct_ctor(ecx, ebml_w, item.ident,\n+                                            ctor_id, index, def_id.node);\n+            }\n+            None => {}\n         }\n       }\n       ItemImpl(_, ref opt_trait, ty, ref ast_methods) => {\n@@ -1110,14 +1069,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'i');\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n-        encode_name(ecx, ebml_w, item.ident);\n+        encode_name(ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n             ast::TyPath(ref path, ref bounds, _) if path.segments\n                                                         .len() == 1 => {\n                 assert!(bounds.is_none());\n-                encode_impl_type_basename(ecx, ebml_w,\n-                                          ast_util::path_to_ident(path));\n+                encode_impl_type_basename(ebml_w, ast_util::path_to_ident(path));\n             }\n             _ => {}\n         }\n@@ -1134,14 +1092,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let impl_vtables = ty::lookup_impl_vtables(tcx, def_id);\n             encode_impl_vtables(ebml_w, ecx, &impl_vtables);\n         }\n-        let elt = ast_map::impl_pretty_name(opt_trait, ty);\n-        encode_path(ecx, ebml_w, path, elt);\n+        encode_path(ebml_w, path.clone());\n         ebml_w.end_tag();\n \n-        // >:-<\n-        let mut impl_path = vec::append(~[], path);\n-        impl_path.push(elt);\n-\n         // Iterate down the methods, emitting them. We rely on the\n         // assumption that all of the actually implemented methods\n         // appear first in the impl structure, in the same order they do\n@@ -1162,7 +1115,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_info_for_method(ecx,\n                                    ebml_w,\n                                    *m,\n-                                   impl_path,\n+                                   path.clone(),\n                                    false,\n                                    item.id,\n                                    ast_method)\n@@ -1178,10 +1131,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_ty_type_param_defs(ebml_w, ecx,\n                                   trait_def.generics.type_param_defs(),\n                                   tag_items_data_item_ty_param_bounds);\n-        encode_region_param_defs(ebml_w, ecx,\n-                                 trait_def.generics.region_param_defs());\n+        encode_region_param_defs(ebml_w, trait_def.generics.region_param_defs());\n         encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n-        encode_name(ecx, ebml_w, item.ident);\n+        encode_name(ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         encode_visibility(ebml_w, vis);\n         for &method_def_id in ty::trait_method_def_ids(tcx, def_id).iter() {\n@@ -1193,7 +1145,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             ebml_w.wr_str(def_to_str(method_def_id));\n             ebml_w.end_tag();\n         }\n-        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n+        encode_path(ebml_w, path.clone());\n         // FIXME(#8559): This should use the tcx's supertrait cache instead of\n         // reading the AST's list, because the former has already filtered out\n         // the builtin-kinds-as-supertraits. See corresponding fixme in decoder.\n@@ -1228,9 +1180,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             encode_parent_item(ebml_w, def_id);\n \n-            let mut trait_path = vec::append(~[], path);\n-            trait_path.push(ast_map::PathName(item.ident));\n-            encode_path(ecx, ebml_w, trait_path, ast_map::PathName(method_ty.ident));\n+            let elem = ast_map::PathName(method_ty.ident.name);\n+            encode_path(ebml_w, path.clone().chain(Some(elem).move_iter()));\n \n             match method_ty.explicit_self {\n                 SelfStatic => {\n@@ -1266,8 +1217,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     }\n                     encode_method_sort(ebml_w, 'p');\n                     (ecx.encode_inlined_item)(\n-                        ecx, ebml_w, path,\n-                        IIMethodRef(def_id, true, m));\n+                        ecx, ebml_w, IIMethodRef(def_id, true, m));\n                 }\n             }\n \n@@ -1287,7 +1237,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n                                 nitem: &ForeignItem,\n                                 index: @RefCell<~[entry<i64>]>,\n-                                path: &ast_map::Path,\n+                                path: PathElems,\n                                 abi: AbiSet) {\n     {\n         let mut index = index.borrow_mut();\n@@ -1298,89 +1248,72 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     }\n \n     ebml_w.start_tag(tag_items_data_item);\n+    encode_def_id(ebml_w, local_def(nitem.id));\n     match nitem.node {\n       ForeignItemFn(..) => {\n-        encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(ImpureFn));\n         encode_bounds_and_type(ebml_w, ecx,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n-        encode_name(ecx, ebml_w, nitem.ident);\n+        encode_name(ebml_w, nitem.ident);\n         if abi.is_intrinsic() {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, *path, IIForeignRef(nitem));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, IIForeignRef(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }\n-        encode_path(ecx, ebml_w, *path, ast_map::PathName(nitem.ident));\n       }\n       ForeignItemStatic(_, mutbl) => {\n-        encode_def_id(ebml_w, local_def(nitem.id));\n         if mutbl {\n             encode_family(ebml_w, 'b');\n         } else {\n             encode_family(ebml_w, 'c');\n         }\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n-        encode_name(ecx, ebml_w, nitem.ident);\n-        encode_path(ecx, ebml_w, *path, ast_map::PathName(nitem.ident));\n+        encode_name(ebml_w, nitem.ident);\n       }\n     }\n+    encode_path(ebml_w, path);\n     ebml_w.end_tag();\n }\n \n fn my_visit_expr(_e: &Expr) { }\n \n fn my_visit_item(i: &Item,\n-                 items: ast_map::Map,\n                  ebml_w: &mut writer::Encoder,\n                  ecx_ptr: *int,\n                  index: @RefCell<~[entry<i64>]>) {\n-    match items.get(i.id) {\n-        ast_map::NodeItem(_, pt) => {\n-            let mut ebml_w = unsafe {\n-                ebml_w.unsafe_clone()\n-            };\n-            // See above\n-            let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n-            encode_info_for_item(ecx, &mut ebml_w, i, index, *pt, i.vis);\n-        }\n-        _ => fail!(\"bad item\")\n-    }\n+    let mut ebml_w = unsafe { ebml_w.unsafe_clone() };\n+    // See above\n+    let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n+    ecx.tcx.map.with_path(i.id, |path| {\n+        encode_info_for_item(ecx, &mut ebml_w, i, index, path, i.vis);\n+    });\n }\n \n fn my_visit_foreign_item(ni: &ForeignItem,\n-                         items: ast_map::Map,\n                          ebml_w: &mut writer::Encoder,\n                          ecx_ptr:*int,\n                          index: @RefCell<~[entry<i64>]>) {\n-    match items.get(ni.id) {\n-        ast_map::NodeForeignItem(_, abi, _, pt) => {\n-            let string = token::get_ident(ni.ident.name);\n-            debug!(\"writing foreign item {}::{}\",\n-                   ast_map::path_to_str(*pt, token::get_ident_interner()),\n-                   string.get());\n-\n-            let mut ebml_w = unsafe {\n-                ebml_w.unsafe_clone()\n-            };\n-            // See above\n-            let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n-            encode_info_for_foreign_item(ecx,\n-                                         &mut ebml_w,\n-                                         ni,\n-                                         index,\n-                                         pt,\n-                                         abi);\n-        }\n-        // case for separate item and foreign-item tables\n-        _ => fail!(\"bad foreign item\")\n-    }\n+    // See above\n+    let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n+    debug!(\"writing foreign item {}::{}\",\n+            ecx.tcx.map.path_to_str(ni.id),\n+            token::get_ident(ni.ident));\n+\n+    let mut ebml_w = unsafe {\n+        ebml_w.unsafe_clone()\n+    };\n+    let abis = ecx.tcx.map.get_foreign_abis(ni.id);\n+    ecx.tcx.map.with_path(ni.id, |path| {\n+        encode_info_for_foreign_item(ecx, &mut ebml_w,\n+                                     ni, index,\n+                                     path, abis);\n+    });\n }\n \n struct EncodeVisitor<'a,'b> {\n     ebml_w_for_visit_item: &'a mut writer::Encoder<'b>,\n     ecx_ptr:*int,\n-    items: ast_map::Map,\n     index: @RefCell<~[entry<i64>]>,\n }\n \n@@ -1392,15 +1325,13 @@ impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n     fn visit_item(&mut self, i: &Item, _: ()) {\n         visit::walk_item(self, i, ());\n         my_visit_item(i,\n-                      self.items,\n                       self.ebml_w_for_visit_item,\n                       self.ecx_ptr,\n                       self.index);\n     }\n     fn visit_foreign_item(&mut self, ni: &ForeignItem, _: ()) {\n         visit::walk_foreign_item(self, ni, ());\n         my_visit_foreign_item(ni,\n-                              self.items,\n                               self.ebml_w_for_visit_item,\n                               self.ecx_ptr,\n                               self.index);\n@@ -1424,17 +1355,15 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                         ebml_w,\n                         &krate.module,\n                         CRATE_NODE_ID,\n-                        [],\n+                        ast_map::Values([].iter()).chain(None),\n                         syntax::parse::token::special_idents::invalid,\n                         Public);\n-    let items = ecx.tcx.items;\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n-    let ecx_ptr : *int = unsafe { cast::transmute(ecx) };\n+    let ecx_ptr: *int = unsafe { cast::transmute(ecx) };\n     {\n         let mut visitor = EncodeVisitor {\n             index: index,\n-            items: items,\n             ecx_ptr: ecx_ptr,\n             ebml_w_for_visit_item: &mut *ebml_w,\n         };\n@@ -1581,20 +1510,17 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n     attrs\n }\n \n-fn encode_crate_deps(ecx: &EncodeContext,\n-                     ebml_w: &mut writer::Encoder,\n-                     cstore: &cstore::CStore) {\n-    fn get_ordered_deps(ecx: &EncodeContext, cstore: &cstore::CStore)\n-                     -> ~[decoder::CrateDep] {\n-        type numdep = decoder::CrateDep;\n-\n+fn encode_crate_deps(ebml_w: &mut writer::Encoder, cstore: &cstore::CStore) {\n+    fn get_ordered_deps(cstore: &cstore::CStore) -> ~[decoder::CrateDep] {\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = ~[];\n         cstore.iter_crate_data(|key, val| {\n-            let dep = decoder::CrateDep {cnum: key,\n-                       name: ecx.tcx.sess.ident_of(val.name),\n-                       vers: decoder::get_crate_vers(val.data()),\n-                       hash: decoder::get_crate_hash(val.data())};\n+            let dep = decoder::CrateDep {\n+                cnum: key,\n+                name: token::str_to_ident(val.name),\n+                vers: decoder::get_crate_vers(val.data()),\n+                hash: decoder::get_crate_hash(val.data())\n+            };\n             deps.push(dep);\n         });\n \n@@ -1616,9 +1542,9 @@ fn encode_crate_deps(ecx: &EncodeContext,\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ebml_w.start_tag(tag_crate_deps);\n-    let r = get_ordered_deps(ecx, cstore);\n+    let r = get_ordered_deps(cstore);\n     for dep in r.iter() {\n-        encode_crate_dep(ecx, ebml_w, (*dep).clone());\n+        encode_crate_dep(ebml_w, (*dep).clone());\n     }\n     ebml_w.end_tag();\n }\n@@ -1801,19 +1727,18 @@ fn encode_misc_info(ecx: &EncodeContext,\n     }\n \n     // Encode reexports for the root module.\n-    encode_reexports(ecx, ebml_w, 0, []);\n+    encode_reexports(ecx, ebml_w, 0, ast_map::Values([].iter()).chain(None));\n \n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: &EncodeContext,\n-                    ebml_w: &mut writer::Encoder,\n+fn encode_crate_dep(ebml_w: &mut writer::Encoder,\n                     dep: decoder::CrateDep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n-    let s = ecx.tcx.sess.str_of(dep.name);\n-    ebml_w.writer.write(s.as_bytes());\n+    let s = token::get_ident(dep.name);\n+    ebml_w.writer.write(s.get().as_bytes());\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_vers);\n     ebml_w.writer.write(dep.vers.as_bytes());\n@@ -1900,7 +1825,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n     ecx.stats.attr_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     i = ebml_w.writer.tell().unwrap();\n-    encode_crate_deps(&ecx, &mut ebml_w, ecx.cstore);\n+    encode_crate_deps(&mut ebml_w, ecx.cstore);\n     ecx.stats.dep_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode the language items."}, {"sha": "8a7964fcf6b531dda11258fba8ac8b675cf26ce7", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -28,7 +28,6 @@ use std::c_str::ToCStr;\n use std::cast;\n use std::cmp;\n use std::io;\n-use std::option;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::str;\n use std::vec;\n@@ -377,16 +376,10 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-pub fn list_file_metadata(intr: @IdentInterner,\n-                          os: Os,\n-                          path: &Path,\n+pub fn list_file_metadata(os: Os, path: &Path,\n                           out: &mut io::Writer) -> io::IoResult<()> {\n     match get_metadata_section(os, path) {\n-      option::Some(bytes) => decoder::list_crate_metadata(intr,\n-                                                          bytes.as_slice(),\n-                                                          out),\n-      option::None => {\n-          write!(out, \"could not find metadata in {}.\\n\", path.display())\n-      }\n+      Some(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n+      None => write!(out, \"could not find metadata in {}.\\n\", path.display())\n     }\n }"}, {"sha": "ca1aabb74f4efe6e857cc0f6efe9a471d1665298", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -24,6 +24,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::opt_vec;\n+use syntax::parse::token;\n \n // Compact string representation for ty::t values. API ty_str &\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n@@ -96,10 +97,9 @@ pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n }\n \n fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n-    let tcx = st.tcx;\n     scan(st, is_last, |bytes| {\n-            tcx.sess.ident_of(str::from_utf8(bytes).unwrap())\n-        })\n+        token::str_to_ident(str::from_utf8(bytes).unwrap())\n+    })\n }\n \n pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n@@ -212,7 +212,7 @@ fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n         }\n         '[' => {\n             let def = parse_def(st, RegionParameter, |x,y| conv(x,y));\n-            let ident = st.tcx.sess.ident_of(parse_str(st, ']'));\n+            let ident = token::str_to_ident(parse_str(st, ']'));\n             ty::BrNamed(def, ident)\n         }\n         'f' => {\n@@ -240,7 +240,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n         assert_eq!(next(st), '|');\n         let index = parse_uint(st);\n         assert_eq!(next(st), '|');\n-        let nm = st.tcx.sess.ident_of(parse_str(st, ']'));\n+        let nm = token::str_to_ident(parse_str(st, ']'));\n         ty::ReEarlyBound(node_id, index, nm)\n       }\n       'f' => {"}, {"sha": "d6245f13245f3451929934e24e4c87eb384d85d1", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -26,6 +26,7 @@ use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::diagnostic::SpanHandler;\n+use syntax::parse::token;\n use syntax::print::pprust::*;\n \n macro_rules! mywrite( ($wr:expr, $($arg:tt)*) => (\n@@ -177,7 +178,7 @@ fn enc_region(w: &mut MemWriter, cx: @ctxt, r: ty::Region) {\n             mywrite!(w, \"B[{}|{}|{}]\",\n                      node_id,\n                      index,\n-                     cx.tcx.sess.str_of(ident));\n+                     token::get_ident(ident));\n         }\n         ty::ReFree(ref fr) => {\n             mywrite!(w, \"f[{}|\", fr.scope_id);\n@@ -208,7 +209,7 @@ fn enc_bound_region(w: &mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n         ty::BrNamed(d, s) => {\n             mywrite!(w, \"[{}|{}]\",\n                      (cx.ds)(d),\n-                     cx.tcx.sess.str_of(s));\n+                     token::get_ident(s));\n         }\n         ty::BrFresh(id) => {\n             mywrite!(w, \"f{}|\", id);\n@@ -420,7 +421,7 @@ fn enc_bounds(w: &mut MemWriter, cx: @ctxt, bs: &ty::ParamBounds) {\n }\n \n pub fn enc_type_param_def(w: &mut MemWriter, cx: @ctxt, v: &ty::TypeParameterDef) {\n-    mywrite!(w, \"{}:{}|\", cx.tcx.sess.str_of(v.ident), (cx.ds)(v.def_id));\n+    mywrite!(w, \"{}:{}|\", token::get_ident(v.ident), (cx.ds)(v.def_id));\n     enc_bounds(w, cx, v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n }"}, {"sha": "5759cc605728451fe49a7513bb4dd7dc82f41563", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -27,7 +27,6 @@ use util::ppaux::ty_to_str;\n \n use syntax::{ast, ast_map, ast_util, codemap, fold};\n use syntax::codemap::Span;\n-use syntax::diagnostic::SpanHandler;\n use syntax::fold::Folder;\n use syntax::parse::token;\n use syntax;\n@@ -80,17 +79,15 @@ trait tr_intern {\n \n pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n-                           path: &[ast_map::PathElem],\n                            ii: e::InlinedItemRef,\n                            maps: Maps) {\n-    let ident = match ii {\n-        e::IIItemRef(i) => i.ident,\n-        e::IIForeignRef(i) => i.ident,\n-        e::IIMethodRef(_, _, m) => m.ident,\n+    let id = match ii {\n+        e::IIItemRef(i) => i.id,\n+        e::IIForeignRef(i) => i.id,\n+        e::IIMethodRef(_, _, m) => m.id,\n     };\n-    debug!(\"> Encoding inlined item: {}::{} ({})\",\n-           ast_map::path_to_str(path, token::get_ident_interner()),\n-           ecx.tcx.sess.str_of(ident),\n+    debug!(\"> Encoding inlined item: {} ({})\",\n+           ecx.tcx.map.path_to_str(id),\n            ebml_w.writer.tell());\n \n     let ii = simplify_ast(ii);\n@@ -102,9 +99,8 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n     ebml_w.end_tag();\n \n-    debug!(\"< Encoded inlined fn: {}::{} ({})\",\n-           ast_map::path_to_str(path, token::get_ident_interner()),\n-           ecx.tcx.sess.str_of(ident),\n+    debug!(\"< Encoded inlined fn: {} ({})\",\n+           ecx.tcx.map.path_to_str(id),\n            ebml_w.writer.tell());\n }\n \n@@ -118,19 +114,25 @@ pub fn encode_exported_macro(ebml_w: &mut writer::Encoder, i: &ast::Item) {\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n-                           path: &[ast_map::PathElem],\n+                           path: ~[ast_map::PathElem],\n                            par_doc: ebml::Doc)\n-                        -> Option<ast::InlinedItem> {\n+                           -> Result<ast::InlinedItem, ~[ast_map::PathElem]> {\n     let dcx = @DecodeContext {\n         cdata: cdata,\n         tcx: tcx,\n         maps: maps\n     };\n     match par_doc.opt_child(c::tag_ast) {\n-      None => None,\n+      None => Err(path),\n       Some(ast_doc) => {\n+        let mut path_as_str = None;\n         debug!(\"> Decoding inlined fn: {}::?\",\n-               ast_map::path_to_str(path, token::get_ident_interner()));\n+        {\n+            // Do an Option dance to use the path after it is moved below.\n+            let s = ast_map::path_to_str(ast_map::Values(path.iter()));\n+            path_as_str = Some(s);\n+            path_as_str.as_ref().map(|x| x.as_slice())\n+        });\n         let mut ast_dsr = reader::Decoder(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n@@ -140,30 +142,26 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n             to_id_range: to_id_range\n         };\n         let raw_ii = decode_ast(ast_doc);\n-        let ii = renumber_and_map_ast(xcx,\n-                                      tcx.sess.diagnostic(),\n-                                      dcx.tcx.items,\n-                                      path.to_owned(),\n-                                      raw_ii);\n+        let ii = renumber_and_map_ast(xcx, &dcx.tcx.map, path, raw_ii);\n         let ident = match ii {\n             ast::IIItem(i) => i.ident,\n             ast::IIForeign(i) => i.ident,\n             ast::IIMethod(_, _, m) => m.ident,\n         };\n-        debug!(\"Fn named: {}\", tcx.sess.str_of(ident));\n+        debug!(\"Fn named: {}\", token::get_ident(ident));\n         debug!(\"< Decoded inlined fn: {}::{}\",\n-               ast_map::path_to_str(path, token::get_ident_interner()),\n-               tcx.sess.str_of(ident));\n+               path_as_str.unwrap(),\n+               token::get_ident(ident));\n         region::resolve_inlined_item(tcx.sess, &tcx.region_maps, &ii);\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n           ast::IIItem(i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_str(i, tcx.sess.intr()));\n+                   syntax::print::pprust::item_to_str(i));\n           }\n           _ => { }\n         }\n-        Some(ii)\n+        Ok(ii)\n       }\n     }\n }\n@@ -381,19 +379,23 @@ struct AstRenumberer {\n \n impl ast_map::FoldOps for AstRenumberer {\n     fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n-        self.xcx.tr_id(id)\n+        if id == ast::DUMMY_NODE_ID {\n+            // Used by ast_map to map the NodeInlinedParent.\n+            self.xcx.dcx.tcx.sess.next_node_id()\n+        } else {\n+            self.xcx.tr_id(id)\n+        }\n     }\n     fn new_span(&self, span: Span) -> Span {\n         self.xcx.tr_span(span)\n     }\n }\n \n fn renumber_and_map_ast(xcx: @ExtendedDecodeContext,\n-                        diag: @SpanHandler,\n-                        map: ast_map::Map,\n-                        path: ast_map::Path,\n+                        map: &ast_map::Map,\n+                        path: ~[ast_map::PathElem],\n                         ii: ast::InlinedItem) -> ast::InlinedItem {\n-    ast_map::map_decoded_item(diag, map, path, AstRenumberer { xcx: xcx }, |fld| {\n+    ast_map::map_decoded_item(map, path, AstRenumberer { xcx: xcx }, |fld| {\n         match ii {\n             ast::IIItem(i) => {\n                 ast::IIItem(fld.fold_item(i).expect_one(\"expected one item\"))\n@@ -1508,10 +1510,7 @@ fn test_simplification() {\n     ).unwrap());\n     match (item_out, item_exp) {\n       (ast::IIItem(item_out), ast::IIItem(item_exp)) => {\n-        assert!(pprust::item_to_str(item_out,\n-                                    token::get_ident_interner())\n-                     == pprust::item_to_str(item_exp,\n-                                            token::get_ident_interner()));\n+        assert!(pprust::item_to_str(item_out) == pprust::item_to_str(item_exp));\n       }\n       _ => fail!()\n     }"}, {"sha": "1f90d2d8f0f8d3a67a30cf18ba479c6fd2b6eadd", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -23,10 +23,8 @@ use middle::borrowck::*;\n use middle::moves;\n use middle::ty;\n use syntax::ast;\n-use syntax::ast_map;\n use syntax::ast_util;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n use util::ppaux::Repr;\n@@ -336,8 +334,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 old_loan.span,\n                 format!(\"{}; {}\", borrow_summary, rule_summary));\n \n-            let old_loan_span = ast_map::node_span(self.tcx().items,\n-                                                   old_loan.kill_scope);\n+            let old_loan_span = self.tcx().map.span(old_loan.kill_scope);\n             self.bccx.span_end_note(old_loan_span,\n                                     \"previous borrow ends here\");\n \n@@ -759,9 +756,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                                  mut move_path: @LoanPath)\n                                  -> MoveError {\n         debug!(\"analyze_move_out_from(expr_id={:?}, move_path={})\",\n-               ast_map::node_id_to_str(self.tcx().items,\n-                                       expr_id,\n-                                       token::get_ident_interner()),\n+               self.tcx().map.node_to_str(expr_id),\n                move_path.repr(self.tcx()));\n \n         // We must check every element of a move path. See"}, {"sha": "15922d57ba83cc3378c7e135827add9b1c66e287", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -185,7 +185,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     let tcx = bccx.tcx;\n \n     debug!(\"gather_loans_in_expr(expr={:?}/{})\",\n-           ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n+           ex.id, pprust::expr_to_str(ex));\n \n     this.id_range.add(ex.id);\n "}, {"sha": "042201040d91c7131a9a01100aa066301ae3a76f", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -552,7 +552,7 @@ impl BorrowckCtxt {\n             move_data::Declared => {}\n \n             move_data::MoveExpr => {\n-                let (expr_ty, expr_span) = match self.tcx.items.find(move.id) {\n+                let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n                         (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n                     }\n@@ -570,16 +570,15 @@ impl BorrowckCtxt {\n \n             move_data::MovePat => {\n                 let pat_ty = ty::node_id_to_type(self.tcx, move.id);\n-                self.tcx.sess.span_note(\n-                    ast_map::node_span(self.tcx.items, move.id),\n+                self.tcx.sess.span_note(self.tcx.map.span(move.id),\n                     format!(\"`{}` moved here because it has type `{}`, \\\n                           which is moved by default (use `ref` to override)\",\n                          self.loan_path_to_str(moved_lp),\n                          pat_ty.user_string(self.tcx)));\n             }\n \n             move_data::Captured => {\n-                let (expr_ty, expr_span) = match self.tcx.items.find(move.id) {\n+                let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n                         (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n                     }\n@@ -793,10 +792,9 @@ impl BorrowckCtxt {\n             LpExtend(lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n                 self.append_autoderefd_loan_path_to_str(lp_base, out);\n                 match fname {\n-                    mc::NamedField(ref fname) => {\n-                        let string = token::get_ident(*fname);\n+                    mc::NamedField(fname) => {\n                         out.push_char('.');\n-                        out.push_str(string.get());\n+                        out.push_str(token::get_name(fname).get());\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push_char('#'); // invent a notation here\n@@ -892,10 +890,7 @@ impl Repr for LoanPath {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match self {\n             &LpVar(id) => {\n-                format!(\"$({})\",\n-                        ast_map::node_id_to_str(tcx.items,\n-                                                id,\n-                                                token::get_ident_interner()))\n+                format!(\"$({})\", tcx.map.node_to_str(id))\n             }\n \n             &LpExtend(lp, _, LpDeref(_)) => {"}, {"sha": "88ade3e225a04d17a1ee1824f691b6db06c0009e", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -22,15 +22,14 @@ use syntax::visit;\n \n struct CheckCrateVisitor {\n     sess: Session,\n-    ast_map: ast_map::Map,\n     def_map: resolve::DefMap,\n     method_map: typeck::method_map,\n     tcx: ty::ctxt,\n }\n \n impl Visitor<bool> for CheckCrateVisitor {\n     fn visit_item(&mut self, i: &Item, env: bool) {\n-        check_item(self, self.sess, self.ast_map, self.def_map, i, env);\n+        check_item(self, self.sess, self.def_map, i, env);\n     }\n     fn visit_pat(&mut self, p: &Pat, env: bool) {\n         check_pat(self, p, env);\n@@ -43,13 +42,11 @@ impl Visitor<bool> for CheckCrateVisitor {\n \n pub fn check_crate(sess: Session,\n                    krate: &Crate,\n-                   ast_map: ast_map::Map,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::method_map,\n                    tcx: ty::ctxt) {\n     let mut v = CheckCrateVisitor {\n         sess: sess,\n-        ast_map: ast_map,\n         def_map: def_map,\n         method_map: method_map,\n         tcx: tcx,\n@@ -60,14 +57,13 @@ pub fn check_crate(sess: Session,\n \n pub fn check_item(v: &mut CheckCrateVisitor,\n                   sess: Session,\n-                  ast_map: ast_map::Map,\n                   def_map: resolve::DefMap,\n                   it: &Item,\n                   _is_const: bool) {\n     match it.node {\n         ItemStatic(_, _, ex) => {\n             v.visit_expr(ex, true);\n-            check_item_recursion(sess, ast_map, def_map, it);\n+            check_item_recursion(sess, &v.tcx.map, def_map, it);\n         }\n         ItemEnum(ref enum_definition, _) => {\n             for var in (*enum_definition).variants.iter() {\n@@ -209,17 +205,17 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n struct CheckItemRecursionVisitor<'a> {\n     root_it: &'a Item,\n     sess: Session,\n-    ast_map: ast_map::Map,\n+    ast_map: &'a ast_map::Map,\n     def_map: resolve::DefMap,\n     idstack: ~[NodeId]\n }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n-pub fn check_item_recursion(sess: Session,\n-                            ast_map: ast_map::Map,\n-                            def_map: resolve::DefMap,\n-                            it: &Item) {\n+pub fn check_item_recursion<'a>(sess: Session,\n+                                ast_map: &'a ast_map::Map,\n+                                def_map: resolve::DefMap,\n+                                it: &'a Item) {\n \n     let mut visitor = CheckItemRecursionVisitor {\n         root_it: it,\n@@ -248,12 +244,7 @@ impl<'a> Visitor<()> for CheckItemRecursionVisitor<'a> {\n                 match def_map.get().find(&e.id) {\n                     Some(&DefStatic(def_id, _)) if\n                             ast_util::is_local(def_id) => {\n-                        match self.ast_map.get(def_id.node) {\n-                            ast_map::NodeItem(it, _) => {\n-                                self.visit_item(it, ());\n-                            }\n-                            _ => fail!(\"const not bound to an item\")\n-                        }\n+                        self.visit_item(self.ast_map.expect_item(def_id.node), ());\n                     }\n                     _ => ()\n                 }"}, {"sha": "cc05516ebac95d81610c085d92fe8a7638c38932", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -24,6 +24,7 @@ use std::vec;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n use syntax::codemap::{DUMMY_SP, Span};\n+use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n \n@@ -189,7 +190,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n                     let variants = ty::enum_variants(cx.tcx, id);\n \n                     match variants.iter().find(|v| v.id == vid) {\n-                        Some(v) => Some(cx.tcx.sess.str_of(v.name)),\n+                        Some(v) => Some(token::get_ident(v.name).get().to_str()),\n                         None => {\n                             fail!(\"check_exhaustive: bad variant in ctor\")\n                         }"}, {"sha": "71223416ae22164ea2850ed0ceaddd71b1ad2a52", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -112,9 +112,9 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n \n     if ast_util::is_local(enum_def) {\n         {\n-            match tcx.items.find(enum_def.node) {\n+            match tcx.map.find(enum_def.node) {\n                 None => None,\n-                Some(ast_map::NodeItem(it, _)) => match it.node {\n+                Some(ast_map::NodeItem(it)) => match it.node {\n                     ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n                         variant_expr(*variants, variant_def.node)\n                     }\n@@ -138,11 +138,9 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n             capture_map: @RefCell::new(HashMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n-            |a, b, c, d| astencode::decode_inlined_item(a,\n-                                                        b,\n+            |a, b, c, d| astencode::decode_inlined_item(a, b,\n                                                         maps,\n-                                                        /*bad*/ c.clone(),\n-                                                        d)) {\n+                                                        c, d)) {\n             csearch::found(ast::IIItem(item)) => match item.node {\n                 ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n                     variant_expr(*variants, variant_def.node)\n@@ -164,9 +162,9 @@ pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n                           -> Option<@Expr> {\n     if ast_util::is_local(def_id) {\n         {\n-            match tcx.items.find(def_id.node) {\n+            match tcx.map.find(def_id.node) {\n                 None => None,\n-                Some(ast_map::NodeItem(it, _)) => match it.node {\n+                Some(ast_map::NodeItem(it)) => match it.node {\n                     ItemStatic(_, ast::MutImmutable, const_expr) => {\n                         Some(const_expr)\n                     }"}, {"sha": "4d22f5414320b837f85339125aa203c42e52135f", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -350,8 +350,7 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n \n     fn pretty_print_to(&self, wr: ~io::Writer,\n                        blk: &ast::Block) -> io::IoResult<()> {\n-        let mut ps = pprust::rust_printer_annotated(wr, self.tcx.sess.intr(),\n-                                                    self as &pprust::PpAnn);\n+        let mut ps = pprust::rust_printer_annotated(wr, self);\n         if_ok!(pprust::cbox(&mut ps, pprust::indent_unit));\n         if_ok!(pprust::ibox(&mut ps, 0u));\n         if_ok!(pprust::print_block(&mut ps, blk));"}, {"sha": "fad44152a2dc12d533a5981aa81ca1763f909d14", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -38,7 +38,7 @@ fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n         return false;\n     }\n \n-    match tcx.items.find(def_id.node) {\n+    match tcx.map.find(def_id.node) {\n         Some(ast_map::NodeItem(..))\n         | Some(ast_map::NodeMethod(..))\n         | Some(ast_map::NodeForeignItem(..))\n@@ -135,7 +135,7 @@ impl MarkSymbolVisitor {\n             }\n             scanned.insert(id);\n \n-            match self.tcx.items.find(id) {\n+            match self.tcx.map.find(id) {\n                 Some(ref node) => {\n                     self.live_symbols.insert(id);\n                     self.visit_node(node);\n@@ -147,7 +147,7 @@ impl MarkSymbolVisitor {\n \n     fn visit_node(&mut self, node: &ast_map::Node) {\n         match *node {\n-            ast_map::NodeItem(item, _) => {\n+            ast_map::NodeItem(item) => {\n                 match item.node {\n                     ast::ItemFn(..)\n                     | ast::ItemTy(..)\n@@ -159,13 +159,13 @@ impl MarkSymbolVisitor {\n                     _ => ()\n                 }\n             }\n-            ast_map::NodeTraitMethod(trait_method, _, _) => {\n+            ast_map::NodeTraitMethod(trait_method) => {\n                 visit::walk_trait_method(self, trait_method, ());\n             }\n-            ast_map::NodeMethod(method, _, _) => {\n+            ast_map::NodeMethod(method) => {\n                 visit::walk_block(self, method.body, ());\n             }\n-            ast_map::NodeForeignItem(foreign_item, _, _, _) => {\n+            ast_map::NodeForeignItem(foreign_item) => {\n                 visit::walk_foreign_item(self, foreign_item, ());\n             }\n             _ => ()\n@@ -359,26 +359,25 @@ impl DeadVisitor {\n     }\n \n     fn warn_dead_code(&mut self, id: ast::NodeId,\n-                      span: codemap::Span, ident: &ast::Ident) {\n-        let string = token::get_ident(ident.name);\n+                      span: codemap::Span, ident: ast::Ident) {\n         self.tcx.sess.add_lint(DeadCode, id, span,\n                                format!(\"code is never used: `{}`\",\n-                                       string.get()));\n+                                       token::get_ident(ident)));\n     }\n }\n \n impl Visitor<()> for DeadVisitor {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let ctor_id = get_struct_ctor_id(item);\n         if !self.symbol_is_live(item.id, ctor_id) && should_warn(item) {\n-            self.warn_dead_code(item.id, item.span, &item.ident);\n+            self.warn_dead_code(item.id, item.span, item.ident);\n         }\n         visit::walk_item(self, item, ());\n     }\n \n     fn visit_foreign_item(&mut self, fi: &ast::ForeignItem, _: ()) {\n         if !self.symbol_is_live(fi.id, None) {\n-            self.warn_dead_code(fi.id, fi.span, &fi.ident);\n+            self.warn_dead_code(fi.id, fi.span, fi.ident);\n         }\n         visit::walk_foreign_item(self, fi, ());\n     }\n@@ -391,7 +390,7 @@ impl Visitor<()> for DeadVisitor {\n             visit::FkMethod(..) => {\n                 let ident = visit::name_of_fn(fk);\n                 if !self.symbol_is_live(id, None) {\n-                    self.warn_dead_code(id, span, &ident);\n+                    self.warn_dead_code(id, span, ident);\n                 }\n             }\n             _ => ()"}, {"sha": "f6af8b86b5d4584bf7785f24c4e06f256b841e45", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -11,18 +11,21 @@\n \n use driver::session;\n use driver::session::Session;\n-use syntax::ast::{Crate, NodeId, Item, ItemFn};\n+use syntax::ast::{Crate, Name, NodeId, Item, ItemFn};\n use syntax::ast_map;\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-struct EntryContext {\n+struct EntryContext<'a> {\n     session: Session,\n \n-    ast_map: ast_map::Map,\n+    ast_map: &'a ast_map::Map,\n+\n+    // The interned Name for \"main\".\n+    main_name: Name,\n \n     // The top-level function called 'main'\n     main_fn: Option<(NodeId, Span)>,\n@@ -38,13 +41,13 @@ struct EntryContext {\n     non_main_fns: ~[(NodeId, Span)],\n }\n \n-impl Visitor<()> for EntryContext {\n+impl<'a> Visitor<()> for EntryContext<'a> {\n     fn visit_item(&mut self, item: &Item, _:()) {\n         find_item(item, self);\n     }\n }\n \n-pub fn find_entry_point(session: Session, krate: &Crate, ast_map: ast_map::Map) {\n+pub fn find_entry_point(session: Session, krate: &Crate, ast_map: &ast_map::Map) {\n     if session.building_library.get() {\n         // No need to find a main function\n         return;\n@@ -58,6 +61,7 @@ pub fn find_entry_point(session: Session, krate: &Crate, ast_map: ast_map::Map)\n \n     let mut ctxt = EntryContext {\n         session: session,\n+        main_name: token::intern(\"main\"),\n         ast_map: ast_map,\n         main_fn: None,\n         attr_main_fn: None,\n@@ -73,27 +77,22 @@ pub fn find_entry_point(session: Session, krate: &Crate, ast_map: ast_map::Map)\n fn find_item(item: &Item, ctxt: &mut EntryContext) {\n     match item.node {\n         ItemFn(..) => {\n-            if item.ident.name == special_idents::main.name {\n-                {\n-                    match ctxt.ast_map.find(item.id) {\n-                        Some(ast_map::NodeItem(_, path)) => {\n-                            if path.len() == 0 {\n-                                // This is a top-level function so can be 'main'\n-                                if ctxt.main_fn.is_none() {\n-                                    ctxt.main_fn = Some((item.id, item.span));\n-                                } else {\n-                                    ctxt.session.span_err(\n-                                        item.span,\n-                                        \"multiple 'main' functions\");\n-                                }\n+            if item.ident.name == ctxt.main_name {\n+                 ctxt.ast_map.with_path(item.id, |mut path| {\n+                        if path.len() == 1 {\n+                            // This is a top-level function so can be 'main'\n+                            if ctxt.main_fn.is_none() {\n+                                ctxt.main_fn = Some((item.id, item.span));\n                             } else {\n-                                // This isn't main\n-                                ctxt.non_main_fns.push((item.id, item.span));\n+                                ctxt.session.span_err(\n+                                    item.span,\n+                                    \"multiple 'main' functions\");\n                             }\n+                        } else {\n+                            // This isn't main\n+                            ctxt.non_main_fns.push((item.id, item.span));\n                         }\n-                        _ => unreachable!()\n-                    }\n-                }\n+                });\n             }\n \n             if attr::contains_name(item.attrs, \"main\") {"}, {"sha": "b5f8d168f6fc180822ffdac1c0577e4614cdb399", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -261,7 +261,7 @@ fn check_fn(\n }\n \n pub fn check_expr(cx: &mut Context, e: &Expr) {\n-    debug!(\"kind::check_expr({})\", expr_to_str(e, cx.tcx.sess.intr()));\n+    debug!(\"kind::check_expr({})\", expr_to_str(e));\n \n     // Handle any kind bounds on type parameters\n     let type_parameter_id = match e.get_callee_id() {"}, {"sha": "eb95bd05b61f3467193d2e58bbf09ee36aaf937e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -1067,8 +1067,8 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n         ty::ty_struct(did, _) |\n         ty::ty_enum(did, _) => {\n             if ast_util::is_local(did) {\n-                match cx.tcx.items.get(did.node) {\n-                    ast_map::NodeItem(it, _) => {\n+                match cx.tcx.map.get(did.node) {\n+                    ast_map::NodeItem(it) => {\n                         if attr::contains_name(it.attrs, \"must_use\") {\n                             cx.span_lint(UnusedMustUse, s.span,\n                                          \"unused result which must be used\");\n@@ -1095,23 +1095,22 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n }\n \n fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n-    fn is_camel_case(cx: ty::ctxt, ident: ast::Ident) -> bool {\n-        let ident = cx.sess.str_of(ident);\n-        assert!(!ident.is_empty());\n-        let ident = ident.trim_chars(&'_');\n+    fn is_camel_case(ident: ast::Ident) -> bool {\n+        let ident = token::get_ident(ident);\n+        assert!(!ident.get().is_empty());\n+        let ident = ident.get().trim_chars(&'_');\n \n         // start with a non-lowercase letter rather than non-uppercase\n         // ones (some scripts don't have a concept of upper/lowercase)\n-        !ident.char_at(0).is_lowercase() &&\n-            !ident.contains_char('_')\n+        !ident.char_at(0).is_lowercase() && !ident.contains_char('_')\n     }\n \n     fn check_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n-        if !is_camel_case(cx.tcx, ident) {\n+        if !is_camel_case(ident) {\n             cx.span_lint(\n                 NonCamelCaseTypes, span,\n                 format!(\"{} `{}` should have a camel case identifier\",\n-                    sort, cx.tcx.sess.str_of(ident)));\n+                    sort, token::get_ident(ident)));\n         }\n     }\n \n@@ -1136,11 +1135,11 @@ fn check_item_non_uppercase_statics(cx: &Context, it: &ast::Item) {\n     match it.node {\n         // only check static constants\n         ast::ItemStatic(_, ast::MutImmutable, _) => {\n-            let s = cx.tcx.sess.str_of(it.ident);\n+            let s = token::get_ident(it.ident);\n             // check for lowercase letters rather than non-uppercase\n             // ones (some scripts don't have a concept of\n             // upper/lowercase)\n-            if s.chars().any(|c| c.is_lowercase()) {\n+            if s.get().chars().any(|c| c.is_lowercase()) {\n                 cx.span_lint(NonUppercaseStatics, it.span,\n                              \"static constant should have an uppercase identifier\");\n             }\n@@ -1156,8 +1155,8 @@ fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n         (&ast::PatIdent(_, ref path, _), Some(&ast::DefStatic(_, false))) => {\n             // last identifier alone is right choice for this lint.\n             let ident = path.segments.last().unwrap().identifier;\n-            let s = cx.tcx.sess.str_of(ident);\n-            if s.chars().any(|c| c.is_lowercase()) {\n+            let s = token::get_ident(ident);\n+            if s.get().chars().any(|c| c.is_lowercase()) {\n                 cx.span_lint(NonUppercasePatternStatics, path.span,\n                              \"static constant in pattern should be all caps\");\n             }\n@@ -1216,7 +1215,7 @@ fn check_unused_mut_pat(cx: &Context, p: &ast::Pat) {\n             // `let mut _a = 1;` doesn't need a warning.\n             let initial_underscore = match path.segments {\n                 [ast::PathSegment { identifier: id, .. }] => {\n-                    cx.tcx.sess.str_of(id).starts_with(\"_\")\n+                    token::get_ident(id).get().starts_with(\"_\")\n                 }\n                 _ => {\n                     cx.tcx.sess.span_bug(p.span,\n@@ -1433,24 +1432,18 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n \n     let stability = if ast_util::is_local(id) {\n         // this crate\n-        match cx.tcx.items.find(id.node) {\n-            Some(ast_node) => {\n-                let s = ast_node.with_attrs(|attrs| {\n-                    attrs.map(|a| {\n-                        attr::find_stability(a.iter().map(|a| a.meta()))\n-                    })\n-                });\n-                match s {\n-                    Some(s) => s,\n+        let s = cx.tcx.map.with_attrs(id.node, |attrs| {\n+            attrs.map(|a| {\n+                attr::find_stability(a.iter().map(|a| a.meta()))\n+            })\n+        });\n+        match s {\n+            Some(s) => s,\n \n-                    // no possibility of having attributes\n-                    // (e.g. it's a local variable), so just\n-                    // ignore it.\n-                    None => return\n-                }\n-            }\n-            _ => cx.tcx.sess.span_bug(e.span,\n-                                      format!(\"handle_def: {:?} not found\", id))\n+            // no possibility of having attributes\n+            // (e.g. it's a local variable), so just\n+            // ignore it.\n+            None => return\n         }\n     } else {\n         // cross-crate\n@@ -1685,11 +1678,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     for (id, v) in lints.get().iter() {\n         for &(lint, span, ref msg) in v.iter() {\n             tcx.sess.span_bug(span, format!(\"unprocessed lint {:?} at {}: {}\",\n-                                            lint,\n-                                            ast_map::node_id_to_str(tcx.items,\n-                                                *id,\n-                                                token::get_ident_interner()),\n-                                            *msg))\n+                                            lint, tcx.map.node_to_str(*id), *msg))\n         }\n     }\n "}, {"sha": "b7a89db4b9e4a3b0aeacf78049a76297f598e5e4", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -337,8 +337,7 @@ impl IrMaps {\n         let var_kinds = self.var_kinds.borrow();\n         match var_kinds.get()[var.get()] {\n             Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n-                let string = token::get_ident(nm.name);\n-                string.get().to_str()\n+                token::get_ident(nm).get().to_str()\n             },\n             ImplicitRet => ~\"<implicit-ret>\"\n         }\n@@ -929,8 +928,7 @@ impl Liveness {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for block, {}\", block_to_str(body,\n-                      self.tcx.sess.intr()));\n+        debug!(\"compute: using id for block, {}\", block_to_str(body));\n \n         let entry_ln: LiveNode =\n             self.with_loop_nodes(body.id, self.s.exit_ln, self.s.exit_ln,\n@@ -1034,8 +1032,7 @@ impl Liveness {\n \n     pub fn propagate_through_expr(&self, expr: @Expr, succ: LiveNode)\n                                   -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\",\n-             expr_to_str(expr, self.tcx.sess.intr()));\n+        debug!(\"propagate_through_expr: {}\", expr_to_str(expr));\n \n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n@@ -1049,8 +1046,7 @@ impl Liveness {\n           }\n \n           ExprFnBlock(_, blk) | ExprProc(_, blk) => {\n-              debug!(\"{} is an ExprFnBlock or ExprProc\",\n-                   expr_to_str(expr, self.tcx.sess.intr()));\n+              debug!(\"{} is an ExprFnBlock or ExprProc\", expr_to_str(expr));\n \n               /*\n               The next-node for a break is the successor of the entire\n@@ -1412,7 +1408,7 @@ impl Liveness {\n             first_merge = false;\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n-               expr.id, block_to_str(body, self.tcx.sess.intr()));\n+               expr.id, block_to_str(body));\n \n         let cond_ln = self.propagate_through_opt_expr(cond, ln);\n         let body_ln = self.with_loop_nodes(expr.id, succ, ln, || {"}, {"sha": "a893840f678d98b475d7e501462332091efacbc1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -433,9 +433,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n     }\n \n     pub fn cat_expr_unadjusted(&mut self, expr: &ast::Expr) -> McResult<cmt> {\n-        debug!(\"cat_expr: id={} expr={}\",\n-               expr.id,\n-               expr.repr(self.tcx()));\n+        debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr(self.tcx()));\n \n         let expr_ty = if_ok!(self.expr_ty(expr));\n         match expr.node {\n@@ -1004,7 +1002,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n \n         let tcx = self.tcx();\n         debug!(\"cat_pattern: id={} pat={} cmt={}\",\n-               pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n+               pat.id, pprust::pat_to_str(pat),\n                cmt.repr(tcx));\n \n         op(self, cmt, pat);\n@@ -1374,8 +1372,7 @@ impl Repr for InteriorKind {\n     fn repr(&self, _tcx: ty::ctxt) -> ~str {\n         match *self {\n             InteriorField(NamedField(fld)) => {\n-                let string = token::get_ident(fld);\n-                string.get().to_owned()\n+                token::get_name(fld).get().to_str()\n             }\n             InteriorField(PositionalField(i)) => format!(\"\\\\#{:?}\", i),\n             InteriorElement(_) => ~\"[]\","}, {"sha": "1f3bb2ba70dcc244b205c872613456343cdb8057", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -357,7 +357,7 @@ enum PrivacyResult {\n impl<'a> PrivacyVisitor<'a> {\n     // used when debugging\n     fn nodestr(&self, id: ast::NodeId) -> ~str {\n-        ast_map::node_id_to_str(self.tcx.items, id, token::get_ident_interner())\n+        self.tcx.map.node_to_str(id)\n     }\n \n     // Determines whether the given definition is public from the point of view\n@@ -417,7 +417,7 @@ impl<'a> PrivacyVisitor<'a> {\n         let mut closest_private_id = did.node;\n         loop {\n             debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n-            let vis = match self.tcx.items.find(closest_private_id) {\n+            let vis = match self.tcx.map.find(closest_private_id) {\n                 // If this item is a method, then we know for sure that it's an\n                 // actual method and not a static method. The reason for this is\n                 // that these cases are only hit in the ExprMethodCall\n@@ -434,22 +434,25 @@ impl<'a> PrivacyVisitor<'a> {\n                 // invocation.\n                 // FIXME(#10573) is this the right behavior? Why not consider\n                 //               where the method was defined?\n-                Some(ast_map::NodeMethod(ref m, imp, _)) => {\n+                Some(ast_map::NodeMethod(ref m)) => {\n+                    let imp = self.tcx.map.get_parent_did(closest_private_id);\n                     match ty::impl_trait_ref(self.tcx, imp) {\n                         Some(..) => return Allowable,\n                         _ if m.vis == ast::Public => return Allowable,\n                         _ => m.vis\n                     }\n                 }\n-                Some(ast_map::NodeTraitMethod(..)) => {\n+                Some(ast_map::NodeTraitMethod(_)) => {\n                     return Allowable;\n                 }\n \n                 // This is not a method call, extract the visibility as one\n                 // would normally look at it\n-                Some(ast_map::NodeItem(it, _)) => it.vis,\n-                Some(ast_map::NodeForeignItem(_, _, v, _)) => v,\n-                Some(ast_map::NodeVariant(ref v, _, _)) => {\n+                Some(ast_map::NodeItem(it)) => it.vis,\n+                Some(ast_map::NodeForeignItem(_)) => {\n+                    self.tcx.map.get_foreign_vis(closest_private_id)\n+                }\n+                Some(ast_map::NodeVariant(ref v)) => {\n                     // sadly enum variants still inherit visibility, so only\n                     // break out of this is explicitly private\n                     if v.node.vis == ast::Private { break }\n@@ -523,17 +526,16 @@ impl<'a> PrivacyVisitor<'a> {\n                     self.tcx.sess.span_err(span, format!(\"{} is inaccessible\",\n                                                          msg));\n                 }\n-                match self.tcx.items.find(id) {\n-                    Some(ast_map::NodeItem(item, _)) => {\n+                match self.tcx.map.find(id) {\n+                    Some(ast_map::NodeItem(item)) => {\n                         let desc = match item.node {\n                             ast::ItemMod(..) => \"module\",\n                             ast::ItemTrait(..) => \"trait\",\n                             _ => return false,\n                         };\n-                        let string = token::get_ident(item.ident.name);\n                         let msg = format!(\"{} `{}` is private\",\n                                           desc,\n-                                          string.get());\n+                                          token::get_ident(item.ident));\n                         self.tcx.sess.span_note(span, msg);\n                     }\n                     Some(..) | None => {}\n@@ -550,10 +552,15 @@ impl<'a> PrivacyVisitor<'a> {\n                    enum_id: Option<ast::DefId>) {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n         let struct_vis = if is_local(id) {\n-            match self.tcx.items.get(id.node) {\n-                ast_map::NodeItem(ref it, _) => it.vis,\n-                ast_map::NodeVariant(ref v, ref it, _) => {\n-                    if v.node.vis == ast::Inherited {it.vis} else {v.node.vis}\n+            match self.tcx.map.get(id.node) {\n+                ast_map::NodeItem(ref it) => it.vis,\n+                ast_map::NodeVariant(ref v) => {\n+                    if v.node.vis == ast::Inherited {\n+                        let parent = self.tcx.map.get_parent(id.node);\n+                        self.tcx.map.expect_item(parent).vis\n+                    } else {\n+                        v.node.vis\n+                    }\n                 }\n                 _ => {\n                     self.tcx.sess.span_bug(span,\n@@ -590,28 +597,26 @@ impl<'a> PrivacyVisitor<'a> {\n             if struct_vis != ast::Public && field.vis == ast::Public { break }\n             if !is_local(field.id) ||\n                !self.private_accessible(field.id.node) {\n-                let string = token::get_ident(ident.name);\n                 self.tcx.sess.span_err(span,\n                                        format!(\"field `{}` is private\",\n-                                               string.get()))\n+                                               token::get_ident(ident)))\n             }\n             break;\n         }\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n     fn check_static_method(&mut self, span: Span, method_id: ast::DefId,\n-                           name: &ast::Ident) {\n+                           name: ast::Ident) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n         let method_id = ty::method(self.tcx, method_id).provided_source\n                                                        .unwrap_or(method_id);\n \n-        let string = token::get_ident(name.name);\n         self.ensure_public(span,\n                            method_id,\n                            None,\n-                           format!(\"method `{}`\", string.get()));\n+                           format!(\"method `{}`\", token::get_ident(name)));\n     }\n \n     // Checks that a path is in scope.\n@@ -627,14 +632,12 @@ impl<'a> PrivacyVisitor<'a> {\n                     let name = token::get_ident(path.segments\n                                                     .last()\n                                                     .unwrap()\n-                                                    .identifier\n-                                                    .name);\n+                                                    .identifier);\n                     self.ensure_public(span,\n                                        def,\n                                        Some(origdid),\n                                        format!(\"{} `{}`\",\n-                                               tyname,\n-                                               name.get()));\n+                                               tyname, name));\n                 }\n             }\n         };\n@@ -659,7 +662,7 @@ impl<'a> PrivacyVisitor<'a> {\n                     ident: ast::Ident) {\n         match *origin {\n             method_static(method_id) => {\n-                self.check_static_method(span, method_id, &ident)\n+                self.check_static_method(span, method_id, ident)\n             }\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not."}, {"sha": "42911d25f393ee0d2efef2ae0c0780d3d9499a8f", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 21, "deletions": 39, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -25,7 +25,6 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{def_id_of_def, is_local};\n use syntax::attr;\n-use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n@@ -66,8 +65,8 @@ fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::Method,\n     }\n     if is_local(impl_src) {\n         {\n-            match tcx.items.find(impl_src.node) {\n-                Some(ast_map::NodeItem(item, _)) => {\n+            match tcx.map.find(impl_src.node) {\n+                Some(ast_map::NodeItem(item)) => {\n                     item_might_be_inlined(item)\n                 }\n                 Some(..) | None => {\n@@ -212,47 +211,33 @@ impl ReachableContext {\n         }\n \n         let node_id = def_id.node;\n-        match tcx.items.find(node_id) {\n-            Some(ast_map::NodeItem(item, _)) => {\n+        match tcx.map.find(node_id) {\n+            Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n                     ast::ItemFn(..) => item_might_be_inlined(item),\n                     _ => false,\n                 }\n             }\n-            Some(ast_map::NodeTraitMethod(trait_method, _, _)) => {\n+            Some(ast_map::NodeTraitMethod(trait_method)) => {\n                 match *trait_method {\n                     ast::Required(_) => false,\n                     ast::Provided(_) => true,\n                 }\n             }\n-            Some(ast_map::NodeMethod(method, impl_did, _)) => {\n+            Some(ast_map::NodeMethod(method)) => {\n                 if generics_require_inlining(&method.generics) ||\n                         attributes_specify_inlining(method.attrs) {\n                     true\n                 } else {\n+                    let impl_did = tcx.map.get_parent_did(node_id);\n                     // Check the impl. If the generics on the self type of the\n                     // impl require inlining, this method does too.\n                     assert!(impl_did.krate == ast::LOCAL_CRATE);\n-                    match tcx.items.find(impl_did.node) {\n-                        Some(ast_map::NodeItem(item, _)) => {\n-                            match item.node {\n-                                ast::ItemImpl(ref generics, _, _, _) => {\n-                                    generics_require_inlining(generics)\n-                                }\n-                                _ => false\n-                            }\n-                        }\n-                        Some(_) => {\n-                            tcx.sess.span_bug(method.span,\n-                                              \"method is not inside an \\\n-                                               impl?!\")\n-                        }\n-                        None => {\n-                            tcx.sess.span_bug(method.span,\n-                                              \"the impl that this method is \\\n-                                               supposedly inside of doesn't \\\n-                                               exist in the AST map?!\")\n+                    match tcx.map.expect_item(impl_did.node).node {\n+                        ast::ItemImpl(ref generics, _, _, _) => {\n+                            generics_require_inlining(generics)\n                         }\n+                        _ => false\n                     }\n                 }\n             }\n@@ -292,7 +277,7 @@ impl ReachableContext {\n             };\n \n             scanned.insert(search_item);\n-            match self.tcx.items.find(search_item) {\n+            match self.tcx.map.find(search_item) {\n                 Some(ref item) => self.propagate_node(item, search_item,\n                                                   &mut visitor),\n                 None if search_item == ast::CRATE_NODE_ID => {}\n@@ -315,7 +300,7 @@ impl ReachableContext {\n             // but all other rust-only interfaces can be private (they will not\n             // participate in linkage after this product is produced)\n             match *node {\n-                ast_map::NodeItem(item, _) => {\n+                ast_map::NodeItem(item) => {\n                     match item.node {\n                         ast::ItemFn(_, ast::ExternFn, _, _, _) => {\n                             let mut reachable_symbols =\n@@ -337,7 +322,7 @@ impl ReachableContext {\n         }\n \n         match *node {\n-            ast_map::NodeItem(item, _) => {\n+            ast_map::NodeItem(item) => {\n                 match item.node {\n                     ast::ItemFn(_, _, _, _, search_block) => {\n                         if item_might_be_inlined(item) {\n@@ -371,7 +356,7 @@ impl ReachableContext {\n                     }\n                 }\n             }\n-            ast_map::NodeTraitMethod(trait_method, _, _) => {\n+            ast_map::NodeTraitMethod(trait_method) => {\n                 match *trait_method {\n                     ast::Required(..) => {\n                         // Keep going, nothing to get exported\n@@ -381,23 +366,20 @@ impl ReachableContext {\n                     }\n                 }\n             }\n-            ast_map::NodeMethod(method, did, _) => {\n+            ast_map::NodeMethod(method) => {\n+                let did = self.tcx.map.get_parent_did(search_item);\n                 if method_might_be_inlined(self.tcx, method, did) {\n                     visit::walk_block(visitor, method.body, ())\n                 }\n             }\n             // Nothing to recurse on for these\n-            ast_map::NodeForeignItem(..) |\n-            ast_map::NodeVariant(..) |\n-            ast_map::NodeStructCtor(..) => {}\n+            ast_map::NodeForeignItem(_) |\n+            ast_map::NodeVariant(_) |\n+            ast_map::NodeStructCtor(_) => {}\n             _ => {\n-                let ident_interner = token::get_ident_interner();\n-                let desc = ast_map::node_id_to_str(self.tcx.items,\n-                                                   search_item,\n-                                                   ident_interner);\n                 self.tcx.sess.bug(format!(\"found unexpected thingy in \\\n                                            worklist: {}\",\n-                                           desc))\n+                                          self.tcx.map.node_to_str(search_item)))\n             }\n         }\n     }"}, {"sha": "bedaff70121d9c8d8b11175e46517f777e119fc3", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 73, "deletions": 100, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -20,7 +20,7 @@ use syntax::ast::*;\n use syntax::ast;\n use syntax::ast_util::{def_id_of_def, local_def, mtwt_resolve};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n-use syntax::parse::token::{IdentInterner, special_idents};\n+use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::print::pprust::path_to_str;\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n@@ -813,7 +813,6 @@ fn Resolver(session: Session,\n         last_private: HashMap::new(),\n \n         emit_errors: true,\n-        intr: session.intr()\n     };\n \n     this\n@@ -824,8 +823,6 @@ struct Resolver {\n     session: @Session,\n     lang_items: @LanguageItems,\n \n-    intr: @IdentInterner,\n-\n     graph_root: @NameBindings,\n \n     method_map: @RefCell<HashMap<Name, HashSet<DefId>>>,\n@@ -1066,14 +1063,14 @@ impl Resolver {\n                     self.resolve_error(sp,\n                         format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_str(duplicate_type),\n-                             self.session.str_of(name)));\n+                             token::get_ident(name)));\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n                                  format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_str(duplicate_type),\n-                                      self.session.str_of(name)));\n+                                      token::get_ident(name)));\n                         }\n                     }\n                 }\n@@ -1679,7 +1676,7 @@ impl Resolver {\n                   debug!(\"(building reduced graph for \\\n                           external crate) ... adding \\\n                           trait method '{}'\",\n-                         self.session.str_of(method_name));\n+                         token::get_ident(method_name));\n \n                   // Add it to the trait info if not static.\n                   if explicit_self != SelfStatic {\n@@ -1776,7 +1773,7 @@ impl Resolver {\n                         self.handle_external_def(def,\n                                                  visibility,\n                                                  child_name_bindings,\n-                                                 self.session.str_of(ident),\n+                                                 token::get_ident(ident).get(),\n                                                  ident,\n                                                  new_parent);\n                     }\n@@ -1795,8 +1792,7 @@ impl Resolver {\n                                 debug!(\"(building reduced graph for \\\n                                         external crate) processing \\\n                                         static methods for type name {}\",\n-                                        self.session.str_of(\n-                                            final_ident));\n+                                        token::get_ident(final_ident));\n \n                                 let (child_name_bindings, new_parent) =\n                                     self.add_child(\n@@ -1847,7 +1843,7 @@ impl Resolver {\n                                     debug!(\"(building reduced graph for \\\n                                              external crate) creating \\\n                                              static method '{}'\",\n-                                           self.session.str_of(ident));\n+                                           token::get_ident(ident));\n \n                                     let (method_name_bindings, _) =\n                                         self.add_child(ident,\n@@ -1893,9 +1889,8 @@ impl Resolver {\n         csearch::each_child_of_item(self.session.cstore,\n                                     def_id,\n                                     |def_like, child_ident, visibility| {\n-            let child_ident_string = token::get_ident(child_ident.name);\n             debug!(\"(populating external module) ... found ident: {}\",\n-                   child_ident_string.get());\n+                   token::get_ident(child_ident));\n             self.build_reduced_graph_for_external_crate_def(module,\n                                                             def_like,\n                                                             child_ident,\n@@ -1955,7 +1950,7 @@ impl Resolver {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n                        self.idents_to_str(directive.module_path),\n-                       self.session.str_of(target));\n+                       token::get_ident(target));\n \n                 let mut import_resolutions = module_.import_resolutions\n                                                     .borrow_mut();\n@@ -2100,7 +2095,7 @@ impl Resolver {\n             } else {\n                 result.push_str(\"::\")\n             }\n-            result.push_str(self.session.str_of(*ident));\n+            result.push_str(token::get_ident(*ident).get());\n         };\n         return result;\n     }\n@@ -2117,8 +2112,8 @@ impl Resolver {\n                                         subclass: ImportDirectiveSubclass)\n                                         -> ~str {\n         match subclass {\n-            SingleImport(_target, source) => {\n-                self.session.str_of(source).to_str()\n+            SingleImport(_, source) => {\n+                token::get_ident(source).get().to_str()\n             }\n             GlobImport => ~\"*\"\n         }\n@@ -2255,9 +2250,9 @@ impl Resolver {\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n                 `{}` id {}, last private {:?}\",\n-               self.session.str_of(target),\n+               token::get_ident(target),\n                self.module_to_str(containing_module),\n-               self.session.str_of(source),\n+               token::get_ident(source),\n                self.module_to_str(module_),\n                directive.id,\n                lp);\n@@ -2443,7 +2438,7 @@ impl Resolver {\n            import_resolution.type_target.get().is_none() {\n             let msg = format!(\"unresolved import: there is no \\\n                                `{}` in `{}`\",\n-                              self.session.str_of(source),\n+                              token::get_ident(source),\n                               self.module_to_str(containing_module));\n             self.resolve_error(directive.span, msg);\n             return Failed;\n@@ -2630,7 +2625,7 @@ impl Resolver {\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                to `{}`\",\n-               token::get_ident(name).get().to_str(),\n+               token::get_name(name).get().to_str(),\n                self.module_to_str(containing_module),\n                self.module_to_str(module_));\n \n@@ -2674,12 +2669,12 @@ impl Resolver {\n                                               TypeNS,\n                                               name_search_type) {\n                 Failed => {\n-                    let segment_name = self.session.str_of(name);\n+                    let segment_name = token::get_ident(name);\n                     let module_name = self.module_to_str(search_module);\n                     if \"???\" == module_name {\n                         let span = Span {\n                             lo: span.lo,\n-                            hi: span.lo + Pos::from_uint(segment_name.len()),\n+                            hi: span.lo + Pos::from_uint(segment_name.get().len()),\n                             expn_info: span.expn_info,\n                         };\n                         self.resolve_error(span,\n@@ -2696,7 +2691,7 @@ impl Resolver {\n                 Indeterminate => {\n                     debug!(\"(resolving module path for import) module \\\n                             resolution is indeterminate: {}\",\n-                            self.session.str_of(name));\n+                            token::get_ident(name));\n                     return Indeterminate;\n                 }\n                 Success((target, used_proxy)) => {\n@@ -2707,12 +2702,8 @@ impl Resolver {\n                             match type_def.module_def {\n                                 None => {\n                                     // Not a module.\n-                                    self.resolve_error(span,\n-                                                          format!(\"not a \\\n-                                                                module `{}`\",\n-                                                               self.session.\n-                                                                   str_of(\n-                                                                    name)));\n+                                    self.resolve_error(span, format!(\"not a module `{}`\",\n+                                                                 token::get_ident(name)));\n                                     return Failed;\n                                 }\n                                 Some(module_def) => {\n@@ -2755,8 +2746,7 @@ impl Resolver {\n                             // There are no type bindings at all.\n                             self.resolve_error(span,\n                                                   format!(\"not a module `{}`\",\n-                                                       self.session.str_of(\n-                                                            name)));\n+                                                       token::get_ident(name)));\n                             return Failed;\n                         }\n                     }\n@@ -2883,7 +2873,7 @@ impl Resolver {\n                                     -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in \\\n                 namespace {:?} in `{}`\",\n-               self.session.str_of(name),\n+               token::get_ident(name),\n                namespace,\n                self.module_to_str(module_));\n \n@@ -3112,7 +3102,7 @@ impl Resolver {\n         // top of the crate otherwise.\n         let mut containing_module;\n         let mut i;\n-        let first_module_path_string = token::get_ident(module_path[0].name);\n+        let first_module_path_string = token::get_ident(module_path[0]);\n         if \"self\" == first_module_path_string.get() {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n@@ -3127,7 +3117,7 @@ impl Resolver {\n \n         // Now loop through all the `super`s we find.\n         while i < module_path.len() {\n-            let string = token::get_ident(module_path[i].name);\n+            let string = token::get_ident(module_path[i]);\n             if \"super\" != string.get() {\n                 break\n             }\n@@ -3161,7 +3151,7 @@ impl Resolver {\n                               name_search_type: NameSearchType)\n                               -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n-               self.session.str_of(name),\n+               token::get_ident(name),\n                self.module_to_str(module_));\n \n         // First, check the direct children of the module.\n@@ -3236,7 +3226,7 @@ impl Resolver {\n \n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve `{}`\",\n-               self.session.str_of(name));\n+               token::get_ident(name));\n         return Failed;\n     }\n \n@@ -3368,11 +3358,11 @@ impl Resolver {\n                                    ns: Namespace) {\n         match namebindings.def_for_namespace(ns) {\n             Some(d) => {\n+                let name = token::get_name(name);\n                 debug!(\"(computing exports) YES: export '{}' => {:?}\",\n-                       token::get_ident(name).get().to_str(),\n-                       def_id_of_def(d));\n+                       name, def_id_of_def(d));\n                 exports2.push(Export2 {\n-                    name: token::get_ident(name).get().to_str(),\n+                    name: name.get().to_str(),\n                     def_id: def_id_of_def(d)\n                 });\n             }\n@@ -3395,7 +3385,7 @@ impl Resolver {\n                 match importresolution.target_for_namespace(ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe export '{}'\",\n-                               token::get_ident(*name).get().to_str());\n+                               token::get_name(*name));\n                         self.add_exports_of_namebindings(exports2,\n                                                          *name,\n                                                          target.bindings,\n@@ -3440,15 +3430,15 @@ impl Resolver {\n                 match children.get().find(&name.name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n-                               self.session.str_of(name),\n+                               token::get_ident(name),\n                                self.module_to_str(orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `{}` in `{}`\",\n-                                       self.session.str_of(name),\n+                                       token::get_ident(name),\n                                        self.module_to_str(orig_module));\n                             }\n                             Some(module_) => {\n@@ -3618,7 +3608,7 @@ impl Resolver {\n \n     fn resolve_item(&mut self, item: &Item) {\n         debug!(\"(resolving item) resolving {}\",\n-               self.session.str_of(item.ident));\n+               token::get_ident(item.ident));\n \n         match item.node {\n \n@@ -3997,7 +3987,7 @@ impl Resolver {\n                 NamedField(ident, _) => {\n                     match ident_map.find(&ident) {\n                         Some(&prev_field) => {\n-                            let ident_str = self.session.str_of(ident);\n+                            let ident_str = token::get_ident(ident);\n                             self.resolve_error(field.span,\n                                 format!(\"field `{}` is already declared\", ident_str));\n                             self.session.span_note(prev_field.span,\n@@ -4170,22 +4160,20 @@ impl Resolver {\n             for (&key, &binding_0) in map_0.iter() {\n                 match map_i.find(&key) {\n                   None => {\n-                    let string = token::get_ident(key);\n                     self.resolve_error(\n                         p.span,\n                         format!(\"variable `{}` from pattern \\\\#1 is \\\n                                   not bound in pattern \\\\#{}\",\n-                                string.get(),\n+                                token::get_name(key),\n                                 i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n-                        let string = token::get_ident(key);\n                         self.resolve_error(\n                             binding_i.span,\n                             format!(\"variable `{}` is bound with different \\\n                                       mode in pattern \\\\#{} than in pattern \\\\#1\",\n-                                    string.get(),\n+                                    token::get_name(key),\n                                     i + 1));\n                     }\n                   }\n@@ -4194,12 +4182,11 @@ impl Resolver {\n \n             for (&key, &binding) in map_i.iter() {\n                 if !map_0.contains_key(&key) {\n-                    let string = token::get_ident(key);\n                     self.resolve_error(\n                         binding.span,\n                         format!(\"variable `{}` from pattern \\\\#{} is \\\n                                   not bound in pattern \\\\#1\",\n-                                string.get(),\n+                                token::get_name(key),\n                                 i + 1));\n                 }\n             }\n@@ -4312,9 +4299,9 @@ impl Resolver {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `{}` to \\\n                                         type {:?}\",\n-                                       self.session.str_of(path.segments\n-                                                               .last().unwrap()\n-                                                               .identifier),\n+                                       token::get_ident(path.segments\n+                                                            .last().unwrap()\n+                                                            .identifier),\n                                        def);\n                                 result_def = Some(def);\n                             }\n@@ -4392,10 +4379,9 @@ impl Resolver {\n                     match self.resolve_bare_identifier_pattern(ident) {\n                         FoundStructOrEnumVariant(def, lp)\n                                 if mode == RefutableMode => {\n-                            let string = token::get_ident(renamed);\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n-                                   string.get());\n+                                   token::get_name(renamed));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4404,19 +4390,17 @@ impl Resolver {\n                             self.record_def(pattern.id, (def, lp));\n                         }\n                         FoundStructOrEnumVariant(..) => {\n-                            let string = token::get_ident(renamed);\n                             self.resolve_error(pattern.span,\n                                                   format!(\"declaration of `{}` \\\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n                                                         struct in scope\",\n-                                                          string.get()));\n+                                                        token::get_name(renamed)));\n                         }\n                         FoundConst(def, lp) if mode == RefutableMode => {\n-                            let string = token::get_ident(renamed);\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n-                                   string.get());\n+                                   token::get_name(renamed));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4430,9 +4414,8 @@ impl Resolver {\n                                                    allowed here\");\n                         }\n                         BareIdentifierPatternUnresolved => {\n-                            let string = token::get_ident(renamed);\n                             debug!(\"(resolving pattern) binding `{}`\",\n-                                   string.get());\n+                                   token::get_name(renamed));\n \n                             let def = match mode {\n                                 RefutableMode => {\n@@ -4487,8 +4470,7 @@ impl Resolver {\n                                      self.resolve_error(pattern.span,\n                                        format!(\"identifier `{}` is bound more \\\n                                              than once in the same pattern\",\n-                                            path_to_str(path, self.session\n-                                                        .intr())));\n+                                            path_to_str(path)));\n                                   }\n                                   // Not bound in the same pattern: do nothing\n                                 }\n@@ -4535,7 +4517,7 @@ impl Resolver {\n                             self.resolve_error(\n                                 path.span,\n                                 format!(\"`{}` is not an enum variant or constant\",\n-                                     self.session.str_of(\n+                                     token::get_ident(\n                                          path.segments.last().unwrap().identifier)))\n                         }\n                         None => {\n@@ -4562,22 +4544,18 @@ impl Resolver {\n                             self.record_def(pattern.id, def);\n                         }\n                         Some(_) => {\n-                            self.resolve_error(\n-                                path.span,\n+                            self.resolve_error(path.span,\n                                 format!(\"`{}` is not an enum variant, struct or const\",\n-                                     self.session\n-                                         .str_of(path.segments\n-                                                     .last().unwrap()\n-                                                     .identifier)));\n+                                    token::get_ident(path.segments\n+                                                         .last().unwrap()\n+                                                         .identifier)));\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n-                                               format!(\"unresolved enum variant, \\\n-                                                    struct or const `{}`\",\n-                                                    self.session\n-                                                        .str_of(path.segments\n-                                                                    .last().unwrap()\n-                                                                    .identifier)));\n+                                format!(\"unresolved enum variant, struct or const `{}`\",\n+                                    token::get_ident(path.segments\n+                                                         .last().unwrap()\n+                                                         .identifier)));\n                         }\n                     }\n \n@@ -4641,7 +4619,7 @@ impl Resolver {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in \\\n                          finding {} at {:?}\",\n-                        self.session.str_of(name),\n+                        token::get_ident(name),\n                         target.bindings.value_def.get());\n                 match target.bindings.value_def.get() {\n                     None => {\n@@ -4673,7 +4651,7 @@ impl Resolver {\n \n             Failed => {\n                 debug!(\"(resolve bare identifier pattern) failed to find {}\",\n-                        self.session.str_of(name));\n+                        token::get_ident(name));\n                 return BareIdentifierPatternUnresolved;\n             }\n         }\n@@ -4969,7 +4947,7 @@ impl Resolver {\n             Some(DlDef(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `{}` to \\\n                         local: {:?}\",\n-                       self.session.str_of(ident),\n+                       token::get_ident(ident),\n                        def);\n                 return Some(def);\n             }\n@@ -4995,13 +4973,13 @@ impl Resolver {\n                         // found a module instead. Modules don't have defs.\n                         debug!(\"(resolving item path by identifier in lexical \\\n                                  scope) failed to resolve {} after success...\",\n-                                 self.session.str_of(ident));\n+                                 token::get_ident(ident));\n                         return None;\n                     }\n                     Some(def) => {\n                         debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `{}` to item\",\n-                               self.session.str_of(ident));\n+                               token::get_ident(ident));\n                         // This lookup is \"all public\" because it only searched\n                         // for one identifier in the current module (couldn't\n                         // have passed through reexports or anything like that.\n@@ -5014,7 +4992,7 @@ impl Resolver {\n             }\n             Failed => {\n                 debug!(\"(resolving item path by identifier in lexical scope) \\\n-                         failed to resolve {}\", self.session.str_of(ident));\n+                         failed to resolve {}\", token::get_ident(ident));\n                 return None;\n             }\n         }\n@@ -5037,7 +5015,7 @@ impl Resolver {\n                                 -> Option<~str> {\n         let this = &mut *self;\n \n-        let mut maybes: ~[~str] = ~[];\n+        let mut maybes: ~[token::InternedString] = ~[];\n         let mut values: ~[uint] = ~[];\n \n         let mut j = {\n@@ -5049,15 +5027,14 @@ impl Resolver {\n             let value_ribs = this.value_ribs.borrow();\n             let bindings = value_ribs.get()[j].bindings.borrow();\n             for (&k, _) in bindings.get().iter() {\n-                let string = token::get_ident(k);\n-                maybes.push(string.get().to_str());\n+                maybes.push(token::get_name(k));\n                 values.push(uint::MAX);\n             }\n         }\n \n         let mut smallest = 0;\n         for (i, other) in maybes.iter().enumerate() {\n-            values[i] = name.lev_distance(*other);\n+            values[i] = name.lev_distance(other.get());\n \n             if values[i] <= values[smallest] {\n                 smallest = i;\n@@ -5068,9 +5045,9 @@ impl Resolver {\n             values[smallest] != uint::MAX &&\n             values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n-            name != maybes[smallest] {\n+            name != maybes[smallest].get() {\n \n-            Some(maybes.swap_remove(smallest))\n+            Some(maybes[smallest].get().to_str())\n \n         } else {\n             None\n@@ -5214,11 +5191,8 @@ impl Resolver {\n                 match self.search_ribs(label_ribs.get(), label, expr.span) {\n                     None =>\n                         self.resolve_error(expr.span,\n-                                              format!(\"use of undeclared label \\\n-                                                   `{}`\",\n-                                                   token::get_ident(label)\n-                                                    .get()\n-                                                    .to_str())),\n+                                              format!(\"use of undeclared label `{}`\",\n+                                                   token::get_name(label))),\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // FIXME: is AllPublic correct?\n                         self.record_def(expr.id, (def, AllPublic))\n@@ -5323,7 +5297,7 @@ impl Resolver {\n \n     fn search_for_traits_containing_method(&mut self, name: Ident) -> ~[DefId] {\n         debug!(\"(searching for traits containing method) looking for '{}'\",\n-               self.session.str_of(name));\n+               token::get_ident(name));\n \n         let mut found_traits = ~[];\n         let mut search_module = self.current_module;\n@@ -5403,7 +5377,7 @@ impl Resolver {\n         debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n                trait_def_id.krate,\n                trait_def_id.node,\n-               self.session.str_of(name));\n+               token::get_ident(name));\n         found_traits.push(trait_def_id);\n     }\n \n@@ -5538,12 +5512,12 @@ impl Resolver {\n         self.populate_module_if_necessary(module_);\n         let children = module_.children.borrow();\n         for (&name, _) in children.get().iter() {\n-            debug!(\"* {}\", token::get_ident(name).get().to_str());\n+            debug!(\"* {}\", token::get_name(name));\n         }\n \n         debug!(\"Import resolutions:\");\n         let import_resolutions = module_.import_resolutions.borrow();\n-        for (name, import_resolution) in import_resolutions.get().iter() {\n+        for (&name, import_resolution) in import_resolutions.get().iter() {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }\n@@ -5562,8 +5536,7 @@ impl Resolver {\n                 }\n             }\n \n-            debug!(\"* {}:{}{}\", token::get_ident(*name).get().to_str(),\n-                   value_repr, type_repr);\n+            debug!(\"* {}:{}{}\", token::get_name(name), value_repr, type_repr);\n         }\n     }\n }"}, {"sha": "7b7bcc1784226f7d9d02b1a0e37d61c0714fdd6e", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -24,6 +24,7 @@ use syntax::ast;\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n use syntax::parse::token::special_idents;\n+use syntax::parse::token;\n use syntax::print::pprust::{lifetime_to_str};\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -261,7 +262,7 @@ impl LifetimeContext {\n         self.sess.span_err(\n             lifetime_ref.span,\n             format!(\"use of undeclared lifetime name `'{}`\",\n-                    self.sess.str_of(lifetime_ref.ident)));\n+                    token::get_ident(lifetime_ref.ident)));\n     }\n \n     fn check_lifetime_names(&self, lifetimes: &OptVec<ast::Lifetime>) {\n@@ -274,7 +275,7 @@ impl LifetimeContext {\n                     self.sess.span_err(\n                         lifetime.span,\n                         format!(\"illegal lifetime parameter name: `{}`\",\n-                                self.sess.str_of(lifetime.ident)));\n+                                token::get_ident(lifetime.ident)));\n                 }\n             }\n \n@@ -286,7 +287,7 @@ impl LifetimeContext {\n                         lifetime_j.span,\n                         format!(\"lifetime name `'{}` declared twice in \\\n                                 the same scope\",\n-                                self.sess.str_of(lifetime_j.ident)));\n+                                token::get_ident(lifetime_j.ident)));\n                 }\n             }\n         }\n@@ -302,8 +303,7 @@ impl LifetimeContext {\n         }\n \n         debug!(\"lifetime_ref={} id={} resolved to {:?}\",\n-                lifetime_to_str(lifetime_ref,\n-                                self.sess.intr()),\n+                lifetime_to_str(lifetime_ref),\n                 lifetime_ref.id,\n                 def);\n         let mut named_region_map = self.named_region_map.borrow_mut();"}, {"sha": "69e7dd9f7fb27bce8b4fcd34a96c386dfa359bf2", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 64, "deletions": 118, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -75,10 +75,9 @@ use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::libc::c_uint;\n-use std::vec;\n use std::local_data;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n-use syntax::ast_map::{PathName, PathPrettyName, path_elem_to_str};\n+use syntax::ast_map::PathName;\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -131,16 +130,15 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     _InsnCtxt { _x: () }\n }\n \n-pub struct StatRecorder<'a> {\n+pub struct StatRecorder {\n     ccx: @CrateContext,\n-    name: &'a str,\n+    name: Option<~str>,\n     start: u64,\n     istart: uint,\n }\n \n-impl<'a> StatRecorder<'a> {\n-    pub fn new(ccx: @CrateContext,\n-               name: &'a str) -> StatRecorder<'a> {\n+impl StatRecorder {\n+    pub fn new(ccx: @CrateContext, name: ~str) -> StatRecorder {\n         let start = if ccx.sess.trans_stats() {\n             time::precise_time_ns()\n         } else {\n@@ -149,23 +147,23 @@ impl<'a> StatRecorder<'a> {\n         let istart = ccx.stats.n_llvm_insns.get();\n         StatRecorder {\n             ccx: ccx,\n-            name: name,\n+            name: Some(name),\n             start: start,\n             istart: istart,\n         }\n     }\n }\n \n #[unsafe_destructor]\n-impl<'a> Drop for StatRecorder<'a> {\n+impl Drop for StatRecorder {\n     fn drop(&mut self) {\n         if self.ccx.sess.trans_stats() {\n             let end = time::precise_time_ns();\n             let elapsed = ((end - self.start) / 1_000_000) as uint;\n             let iend = self.ccx.stats.n_llvm_insns.get();\n             {\n                 let mut fn_stats = self.ccx.stats.fn_stats.borrow_mut();\n-                fn_stats.get().push((self.name.to_owned(),\n+                fn_stats.get().push((self.name.take_unwrap(),\n                                      elapsed,\n                                      iend - self.istart));\n             }\n@@ -589,15 +587,14 @@ pub fn compare_scalar_types<'a>(\n                             t: ty::t,\n                             op: ast::BinOp)\n                             -> Result<'a> {\n-    let f = |a| compare_scalar_values(cx, lhs, rhs, a, op);\n+    let f = |a| rslt(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n \n     match ty::get(t).sty {\n-        ty::ty_nil => rslt(cx, f(nil_type)),\n-        ty::ty_bool | ty::ty_ptr(_) => rslt(cx, f(unsigned_int)),\n-        ty::ty_char => rslt(cx, f(unsigned_int)),\n-        ty::ty_int(_) => rslt(cx, f(signed_int)),\n-        ty::ty_uint(_) => rslt(cx, f(unsigned_int)),\n-        ty::ty_float(_) => rslt(cx, f(floating_point)),\n+        ty::ty_nil => f(nil_type),\n+        ty::ty_bool | ty::ty_ptr(_) |\n+        ty::ty_uint(_) | ty::ty_char => f(unsigned_int),\n+        ty::ty_int(_) => f(signed_int),\n+        ty::ty_float(_) => f(floating_point),\n             // Should never get here, because t is scalar.\n         _ => cx.sess().bug(\"non-scalar type passed to compare_scalar_types\")\n     }\n@@ -914,10 +911,7 @@ pub fn invoke<'a>(\n             debug!(\"invoke at ???\");\n         }\n         Some(id) => {\n-            debug!(\"invoke at {}\",\n-                   ast_map::node_id_to_str(bcx.tcx().items,\n-                                           id,\n-                                           token::get_ident_interner()));\n+            debug!(\"invoke at {}\", bcx.tcx().map.node_to_str(id));\n         }\n     }\n \n@@ -1219,7 +1213,6 @@ pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n // Be warned! You must call `init_function` before doing anything with the\n // returned function context.\n pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n-                       path: ast_map::Path,\n                        llfndecl: ValueRef,\n                        id: ast::NodeId,\n                        has_env: bool,\n@@ -1230,12 +1223,9 @@ pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n                        -> FunctionContext<'a> {\n     for p in param_substs.iter() { p.validate(); }\n \n-    debug!(\"new_fn_ctxt(path={},\n-           id={:?}, \\\n-           param_substs={})\",\n-           path_str(ccx.sess, path),\n-           id,\n-           param_substs.repr(ccx.tcx));\n+    debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n+           if id == -1 { ~\"\" } else { ccx.tcx.map.path_to_str(id) },\n+           id, param_substs.repr(ccx.tcx));\n \n     let substd_output_type = match param_substs {\n         None => output_type,\n@@ -1261,7 +1251,6 @@ pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n           id: id,\n           param_substs: param_substs,\n           span: sp,\n-          path: path,\n           block_arena: block_arena,\n           ccx: ccx,\n           debug_context: debug_context,\n@@ -1439,7 +1428,6 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block) {\n // If the function closes over its environment a closure will be\n // returned.\n pub fn trans_closure<'a>(ccx: @CrateContext,\n-                         path: ast_map::Path,\n                          decl: &ast::FnDecl,\n                          body: &ast::Block,\n                          llfndecl: ValueRef,\n@@ -1463,7 +1451,6 @@ pub fn trans_closure<'a>(ccx: @CrateContext,\n \n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx,\n-                          path,\n                           llfndecl,\n                           id,\n                           has_env,\n@@ -1537,19 +1524,17 @@ pub fn trans_closure<'a>(ccx: @CrateContext,\n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n pub fn trans_fn(ccx: @CrateContext,\n-                path: ast_map::Path,\n                 decl: &ast::FnDecl,\n                 body: &ast::Block,\n                 llfndecl: ValueRef,\n                 param_substs: Option<@param_substs>,\n                 id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n-    let the_path_str = path_str(ccx.sess, path);\n-    let _s = StatRecorder::new(ccx, the_path_str);\n+    let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_str(id));\n     debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx));\n     let _icx = push_ctxt(\"trans_fn\");\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n-    trans_closure(ccx, path.clone(), decl, body, llfndecl,\n+    trans_closure(ccx, decl, body, llfndecl,\n                   param_substs, id, attrs, output_type, |bcx| bcx);\n }\n \n@@ -1616,15 +1601,8 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n     };\n \n     let arena = TypedArena::new();\n-    let fcx = new_fn_ctxt(ccx,\n-                          ~[],\n-                          llfndecl,\n-                          ctor_id,\n-                          false,\n-                          result_ty,\n-                          param_substs,\n-                          None,\n-                          &arena);\n+    let fcx = new_fn_ctxt(ccx, llfndecl, ctor_id, false, result_ty,\n+                          param_substs, None, &arena);\n     init_function(&fcx, false, result_ty, param_substs);\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n@@ -1684,29 +1662,15 @@ impl Visitor<()> for TransItemVisitor {\n \n pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n-    let path = {\n-        match ccx.tcx.items.get(item.id) {\n-            ast_map::NodeItem(_, p) => p,\n-            // tjc: ?\n-            _ => fail!(\"trans_item\"),\n-        }\n-    };\n     match item.node {\n       ast::ItemFn(decl, purity, _abis, ref generics, body) => {\n         if purity == ast::ExternFn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_rust_fn_with_foreign_abi(\n-                ccx,\n-                &vec::append_one((*path).clone(), PathName(item.ident)),\n-                decl,\n-                body,\n-                item.attrs,\n-                llfndecl,\n-                item.id);\n+                ccx, decl, body, item.attrs, llfndecl, item.id);\n         } else if !generics.is_type_parameterized() {\n-            let path = vec::append_one((*path).clone(), PathName(item.ident));\n             let llfn = get_item_val(ccx, item.id);\n-            trans_fn(ccx, path, decl, body, llfn, None, item.id, item.attrs);\n+            trans_fn(ccx, decl, body, llfn, None, item.id, item.attrs);\n         } else {\n             // Be sure to travel more than just one layer deep to catch nested\n             // items in blocks and such.\n@@ -1715,12 +1679,7 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n         }\n       }\n       ast::ItemImpl(ref generics, _, _, ref ms) => {\n-        meth::trans_impl(ccx,\n-                         (*path).clone(),\n-                         item.ident,\n-                         *ms,\n-                         generics,\n-                         item.id);\n+        meth::trans_impl(ccx, item.ident, *ms, generics, item.id);\n       }\n       ast::ItemMod(ref m) => {\n         trans_mod(ccx, m);\n@@ -1844,9 +1803,7 @@ pub fn register_fn_llvmty(ccx: @CrateContext,\n                           cc: lib::llvm::CallConv,\n                           fn_ty: Type,\n                           output: ty::t) -> ValueRef {\n-    debug!(\"register_fn_fuller creating fn for item {} with path {}\",\n-           node_id,\n-           ast_map::path_to_str(item_path(ccx, &node_id), token::get_ident_interner()));\n+    debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n     let llfn = decl_fn(ccx.llmod, sym, cc, fn_ty, output);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n@@ -1934,22 +1891,21 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n     }\n }\n \n-pub fn item_path(ccx: &CrateContext, id: &ast::NodeId) -> ast_map::Path {\n-    ty::item_path(ccx.tcx, ast_util::local_def(*id))\n-}\n-\n-fn exported_name(ccx: &CrateContext, path: ast_map::Path,\n+fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n                  ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n         Some(name) => name.get().to_owned(),\n \n-        // Don't mangle\n-        _ if attr::contains_name(attrs, \"no_mangle\")\n-            => path_elem_to_str(*path.last().unwrap(), token::get_ident_interner()),\n-\n-        // Usual name mangling\n-        _ => mangle_exported_name(ccx, path, ty)\n+        _ => ccx.tcx.map.with_path(id, |mut path| {\n+            if attr::contains_name(attrs, \"no_mangle\") {\n+                // Don't mangle\n+                path.last().unwrap().to_str()\n+            } else {\n+                // Usual name mangling\n+                mangle_exported_name(ccx, path, ty, id)\n+            }\n+        })\n     }\n }\n \n@@ -1965,14 +1921,11 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n         Some(v) => v,\n         None => {\n             let mut foreign = false;\n-            let item = ccx.tcx.items.get(id);\n+            let item = ccx.tcx.map.get(id);\n             let val = match item {\n-                ast_map::NodeItem(i, pth) => {\n-\n-                    let elt = PathPrettyName(i.ident, id as u64);\n-                    let my_path = vec::append_one((*pth).clone(), elt);\n+                ast_map::NodeItem(i) => {\n                     let ty = ty::node_id_to_type(ccx.tcx, i.id);\n-                    let sym = exported_name(ccx, my_path, ty, i.attrs);\n+                    let sym = exported_name(ccx, id, ty, i.attrs);\n \n                     let v = match i.node {\n                         ast::ItemStatic(_, _, expr) => {\n@@ -2100,31 +2053,31 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                     v\n                 }\n \n-                ast_map::NodeTraitMethod(trait_method, _, pth) => {\n+                ast_map::NodeTraitMethod(trait_method) => {\n                     debug!(\"get_item_val(): processing a NodeTraitMethod\");\n                     match *trait_method {\n                         ast::Required(_) => {\n                             ccx.sess.bug(\"unexpected variant: required trait method in \\\n                                          get_item_val()\");\n                         }\n                         ast::Provided(m) => {\n-                            register_method(ccx, id, pth, m)\n+                            register_method(ccx, id, m)\n                         }\n                     }\n                 }\n \n-                ast_map::NodeMethod(m, _, pth) => {\n-                    register_method(ccx, id, pth, m)\n+                ast_map::NodeMethod(m) => {\n+                    register_method(ccx, id, m)\n                 }\n \n-                ast_map::NodeForeignItem(ni, abis, _, pth) => {\n+                ast_map::NodeForeignItem(ni) => {\n                     let ty = ty::node_id_to_type(ccx.tcx, ni.id);\n                     foreign = true;\n \n                     match ni.node {\n                         ast::ForeignItemFn(..) => {\n-                            let path = vec::append_one((*pth).clone(), PathName(ni.ident));\n-                            foreign::register_foreign_item_fn(ccx, abis, &path, ni)\n+                            let abis = ccx.tcx.map.get_foreign_abis(id);\n+                            foreign::register_foreign_item_fn(ccx, abis, ni)\n                         }\n                         ast::ForeignItemStatic(..) => {\n                             // Treat the crate map static specially in order to\n@@ -2165,16 +2118,15 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                     }\n                 }\n \n-                ast_map::NodeVariant(ref v, enm, pth) => {\n+                ast_map::NodeVariant(ref v) => {\n                     let llfn;\n                     match v.node.kind {\n                         ast::TupleVariantKind(ref args) => {\n                             assert!(args.len() != 0u);\n-                            let pth = vec::append((*pth).clone(),\n-                                                  [PathName(enm.ident),\n-                                                   PathName((*v).node.name)]);\n                             let ty = ty::node_id_to_type(ccx.tcx, id);\n-                            let sym = exported_name(ccx, pth, ty, enm.attrs);\n+                            let parent = ccx.tcx.map.get_parent(id);\n+                            let enm = ccx.tcx.map.expect_item(parent);\n+                            let sym = exported_name(ccx, id, ty, enm.attrs);\n \n                             llfn = match enm.node {\n                                 ast::ItemEnum(_, _) => {\n@@ -2191,17 +2143,18 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                     llfn\n                 }\n \n-                ast_map::NodeStructCtor(struct_def, struct_item, struct_path) => {\n+                ast_map::NodeStructCtor(struct_def) => {\n                     // Only register the constructor if this is a tuple-like struct.\n                     match struct_def.ctor_id {\n                         None => {\n                             ccx.tcx.sess.bug(\"attempt to register a constructor of \\\n                                               a non-tuple-like struct\")\n                         }\n                         Some(ctor_id) => {\n+                            let parent = ccx.tcx.map.get_parent(id);\n+                            let struct_item = ccx.tcx.map.expect_item(parent);\n                             let ty = ty::node_id_to_type(ccx.tcx, ctor_id);\n-                            let sym = exported_name(ccx, (*struct_path).clone(), ty,\n-                                                    struct_item.attrs);\n+                            let sym = exported_name(ccx, id, ty, struct_item.attrs);\n                             let llfn = register_fn(ccx, struct_item.span,\n                                                    sym, ctor_id, ty);\n                             set_inline_hint(llfn);\n@@ -2233,16 +2186,11 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n     }\n }\n \n-fn register_method(ccx: @CrateContext,\n-                   id: ast::NodeId,\n-                   path: @ast_map::Path,\n+fn register_method(ccx: @CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n \n-    let mut path = (*path).clone();\n-    path.push(PathPrettyName(m.ident, token::gensym(\"meth\") as u64));\n-\n-    let sym = exported_name(ccx, path, mty, m.attrs);\n+    let sym = exported_name(ccx, id, mty, m.attrs);\n \n     let llfn = register_fn(ccx, m.span, sym, id, mty);\n     set_llvm_fn_attrs(m.attrs, llfn);\n@@ -2489,10 +2437,9 @@ pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n     return (map, keys.len())\n }\n \n-pub fn symname(sess: session::Session, name: &str,\n-               hash: &str, vers: &str) -> ~str {\n-    let elt = PathName(sess.ident_of(name));\n-    link::exported_name(sess, ~[elt], hash, vers)\n+pub fn symname(name: &str, hash: &str, vers: &str) -> ~str {\n+    let path = [PathName(token::intern(name))];\n+    link::exported_name(ast_map::Values(path.iter()).chain(None), hash, vers)\n }\n \n pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n@@ -2506,7 +2453,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let sym_name = if is_top {\n         ~\"_rust_crate_map_toplevel\"\n     } else {\n-        symname(sess, \"_rust_crate_map_\" + mapmeta.crateid.name, mapmeta.crate_hash,\n+        symname(\"_rust_crate_map_\" + mapmeta.crateid.name, mapmeta.crate_hash,\n                 mapmeta.crateid.version_or_default())\n     };\n \n@@ -2539,7 +2486,7 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n     let cstore = ccx.sess.cstore;\n     while cstore.have_crate_data(i) {\n         let cdata = cstore.get_crate_data(i);\n-        let nm = symname(ccx.sess, format!(\"_rust_crate_map_{}\", cdata.name),\n+        let nm = symname(format!(\"_rust_crate_map_{}\", cdata.name),\n                          cstore.get_crate_hash(i),\n                          cstore.get_crate_vers(i));\n         let cr = nm.with_c_str(|buf| {\n@@ -2590,7 +2537,7 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n     }\n }\n \n-pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_inlined_item<'r>)\n+pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeInlinedItem<'r>)\n     -> encoder::EncodeParams<'r> {\n \n         let diag = cx.sess.diagnostic();\n@@ -2617,9 +2564,8 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> ~[u8] {\n         return ~[]\n     }\n \n-    let encode_inlined_item: encoder::encode_inlined_item =\n-        |ecx, ebml_w, path, ii|\n-        astencode::encode_inlined_item(ecx, ebml_w, path, ii, cx.maps);\n+    let encode_inlined_item: encoder::EncodeInlinedItem =\n+        |ecx, ebml_w, ii| astencode::encode_inlined_item(ecx, ebml_w, ii, cx.maps);\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);"}, {"sha": "cfba7f03fc9e941e50629a38538df0af3559097a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -357,28 +357,23 @@ pub fn trans_fn_ref_with_vtables(\n     // intrinsic, or is a default method.  In particular, if we see an\n     // intrinsic that is inlined from a different crate, we want to reemit the\n     // intrinsic instead of trying to call it in the other crate.\n-    let must_monomorphise;\n-    if type_params.len() > 0 || is_default {\n-        must_monomorphise = true;\n+    let must_monomorphise = if type_params.len() > 0 || is_default {\n+        true\n     } else if def_id.krate == ast::LOCAL_CRATE {\n-        {\n-            let map_node = session::expect(\n-                ccx.sess,\n-                ccx.tcx.items.find(def_id.node),\n-                || format!(\"local item should be in ast map\"));\n-\n-            match map_node {\n-                ast_map::NodeForeignItem(_, abis, _, _) => {\n-                    must_monomorphise = abis.is_intrinsic()\n-                }\n-                _ => {\n-                    must_monomorphise = false;\n-                }\n+        let map_node = session::expect(\n+            ccx.sess,\n+            ccx.tcx.map.find(def_id.node),\n+            || format!(\"local item should be in ast map\"));\n+\n+        match map_node {\n+            ast_map::NodeForeignItem(_) => {\n+                ccx.tcx.map.get_foreign_abis(def_id.node).is_intrinsic()\n             }\n+            _ => false\n         }\n     } else {\n-        must_monomorphise = false;\n-    }\n+        false\n+    };\n \n     // Create a monomorphic verison of generic functions\n     if must_monomorphise {"}, {"sha": "5bbb9749a592a87e2f4d6cacbe27794120fe0372", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -24,8 +24,6 @@ use middle::trans::glue;\n use middle::trans::type_::Type;\n use middle::ty;\n use syntax::ast;\n-use syntax::ast_map;\n-use syntax::parse::token;\n use syntax::opt_vec;\n use syntax::opt_vec::OptVec;\n use util::ppaux::Repr;\n@@ -89,8 +87,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"push_ast_cleanup_scope({})\",\n-               ast_map::node_id_to_str(self.ccx.tcx.items, id,\n-                                       token::get_ident_interner()));\n+               self.ccx.tcx.map.node_to_str(id));\n \n         // FIXME(#2202) -- currently closure bodies have a parent\n         // region, which messes up the assertion below, since there\n@@ -114,8 +111,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                                id: ast::NodeId,\n                                exits: [&'a Block<'a>, ..EXIT_MAX]) {\n         debug!(\"push_loop_cleanup_scope({})\",\n-               ast_map::node_id_to_str(self.ccx.tcx.items, id,\n-                                       token::get_ident_interner()));\n+               self.ccx.tcx.map.node_to_str(id));\n         assert_eq!(Some(id), self.top_ast_scope());\n \n         self.push_scope(CleanupScope::new(LoopScopeKind(id, exits)));\n@@ -139,8 +135,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"pop_and_trans_ast_cleanup_scope({})\",\n-               ast_map::node_id_to_str(self.ccx.tcx.items, cleanup_scope,\n-                                       token::get_ident_interner()));\n+               self.ccx.tcx.map.node_to_str(cleanup_scope));\n \n         assert!(self.top_scope(|s| s.kind.is_ast_with_id(cleanup_scope)));\n \n@@ -159,8 +154,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         debug!(\"pop_loop_cleanup_scope({})\",\n-               ast_map::node_id_to_str(self.ccx.tcx.items, cleanup_scope,\n-                                       token::get_ident_interner()));\n+               self.ccx.tcx.map.node_to_str(cleanup_scope));\n \n         assert!(self.top_scope(|s| s.kind.is_loop_with_id(cleanup_scope)));\n \n@@ -338,8 +332,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         self.ccx.tcx.sess.bug(\n             format!(\"no cleanup scope {} found\",\n-                    ast_map::node_id_to_str(self.ccx.tcx.items, cleanup_scope,\n-                                            token::get_ident_interner())));\n+                    self.ccx.tcx.map.node_to_str(cleanup_scope)));\n     }\n \n     fn schedule_clean_in_custom_scope(&self,"}, {"sha": "2be53b92db160dce31f27bdf27f66a92e9b2a111", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -26,11 +26,8 @@ use util::ppaux::Repr;\n use util::ppaux::ty_to_str;\n \n use arena::TypedArena;\n-use std::vec;\n use syntax::ast;\n-use syntax::ast_map::PathName;\n use syntax::ast_util;\n-use syntax::parse::token::special_idents;\n \n // ___Good to know (tm)__________________________________________________\n //\n@@ -353,8 +350,7 @@ pub fn trans_expr_fn<'a>(\n                      sigil: ast::Sigil,\n                      decl: &ast::FnDecl,\n                      body: &ast::Block,\n-                     outer_id: ast::NodeId,\n-                     user_id: ast::NodeId,\n+                     id: ast::NodeId,\n                      dest: expr::Dest)\n                      -> &'a Block<'a> {\n     /*!\n@@ -364,13 +360,7 @@ pub fn trans_expr_fn<'a>(\n      * - `sigil`\n      * - `decl`\n      * - `body`\n-     * - `outer_id`: The id of the closure expression with the correct\n-     *   type.  This is usually the same as `user_id`, but in the\n-     *   case of a `for` loop, the `outer_id` will have the return\n-     *   type of boolean, and the `user_id` will have the return type\n-     *   of `nil`.\n-     * - `user_id`: The id of the closure as the user expressed it.\n-         Generally the same as `outer_id`\n+     * - `id`: The id of the closure expression.\n      * - `cap_clause`: information about captured variables, if any.\n      * - `dest`: where to write the closure value, which must be a\n          (fn ptr, env) pair\n@@ -386,30 +376,28 @@ pub fn trans_expr_fn<'a>(\n     };\n \n     let ccx = bcx.ccx();\n-    let fty = node_id_type(bcx, outer_id);\n+    let fty = node_id_type(bcx, id);\n     let f = match ty::get(fty).sty {\n         ty::ty_closure(ref f) => f,\n         _ => fail!(\"expected closure\")\n     };\n \n-    let sub_path = vec::append_one(bcx.fcx.path.clone(),\n-                                   PathName(special_idents::anon));\n-    // FIXME: Bad copy.\n-    let s = mangle_internal_name_by_path_and_seq(ccx,\n-                                                 sub_path.clone(),\n-                                                 \"expr_fn\");\n+    let tcx = bcx.tcx();\n+    let s = tcx.map.with_path(id, |path| {\n+        mangle_internal_name_by_path_and_seq(path, \"closure\")\n+    });\n     let llfn = decl_internal_rust_fn(ccx, true, f.sig.inputs, f.sig.output, s);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n \n     let cap_vars = {\n         let capture_map = ccx.maps.capture_map.borrow();\n-        capture_map.get().get_copy(&user_id)\n+        capture_map.get().get_copy(&id)\n     };\n     let ClosureResult {llbox, cdata_ty, bcx} = build_closure(bcx, *cap_vars.borrow(), sigil);\n-    trans_closure(ccx, sub_path, decl, body, llfn,\n-                  bcx.fcx.param_substs, user_id,\n+    trans_closure(ccx, decl, body, llfn,\n+                  bcx.fcx.param_substs, id,\n                   [], ty::ty_fn_ret(fty),\n                   |bcx| load_environment(bcx, cdata_ty, *cap_vars.borrow(), sigil));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n@@ -454,8 +442,9 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n         }\n     };\n \n-    let path = ty::item_path(tcx, def_id);\n-    let name = mangle_internal_name_by_path_and_seq(ccx, path, \"as_closure\");\n+    let name = ty::with_path(tcx, def_id, |path| {\n+        mangle_internal_name_by_path_and_seq(path, \"as_closure\")\n+    });\n     let llfn = if is_local {\n         decl_internal_rust_fn(ccx, true, f.sig.inputs, f.sig.output, name)\n     } else {\n@@ -476,8 +465,7 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n     let _icx = push_ctxt(\"closure::get_wrapper_for_bare_fn\");\n \n     let arena = TypedArena::new();\n-    let fcx = new_fn_ctxt(ccx, ~[], llfn, -1, true, f.sig.output, None, None,\n-                          &arena);\n+    let fcx = new_fn_ctxt(ccx, llfn, -1, true, f.sig.output, None, None, &arena);\n     init_function(&fcx, true, f.sig.output, None);\n     let bcx = fcx.entry_bcx.get().unwrap();\n "}, {"sha": "e29e65857837edee7b011c49d93f81eb8f8a3c53", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -10,8 +10,6 @@\n \n //! Code that is useful in various trans modules.\n \n-\n-use driver::session;\n use driver::session::Session;\n use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef};\n use lib::llvm::{True, False, Bool};\n@@ -37,12 +35,12 @@ use std::cast;\n use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_longlong, c_ulonglong, c_char};\n-use syntax::ast::{Ident};\n-use syntax::ast_map::{Path, PathElem, PathPrettyName};\n+use syntax::ast::Ident;\n+use syntax::ast;\n+use syntax::ast_map::{PathElem, PathName};\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n-use syntax::{ast, ast_map};\n \n pub use middle::trans::context::CrateContext;\n \n@@ -102,10 +100,8 @@ pub fn return_type_is_void(ccx: &CrateContext, ty: ty::t) -> bool {\n     ty::type_is_nil(ty) || ty::type_is_bot(ty) || ty::type_is_empty(ccx.tcx, ty)\n }\n \n-pub fn gensym_name(name: &str) -> (Ident, PathElem) {\n-    let name = token::gensym(name);\n-    let ident = Ident::new(name);\n-    (ident, PathPrettyName(ident, name as u64))\n+pub fn gensym_name(name: &str) -> PathElem {\n+    PathName(token::gensym(name))\n }\n \n pub struct tydesc_info {\n@@ -277,7 +273,6 @@ pub struct FunctionContext<'a> {\n     // The source span and nesting context where this function comes from, for\n     // error reporting and symbol generation.\n     span: Option<Span>,\n-    path: Path,\n \n     // The arena that blocks are allocated from.\n     block_arena: &'a TypedArena<Block<'a>>,\n@@ -446,12 +441,11 @@ impl<'a> Block<'a> {\n     pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n \n     pub fn ident(&self, ident: Ident) -> ~str {\n-        let string = token::get_ident(ident.name);\n-        string.get().to_str()\n+        token::get_ident(ident).get().to_str()\n     }\n \n     pub fn node_id_to_str(&self, id: ast::NodeId) -> ~str {\n-        ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n+        self.tcx().map.node_to_str(id)\n     }\n \n     pub fn expr_to_str(&self, e: &ast::Expr) -> ~str {\n@@ -785,25 +779,6 @@ pub fn align_to(cx: &Block, off: ValueRef, align: ValueRef) -> ValueRef {\n     return build::And(cx, bumped, build::Not(cx, mask));\n }\n \n-pub fn path_str(sess: session::Session, p: &[PathElem]) -> ~str {\n-    let mut r = ~\"\";\n-    let mut first = true;\n-    for e in p.iter() {\n-        match *e {\n-            ast_map::PathName(s) | ast_map::PathMod(s) |\n-            ast_map::PathPrettyName(s, _) => {\n-                if first {\n-                    first = false\n-                } else {\n-                    r.push_str(\"::\")\n-                }\n-                r.push_str(sess.str_of(s));\n-            }\n-        }\n-    }\n-    r\n-}\n-\n pub fn monomorphize_type(bcx: &Block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n         Some(substs) => {"}, {"sha": "9c04f6d9399facc43944605dd592ea65a1a606c0", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -34,7 +34,7 @@ use middle::trans::type_::Type;\n use std::c_str::ToCStr;\n use std::libc::c_uint;\n use std::vec;\n-use syntax::{ast, ast_util, ast_map};\n+use syntax::{ast, ast_util};\n \n pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n     -> ValueRef {\n@@ -170,18 +170,11 @@ pub fn get_const_val(cx: @CrateContext,\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n         }\n \n-        let opt_item = cx.tcx.items.get(def_id.node);\n-\n-        match opt_item {\n-            ast_map::NodeItem(item, _) => {\n-                match item.node {\n-                    ast::ItemStatic(_, ast::MutImmutable, _) => {\n-                        trans_const(cx, ast::MutImmutable, def_id.node);\n-                    }\n-                    _ => {}\n-                }\n+        match cx.tcx.map.expect_item(def_id.node).node {\n+            ast::ItemStatic(_, ast::MutImmutable, _) => {\n+                trans_const(cx, ast::MutImmutable, def_id.node);\n             }\n-            _ => cx.tcx.sess.bug(\"expected a const to be an item\")\n+            _ => {}\n         }\n     }\n "}, {"sha": "74450695ae758f26b92e73edcc19a195cefc6566", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 115, "deletions": 169, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -176,7 +176,7 @@ pub struct CrateDebugContext {\n     priv current_debug_location: Cell<DebugLocation>,\n     priv created_files: RefCell<HashMap<~str, DIFile>>,\n     priv created_types: RefCell<HashMap<uint, DIType>>,\n-    priv namespace_map: RefCell<HashMap<~[ast::Ident], @NamespaceTreeNode>>,\n+    priv namespace_map: RefCell<HashMap<~[ast::Name], @NamespaceTreeNode>>,\n     // This collection is used to assert that composite types (structs, enums, ...) have their\n     // members only set once:\n     priv composite_types_completed: RefCell<HashSet<DIType>>,\n@@ -332,7 +332,7 @@ pub fn create_captured_var_metadata(bcx: &Block,\n \n     let cx = bcx.ccx();\n \n-    let ast_item = cx.tcx.items.find(node_id);\n+    let ast_item = cx.tcx.map.find(node_id);\n \n     let variable_ident = match ast_item {\n         None => {\n@@ -540,10 +540,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n     let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n \n-    let fnitem = cx.tcx.items.get(fn_ast_id);\n+    let fnitem = cx.tcx.map.get(fn_ast_id);\n \n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n-        ast_map::NodeItem(ref item, _) => {\n+        ast_map::NodeItem(ref item) => {\n             match item.node {\n                 ast::ItemFn(fn_decl, _, _, ref generics, top_level_block) => {\n                     (item.ident, fn_decl, generics, top_level_block, item.span, true)\n@@ -554,7 +554,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 }\n             }\n         }\n-        ast_map::NodeMethod(method, _, _) => {\n+        ast_map::NodeMethod(method) => {\n             (method.ident,\n              method.decl,\n              &method.generics,\n@@ -581,7 +581,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n-        ast_map::NodeTraitMethod(trait_method, _, _) => {\n+        ast_map::NodeTraitMethod(trait_method) => {\n             match *trait_method {\n                 ast::Provided(method) => {\n                     (method.ident,\n@@ -622,8 +622,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     };\n \n     // get_template_parameters() will append a `<...>` clause to the function name if necessary.\n-    let function_name_string = token::get_ident(ident.name);\n-    let mut function_name = function_name_string.get().to_owned();\n+    let mut function_name = token::get_ident(ident).get().to_str();\n     let template_parameters = get_template_parameters(cx,\n                                                       generics,\n                                                       param_substs,\n@@ -634,7 +633,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     // into a namespace. In the future this could be improved somehow (storing a path in the\n     // ast_map, or construct a path using the enclosing function).\n     let (linkage_name, containing_scope) = if has_path {\n-        let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id), span);\n+        let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n         let linkage_name = namespace_node.mangled_name_of_contained_item(function_name);\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n@@ -792,9 +791,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n                 let ident = special_idents::type_self;\n \n-                let param_metadata_string = token::get_ident(ident.name);\n-                let param_metadata = param_metadata_string.get()\n-                                                          .with_c_str(|name| {\n+                let param_metadata = token::get_ident(ident).get()\n+                                                            .with_c_str(|name| {\n                     unsafe {\n                         llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                             DIB(cx),\n@@ -832,9 +830,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             // Again, only create type information if debuginfo is enabled\n             if cx.sess.opts.debuginfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n-                let param_metadata_string = token::get_ident(ident.name);\n-                let param_metadata = param_metadata_string.get()\n-                                                          .with_c_str(|name| {\n+                let param_metadata = token::get_ident(ident).get()\n+                                                            .with_c_str(|name| {\n                     unsafe {\n                         llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                             DIB(cx),\n@@ -939,8 +936,7 @@ fn declare_local(bcx: &Block,\n     let filename = span_start(cx, span).file.name.clone();\n     let file_metadata = file_metadata(cx, filename);\n \n-    let variable_ident_string = token::get_ident(variable_ident.name);\n-    let name: &str = variable_ident_string.get();\n+    let name = token::get_ident(variable_ident);\n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);\n \n@@ -950,7 +946,7 @@ fn declare_local(bcx: &Block,\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n \n-    let (var_alloca, var_metadata) = name.with_c_str(|name| {\n+    let (var_alloca, var_metadata) = name.get().with_c_str(|name| {\n         match variable_access {\n             DirectVariable { alloca } => (\n                 alloca,\n@@ -1056,7 +1052,7 @@ fn scope_metadata(fcx: &FunctionContext,\n     match scope_map.get().find_copy(&node_id) {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n-            let node = fcx.ccx.tcx.items.get(node_id);\n+            let node = fcx.ccx.tcx.map.get(node_id);\n \n             fcx.ccx.sess.span_bug(span,\n                 format!(\"debuginfo: Could not find scope info for node {:?}\", node));\n@@ -1169,8 +1165,7 @@ impl StructMemberDescriptionFactory {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n                 ~\"\"\n             } else {\n-                let string = token::get_ident(field.ident.name);\n-                string.get().to_str()\n+                token::get_ident(field.ident).get().to_str()\n             };\n \n             MemberDescription {\n@@ -1192,7 +1187,7 @@ fn prepare_struct_metadata(cx: &CrateContext,\n     let struct_name = ppaux::ty_to_str(cx.tcx, struct_type);\n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n \n-    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id, span);\n+    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n \n     let file_name = span_start(cx, definition_span).file.name.clone();\n     let file_metadata = file_metadata(cx, file_name);\n@@ -1391,45 +1386,29 @@ fn describe_enum_variant(cx: &CrateContext,\n                          file_metadata: DIFile,\n                          span: Span)\n                       -> (DICompositeType, Type, MemberDescriptionFactory) {\n-    let variant_info_string = token::get_ident(variant_info.name.name);\n-    let variant_name = variant_info_string.get();\n     let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n                                           struct_def.packed);\n     // Could some consistency checks here: size, align, field count, discr type\n \n     // Find the source code location of the variant's definition\n     let variant_definition_span = if variant_info.id.krate == ast::LOCAL_CRATE {\n-        {\n-            match cx.tcx.items.find(variant_info.id.node) {\n-                Some(ast_map::NodeVariant(ref variant, _, _)) => variant.span,\n-                ref node => {\n-                    cx.sess.span_warn(span,\n-                        format!(\"debuginfo::enum_metadata()::\\\n-                                 adt_struct_metadata() - Unexpected node \\\n-                                 type: {:?}. This is a bug.\", node));\n-                    codemap::DUMMY_SP\n-                }\n-            }\n-        }\n+        cx.tcx.map.span(variant_info.id.node)\n     } else {\n         // For definitions from other crates we have no location information available.\n         codemap::DUMMY_SP\n     };\n \n     let metadata_stub = create_struct_stub(cx,\n                                            variant_llvm_type,\n-                                           variant_name,\n+                                           token::get_ident(variant_info.name).get(),\n                                            containing_scope,\n                                            file_metadata,\n                                            variant_definition_span);\n \n     // Get the argument names from the enum variant info\n     let mut arg_names = match variant_info.arg_names {\n         Some(ref names) => {\n-            names.map(|ident| {\n-                let string = token::get_ident(ident.name);\n-                string.get().to_str()\n-            })\n+            names.map(|ident| token::get_ident(*ident).get().to_str())\n         }\n         None => variant_info.args.map(|_| ~\"\")\n     };\n@@ -1462,9 +1441,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                       -> RecursiveTypeDescription {\n     let enum_name = ppaux::ty_to_str(cx.tcx, enum_type);\n \n-    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx,\n-                                                                              enum_def_id,\n-                                                                              span);\n+    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n@@ -1487,16 +1464,12 @@ fn prepare_enum_metadata(cx: &CrateContext,\n     let enumerators_metadata: ~[DIDescriptor] = variants\n         .iter()\n         .map(|v| {\n-            let string = token::get_ident(v.name.name);\n-            let name: &str = string.get();\n-            let discriminant_value = v.disr_val as c_ulonglong;\n-\n-            name.with_c_str(|name| {\n+            token::get_ident(v.name).get().with_c_str(|name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateEnumerator(\n                         DIB(cx),\n                         name,\n-                        discriminant_value)\n+                        v.disr_val as c_ulonglong)\n                 }\n             })\n         })\n@@ -2007,24 +1980,21 @@ fn trait_metadata(cx: &CrateContext,\n                   substs: &ty::substs,\n                   trait_store: ty::TraitStore,\n                   mutability: ast::Mutability,\n-                  _: &ty::BuiltinBounds,\n-                  usage_site_span: Span)\n+                  _: &ty::BuiltinBounds)\n                -> DIType {\n     // The implementation provided here is a stub. It makes sure that the trait type is\n     // assigned the correct name, size, namespace, and source location. But it does not describe\n     // the trait's methods.\n-    let path = ty::item_path(cx.tcx, def_id);\n-    let ident = path.last().unwrap().ident();\n-    let ident_string = token::get_ident(ident.name);\n+    let last = ty::with_path(cx.tcx, def_id, |mut path| path.last().unwrap());\n+    let ident_string = token::get_name(last.name());\n     let name = ppaux::trait_store_to_str(cx.tcx, trait_store) +\n                ppaux::mutability_to_str(mutability) +\n                ident_string.get();\n     // Add type and region parameters\n     let name = ppaux::parameterized(cx.tcx, name, &substs.regions,\n                                     substs.tps, def_id, true);\n \n-    let (containing_scope, definition_span) =\n-        get_namespace_and_span_for_item(cx, def_id, usage_site_span);\n+    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n \n     let file_name = span_start(cx, definition_span).file.name.clone();\n     let file_metadata = file_metadata(cx, file_name);\n@@ -2138,7 +2108,7 @@ fn type_metadata(cx: &CrateContext,\n             subroutine_type_metadata(cx, &closurety.sig, usage_site_span)\n         },\n         ty::ty_trait(def_id, ref substs, trait_store, mutability, ref bounds) => {\n-            trait_metadata(cx, def_id, t, substs, trait_store, mutability, bounds, usage_site_span)\n+            trait_metadata(cx, def_id, t, substs, trait_store, mutability, bounds)\n         },\n         ty::ty_struct(def_id, ref substs) => {\n             prepare_struct_metadata(cx, t, def_id, substs, usage_site_span).finalize(cx)\n@@ -2256,25 +2226,11 @@ fn assert_type_for_node_id(cx: &CrateContext, node_id: ast::NodeId, error_span:\n     }\n }\n \n-fn get_namespace_and_span_for_item(cx: &CrateContext,\n-                                   def_id: ast::DefId,\n-                                   warning_span: Span)\n-                                -> (DIScope, Span) {\n-    let containing_scope = namespace_for_item(cx, def_id, warning_span).scope;\n+fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n+                                   -> (DIScope, Span) {\n+    let containing_scope = namespace_for_item(cx, def_id).scope;\n     let definition_span = if def_id.krate == ast::LOCAL_CRATE {\n-        {\n-            let definition_span = match cx.tcx.items.find(def_id.node) {\n-                Some(ast_map::NodeItem(item, _)) => item.span,\n-                ref node => {\n-                    cx.sess.span_warn(warning_span,\n-                        format!(\"debuginfo::\\\n-                                 get_namespace_and_span_for_item() \\\n-                                 - Unexpected node type: {:?}\", *node));\n-                    codemap::DUMMY_SP\n-                }\n-            };\n-            definition_span\n-        }\n+        cx.tcx.map.span(def_id.node)\n     } else {\n         // For external items there is no span information\n         codemap::DUMMY_SP\n@@ -2745,122 +2701,112 @@ fn populate_scope_map(cx: &CrateContext,\n //=-------------------------------------------------------------------------------------------------\n \n struct NamespaceTreeNode {\n-    ident: ast::Ident,\n+    name: ast::Name,\n     scope: DIScope,\n     parent: Option<@NamespaceTreeNode>,\n }\n \n impl NamespaceTreeNode {\n     fn mangled_name_of_contained_item(&self, item_name: &str) -> ~str {\n-        let mut name = ~\"_ZN\";\n-        fill_nested(self, &mut name);\n-\n-        name.push_str(format!(\"{}{}\", item_name.len(), item_name));\n-        name.push_char('E');\n-\n-        return name;\n-\n         fn fill_nested(node: &NamespaceTreeNode, output: &mut ~str) {\n             match node.parent {\n-                Some(parent) => {\n-                    fill_nested(parent, output);\n-                }\n+                Some(parent) => fill_nested(parent, output),\n                 None => {}\n             }\n-            let string = token::get_ident(node.ident.name);\n-            output.push_str(format!(\"{}{}\",\n-                                    string.get().len(),\n-                                    string.get()));\n+            let string = token::get_name(node.name);\n+            output.push_str(format!(\"{}\", string.get().len()));\n+            output.push_str(string.get());\n         }\n+\n+        let mut name = ~\"_ZN\";\n+        fill_nested(self, &mut name);\n+        name.push_str(format!(\"{}\", item_name.len()));\n+        name.push_str(item_name);\n+        name.push_char('E');\n+        name\n     }\n }\n \n-fn namespace_for_item(cx: &CrateContext,\n-                      def_id: ast::DefId,\n-                      warning_span: Span)\n-                   -> @NamespaceTreeNode {\n-    let namespace_path = {\n-        let mut item_path = ty::item_path(cx.tcx, def_id);\n-\n-        if (def_id.krate == ast::LOCAL_CRATE && item_path.len() < 1) ||\n-           (def_id.krate != ast::LOCAL_CRATE && item_path.len() < 2) {\n-            cx.sess.bug(format!(\"debuginfo::namespace_for_item() - Item path too short: {}\",\n-                ast_map::path_to_str(item_path, token::get_ident_interner())));\n-        }\n-\n-        // remove the name of the item\n-        item_path.pop();\n-\n-        if def_id.krate == ast::LOCAL_CRATE {\n-            // prepend crate name if not already present\n+fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNode {\n+    ty::with_path(cx.tcx, def_id, |path| {\n+        // prepend crate name if not already present\n+        let krate = if def_id.krate == ast::LOCAL_CRATE {\n             let crate_namespace_ident = token::str_to_ident(cx.link_meta.crateid.name);\n-            item_path.insert(0, ast_map::PathMod(crate_namespace_ident));\n-        }\n-\n-        item_path\n-    };\n-\n-    let mut current_key = vec::with_capacity(namespace_path.len());\n-    let mut parent_node: Option<@NamespaceTreeNode> = None;\n-    let last_index = namespace_path.len() - 1;\n+            Some(ast_map::PathMod(crate_namespace_ident.name))\n+        } else {\n+            None\n+        };\n+        let mut path = krate.move_iter().chain(path).peekable();\n \n-    // Create/Lookup namespace for each element of the path.\n-    for (i, &path_element) in namespace_path.iter().enumerate() {\n-        let ident = path_element.ident();\n-        current_key.push(ident);\n+        let mut current_key = ~[];\n+        let mut parent_node: Option<@NamespaceTreeNode> = None;\n \n-        let existing_node = {\n-            let namespace_map = debug_context(cx).namespace_map.borrow();\n-            namespace_map.get().find_copy(&current_key)\n-        };\n-        let current_node = match existing_node {\n-            Some(existing_node) => existing_node,\n-            None => {\n-                // create and insert\n-                let parent_scope = match parent_node {\n-                    Some(node) => node.scope,\n-                    None => ptr::null()\n-                };\n-                let namespace_name_string = token::get_ident(ident.name);\n-                let namespace_name = namespace_name_string.get();\n+        // Create/Lookup namespace for each element of the path.\n+        loop {\n+            // Emulate a for loop so we can use peek below.\n+            let path_element = match path.next() {\n+                Some(e) => e,\n+                None => break\n+            };\n+            // Ignore the name of the item (the last path element).\n+            if path.peek().is_none() {\n+                break;\n+            }\n \n-                let namespace_metadata = unsafe {\n-                    namespace_name.with_c_str(|namespace_name| {\n-                        llvm::LLVMDIBuilderCreateNameSpace(\n-                            DIB(cx),\n-                            parent_scope,\n-                            namespace_name,\n-                            ptr::null(), // cannot reconstruct file ...\n-                            0)           // ... or line information, but that's not so important.\n-                    })\n-                };\n+            let name = path_element.name();\n+            current_key.push(name);\n \n-                let node = @NamespaceTreeNode {\n-                    ident: ident,\n-                    scope: namespace_metadata,\n-                    parent: parent_node,\n-                };\n+            let existing_node = {\n+                let namespace_map = debug_context(cx).namespace_map.borrow();\n+                namespace_map.get().find_copy(&current_key)\n+            };\n+            let current_node = match existing_node {\n+                Some(existing_node) => existing_node,\n+                None => {\n+                    // create and insert\n+                    let parent_scope = match parent_node {\n+                        Some(node) => node.scope,\n+                        None => ptr::null()\n+                    };\n+                    let namespace_name = token::get_name(name);\n+                    let scope = namespace_name.get().with_c_str(|namespace_name| {\n+                        unsafe {\n+                            llvm::LLVMDIBuilderCreateNameSpace(\n+                                DIB(cx),\n+                                parent_scope,\n+                                namespace_name,\n+                                // cannot reconstruct file ...\n+                                ptr::null(),\n+                                // ... or line information, but that's not so important.\n+                                0)\n+                        }\n+                    });\n+\n+                    let node = @NamespaceTreeNode {\n+                        name: name,\n+                        scope: scope,\n+                        parent: parent_node,\n+                    };\n+\n+                    {\n+                        let mut namespace_map = debug_context(cx).namespace_map\n+                                                                 .borrow_mut();\n+                        namespace_map.get().insert(current_key.clone(), node);\n+                    }\n \n-                {\n-                    let mut namespace_map = debug_context(cx).namespace_map\n-                                                             .borrow_mut();\n-                    namespace_map.get().insert(current_key.clone(), node);\n+                    node\n                 }\n+            };\n \n-                node\n-            }\n-        };\n-\n-        if i == last_index {\n-            return current_node;\n-        } else {\n             parent_node = Some(current_node);\n         }\n-    }\n \n-    // Should be unreachable:\n-    let error_message = format!(\"debuginfo::namespace_for_item() - Code path should be \\\n-                                 unreachable. namespace_path was {}\",\n-                                 ast_map::path_to_str(namespace_path, token::get_ident_interner()));\n-    cx.sess.span_bug(warning_span, error_message);\n+        match parent_node {\n+            Some(node) => node,\n+            None => {\n+                cx.sess.bug(format!(\"debuginfo::namespace_for_item(): \\\n+                    path too short for {:?}\", def_id));\n+            }\n+        }\n+    })\n }"}, {"sha": "357e2e5e9ef6acc291a8b8d25f61931fe6ef9587", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -70,10 +70,11 @@ use middle::trans::type_::Type;\n \n use std::hashmap::HashMap;\n use std::vec;\n-use syntax::print::pprust::{expr_to_str};\n use syntax::ast;\n-use syntax::ast_map::PathMod;\n+use syntax::ast_map;\n use syntax::codemap;\n+use syntax::parse::token;\n+use syntax::print::pprust::{expr_to_str};\n \n // Destinations\n \n@@ -773,10 +774,8 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             let expr_ty = expr_ty(bcx, expr);\n             let sigil = ty::ty_closure_sigil(expr_ty);\n             debug!(\"translating block function {} with type {}\",\n-                   expr_to_str(expr, tcx.sess.intr()),\n-                   expr_ty.repr(tcx));\n-            closure::trans_expr_fn(bcx, sigil, decl, body,\n-                                   expr.id, expr.id, dest)\n+                   expr_to_str(expr), expr_ty.repr(tcx));\n+            closure::trans_expr_fn(bcx, sigil, decl, body, expr.id, dest)\n         }\n         ast::ExprCall(f, ref args, _) => {\n             callee::trans_call(bcx, expr, f,\n@@ -1699,31 +1698,32 @@ fn trans_assign_op<'a>(\n     return result_datum.store_to(bcx, dst_datum.val);\n }\n \n-fn trans_log_level<'a>(bcx: &'a Block<'a>)\n-                       -> DatumBlock<'a, Expr> {\n+fn trans_log_level<'a>(bcx: &'a Block<'a>) -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_log_level\");\n     let ccx = bcx.ccx();\n \n     let (modpath, modname) = {\n-        let srccrate;\n-        {\n+        let srccrate = {\n             let external_srcs = ccx.external_srcs.borrow();\n-            srccrate = match external_srcs.get().find(&bcx.fcx.id) {\n+            match external_srcs.get().find(&bcx.fcx.id) {\n                 Some(&src) => {\n                     ccx.sess.cstore.get_crate_data(src.krate).name.clone()\n                 }\n                 None => ccx.link_meta.crateid.name.to_str(),\n-            };\n-        };\n-        let mut modpath = ~[PathMod(ccx.sess.ident_of(srccrate))];\n-        for e in bcx.fcx.path.iter() {\n-            match *e {\n-                PathMod(_) => { modpath.push(*e) }\n-                _ => {}\n             }\n-        }\n-        let modname = path_str(ccx.sess, modpath);\n-        (modpath, modname)\n+        };\n+        bcx.tcx().map.with_path(bcx.fcx.id, |path| {\n+            let first = ast_map::PathMod(token::intern(srccrate));\n+            let mut path = Some(first).move_iter().chain(path).filter(|e| {\n+                match *e {\n+                    ast_map::PathMod(_) => true,\n+                    _ => false\n+                }\n+            });\n+            let modpath: ~[ast_map::PathElem] = path.collect();\n+            let modname = ast_map::path_to_str(ast_map::Values(modpath.iter()));\n+            (modpath, modname)\n+        })\n     };\n \n     let module_data_exists;\n@@ -1737,7 +1737,7 @@ fn trans_log_level<'a>(bcx: &'a Block<'a>)\n         module_data.get().get_copy(&modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n-            ccx, modpath, \"loglevel\");\n+            ast_map::Values(modpath.iter()).chain(None), \"loglevel\");\n         let global;\n         unsafe {\n             global = s.with_c_str(|buf| {"}, {"sha": "d0eef924356ab6fd9f66082701c771104a0be199", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 23, "deletions": 42, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -27,7 +27,6 @@ use middle::ty::FnSig;\n use middle::ty;\n use std::cmp;\n use std::libc::c_uint;\n-use std::vec;\n use syntax::abi::{Cdecl, Aapcs, C, AbiSet, Win64};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall, System};\n use syntax::codemap::Span;\n@@ -106,9 +105,7 @@ pub fn llvm_calling_convention(ccx: &CrateContext,\n }\n \n \n-pub fn register_foreign_item_fn(ccx: @CrateContext,\n-                                abis: AbiSet,\n-                                path: &ast_map::Path,\n+pub fn register_foreign_item_fn(ccx: @CrateContext, abis: AbiSet,\n                                 foreign_item: @ast::ForeignItem) -> ValueRef {\n     /*!\n      * Registers a foreign function found in a library.\n@@ -117,21 +114,18 @@ pub fn register_foreign_item_fn(ccx: @CrateContext,\n \n     debug!(\"register_foreign_item_fn(abis={}, \\\n             path={}, \\\n-            foreign_item.id={:?})\",\n+            foreign_item.id={})\",\n            abis.repr(ccx.tcx),\n-           path.repr(ccx.tcx),\n+           ccx.tcx.map.path_to_str(foreign_item.id),\n            foreign_item.id);\n \n     let cc = match llvm_calling_convention(ccx, abis) {\n         Some(cc) => cc,\n         None => {\n             ccx.sess.span_fatal(foreign_item.span,\n-                format!(\"ABI `{}` has no suitable ABI \\\n-                      for target architecture \\\n-                      in module {}\",\n-                     abis.user_string(ccx.tcx),\n-                     ast_map::path_to_str(*path,\n-                                          ccx.sess.intr())));\n+                format!(\"ABI `{}` has no suitable calling convention \\\n+                      for target architecture\",\n+                      abis.user_string(ccx.tcx)));\n         }\n     };\n \n@@ -160,7 +154,7 @@ pub fn register_foreign_item_fn(ccx: @CrateContext,\n     };\n     add_argument_attributes(&tys, llfn);\n \n-    return llfn;\n+    llfn\n }\n \n pub fn trans_native_call<'a>(\n@@ -353,28 +347,17 @@ pub fn trans_native_call<'a>(\n     return bcx;\n }\n \n-pub fn trans_foreign_mod(ccx: @CrateContext,\n-                         foreign_mod: &ast::ForeignMod) {\n+pub fn trans_foreign_mod(ccx: @CrateContext, foreign_mod: &ast::ForeignMod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n     for &foreign_item in foreign_mod.items.iter() {\n         match foreign_item.node {\n             ast::ForeignItemFn(..) => {\n-                let (abis, mut path) =\n-                    match ccx.tcx.items.get(foreign_item.id) {\n-                        ast_map::NodeForeignItem(_, abis, _, path) => {\n-                            (abis, (*path).clone())\n-                        }\n-                        _ => {\n-                            fail!(\"unable to find foreign item in tcx.items \\\n-                                   table.\")\n-                        }\n-                    };\n+                let abis = foreign_mod.abis;\n                 if !(abis.is_rust() || abis.is_intrinsic()) {\n-                    path.push(ast_map::PathName(foreign_item.ident));\n-                    register_foreign_item_fn(ccx, abis, &path, foreign_item);\n+                    register_foreign_item_fn(ccx, abis, foreign_item);\n                 }\n             }\n-            _ => ()\n+            _ => {}\n         }\n \n         let lname = link_name(foreign_item);\n@@ -433,7 +416,6 @@ pub fn register_rust_fn_with_foreign_abi(ccx: @CrateContext,\n }\n \n pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n-                                      path: &ast_map::Path,\n                                       decl: &ast::FnDecl,\n                                       body: &ast::Block,\n                                       attrs: &[ast::Attribute],\n@@ -444,14 +426,13 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n \n     unsafe { // unsafe because we call LLVM operations\n         // Build up the Rust function (`foo0` above).\n-        let llrustfn = build_rust_fn(ccx, path, decl, body, attrs, id);\n+        let llrustfn = build_rust_fn(ccx, decl, body, attrs, id);\n \n         // Build up the foreign wrapper (`foo` above).\n         return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys);\n     }\n \n     fn build_rust_fn(ccx: @CrateContext,\n-                     path: &ast_map::Path,\n                      decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      attrs: &[ast::Attribute],\n@@ -460,10 +441,11 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n         let tcx = ccx.tcx;\n         let t = ty::node_id_to_type(tcx, id);\n-        let ps = link::mangle_internal_name_by_path(\n-            ccx, vec::append_one((*path).clone(), ast_map::PathName(\n-                special_idents::clownshoe_abi\n-            )));\n+\n+        let ps = ccx.tcx.map.with_path(id, |path| {\n+            let abi = Some(ast_map::PathName(special_idents::clownshoe_abi.name));\n+            link::mangle(path.chain(abi.move_iter()), None, None)\n+        });\n \n         // Compute the type that the function would have if it were just a\n         // normal Rust function. This will be the type of the wrappee fn.\n@@ -475,19 +457,18 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n             _ => {\n                 ccx.sess.bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                   expected a bare fn ty\",\n-                                  path.repr(tcx),\n+                                  ccx.tcx.map.path_to_str(id),\n                                   t.repr(tcx)));\n             }\n         };\n \n-        debug!(\"build_rust_fn: path={} id={:?} t={}\",\n-               path.repr(tcx),\n-               id,\n-               t.repr(tcx));\n+        debug!(\"build_rust_fn: path={} id={} t={}\",\n+               ccx.tcx.map.path_to_str(id),\n+               id, t.repr(tcx));\n \n         let llfn = base::decl_internal_rust_fn(ccx, false, f.sig.inputs, f.sig.output, ps);\n         base::set_llvm_fn_attrs(attrs, llfn);\n-        base::trans_fn(ccx, (*path).clone(), decl, body, llfn, None, id, []);\n+        base::trans_fn(ccx, decl, body, llfn, None, id, []);\n         llfn\n     }\n \n@@ -733,7 +714,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n \n pub fn link_name(i: @ast::ForeignItem) -> InternedString {\n      match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n-        None => token::get_ident(i.ident.name),\n+        None => token::get_ident(i.ident),\n         Some(ln) => ln.clone(),\n     }\n }"}, {"sha": "25d49bd789d871d5aed7f0bb4c914ff437421d45", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -456,8 +456,7 @@ fn make_generic_glue(ccx: @CrateContext,\n     let _s = StatRecorder::new(ccx, glue_name);\n \n     let arena = TypedArena::new();\n-    let fcx = new_fn_ctxt(ccx, ~[], llfn, -1, false, ty::mk_nil(), None, None,\n-                          &arena);\n+    let fcx = new_fn_ctxt(ccx, llfn, -1, false, ty::mk_nil(), None, None, &arena);\n \n     init_function(&fcx, false, ty::mk_nil(), None);\n "}, {"sha": "878d7d9f39cadfbbf6b4dd81448cfe1c40bdd7e0", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -15,9 +15,7 @@ use middle::trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n use middle::trans::common::*;\n use middle::ty;\n \n-use std::vec;\n use syntax::ast;\n-use syntax::ast_map::PathName;\n use syntax::ast_util::local_def;\n use syntax::attr;\n \n@@ -45,9 +43,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n     let csearch_result =\n         csearch::maybe_get_item_ast(\n             ccx.tcx, fn_id,\n-            |a,b,c,d| {\n-                astencode::decode_inlined_item(a, b, ccx.maps, c.clone(), d)\n-            });\n+            |a,b,c,d| astencode::decode_inlined_item(a, b, ccx.maps, c, d));\n     return match csearch_result {\n         csearch::not_found => {\n             let mut external = ccx.external.borrow_mut();\n@@ -157,9 +153,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n \n           if num_type_params == 0 {\n               let llfn = get_item_val(ccx, mth.id);\n-              let path = vec::append_one(\n-                  ty::item_path(ccx.tcx, impl_did), PathName(mth.ident));\n-              trans_fn(ccx, path, mth.decl, mth.body, llfn, None, mth.id, []);\n+              trans_fn(ccx, mth.decl, mth.body, llfn, None, mth.id, []);\n           }\n           local_def(mth.id)\n         }"}, {"sha": "4abc114fef667a2f3c4e7e896e4583f41c6eeaa8", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 63, "deletions": 75, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -18,78 +18,76 @@ use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n+use middle::trans::glue;\n use middle::trans::type_of::*;\n use middle::trans::type_of;\n use middle::trans::machine;\n-use middle::trans::glue;\n+use middle::trans::machine::llsize_of;\n+use middle::trans::type_::Type;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::parse::token;\n use util::ppaux::ty_to_str;\n-use middle::trans::machine::llsize_of;\n-use middle::trans::type_::Type;\n \n pub fn get_simple_intrinsic(ccx: @CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n-    let nm = ccx.sess.str_of(item.ident);\n-    let name = nm.as_slice();\n-\n-    match name {\n-        \"sqrtf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.sqrt.f32\"))),\n-        \"sqrtf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.sqrt.f64\"))),\n-        \"powif32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.powi.f32\"))),\n-        \"powif64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.powi.f64\"))),\n-        \"sinf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.sin.f32\"))),\n-        \"sinf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.sin.f64\"))),\n-        \"cosf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.cos.f32\"))),\n-        \"cosf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.cos.f64\"))),\n-        \"powf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.pow.f32\"))),\n-        \"powf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.pow.f64\"))),\n-        \"expf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.exp.f32\"))),\n-        \"expf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.exp.f64\"))),\n-        \"exp2f32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.exp2.f32\"))),\n-        \"exp2f64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.exp2.f64\"))),\n-        \"logf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log.f32\"))),\n-        \"logf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log.f64\"))),\n-        \"log10f32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log10.f32\"))),\n-        \"log10f64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log10.f64\"))),\n-        \"log2f32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log2.f32\"))),\n-        \"log2f64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log2.f64\"))),\n-        \"fmaf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.fma.f32\"))),\n-        \"fmaf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.fma.f64\"))),\n-        \"fabsf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.fabs.f32\"))),\n-        \"fabsf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.fabs.f64\"))),\n-        \"copysignf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.copysign.f32\"))),\n-        \"copysignf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.copysign.f64\"))),\n-        \"floorf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.floor.f32\"))),\n-        \"floorf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.floor.f64\"))),\n-        \"ceilf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ceil.f32\"))),\n-        \"ceilf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ceil.f64\"))),\n-        \"truncf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.trunc.f32\"))),\n-        \"truncf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.trunc.f64\"))),\n-        \"rintf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.rint.f32\"))),\n-        \"rintf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.rint.f64\"))),\n-        \"nearbyintf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.nearbyint.f32\"))),\n-        \"nearbyintf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.nearbyint.f64\"))),\n-        \"roundf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.round.f32\"))),\n-        \"roundf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.round.f64\"))),\n-        \"ctpop8\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ctpop.i8\"))),\n-        \"ctpop16\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ctpop.i16\"))),\n-        \"ctpop32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ctpop.i32\"))),\n-        \"ctpop64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ctpop.i64\"))),\n-        \"bswap16\" => Some(ccx.intrinsics.get_copy(&(\"llvm.bswap.i16\"))),\n-        \"bswap32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.bswap.i32\"))),\n-        \"bswap64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.bswap.i64\"))),\n-        _ => None\n-    }\n+    let name = match token::get_ident(item.ident).get() {\n+        \"sqrtf32\" => \"llvm.sqrt.f32\",\n+        \"sqrtf64\" => \"llvm.sqrt.f64\",\n+        \"powif32\" => \"llvm.powi.f32\",\n+        \"powif64\" => \"llvm.powi.f64\",\n+        \"sinf32\" => \"llvm.sin.f32\",\n+        \"sinf64\" => \"llvm.sin.f64\",\n+        \"cosf32\" => \"llvm.cos.f32\",\n+        \"cosf64\" => \"llvm.cos.f64\",\n+        \"powf32\" => \"llvm.pow.f32\",\n+        \"powf64\" => \"llvm.pow.f64\",\n+        \"expf32\" => \"llvm.exp.f32\",\n+        \"expf64\" => \"llvm.exp.f64\",\n+        \"exp2f32\" => \"llvm.exp2.f32\",\n+        \"exp2f64\" => \"llvm.exp2.f64\",\n+        \"logf32\" => \"llvm.log.f32\",\n+        \"logf64\" => \"llvm.log.f64\",\n+        \"log10f32\" => \"llvm.log10.f32\",\n+        \"log10f64\" => \"llvm.log10.f64\",\n+        \"log2f32\" => \"llvm.log2.f32\",\n+        \"log2f64\" => \"llvm.log2.f64\",\n+        \"fmaf32\" => \"llvm.fma.f32\",\n+        \"fmaf64\" => \"llvm.fma.f64\",\n+        \"fabsf32\" => \"llvm.fabs.f32\",\n+        \"fabsf64\" => \"llvm.fabs.f64\",\n+        \"copysignf32\" => \"llvm.copysign.f32\",\n+        \"copysignf64\" => \"llvm.copysign.f64\",\n+        \"floorf32\" => \"llvm.floor.f32\",\n+        \"floorf64\" => \"llvm.floor.f64\",\n+        \"ceilf32\" => \"llvm.ceil.f32\",\n+        \"ceilf64\" => \"llvm.ceil.f64\",\n+        \"truncf32\" => \"llvm.trunc.f32\",\n+        \"truncf64\" => \"llvm.trunc.f64\",\n+        \"rintf32\" => \"llvm.rint.f32\",\n+        \"rintf64\" => \"llvm.rint.f64\",\n+        \"nearbyintf32\" => \"llvm.nearbyint.f32\",\n+        \"nearbyintf64\" => \"llvm.nearbyint.f64\",\n+        \"roundf32\" => \"llvm.round.f32\",\n+        \"roundf64\" => \"llvm.round.f64\",\n+        \"ctpop8\" => \"llvm.ctpop.i8\",\n+        \"ctpop16\" => \"llvm.ctpop.i16\",\n+        \"ctpop32\" => \"llvm.ctpop.i32\",\n+        \"ctpop64\" => \"llvm.ctpop.i64\",\n+        \"bswap16\" => \"llvm.bswap.i16\",\n+        \"bswap32\" => \"llvm.bswap.i32\",\n+        \"bswap64\" => \"llvm.bswap.i64\",\n+        _ => return None\n+    };\n+    Some(ccx.intrinsics.get_copy(&name))\n }\n \n pub fn trans_intrinsic(ccx: @CrateContext,\n                        decl: ValueRef,\n                        item: &ast::ForeignItem,\n-                       path: ast_map::Path,\n                        substs: @param_substs,\n                        ref_id: Option<ast::NodeId>) {\n-    debug!(\"trans_intrinsic(item.ident={})\", ccx.sess.str_of(item.ident));\n+    debug!(\"trans_intrinsic(item.ident={})\", token::get_ident(item.ident));\n \n     fn with_overflow_instrinsic(bcx: &Block, name: &'static str, t: ty::t) {\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n@@ -195,29 +193,21 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n \n     let arena = TypedArena::new();\n-    let fcx = new_fn_ctxt(ccx,\n-                          path,\n-                          decl,\n-                          item.id,\n-                          false,\n-                          output_type,\n-                          Some(substs),\n-                          Some(item.span),\n-                          &arena);\n+    let fcx = new_fn_ctxt(ccx, decl, item.id, false, output_type,\n+                          Some(substs), Some(item.span), &arena);\n     init_function(&fcx, true, output_type, Some(substs));\n \n     set_always_inline(fcx.llfn);\n \n     let mut bcx = fcx.entry_bcx.get().unwrap();\n     let first_real_arg = fcx.arg_pos(0u);\n \n-    let nm = ccx.sess.str_of(item.ident);\n-    let name = nm.as_slice();\n+    let name = token::get_ident(item.ident);\n \n     // This requires that atomic intrinsics follow a specific naming pattern:\n     // \"atomic_<operation>[_<ordering>], and no ordering means SeqCst\n-    if name.starts_with(\"atomic_\") {\n-        let split : ~[&str] = name.split('_').collect();\n+    if name.get().starts_with(\"atomic_\") {\n+        let split: ~[&str] = name.get().split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n         let order = if split.len() == 2 {\n             lib::llvm::SequentiallyConsistent\n@@ -282,7 +272,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         return;\n     }\n \n-    match name {\n+    match name.get() {\n         \"abort\" => {\n             let llfn = bcx.ccx().intrinsics.get_copy(&(\"llvm.trap\"));\n             Call(bcx, llfn, [], []);\n@@ -382,11 +372,9 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n             let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n             if in_type_size != out_type_size {\n-                let sp = {\n-                    match ccx.tcx.items.get(ref_id.unwrap()) {\n-                        ast_map::NodeExpr(e) => e.span,\n-                        _ => fail!(\"transmute has non-expr arg\"),\n-                    }\n+                let sp = match ccx.tcx.map.get(ref_id.unwrap()) {\n+                    ast_map::NodeExpr(e) => e.span,\n+                    _ => fail!(\"transmute has non-expr arg\"),\n                 };\n                 let pluralize = |n| if 1 == n { \"\" } else { \"s\" };\n                 ccx.sess.span_fatal(sp,"}, {"sha": "6c23cfd8ccbad3a66ee7983a30bd28fe749c22ca", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -35,9 +35,8 @@ use middle::trans::type_::Type;\n \n use std::c_str::ToCStr;\n use std::vec;\n-use syntax::ast_map::{Path, PathMod, PathName, PathPrettyName};\n use syntax::parse::token;\n-use syntax::{ast, ast_map, ast_util, visit};\n+use syntax::{ast, ast_map, visit};\n \n /**\n The main \"translation\" pass for methods.  Generates code\n@@ -46,16 +45,14 @@ be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n pub fn trans_impl(ccx: @CrateContext,\n-                  path: Path,\n                   name: ast::Ident,\n                   methods: &[@ast::Method],\n                   generics: &ast::Generics,\n                   id: ast::NodeId) {\n     let _icx = push_ctxt(\"meth::trans_impl\");\n     let tcx = ccx.tcx;\n \n-    debug!(\"trans_impl(path={}, name={}, id={:?})\",\n-           path.repr(tcx), name.repr(tcx), id);\n+    debug!(\"trans_impl(name={}, id={:?})\", name.repr(tcx), id);\n \n     // Both here and below with generic methods, be sure to recurse and look for\n     // items that we need to translate.\n@@ -66,14 +63,10 @@ pub fn trans_impl(ccx: @CrateContext,\n         }\n         return;\n     }\n-    let sub_path = vec::append_one(path, PathName(name));\n     for method in methods.iter() {\n         if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n-            let path = vec::append_one(sub_path.clone(),\n-                                       PathName(method.ident));\n-\n-            trans_fn(ccx, path, method.decl, method.body,\n+            trans_fn(ccx, method.decl, method.body,\n                      llfn, None, method.id, []);\n         } else {\n             let mut v = TransItemVisitor{ ccx: ccx };\n@@ -85,17 +78,15 @@ pub fn trans_impl(ccx: @CrateContext,\n /// Translates a (possibly monomorphized) method body.\n ///\n /// Parameters:\n-/// * `path`: the path to the method\n /// * `method`: the AST node for the method\n /// * `param_substs`: if this is a generic method, the current values for\n ///   type parameters and so forth, else None\n /// * `llfn`: the LLVM ValueRef for the method\n ///\n-/// FIXME(pcwalton) Can we take `path` by reference?\n-pub fn trans_method(ccx: @CrateContext, path: Path, method: &ast::Method,\n+pub fn trans_method(ccx: @CrateContext, method: &ast::Method,\n                     param_substs: Option<@param_substs>,\n                     llfn: ValueRef) -> ValueRef {\n-    trans_fn(ccx, path, method.decl, method.body,\n+    trans_fn(ccx, method.decl, method.body,\n              llfn, param_substs, method.id, []);\n     llfn\n }\n@@ -185,23 +176,21 @@ pub fn trans_static_method_callee(bcx: &Block,\n         generics.type_param_defs().len();\n \n     let mname = if method_id.krate == ast::LOCAL_CRATE {\n-        {\n-            match bcx.tcx().items.get(method_id.node) {\n-                ast_map::NodeTraitMethod(trait_method, _, _) => {\n-                    ast_util::trait_method_to_ty_method(trait_method).ident\n-                }\n-                _ => fail!(\"callee is not a trait method\")\n+        match bcx.tcx().map.get(method_id.node) {\n+            ast_map::NodeTraitMethod(method) => {\n+                let ident = match *method {\n+                    ast::Required(ref m) => m.ident,\n+                    ast::Provided(ref m) => m.ident\n+                };\n+                ident.name\n             }\n+            _ => fail!(\"callee is not a trait method\")\n         }\n     } else {\n-        let path = csearch::get_item_path(bcx.tcx(), method_id);\n-        match path[path.len()-1] {\n-            PathPrettyName(s, _) | PathName(s) => { s }\n-            PathMod(_) => { fail!(\"path doesn't have a name?\") }\n-        }\n+        csearch::get_item_path(bcx.tcx(), method_id).last().unwrap().name()\n     };\n     debug!(\"trans_static_method_callee: method_id={:?}, callee_id={:?}, \\\n-            name={}\", method_id, callee_id, ccx.sess.str_of(mname));\n+            name={}\", method_id, callee_id, token::get_name(mname));\n \n     let vtbls = {\n         let vtable_map = ccx.maps.vtable_map.borrow();\n@@ -213,7 +202,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n-            let mth_id = method_with_name(ccx, impl_did, mname.name);\n+            let mth_id = method_with_name(ccx, impl_did, mname);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n                     bcx, mth_id, callee_id,\n@@ -542,7 +531,7 @@ fn emit_vtable_methods(bcx: &Block,\n         if m.generics.has_type_params() ||\n            ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone())) {\n             debug!(\"(making impl vtable) method has self or type params: {}\",\n-                   tcx.sess.str_of(ident));\n+                   token::get_ident(ident));\n             C_null(Type::nil().ptr_to())\n         } else {\n             trans_fn_ref_with_vtables(bcx, m_id, 0, substs, Some(vtables))"}, {"sha": "7a9d93d89f2b3f5e8463926e8d4d99c6d038367a", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 44, "deletions": 70, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -94,60 +94,34 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     // calling a static provided method. This is sort of unfortunate.\n     let mut is_static_provided = None;\n \n-    let map_node = {\n-        session::expect(\n-            ccx.sess,\n-            ccx.tcx.items.find(fn_id.node),\n-            || format!(\"while monomorphizing {:?}, couldn't find it in the \\\n-                        item map (may have attempted to monomorphize an item \\\n-                        defined in a different crate?)\", fn_id))\n-    };\n+    let map_node = session::expect(\n+        ccx.sess,\n+        ccx.tcx.map.find(fn_id.node),\n+        || format!(\"while monomorphizing {:?}, couldn't find it in the \\\n+                    item map (may have attempted to monomorphize an item \\\n+                    defined in a different crate?)\", fn_id));\n \n-    // Get the path so that we can create a symbol\n-    let (pt, name, span) = match map_node {\n-      ast_map::NodeItem(i, pt) => (pt, i.ident, i.span),\n-      ast_map::NodeVariant(ref v, enm, pt) => (pt, (*v).node.name, enm.span),\n-      ast_map::NodeMethod(m, _, pt) => (pt, m.ident, m.span),\n-      ast_map::NodeForeignItem(i, abis, _, pt) if abis.is_intrinsic()\n-      => (pt, i.ident, i.span),\n-      ast_map::NodeForeignItem(..) => {\n-        // Foreign externs don't have to be monomorphized.\n-        return (get_item_val(ccx, fn_id.node), true);\n-      }\n-      ast_map::NodeTraitMethod(method, _, pt) => {\n-          match *method {\n-              ast::Provided(m) => {\n-                // If this is a static provided method, indicate that\n-                // and stash the number of params on the method.\n-                if m.explicit_self.node == ast::SelfStatic {\n-                    is_static_provided = Some(m.generics.ty_params.len());\n+    match map_node {\n+        ast_map::NodeForeignItem(_) => {\n+            if !ccx.tcx.map.get_foreign_abis(fn_id.node).is_intrinsic() {\n+                // Foreign externs don't have to be monomorphized.\n+                return (get_item_val(ccx, fn_id.node), true);\n+            }\n+        }\n+        ast_map::NodeTraitMethod(method) => {\n+            match *method {\n+                ast::Provided(m) => {\n+                    // If this is a static provided method, indicate that\n+                    // and stash the number of params on the method.\n+                    if m.explicit_self.node == ast::SelfStatic {\n+                        is_static_provided = Some(m.generics.ty_params.len());\n+                    }\n                 }\n-\n-                (pt, m.ident, m.span)\n-              }\n-              ast::Required(_) => {\n-                ccx.tcx.sess.bug(\"Can't monomorphize a required trait method\")\n-              }\n-          }\n-      }\n-      ast_map::NodeExpr(..) => {\n-        ccx.tcx.sess.bug(\"Can't monomorphize an expr\")\n-      }\n-      ast_map::NodeStmt(..) => {\n-        ccx.tcx.sess.bug(\"Can't monomorphize a stmt\")\n-      }\n-      ast_map::NodeArg(..) => ccx.tcx.sess.bug(\"Can't monomorphize an arg\"),\n-      ast_map::NodeBlock(..) => {\n-          ccx.tcx.sess.bug(\"Can't monomorphize a block\")\n-      }\n-      ast_map::NodeLocal(..) => {\n-          ccx.tcx.sess.bug(\"Can't monomorphize a local\")\n-      }\n-      ast_map::NodeCalleeScope(..) => {\n-          ccx.tcx.sess.bug(\"Can't monomorphize a callee-scope\")\n-      }\n-      ast_map::NodeStructCtor(_, i, pt) => (pt, i.ident, i.span)\n-    };\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n+    }\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx));\n     let mono_ty = match is_static_provided {\n@@ -202,15 +176,15 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         // to be causing an infinite expansion.\n         if depth > 30 {\n             ccx.sess.span_fatal(\n-                span, \"overly deep expansion of inlined function\");\n+                ccx.tcx.map.span(fn_id.node),\n+                \"overly deep expansion of inlined function\");\n         }\n         monomorphizing.get().insert(fn_id, depth + 1);\n     }\n \n-    let (_, elt) = gensym_name(ccx.sess.str_of(name));\n-    let mut pt = (*pt).clone();\n-    pt.push(elt);\n-    let s = mangle_exported_name(ccx, pt.clone(), mono_ty);\n+    let s = ccx.tcx.map.with_path(fn_id.node, |path| {\n+        mangle_exported_name(ccx, path, mono_ty, fn_id.node)\n+    });\n     debug!(\"monomorphize_fn mangled to {}\", s);\n \n     let mk_lldecl = || {\n@@ -223,42 +197,43 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     };\n \n     let lldecl = match map_node {\n-        ast_map::NodeItem(i, _) => {\n+        ast_map::NodeItem(i) => {\n             match *i {\n               ast::Item {\n                   node: ast::ItemFn(decl, _, _, _, body),\n                   ..\n               } => {\n                   let d = mk_lldecl();\n                   set_llvm_fn_attrs(i.attrs, d);\n-                  trans_fn(ccx, pt, decl, body, d, Some(psubsts), fn_id.node, []);\n+                  trans_fn(ccx, decl, body, d, Some(psubsts), fn_id.node, []);\n                   d\n               }\n               _ => {\n                 ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n               }\n             }\n         }\n-        ast_map::NodeForeignItem(i, _, _, _) => {\n+        ast_map::NodeForeignItem(i) => {\n             let simple = intrinsic::get_simple_intrinsic(ccx, i);\n             match simple {\n                 Some(decl) => decl,\n                 None => {\n                     let d = mk_lldecl();\n-                    intrinsic::trans_intrinsic(ccx, d, i, pt, psubsts, ref_id);\n+                    intrinsic::trans_intrinsic(ccx, d, i, psubsts, ref_id);\n                     d\n                 }\n             }\n         }\n-        ast_map::NodeVariant(v, enum_item, _) => {\n-            let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n+        ast_map::NodeVariant(v) => {\n+            let parent = ccx.tcx.map.get_parent(fn_id.node);\n+            let tvs = ty::enum_variants(ccx.tcx, local_def(parent));\n             let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl();\n             set_inline_hint(d);\n             match v.node.kind {\n                 ast::TupleVariantKind(ref args) => {\n                     trans_enum_variant(ccx,\n-                                       enum_item.id,\n+                                       parent,\n                                        v,\n                                        (*args).clone(),\n                                        this_tv.disr_val,\n@@ -270,19 +245,18 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n             }\n             d\n         }\n-        ast_map::NodeMethod(mth, _, _) => {\n+        ast_map::NodeMethod(mth) => {\n             let d = mk_lldecl();\n             set_llvm_fn_attrs(mth.attrs, d);\n-            trans_fn(ccx, pt, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n+            trans_fn(ccx, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n             d\n         }\n-        ast_map::NodeTraitMethod(method, _, pt) => {\n+        ast_map::NodeTraitMethod(method) => {\n             match *method {\n                 ast::Provided(mth) => {\n                     let d = mk_lldecl();\n                     set_llvm_fn_attrs(mth.attrs, d);\n-                    trans_fn(ccx, (*pt).clone(), mth.decl, mth.body,\n-                             d, Some(psubsts), mth.id, []);\n+                    trans_fn(ccx, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n                     d\n                 }\n                 _ => {\n@@ -291,7 +265,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                 }\n             }\n         }\n-        ast_map::NodeStructCtor(struct_def, _, _) => {\n+        ast_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl();\n             set_inline_hint(d);\n             base::trans_tuple_struct(ccx,"}, {"sha": "196c69fd59ecd56a1217cda012fe1749c893f0ab", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -31,7 +31,7 @@ use std::option::{Some,None};\n use std::vec;\n use syntax::ast::DefId;\n use syntax::ast;\n-use syntax::ast_map::PathName;\n+use syntax::ast_map;\n use syntax::parse::token::{InternedString, special_idents};\n use syntax::parse::token;\n \n@@ -94,7 +94,7 @@ impl<'a> Reflector<'a> {\n         let fcx = self.bcx.fcx;\n         let tcx = self.bcx.tcx();\n         let mth_idx = ty::method_idx(\n-            tcx.sess.ident_of(~\"visit_\" + ty_name),\n+            token::str_to_ident(~\"visit_\" + ty_name),\n             *self.visitor_methods).expect(format!(\"couldn't find visit method \\\n                                                 for {}\", ty_name));\n         let mth_ty =\n@@ -269,7 +269,7 @@ impl<'a> Reflector<'a> {\n                   for (i, field) in fields.iter().enumerate() {\n                       let extra = ~[\n                         this.c_uint(i),\n-                        this.c_slice(token::get_ident(field.ident.name)),\n+                        this.c_slice(token::get_ident(field.ident)),\n                         this.c_bool(named_fields)\n                       ] + this.c_mt(&field.mt);\n                       this.visit(\"class_field\", extra);\n@@ -291,22 +291,13 @@ impl<'a> Reflector<'a> {\n                                                            mutbl: ast::MutImmutable });\n \n             let make_get_disr = || {\n-                let sub_path = bcx.fcx.path + &[PathName(special_idents::anon)];\n-                let sym = mangle_internal_name_by_path_and_seq(ccx,\n-                                                               sub_path,\n-                                                               \"get_disr\");\n+                let sym = mangle_internal_name_by_path_and_seq(\n+                    ast_map::Values([].iter()).chain(None), \"get_disr\");\n \n                 let llfdecl = decl_internal_rust_fn(ccx, false, [opaqueptrty], ty::mk_u64(), sym);\n                 let arena = TypedArena::new();\n-                let fcx = new_fn_ctxt(ccx,\n-                                      ~[],\n-                                      llfdecl,\n-                                      -1, // id\n-                                      false,\n-                                      ty::mk_u64(),\n-                                      None,\n-                                      None,\n-                                      &arena);\n+                let fcx = new_fn_ctxt(ccx, llfdecl, -1, false,\n+                                      ty::mk_u64(), None, None, &arena);\n                 init_function(&fcx, false, ty::mk_u64(), None);\n \n                 let arg = unsafe {\n@@ -333,7 +324,7 @@ impl<'a> Reflector<'a> {\n                 + self.c_size_and_align(t);\n             self.bracketed(\"enum\", enum_args, |this| {\n                 for (i, v) in variants.iter().enumerate() {\n-                    let name = token::get_ident(v.name.name);\n+                    let name = token::get_ident(v.name);\n                     let variant_args = ~[this.c_uint(i),\n                                          C_u64(v.disr_val),\n                                          this.c_uint(v.args.len()),"}, {"sha": "22ed9b5010f83070b8bb57f7e52de82732f46ae8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 44, "deletions": 105, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -284,9 +284,7 @@ pub struct ctxt_ {\n     trait_refs: RefCell<HashMap<NodeId, @TraitRef>>,\n     trait_defs: RefCell<HashMap<DefId, @TraitDef>>,\n \n-    /// Despite its name, `items` does not only map NodeId to an item but\n-    /// also to expr/stmt/local/arg/etc\n-    items: ast_map::Map,\n+    map: ast_map::Map,\n     intrinsic_defs: RefCell<HashMap<ast::DefId, t>>,\n     freevars: RefCell<freevars::freevar_map>,\n     tcache: type_cache,\n@@ -1066,7 +1064,7 @@ pub type node_type_table = RefCell<HashMap<uint,t>>;\n pub fn mk_ctxt(s: session::Session,\n                dm: resolve::DefMap,\n                named_region_map: @RefCell<resolve_lifetime::NamedRegionMap>,\n-               amap: ast_map::Map,\n+               map: ast_map::Map,\n                freevars: freevars::freevar_map,\n                region_maps: middle::region::RegionMaps,\n                lang_items: @middle::lang_items::LanguageItems)\n@@ -1085,7 +1083,7 @@ pub fn mk_ctxt(s: session::Session,\n         node_type_substs: RefCell::new(HashMap::new()),\n         trait_refs: RefCell::new(HashMap::new()),\n         trait_defs: RefCell::new(HashMap::new()),\n-        items: amap,\n+        map: map,\n         intrinsic_defs: RefCell::new(HashMap::new()),\n         freevars: RefCell::new(freevars),\n         tcache: RefCell::new(HashMap::new()),\n@@ -2775,8 +2773,7 @@ pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n        Some(&t) => t,\n        None => cx.sess.bug(\n            format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-                ast_map::node_id_to_str(cx.items, id,\n-                                        token::get_ident_interner())))\n+               cx.map.node_to_str(id)))\n     }\n }\n \n@@ -2790,8 +2787,7 @@ pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n        Some(t) => t,\n        None => cx.sess.bug(\n            format!(\"node_id_to_type: no type for node `{}`\",\n-                ast_map::node_id_to_str(cx.items, id,\n-                                        token::get_ident_interner())))\n+               cx.map.node_to_str(id)))\n     }\n }\n \n@@ -3001,7 +2997,7 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::Expr) -> t {\n }\n \n pub fn expr_span(cx: ctxt, id: NodeId) -> Span {\n-    match cx.items.find(id) {\n+    match cx.map.find(id) {\n         Some(ast_map::NodeExpr(e)) => {\n             e.span\n         }\n@@ -3017,12 +3013,11 @@ pub fn expr_span(cx: ctxt, id: NodeId) -> Span {\n }\n \n pub fn local_var_name_str(cx: ctxt, id: NodeId) -> InternedString {\n-    match cx.items.find(id) {\n+    match cx.map.find(id) {\n         Some(ast_map::NodeLocal(pat)) => {\n             match pat.node {\n                 ast::PatIdent(_, ref path, _) => {\n-                    let ident = ast_util::path_to_ident(path);\n-                    token::get_ident(ident.name)\n+                    token::get_ident(ast_util::path_to_ident(path))\n                 }\n                 _ => {\n                     cx.sess.bug(\n@@ -3489,11 +3484,10 @@ pub fn field_idx_strict(tcx: ty::ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n     for f in fields.iter() { if f.ident.name == name { return i; } i += 1u; }\n-    let string = token::get_ident(name);\n     tcx.sess.bug(format!(\n         \"no field named `{}` found in the list of fields `{:?}`\",\n-        string.get(),\n-        fields.map(|f| tcx.sess.str_of(f.ident))));\n+        token::get_name(name),\n+        fields.map(|f| token::get_ident(f.ident).get().to_str())));\n }\n \n pub fn method_idx(id: ast::Ident, meths: &[@Method]) -> Option<uint> {\n@@ -3639,8 +3633,8 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         terr_record_fields(values) => {\n             format!(\"expected a record with field `{}` but found one with field \\\n                   `{}`\",\n-                 cx.sess.str_of(values.expected),\n-                 cx.sess.str_of(values.found))\n+                 token::get_ident(values.expected),\n+                 token::get_ident(values.found))\n         }\n         terr_arg_count => ~\"incorrect number of function parameters\",\n         terr_regions_does_not_outlive(..) => {\n@@ -3674,7 +3668,7 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                  trait_store_to_str(cx, (*values).found))\n         }\n         terr_in_field(err, fname) => {\n-            format!(\"in field `{}`, {}\", cx.sess.str_of(fname),\n+            format!(\"in field `{}`, {}\", token::get_ident(fname),\n                  type_err_to_str(cx, err))\n         }\n         terr_sorts(values) => {\n@@ -3768,8 +3762,8 @@ pub fn provided_source(cx: ctxt, id: ast::DefId) -> Option<ast::DefId> {\n pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n     if is_local(id) {\n         {\n-            match cx.items.find(id.node) {\n-                Some(ast_map::NodeItem(item, _)) => {\n+            match cx.map.find(id.node) {\n+                Some(ast_map::NodeItem(item)) => {\n                     match item.node {\n                         ItemTrait(_, _, ref ms) => {\n                             let (_, p) = ast_util::split_trait_methods(*ms);\n@@ -3897,24 +3891,21 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n \n     let ret = if id.krate == ast::LOCAL_CRATE {\n         debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n-        {\n-            match cx.items.find(id.node) {\n-                Some(ast_map::NodeItem(item, _)) => {\n-                    match item.node {\n-                        ast::ItemImpl(_, ref opt_trait, _, _) => {\n-                            match opt_trait {\n-                                &Some(ref t) => {\n-                                    Some(ty::node_id_to_trait_ref(cx,\n-                                                                  t.ref_id))\n-                                }\n-                                &None => None\n+        match cx.map.find(id.node) {\n+            Some(ast_map::NodeItem(item)) => {\n+                match item.node {\n+                    ast::ItemImpl(_, ref opt_trait, _, _) => {\n+                        match opt_trait {\n+                            &Some(ref t) => {\n+                                Some(ty::node_id_to_trait_ref(cx, t.ref_id))\n                             }\n+                            &None => None\n                         }\n-                        _ => None\n                     }\n+                    _ => None\n                 }\n-                _ => None\n             }\n+            _ => None\n         }\n     } else {\n         csearch::get_impl_trait(cx, id)\n@@ -4038,7 +4029,7 @@ pub fn substd_enum_variants(cx: ctxt,\n }\n \n pub fn item_path_str(cx: ctxt, id: ast::DefId) -> ~str {\n-    ast_map::path_to_str(item_path(cx, id), token::get_ident_interner())\n+    with_path(cx, id, |path| ast_map::path_to_str(path))\n }\n \n pub enum DtorKind {\n@@ -4084,54 +4075,11 @@ pub fn has_dtor(cx: ctxt, struct_id: DefId) -> bool {\n     ty_dtor(cx, struct_id).is_present()\n }\n \n-pub fn item_path(cx: ctxt, id: ast::DefId) -> ast_map::Path {\n-    if id.krate != ast::LOCAL_CRATE {\n-        return csearch::get_item_path(cx, id)\n-    }\n-\n-    // FIXME (#5521): uncomment this code and don't have a catch-all at the\n-    //                end of the match statement. Favor explicitly listing\n-    //                each variant.\n-    // let node = cx.items.get(&id.node);\n-    // match *node {\n-    match cx.items.get(id.node) {\n-        ast_map::NodeItem(item, path) => {\n-            let item_elt = match item.node {\n-                ItemMod(_) | ItemForeignMod(_) => {\n-                    ast_map::PathMod(item.ident)\n-                }\n-                _ => ast_map::PathName(item.ident)\n-            };\n-            vec::append_one((*path).clone(), item_elt)\n-        }\n-\n-        ast_map::NodeForeignItem(nitem, _, _, path) => {\n-            vec::append_one((*path).clone(),\n-                            ast_map::PathName(nitem.ident))\n-        }\n-\n-        ast_map::NodeMethod(method, _, path) => {\n-            vec::append_one((*path).clone(),\n-                            ast_map::PathName(method.ident))\n-        }\n-        ast_map::NodeTraitMethod(trait_method, _, path) => {\n-            let method = ast_util::trait_method_to_ty_method(&*trait_method);\n-            vec::append_one((*path).clone(),\n-                            ast_map::PathName(method.ident))\n-        }\n-\n-        ast_map::NodeVariant(ref variant, _, path) => {\n-            vec::append_one(path.init().to_owned(),\n-                            ast_map::PathName((*variant).node.name))\n-        }\n-\n-        ast_map::NodeStructCtor(_, item, path) => {\n-            vec::append_one((*path).clone(), ast_map::PathName(item.ident))\n-        }\n-\n-        ref node => {\n-            cx.sess.bug(format!(\"cannot find item_path for node {:?}\", node));\n-        }\n+pub fn with_path<T>(cx: ctxt, id: ast::DefId, f: |ast_map::PathElems| -> T) -> T {\n+    if id.krate == ast::LOCAL_CRATE {\n+        cx.map.with_path(id.node, f)\n+    } else {\n+        f(ast_map::Values(csearch::get_item_path(cx, id).iter()).chain(None))\n     }\n }\n \n@@ -4164,8 +4112,8 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n         {\n-            match cx.items.get(id.node) {\n-              ast_map::NodeItem(item, _) => {\n+            match cx.map.get(id.node) {\n+              ast_map::NodeItem(item) => {\n                   match item.node {\n                     ast::ItemEnum(ref enum_definition, _) => {\n                         let mut last_discriminant: Option<Disr> = None;\n@@ -4287,23 +4235,16 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n // decoder to use iterators instead of higher-order functions.)\n pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n     if is_local(did) {\n-        {\n-            match tcx.items.find(did.node) {\n-                Some(ast_map::NodeItem(item, _)) => {\n-                    item.attrs.iter().advance(|attr| f(attr.node.value))\n-                }\n-                _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n-                                          did))\n-            }\n-        }\n+        let item = tcx.map.expect_item(did.node);\n+        item.attrs.iter().advance(|attr| f(attr.node.value))\n     } else {\n         let mut cont = true;\n         csearch::get_item_attrs(tcx.cstore, did, |meta_items| {\n             if cont {\n                 cont = meta_items.iter().advance(|ptrptr| f(*ptrptr));\n             }\n         });\n-        return cont;\n+        cont\n     }\n }\n \n@@ -4318,7 +4259,7 @@ pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n             true\n         }\n     });\n-    return found;\n+    found\n }\n \n /// Determine whether an item is annotated with `#[packed]`\n@@ -4371,16 +4312,16 @@ pub fn lookup_field_type(tcx: ctxt,\n pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n   if did.krate == ast::LOCAL_CRATE {\n       {\n-          match cx.items.find(did.node) {\n-           Some(ast_map::NodeItem(i,_)) => {\n+          match cx.map.find(did.node) {\n+           Some(ast_map::NodeItem(i)) => {\n              match i.node {\n                 ast::ItemStruct(struct_def, _) => {\n                    struct_field_tys(struct_def.fields)\n                 }\n                 _ => cx.sess.bug(\"struct ID bound to non-struct\")\n              }\n            }\n-           Some(ast_map::NodeVariant(ref variant, _, _)) => {\n+           Some(ast_map::NodeVariant(ref variant)) => {\n               match (*variant).node.kind {\n                 ast::StructVariantKind(struct_def) => {\n                   struct_field_tys(struct_def.fields)\n@@ -4394,8 +4335,7 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n            _ => {\n                cx.sess.bug(\n                    format!(\"struct ID not bound to an item: {}\",\n-                        ast_map::node_id_to_str(cx.items, did.node,\n-                                                token::get_ident_interner())));\n+                        cx.map.node_to_str(did.node)));\n            }\n           }\n       }\n@@ -4428,8 +4368,7 @@ fn struct_field_tys(fields: &[StructField]) -> ~[field_ty] {\n             }\n             UnnamedField => {\n                 field_ty {\n-                    name:\n-                        syntax::parse::token::special_idents::unnamed_field.name,\n+                    name: syntax::parse::token::special_idents::unnamed_field.name,\n                     id: ast_util::local_def(field.node.id),\n                     vis: ast::Public,\n                 }\n@@ -4909,12 +4848,12 @@ pub fn populate_implementations_for_trait_if_necessary(\n /// If it implements no trait, return `None`.\n pub fn trait_id_of_impl(tcx: ctxt,\n                         def_id: ast::DefId) -> Option<ast::DefId> {\n-    let node = match tcx.items.find(def_id.node) {\n+    let node = match tcx.map.find(def_id.node) {\n         Some(node) => node,\n         None => return None\n     };\n     match node {\n-        ast_map::NodeItem(item, _) => {\n+        ast_map::NodeItem(item) => {\n             match item.node {\n                 ast::ItemImpl(_, Some(ref trait_ref), _, _) => {\n                     Some(node_id_to_trait_ref(tcx, trait_ref.ref_id).def_id)"}, {"sha": "70b739e33d9b2078abf6bbf9f3c4b069f7f5f950", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -63,11 +63,10 @@ use util::ppaux::Repr;\n \n use std::vec;\n use syntax::abi::AbiSet;\n-use syntax::{ast, ast_map, ast_util};\n+use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n-use syntax::parse::token;\n use syntax::print::pprust::{lifetime_to_str, path_to_str};\n \n pub trait AstConv {\n@@ -111,9 +110,8 @@ pub fn ast_region_to_region(tcx: ty::ctxt, lifetime: &ast::Lifetime)\n     };\n \n     debug!(\"ast_region_to_region(lifetime={} id={}) yields {}\",\n-            lifetime_to_str(lifetime, tcx.sess.intr()),\n-            lifetime.id,\n-            r.repr(tcx));\n+            lifetime_to_str(lifetime),\n+            lifetime.id, r.repr(tcx));\n \n     r\n }\n@@ -146,8 +144,7 @@ fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n     };\n \n     debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {}\",\n-            opt_lifetime.as_ref().map(\n-                |e| lifetime_to_str(e, this.tcx().sess.intr())),\n+            opt_lifetime.as_ref().map(|e| lifetime_to_str(e)),\n             r.repr(this.tcx()));\n \n     r\n@@ -333,8 +330,7 @@ pub fn ast_ty_to_prim_ty(tcx: ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n             let def_map = tcx.def_map.borrow();\n             let a_def = match def_map.get().find(&id) {\n                 None => tcx.sess.span_fatal(\n-                    ast_ty.span, format!(\"unbound path {}\",\n-                                         path_to_str(path, tcx.sess.intr()))),\n+                    ast_ty.span, format!(\"unbound path {}\", path_to_str(path))),\n                 Some(&d) => d\n             };\n             match a_def {\n@@ -564,8 +560,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 let def_map = tcx.def_map.borrow();\n                 let a_def = match def_map.get().find(&id) {\n                     None => tcx.sess.span_fatal(\n-                        ast_ty.span, format!(\"unbound path {}\",\n-                                             path_to_str(path, tcx.sess.intr()))),\n+                        ast_ty.span, format!(\"unbound path {}\", path_to_str(path))),\n                     Some(&d) => d\n                 };\n                 // Kind bounds on path types are only supported for traits.\n@@ -579,7 +574,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 }\n                 match a_def {\n                     ast::DefTrait(_) => {\n-                        let path_str = path_to_str(path, tcx.sess.intr());\n+                        let path_str = path_to_str(path);\n                         tcx.sess.span_err(\n                             ast_ty.span,\n                             format!(\"reference to trait `{}` where a type is expected; \\\n@@ -605,8 +600,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     ast::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                             format!(\"found module name used as a type: {}\",\n-                                    ast_map::node_id_to_str(tcx.items, id.node,\n-                                                            token::get_ident_interner())));\n+                                    tcx.map.node_to_str(id.node)));\n                     }\n                     ast::DefPrimTy(_) => {\n                         fail!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");"}, {"sha": "8117e816493853e41d412dc874cfb0882a50fb9f", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -308,7 +308,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             Some(&(_, true)) => {\n                 tcx.sess.span_err(span,\n                     format!(\"field `{}` bound twice in pattern\",\n-                            tcx.sess.str_of(field.ident)));\n+                            token::get_ident(field.ident)));\n             }\n             Some(&(index, ref mut used)) => {\n                 *used = true;\n@@ -321,14 +321,14 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                 found_fields.insert(index);\n             }\n             None => {\n-                let name = pprust::path_to_str(path, tcx.sess.intr());\n+                let name = pprust::path_to_str(path);\n                 // Check the pattern anyway, so that attempts to look\n                 // up its type won't fail\n                 check_pat(pcx, field.pat, ty::mk_err());\n                 tcx.sess.span_err(span,\n                     format!(\"struct `{}` does not have a field named `{}`\",\n                          name,\n-                         tcx.sess.str_of(field.ident)));\n+                         token::get_ident(field.ident)));\n             }\n         }\n     }\n@@ -340,10 +340,9 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                 continue;\n             }\n \n-            let string = token::get_ident(field.name);\n             tcx.sess.span_err(span,\n                               format!(\"pattern does not mention field `{}`\",\n-                                      string.get()));\n+                                  token::get_name(field.name)));\n         }\n     }\n }\n@@ -366,7 +365,7 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n             // OK.\n         }\n         Some(&ast::DefStruct(..)) | Some(&ast::DefVariant(..)) => {\n-            let name = pprust::path_to_str(path, tcx.sess.intr());\n+            let name = pprust::path_to_str(path);\n             tcx.sess.span_err(span,\n                               format!(\"mismatched types: expected `{}` but found `{}`\",\n                                    fcx.infcx().ty_to_str(expected),\n@@ -405,7 +404,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                     variant_id, substitutions, etc);\n         }\n         Some(&ast::DefStruct(..)) | Some(&ast::DefVariant(..)) => {\n-            let name = pprust::path_to_str(path, tcx.sess.intr());\n+            let name = pprust::path_to_str(path);\n             tcx.sess.span_err(span,\n                               format!(\"mismatched types: expected `{}` but \\\n                                     found `{}`\","}, {"sha": "21877bda1c10be3e57636a4b37aeec29520f704b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -105,7 +105,6 @@ use syntax::ast::{DefId, SelfValue, SelfRegion};\n use syntax::ast::{SelfUniq, SelfStatic, NodeId};\n use syntax::ast::{MutMutable, MutImmutable};\n use syntax::ast;\n-use syntax::ast_map;\n use syntax::parse::token;\n \n #[deriving(Eq)]\n@@ -556,9 +555,8 @@ impl<'a> LookupContext<'a> {\n             }\n         }\n \n-        let method_name = token::get_ident(self.m_name);\n         debug!(\"push_candidates_from_impl: {} {} {}\",\n-               method_name.get(),\n+               token::get_name(self.m_name),\n                impl_info.ident.repr(self.tcx()),\n                impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n \n@@ -1298,21 +1296,7 @@ impl<'a> LookupContext<'a> {\n \n     fn report_static_candidate(&self, idx: uint, did: DefId) {\n         let span = if did.krate == ast::LOCAL_CRATE {\n-            {\n-                match self.tcx().items.find(did.node) {\n-                  Some(ast_map::NodeMethod(m, _, _)) => m.span,\n-                  Some(ast_map::NodeTraitMethod(trait_method, _, _)) => {\n-                      match *trait_method {\n-                          ast::Provided(m) => m.span,\n-                          _ => {\n-                              fail!(\"report_static_candidate, bad item {:?}\",\n-                                    did)\n-                          }\n-                      }\n-                  }\n-                  _ => fail!(\"report_static_candidate: bad item {:?}\", did)\n-                }\n-            }\n+            self.tcx().map.span(did.node)\n         } else {\n             self.expr.span\n         };"}, {"sha": "5d33f6d172201700545fd90511079b44131f545b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 46, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -121,7 +121,6 @@ use std::vec;\n use syntax::abi::AbiSet;\n use syntax::ast::{Provided, Required};\n use syntax::ast;\n-use syntax::ast_map;\n use syntax::ast_util::local_def;\n use syntax::ast_util;\n use syntax::attr;\n@@ -389,7 +388,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n                 {\n                     let locals = self.fcx.inh.locals.borrow();\n                     debug!(\"Pattern binding {} is assigned to {}\",\n-                           self.tcx.sess.str_of(path.segments[0].identifier),\n+                           token::get_ident(path.segments[0].identifier),\n                            self.fcx.infcx().ty_to_str(\n                                locals.get().get_copy(&p.id)));\n                 }\n@@ -520,7 +519,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n         match orig_sp {\n             Some(orig_sp) => {\n                 tcx.sess.span_err(sp, format!(\"duplicate field name {} in record type declaration\",\n-                                              tcx.sess.str_of(id)));\n+                                              token::get_ident(id)));\n                 tcx.sess.span_note(orig_sp, \"first declaration of this field occurred here\");\n                 break;\n             }\n@@ -574,7 +573,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n         check_bare_fn(ccx, decl, body, it.id, fn_tpt.ty, param_env);\n       }\n       ast::ItemImpl(_, ref opt_trait_ref, _, ref ms) => {\n-        debug!(\"ItemImpl {} with id {}\", ccx.tcx.sess.str_of(it.ident), it.id);\n+        debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n \n         let impl_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         for m in ms.iter() {\n@@ -723,9 +722,8 @@ fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n                 tcx.sess.span_err(\n                     impl_method.span,\n                     format!(\"method `{}` is not a member of trait `{}`\",\n-                            tcx.sess.str_of(impl_method_ty.ident),\n-                            pprust::path_to_str(&ast_trait_ref.path,\n-                                                tcx.sess.intr())));\n+                            token::get_ident(impl_method_ty.ident),\n+                            pprust::path_to_str(&ast_trait_ref.path)));\n             }\n         }\n     }\n@@ -743,7 +741,7 @@ fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n                 |m| m.ident.name == trait_method.ident.name);\n         if !is_implemented && !is_provided {\n             missing_methods.push(\n-                format!(\"`{}`\", ccx.tcx.sess.str_of(trait_method.ident)));\n+                format!(\"`{}`\", token::get_ident(trait_method.ident)));\n         }\n     }\n \n@@ -794,19 +792,17 @@ fn compare_impl_method(tcx: ty::ctxt,\n                 impl_m_span,\n                 format!(\"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n-                        tcx.sess.str_of(trait_m.ident),\n-                        pprust::explicit_self_to_str(&impl_m.explicit_self,\n-                                                     tcx.sess.intr())));\n+                        token::get_ident(trait_m.ident),\n+                        pprust::explicit_self_to_str(&impl_m.explicit_self)));\n             return;\n         }\n         (_, &ast::SelfStatic) => {\n             tcx.sess.span_err(\n                 impl_m_span,\n                 format!(\"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n-                        tcx.sess.str_of(trait_m.ident),\n-                        pprust::explicit_self_to_str(&trait_m.explicit_self,\n-                                                     tcx.sess.intr())));\n+                        token::get_ident(trait_m.ident),\n+                        pprust::explicit_self_to_str(&trait_m.explicit_self)));\n             return;\n         }\n         _ => {\n@@ -821,7 +817,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n             impl_m_span,\n             format!(\"method `{}` has {} type parameter(s), but its trait \\\n                     declaration has {} type parameter(s)\",\n-                    tcx.sess.str_of(trait_m.ident),\n+                    token::get_ident(trait_m.ident),\n                     num_impl_m_type_params,\n                     num_trait_m_type_params));\n         return;\n@@ -832,7 +828,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n             impl_m_span,\n             format!(\"method `{}` has {} parameter{} \\\n                   but the declaration in trait `{}` has {}\",\n-                 tcx.sess.str_of(trait_m.ident),\n+                 token::get_ident(trait_m.ident),\n                  impl_m.fty.sig.inputs.len(),\n                  if impl_m.fty.sig.inputs.len() == 1 { \"\" } else { \"s\" },\n                  ty::item_path_str(tcx, trait_m.def_id),\n@@ -857,7 +853,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n                        which is not required by \\\n                        the corresponding type parameter \\\n                        in the trait declaration\",\n-                       tcx.sess.str_of(trait_m.ident),\n+                       token::get_ident(trait_m.ident),\n                        i,\n                        extra_bounds.user_string(tcx)));\n            return;\n@@ -875,7 +871,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n                         type parameter {} has {} trait bound(s), but the \\\n                         corresponding type parameter in \\\n                         the trait declaration has {} trait bound(s)\",\n-                        tcx.sess.str_of(trait_m.ident),\n+                        token::get_ident(trait_m.ident),\n                         i, impl_param_def.bounds.trait_bounds.len(),\n                         trait_param_def.bounds.trait_bounds.len()));\n             return;\n@@ -945,7 +941,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n             tcx.sess.span_err(\n                 impl_m_span,\n                 format!(\"method `{}` has an incompatible type: {}\",\n-                        tcx.sess.str_of(trait_m.ident),\n+                        token::get_ident(trait_m.ident),\n                         ty::type_err_to_str(tcx, terr)));\n             ty::note_and_explain_type_err(tcx, terr);\n         }\n@@ -1102,9 +1098,7 @@ impl FnCtxt {\n             None => {\n                 self.tcx().sess.bug(\n                     format!(\"no type for node {}: {} in fcx {}\",\n-                            id, ast_map::node_id_to_str(\n-                                self.tcx().items, id,\n-                                token::get_ident_interner()),\n+                            id, self.tcx().map.node_to_str(id),\n                             self.tag()));\n             }\n         }\n@@ -1117,8 +1111,7 @@ impl FnCtxt {\n             None => {\n                 self.tcx().sess.bug(\n                     format!(\"no type substs for node {}: {} in fcx {}\",\n-                            id, ast_map::node_id_to_str(self.tcx().items, id,\n-                                                        token::get_ident_interner()),\n+                            id, self.tcx().map.node_to_str(id),\n                             self.tag()));\n             }\n         }\n@@ -1908,8 +1901,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                   |actual| {\n                       format!(\"type `{}` does not implement any method in scope \\\n                             named `{}`\",\n-                           actual,\n-                           fcx.ccx.tcx.sess.str_of(method_name))\n+                           actual, token::get_ident(method_name))\n                   },\n                   expr_t,\n                   None);\n@@ -2336,11 +2328,9 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {\n-                        let string = token::get_ident(field);\n                         format!(\"attempted to take value of method `{}` on type `{}` \\\n                                  (try writing an anonymous function)\",\n-                                string.get(),\n-                                actual)\n+                                token::get_name(field), actual)\n                     },\n                     expr_t, None);\n             }\n@@ -2349,11 +2339,9 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {\n-                        let string = token::get_ident(field);\n                         format!(\"attempted access of field `{}` on type `{}`, \\\n                                  but no field with that name was found\",\n-                                string.get(),\n-                                actual)\n+                                token::get_name(field), actual)\n                     },\n                     expr_t, None);\n             }\n@@ -2392,15 +2380,15 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                       field.ident.span,\n                       |actual| {\n                           format!(\"structure `{}` has no field named `{}`\",\n-                                  actual, tcx.sess.str_of(field.ident.node))\n+                                  actual, token::get_ident(field.ident.node))\n                     }, struct_ty, None);\n                     error_happened = true;\n                 }\n                 Some((_, true)) => {\n                     tcx.sess.span_err(\n                         field.ident.span,\n                         format!(\"field `{}` specified more than once\",\n-                             tcx.sess.str_of(field.ident.node)));\n+                            token::get_ident(field.ident.node)));\n                     error_happened = true;\n                 }\n                 Some((field_id, false)) => {\n@@ -2433,8 +2421,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                     let name = class_field.name;\n                     let (_, seen) = *class_field_map.get(&name);\n                     if !seen {\n-                        let string = token::get_ident(name);\n-                        missing_fields.push(~\"`\" + string.get() + \"`\");\n+                        missing_fields.push(~\"`\" + token::get_name(name).get() + \"`\");\n                     }\n                 }\n \n@@ -3201,7 +3188,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                       let resolved = structurally_resolved_type(fcx,\n                                                                 expr.span,\n                                                                 raw_base_t);\n-                      let index_ident = tcx.sess.ident_of(\"index\");\n                       let error_message = || {\n                         fcx.type_error_message(expr.span,\n                                                |actual| {\n@@ -3216,7 +3202,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                     callee_id,\n                                                     expr,\n                                                     resolved,\n-                                                    index_ident.name,\n+                                                    token::intern(\"index\"),\n                                                     [base, idx],\n                                                     DoDerefArgs,\n                                                     AutoderefReceiver,\n@@ -3230,7 +3216,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     }\n \n     debug!(\"type of expr({}) {} is...\", expr.id,\n-           syntax::print::pprust::expr_to_str(expr, tcx.sess.intr()));\n+           syntax::print::pprust::expr_to_str(expr));\n     debug!(\"... {}, expected is {}\",\n            ppaux::ty_to_str(tcx, fcx.expr_ty(expr)),\n            match expected {\n@@ -3576,7 +3562,7 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n \n             match v.node.disr_expr {\n                 Some(e) => {\n-                    debug!(\"disr expr, checking {}\", pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n+                    debug!(\"disr expr, checking {}\", pprust::expr_to_str(e));\n \n                     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n                     let declty = ty::mk_int_var(ccx.tcx, fcx.infcx().next_int_var_id());\n@@ -4013,7 +3999,7 @@ pub fn check_bounds_are_used(ccx: @CrateCtxt,\n         if !*b {\n             ccx.tcx.sess.span_err(\n                 span, format!(\"type parameter `{}` is unused\",\n-                           ccx.tcx.sess.str_of(tps.get(i).ident)));\n+                              token::get_ident(tps.get(i).ident)));\n         }\n     }\n }\n@@ -4024,10 +4010,9 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n     }\n \n     let tcx = ccx.tcx;\n-    let nm = ccx.tcx.sess.str_of(it.ident);\n-    let name = nm.as_slice();\n-    let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n-        let split : ~[&str] = name.split('_').collect();\n+    let name = token::get_ident(it.ident);\n+    let (n_tps, inputs, output) = if name.get().starts_with(\"atomic_\") {\n+        let split : ~[&str] = name.get().split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n         //We only care about the operation here\n@@ -4071,7 +4056,7 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n         }\n \n     } else {\n-        match name {\n+        match name.get() {\n             \"abort\" => (0, ~[], ty::mk_bot()),\n             \"breakpoint\" => (0, ~[], ty::mk_nil()),\n             \"size_of\" |"}, {"sha": "46e79f4d1d5f713a6cc08cf0146741c5226e6dca", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -561,7 +561,7 @@ pub fn location_info_for_item(item: &ast::Item) -> LocationInfo {\n \n pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n-           ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n+           ex.id, is_early, expr_to_str(ex));\n     let _indent = indenter();\n \n     let cx = fcx.ccx;"}, {"sha": "36abb7aa457334ce1a988a56b7d3e5b3e7bef5d2", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -334,7 +334,7 @@ fn visit_pat(p: &ast::Pat, wbcx: &mut WbCtxt) {\n \n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n     debug!(\"Type for pattern binding {} (id {}) resolved to {}\",\n-           pat_to_str(p, wbcx.fcx.ccx.tcx.sess.intr()), p.id,\n+           pat_to_str(p), p.id,\n            wbcx.fcx.infcx().ty_to_str(\n                ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n                                    p.id)));\n@@ -347,7 +347,7 @@ fn visit_local(l: &ast::Local, wbcx: &mut WbCtxt) {\n     match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n         Ok(lty) => {\n             debug!(\"Type for local {} (id {}) resolved to {}\",\n-                   pat_to_str(l.pat, wbcx.fcx.tcx().sess.intr()),\n+                   pat_to_str(l.pat),\n                    l.id,\n                    wbcx.fcx.infcx().ty_to_str(lty));\n             write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.id, lty);"}, {"sha": "a9dffeb670fffc5ff3bcfab26fbaceb44b804647", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -43,6 +43,7 @@ use syntax::ast_map;\n use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::codemap::Span;\n use syntax::opt_vec;\n+use syntax::parse::token;\n use syntax::visit;\n \n use std::cell::RefCell;\n@@ -155,8 +156,7 @@ struct CoherenceCheckVisitor<'a> {\n impl<'a> visit::Visitor<()> for CoherenceCheckVisitor<'a> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n \n-//      debug!(\"(checking coherence) item '{}'\",\n-//             self.cc.crate_context.tcx.sess.str_of(item.ident));\n+        //debug!(\"(checking coherence) item '{}'\", token::get_ident(item.ident));\n \n         match item.node {\n             ItemImpl(_, ref opt_trait, _, _) => {\n@@ -267,9 +267,8 @@ impl CoherenceChecker {\n         // base type.\n \n         if associated_traits.len() == 0 {\n-            debug!(\"(checking implementation) no associated traits for item \\\n-                    '{}'\",\n-                   self.crate_context.tcx.sess.str_of(item.ident));\n+            debug!(\"(checking implementation) no associated traits for item '{}'\",\n+                   token::get_ident(item.ident));\n \n             match get_base_type_def_id(&self.inference_context,\n                                        item.span,\n@@ -293,7 +292,7 @@ impl CoherenceChecker {\n                 self.crate_context.tcx, associated_trait.ref_id);\n             debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n                    trait_ref.repr(self.crate_context.tcx),\n-                   self.crate_context.tcx.sess.str_of(item.ident));\n+                   token::get_ident(item.ident));\n \n             self.add_trait_impl(trait_ref.def_id, implementation);\n         }\n@@ -584,13 +583,13 @@ impl CoherenceChecker {\n \n                         // Make sure that this type precisely names a nominal\n                         // type.\n-                        match self.crate_context.tcx.items.find(def_id.node) {\n+                        match self.crate_context.tcx.map.find(def_id.node) {\n                             None => {\n                                 self.crate_context.tcx.sess.span_bug(\n                                     original_type.span,\n                                     \"resolve didn't resolve this type?!\");\n                             }\n-                            Some(NodeItem(item, _)) => {\n+                            Some(NodeItem(item)) => {\n                                 match item.node {\n                                     ItemStruct(..) | ItemEnum(..) => true,\n                                     _ => false,\n@@ -641,15 +640,7 @@ impl CoherenceChecker {\n \n     fn span_of_impl(&self, implementation: @Impl) -> Span {\n         assert_eq!(implementation.did.krate, LOCAL_CRATE);\n-        match self.crate_context.tcx.items.find(implementation.did.node) {\n-            Some(NodeItem(item, _)) => {\n-                return item.span;\n-            }\n-            _ => {\n-                self.crate_context.tcx.sess.bug(\"span_of_impl() called on something that \\\n-                                                 wasn't an impl!\");\n-            }\n-        }\n+        self.crate_context.tcx.map.span(implementation.did.node)\n     }\n \n     // External crate handling\n@@ -746,8 +737,8 @@ impl CoherenceChecker {\n                     // Destructors only work on nominal types.\n                     if impl_info.did.krate == ast::LOCAL_CRATE {\n                         {\n-                            match tcx.items.find(impl_info.did.node) {\n-                                Some(ast_map::NodeItem(item, _)) => {\n+                            match tcx.map.find(impl_info.did.node) {\n+                                Some(ast_map::NodeItem(item)) => {\n                                     tcx.sess.span_err((*item).span,\n                                                       \"the Drop trait may \\\n                                                        only be implemented \\"}, {"sha": "28100717e71c53a35afb734b1ad99481f591efa2", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -53,10 +53,11 @@ use syntax::ast_map;\n use syntax::ast_util::{local_def, split_trait_methods};\n use syntax::codemap::Span;\n use syntax::codemap;\n+use syntax::parse::token::special_idents;\n+use syntax::parse::token;\n use syntax::print::pprust::{path_to_str};\n use syntax::visit;\n use syntax::opt_vec::OptVec;\n-use syntax::parse::token::special_idents;\n \n struct CollectItemTypesVisitor {\n     ccx: @CrateCtxt\n@@ -111,14 +112,15 @@ impl AstConv for CrateCtxt {\n             return csearch::get_type(self.tcx, id)\n         }\n \n-        match self.tcx.items.find(id.node) {\n-            Some(ast_map::NodeItem(item, _)) => ty_of_item(self, item),\n-            Some(ast_map::NodeForeignItem(foreign_item, abis, _, _)) => {\n+        match self.tcx.map.find(id.node) {\n+            Some(ast_map::NodeItem(item)) => ty_of_item(self, item),\n+            Some(ast_map::NodeForeignItem(foreign_item)) => {\n+                let abis = self.tcx.map.get_foreign_abis(id.node);\n                 ty_of_foreign_item(self, foreign_item, abis)\n             }\n-            ref x => {\n-                self.tcx.sess.bug(format!(\"unexpected sort of item \\\n-                                           in get_item_ty(): {:?}\", (*x)));\n+            x => {\n+                self.tcx.sess.bug(format!(\"unexpected sort of node \\\n+                                           in get_item_ty(): {:?}\", x));\n             }\n         }\n     }\n@@ -128,8 +130,7 @@ impl AstConv for CrateCtxt {\n     }\n \n     fn ty_infer(&self, span: Span) -> ty::t {\n-        self.tcx.sess.span_bug(span,\n-                               \"found `ty_infer` in unexpected place\");\n+        self.tcx.sess.span_bug(span, \"found `ty_infer` in unexpected place\");\n     }\n }\n \n@@ -185,8 +186,8 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n     let tcx = ccx.tcx;\n-    match tcx.items.get(trait_id) {\n-        ast_map::NodeItem(item, _) => {\n+    match tcx.map.get(trait_id) {\n+        ast_map::NodeItem(item) => {\n             match item.node {\n                 ast::ItemTrait(ref generics, _, ref ms) => {\n                     let trait_ty_generics = ty_generics(ccx, generics, 0);\n@@ -553,7 +554,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n \n pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n-    debug!(\"convert: item {} with id {}\", tcx.sess.str_of(it.ident), it.id);\n+    debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n     match it.node {\n       // These don't define types.\n       ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {}\n@@ -716,13 +717,7 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     // map, and I regard each time that I use it as a personal and\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n-    let abis = match ccx.tcx.items.find(i.id) {\n-        Some(ast_map::NodeForeignItem(_, abis, _, _)) => abis,\n-        ref x => {\n-            ccx.tcx.sess.bug(format!(\"unexpected sort of item \\\n-                                   in get_item_ty(): {:?}\", (*x)));\n-        }\n-    };\n+    let abis = ccx.tcx.map.get_foreign_abis(i.id);\n \n     let tpt = ty_of_foreign_item(ccx, i, abis);\n     write_ty_to_tcx(ccx.tcx, i.id, tpt.ty);\n@@ -758,8 +753,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n             ccx.tcx.sess.span_fatal(\n                 ast_trait_ref.path.span,\n                 format!(\"{} is not a trait\",\n-                    path_to_str(&ast_trait_ref.path,\n-                                ccx.tcx.sess.intr())));\n+                    path_to_str(&ast_trait_ref.path)));\n         }\n     }\n }\n@@ -769,8 +763,8 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n     }\n \n-    match ccx.tcx.items.get(trait_id.node) {\n-        ast_map::NodeItem(item, _) => trait_def_of_item(ccx, item),\n+    match ccx.tcx.map.get(trait_id.node) {\n+        ast_map::NodeItem(item) => trait_def_of_item(ccx, item),\n         _ => ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n                                    trait_id.node))\n     }\n@@ -845,7 +839,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n             };\n             debug!(\"type of {} (id {}) is {}\",\n-                    tcx.sess.str_of(it.ident),\n+                    token::get_ident(it.ident),\n                     it.id,\n                     ppaux::ty_to_str(tcx, tpt.ty));\n "}, {"sha": "57b1efbf3e922d874f8e45f5f770cc6564b7001c", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -337,8 +337,8 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n         ty::ty_bare_fn(..) => {\n-            match tcx.items.find(main_id) {\n-                Some(ast_map::NodeItem(it,_)) => {\n+            match tcx.map.find(main_id) {\n+                Some(ast_map::NodeItem(it)) => {\n                     match it.node {\n                         ast::ItemFn(_, _, _, ref ps, _)\n                         if ps.is_parameterized() => {\n@@ -382,8 +382,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n     let start_t = ty::node_id_to_type(tcx, start_id);\n     match ty::get(start_t).sty {\n         ty::ty_bare_fn(_) => {\n-            match tcx.items.find(start_id) {\n-                Some(ast_map::NodeItem(it,_)) => {\n+            match tcx.map.find(start_id) {\n+                Some(ast_map::NodeItem(it)) => {\n                     match it.node {\n                         ast::ItemFn(_,_,_,ref ps,_)\n                         if ps.is_parameterized() => {"}, {"sha": "57c7f6752a8c9a997593c207dcf227a0c524a484", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -198,9 +198,7 @@ use arena::Arena;\n use middle::ty;\n use std::vec;\n use syntax::ast;\n-use syntax::ast_map;\n use syntax::ast_util;\n-use syntax::parse::token;\n use syntax::opt_vec;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -534,9 +532,7 @@ impl<'a> ConstraintContext<'a> {\n             None => {\n                 self.tcx().sess.bug(format!(\n                         \"No inferred index entry for {}\",\n-                        ast_map::node_id_to_str(self.tcx().items,\n-                                                param_id,\n-                                                token::get_ident_interner())));\n+                        self.tcx().map.node_to_str(param_id)));\n             }\n         }\n     }\n@@ -940,7 +936,7 @@ impl<'a> SolveContext<'a> {\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n                 let found = item_variances.repr(tcx);\n-                tcx.sess.span_err(ast_map::node_span(tcx.items, item_id), found);\n+                tcx.sess.span_err(tcx.map.span(item_id), found);\n             }\n \n             let mut item_variance_map = tcx.item_variance_map.borrow_mut();"}, {"sha": "dd270885b0e1bd1a1c23fa9036d0eb1a02f93b33", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 39, "deletions": 60, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -70,7 +70,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                             -> (~str, Option<Span>) {\n     return match region {\n       ReScope(node_id) => {\n-        match cx.items.find(node_id) {\n+        match cx.map.find(node_id) {\n           Some(ast_map::NodeBlock(ref blk)) => {\n             explain_span(cx, \"block\", blk.span)\n           }\n@@ -90,7 +90,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n           Some(ast_map::NodeStmt(stmt)) => {\n               explain_span(cx, \"statement\", stmt.span)\n           }\n-          Some(ast_map::NodeItem(it, _)) if (match it.node {\n+          Some(ast_map::NodeItem(it)) if (match it.node {\n                 ast::ItemFn(..) => true, _ => false}) => {\n               explain_span(cx, \"function body\", it.span)\n           }\n@@ -111,12 +111,12 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                     bound_region_ptr_to_str(cx, fr.bound_region))\n         };\n \n-        match cx.items.find(fr.scope_id) {\n+        match cx.map.find(fr.scope_id) {\n           Some(ast_map::NodeBlock(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n             (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n-          Some(ast_map::NodeItem(it, _)) if match it.node {\n+          Some(ast_map::NodeItem(it)) if match it.node {\n                 ast::ItemImpl(..) => true, _ => false} => {\n             let (msg, opt_span) = explain_span(cx, \"impl\", it.span);\n             (format!(\"{} {}\", prefix, msg), opt_span)\n@@ -162,15 +162,15 @@ pub fn bound_region_to_str(cx: ctxt,\n     }\n \n     match br {\n-      BrNamed(_, ident)   => format!(\"{}'{}{}\", prefix,\n-                                      cx.sess.str_of(ident), space_str),\n-      BrAnon(_)           => prefix.to_str(),\n-      BrFresh(_)          => prefix.to_str(),\n+        BrNamed(_, ident)   => format!(\"{}'{}{}\", prefix,\n+                                       token::get_ident(ident), space_str),\n+        BrAnon(_)           => prefix.to_str(),\n+        BrFresh(_)          => prefix.to_str(),\n     }\n }\n \n pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n-    match cx.items.find(node_id) {\n+    match cx.map.find(node_id) {\n       Some(ast_map::NodeBlock(ref blk)) => {\n         format!(\"<block at {}>\",\n              cx.sess.codemap.span_to_str(blk.span))\n@@ -201,10 +201,7 @@ pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n       None => {\n         format!(\"<unknown-{}>\", node_id)\n       }\n-      _ => { cx.sess.bug(\n-          format!(\"ReScope refers to {}\",\n-               ast_map::node_id_to_str(cx.items, node_id,\n-                                       token::get_ident_interner()))) }\n+      _ => cx.sess.bug(format!(\"ReScope refers to {}\", cx.map.node_to_str(node_id)))\n     }\n }\n \n@@ -228,7 +225,7 @@ pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~st\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n         ty::ReScope(_) => prefix.to_str(),\n-        ty::ReEarlyBound(_, _, ident) => cx.sess.str_of(ident).to_owned(),\n+        ty::ReEarlyBound(_, _, ident) => token::get_ident(ident).get().to_str(),\n         ty::ReLateBound(_, br) => bound_region_to_str(cx, prefix, space, br),\n         ty::ReFree(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n         ty::ReInfer(ReSkolemized(_, br)) => {\n@@ -329,11 +326,11 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         s.push_str(\"fn\");\n \n         match ident {\n-          Some(i) => {\n-              s.push_char(' ');\n-              s.push_str(cx.sess.str_of(i));\n-          }\n-          _ => { }\n+            Some(i) => {\n+                s.push_char(' ');\n+                s.push_str(token::get_ident(i).get());\n+            }\n+            _ => { }\n         }\n \n         push_sig_to_str(cx, &mut s, '(', ')', sig);\n@@ -432,8 +429,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     // if there is an id, print that instead of the structural type:\n     /*for def_id in ty::type_def_id(typ).iter() {\n         // note that this typedef cannot have type parameters\n-        return ast_map::path_to_str(ty::item_path(cx, *def_id),\n-                                    cx.sess.intr());\n+        return ty::item_path_str(cx, *def_id);\n     }*/\n \n     // pretty print the structural type representation:\n@@ -470,23 +466,23 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n           let ty_param_defs = cx.ty_param_defs.borrow();\n           let param_def = ty_param_defs.get().find(&did.node);\n           let ident = match param_def {\n-              Some(def) => cx.sess.str_of(def.ident).to_owned(),\n-              None => {\n-                  // This should not happen...\n-                  format!(\"BUG[{:?}]\", id)\n-              }\n+              Some(def) => token::get_ident(def.ident).get().to_str(),\n+              // This should not happen...\n+              None => format!(\"BUG[{:?}]\", id)\n           };\n-          if !cx.sess.verbose() { ident } else { format!(\"{}:{:?}\", ident, did) }\n+          if !cx.sess.verbose() {\n+              ident\n+          } else {\n+            format!(\"{}:{:?}\", ident, did)\n+          }\n       }\n       ty_self(..) => ~\"Self\",\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n-        let path = ty::item_path(cx, did);\n-        let base = ast_map::path_to_str(path, cx.sess.intr());\n+        let base = ty::item_path_str(cx, did);\n         parameterized(cx, base, &substs.regions, substs.tps, did, false)\n       }\n       ty_trait(did, ref substs, s, mutbl, ref bounds) => {\n-        let path = ty::item_path(cx, did);\n-        let base = ast_map::path_to_str(path, cx.sess.intr());\n+        let base = ty::item_path_str(cx, did);\n         let ty = parameterized(cx, base, &substs.regions,\n                                substs.tps, did, true);\n         let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n@@ -632,9 +628,9 @@ impl Repr for ty::TypeParameterDef {\n }\n \n impl Repr for ty::RegionParameterDef {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n         format!(\"RegionParameterDef({}, {:?})\",\n-                tcx.sess.str_of(self.ident),\n+                token::get_ident(self.ident),\n                 self.def_id)\n     }\n }\n@@ -689,35 +685,30 @@ impl Repr for ty::TraitRef {\n }\n \n impl Repr for ast::Expr {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n-        format!(\"expr({}: {})\",\n-             self.id,\n-             pprust::expr_to_str(self, tcx.sess.intr()))\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        format!(\"expr({}: {})\", self.id, pprust::expr_to_str(self))\n     }\n }\n \n impl Repr for ast::Item {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        format!(\"item({})\",\n-                ast_map::node_id_to_str(tcx.items,\n-                                        self.id,\n-                                        token::get_ident_interner()))\n+        format!(\"item({})\", tcx.map.node_to_str(self.id))\n     }\n }\n \n impl Repr for ast::Stmt {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n         format!(\"stmt({}: {})\",\n                 ast_util::stmt_id(self),\n-                pprust::stmt_to_str(self, tcx.sess.intr()))\n+                pprust::stmt_to_str(self))\n     }\n }\n \n impl Repr for ast::Pat {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n         format!(\"pat({}: {})\",\n              self.id,\n-             pprust::pat_to_str(self, tcx.sess.intr()))\n+             pprust::pat_to_str(self))\n     }\n }\n \n@@ -783,7 +774,7 @@ impl Repr for ast::DefId {\n         // and otherwise fallback to just printing the crate/node pair\n         if self.krate == ast::LOCAL_CRATE {\n             {\n-                match tcx.items.find(self.node) {\n+                match tcx.map.find(self.node) {\n                     Some(ast_map::NodeItem(..)) |\n                     Some(ast_map::NodeForeignItem(..)) |\n                     Some(ast_map::NodeMethod(..)) |\n@@ -848,8 +839,7 @@ impl Repr for ty::Method {\n \n impl Repr for ast::Ident {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n-        let string = token::get_ident(self.name);\n-        string.get().to_str()\n+        token::get_ident(*self).get().to_str()\n     }\n }\n \n@@ -943,16 +933,6 @@ impl Repr for ty::vstore {\n     }\n }\n \n-impl Repr for ast_map::PathElem {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n-        match *self {\n-            ast_map::PathMod(id) => id.repr(tcx),\n-            ast_map::PathName(id) => id.repr(tcx),\n-            ast_map::PathPrettyName(id, _) => id.repr(tcx),\n-        }\n-    }\n-}\n-\n impl Repr for ty::BuiltinBound {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n@@ -1004,8 +984,7 @@ impl UserString for ty::BuiltinBounds {\n \n impl UserString for ty::TraitRef {\n     fn user_string(&self, tcx: ctxt) -> ~str {\n-        let path = ty::item_path(tcx, self.def_id);\n-        let base = ast_map::path_to_str(path, tcx.sess.intr());\n+        let base = ty::item_path_str(tcx, self.def_id);\n         if tcx.sess.verbose() && self.substs.self_ty.is_some() {\n             let mut all_tps = self.substs.tps.clone();\n             for &t in self.substs.self_ty.iter() { all_tps.push(t); }"}, {"sha": "22f9d2f9843b9ce0efb0a12c06ee90982f38930c", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -13,7 +13,6 @@\n \n use syntax;\n use syntax::ast;\n-use syntax::ast_map;\n use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttributeMethods;\n@@ -887,7 +886,7 @@ fn path_to_str(p: &ast::Path) -> ~str {\n \n     let mut s = ~\"\";\n     let mut first = true;\n-    for i in p.segments.iter().map(|x| token::get_ident(x.identifier.name)) {\n+    for i in p.segments.iter().map(|x| token::get_ident(x.identifier)) {\n         if !first || p.global {\n             s.push_str(\"::\");\n         } else {\n@@ -900,8 +899,7 @@ fn path_to_str(p: &ast::Path) -> ~str {\n \n impl Clean<~str> for ast::Ident {\n     fn clean(&self) -> ~str {\n-        let string = token::get_ident(self.name);\n-        string.get().to_owned()\n+        token::get_ident(*self).get().to_owned()\n     }\n }\n \n@@ -1212,8 +1210,7 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n     let d = match def_map.get().find(&id) {\n         Some(k) => k,\n         None => {\n-            debug!(\"could not find {:?} in defmap (`{}`)\", id,\n-                   syntax::ast_map::node_id_to_str(tycx.items, id, cx.sess.intr()));\n+            debug!(\"could not find {:?} in defmap (`{}`)\", id, tycx.map.node_to_str(id));\n             fail!(\"Unexpected failure: unresolved id not in defmap (this is a bug!)\")\n         }\n     };\n@@ -1243,12 +1240,7 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n         ResolvedPath{ path: path, typarams: tpbs, id: def_id.node }\n     } else {\n         let fqn = csearch::get_item_path(tycx, def_id);\n-        let fqn = fqn.move_iter().map(|i| {\n-            match i {\n-                ast_map::PathMod(id) | ast_map::PathName(id) |\n-                ast_map::PathPrettyName(id, _) => id.clean()\n-            }\n-        }).to_owned_vec();\n+        let fqn = fqn.move_iter().map(|i| i.to_str()).to_owned_vec();\n         ExternalPath{ path: path, typarams: tpbs, fqn: fqn, kind: kind,\n                       krate: def_id.krate }\n     }"}, {"sha": "5bf1aa3e91a6d4f67dc55ec7bf02b17f54366079", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -188,9 +188,9 @@ impl<'a> RustdocVisitor<'a> {\n         };\n         if analysis.public_items.contains(&def.node) { return false }\n \n-        let item = self.cx.tycx.unwrap().items.get(def.node);\n+        let item = self.cx.tycx.unwrap().map.get(def.node);\n         match item {\n-            ast_map::NodeItem(it, _) => {\n+            ast_map::NodeItem(it) => {\n                 if glob {\n                     match it.node {\n                         ast::ItemMod(ref m) => {"}, {"sha": "72330bb7f31393202b6b405d06248f292b85909d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -125,10 +125,9 @@ pub type Name = u32;\n /// A mark represents a unique id associated with a macro expansion\n pub type Mrk = u32;\n \n-impl<S:Encoder> Encodable<S> for Ident {\n+impl<S: Encoder> Encodable<S> for Ident {\n     fn encode(&self, s: &mut S) {\n-        let string = token::get_ident(self.name);\n-        s.emit_str(string.get());\n+        s.emit_str(token::get_ident(*self).get());\n     }\n }\n "}, {"sha": "26c4b07fc9644957b0db4788dbe69b21bf122bf2", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 442, "deletions": 336, "changes": 778, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -10,189 +10,170 @@\n \n use abi::AbiSet;\n use ast::*;\n-use ast;\n use ast_util;\n use codemap::Span;\n-use diagnostic::SpanHandler;\n use fold::Folder;\n use fold;\n-use parse::token::{get_ident_interner, IdentInterner};\n+use parse::token;\n use print::pprust;\n use util::small_vector::SmallVector;\n \n use std::logging;\n use std::cell::RefCell;\n-use collections::SmallIntMap;\n+use std::iter;\n+use std::vec;\n \n #[deriving(Clone, Eq)]\n pub enum PathElem {\n-    PathMod(Ident),\n-    PathName(Ident),\n-\n-    // A pretty name can come from an `impl` block. We attempt to select a\n-    // reasonable name for debuggers to see, but to guarantee uniqueness with\n-    // other paths the hash should also be taken into account during symbol\n-    // generation.\n-    PathPrettyName(Ident, u64),\n+    PathMod(Name),\n+    PathName(Name)\n }\n \n impl PathElem {\n-    pub fn ident(&self) -> Ident {\n+    pub fn name(&self) -> Name {\n         match *self {\n-            PathMod(ident)            |\n-            PathName(ident)           |\n-            PathPrettyName(ident, _) => ident\n+            PathMod(name) | PathName(name) => name\n         }\n     }\n }\n \n-pub type Path = ~[PathElem];\n-\n-pub fn path_to_str_with_sep(p: &[PathElem], sep: &str, itr: @IdentInterner)\n-                            -> ~str {\n-    let strs = p.map(|e| {\n-        match *e {\n-            PathMod(s) | PathName(s) | PathPrettyName(s, _) => {\n-                itr.get(s.name)\n-            }\n-        }\n-    });\n-    strs.connect(sep)\n-}\n-\n-pub fn path_ident_to_str(p: &Path, i: Ident, itr: @IdentInterner) -> ~str {\n-    if p.is_empty() {\n-        itr.get(i.name).into_owned()\n-    } else {\n-        let string = itr.get(i.name);\n-        format!(\"{}::{}\", path_to_str(*p, itr), string.as_slice())\n+impl ToStr for PathElem {\n+    fn to_str(&self) -> ~str {\n+        token::get_name(self.name()).get().to_str()\n     }\n }\n \n-pub fn path_to_str(p: &[PathElem], itr: @IdentInterner) -> ~str {\n-    path_to_str_with_sep(p, \"::\", itr)\n+#[deriving(Clone)]\n+struct LinkedPathNode<'a> {\n+    node: PathElem,\n+    next: LinkedPath<'a>,\n }\n \n-pub fn path_elem_to_str(pe: PathElem, itr: @IdentInterner) -> ~str {\n-    match pe {\n-        PathMod(s) | PathName(s) | PathPrettyName(s, _) => {\n-            itr.get(s.name).into_owned()\n-        }\n-    }\n-}\n+type LinkedPath<'a> = Option<&'a LinkedPathNode<'a>>;\n \n-/// write a \"pretty\" version of `ty` to `out`. This is designed so\n-/// that symbols of `impl`'d methods give some hint of where they came\n-/// from, even if it's hard to read (previously they would all just be\n-/// listed as `__extensions__::method_name::hash`, with no indication\n-/// of the type).\n-// FIXME: these dollar signs and the names in general are actually a\n-//      relic of $ being one of the very few valid symbol names on\n-//      unix. These kinds of details shouldn't be exposed way up here\n-//      in the ast.\n-fn pretty_ty(ty: &Ty, itr: @IdentInterner, out: &mut ~str) {\n-    let (prefix, subty) = match ty.node {\n-        TyUniq(ty) => (\"$UP$\", &*ty),\n-        TyBox(ty) => (\"$SP$\", &*ty),\n-        TyPtr(MutTy { ty, mutbl }) => (if mutbl == MutMutable {\"$RPmut$\"} else {\"$RP$\"},\n-                                       &*ty),\n-        TyRptr(_, MutTy { ty, mutbl }) => (if mutbl == MutMutable {\"$BPmut$\"} else {\"$BP$\"},\n-                                           &*ty),\n-\n-        TyVec(ty) => (\"$VEC$\", &*ty),\n-        TyFixedLengthVec(ty, _) => (\"$FIXEDVEC$\", &*ty),\n-\n-        // these can't be represented as <prefix><contained ty>, so\n-        // need custom handling.\n-        TyNil => { out.push_str(\"$NIL$\"); return }\n-        TyPath(ref path, _, _) => {\n-            out.push_str(itr.get(path.segments\n-                                     .last()\n-                                     .unwrap()\n-                                     .identifier\n-                                     .name).as_slice());\n-            return\n-        }\n-        TyTup(ref tys) => {\n-            out.push_str(format!(\"$TUP_{}$\", tys.len()));\n-            for subty in tys.iter() {\n-                pretty_ty(*subty, itr, out);\n-                out.push_char('$');\n+impl<'a> Iterator<PathElem> for LinkedPath<'a> {\n+    fn next(&mut self) -> Option<PathElem> {\n+        match *self {\n+            Some(node) => {\n+                *self = node.next;\n+                Some(node.node)\n             }\n-            return\n+            None => None\n         }\n+    }\n+}\n \n-        // meh, better than nothing.\n-        TyBot => { out.push_str(\"$BOT$\"); return }\n-        TyClosure(..) => { out.push_str(\"$CLOSURE$\"); return }\n-        TyBareFn(..) => { out.push_str(\"$FN$\"); return }\n-        TyTypeof(..) => { out.push_str(\"$TYPEOF$\"); return }\n-        TyInfer(..) => { out.push_str(\"$INFER$\"); return }\n-\n-    };\n+// HACK(eddyb) move this into libstd (value wrapper for vec::Items).\n+#[deriving(Clone)]\n+pub struct Values<'a, T>(vec::Items<'a, T>);\n \n-    out.push_str(prefix);\n-    pretty_ty(subty, itr, out);\n+impl<'a, T: Pod> Iterator<T> for Values<'a, T> {\n+    fn next(&mut self) -> Option<T> {\n+        let &Values(ref mut items) = self;\n+        items.next().map(|&x| x)\n+    }\n }\n \n-pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> PathElem {\n-    let itr = get_ident_interner();\n+/// The type of the iterator used by with_path.\n+pub type PathElems<'a, 'b> = iter::Chain<Values<'a, PathElem>, LinkedPath<'b>>;\n \n-    let hash = (trait_ref, ty).hash();\n-    let mut pretty;\n-    match *trait_ref {\n-        None => pretty = ~\"\",\n-        Some(ref trait_ref) => {\n-            pretty = itr.get(trait_ref.path.segments.last().unwrap().identifier.name)\n-                        .into_owned();\n-            pretty.push_char('$');\n-        }\n-    };\n-    pretty_ty(ty, itr, &mut pretty);\n+pub fn path_to_str<PI: Iterator<PathElem>>(mut path: PI) -> ~str {\n+    let itr = token::get_ident_interner();\n \n-    PathPrettyName(Ident::new(itr.gensym(pretty)), hash)\n+    path.fold(~\"\", |mut s, e| {\n+        let e = itr.get(e.name());\n+        if !s.is_empty() {\n+            s.push_str(\"::\");\n+        }\n+        s.push_str(e.as_slice());\n+        s\n+    })\n }\n \n #[deriving(Clone)]\n pub enum Node {\n-    NodeItem(@Item, @Path),\n-    NodeForeignItem(@ForeignItem, AbiSet, Visibility, @Path),\n-    NodeTraitMethod(@TraitMethod, DefId /* trait did */,\n-                    @Path /* path to the trait */),\n-    NodeMethod(@Method, DefId /* impl did */, @Path /* path to the impl */),\n-\n-    /// NodeVariant represents a variant of an enum, e.g., for\n-    /// `enum A { B, C, D }`, there would be a NodeItem for `A`, and a\n-    /// NodeVariant item for each of `B`, `C`, and `D`.\n-    NodeVariant(P<Variant>, @Item, @Path),\n+    NodeItem(@Item),\n+    NodeForeignItem(@ForeignItem),\n+    NodeTraitMethod(@TraitMethod),\n+    NodeMethod(@Method),\n+    NodeVariant(P<Variant>),\n     NodeExpr(@Expr),\n     NodeStmt(@Stmt),\n     NodeArg(@Pat),\n     NodeLocal(@Pat),\n     NodeBlock(P<Block>),\n \n     /// NodeStructCtor represents a tuple struct.\n-    NodeStructCtor(@StructDef, @Item, @Path),\n-    NodeCalleeScope(@Expr)\n+    NodeStructCtor(@StructDef),\n+    NodeCalleeScope(@Expr),\n }\n \n-impl Node {\n-    pub fn with_attrs<T>(&self, f: |Option<&[Attribute]>| -> T) -> T {\n-        let attrs = match *self {\n-            NodeItem(i, _) => Some(i.attrs.as_slice()),\n-            NodeForeignItem(fi, _, _, _) => Some(fi.attrs.as_slice()),\n-            NodeTraitMethod(tm, _, _) => match *tm {\n-                Required(ref type_m) => Some(type_m.attrs.as_slice()),\n-                Provided(m) => Some(m.attrs.as_slice())\n-            },\n-            NodeMethod(m, _, _) => Some(m.attrs.as_slice()),\n-            NodeVariant(ref v, _, _) => Some(v.node.attrs.as_slice()),\n-            // unit/tuple structs take the attributes straight from\n-            // the struct definition.\n-            NodeStructCtor(_, strct, _) => Some(strct.attrs.as_slice()),\n-            _ => None\n-        };\n-        f(attrs)\n+// The odd layout is to bring down the total size.\n+#[deriving(Clone)]\n+enum MapEntry {\n+    // Placeholder for holes in the map.\n+    NotPresent,\n+\n+    // All the node types, with a parent ID.\n+    EntryItem(NodeId, @Item),\n+    EntryForeignItem(NodeId, @ForeignItem),\n+    EntryTraitMethod(NodeId, @TraitMethod),\n+    EntryMethod(NodeId, @Method),\n+    EntryVariant(NodeId, P<Variant>),\n+    EntryExpr(NodeId, @Expr),\n+    EntryStmt(NodeId, @Stmt),\n+    EntryArg(NodeId, @Pat),\n+    EntryLocal(NodeId, @Pat),\n+    EntryBlock(NodeId, P<Block>),\n+    EntryStructCtor(NodeId, @StructDef),\n+    EntryCalleeScope(NodeId, @Expr),\n+\n+    // Roots for node trees.\n+    RootCrate,\n+    RootInlinedParent(P<InlinedParent>)\n+}\n+\n+struct InlinedParent {\n+    path: ~[PathElem],\n+    // Required by NodeTraitMethod and NodeMethod.\n+    def_id: DefId\n+}\n+\n+impl MapEntry {\n+    fn parent(&self) -> Option<NodeId> {\n+        Some(match *self {\n+            EntryItem(id, _) => id,\n+            EntryForeignItem(id, _) => id,\n+            EntryTraitMethod(id, _) => id,\n+            EntryMethod(id, _) => id,\n+            EntryVariant(id, _) => id,\n+            EntryExpr(id, _) => id,\n+            EntryStmt(id, _) => id,\n+            EntryArg(id, _) => id,\n+            EntryLocal(id, _) => id,\n+            EntryBlock(id, _) => id,\n+            EntryStructCtor(id, _) => id,\n+            EntryCalleeScope(id, _) => id,\n+            _ => return None\n+        })\n+    }\n+\n+    fn to_node(&self) -> Option<Node> {\n+        Some(match *self {\n+            EntryItem(_, p) => NodeItem(p),\n+            EntryForeignItem(_, p) => NodeForeignItem(p),\n+            EntryTraitMethod(_, p) => NodeTraitMethod(p),\n+            EntryMethod(_, p) => NodeMethod(p),\n+            EntryVariant(_, p) => NodeVariant(p),\n+            EntryExpr(_, p) => NodeExpr(p),\n+            EntryStmt(_, p) => NodeStmt(p),\n+            EntryArg(_, p) => NodeArg(p),\n+            EntryLocal(_, p) => NodeLocal(p),\n+            EntryBlock(_, p) => NodeBlock(p),\n+            EntryStructCtor(_, p) => NodeStructCtor(p),\n+            EntryCalleeScope(_, p) => NodeCalleeScope(p),\n+            _ => return None\n+        })\n     }\n }\n \n@@ -202,141 +183,292 @@ pub struct Map {\n     /// a NodeId is in the map, but empirically the occupancy is about\n     /// 75-80%, so there's not too much overhead (certainly less than\n     /// a hashmap, since they (at the time of writing) have a maximum\n-    /// of 75% occupancy). (The additional overhead of the Option<>\n-    /// inside the SmallIntMap could be removed by adding an extra\n-    /// empty variant to Node and storing a vector here, but that was\n-    /// found to not make much difference.)\n+    /// of 75% occupancy).\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    priv map: @RefCell<SmallIntMap<Node>>\n+    priv map: RefCell<~[MapEntry]>\n }\n \n impl Map {\n+    fn find_entry(&self, id: NodeId) -> Option<MapEntry> {\n+        let map = self.map.borrow();\n+        map.get().get(id as uint).map(|x| *x)\n+    }\n+\n     /// Retrieve the Node corresponding to `id`, failing if it cannot\n     /// be found.\n-    pub fn get(&self, id: ast::NodeId) -> Node {\n-        let map = self.map.borrow();\n-        *map.get().get(&(id as uint))\n+    pub fn get(&self, id: NodeId) -> Node {\n+        match self.find(id) {\n+            Some(node) => node,\n+            None => fail!(\"couldn't find node id {} in the AST map\", id)\n+        }\n     }\n+\n     /// Retrieve the Node corresponding to `id`, returning None if\n     /// cannot be found.\n-    pub fn find(&self, id: ast::NodeId) -> Option<Node> {\n-        let map = self.map.borrow();\n-        map.get().find(&(id as uint)).map(|&n| n)\n+    pub fn find(&self, id: NodeId) -> Option<Node> {\n+        self.find_entry(id).and_then(|x| x.to_node())\n+    }\n+\n+    pub fn get_parent(&self, id: NodeId) -> NodeId {\n+        self.find_entry(id).and_then(|x| x.parent()).unwrap_or(id)\n+    }\n+\n+    pub fn get_parent_did(&self, id: NodeId) -> DefId {\n+        let parent = self.get_parent(id);\n+        match self.find_entry(parent) {\n+            Some(RootInlinedParent(data)) => data.def_id,\n+            _ => ast_util::local_def(parent)\n+        }\n+    }\n+\n+    pub fn get_foreign_abis(&self, id: NodeId) -> AbiSet {\n+        let parent = self.get_parent(id);\n+        let abis = match self.find_entry(parent) {\n+            Some(EntryItem(_, i)) => match i.node {\n+                ItemForeignMod(ref nm) => Some(nm.abis),\n+                _ => None\n+            },\n+            // Wrong but OK, because the only inlined foreign items are intrinsics.\n+            Some(RootInlinedParent(_)) => Some(AbiSet::Intrinsic()),\n+            _ => None\n+        };\n+        match abis {\n+            Some(abis) => abis,\n+            None => fail!(\"expected foreign mod or inlined parent, found {}\",\n+                          self.node_to_str(parent))\n+        }\n+    }\n+\n+    pub fn get_foreign_vis(&self, id: NodeId) -> Visibility {\n+        let vis = self.expect_foreign_item(id).vis;\n+        match self.find(self.get_parent(id)) {\n+            Some(NodeItem(i)) => vis.inherit_from(i.vis),\n+            _ => vis\n+        }\n+    }\n+\n+    pub fn expect_item(&self, id: NodeId) -> @Item {\n+        match self.find(id) {\n+            Some(NodeItem(item)) => item,\n+            _ => fail!(\"expected item, found {}\", self.node_to_str(id))\n+        }\n+    }\n+\n+    pub fn expect_foreign_item(&self, id: NodeId) -> @ForeignItem {\n+        match self.find(id) {\n+            Some(NodeForeignItem(item)) => item,\n+            _ => fail!(\"expected foreign item, found {}\", self.node_to_str(id))\n+        }\n+    }\n+\n+    pub fn get_path_elem(&self, id: NodeId) -> PathElem {\n+        match self.get(id) {\n+            NodeItem(item) => {\n+                match item.node {\n+                    ItemMod(_) | ItemForeignMod(_) => {\n+                        PathMod(item.ident.name)\n+                    }\n+                    _ => PathName(item.ident.name)\n+                }\n+            }\n+            NodeForeignItem(i) => PathName(i.ident.name),\n+            NodeMethod(m) => PathName(m.ident.name),\n+            NodeTraitMethod(tm) => match *tm {\n+                Required(ref m) => PathName(m.ident.name),\n+                Provided(ref m) => PathName(m.ident.name)\n+            },\n+            NodeVariant(v) => PathName(v.node.name.name),\n+            node => fail!(\"no path elem for {:?}\", node)\n+        }\n+    }\n+\n+    pub fn with_path<T>(&self, id: NodeId, f: |PathElems| -> T) -> T {\n+        self.with_path_next(id, None, f)\n+    }\n+\n+    pub fn path_to_str(&self, id: NodeId) -> ~str {\n+        self.with_path(id, |path| path_to_str(path))\n+    }\n+\n+    fn path_to_str_with_ident(&self, id: NodeId, i: Ident) -> ~str {\n+        self.with_path(id, |path| {\n+            path_to_str(path.chain(Some(PathName(i.name)).move_iter()))\n+        })\n+    }\n+\n+    fn with_path_next<T>(&self, id: NodeId, next: LinkedPath, f: |PathElems| -> T) -> T {\n+        let parent = self.get_parent(id);\n+        let parent = match self.find_entry(id) {\n+            Some(EntryForeignItem(..)) | Some(EntryVariant(..)) => {\n+                // Anonymous extern items, enum variants and struct ctors\n+                // go in the parent scope.\n+                self.get_parent(parent)\n+            }\n+            // But tuple struct ctors don't have names, so use the path of its\n+            // parent, the struct item. Similarly with closure expressions.\n+            Some(EntryStructCtor(..)) | Some(EntryExpr(..)) => {\n+                return self.with_path_next(parent, next, f);\n+            }\n+            _ => parent\n+        };\n+        if parent == id {\n+            match self.find_entry(id) {\n+                Some(RootInlinedParent(data)) => {\n+                    f(Values(data.path.iter()).chain(next))\n+                }\n+                _ => f(Values([].iter()).chain(next))\n+            }\n+        } else {\n+            self.with_path_next(parent, Some(&LinkedPathNode {\n+                node: self.get_path_elem(id),\n+                next: next\n+            }), f)\n+        }\n+    }\n+\n+    pub fn with_attrs<T>(&self, id: NodeId, f: |Option<&[Attribute]>| -> T) -> T {\n+        let attrs = match self.get(id) {\n+            NodeItem(i) => Some(i.attrs.as_slice()),\n+            NodeForeignItem(fi) => Some(fi.attrs.as_slice()),\n+            NodeTraitMethod(tm) => match *tm {\n+                Required(ref type_m) => Some(type_m.attrs.as_slice()),\n+                Provided(m) => Some(m.attrs.as_slice())\n+            },\n+            NodeMethod(m) => Some(m.attrs.as_slice()),\n+            NodeVariant(ref v) => Some(v.node.attrs.as_slice()),\n+            // unit/tuple structs take the attributes straight from\n+            // the struct definition.\n+            // FIXME(eddyb) make this work again (requires access to the map).\n+            NodeStructCtor(_) => {\n+                return self.with_attrs(self.get_parent(id), f);\n+            }\n+            _ => None\n+        };\n+        f(attrs)\n+    }\n+\n+    pub fn span(&self, id: NodeId) -> Span {\n+        match self.find(id) {\n+            Some(NodeItem(item)) => item.span,\n+            Some(NodeForeignItem(foreign_item)) => foreign_item.span,\n+            Some(NodeTraitMethod(trait_method)) => {\n+                match *trait_method {\n+                    Required(ref type_method) => type_method.span,\n+                    Provided(ref method) => method.span,\n+                }\n+            }\n+            Some(NodeMethod(method)) => method.span,\n+            Some(NodeVariant(variant)) => variant.span,\n+            Some(NodeExpr(expr)) => expr.span,\n+            Some(NodeStmt(stmt)) => stmt.span,\n+            Some(NodeArg(pat)) | Some(NodeLocal(pat)) => pat.span,\n+            Some(NodeBlock(block)) => block.span,\n+            Some(NodeStructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n+            Some(NodeCalleeScope(expr)) => expr.span,\n+            _ => fail!(\"node_span: could not find span for id {}\", id),\n+        }\n+    }\n+\n+    pub fn node_to_str(&self, id: NodeId) -> ~str {\n+        node_id_to_str(self, id)\n     }\n }\n \n pub trait FoldOps {\n-    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n+    fn new_id(&self, id: NodeId) -> NodeId {\n         id\n     }\n     fn new_span(&self, span: Span) -> Span {\n         span\n     }\n }\n \n-pub struct Ctx<F> {\n-    map: Map,\n-    path: Path,\n-    diag: @SpanHandler,\n+pub struct Ctx<'a, F> {\n+    map: &'a Map,\n+    // The node in which we are currently mapping (an item or a method).\n+    // When equal to DUMMY_NODE_ID, the next mapped node becomes the parent.\n+    parent: NodeId,\n     fold_ops: F\n }\n \n-impl<F> Ctx<F> {\n-    fn insert(&self, id: ast::NodeId, node: Node) {\n+impl<'a, F> Ctx<'a, F> {\n+    fn insert(&self, id: NodeId, entry: MapEntry) {\n         let mut map = self.map.map.borrow_mut();\n-        map.get().insert(id as uint, node);\n+        map.get().grow_set(id as uint, &NotPresent, entry);\n     }\n }\n \n-impl<F: FoldOps> Folder for Ctx<F> {\n-    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n-        self.fold_ops.new_id(id)\n+impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n+    fn new_id(&mut self, id: NodeId) -> NodeId {\n+        let id = self.fold_ops.new_id(id);\n+        if self.parent == DUMMY_NODE_ID {\n+            self.parent = id;\n+        }\n+        id\n     }\n \n     fn new_span(&mut self, span: Span) -> Span {\n         self.fold_ops.new_span(span)\n     }\n \n     fn fold_item(&mut self, i: @Item) -> SmallVector<@Item> {\n-        // clone is FIXME #2543\n-        let item_path = @self.path.clone();\n-        self.path.push(match i.node {\n-            ItemImpl(_, ref maybe_trait, ty, _) => {\n-                // Right now the ident on impls is __extensions__ which isn't\n-                // very pretty when debugging, so attempt to select a better\n-                // name to use.\n-                impl_pretty_name(maybe_trait, ty)\n-            }\n-            ItemMod(_) | ItemForeignMod(_) => PathMod(i.ident),\n-            _ => PathName(i.ident)\n-        });\n+        let parent = self.parent;\n+        self.parent = DUMMY_NODE_ID;\n \n         let i = fold::noop_fold_item(i, self).expect_one(\"expected one item\");\n-        self.insert(i.id, NodeItem(i, item_path));\n+        assert_eq!(self.parent, i.id);\n \n         match i.node {\n             ItemImpl(_, _, _, ref ms) => {\n-                // clone is FIXME #2543\n-                let p = @self.path.clone();\n-                let impl_did = ast_util::local_def(i.id);\n                 for &m in ms.iter() {\n-                    self.insert(m.id, NodeMethod(m, impl_did, p));\n+                    self.insert(m.id, EntryMethod(self.parent, m));\n                 }\n-\n             }\n             ItemEnum(ref enum_definition, _) => {\n-                // clone is FIXME #2543\n-                let p = @self.path.clone();\n                 for &v in enum_definition.variants.iter() {\n-                    self.insert(v.node.id, NodeVariant(v, i, p));\n+                    self.insert(v.node.id, EntryVariant(self.parent, v));\n                 }\n             }\n             ItemForeignMod(ref nm) => {\n-                for nitem in nm.items.iter() {\n-                    // Compute the visibility for this native item.\n-                    let visibility = nitem.vis.inherit_from(i.vis);\n-\n-                    self.insert(nitem.id,\n-                                // Anonymous extern mods go in the parent scope.\n-                                NodeForeignItem(*nitem, nm.abis, visibility, item_path));\n+                for &nitem in nm.items.iter() {\n+                    self.insert(nitem.id, EntryForeignItem(self.parent, nitem));\n                 }\n             }\n             ItemStruct(struct_def, _) => {\n                 // If this is a tuple-like struct, register the constructor.\n                 match struct_def.ctor_id {\n-                    None => {}\n                     Some(ctor_id) => {\n-                        // clone is FIXME #2543\n-                        let p = @self.path.clone();\n-                        self.insert(ctor_id, NodeStructCtor(struct_def, i, p));\n+                        self.insert(ctor_id, EntryStructCtor(self.parent,\n+                                                             struct_def));\n                     }\n+                    None => {}\n                 }\n             }\n             ItemTrait(_, ref traits, ref methods) => {\n                 for t in traits.iter() {\n-                    self.insert(t.ref_id, NodeItem(i, item_path));\n+                    self.insert(t.ref_id, EntryItem(self.parent, i));\n                 }\n \n-                // clone is FIXME #2543\n-                let p = @self.path.clone();\n                 for tm in methods.iter() {\n-                    let d_id = ast_util::local_def(i.id);\n                     match *tm {\n                         Required(ref m) => {\n-                            self.insert(m.id, NodeTraitMethod(@(*tm).clone(), d_id, p));\n+                            self.insert(m.id, EntryTraitMethod(self.parent,\n+                                                               @(*tm).clone()));\n                         }\n                         Provided(m) => {\n-                            self.insert(m.id, NodeTraitMethod(@Provided(m), d_id, p));\n+                            self.insert(m.id, EntryTraitMethod(self.parent,\n+                                                               @Provided(m)));\n                         }\n                     }\n                 }\n             }\n             _ => {}\n         }\n \n-        self.path.pop().unwrap();\n+        self.parent = parent;\n+        self.insert(i.id, EntryItem(self.parent, i));\n \n         SmallVector::one(i)\n     }\n@@ -346,7 +478,7 @@ impl<F: FoldOps> Folder for Ctx<F> {\n         match pat.node {\n             PatIdent(..) => {\n                 // Note: this is at least *potentially* a pattern...\n-                self.insert(pat.id, NodeLocal(pat));\n+                self.insert(pat.id, EntryLocal(self.parent, pat));\n             }\n             _ => {}\n         }\n@@ -357,211 +489,185 @@ impl<F: FoldOps> Folder for Ctx<F> {\n     fn fold_expr(&mut self, expr: @Expr) -> @Expr {\n         let expr = fold::noop_fold_expr(expr, self);\n \n-        self.insert(expr.id, NodeExpr(expr));\n+        self.insert(expr.id, EntryExpr(self.parent, expr));\n \n         // Expressions which are or might be calls:\n-        {\n-            let r = expr.get_callee_id();\n-            for callee_id in r.iter() {\n-                self.insert(*callee_id, NodeCalleeScope(expr));\n-            }\n+        for callee_id in expr.get_callee_id().iter() {\n+            self.insert(*callee_id, EntryCalleeScope(self.parent, expr));\n         }\n \n         expr\n     }\n \n     fn fold_stmt(&mut self, stmt: &Stmt) -> SmallVector<@Stmt> {\n         let stmt = fold::noop_fold_stmt(stmt, self).expect_one(\"expected one statement\");\n-        self.insert(ast_util::stmt_id(stmt), NodeStmt(stmt));\n+        self.insert(ast_util::stmt_id(stmt), EntryStmt(self.parent, stmt));\n         SmallVector::one(stmt)\n     }\n \n     fn fold_method(&mut self, m: @Method) -> @Method {\n-        self.path.push(PathName(m.ident));\n+        let parent = self.parent;\n+        self.parent = DUMMY_NODE_ID;\n         let m = fold::noop_fold_method(m, self);\n-        self.path.pop();\n+        assert_eq!(self.parent, m.id);\n+        self.parent = parent;\n         m\n     }\n \n     fn fold_fn_decl(&mut self, decl: &FnDecl) -> P<FnDecl> {\n         let decl = fold::noop_fold_fn_decl(decl, self);\n         for a in decl.inputs.iter() {\n-            self.insert(a.id, NodeArg(a.pat));\n+            self.insert(a.id, EntryArg(self.parent, a.pat));\n         }\n         decl\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n         let block = fold::noop_fold_block(block, self);\n-        self.insert(block.id, NodeBlock(block));\n+        self.insert(block.id, EntryBlock(self.parent, block));\n         block\n     }\n }\n \n-pub fn map_crate<F: 'static + FoldOps>(diag: @SpanHandler, c: Crate,\n-                                       fold_ops: F) -> (Crate, Map) {\n-    let mut cx = Ctx {\n-        map: Map { map: @RefCell::new(SmallIntMap::new()) },\n-        path: ~[],\n-        diag: diag,\n-        fold_ops: fold_ops\n+pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {\n+    let map = Map { map: RefCell::new(~[]) };\n+    let krate = {\n+        let mut cx = Ctx {\n+            map: &map,\n+            parent: CRATE_NODE_ID,\n+            fold_ops: fold_ops\n+        };\n+        cx.insert(CRATE_NODE_ID, RootCrate);\n+        cx.fold_crate(krate)\n     };\n-    let krate = cx.fold_crate(c);\n \n     if log_enabled!(logging::DEBUG) {\n-        let map = cx.map.map.borrow();\n-        // this only makes sense for ordered stores; note the\n+        let map = map.map.borrow();\n+        // This only makes sense for ordered stores; note the\n         // enumerate to count the number of entries.\n-        let (entries_less_1, (largest_id, _)) =\n-            map.get().iter().enumerate().last().expect(\"AST map was empty after folding?\");\n+        let (entries_less_1, _) = map.get().iter().filter(|&x| {\n+            match *x {\n+                NotPresent => false,\n+                _ => true\n+            }\n+        }).enumerate().last().expect(\"AST map was empty after folding?\");\n \n         let entries = entries_less_1 + 1;\n-        let vector_length = largest_id + 1;\n+        let vector_length = map.get().len();\n         debug!(\"The AST map has {} entries with a maximum of {}: occupancy {:.1}%\",\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    (krate, cx.map)\n+    (krate, map)\n }\n \n // Used for items loaded from external crate that are being inlined into this\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n-pub fn map_decoded_item<F: 'static + FoldOps>(diag: @SpanHandler,\n-                                              map: Map,\n-                                              path: Path,\n-                                              fold_ops: F,\n-                                              fold_ii: |&mut Ctx<F>| -> InlinedItem)\n-                                              -> InlinedItem {\n-    // I believe it is ok for the local IDs of inlined items from other crates\n-    // to overlap with the local ids from this crate, so just generate the ids\n-    // starting from 0.\n+pub fn map_decoded_item<F: FoldOps>(map: &Map,\n+                                    path: ~[PathElem],\n+                                    fold_ops: F,\n+                                    fold: |&mut Ctx<F>| -> InlinedItem)\n+                                    -> InlinedItem {\n     let mut cx = Ctx {\n         map: map,\n-        path: path.clone(),\n-        diag: diag,\n+        parent: DUMMY_NODE_ID,\n         fold_ops: fold_ops\n     };\n \n-    let ii = fold_ii(&mut cx);\n+    // Generate a NodeId for the RootInlinedParent inserted below.\n+    cx.new_id(DUMMY_NODE_ID);\n \n     // Methods get added to the AST map when their impl is visited.  Since we\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now. Likewise with foreign items.\n+    let mut def_id = DefId { krate: LOCAL_CRATE, node: DUMMY_NODE_ID };\n+    let ii = fold(&mut cx);\n     match ii {\n-        IIItem(..) => {} // fallthrough\n-        IIForeign(i) => {\n-            cx.insert(i.id, NodeForeignItem(i,\n-                                            AbiSet::Intrinsic(),\n-                                            i.vis,    // Wrong but OK\n-                                            @path));\n-        }\n+        IIItem(_) => {}\n         IIMethod(impl_did, is_provided, m) => {\n             let entry = if is_provided {\n-                NodeTraitMethod(@Provided(m), impl_did, @path)\n+                EntryTraitMethod(cx.parent, @Provided(m))\n             } else {\n-                NodeMethod(m, impl_did, @path)\n+                EntryMethod(cx.parent, m)\n             };\n             cx.insert(m.id, entry);\n+            def_id = impl_did;\n+        }\n+        IIForeign(i) => {\n+            cx.insert(i.id, EntryForeignItem(cx.parent, i));\n         }\n     }\n \n+    cx.insert(cx.parent, RootInlinedParent(P(InlinedParent {\n+        path: path,\n+        def_id: def_id\n+    })));\n+\n     ii\n }\n \n-pub fn node_id_to_str(map: Map, id: NodeId, itr: @IdentInterner) -> ~str {\n+fn node_id_to_str(map: &Map, id: NodeId) -> ~str {\n     match map.find(id) {\n-      None => {\n-        format!(\"unknown node (id={})\", id)\n-      }\n-      Some(NodeItem(item, path)) => {\n-        let path_str = path_ident_to_str(path, item.ident, itr);\n-        let item_str = match item.node {\n-            ItemStatic(..) => ~\"static\",\n-            ItemFn(..) => ~\"fn\",\n-            ItemMod(..) => ~\"mod\",\n-            ItemForeignMod(..) => ~\"foreign mod\",\n-            ItemTy(..) => ~\"ty\",\n-            ItemEnum(..) => ~\"enum\",\n-            ItemStruct(..) => ~\"struct\",\n-            ItemTrait(..) => ~\"trait\",\n-            ItemImpl(..) => ~\"impl\",\n-            ItemMac(..) => ~\"macro\"\n-        };\n-        format!(\"{} {} (id={})\", item_str, path_str, id)\n-      }\n-      Some(NodeForeignItem(item, abi, _, path)) => {\n-        format!(\"foreign item {} with abi {:?} (id={})\",\n-             path_ident_to_str(path, item.ident, itr), abi, id)\n-      }\n-      Some(NodeMethod(m, _, path)) => {\n-        let name = itr.get(m.ident.name);\n-        format!(\"method {} in {} (id={})\",\n-             name.as_slice(), path_to_str(*path, itr), id)\n-      }\n-      Some(NodeTraitMethod(ref tm, _, path)) => {\n-        let m = ast_util::trait_method_to_ty_method(&**tm);\n-        let name = itr.get(m.ident.name);\n-        format!(\"method {} in {} (id={})\",\n-             name.as_slice(), path_to_str(*path, itr), id)\n-      }\n-      Some(NodeVariant(ref variant, _, path)) => {\n-        let name = itr.get(variant.node.name.name);\n-        format!(\"variant {} in {} (id={})\",\n-             name.as_slice(),\n-             path_to_str(*path, itr), id)\n-      }\n-      Some(NodeExpr(expr)) => {\n-        format!(\"expr {} (id={})\", pprust::expr_to_str(expr, itr), id)\n-      }\n-      Some(NodeCalleeScope(expr)) => {\n-        format!(\"callee_scope {} (id={})\", pprust::expr_to_str(expr, itr), id)\n-      }\n-      Some(NodeStmt(stmt)) => {\n-        format!(\"stmt {} (id={})\",\n-             pprust::stmt_to_str(stmt, itr), id)\n-      }\n-      Some(NodeArg(pat)) => {\n-        format!(\"arg {} (id={})\", pprust::pat_to_str(pat, itr), id)\n-      }\n-      Some(NodeLocal(pat)) => {\n-        format!(\"local {} (id={})\", pprust::pat_to_str(pat, itr), id)\n-      }\n-      Some(NodeBlock(block)) => {\n-        format!(\"block {} (id={})\", pprust::block_to_str(block, itr), id)\n-      }\n-      Some(NodeStructCtor(_, _, path)) => {\n-        format!(\"struct_ctor {} (id={})\", path_to_str(*path, itr), id)\n-      }\n-    }\n-}\n-\n-pub fn node_item_query<Result>(items: Map, id: NodeId, query: |@Item| -> Result, error_msg: ~str)\n-                       -> Result {\n-    match items.find(id) {\n-        Some(NodeItem(it, _)) => query(it),\n-        _ => fail!(\"{}\", error_msg)\n-    }\n-}\n-\n-pub fn node_span(items: Map, id: ast::NodeId) -> Span {\n-    match items.find(id) {\n-        Some(NodeItem(item, _)) => item.span,\n-        Some(NodeForeignItem(foreign_item, _, _, _)) => foreign_item.span,\n-        Some(NodeTraitMethod(trait_method, _, _)) => {\n-            match *trait_method {\n-                Required(ref type_method) => type_method.span,\n-                Provided(ref method) => method.span,\n-            }\n+        Some(NodeItem(item)) => {\n+            let path_str = map.path_to_str_with_ident(id, item.ident);\n+            let item_str = match item.node {\n+                ItemStatic(..) => \"static\",\n+                ItemFn(..) => \"fn\",\n+                ItemMod(..) => \"mod\",\n+                ItemForeignMod(..) => \"foreign mod\",\n+                ItemTy(..) => \"ty\",\n+                ItemEnum(..) => \"enum\",\n+                ItemStruct(..) => \"struct\",\n+                ItemTrait(..) => \"trait\",\n+                ItemImpl(..) => \"impl\",\n+                ItemMac(..) => \"macro\"\n+            };\n+            format!(\"{} {} (id={})\", item_str, path_str, id)\n+        }\n+        Some(NodeForeignItem(item)) => {\n+            let path_str = map.path_to_str_with_ident(id, item.ident);\n+            format!(\"foreign item {} (id={})\", path_str, id)\n+        }\n+        Some(NodeMethod(m)) => {\n+            format!(\"method {} in {} (id={})\",\n+                    token::get_ident(m.ident),\n+                    map.path_to_str(id), id)\n+        }\n+        Some(NodeTraitMethod(ref tm)) => {\n+            let m = ast_util::trait_method_to_ty_method(&**tm);\n+            format!(\"method {} in {} (id={})\",\n+                    token::get_ident(m.ident),\n+                    map.path_to_str(id), id)\n+        }\n+        Some(NodeVariant(ref variant)) => {\n+            format!(\"variant {} in {} (id={})\",\n+                    token::get_ident(variant.node.name),\n+                    map.path_to_str(id), id)\n+        }\n+        Some(NodeExpr(expr)) => {\n+            format!(\"expr {} (id={})\", pprust::expr_to_str(expr), id)\n+        }\n+        Some(NodeCalleeScope(expr)) => {\n+            format!(\"callee_scope {} (id={})\", pprust::expr_to_str(expr), id)\n+        }\n+        Some(NodeStmt(stmt)) => {\n+            format!(\"stmt {} (id={})\", pprust::stmt_to_str(stmt), id)\n+        }\n+        Some(NodeArg(pat)) => {\n+            format!(\"arg {} (id={})\", pprust::pat_to_str(pat), id)\n+        }\n+        Some(NodeLocal(pat)) => {\n+            format!(\"local {} (id={})\", pprust::pat_to_str(pat), id)\n+        }\n+        Some(NodeBlock(block)) => {\n+            format!(\"block {} (id={})\", pprust::block_to_str(block), id)\n+        }\n+        Some(NodeStructCtor(_)) => {\n+            format!(\"struct_ctor {} (id={})\", map.path_to_str(id), id)\n+        }\n+        None => {\n+            format!(\"unknown node (id={})\", id)\n         }\n-        Some(NodeMethod(method, _, _)) => method.span,\n-        Some(NodeVariant(variant, _, _)) => variant.span,\n-        Some(NodeExpr(expr)) => expr.span,\n-        Some(NodeStmt(stmt)) => stmt.span,\n-        Some(NodeArg(pat)) | Some(NodeLocal(pat)) => pat.span,\n-        Some(NodeBlock(block)) => block.span,\n-        Some(NodeStructCtor(_, item, _)) => item.span,\n-        Some(NodeCalleeScope(expr)) => expr.span,\n-        None => fail!(\"node_span: could not find id {}\", id),\n     }\n }"}, {"sha": "790f3927352a62082ef2f6aae4fc8eb17491a508", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -14,6 +14,7 @@ use ast_util;\n use codemap::Span;\n use opt_vec;\n use parse::token;\n+use print::pprust;\n use visit::Visitor;\n use visit;\n \n@@ -26,8 +27,7 @@ use std::local_data;\n pub fn path_name_i(idents: &[Ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     idents.map(|i| {\n-        let string = token::get_ident(i.name);\n-        string.get().to_str()\n+        token::get_ident(*i).get().to_str()\n     }).connect(\"::\")\n }\n \n@@ -246,6 +246,23 @@ pub fn unguarded_pat(a: &Arm) -> Option<~[@Pat]> {\n     }\n }\n \n+/// Generate a \"pretty\" name for an `impl` from its type and trait.\n+/// This is designed so that symbols of `impl`'d methods give some\n+/// hint of where they came from, (previously they would all just be\n+/// listed as `__extensions__::method_name::hash`, with no indication\n+/// of the type).\n+pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n+    let mut pretty = pprust::ty_to_str(ty);\n+    match *trait_ref {\n+        Some(ref trait_ref) => {\n+            pretty.push_char('.');\n+            pretty.push_str(pprust::path_to_str(&trait_ref.path));\n+        }\n+        None => {}\n+    }\n+    token::gensym_ident(pretty)\n+}\n+\n pub fn public_methods(ms: ~[@Method]) -> ~[@Method] {\n     ms.move_iter().filter(|m| {\n         match m.vis {"}, {"sha": "0900eca1ad1d8d6c47a3b32f753e971c44fa7e43", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -440,8 +440,7 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n         match tts[0] {\n             ast::TTTok(_, token::LIT_STR(ident))\n             | ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => {\n-                let interned_str = token::get_ident(ident.name);\n-                return Some(interned_str.get().to_str())\n+                return Some(token::get_ident(ident).get().to_str())\n             }\n             _ => cx.span_err(sp, format!(\"{} requires a string.\", name)),\n         }"}, {"sha": "15e9d31daa00fc24c4841f131f6364647fe56356", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -31,8 +31,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         } else {\n             match *e {\n                 ast::TTTok(_, token::IDENT(ident,_)) => {\n-                    let interned_str = token::get_ident(ident.name);\n-                    res_str.push_str(interned_str.get())\n+                    res_str.push_str(token::get_ident(ident).get())\n                 }\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");"}, {"sha": "c1a6b41db9d116667dfd00c4627932bcc9413347", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -86,8 +86,7 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                 decoder,\n                                 cx.ident_of(\"read_struct\"),\n                                 ~[\n-                cx.expr_str(trait_span,\n-                            token::get_ident(substr.type_ident.name)),\n+                cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 cx.expr_uint(trait_span, nfields),\n                 cx.lambda_expr_1(trait_span, result, blkarg)\n             ])\n@@ -100,8 +99,7 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n             for (i, &(name, v_span, ref parts)) in fields.iter().enumerate() {\n-                variants.push(cx.expr_str(v_span,\n-                                          token::get_ident(name.name)));\n+                variants.push(cx.expr_str(v_span, token::get_ident(name)));\n \n                 let decoded = decode_static_fields(cx,\n                                                    v_span,\n@@ -130,8 +128,7 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                 decoder,\n                                 cx.ident_of(\"read_enum\"),\n                                 ~[\n-                cx.expr_str(trait_span,\n-                            token::get_ident(substr.type_ident.name)),\n+                cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 cx.lambda_expr_1(trait_span, result, blkarg)\n             ])\n         }\n@@ -166,7 +163,7 @@ fn decode_static_fields(cx: &mut ExtCtxt,\n         Named(ref fields) => {\n             // use the field's span to get nicer error messages.\n             let fields = fields.iter().enumerate().map(|(i, &(name, span))| {\n-                let arg = getarg(cx, span, token::get_ident(name.name), i);\n+                let arg = getarg(cx, span, token::get_ident(name), i);\n                 cx.field_imm(span, name, arg)\n             }).collect();\n             cx.expr_struct_ident(trait_span, outer_pat_ident, fields)"}, {"sha": "f35cdab972ce876d85f80055a8430aedfa5cc87a", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -132,7 +132,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                     ..\n                 }) in fields.iter().enumerate() {\n                 let name = match name {\n-                    Some(id) => token::get_ident(id.name),\n+                    Some(id) => token::get_ident(id),\n                     None => {\n                         token::intern_and_get_ident(format!(\"_field{}\", i))\n                     }\n@@ -152,8 +152,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                 encoder,\n                                 cx.ident_of(\"emit_struct\"),\n                                 ~[\n-                cx.expr_str(trait_span,\n-                            token::get_ident(substr.type_ident.name)),\n+                cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 cx.expr_uint(trait_span, fields.len()),\n                 blk\n             ])\n@@ -179,8 +178,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            let name = cx.expr_str(trait_span,\n-                                   token::get_ident(variant.node.name.name));\n+            let name = cx.expr_str(trait_span, token::get_ident(variant.node.name));\n             let call = cx.expr_method_call(trait_span, blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n                                            ~[name,\n@@ -192,8 +190,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                           encoder,\n                                           cx.ident_of(\"emit_enum\"),\n                                           ~[\n-                cx.expr_str(trait_span,\n-                            token::get_ident(substr.type_ident.name)),\n+                cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 blk\n             ]);\n             cx.expr_block(cx.block(trait_span, ~[me], Some(ret)))"}, {"sha": "a9fdb15fdd456fce038cc0a43bb3c8165ebc665a", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -178,7 +178,7 @@ StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, <span of C0>, Unnamed(~[<span\n \n use ast;\n use ast::{P, EnumDef, Expr, Ident, Generics, StructDef};\n-\n+use ast_util;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap;\n@@ -405,11 +405,13 @@ impl<'a> TraitDef<'a> {\n                                ast::LitStr(token::intern_and_get_ident(\n                                                \"Automatically derived.\"),\n                                            ast::CookedStr)));\n+        let opt_trait_ref = Some(trait_ref);\n+        let ident = ast_util::impl_pretty_name(&opt_trait_ref, self_type);\n         cx.item(\n             self.span,\n-            ::parse::token::special_idents::clownshoes_extensions,\n+            ident,\n             ~[doc_attr],\n-            ast::ItemImpl(trait_generics, Some(trait_ref),\n+            ast::ItemImpl(trait_generics, opt_trait_ref,\n                           self_type, methods.map(|x| *x)))\n     }\n "}, {"sha": "68fad460a344c9430b38d11979af13b2c0aa8295", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -67,7 +67,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         }\n     };\n \n-    let mut format_string = token::get_ident(name.name).get().to_owned();\n+    let mut format_string = token::get_ident(name).get().to_owned();\n     // the internal fields we're actually formatting\n     let mut exprs = ~[];\n \n@@ -99,7 +99,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                 for (i, field) in fields.iter().enumerate() {\n                     if i != 0 { format_string.push_str(\",\"); }\n \n-                    let name = token::get_ident(field.name.unwrap().name);\n+                    let name = token::get_ident(field.name.unwrap());\n                     format_string.push_str(\" \");\n                     format_string.push_str(name.get());\n                     format_string.push_str(\": {}\");"}, {"sha": "8453d0f03125ec4bd74da66392973e2450113b0b", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -57,10 +57,10 @@ fn to_str_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure)\n                 name: ast::Ident,\n                 fields: &[FieldInfo]| {\n         if fields.len() == 0 {\n-            cx.expr_str_uniq(span, token::get_ident(name.name))\n+            cx.expr_str_uniq(span, token::get_ident(name))\n         } else {\n             let buf = cx.ident_of(\"buf\");\n-            let interned_str = token::get_ident(name.name);\n+            let interned_str = token::get_ident(name);\n             let start =\n                 token::intern_and_get_ident(interned_str.get() + start);\n             let init = cx.expr_str_uniq(span, start);\n@@ -81,7 +81,7 @@ fn to_str_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure)\n                     match name {\n                         None => {}\n                         Some(id) => {\n-                            let interned_id = token::get_ident(id.name);\n+                            let interned_id = token::get_ident(id);\n                             let name = interned_id.get() + \": \";\n                             push(cx.expr_str(span,\n                                              token::intern_and_get_ident(name)));"}, {"sha": "380178191b78671bfc93b6523d71ba15a1d18f46", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -54,8 +54,8 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                         // let compilation continue\n                         return e;\n                     }\n-                    let extname = &pth.segments[0].identifier;\n-                    let extnamestr = token::get_ident(extname.name);\n+                    let extname = pth.segments[0].identifier;\n+                    let extnamestr = token::get_ident(extname);\n                     // leaving explicit deref here to highlight unbox op:\n                     let marked_after = match fld.extsbox.find(&extname.name) {\n                         None => {\n@@ -297,26 +297,25 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n-    let extname = &pth.segments[0].identifier;\n-    let extnamestr = token::get_ident(extname.name);\n+    let extname = pth.segments[0].identifier;\n+    let extnamestr = token::get_ident(extname);\n     let fm = fresh_mark();\n     let expanded = match fld.extsbox.find(&extname.name) {\n         None => {\n             fld.cx.span_err(pth.span,\n                             format!(\"macro undefined: '{}!'\",\n-                                    extnamestr.get()));\n+                                    extnamestr));\n             // let compilation continue\n             return SmallVector::zero();\n         }\n \n         Some(&NormalTT(ref expander, span)) => {\n             if it.ident.name != parse::token::special_idents::invalid.name {\n-                let string = token::get_ident(it.ident.name);\n                 fld.cx.span_err(pth.span,\n                                 format!(\"macro {}! expects no ident argument, \\\n                                         given '{}'\",\n-                                        extnamestr.get(),\n-                                        string.get()));\n+                                        extnamestr,\n+                                        token::get_ident(it.ident)));\n                 return SmallVector::zero();\n             }\n             fld.cx.bt_push(ExpnInfo {\n@@ -418,13 +417,10 @@ fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n     let MacroCrate { lib, cnum } = fld.cx.loader.load_crate(krate);\n \n     let crate_name = match krate.node {\n-        ast::ViewItemExternMod(ref name, _, _) => {\n-            let string = token::get_ident(name.name);\n-            string.get().to_str()\n-        },\n-        _ => unreachable!(),\n+        ast::ViewItemExternMod(name, _, _) => name,\n+        _ => unreachable!()\n     };\n-    let name = format!(\"<{} macros>\", crate_name);\n+    let name = format!(\"<{} macros>\", token::get_ident(crate_name));\n \n     let exported_macros = fld.cx.loader.get_exported_macros(cnum);\n     for source in exported_macros.iter() {\n@@ -496,12 +492,11 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n         fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n         return SmallVector::zero();\n     }\n-    let extname = &pth.segments[0].identifier;\n-    let extnamestr = token::get_ident(extname.name);\n+    let extname = pth.segments[0].identifier;\n+    let extnamestr = token::get_ident(extname);\n     let marked_after = match fld.extsbox.find(&extname.name) {\n         None => {\n-            fld.cx.span_err(pth.span, format!(\"macro undefined: '{}'\",\n-                                              extnamestr.get()));\n+            fld.cx.span_err(pth.span, format!(\"macro undefined: '{}'\", extnamestr));\n             return SmallVector::zero();\n         }\n \n@@ -535,7 +530,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n                 _ => {\n                     fld.cx.span_err(pth.span,\n                                     format!(\"non-stmt macro in stmt pos: {}\",\n-                                            extnamestr.get()));\n+                                            extnamestr));\n                     return SmallVector::zero();\n                 }\n             };\n@@ -545,7 +540,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n \n         _ => {\n             fld.cx.span_err(pth.span, format!(\"'{}' is not a tt-style macro\",\n-                                              extnamestr.get()));\n+                                              extnamestr));\n             return SmallVector::zero();\n         }\n     };\n@@ -1186,9 +1181,7 @@ mod test {\n                         println!(\"uh oh, matches but shouldn't:\");\n                         println!(\"varref: {:?}\",varref);\n                         // good lord, you can't make a path with 0 segments, can you?\n-                        let string = token::get_ident(varref.segments[0]\n-                                                            .identifier\n-                                                            .name);\n+                        let string = token::get_ident(varref.segments[0].identifier);\n                         println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n                                  varref.segments[0].identifier.name,\n                                  string.get());\n@@ -1213,10 +1206,7 @@ foo_module!()\n         let bindings = name_finder.ident_accumulator;\n \n         let cxbinds: ~[&ast::Ident] =\n-            bindings.iter().filter(|b| {\n-                let string = token::get_ident(b.name);\n-                \"xx\" == string.get()\n-            }).collect();\n+            bindings.iter().filter(|b| \"xx\" == token::get_ident(**b).get()).collect();\n         let cxbind = match cxbinds {\n             [b] => b,\n             _ => fail!(\"expected just one binding for ext_cx\")\n@@ -1228,12 +1218,9 @@ foo_module!()\n         let varrefs = path_finder.path_accumulator;\n \n         // the xx binding should bind all of the xx varrefs:\n-        for (idx,v) in varrefs.iter().filter(|p|{\n+        for (idx,v) in varrefs.iter().filter(|p| {\n             p.segments.len() == 1\n-            && {\n-                let string = token::get_ident(p.segments[0].identifier.name);\n-                \"xx\" == string.get()\n-            }\n+            && \"xx\" == token::get_ident(p.segments[0].identifier).get()\n         }).enumerate() {\n             if mtwt_resolve(v.segments[0].identifier) != resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");"}, {"sha": "01d348595b88c08d993c0b1804f048e364a8defd", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -112,7 +112,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span,\n                     return (extra, None);\n                 }\n             };\n-            let interned_name = token::get_ident(ident.name);\n+            let interned_name = token::get_ident(ident);\n             let name = interned_name.get();\n             p.expect(&token::EQ);\n             let e = p.parse_expr();"}, {"sha": "5ee4084d207ba36dcc942d98933435d7757305a0", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -13,18 +13,14 @@ use codemap;\n use ext::base::*;\n use ext::base;\n use print;\n-use parse::token::{get_ident_interner};\n \n pub fn expand_syntax_ext(cx: &mut ExtCtxt,\n                          sp: codemap::Span,\n                          tt: &[ast::TokenTree])\n                       -> base::MacResult {\n \n     cx.print_backtrace();\n-    println!(\"{}\",\n-        print::pprust::tt_to_str(\n-            &ast::TTDelim(@tt.to_owned()),\n-            get_ident_interner()));\n+    println!(\"{}\", print::pprust::tt_to_str(&ast::TTDelim(@tt.to_owned())));\n \n     //trivial expression\n     MRExpr(@ast::Expr {"}, {"sha": "35a5cbd235ae4cb56f3b2d4192aa779b64ba0a51", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -71,14 +71,13 @@ pub mod rt {\n \n     impl ToSource for ast::Ident {\n         fn to_source(&self) -> ~str {\n-            let this = get_ident(self.name);\n-            this.get().to_owned()\n+            get_ident(*self).get().to_str()\n         }\n     }\n \n     impl ToSource for @ast::Item {\n         fn to_source(&self) -> ~str {\n-            pprust::item_to_str(*self, get_ident_interner())\n+            pprust::item_to_str(*self)\n         }\n     }\n \n@@ -90,7 +89,7 @@ pub mod rt {\n \n     impl ToSource for ast::Ty {\n         fn to_source(&self) -> ~str {\n-            pprust::ty_to_str(self, get_ident_interner())\n+            pprust::ty_to_str(self)\n         }\n     }\n \n@@ -102,19 +101,19 @@ pub mod rt {\n \n     impl ToSource for Generics {\n         fn to_source(&self) -> ~str {\n-            pprust::generics_to_str(self, get_ident_interner())\n+            pprust::generics_to_str(self)\n         }\n     }\n \n     impl ToSource for @ast::Expr {\n         fn to_source(&self) -> ~str {\n-            pprust::expr_to_str(*self, get_ident_interner())\n+            pprust::expr_to_str(*self)\n         }\n     }\n \n     impl ToSource for ast::Block {\n         fn to_source(&self) -> ~str {\n-            pprust::block_to_str(self, get_ident_interner())\n+            pprust::block_to_str(self)\n         }\n     }\n \n@@ -349,7 +348,7 @@ fn id_ext(str: &str) -> ast::Ident {\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n-    let e_str = cx.expr_str(sp, token::get_ident(ident.name));\n+    let e_str = cx.expr_str(sp, token::get_ident(ident));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),"}, {"sha": "150f054b2afe4f43bf97bccab4c7c12189ff3101", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -16,7 +16,6 @@ use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use parse;\n-use parse::token::get_ident_interner;\n use parse::token;\n use print::pprust;\n \n@@ -64,18 +63,15 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n-    let s = pprust::tts_to_str(tts, get_ident_interner());\n+    let s = pprust::tts_to_str(tts);\n     base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let string = cx.mod_path()\n-                   .map(|x| {\n-                        let interned_str = token::get_ident(x.name);\n-                        interned_str.get().to_str()\n-                    })\n+                   .map(|x| token::get_ident(*x).get().to_str())\n                    .connect(\"::\");\n     base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(string)))\n }"}, {"sha": "c2d005da74ebe8f5c83cba912ebc6b54d51772ee", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -18,7 +18,7 @@ use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n use parse::attr::ParserAttr;\n use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n-use parse::token::{Token, EOF, to_str, Nonterminal, get_ident_interner};\n+use parse::token::{Token, EOF, Nonterminal};\n use parse::token;\n \n use std::hashmap::HashMap;\n@@ -180,14 +180,15 @@ pub fn nameize(p_s: @ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n             };\n           }\n           codemap::Spanned {\n-                node: MatchNonterminal(ref bind_name, _, idx), span: sp\n+                node: MatchNonterminal(bind_name, _, idx),\n+                span\n           } => {\n-            if ret_val.contains_key(bind_name) {\n-                let string = token::get_ident(bind_name.name);\n+            if ret_val.contains_key(&bind_name) {\n+                let string = token::get_ident(bind_name);\n                 p_s.span_diagnostic\n-                   .span_fatal(sp, \"duplicated bind name: \" + string.get())\n+                   .span_fatal(span, \"duplicated bind name: \" + string.get())\n             }\n-            ret_val.insert(*bind_name, res[idx]);\n+            ret_val.insert(bind_name, res[idx]);\n           }\n         }\n     }\n@@ -364,12 +365,10 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n                 || bb_eis.len() > 1u {\n                 let nts = bb_eis.map(|ei| {\n                     match ei.elts[ei.idx].node {\n-                      MatchNonterminal(ref bind,ref name,_) => {\n-                        let bind_string = token::get_ident(bind.name);\n-                        let name_string = token::get_ident(name.name);\n+                      MatchNonterminal(bind, name, _) => {\n                         format!(\"{} ('{}')\",\n-                                name_string.get(),\n-                                bind_string.get())\n+                                token::get_ident(name),\n+                                token::get_ident(bind))\n                       }\n                       _ => fail!()\n                     } }).connect(\" or \");\n@@ -379,7 +378,7 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n                     nts, next_eis.len()));\n             } else if bb_eis.len() == 0u && next_eis.len() == 0u {\n                 return Failure(sp, format!(\"no rules expected the token `{}`\",\n-                            to_str(get_ident_interner(), &tok)));\n+                            token::to_str(&tok)));\n             } else if next_eis.len() > 0u {\n                 /* Now process the next token */\n                 while next_eis.len() > 0u {\n@@ -391,8 +390,8 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n \n                 let mut ei = bb_eis.pop().unwrap();\n                 match ei.elts[ei.idx].node {\n-                  MatchNonterminal(_, ref name, idx) => {\n-                    let name_string = token::get_ident(name.name);\n+                  MatchNonterminal(_, name, idx) => {\n+                    let name_string = token::get_ident(name);\n                     ei.matches[idx].push(@MatchedNonterminal(\n                         parse_nt(&mut rust_parser, name_string.get())));\n                     ei.idx += 1u;\n@@ -426,7 +425,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n       \"ident\" => match p.token {\n         token::IDENT(sn,b) => { p.bump(); token::NtIdent(~sn,b) }\n         _ => {\n-            let token_str = token::to_str(get_ident_interner(), &p.token);\n+            let token_str = token::to_str(&p.token);\n             p.fatal(~\"expected ident, found \" + token_str)\n         }\n       },"}, {"sha": "45fe24ebf68ff5ae02b81c11a340969ff5e014e1", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -21,7 +21,7 @@ use ext::tt::macro_parser::{parse, parse_or_else};\n use parse::lexer::new_tt_reader;\n use parse::parser::Parser;\n use parse::attr::ParserAttr;\n-use parse::token::{get_ident_interner, special_idents, gensym_ident};\n+use parse::token::{special_idents, gensym_ident};\n use parse::token::{FAT_ARROW, SEMI, NtMatchers, NtTT, EOF};\n use parse::token;\n use print;\n@@ -113,11 +113,9 @@ fn generic_extension(cx: &ExtCtxt,\n                      rhses: &[@NamedMatch])\n                      -> MacResult {\n     if cx.trace_macros() {\n-        let interned_name = token::get_ident(name.name);\n         println!(\"{}! \\\\{ {} \\\\}\",\n-                 interned_name.get(),\n-                 print::pprust::tt_to_str(&TTDelim(@arg.to_owned()),\n-                                          get_ident_interner()));\n+                 token::get_ident(name),\n+                 print::pprust::tt_to_str(&TTDelim(@arg.to_owned())));\n     }\n \n     // Which arm's failure should we report? (the one furthest along)\n@@ -231,7 +229,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n     };\n \n     return MRDef(MacroDef {\n-        name: token::get_ident(name.name).get().to_str(),\n+        name: token::get_ident(name).get().to_str(),\n         ext: NormalTT(exp, Some(sp))\n     });\n }"}, {"sha": "fb2aae9b8c168518ad25418b0e523c7edd8db8ce", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -19,7 +19,6 @@ use parse::lexer::TokenAndSpan;\n \n use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n-use std::option;\n \n ///an unzipping of `TokenTree`s\n struct TtFrame {\n@@ -57,7 +56,7 @@ pub fn new_tt_reader(sp_diag: @SpanHandler,\n             idx: Cell::new(0u),\n             dotdotdoted: false,\n             sep: None,\n-            up: option::None\n+            up: None\n         }),\n         interpolations: match interp { /* just a convienience */\n             None => RefCell::new(HashMap::new()),\n@@ -122,10 +121,9 @@ fn lookup_cur_matched(r: &TtReader, name: Ident) -> @NamedMatch {\n     match matched_opt {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n-            let name_string = token::get_ident(name.name);\n             r.sp_diag.span_fatal(r.cur_span.get(),\n                                  format!(\"unknown macro variable `{}`\",\n-                                         name_string.get()));\n+                                         token::get_ident(name)));\n         }\n     }\n }\n@@ -141,16 +139,16 @@ fn lis_merge(lhs: LockstepIterSize, rhs: LockstepIterSize) -> LockstepIterSize {\n     match lhs {\n         LisUnconstrained => rhs.clone(),\n         LisContradiction(_) => lhs.clone(),\n-        LisConstraint(l_len, ref l_id) => match rhs {\n+        LisConstraint(l_len, l_id) => match rhs {\n             LisUnconstrained => lhs.clone(),\n             LisContradiction(_) => rhs.clone(),\n             LisConstraint(r_len, _) if l_len == r_len => lhs.clone(),\n-            LisConstraint(r_len, ref r_id) => {\n-                let l_n = token::get_ident(l_id.name);\n-                let r_n = token::get_ident(r_id.name);\n+            LisConstraint(r_len, r_id) => {\n+                let l_n = token::get_ident(l_id);\n+                let r_n = token::get_ident(r_id);\n                 LisContradiction(format!(\"inconsistent lockstep iteration: \\\n                                           '{}' has {} items, but '{}' has {}\",\n-                                          l_n.get(), l_len, r_n.get(), r_len))\n+                                          l_n, l_len, r_n, r_len))\n             }\n         }\n     }\n@@ -240,7 +238,7 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n                 idx: Cell::new(0u),\n                 dotdotdoted: false,\n                 sep: None,\n-                up: option::Some(r.stack.get())\n+                up: Some(r.stack.get())\n             });\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n@@ -314,11 +312,10 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n                 return ret_val;\n               }\n               MatchedSeq(..) => {\n-                let string = token::get_ident(ident.name);\n                 r.sp_diag.span_fatal(\n                     r.cur_span.get(), /* blame the macro writer */\n                     format!(\"variable '{}' is still repeating at this depth\",\n-                            string.get()));\n+                            token::get_ident(ident)));\n               }\n             }\n           }"}, {"sha": "6fb66a66f18b5c6d2cafcae555aa268896de87f0", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -10,6 +10,7 @@\n \n use ast::*;\n use ast;\n+use ast_util;\n use codemap::{respan, Span, Spanned};\n use parse::token;\n use opt_vec::OptVec;\n@@ -261,10 +262,10 @@ pub trait Folder {\n \n     fn fold_local(&mut self, l: @Local) -> @Local {\n         @Local {\n+            id: self.new_id(l.id), // Needs to be first, for ast_map.\n             ty: self.fold_ty(l.ty),\n             pat: self.fold_pat(l.pat),\n             init: l.init.map(|e| self.fold_expr(e)),\n-            id: self.new_id(l.id),\n             span: self.new_span(l.span),\n         }\n     }\n@@ -344,9 +345,9 @@ fn fold_attribute_<T: Folder>(at: Attribute, fld: &mut T) -> Attribute {\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n     Arg {\n+        id: fld.new_id(a.id), // Needs to be first, for ast_map.\n         ty: fld.fold_ty(a.ty),\n         pat: fld.fold_pat(a.pat),\n-        id: fld.new_id(a.id),\n     }\n }\n \n@@ -514,10 +515,10 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n     P(Block {\n+        id: folder.new_id(b.id), // Needs to be first, for ast_map.\n         view_items: view_items,\n         stmts: stmts,\n         expr: b.expr.map(|x| folder.fold_expr(x)),\n-        id: folder.new_id(b.id),\n         rules: b.rules,\n         span: folder.new_span(b.span),\n     })\n@@ -579,13 +580,13 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n \n pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMethod {\n     TypeMethod {\n+        id: fld.new_id(m.id), // Needs to be first, for ast_map.\n         ident: fld.fold_ident(m.ident),\n         attrs: m.attrs.map(|a| fold_attribute_(*a, fld)),\n         purity: m.purity,\n         decl: fld.fold_fn_decl(m.decl),\n         generics: fold_generics(&m.generics, fld),\n         explicit_self: fld.fold_explicit_self(&m.explicit_self),\n-        id: fld.new_id(m.id),\n         span: fld.new_span(m.span),\n     }\n }\n@@ -609,18 +610,29 @@ pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n }\n \n pub fn noop_fold_item<T: Folder>(i: &Item, folder: &mut T) -> SmallVector<@Item> {\n+    let id = folder.new_id(i.id); // Needs to be first, for ast_map.\n+    let node = folder.fold_item_underscore(&i.node);\n+    let ident = match node {\n+        // The node may have changed, recompute the \"pretty\" impl name.\n+        ItemImpl(_, ref maybe_trait, ty, _) => {\n+            ast_util::impl_pretty_name(maybe_trait, ty)\n+        }\n+        _ => i.ident\n+    };\n+\n     SmallVector::one(@Item {\n-        ident: folder.fold_ident(i.ident),\n+        id: id,\n+        ident: folder.fold_ident(ident),\n         attrs: i.attrs.map(|e| fold_attribute_(*e, folder)),\n-        id: folder.new_id(i.id),\n-        node: folder.fold_item_underscore(&i.node),\n+        node: node,\n         vis: i.vis,\n         span: folder.new_span(i.span)\n     })\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @ForeignItem {\n     @ForeignItem {\n+        id: folder.new_id(ni.id), // Needs to be first, for ast_map.\n         ident: folder.fold_ident(ni.ident),\n         attrs: ni.attrs.map(|x| fold_attribute_(*x, folder)),\n         node: match ni.node {\n@@ -636,22 +648,21 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @F\n                 ForeignItemStatic(folder.fold_ty(t), m)\n             }\n         },\n-        id: folder.new_id(ni.id),\n         span: folder.new_span(ni.span),\n         vis: ni.vis,\n     }\n }\n \n pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> @Method {\n     @Method {\n+        id: folder.new_id(m.id), // Needs to be first, for ast_map.\n         ident: folder.fold_ident(m.ident),\n         attrs: m.attrs.map(|a| fold_attribute_(*a, folder)),\n         generics: fold_generics(&m.generics, folder),\n         explicit_self: folder.fold_explicit_self(&m.explicit_self),\n         purity: m.purity,\n         decl: folder.fold_fn_decl(m.decl),\n         body: folder.fold_block(m.body),\n-        id: folder.new_id(m.id),\n         span: folder.new_span(m.span),\n         vis: m.vis\n     }\n@@ -894,8 +905,7 @@ mod test {\n             ~\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate,\n-                                    token::get_ident_interner()),\n+                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate),\n                      ~\"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\");\n     }\n \n@@ -907,8 +917,7 @@ mod test {\n               (g $(d $d $e)+))} \");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate,\n-                                    token::get_ident_interner()),\n+                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate),\n                      ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n     }\n }"}, {"sha": "e0ae9ce2812141eedb7ef5d29f438f0bb8b522fe", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -16,7 +16,6 @@ use parse::lexer::{StringReader, bump, is_eof, nextch_is, TokenAndSpan};\n use parse::lexer::{is_line_non_doc_comment, is_block_non_doc_comment};\n use parse::lexer;\n use parse::token;\n-use parse::token::{get_ident_interner};\n \n use std::io;\n use std::str;\n@@ -385,7 +384,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                 literals.push(Literal {lit: s.to_owned(), pos: sp.lo});\n             })\n         } else {\n-            debug!(\"tok: {}\", token::to_str(get_ident_interner(), &tok));\n+            debug!(\"tok: {}\", token::to_str(&tok));\n         }\n         first_read = false;\n     }"}, {"sha": "460ad76cffeb9e3b369cd9e23e9ee5436c018963", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use parse::token;\n-use parse::token::{get_ident_interner};\n \n // SeqSep : a sequence separator (token)\n // and whether a trailing separator is allowed.\n@@ -36,10 +35,3 @@ pub fn seq_sep_none() -> SeqSep {\n         trailing_sep_allowed: false,\n     }\n }\n-\n-// maps any token back to a string. not necessary if you know it's\n-// an identifier....\n-pub fn token_to_str(token: &token::Token) -> ~str {\n-    token::to_str(get_ident_interner(), token)\n-}\n-"}, {"sha": "accffd374a9f8b21ace3bc5c3df673a7ef4abf70", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -175,8 +175,7 @@ impl ParserObsoleteMethods for Parser {\n     fn is_obsolete_ident(&mut self, ident: &str) -> bool {\n         match self.token {\n             token::IDENT(sid, _) => {\n-                let interned_string = token::get_ident(sid.name);\n-                interned_string.equiv(&ident)\n+                token::get_ident(sid).equiv(&ident)\n             }\n             _ => false\n         }"}, {"sha": "674d41e9dbe2a456f0697e9b3f5f5b080479ddb6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -71,9 +71,9 @@ use parse::common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed};\n use parse::lexer::Reader;\n use parse::lexer::TokenAndSpan;\n use parse::obsolete::*;\n-use parse::token::{INTERPOLATED, InternedString, can_begin_expr, get_ident};\n-use parse::token::{get_ident_interner, is_ident, is_ident_or_path};\n-use parse::token::{is_plain_ident, keywords, special_idents, token_to_binop};\n+use parse::token::{INTERPOLATED, InternedString, can_begin_expr};\n+use parse::token::{is_ident, is_ident_or_path, is_plain_ident};\n+use parse::token::{keywords, special_idents, token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, ParseSess};\n use opt_vec;\n@@ -288,7 +288,6 @@ struct ParsedItemsAndViewItems {\n pub fn Parser(sess: @ParseSess, cfg: ast::CrateConfig, rdr: ~Reader:)\n               -> Parser {\n     let tok0 = rdr.next_token();\n-    let interner = get_ident_interner();\n     let span = tok0.sp;\n     let placeholder = TokenAndSpan {\n         tok: token::UNDERSCORE,\n@@ -297,7 +296,7 @@ pub fn Parser(sess: @ParseSess, cfg: ast::CrateConfig, rdr: ~Reader:)\n \n     Parser {\n         reader: rdr,\n-        interner: interner,\n+        interner: token::get_ident_interner(),\n         sess: sess,\n         cfg: cfg,\n         token: tok0.tok,\n@@ -359,7 +358,7 @@ fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n impl Parser {\n     // convert a token to a string using self's reader\n     pub fn token_to_str(token: &token::Token) -> ~str {\n-        token::to_str(get_ident_interner(), token)\n+        token::to_str(token)\n     }\n \n     // convert the current token to a string using self's reader\n@@ -531,12 +530,10 @@ impl Parser {\n     // otherwise, eat it.\n     pub fn expect_keyword(&mut self, kw: keywords::Keyword) {\n         if !self.eat_keyword(kw) {\n-            let id_ident = kw.to_ident();\n-            let id_interned_str = token::get_ident(id_ident.name);\n+            let id_interned_str = token::get_ident(kw.to_ident());\n             let token_str = self.this_token_to_str();\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n-                               id_interned_str.get(),\n-                               token_str))\n+                               id_interned_str, token_str))\n         }\n     }\n \n@@ -804,7 +801,7 @@ impl Parser {\n     }\n \n     pub fn id_to_interned_str(&mut self, id: Ident) -> InternedString {\n-        get_ident(id.name)\n+        token::get_ident(id)\n     }\n \n     // Is the current token one of the keywords that signals a bare function\n@@ -3425,8 +3422,7 @@ impl Parser {\n         loop {\n             match self.token {\n                 token::LIFETIME(lifetime) => {\n-                    let lifetime_interned_string =\n-                        token::get_ident(lifetime.name);\n+                    let lifetime_interned_string = token::get_ident(lifetime);\n                     if lifetime_interned_string.equiv(&(\"static\")) {\n                         result.push(RegionTyParamBound);\n                     } else {\n@@ -3876,10 +3872,6 @@ impl Parser {\n         // First, parse type parameters if necessary.\n         let generics = self.parse_generics();\n \n-        // This is a new-style impl declaration.\n-        // FIXME: clownshoes\n-        let ident = special_idents::clownshoes_extensions;\n-\n         // Special case: if the next identifier that follows is '(', don't\n         // allow this to be parsed as a trait.\n         let could_be_trait = self.token != token::LPAREN;\n@@ -3923,6 +3915,8 @@ impl Parser {\n             method_attrs = None;\n         }\n \n+        let ident = ast_util::impl_pretty_name(&opt_trait, ty);\n+\n         (ident, ItemImpl(generics, opt_trait, ty, meths), Some(inner_attrs))\n     }\n \n@@ -3959,9 +3953,8 @@ impl Parser {\n                 fields.push(self.parse_struct_decl_field());\n             }\n             if fields.len() == 0 {\n-                let string = get_ident_interner().get(class_name.name);\n                 self.fatal(format!(\"unit-like struct definition should be written as `struct {};`\",\n-                                   string.as_slice()));\n+                                   token::get_ident(class_name)));\n             }\n             self.bump();\n         } else if self.token == token::LPAREN {\n@@ -4159,7 +4152,7 @@ impl Parser {\n                 outer_attrs, \"path\") {\n             Some(d) => dir_path.join(d),\n             None => {\n-                let mod_string = token::get_ident(id.name);\n+                let mod_string = token::get_ident(id);\n                 let mod_name = mod_string.get().to_owned();\n                 let default_path_str = mod_name + \".rs\";\n                 let secondary_path_str = mod_name + \"/mod.rs\";\n@@ -4378,7 +4371,7 @@ impl Parser {\n \n         let item = self.mk_item(lo,\n                                 self.last_span.hi,\n-                                special_idents::clownshoes_foreign_mod,\n+                                special_idents::invalid,\n                                 ItemForeignMod(m),\n                                 visibility,\n                                 maybe_append(attrs, Some(inner)));\n@@ -4498,7 +4491,7 @@ impl Parser {\n             token::LIT_STR(s)\n             | token::LIT_STR_RAW(s, _) => {\n                 self.bump();\n-                let identifier_string = token::get_ident(s.name);\n+                let identifier_string = token::get_ident(s);\n                 let the_string = identifier_string.get();\n                 let mut abis = AbiSet::empty();\n                 for word in the_string.words() {"}, {"sha": "b264e8d7467ba23caa887aced926888fe2367d4b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 103, "deletions": 118, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{P, Name, Mrk};\n+use ast::{P, Ident, Name, Mrk};\n use ast_util;\n use parse::token;\n use util::interner::{RcStr, StrInterner};\n@@ -133,7 +133,7 @@ pub fn binop_to_str(o: BinOp) -> ~str {\n     }\n }\n \n-pub fn to_str(input: @IdentInterner, t: &Token) -> ~str {\n+pub fn to_str(t: &Token) -> ~str {\n     match *t {\n       EQ => ~\"=\",\n       LT => ~\"<\",\n@@ -187,50 +187,42 @@ pub fn to_str(input: @IdentInterner, t: &Token) -> ~str {\n           u.to_str() + ast_util::uint_ty_to_str(t)\n       }\n       LIT_INT_UNSUFFIXED(i) => { i.to_str() }\n-      LIT_FLOAT(ref s, t) => {\n-        let body_string = get_ident(s.name);\n-        let mut body = body_string.get().to_str();\n+      LIT_FLOAT(s, t) => {\n+        let mut body = get_ident(s).get().to_str();\n         if body.ends_with(\".\") {\n             body.push_char('0');  // `10.f` is not a float literal\n         }\n         body + ast_util::float_ty_to_str(t)\n       }\n-      LIT_FLOAT_UNSUFFIXED(ref s) => {\n-        let body_string = get_ident(s.name);\n-        let mut body = body_string.get().to_owned();\n+      LIT_FLOAT_UNSUFFIXED(s) => {\n+        let mut body = get_ident(s).get().to_str();\n         if body.ends_with(\".\") {\n             body.push_char('0');  // `10.f` is not a float literal\n         }\n         body\n       }\n-      LIT_STR(ref s) => {\n-          let literal_string = get_ident(s.name);\n-          format!(\"\\\"{}\\\"\", literal_string.get().escape_default())\n+      LIT_STR(s) => {\n+          format!(\"\\\"{}\\\"\", get_ident(s).get().escape_default())\n       }\n-      LIT_STR_RAW(ref s, n) => {\n-          let literal_string = get_ident(s.name);\n+      LIT_STR_RAW(s, n) => {\n           format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                  delim=\"#\".repeat(n), string=literal_string.get())\n+                  delim=\"#\".repeat(n), string=get_ident(s))\n       }\n \n       /* Name components */\n-      IDENT(s, _) => input.get(s.name).into_owned(),\n+      IDENT(s, _) => get_ident(s).get().to_str(),\n       LIFETIME(s) => {\n-          let name = input.get(s.name);\n-          format!(\"'{}\", name.as_slice())\n+          format!(\"'{}\", get_ident(s))\n       }\n       UNDERSCORE => ~\"_\",\n \n       /* Other */\n-      DOC_COMMENT(ref s) => {\n-          let comment_string = get_ident(s.name);\n-          comment_string.get().to_str()\n-      }\n+      DOC_COMMENT(s) => get_ident(s).get().to_str(),\n       EOF => ~\"<eof>\",\n       INTERPOLATED(ref nt) => {\n         match nt {\n-            &NtExpr(e) => ::print::pprust::expr_to_str(e, input),\n-            &NtAttr(e) => ::print::pprust::attribute_to_str(e, input),\n+            &NtExpr(e) => ::print::pprust::expr_to_str(e),\n+            &NtAttr(e) => ::print::pprust::attribute_to_str(e),\n             _ => {\n                 ~\"an interpolated \" +\n                     match *nt {\n@@ -398,7 +390,7 @@ macro_rules! declare_special_idents_and_keywords {(\n         }\n     }\n \n-    fn mk_fresh_ident_interner() -> @IdentInterner {\n+    fn mk_fresh_ident_interner() -> IdentInterner {\n         // The indices here must correspond to the numbers in\n         // special_idents, in Keyword to_ident(), and in static\n         // constants below.\n@@ -408,92 +400,85 @@ macro_rules! declare_special_idents_and_keywords {(\n             $( $rk_str, )*\n         ];\n \n-        @interner::StrInterner::prefill(init_vec)\n+        interner::StrInterner::prefill(init_vec)\n     }\n }}\n \n // If the special idents get renumbered, remember to modify these two as appropriate\n-static SELF_KEYWORD_NAME: Name = 3;\n-static STATIC_KEYWORD_NAME: Name = 10;\n+static SELF_KEYWORD_NAME: Name = 1;\n+static STATIC_KEYWORD_NAME: Name = 2;\n \n declare_special_idents_and_keywords! {\n     pub mod special_idents {\n         // These ones are statics\n-\n-        (0,                          anon,                   \"anon\");\n-        (1,                          invalid,                \"\");       // ''\n-        (2,                          clownshoes_extensions,  \"__extensions__\");\n-\n-        (super::SELF_KEYWORD_NAME,   self_,                  \"self\"); // 'self'\n+        (0,                          invalid,                \"\");\n+        (super::SELF_KEYWORD_NAME,   self_,                  \"self\");\n+        (super::STATIC_KEYWORD_NAME, statik,                 \"static\");\n \n         // for matcher NTs\n-        (4,                          tt,                     \"tt\");\n-        (5,                          matchers,               \"matchers\");\n+        (3,                          tt,                     \"tt\");\n+        (4,                          matchers,               \"matchers\");\n \n         // outside of libsyntax\n-        (6,                          arg,                    \"arg\");\n-        (7,                          clownshoe_abi,          \"__rust_abi\");\n-        (8,                          main,                   \"main\");\n-        (9,                          opaque,                 \"<opaque>\");\n-        (super::STATIC_KEYWORD_NAME, statik,                 \"static\");\n-        (11,                         clownshoes_foreign_mod, \"__foreign_mod__\");\n-        (12,                         unnamed_field,          \"<unnamed_field>\");\n-        (13,                         type_self,              \"Self\"); // `Self`\n+        (5,                          clownshoe_abi,          \"__rust_abi\");\n+        (6,                          opaque,                 \"<opaque>\");\n+        (7,                          unnamed_field,          \"<unnamed_field>\");\n+        (8,                          type_self,              \"Self\");\n     }\n \n     pub mod keywords {\n         // These ones are variants of the Keyword enum\n \n         'strict:\n-        (14,                         As,         \"as\");\n-        (15,                         Break,      \"break\");\n-        (16,                         Const,      \"const\");\n-        (17,                         Else,       \"else\");\n-        (18,                         Enum,       \"enum\");\n-        (19,                         Extern,     \"extern\");\n-        (20,                         False,      \"false\");\n-        (21,                         Fn,         \"fn\");\n-        (22,                         For,        \"for\");\n-        (23,                         If,         \"if\");\n-        (24,                         Impl,       \"impl\");\n-        (25,                         In,         \"in\");\n-        (26,                         Let,        \"let\");\n-        (27,                         __LogLevel, \"__log_level\");\n-        (28,                         Loop,       \"loop\");\n-        (29,                         Match,      \"match\");\n-        (30,                         Mod,        \"mod\");\n-        (31,                         Crate,      \"crate\");\n-        (32,                         Mut,        \"mut\");\n-        (33,                         Once,       \"once\");\n-        (34,                         Priv,       \"priv\");\n-        (35,                         Pub,        \"pub\");\n-        (36,                         Ref,        \"ref\");\n-        (37,                         Return,     \"return\");\n+        (9,                          As,         \"as\");\n+        (10,                         Break,      \"break\");\n+        (11,                         Const,      \"const\");\n+        (12,                         Crate,      \"crate\");\n+        (13,                         Else,       \"else\");\n+        (14,                         Enum,       \"enum\");\n+        (15,                         Extern,     \"extern\");\n+        (16,                         False,      \"false\");\n+        (17,                         Fn,         \"fn\");\n+        (18,                         For,        \"for\");\n+        (19,                         If,         \"if\");\n+        (20,                         Impl,       \"impl\");\n+        (21,                         In,         \"in\");\n+        (22,                         Let,        \"let\");\n+        (23,                         __LogLevel, \"__log_level\");\n+        (24,                         Loop,       \"loop\");\n+        (25,                         Match,      \"match\");\n+        (26,                         Mod,        \"mod\");\n+        (27,                         Mut,        \"mut\");\n+        (28,                         Once,       \"once\");\n+        (29,                         Priv,       \"priv\");\n+        (30,                         Pub,        \"pub\");\n+        (31,                         Ref,        \"ref\");\n+        (32,                         Return,     \"return\");\n         // Static and Self are also special idents (prefill de-dupes)\n         (super::STATIC_KEYWORD_NAME, Static,     \"static\");\n         (super::SELF_KEYWORD_NAME,   Self,       \"self\");\n-        (38,                         Struct,     \"struct\");\n-        (39,                         Super,      \"super\");\n-        (40,                         True,       \"true\");\n-        (41,                         Trait,      \"trait\");\n-        (42,                         Type,       \"type\");\n-        (43,                         Unsafe,     \"unsafe\");\n-        (44,                         Use,        \"use\");\n-        (45,                         While,      \"while\");\n-        (46,                         Continue,   \"continue\");\n-        (47,                         Proc,       \"proc\");\n-        (48,                         Box,        \"box\");\n+        (33,                         Struct,     \"struct\");\n+        (34,                         Super,      \"super\");\n+        (35,                         True,       \"true\");\n+        (36,                         Trait,      \"trait\");\n+        (37,                         Type,       \"type\");\n+        (38,                         Unsafe,     \"unsafe\");\n+        (39,                         Use,        \"use\");\n+        (40,                         While,      \"while\");\n+        (41,                         Continue,   \"continue\");\n+        (42,                         Proc,       \"proc\");\n+        (43,                         Box,        \"box\");\n \n         'reserved:\n-        (49,                         Alignof,    \"alignof\");\n-        (50,                         Be,         \"be\");\n-        (51,                         Offsetof,   \"offsetof\");\n-        (52,                         Pure,       \"pure\");\n-        (53,                         Sizeof,     \"sizeof\");\n-        (54,                         Typeof,     \"typeof\");\n-        (55,                         Unsized,    \"unsized\");\n-        (56,                         Yield,      \"yield\");\n-        (57,                         Do,         \"do\");\n+        (44,                         Alignof,    \"alignof\");\n+        (45,                         Be,         \"be\");\n+        (46,                         Offsetof,   \"offsetof\");\n+        (47,                         Pure,       \"pure\");\n+        (48,                         Sizeof,     \"sizeof\");\n+        (49,                         Typeof,     \"typeof\");\n+        (50,                         Unsized,    \"unsized\");\n+        (51,                         Yield,      \"yield\");\n+        (52,                         Do,         \"do\");\n     }\n }\n \n@@ -531,12 +516,12 @@ pub type IdentInterner = StrInterner;\n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n pub fn get_ident_interner() -> @IdentInterner {\n-    local_data_key!(key: @@::parse::token::IdentInterner)\n+    local_data_key!(key: @::parse::token::IdentInterner)\n     match local_data::get(key, |k| k.map(|k| *k)) {\n-        Some(interner) => *interner,\n+        Some(interner) => interner,\n         None => {\n-            let interner = mk_fresh_ident_interner();\n-            local_data::set(key, @interner);\n+            let interner = @mk_fresh_ident_interner();\n+            local_data::set(key, interner);\n             interner\n         }\n     }\n@@ -603,8 +588,7 @@ impl<'a> Equiv<&'a str> for InternedString {\n \n impl<D:Decoder> Decodable<D> for InternedString {\n     fn decode(d: &mut D) -> InternedString {\n-        let interner = get_ident_interner();\n-        get_ident(interner.intern(d.read_str()))\n+        get_name(get_ident_interner().intern(d.read_str()))\n     }\n }\n \n@@ -614,54 +598,55 @@ impl<E:Encoder> Encodable<E> for InternedString {\n     }\n }\n \n+/// Returns the string contents of a name, using the task-local interner.\n+#[inline]\n+pub fn get_name(name: Name) -> InternedString {\n+    let interner = get_ident_interner();\n+    InternedString::new_from_rc_str(interner.get(name))\n+}\n+\n /// Returns the string contents of an identifier, using the task-local\n /// interner.\n #[inline]\n-pub fn get_ident(idx: Name) -> InternedString {\n-    let interner = get_ident_interner();\n-    InternedString::new_from_rc_str(interner.get(idx))\n+pub fn get_ident(ident: Ident) -> InternedString {\n+    get_name(ident.name)\n }\n \n /// Interns and returns the string contents of an identifier, using the\n /// task-local interner.\n #[inline]\n pub fn intern_and_get_ident(s: &str) -> InternedString {\n-    get_ident(intern(s))\n-}\n-\n-/* for when we don't care about the contents; doesn't interact with TLD or\n-   serialization */\n-pub fn mk_fake_ident_interner() -> @IdentInterner {\n-    @interner::StrInterner::new()\n+    get_name(intern(s))\n }\n \n-// maps a string to its interned representation\n+/// Maps a string to its interned representation.\n #[inline]\n-pub fn intern(str : &str) -> Name {\n-    let interner = get_ident_interner();\n-    interner.intern(str)\n+pub fn intern(s: &str) -> Name {\n+    get_ident_interner().intern(s)\n }\n \n-// gensyms a new uint, using the current interner\n-pub fn gensym(str : &str) -> Name {\n-    let interner = get_ident_interner();\n-    interner.gensym(str)\n+/// gensym's a new uint, using the current interner.\n+#[inline]\n+pub fn gensym(s: &str) -> Name {\n+    get_ident_interner().gensym(s)\n }\n \n-// maps a string to an identifier with an empty syntax context\n-pub fn str_to_ident(str : &str) -> ast::Ident {\n-    ast::Ident::new(intern(str))\n+/// Maps a string to an identifier with an empty syntax context.\n+#[inline]\n+pub fn str_to_ident(s: &str) -> ast::Ident {\n+    ast::Ident::new(intern(s))\n }\n \n-// maps a string to a gensym'ed identifier\n-pub fn gensym_ident(str : &str) -> ast::Ident {\n-    ast::Ident::new(gensym(str))\n+/// Maps a string to a gensym'ed identifier.\n+#[inline]\n+pub fn gensym_ident(s: &str) -> ast::Ident {\n+    ast::Ident::new(gensym(s))\n }\n \n // create a fresh name that maps to the same string as the old one.\n // note that this guarantees that str_ptr_eq(ident_to_str(src),interner_get(fresh_name(src)));\n // that is, that the new name and the old one are connected to ptr_eq strings.\n-pub fn fresh_name(src : &ast::Ident) -> Name {\n+pub fn fresh_name(src: &ast::Ident) -> Name {\n     let interner = get_ident_interner();\n     interner.gensym_copy(src.name)\n     // following: debug version. Could work in final except that it's incompatible with"}, {"sha": "85bc372b9c61d4dceba56c8073ff2ef582c058bb", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 51, "deletions": 61, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -83,18 +83,15 @@ pub fn end(s: &mut State) -> io::IoResult<()> {\n     pp::end(&mut s.s)\n }\n \n-pub fn rust_printer(writer: ~io::Writer, intr: @IdentInterner) -> State<'static> {\n-    rust_printer_annotated(writer, intr, &NoAnn)\n+pub fn rust_printer(writer: ~io::Writer) -> State<'static> {\n+    rust_printer_annotated(writer, &NoAnn)\n }\n \n-pub fn rust_printer_annotated<'a>(writer: ~io::Writer,\n-                                  intr: @IdentInterner,\n-                                  ann: &'a PpAnn)\n-                                  -> State<'a> {\n+pub fn rust_printer_annotated<'a>(writer: ~io::Writer, ann: &'a PpAnn) -> State<'a> {\n     State {\n         s: pp::mk_printer(writer, default_columns),\n         cm: None,\n-        intr: intr,\n+        intr: token::get_ident_interner(),\n         comments: None,\n         literals: None,\n         cur_cmnt_and_lit: CurrentCommentAndLiteral {\n@@ -114,7 +111,6 @@ pub static default_columns: uint = 78u;\n // it can scan the input text for comments and literals to\n // copy forward.\n pub fn print_crate(cm: @CodeMap,\n-                   intr: @IdentInterner,\n                    span_diagnostic: @diagnostic::SpanHandler,\n                    krate: &ast::Crate,\n                    filename: ~str,\n@@ -130,7 +126,7 @@ pub fn print_crate(cm: @CodeMap,\n     let mut s = State {\n         s: pp::mk_printer(out, default_columns),\n         cm: Some(cm),\n-        intr: intr,\n+        intr: token::get_ident_interner(),\n         comments: Some(cmnts),\n         // If the code is post expansion, don't use the table of\n         // literals, since it doesn't correspond with the literals\n@@ -157,52 +153,51 @@ pub fn print_crate_(s: &mut State, krate: &ast::Crate) -> io::IoResult<()> {\n     Ok(())\n }\n \n-pub fn ty_to_str(ty: &ast::Ty, intr: @IdentInterner) -> ~str {\n-    to_str(ty, print_type, intr)\n+pub fn ty_to_str(ty: &ast::Ty) -> ~str {\n+    to_str(ty, print_type)\n }\n \n-pub fn pat_to_str(pat: &ast::Pat, intr: @IdentInterner) -> ~str {\n-    to_str(pat, print_pat, intr)\n+pub fn pat_to_str(pat: &ast::Pat) -> ~str {\n+    to_str(pat, print_pat)\n }\n \n-pub fn expr_to_str(e: &ast::Expr, intr: @IdentInterner) -> ~str {\n-    to_str(e, print_expr, intr)\n+pub fn expr_to_str(e: &ast::Expr) -> ~str {\n+    to_str(e, print_expr)\n }\n \n-pub fn lifetime_to_str(e: &ast::Lifetime, intr: @IdentInterner) -> ~str {\n-    to_str(e, print_lifetime, intr)\n+pub fn lifetime_to_str(e: &ast::Lifetime) -> ~str {\n+    to_str(e, print_lifetime)\n }\n \n-pub fn tt_to_str(tt: &ast::TokenTree, intr: @IdentInterner) -> ~str {\n-    to_str(tt, print_tt, intr)\n+pub fn tt_to_str(tt: &ast::TokenTree) -> ~str {\n+    to_str(tt, print_tt)\n }\n \n-pub fn tts_to_str(tts: &[ast::TokenTree], intr: @IdentInterner) -> ~str {\n-    to_str(&tts, print_tts, intr)\n+pub fn tts_to_str(tts: &[ast::TokenTree]) -> ~str {\n+    to_str(&tts, print_tts)\n }\n \n-pub fn stmt_to_str(s: &ast::Stmt, intr: @IdentInterner) -> ~str {\n-    to_str(s, print_stmt, intr)\n+pub fn stmt_to_str(s: &ast::Stmt) -> ~str {\n+    to_str(s, print_stmt)\n }\n \n-pub fn item_to_str(i: &ast::Item, intr: @IdentInterner) -> ~str {\n-    to_str(i, print_item, intr)\n+pub fn item_to_str(i: &ast::Item) -> ~str {\n+    to_str(i, print_item)\n }\n \n-pub fn generics_to_str(generics: &ast::Generics,\n-                       intr: @IdentInterner) -> ~str {\n-    to_str(generics, print_generics, intr)\n+pub fn generics_to_str(generics: &ast::Generics) -> ~str {\n+    to_str(generics, print_generics)\n }\n \n-pub fn path_to_str(p: &ast::Path, intr: @IdentInterner) -> ~str {\n-    to_str(p, |a,b| print_path(a, b, false), intr)\n+pub fn path_to_str(p: &ast::Path) -> ~str {\n+    to_str(p, |a,b| print_path(a, b, false))\n }\n \n pub fn fun_to_str(decl: &ast::FnDecl, purity: ast::Purity, name: ast::Ident,\n                   opt_explicit_self: Option<ast::ExplicitSelf_>,\n-                  generics: &ast::Generics, intr: @IdentInterner) -> ~str {\n+                  generics: &ast::Generics) -> ~str {\n     let wr = ~MemWriter::new();\n-    let mut s = rust_printer(wr as ~io::Writer, intr);\n+    let mut s = rust_printer(wr as ~io::Writer);\n     print_fn(&mut s, decl, Some(purity), AbiSet::Rust(),\n              name, generics, opt_explicit_self, ast::Inherited).unwrap();\n     end(&mut s).unwrap(); // Close the head box\n@@ -213,9 +208,9 @@ pub fn fun_to_str(decl: &ast::FnDecl, purity: ast::Purity, name: ast::Ident,\n     }\n }\n \n-pub fn block_to_str(blk: &ast::Block, intr: @IdentInterner) -> ~str {\n+pub fn block_to_str(blk: &ast::Block) -> ~str {\n     let wr = ~MemWriter::new();\n-    let mut s = rust_printer(wr as ~io::Writer, intr);\n+    let mut s = rust_printer(wr as ~io::Writer);\n     // containing cbox, will be closed by print-block at }\n     cbox(&mut s, indent_unit).unwrap();\n     // head-ibox, will be closed by print-block after {\n@@ -227,16 +222,16 @@ pub fn block_to_str(blk: &ast::Block, intr: @IdentInterner) -> ~str {\n     }\n }\n \n-pub fn meta_item_to_str(mi: &ast::MetaItem, intr: @IdentInterner) -> ~str {\n-    to_str(mi, print_meta_item, intr)\n+pub fn meta_item_to_str(mi: &ast::MetaItem) -> ~str {\n+    to_str(mi, print_meta_item)\n }\n \n-pub fn attribute_to_str(attr: &ast::Attribute, intr: @IdentInterner) -> ~str {\n-    to_str(attr, print_attribute, intr)\n+pub fn attribute_to_str(attr: &ast::Attribute) -> ~str {\n+    to_str(attr, print_attribute)\n }\n \n-pub fn variant_to_str(var: &ast::Variant, intr: @IdentInterner) -> ~str {\n-    to_str(var, print_variant, intr)\n+pub fn variant_to_str(var: &ast::Variant) -> ~str {\n+    to_str(var, print_variant)\n }\n \n pub fn cbox(s: &mut State, u: uint) -> io::IoResult<()> {\n@@ -817,7 +812,7 @@ pub fn print_tt(s: &mut State, tt: &ast::TokenTree) -> io::IoResult<()> {\n     match *tt {\n         ast::TTDelim(ref tts) => print_tts(s, &(tts.as_slice())),\n         ast::TTTok(_, ref tk) => {\n-            word(&mut s.s, parse::token::to_str(s.intr, tk))\n+            word(&mut s.s, parse::token::to_str(tk))\n         }\n         ast::TTSeq(_, ref tts, ref sep, zerok) => {\n             if_ok!(word(&mut s.s, \"$(\"));\n@@ -827,7 +822,7 @@ pub fn print_tt(s: &mut State, tt: &ast::TokenTree) -> io::IoResult<()> {\n             if_ok!(word(&mut s.s, \")\"));\n             match *sep {\n                 Some(ref tk) => {\n-                    if_ok!(word(&mut s.s, parse::token::to_str(s.intr, tk)));\n+                    if_ok!(word(&mut s.s, parse::token::to_str(tk)));\n                 }\n                 None => ()\n             }\n@@ -1615,13 +1610,11 @@ pub fn print_decl(s: &mut State, decl: &ast::Decl) -> io::IoResult<()> {\n }\n \n pub fn print_ident(s: &mut State, ident: ast::Ident) -> io::IoResult<()> {\n-    let string = token::get_ident(ident.name);\n-    word(&mut s.s, string.get())\n+    word(&mut s.s, token::get_ident(ident).get())\n }\n \n pub fn print_name(s: &mut State, name: ast::Name) -> io::IoResult<()> {\n-    let string = token::get_ident(name);\n-    word(&mut s.s, string.get())\n+    word(&mut s.s, token::get_name(name).get())\n }\n \n pub fn print_for_decl(s: &mut State, loc: &ast::Local,\n@@ -1692,15 +1685,14 @@ fn print_path_(s: &mut State,\n     Ok(())\n }\n \n-pub fn print_path(s: &mut State, path: &ast::Path,\n-                  colons_before_params: bool) -> io::IoResult<()> {\n+fn print_path(s: &mut State, path: &ast::Path,\n+              colons_before_params: bool) -> io::IoResult<()> {\n     print_path_(s, path, colons_before_params, &None)\n }\n \n-pub fn print_bounded_path(s: &mut State, path: &ast::Path,\n-                          bounds: &Option<OptVec<ast::TyParamBound>>)\n-    -> io::IoResult<()>\n-{\n+fn print_bounded_path(s: &mut State, path: &ast::Path,\n+                      bounds: &Option<OptVec<ast::TyParamBound>>)\n+    -> io::IoResult<()> {\n     print_path_(s, path, false, bounds)\n }\n \n@@ -1818,11 +1810,10 @@ pub fn print_pat(s: &mut State, pat: &ast::Pat) -> io::IoResult<()> {\n     Ok(())\n }\n \n-pub fn explicit_self_to_str(explicit_self: &ast::ExplicitSelf_,\n-                            intr: @IdentInterner) -> ~str {\n+pub fn explicit_self_to_str(explicit_self: &ast::ExplicitSelf_) -> ~str {\n     to_str(explicit_self, |a, &b| {\n         print_explicit_self(a, b, ast::MutImmutable).map(|_| ())\n-    }, intr)\n+    })\n }\n \n // Returns whether it printed anything\n@@ -2346,7 +2337,7 @@ pub fn print_literal(s: &mut State, lit: &ast::Lit) -> io::IoResult<()> {\n }\n \n pub fn lit_to_str(l: &ast::Lit) -> ~str {\n-    return to_str(l, print_literal, parse::token::mk_fake_ident_interner());\n+    to_str(l, print_literal)\n }\n \n pub fn next_lit(s: &mut State, pos: BytePos) -> Option<comments::Literal> {\n@@ -2450,10 +2441,9 @@ unsafe fn get_mem_writer(writer: &mut ~io::Writer) -> ~str {\n     result\n }\n \n-pub fn to_str<T>(t: &T, f: |&mut State, &T| -> io::IoResult<()>,\n-                 intr: @IdentInterner) -> ~str {\n+pub fn to_str<T>(t: &T, f: |&mut State, &T| -> io::IoResult<()>) -> ~str {\n     let wr = ~MemWriter::new();\n-    let mut s = rust_printer(wr as ~io::Writer, intr);\n+    let mut s = rust_printer(wr as ~io::Writer);\n     f(&mut s, t).unwrap();\n     eof(&mut s.s).unwrap();\n     unsafe {\n@@ -2600,7 +2590,7 @@ mod test {\n         };\n         let generics = ast_util::empty_generics();\n         assert_eq!(&fun_to_str(&decl, ast::ImpureFn, abba_ident,\n-                               None, &generics, token::get_ident_interner()),\n+                               None, &generics),\n                    &~\"fn abba()\");\n     }\n \n@@ -2618,7 +2608,7 @@ mod test {\n             vis: ast::Public,\n         });\n \n-        let varstr = variant_to_str(&var,token::get_ident_interner());\n+        let varstr = variant_to_str(&var);\n         assert_eq!(&varstr,&~\"pub principal_skinner\");\n     }\n }"}, {"sha": "aedff2d7854923b7d163073158299815b62c3189", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -21,16 +21,16 @@ use std::hashmap::HashMap;\n use std::rc::Rc;\n \n pub struct Interner<T> {\n-    priv map: @RefCell<HashMap<T, Name>>,\n-    priv vect: @RefCell<~[T]>,\n+    priv map: RefCell<HashMap<T, Name>>,\n+    priv vect: RefCell<~[T]>,\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n-            map: @RefCell::new(HashMap::new()),\n-            vect: @RefCell::new(~[]),\n+            map: RefCell::new(HashMap::new()),\n+            vect: RefCell::new(~[]),\n         }\n     }\n \n@@ -123,18 +123,18 @@ impl RcStr {\n }\n \n // A StrInterner differs from Interner<String> in that it accepts\n-// references rather than @ ones, resulting in less allocation.\n+// &str rather than RcStr, resulting in less allocation.\n pub struct StrInterner {\n-    priv map: @RefCell<HashMap<RcStr, Name>>,\n-    priv vect: @RefCell<~[RcStr]>,\n+    priv map: RefCell<HashMap<RcStr, Name>>,\n+    priv vect: RefCell<~[RcStr]>,\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n impl StrInterner {\n     pub fn new() -> StrInterner {\n         StrInterner {\n-            map: @RefCell::new(HashMap::new()),\n-            vect: @RefCell::new(~[]),\n+            map: RefCell::new(HashMap::new()),\n+            vect: RefCell::new(~[]),\n         }\n     }\n "}, {"sha": "ce87c3d7591f52c5e6780cd95e2f199e5be3ca7a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -43,7 +43,7 @@ pub enum FnKind<'a> {\n pub fn name_of_fn(fk: &FnKind) -> Ident {\n     match *fk {\n         FkItemFn(name, _, _, _) | FkMethod(name, _, _) => name,\n-        FkFnBlock(..) => parse::token::special_idents::anon\n+        FkFnBlock(..) => parse::token::special_idents::invalid\n     }\n }\n "}, {"sha": "ca1e0293f8ee7ad07ceb5ff6e71d3c429da42b88", "filename": "src/test/compile-fail/ambig_impl_2_exe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -15,6 +15,6 @@ use ambig_impl_2_lib::me;\n trait me {\n     fn me(&self) -> uint;\n }\n-impl me for uint { fn me(&self) -> uint { *self } } //~ NOTE is `me$uint::me`\n+impl me for uint { fn me(&self) -> uint { *self } } //~ NOTE is `uint.me::me`\n fn main() { 1u.me(); } //~ ERROR multiple applicable methods in scope\n-//~^ NOTE is `ambig_impl_2_lib::me$uint::me`\n+//~^ NOTE is `ambig_impl_2_lib::uint.me::me`"}, {"sha": "1327f69630b1bc3e4df18cd7f4035075539c6be6", "filename": "src/test/compile-fail/ambig_impl_unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe7bfe4d2de9942449d3656317e66bc9ec50204/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs?ref=2fe7bfe4d2de9942449d3656317e66bc9ec50204", "patch": "@@ -13,11 +13,11 @@ trait foo {\n }\n \n impl foo for ~[uint] {\n-    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `foo$$UP$$VEC$uint::foo`\n+    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `~[uint].foo::foo`\n }\n \n impl foo for ~[int] {\n-    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `foo$$UP$$VEC$int::foo`\n+    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `~[int].foo::foo`\n }\n \n fn main() {"}]}