{"sha": "34329d6f6c73a6f0080e169007d099a40db3aea1", "node_id": "C_kwDOAAsO6NoAKDM0MzI5ZDZmNmM3M2E2ZjAwODBlMTY5MDA3ZDA5OWE0MGRiM2FlYTE", "commit": {"author": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2022-10-29T13:19:57Z"}, "committer": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2023-01-07T10:38:38Z"}, "message": "introduce AstConv::probe_adt", "tree": {"sha": "f07cb5c8012a1329a2e6e860b606a599f59d7068", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f07cb5c8012a1329a2e6e860b606a599f59d7068"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34329d6f6c73a6f0080e169007d099a40db3aea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34329d6f6c73a6f0080e169007d099a40db3aea1", "html_url": "https://github.com/rust-lang/rust/commit/34329d6f6c73a6f0080e169007d099a40db3aea1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34329d6f6c73a6f0080e169007d099a40db3aea1/comments", "author": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d227506683e846cbeb872e089d660187a7a6041f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d227506683e846cbeb872e089d660187a7a6041f", "html_url": "https://github.com/rust-lang/rust/commit/d227506683e846cbeb872e089d660187a7a6041f"}], "stats": {"total": 57, "additions": 38, "deletions": 19}, "files": [{"sha": "df6600626a30bd73f473d9fa62f9d041ca9de726", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/34329d6f6c73a6f0080e169007d099a40db3aea1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34329d6f6c73a6f0080e169007d099a40db3aea1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=34329d6f6c73a6f0080e169007d099a40db3aea1", "patch": "@@ -106,9 +106,12 @@ pub trait AstConv<'tcx> {\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx>;\n \n-    fn normalize_ty_2(&self, _span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        ty\n-    }\n+    /// Returns `AdtDef` if `ty` is an ADT.\n+    /// Note that `ty` might be a projection type that needs normalization.\n+    /// This used to get the enum variants in scope of the type.\n+    /// For example, `Self::A` could refer to an associated type\n+    /// or to an enum variant depending on the result of this function.\n+    fn probe_adt(&self, span: Span, ty: Ty<'tcx>) -> Option<ty::AdtDef<'tcx>>;\n \n     /// Invoked when we encounter an error from some prior pass\n     /// (e.g., resolve) that is translated into a ty-error. This is\n@@ -1805,7 +1808,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Check if we have an enum variant.\n         let mut variant_resolution = None;\n-        if let ty::Adt(adt_def, adt_substs) = self.normalize_ty_2(span, qself_ty).kind() {\n+        if let Some(adt_def) = self.probe_adt(span, qself_ty) {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def\n                     .variants()\n@@ -1907,6 +1910,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let Some(assoc_ty_did) = self.lookup_assoc_ty(assoc_ident, hir_ref_id, span, impl_) else {\n                     continue;\n                 };\n+                let ty::Adt(_, adt_substs) = qself_ty.kind() else {\n+                    // FIXME(inherent_associated_types)\n+                    bug!(\"unimplemented: non-adt self of inherent assoc ty\");\n+                };\n                 let item_substs = self.create_substs_for_associated_item(\n                     span,\n                     assoc_ty_did,\n@@ -2262,6 +2269,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Option<Ty<'tcx>>,\n         kind: DefKind,\n         def_id: DefId,\n+        span: Span,\n     ) -> Vec<PathSeg> {\n         // We need to extract the type parameters supplied by the user in\n         // the path `path`. Due to the current setup, this is a bit of a\n@@ -2329,8 +2337,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             // Case 2. Reference to a variant constructor.\n             DefKind::Ctor(CtorOf::Variant, ..) | DefKind::Variant => {\n-                let adt_def = self_ty.map(|t| t.ty_adt_def().unwrap());\n-                let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n+                let (generics_def_id, index) = if let Some(self_ty) = self_ty {\n+                    let adt_def = self.probe_adt(span, self_ty).unwrap();\n                     debug_assert!(adt_def.is_enum());\n                     (adt_def.did(), last)\n                 } else if last >= 1 && segments[last - 1].args.is_some() {\n@@ -2426,7 +2434,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 assert_eq!(opt_self_ty, None);\n \n                 let path_segs =\n-                    self.def_ids_for_value_path_segments(path.segments, None, kind, def_id);\n+                    self.def_ids_for_value_path_segments(path.segments, None, kind, def_id, span);\n                 let generic_segs: FxHashSet<_> =\n                     path_segs.iter().map(|PathSeg(_, index)| index).collect();\n                 self.prohibit_generics("}, {"sha": "b7f259668a1e48f005761958a12947e6986d77ea", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34329d6f6c73a6f0080e169007d099a40db3aea1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34329d6f6c73a6f0080e169007d099a40db3aea1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=34329d6f6c73a6f0080e169007d099a40db3aea1", "patch": "@@ -505,6 +505,11 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         }\n     }\n \n+    fn probe_adt(&self, _span: Span, ty: Ty<'tcx>) -> Option<ty::AdtDef<'tcx>> {\n+        // FIXME(#103640): Should we handle the case where `ty` is a projection?\n+        ty.ty_adt_def()\n+    }\n+\n     fn set_tainted_by_errors(&self, _: ErrorGuaranteed) {\n         // There's no obvious place to track this, so just let it go.\n     }"}, {"sha": "6c2dfaf4413be48fe0bf554f4705f831ec1cc9ff", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/34329d6f6c73a6f0080e169007d099a40db3aea1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34329d6f6c73a6f0080e169007d099a40db3aea1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=34329d6f6c73a6f0080e169007d099a40db3aea1", "patch": "@@ -1007,9 +1007,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Res::Def(kind, def_id) => <dyn AstConv<'_>>::def_ids_for_value_path_segments(\n                 self,\n                 segments,\n-                self_ty.map(|ty| ty.normalized),\n+                self_ty.map(|ty| ty.raw),\n                 kind,\n                 def_id,\n+                span,\n             ),\n             _ => bug!(\"instantiate_value_path on {:?}\", res),\n         };\n@@ -1122,7 +1123,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .unwrap_or(false);\n \n         let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n-            let ty = self.normalize_ty_2(span, tcx.at(span).type_of(impl_def_id));\n+            let ty = tcx.at(span).type_of(impl_def_id);\n+            let ty = self.normalize(span, ty);\n             match *ty.kind() {\n                 ty::Adt(adt_def, substs) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n@@ -1238,10 +1240,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // If we have a default, then we it doesn't matter that we're not\n                             // inferring the type arguments: we provide the default where any\n                             // is missing.\n-                            let default = tcx.bound_type_of(param.def_id);\n-                            self.fcx\n-                                .normalize_ty_2(self.span, default.subst(tcx, substs.unwrap()))\n-                                .into()\n+                            let default =\n+                                tcx.bound_type_of(param.def_id).subst(tcx, substs.unwrap());\n+                            self.fcx.normalize(self.span, default).into()\n                         } else {\n                             // If no type arguments were provided, we have to infer them.\n                             // This case also occurs as a result of some malformed input, e.g."}, {"sha": "6347b9a69a0077906a78c12b1f1cce0be753ba85", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/34329d6f6c73a6f0080e169007d099a40db3aea1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34329d6f6c73a6f0080e169007d099a40db3aea1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=34329d6f6c73a6f0080e169007d099a40db3aea1", "patch": "@@ -297,11 +297,14 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         self.tcx().mk_projection(item_def_id, item_substs)\n     }\n \n-    fn normalize_ty_2(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.has_escaping_bound_vars() {\n-            ty // FIXME: normalization and escaping regions\n-        } else {\n-            self.normalize(span, ty)\n+    fn probe_adt(&self, span: Span, ty: Ty<'tcx>) -> Option<ty::AdtDef<'tcx>> {\n+        match ty.kind() {\n+            ty::Adt(adt_def, _) => Some(*adt_def),\n+            // FIXME(#104767): Should we handle bound regions here?\n+            ty::Alias(ty::Projection, _) if !ty.has_escaping_bound_vars() => {\n+                self.normalize(span, ty).ty_adt_def()\n+            }\n+            _ => None,\n         }\n     }\n \n@@ -310,7 +313,9 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n \n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span) {\n-        self.write_ty(hir_id, self.normalize_ty_2(span, ty))\n+        // FIXME: normalization and escaping regions\n+        let ty = if !ty.has_escaping_bound_vars() { self.normalize(span, ty) } else { ty };\n+        self.write_ty(hir_id, ty)\n     }\n }\n "}]}