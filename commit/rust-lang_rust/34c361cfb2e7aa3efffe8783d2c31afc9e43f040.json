{"sha": "34c361cfb2e7aa3efffe8783d2c31afc9e43f040", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YzM2MWNmYjJlN2FhM2VmZmZlODc4M2QyYzMxYWZjOWU0M2YwNDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-11T23:22:41Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-17T18:44:21Z"}, "message": "when creating an AssociatedItem, read data from impl, not impl item\n\nBefore, when we created an AssociatedItem for impl item X, we would read\nthe impl item itself. Now we instead load up the impl I that contains X\nand read the data from the `ImplItemRef` for X; actually, we do it for\nall impl items in I pre-emptively.\n\nThis kills the last source of edges between a method X and a call to a\nmethod Y defined in the same impl.\n\nFixes #37121", "tree": {"sha": "c58d14fb7887fd565ccc152d22d7f7e65a40c36b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c58d14fb7887fd565ccc152d22d7f7e65a40c36b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34c361cfb2e7aa3efffe8783d2c31afc9e43f040", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34c361cfb2e7aa3efffe8783d2c31afc9e43f040", "html_url": "https://github.com/rust-lang/rust/commit/34c361cfb2e7aa3efffe8783d2c31afc9e43f040", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "629f5ffb23aeb96621bb4da7f7ea6d605670056b", "url": "https://api.github.com/repos/rust-lang/rust/commits/629f5ffb23aeb96621bb4da7f7ea6d605670056b", "html_url": "https://github.com/rust-lang/rust/commit/629f5ffb23aeb96621bb4da7f7ea6d605670056b"}], "stats": {"total": 219, "additions": 129, "deletions": 90}, "files": [{"sha": "feefc43f4013e682af3628f86cb1353ae81f0397", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=34c361cfb2e7aa3efffe8783d2c31afc9e43f040", "patch": "@@ -106,7 +106,7 @@ pub type DefMap = NodeMap<PathResolution>;\n // within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Export {\n     pub name: ast::Name, // The name of the target.\n     pub def: Def, // The definition of the target."}, {"sha": "ac2f3ad9b899b0f294b92722f3d7bb41ec1f6246", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=34c361cfb2e7aa3efffe8783d2c31afc9e43f040", "patch": "@@ -1007,8 +1007,9 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                     // types, which appear not to unify -- so the\n                     // overlap check succeeds, when it should\n                     // fail.\n-                    bug!(\"Tried to project an inherited associated type during \\\n-                          coherence checking, which is currently not supported.\");\n+                    span_bug!(obligation.cause.span,\n+                              \"Tried to project an inherited associated type during \\\n+                               coherence checking, which is currently not supported.\");\n                 };\n                 candidate_set.vec.extend(new_candidate);\n             }"}, {"sha": "9984dd42f566b6bbe3461362cadf11a38d3d955a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 105, "deletions": 60, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=34c361cfb2e7aa3efffe8783d2c31afc9e43f040", "patch": "@@ -2113,69 +2113,111 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                            .expect(\"missing AssociatedItem in metadata\");\n             }\n \n+            // When the user asks for a given associated item, we\n+            // always go ahead and convert all the associated items in\n+            // the container. Note that we are also careful only to\n+            // ever register a read on the *container* of the assoc\n+            // item, not the assoc item itself. This prevents changes\n+            // in the details of an item (for example, the type to\n+            // which an associated type is bound) from contaminating\n+            // those tasks that just need to scan the names of items\n+            // and so forth.\n+\n             let id = self.map.as_local_node_id(def_id).unwrap();\n             let parent_id = self.map.get_parent(id);\n             let parent_def_id = self.map.local_def_id(parent_id);\n-            match self.map.get(id) {\n-                ast_map::NodeTraitItem(trait_item) => {\n-                    let (kind, has_self, has_value) = match trait_item.node {\n-                        hir::MethodTraitItem(ref sig, ref body) => {\n-                            (AssociatedKind::Method, sig.decl.get_self().is_some(),\n-                             body.is_some())\n-                        }\n-                        hir::ConstTraitItem(_, ref value) => {\n-                            (AssociatedKind::Const, false, value.is_some())\n-                        }\n-                        hir::TypeTraitItem(_, ref ty) => {\n-                            (AssociatedKind::Type, false, ty.is_some())\n-                        }\n-                    };\n-\n-                    AssociatedItem {\n-                        name: trait_item.name,\n-                        kind: kind,\n-                        vis: Visibility::from_hir(&hir::Inherited, id, self),\n-                        defaultness: hir::Defaultness::Default,\n-                        has_value: has_value,\n-                        def_id: def_id,\n-                        container: TraitContainer(parent_def_id),\n-                        method_has_self_argument: has_self\n+            let parent_item = self.map.expect_item(parent_id);\n+            match parent_item.node {\n+                hir::ItemImpl(.., ref impl_trait_ref, _, ref impl_item_refs) => {\n+                    for impl_item_ref in impl_item_refs {\n+                        let assoc_item =\n+                            self.associated_item_from_impl_item_ref(parent_def_id,\n+                                                                    impl_trait_ref.is_some(),\n+                                                                    impl_item_ref);\n+                        self.associated_items.borrow_mut().insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n-                ast_map::NodeImplItem(impl_item) => {\n-                    let (kind, has_self) = match impl_item.node {\n-                        hir::ImplItemKind::Method(ref sig, _) => {\n-                            (AssociatedKind::Method, sig.decl.get_self().is_some())\n-                        }\n-                        hir::ImplItemKind::Const(..) => (AssociatedKind::Const, false),\n-                        hir::ImplItemKind::Type(..) => (AssociatedKind::Type, false)\n-                    };\n-\n-                    // Trait impl items are always public.\n-                    let public = hir::Public;\n-                    let parent_item = self.map.expect_item(parent_id);\n-                    let vis = if let hir::ItemImpl(.., Some(_), _, _) = parent_item.node {\n-                        &public\n-                    } else {\n-                        &impl_item.vis\n-                    };\n-\n-                    AssociatedItem {\n-                        name: impl_item.name,\n-                        kind: kind,\n-                        vis: Visibility::from_hir(vis, id, self),\n-                        defaultness: impl_item.defaultness,\n-                        has_value: true,\n-                        def_id: def_id,\n-                        container: ImplContainer(parent_def_id),\n-                        method_has_self_argument: has_self\n+\n+                hir::ItemTrait(.., ref trait_items) => {\n+                    for trait_item in trait_items {\n+                        let assoc_item =\n+                            self.associated_item_from_trait_item_ref(parent_def_id, trait_item);\n+                        self.associated_items.borrow_mut().insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n-                item => bug!(\"associated_item: {:?} not an associated item\", item)\n+\n+                ref r => {\n+                    panic!(\"unexpected container of associated items: {:?}\", r)\n+                }\n             }\n+\n+            // memoize wants us to return something, so return\n+            // the one we generated for this def-id\n+            *self.associated_items.borrow().get(&def_id).unwrap()\n         })\n     }\n \n+    fn associated_item_from_trait_item_ref(self,\n+                                           parent_def_id: DefId,\n+                                           trait_item: &hir::TraitItem)\n+                                           -> AssociatedItem {\n+        let def_id = self.map.local_def_id(trait_item.id);\n+\n+        let (kind, has_self, has_value) = match trait_item.node {\n+            hir::MethodTraitItem(ref sig, ref body) => {\n+                (AssociatedKind::Method, sig.decl.get_self().is_some(),\n+                 body.is_some())\n+            }\n+            hir::ConstTraitItem(_, ref value) => {\n+                (AssociatedKind::Const, false, value.is_some())\n+            }\n+            hir::TypeTraitItem(_, ref ty) => {\n+                (AssociatedKind::Type, false, ty.is_some())\n+            }\n+        };\n+\n+        AssociatedItem {\n+            name: trait_item.name,\n+            kind: kind,\n+            vis: Visibility::from_hir(&hir::Inherited, trait_item.id, self),\n+            defaultness: hir::Defaultness::Default,\n+            has_value: has_value,\n+            def_id: def_id,\n+            container: TraitContainer(parent_def_id),\n+            method_has_self_argument: has_self\n+        }\n+    }\n+\n+    fn associated_item_from_impl_item_ref(self,\n+                                          parent_def_id: DefId,\n+                                          from_trait_impl: bool,\n+                                          impl_item_ref: &hir::ImplItemRef)\n+                                          -> AssociatedItem {\n+        let def_id = self.map.local_def_id(impl_item_ref.id.node_id);\n+        let (kind, has_self) = match impl_item_ref.kind {\n+            hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n+            hir::AssociatedItemKind::Method { has_self } => {\n+                (ty::AssociatedKind::Method, has_self)\n+            }\n+            hir::AssociatedItemKind::Type => (ty::AssociatedKind::Type, false),\n+        };\n+\n+        // Trait impl items are always public.\n+        let public = hir::Public;\n+        let vis = if from_trait_impl { &public } else { &impl_item_ref.vis };\n+\n+        ty::AssociatedItem {\n+            name: impl_item_ref.name,\n+            kind: kind,\n+            vis: ty::Visibility::from_hir(vis, impl_item_ref.id.node_id, self),\n+            defaultness: impl_item_ref.defaultness,\n+            has_value: true,\n+            def_id: def_id,\n+            container: ImplContainer(parent_def_id),\n+            method_has_self_argument: has_self\n+        }\n+    }\n+\n     pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n         self.associated_item_def_ids.memoize(def_id, || {\n             if !def_id.is_local() {\n@@ -2184,19 +2226,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             let id = self.map.as_local_node_id(def_id).unwrap();\n             let item = self.map.expect_item(id);\n-            match item.node {\n+            let vec: Vec<_> = match item.node {\n                 hir::ItemTrait(.., ref trait_items) => {\n-                    Rc::new(trait_items.iter().map(|trait_item| {\n-                        self.map.local_def_id(trait_item.id)\n-                    }).collect())\n+                    trait_items.iter()\n+                               .map(|trait_item| trait_item.id)\n+                               .map(|id| self.map.local_def_id(id))\n+                               .collect()\n                 }\n                 hir::ItemImpl(.., ref impl_item_refs) => {\n-                    Rc::new(impl_item_refs.iter().map(|impl_item_ref| {\n-                        self.map.local_def_id(impl_item_ref.id.node_id)\n-                    }).collect())\n+                    impl_item_refs.iter()\n+                                  .map(|impl_item_ref| impl_item_ref.id)\n+                                  .map(|id| self.map.local_def_id(id.node_id))\n+                                  .collect()\n                 }\n                 _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")\n-            }\n+            };\n+            Rc::new(vec)\n         })\n     }\n "}, {"sha": "535b6bcdcba177dff99ac1d7429bbbcc54cbfaf9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=34c361cfb2e7aa3efffe8783d2c31afc9e43f040", "patch": "@@ -731,11 +731,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                       ref generics,\n                       ref opt_trait_ref,\n                       ref selfty,\n-                      ref _impl_item_ids /* [1] */) => {\n-            // [1]: We really don't want to be inspecting the details\n-            // of impl-items here; it creates bad edges in the\n-            // incr. comp. graph.\n-\n+                      _) => {\n             // Create generics from the generics specified in the impl head.\n             debug!(\"convert: ast_generics={:?}\", generics);\n             let def_id = ccx.tcx.map.local_def_id(it.id);"}, {"sha": "939fd6ccfc88e0e6f337d4fe04a4cc03d867f31e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=34c361cfb2e7aa3efffe8783d2c31afc9e43f040", "patch": "@@ -507,15 +507,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // regardless of where they're located.\n                 if !self.inlining {\n                     let items = item_ids.iter()\n-                                        .map(|&id| self.cx.map.impl_item(id).clone())\n+                                        .map(|ii| self.cx.map.impl_item(ii.id).clone())\n                                         .collect();\n                     let i = Impl {\n                         unsafety: unsafety,\n                         polarity: polarity,\n                         generics: gen.clone(),\n                         trait_: tr.clone(),\n                         for_: ty.clone(),\n-                        items: items.clone(),\n+                        items: items,\n                         attrs: item.attrs.clone(),\n                         id: item.id,\n                         whence: item.span,"}, {"sha": "46e5a88eef9402fc9f1c9a4428bf3999f2e639f1", "filename": "src/test/incremental/change_private_impl_method/struct_point.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs?ref=34c361cfb2e7aa3efffe8783d2c31afc9e43f040", "patch": "@@ -20,9 +20,8 @@\n \n #![rustc_partition_translated(module=\"struct_point-point\", cfg=\"rpass2\")]\n \n-// FIXME(#37121) -- the following two modules *should* be reused but are not\n-#![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n@@ -60,8 +59,7 @@ mod point {\n mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    // FIXME(#37121) -- we should not need to typeck this again\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -72,8 +70,7 @@ mod fn_calls_methods_in_same_impl {\n mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    // FIXME(#37121) -- we should not need to typeck this again\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn check() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);"}, {"sha": "a8779e3f92d9a7ecd81bb868a0c60877da81b3a7", "filename": "src/test/incremental/change_private_impl_method_cc/struct_point.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c361cfb2e7aa3efffe8783d2c31afc9e43f040/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs?ref=34c361cfb2e7aa3efffe8783d2c31afc9e43f040", "patch": "@@ -19,20 +19,23 @@\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]\n \n-// FIXME(#37333) -- the following modules *should* be reused but are not\n+#![rustc_partition_reused(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n+\n+// FIXME(#37333) the struct fields get entangled with inherent methods\n+#![rustc_partition_translated(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n+\n+// FIXME(#37720) these two should be reused, but data gets entangled across crates\n #![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n #![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n \n extern crate point;\n \n /// A fn item that calls (public) methods on `Point` from the same impl which changed\n mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    // FIXME(#37333) -- we should not need to typeck this again\n+    // FIXME(#37720) data gets entangled across crates\n     #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n@@ -44,9 +47,9 @@ mod fn_calls_methods_in_same_impl {\n mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    // FIXME(#37333) -- we should not need to typeck this again\n+    // FIXME(#37720) data gets entangled across crates\n     #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n-    pub fn check() {\n+    pub fn dirty() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);\n     }\n@@ -56,8 +59,7 @@ mod fn_calls_methods_in_another_impl {\n mod fn_make_struct {\n     use point::Point;\n \n-    // FIXME(#37333) -- we should not need to typeck this again\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -67,8 +69,7 @@ mod fn_make_struct {\n mod fn_read_field {\n     use point::Point;\n \n-    // FIXME(#37333) -- we should not need to typeck this again\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -78,8 +79,7 @@ mod fn_read_field {\n mod fn_write_field {\n     use point::Point;\n \n-    // FIXME(#37333) -- we should not need to typeck this again\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}]}