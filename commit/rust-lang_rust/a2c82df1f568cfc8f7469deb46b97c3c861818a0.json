{"sha": "a2c82df1f568cfc8f7469deb46b97c3c861818a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYzgyZGYxZjU2OGNmYzhmNzQ2OWRlYjQ2Yjk3YzNjODYxODE4YTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-19T02:21:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-19T02:21:19Z"}, "message": "Auto merge of #76838 - est31:dogfood_uninit_features, r=oli-obk\n\nDogfood new_uninit and maybe_uninit_slice in rustc_arena\n\nDogfoods a few cool `MaybeUninit` related features in the compiler's rustc_arena crate.\n\nSplit off from #76821\n\nr? `@oli-obk`", "tree": {"sha": "001bd7e9294c5f4f98e1eb8fd4702fa829cab409", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/001bd7e9294c5f4f98e1eb8fd4702fa829cab409"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2c82df1f568cfc8f7469deb46b97c3c861818a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c82df1f568cfc8f7469deb46b97c3c861818a0", "html_url": "https://github.com/rust-lang/rust/commit/a2c82df1f568cfc8f7469deb46b97c3c861818a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2c82df1f568cfc8f7469deb46b97c3c861818a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6ab8e5fe0a837e06ae53bfa962e844d220ccf38", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ab8e5fe0a837e06ae53bfa962e844d220ccf38", "html_url": "https://github.com/rust-lang/rust/commit/c6ab8e5fe0a837e06ae53bfa962e844d220ccf38"}, {"sha": "2805a0515461d6f70f7d4a6c1f5491dbed5d61b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2805a0515461d6f70f7d4a6c1f5491dbed5d61b8", "html_url": "https://github.com/rust-lang/rust/commit/2805a0515461d6f70f7d4a6c1f5491dbed5d61b8"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "0d0b1efd2de18589b29fa10497006018ecc7d76d", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a2c82df1f568cfc8f7469deb46b97c3c861818a0/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c82df1f568cfc8f7469deb46b97c3c861818a0/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=a2c82df1f568cfc8f7469deb46b97c3c861818a0", "patch": "@@ -13,12 +13,11 @@\n )]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![feature(raw_vec_internals)]\n+#![feature(new_uninit)]\n+#![feature(maybe_uninit_slice)]\n #![cfg_attr(test, feature(test))]\n #![allow(deprecated)]\n \n-extern crate alloc;\n-\n use rustc_data_structures::cold_path;\n use smallvec::SmallVec;\n \n@@ -27,12 +26,10 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::intrinsics;\n use std::marker::{PhantomData, Send};\n-use std::mem;\n+use std::mem::{self, MaybeUninit};\n use std::ptr;\n use std::slice;\n \n-use alloc::raw_vec::RawVec;\n-\n /// An arena that can hold objects of only one type.\n pub struct TypedArena<T> {\n     /// A pointer to the next object to be allocated.\n@@ -52,15 +49,15 @@ pub struct TypedArena<T> {\n \n struct TypedArenaChunk<T> {\n     /// The raw storage for the arena chunk.\n-    storage: RawVec<T>,\n+    storage: Box<[MaybeUninit<T>]>,\n     /// The number of valid entries in the chunk.\n     entries: usize,\n }\n \n impl<T> TypedArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n-        TypedArenaChunk { storage: RawVec::with_capacity(capacity), entries: 0 }\n+        TypedArenaChunk { storage: Box::new_uninit_slice(capacity), entries: 0 }\n     }\n \n     /// Destroys this arena chunk.\n@@ -69,30 +66,25 @@ impl<T> TypedArenaChunk<T> {\n         // The branch on needs_drop() is an -O1 performance optimization.\n         // Without the branch, dropping TypedArena<u8> takes linear time.\n         if mem::needs_drop::<T>() {\n-            let mut start = self.start();\n-            // Destroy all allocated objects.\n-            for _ in 0..len {\n-                ptr::drop_in_place(start);\n-                start = start.offset(1);\n-            }\n+            ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut self.storage[..len]));\n         }\n     }\n \n     // Returns a pointer to the first allocated object.\n     #[inline]\n-    fn start(&self) -> *mut T {\n-        self.storage.ptr()\n+    fn start(&mut self) -> *mut T {\n+        MaybeUninit::slice_as_mut_ptr(&mut self.storage)\n     }\n \n     // Returns a pointer to the end of the allocated space.\n     #[inline]\n-    fn end(&self) -> *mut T {\n+    fn end(&mut self) -> *mut T {\n         unsafe {\n             if mem::size_of::<T>() == 0 {\n                 // A pointer as large as possible for zero-sized elements.\n                 !0 as *mut T\n             } else {\n-                self.start().add(self.storage.capacity())\n+                self.start().add(self.storage.len())\n             }\n         }\n     }\n@@ -226,10 +218,10 @@ impl<T> TypedArena<T> {\n                 let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n                 last_chunk.entries = used_bytes / mem::size_of::<T>();\n \n-                // If the previous chunk's capacity is less than HUGE_PAGE\n+                // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = last_chunk.storage.capacity();\n+                new_cap = last_chunk.storage.len();\n                 if new_cap < HUGE_PAGE / elem_size {\n                     new_cap = new_cap.checked_mul(2).unwrap();\n                 }\n@@ -239,7 +231,7 @@ impl<T> TypedArena<T> {\n             // Also ensure that this chunk can fit `additional`.\n             new_cap = cmp::max(additional, new_cap);\n \n-            let chunk = TypedArenaChunk::<T>::new(new_cap);\n+            let mut chunk = TypedArenaChunk::<T>::new(new_cap);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());\n             chunks.push(chunk);\n@@ -301,7 +293,7 @@ unsafe impl<#[may_dangle] T> Drop for TypedArena<T> {\n                     chunk.destroy(chunk.entries);\n                 }\n             }\n-            // RawVec handles deallocation of `last_chunk` and `self.chunks`.\n+            // Box handles deallocation of `last_chunk` and `self.chunks`.\n         }\n     }\n }\n@@ -344,10 +336,10 @@ impl DroplessArena {\n                 // There is no need to update `last_chunk.entries` because that\n                 // field isn't used by `DroplessArena`.\n \n-                // If the previous chunk's capacity is less than HUGE_PAGE\n+                // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = last_chunk.storage.capacity();\n+                new_cap = last_chunk.storage.len();\n                 if new_cap < HUGE_PAGE {\n                     new_cap = new_cap.checked_mul(2).unwrap();\n                 }\n@@ -357,7 +349,7 @@ impl DroplessArena {\n             // Also ensure that this chunk can fit `additional`.\n             new_cap = cmp::max(additional, new_cap);\n \n-            let chunk = TypedArenaChunk::<u8>::new(new_cap);\n+            let mut chunk = TypedArenaChunk::<u8>::new(new_cap);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());\n             chunks.push(chunk);"}, {"sha": "e8a1f2db1a16b029b380b4f0004306f0ab43ac63", "filename": "compiler/rustc_arena/src/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2c82df1f568cfc8f7469deb46b97c3c861818a0/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c82df1f568cfc8f7469deb46b97c3c861818a0/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Ftests.rs?ref=a2c82df1f568cfc8f7469deb46b97c3c861818a0", "patch": "@@ -121,6 +121,17 @@ pub fn bench_typed_arena_clear(b: &mut Bencher) {\n     })\n }\n \n+#[bench]\n+pub fn bench_typed_arena_clear_100(b: &mut Bencher) {\n+    let mut arena = TypedArena::default();\n+    b.iter(|| {\n+        for _ in 0..100 {\n+            arena.alloc(Point { x: 1, y: 2, z: 3 });\n+        }\n+        arena.clear();\n+    })\n+}\n+\n // Drop tests\n \n struct DropCounter<'a> {"}]}