{"sha": "4780ac0f02979d397fcc8a87135fdea2d566010c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ODBhYzBmMDI5NzlkMzk3ZmNjOGE4NzEzNWZkZWEyZDU2NjAxMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T12:56:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T12:56:14Z"}, "message": "Auto merge of #4857 - rust-lang:rustup, r=matthewjasper,oli-obk\n\nRustup\n\nFrom https://github.com/rust-lang/rust/pull/66246/\n\nchangelog: none", "tree": {"sha": "f42911d08a08cd841e30c21959143a36f30daa84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f42911d08a08cd841e30c21959143a36f30daa84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4780ac0f02979d397fcc8a87135fdea2d566010c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4780ac0f02979d397fcc8a87135fdea2d566010c", "html_url": "https://github.com/rust-lang/rust/commit/4780ac0f02979d397fcc8a87135fdea2d566010c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4780ac0f02979d397fcc8a87135fdea2d566010c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5a6714155c46c75df55cd5116de343811763727", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a6714155c46c75df55cd5116de343811763727", "html_url": "https://github.com/rust-lang/rust/commit/b5a6714155c46c75df55cd5116de343811763727"}, {"sha": "604e6ba0e2fb011987554f878bed4b8ba9bc00ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/604e6ba0e2fb011987554f878bed4b8ba9bc00ec", "html_url": "https://github.com/rust-lang/rust/commit/604e6ba0e2fb011987554f878bed4b8ba9bc00ec"}], "stats": {"total": 163, "additions": 67, "deletions": 96}, "files": [{"sha": "e796b465944d9e61dee61817624a6df8bf8f1ab7", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4780ac0f02979d397fcc8a87135fdea2d566010c/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4780ac0f02979d397fcc8a87135fdea2d566010c/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=4780ac0f02979d397fcc8a87135fdea2d566010c", "patch": "@@ -1,12 +1,11 @@\n use rustc::hir::intravisit as visit;\n use rustc::hir::{self, *};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::middle::expr_use_visitor::*;\n-use rustc::middle::mem_categorization::{cmt_, Categorization};\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n use rustc::util::nodemap::HirIdSet;\n use rustc::{declare_tool_lint, impl_lint_pass};\n+use rustc_typeck::expr_use_visitor::*;\n use syntax::source_map::Span;\n \n use crate::utils::span_lint;\n@@ -77,8 +76,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxedLocal {\n         };\n \n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n-        let region_scope_tree = &cx.tcx.region_scope_tree(fn_def_id);\n-        ExprUseVisitor::new(&mut v, cx.tcx, fn_def_id, cx.param_env, region_scope_tree, cx.tables).consume_body(body);\n+        cx.tcx.infer_ctxt().enter(|infcx| {\n+            ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.tables).consume_body(body);\n+        });\n \n         for node in v.set {\n             span_lint(\n@@ -105,45 +105,49 @@ fn is_argument(map: &hir::map::Map<'_>, id: HirId) -> bool {\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n-    fn consume(&mut self, cmt: &cmt_<'tcx>, mode: ConsumeMode) {\n-        if let Categorization::Local(lid) = cmt.cat {\n-            if let ConsumeMode::Move = mode {\n-                // moved out or in. clearly can't be localized\n-                self.set.remove(&lid);\n-            }\n-        }\n-        let map = &self.cx.tcx.hir();\n-        if let Categorization::Local(lid) = cmt.cat {\n-            if let Some(Node::Binding(_)) = map.find(cmt.hir_id) {\n-                if self.set.contains(&lid) {\n-                    // let y = x where x is known\n-                    // remove x, insert y\n-                    self.set.insert(cmt.hir_id);\n+    fn consume(&mut self, cmt: &Place<'tcx>, mode: ConsumeMode) {\n+        if cmt.projections.is_empty() {\n+            if let PlaceBase::Local(lid) = cmt.base {\n+                if let ConsumeMode::Move = mode {\n+                    // moved out or in. clearly can't be localized\n                     self.set.remove(&lid);\n                 }\n+                let map = &self.cx.tcx.hir();\n+                if let Some(Node::Binding(_)) = map.find(cmt.hir_id) {\n+                    if self.set.contains(&lid) {\n+                        // let y = x where x is known\n+                        // remove x, insert y\n+                        self.set.insert(cmt.hir_id);\n+                        self.set.remove(&lid);\n+                    }\n+                }\n             }\n         }\n     }\n \n-    fn borrow(&mut self, cmt: &cmt_<'tcx>, _: ty::BorrowKind) {\n-        if let Categorization::Local(lid) = cmt.cat {\n-            self.set.remove(&lid);\n+    fn borrow(&mut self, cmt: &Place<'tcx>, _: ty::BorrowKind) {\n+        if cmt.projections.is_empty() {\n+            if let PlaceBase::Local(lid) = cmt.base {\n+                self.set.remove(&lid);\n+            }\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &cmt_<'tcx>) {\n-        let map = &self.cx.tcx.hir();\n-        if is_argument(map, cmt.hir_id) {\n-            // Skip closure arguments\n-            let parent_id = map.get_parent_node(cmt.hir_id);\n-            if let Some(Node::Expr(..)) = map.find(map.get_parent_node(parent_id)) {\n-                return;\n-            }\n+    fn mutate(&mut self, cmt: &Place<'tcx>) {\n+        if cmt.projections.is_empty() {\n+            let map = &self.cx.tcx.hir();\n+            if is_argument(map, cmt.hir_id) {\n+                // Skip closure arguments\n+                let parent_id = map.get_parent_node(cmt.hir_id);\n+                if let Some(Node::Expr(..)) = map.find(map.get_parent_node(parent_id)) {\n+                    return;\n+                }\n \n-            if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n-                self.set.insert(cmt.hir_id);\n+                if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n+                    self.set.insert(cmt.hir_id);\n+                }\n+                return;\n             }\n-            return;\n         }\n     }\n }"}, {"sha": "4212f9c1e64f07f9bcee7f7ed7157ab42a465d0d", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4780ac0f02979d397fcc8a87135fdea2d566010c/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4780ac0f02979d397fcc8a87135fdea2d566010c/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=4780ac0f02979d397fcc8a87135fdea2d566010c", "patch": "@@ -12,13 +12,11 @@ use rustc::{declare_lint_pass, declare_tool_lint};\n use crate::consts::{constant, Constant};\n use crate::utils::usage::mutated_variables;\n use crate::utils::{is_type_diagnostic_item, qpath_res, sext, sugg};\n-use rustc::middle::expr_use_visitor::*;\n-use rustc::middle::mem_categorization::cmt_;\n-use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n+use rustc_typeck::expr_use_visitor::*;\n use std::iter::{once, Iterator};\n use std::mem;\n use syntax::ast;\n@@ -1586,11 +1584,11 @@ struct MutatePairDelegate {\n }\n \n impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n-    fn consume(&mut self, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: &Place<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, cmt: &cmt_<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, cmt: &Place<'tcx>, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n-            if let Categorization::Local(id) = cmt.cat {\n+            if let PlaceBase::Local(id) = cmt.base {\n                 if Some(id) == self.hir_id_low {\n                     self.span_low = Some(cmt.span)\n                 }\n@@ -1601,8 +1599,8 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &cmt_<'tcx>) {\n-        if let Categorization::Local(id) = cmt.cat {\n+    fn mutate(&mut self, cmt: &Place<'tcx>) {\n+        if let PlaceBase::Local(id) = cmt.base {\n             if Some(id) == self.hir_id_low {\n                 self.span_low = Some(cmt.span)\n             }\n@@ -1680,16 +1678,9 @@ fn check_for_mutation(\n         span_high: None,\n     };\n     let def_id = def_id::DefId::local(body.hir_id.owner);\n-    let region_scope_tree = &cx.tcx.region_scope_tree(def_id);\n-    ExprUseVisitor::new(\n-        &mut delegate,\n-        cx.tcx,\n-        def_id,\n-        cx.param_env,\n-        region_scope_tree,\n-        cx.tables,\n-    )\n-    .walk_expr(body);\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        ExprUseVisitor::new(&mut delegate, &infcx, def_id, cx.param_env, cx.tables).walk_expr(body);\n+    });\n     delegate.mutation_span()\n }\n "}, {"sha": "05894de5cb708bfe00d6e011e615def80089c3fb", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4780ac0f02979d397fcc8a87135fdea2d566010c/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4780ac0f02979d397fcc8a87135fdea2d566010c/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=4780ac0f02979d397fcc8a87135fdea2d566010c", "patch": "@@ -8,14 +8,13 @@ use matches::matches;\n use rustc::hir::intravisit::FnKind;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization as mc;\n use rustc::traits;\n use rustc::ty::{self, RegionKind, TypeFoldable};\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_target::spec::abi::Abi;\n+use rustc_typeck::expr_use_visitor as euv;\n use std::borrow::Cow;\n use syntax::ast::Attribute;\n use syntax::errors::DiagnosticBuilder;\n@@ -135,9 +134,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n             ..\n         } = {\n             let mut ctx = MovedVariablesCtxt::default();\n-            let region_scope_tree = &cx.tcx.region_scope_tree(fn_def_id);\n-            euv::ExprUseVisitor::new(&mut ctx, cx.tcx, fn_def_id, cx.param_env, region_scope_tree, cx.tables)\n-                .consume_body(body);\n+            cx.tcx.infer_ctxt().enter(|infcx| {\n+                euv::ExprUseVisitor::new(&mut ctx, &infcx, fn_def_id, cx.param_env, cx.tables).consume_body(body);\n+            });\n             ctx\n         };\n \n@@ -326,34 +325,21 @@ struct MovedVariablesCtxt {\n }\n \n impl MovedVariablesCtxt {\n-    fn move_common(&mut self, cmt: &mc::cmt_<'_>) {\n-        let cmt = unwrap_downcast_or_interior(cmt);\n-\n-        if let mc::Categorization::Local(vid) = cmt.cat {\n+    fn move_common(&mut self, cmt: &euv::Place<'_>) {\n+        if let euv::PlaceBase::Local(vid) = cmt.base {\n             self.moved_vars.insert(vid);\n         }\n     }\n }\n \n impl<'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt {\n-    fn consume(&mut self, cmt: &mc::cmt_<'tcx>, mode: euv::ConsumeMode) {\n+    fn consume(&mut self, cmt: &euv::Place<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move = mode {\n             self.move_common(cmt);\n         }\n     }\n \n-    fn borrow(&mut self, _: &mc::cmt_<'tcx>, _: ty::BorrowKind) {}\n-\n-    fn mutate(&mut self, _: &mc::cmt_<'tcx>) {}\n-}\n+    fn borrow(&mut self, _: &euv::Place<'tcx>, _: ty::BorrowKind) {}\n \n-fn unwrap_downcast_or_interior<'a, 'tcx>(mut cmt: &'a mc::cmt_<'tcx>) -> mc::cmt_<'tcx> {\n-    loop {\n-        match cmt.cat {\n-            mc::Categorization::Downcast(ref c, _) | mc::Categorization::Interior(ref c, _) => {\n-                cmt = c;\n-            },\n-            _ => return (*cmt).clone(),\n-        }\n-    }\n+    fn mutate(&mut self, _: &euv::Place<'tcx>) {}\n }"}, {"sha": "089ebafbb7fd8ec8a04cb7dee43d4afa35cfb307", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4780ac0f02979d397fcc8a87135fdea2d566010c/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4780ac0f02979d397fcc8a87135fdea2d566010c/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=4780ac0f02979d397fcc8a87135fdea2d566010c", "patch": "@@ -1,11 +1,9 @@\n use rustc::hir::def::Res;\n use rustc::hir::*;\n use rustc::lint::LateContext;\n-use rustc::middle::expr_use_visitor::*;\n-use rustc::middle::mem_categorization::cmt_;\n-use rustc::middle::mem_categorization::Categorization;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_typeck::expr_use_visitor::*;\n \n /// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n@@ -14,16 +12,9 @@ pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tc\n         skip: false,\n     };\n     let def_id = def_id::DefId::local(expr.hir_id.owner);\n-    let region_scope_tree = &cx.tcx.region_scope_tree(def_id);\n-    ExprUseVisitor::new(\n-        &mut delegate,\n-        cx.tcx,\n-        def_id,\n-        cx.param_env,\n-        region_scope_tree,\n-        cx.tables,\n-    )\n-    .walk_expr(expr);\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        ExprUseVisitor::new(&mut delegate, &infcx, def_id, cx.param_env, cx.tables).walk_expr(expr);\n+    });\n \n     if delegate.skip {\n         return None;\n@@ -46,33 +37,32 @@ struct MutVarsDelegate {\n \n impl<'tcx> MutVarsDelegate {\n     #[allow(clippy::similar_names)]\n-    fn update(&mut self, cat: &'tcx Categorization<'_>) {\n-        match *cat {\n-            Categorization::Local(id) => {\n+    fn update(&mut self, cat: &Place<'tcx>) {\n+        match cat.base {\n+            PlaceBase::Local(id) => {\n                 self.used_mutably.insert(id);\n             },\n-            Categorization::Upvar(_) => {\n+            PlaceBase::Upvar(_) => {\n                 //FIXME: This causes false negatives. We can't get the `NodeId` from\n                 //`Categorization::Upvar(_)`. So we search for any `Upvar`s in the\n                 //`while`-body, not just the ones in the condition.\n                 self.skip = true\n             },\n-            Categorization::Deref(ref cmt, _) | Categorization::Interior(ref cmt, _) => self.update(&cmt.cat),\n             _ => {},\n         }\n     }\n }\n \n impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n-    fn consume(&mut self, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: &Place<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, cmt: &cmt_<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, cmt: &Place<'tcx>, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n-            self.update(&cmt.cat)\n+            self.update(&cmt)\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &cmt_<'tcx>) {\n-        self.update(&cmt.cat)\n+    fn mutate(&mut self, cmt: &Place<'tcx>) {\n+        self.update(&cmt)\n     }\n }"}]}