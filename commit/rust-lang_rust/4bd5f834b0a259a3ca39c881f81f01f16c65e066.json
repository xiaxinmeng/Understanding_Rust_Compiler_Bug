{"sha": "4bd5f834b0a259a3ca39c881f81f01f16c65e066", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZDVmODM0YjBhMjU5YTNjYTM5Yzg4MWY4MWYwMWYxNmM2NWUwNjY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-06T13:22:13Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-06T19:24:03Z"}, "message": "First take on an alias-safety checker\n\nThe alias checker works by ensuring that any value to which an alias\nis created is rooted in some way that ensures it outlives the alias.\n\nIt is now disallowed to create an alias to the content of a mutable\nbox, or to a box hanging off a mutable field. There is also machinery\nin place to prevent assignment to local variables whenever they are\nthe root of a live alias.", "tree": {"sha": "820710dae88ce16af703d1d80dfe0a2fdc8c7f73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/820710dae88ce16af703d1d80dfe0a2fdc8c7f73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bd5f834b0a259a3ca39c881f81f01f16c65e066", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd5f834b0a259a3ca39c881f81f01f16c65e066", "html_url": "https://github.com/rust-lang/rust/commit/4bd5f834b0a259a3ca39c881f81f01f16c65e066", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bd5f834b0a259a3ca39c881f81f01f16c65e066/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b334f061a7e7e7ff766f934081bc40ebfdaa698", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b334f061a7e7e7ff766f934081bc40ebfdaa698", "html_url": "https://github.com/rust-lang/rust/commit/2b334f061a7e7e7ff766f934081bc40ebfdaa698"}], "stats": {"total": 285, "additions": 285, "deletions": 0}, "files": [{"sha": "e33a2e1c35dec07e27d8859d1d3089c4f53fff4c", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bd5f834b0a259a3ca39c881f81f01f16c65e066/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd5f834b0a259a3ca39c881f81f01f16c65e066/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=4bd5f834b0a259a3ca39c881f81f01f16c65e066", "patch": "@@ -109,6 +109,9 @@ fn compile_input(session::session sess,\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n \n+    time(time_passes, \"alias checking\",\n+         bind middle::alias::check_crate(@ty_cx, def_map, crate));\n+\n     auto llmod =\n         time[llvm::llvm::ModuleRef](time_passes, \"translation\",\n                                     bind trans::trans_crate(sess, crate,"}, {"sha": "9de830075ed9ca8ef979bde2b333451841b24dc1", "filename": "src/comp/middle/alias.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/4bd5f834b0a259a3ca39c881f81f01f16c65e066/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd5f834b0a259a3ca39c881f81f01f16c65e066/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=4bd5f834b0a259a3ca39c881f81f01f16c65e066", "patch": "@@ -0,0 +1,255 @@\n+import front::ast;\n+import front::ast::ident;\n+import front::ast::def_id;\n+import std::vec;\n+import std::str;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+\n+tag deref_t {\n+    field(ident);\n+    index;\n+    unbox;\n+}\n+type deref = rec(bool mut, deref_t t);\n+\n+type ctx = @rec(@ty::ctxt tcx,\n+                resolve::def_map dm,\n+                // The current blacklisted (non-assignable) locals\n+                mutable vec[vec[def_id]] bl,\n+                // A stack of blacklists for outer function scopes\n+                mutable vec[vec[vec[def_id]]] blstack);\n+\n+fn check_crate(@ty::ctxt tcx, resolve::def_map dm, &@ast::crate crate) {\n+    auto cx = @rec(tcx = tcx,\n+                   dm = dm,\n+                   mutable bl = vec::empty[vec[def_id]](),\n+                   mutable blstack = vec::empty[vec[vec[def_id]]]());\n+    auto v = rec(visit_item_pre = bind enter_item(cx, _),\n+                 visit_item_post = bind leave_item(cx, _),\n+                 visit_method_pre = bind enter_method(cx, _),\n+                 visit_method_post = bind leave_method(cx, _),\n+                 visit_expr_pre = bind check_expr(cx, _),\n+                 visit_expr_post = bind leave_expr(cx, _)\n+                 with walk::default_visitor());\n+    walk::walk_crate(v, *crate);\n+}\n+\n+fn enter_item(ctx cx, &@ast::item it) {\n+    alt (it.node) {\n+        case (ast::item_fn(_, _, _, _, _)) {\n+            vec::push(cx.blstack, cx.bl);\n+            cx.bl = [];\n+        }\n+        case (_) {}\n+    }\n+}\n+fn leave_item(ctx cx, &@ast::item it) {\n+    alt (it.node) {\n+        case (ast::item_fn(_, _, _, _, _)) {\n+            cx.bl = vec::pop(cx.blstack);\n+        }\n+        case (_) {}\n+    }\n+}\n+\n+fn enter_method(ctx cx, &@ast::method mt) {\n+    vec::push(cx.blstack, cx.bl);\n+    cx.bl = [];\n+}\n+fn leave_method(ctx cx, &@ast::method mt) {\n+    cx.bl = vec::pop(cx.blstack);\n+}\n+\n+fn check_expr(ctx cx, &@ast::expr ex) {\n+    alt (ex.node) {\n+        case (ast::expr_call(?f, ?args, _)) {\n+            auto fty = ty::expr_ty(*cx.tcx, f);\n+            auto argtys = alt (ty::struct(*cx.tcx, fty)) {\n+                case (ty::ty_fn(_, ?args, _, _)) { args }\n+                case (ty::ty_native_fn(_, ?args, _)) { args }\n+            };\n+            auto i = 0u;\n+            let vec[def_id] listed = [];\n+            for (ty::arg argty in argtys) {\n+                // FIXME Treat mo_either specially here?\n+                if (argty.mode != ty::mo_val) {\n+                    alt (check_rooted(cx, args.(i), false)) {\n+                        case (some(?did)) {\n+                            vec::push(listed, did);\n+                        }\n+                        case (_) {}\n+                    }\n+                }\n+                i += 1u;\n+            }\n+            // FIXME when mutable aliases can be distinguished, go over the\n+            // args again and ensure that we're not passing a blacklisted\n+            // variable by mutable alias (using 'listed' and the context\n+            // blacklist).\n+        }\n+        case (ast::expr_put(?val, _)) {\n+            alt (val) {\n+                case (some(?ex)) { check_rooted(cx, ex, false); }\n+                case (_) {}\n+            }\n+        }\n+        case (ast::expr_alt(?input, _, _)) {\n+            vec::push(cx.bl, alt (check_rooted(cx, input, true)) {\n+                case (some(?did)) { [did] }\n+                case (_) { vec::empty[def_id]() }\n+            });\n+        }\n+\n+        case (ast::expr_move(?dest, _, _)) { check_assign(cx, dest); }\n+        case (ast::expr_assign(?dest, _, _)) { check_assign(cx, dest); }\n+        case (ast::expr_assign_op(_, ?dest, _, _)) { check_assign(cx, dest); }\n+        case (_) {}\n+    }\n+}\n+\n+fn leave_expr(ctx cx, &@ast::expr ex) {\n+    alt (ex.node) {\n+        case (ast::expr_alt(_, _, _)) { vec::pop(cx.bl); }\n+        case (_) {}\n+    }\n+}\n+\n+fn check_assign(&ctx cx, &@ast::expr ex) {\n+    alt (ex.node) {\n+        case (ast::expr_path(?pt, ?ann)) {\n+            auto did = ast::def_id_of_def(cx.dm.get(ann.id));\n+            for (vec[def_id] layer in cx.bl) {\n+                for (def_id black in layer) {\n+                    if (did == black) {\n+                        cx.tcx.sess.span_err\n+                            (ex.span, str::connect(pt.node.idents, \"::\") +\n+                             \" is being aliased and may not be assigned to\");\n+                    }\n+                }\n+            }\n+        }\n+        case (_) {}\n+    }\n+}\n+\n+fn check_rooted(&ctx cx, &@ast::expr ex, bool autoderef)\n+    -> option::t[def_id] {\n+    auto root = expr_root(cx, ex, autoderef);\n+    if (has_unsafe_box(root.ds)) {\n+        cx.tcx.sess.span_err\n+            (ex.span, \"can not create alias to improperly anchored value\");\n+    }\n+    alt (root.ex.node) {\n+        case (ast::expr_path(_, ?ann)) {\n+            ret some(ast::def_id_of_def(cx.dm.get(ann.id)));\n+        }\n+        case (_) {\n+            ret none[def_id];\n+        }\n+    }\n+}\n+\n+fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n+    -> rec(@ast::expr ex, vec[deref] ds) {\n+    let vec[deref] ds = [];\n+    if (autoderef) {\n+        auto auto_unbox = maybe_auto_unbox(cx, ex);\n+        if (auto_unbox.done) {\n+            vec::push(ds, rec(mut=auto_unbox.mut, t=unbox));\n+        }\n+    }\n+    while (true) {\n+        alt ({ex.node}) {\n+            case (ast::expr_field(?base, ?ident, _)) {\n+                auto auto_unbox = maybe_auto_unbox(cx, base);\n+                alt (auto_unbox.t) {\n+                    case (ty::ty_tup(?fields)) {\n+                        auto fnm = ty::field_num(cx.tcx.sess, ex.span, ident);\n+                        auto mt = fields.(fnm).mut != ast::imm;\n+                        vec::push(ds, rec(mut=mt, t=field(ident)));\n+                    }\n+                    case (ty::ty_rec(?fields)) {\n+                        for (ty::field fld in fields) {\n+                            if (str::eq(ident, fld.ident)) {\n+                                auto mt = fld.mt.mut != ast::imm;\n+                                vec::push(ds, rec(mut=mt, t=field(ident)));\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    case (ty::ty_obj(_)) {\n+                        vec::push(ds, rec(mut=false, t=field(ident)));\n+                    }\n+                }\n+                if (auto_unbox.done) {\n+                    vec::push(ds, rec(mut=auto_unbox.mut, t=unbox));\n+                }\n+                ex = base;\n+            }\n+            case (ast::expr_index(?base, _, _)) {\n+                auto auto_unbox = maybe_auto_unbox(cx, base);\n+                alt (auto_unbox.t) {\n+                    case (ty::ty_vec(?mt)) {\n+                        vec::push(ds, rec(mut=mt.mut != ast::imm, t=index));\n+                    }\n+                }\n+                if (auto_unbox.done) {\n+                    vec::push(ds, rec(mut=auto_unbox.mut, t=unbox));\n+                }\n+                ex = base;\n+            }\n+            case (ast::expr_unary(?op, ?base, _)) {\n+                if (op == ast::deref) {\n+                    alt (ty::struct(*cx.tcx, ty::expr_ty(*cx.tcx, base))) {\n+                        case (ty::ty_box(?mt)) {\n+                            vec::push(ds, rec(mut=mt.mut!=ast::imm, t=unbox));\n+                        }\n+                    }\n+                    ex = base;\n+                } else {\n+                    break;\n+                }\n+            }\n+            case (_) { break; }\n+        }\n+    }\n+    vec::reverse(ds);\n+    ret rec(ex = ex, ds = ds);\n+}\n+\n+fn maybe_auto_unbox(&ctx cx, &@ast::expr ex)\n+    -> rec(ty::sty t, bool done, bool mut) {\n+    auto tp = ty::struct(*cx.tcx, ty::expr_ty(*cx.tcx, ex));\n+    alt (tp) {\n+        case (ty::ty_box(?mt)) {\n+            ret rec(t=ty::struct(*cx.tcx, mt.ty),\n+                    done=true, mut=mt.mut != ast::imm);\n+        }\n+        case (_) { ret rec(t=tp, done=false, mut=false); }\n+    }\n+}\n+\n+fn has_unsafe_box(&vec[deref] ds) -> bool {\n+    auto saw_mut = false;\n+    for (deref d in ds) {\n+        if (d.mut) { saw_mut = true; }\n+        if (d.t == unbox) {\n+            // Directly aliasing the content of a mutable box is never okay,\n+            // and any box living under mutable connection may be severed from\n+            // its root and freed.\n+            if (saw_mut) { ret true; }\n+        }\n+    }\n+    ret false;\n+}\n+\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "b7911a634b59be3e9a944560a95d43b9d7dfbaba", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bd5f834b0a259a3ca39c881f81f01f16c65e066/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4bd5f834b0a259a3ca39c881f81f01f16c65e066/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=4bd5f834b0a259a3ca39c881f81f01f16c65e066", "patch": "@@ -16,6 +16,7 @@ mod middle {\n     mod metadata;\n     mod resolve;\n     mod typeck;\n+    mod alias;\n \n     mod tstate {\n         mod ck;"}, {"sha": "e4ff5f86da2c2166ab4feb8c9b98f66fc37f0177", "filename": "src/test/compile-fail/unsafe-alias.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bd5f834b0a259a3ca39c881f81f01f16c65e066/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd5f834b0a259a3ca39c881f81f01f16c65e066/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs?ref=4bd5f834b0a259a3ca39c881f81f01f16c65e066", "patch": "@@ -0,0 +1,10 @@\n+// error-pattern:can not create alias\n+\n+fn foo(&int x) {\n+    log x;\n+}\n+\n+fn main() {\n+    auto box = @mutable 1;\n+    foo(*box);\n+}"}, {"sha": "a0342d87c867a3f1cbdf3a11799b03d2dff5ea9b", "filename": "src/test/compile-fail/unsafe-alt.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bd5f834b0a259a3ca39c881f81f01f16c65e066/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd5f834b0a259a3ca39c881f81f01f16c65e066/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs?ref=4bd5f834b0a259a3ca39c881f81f01f16c65e066", "patch": "@@ -0,0 +1,16 @@\n+// error-pattern:x is being aliased\n+\n+tag foo {\n+    left(int);\n+    right(bool);\n+}\n+\n+fn main() {\n+    auto x = left(10);\n+    alt (x) {\n+        case (left(?i)) {\n+            x = right(false);\n+        }\n+        case (_) {}\n+    }\n+}"}]}