{"sha": "b2f539375a24511f8dff5e67e549e0f08e5b961d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZjUzOTM3NWEyNDUxMWY4ZGZmNWU2N2U1NDllMGYwOGU1Yjk2MWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-17T20:10:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-17T20:10:25Z"}, "message": "Auto merge of #29887 - sanxiyn:match-ref-pats, r=sfackler", "tree": {"sha": "c95373b43ce090afc45f616097420c08ad4e7cee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c95373b43ce090afc45f616097420c08ad4e7cee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2f539375a24511f8dff5e67e549e0f08e5b961d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f539375a24511f8dff5e67e549e0f08e5b961d", "html_url": "https://github.com/rust-lang/rust/commit/b2f539375a24511f8dff5e67e549e0f08e5b961d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2f539375a24511f8dff5e67e549e0f08e5b961d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b31cc644d188126de6728b08b1cde707c1dc9400", "url": "https://api.github.com/repos/rust-lang/rust/commits/b31cc644d188126de6728b08b1cde707c1dc9400", "html_url": "https://github.com/rust-lang/rust/commit/b31cc644d188126de6728b08b1cde707c1dc9400"}, {"sha": "95f6ea920d56d9f3db52f5fa0a81f0ec4dffde5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/95f6ea920d56d9f3db52f5fa0a81f0ec4dffde5f", "html_url": "https://github.com/rust-lang/rust/commit/95f6ea920d56d9f3db52f5fa0a81f0ec4dffde5f"}], "stats": {"total": 114, "additions": 57, "deletions": 57}, "files": [{"sha": "e4697a7fd9149760d985495dbd2f6941f04f6ed2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b2f539375a24511f8dff5e67e549e0f08e5b961d", "patch": "@@ -1686,9 +1686,9 @@ pub enum Visibility {\n \n impl Visibility {\n     pub fn inherit_from(&self, parent_visibility: Visibility) -> Visibility {\n-        match self {\n-            &Inherited => parent_visibility,\n-            &Public => *self\n+        match *self {\n+            Inherited => parent_visibility,\n+            Public => *self\n         }\n     }\n }"}, {"sha": "67826c9c6cdffab502f84010bbd8119e13873a72", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=b2f539375a24511f8dff5e67e549e0f08e5b961d", "patch": "@@ -242,8 +242,8 @@ impl<'a> LifetimeBounds<'a> {\n             cx.lifetime_def(span, cx.ident_of(*lt).name, bounds)\n         }).collect();\n         let ty_params = self.bounds.iter().map(|t| {\n-            match t {\n-                &(ref name, ref bounds) => {\n+            match *t {\n+                (ref name, ref bounds) => {\n                     mk_ty_param(cx,\n                                 span,\n                                 *name,"}, {"sha": "5e5b815818161de75828c14193a6c4511d8de809", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b2f539375a24511f8dff5e67e549e0f08e5b961d", "patch": "@@ -63,9 +63,9 @@ pub mod rt {\n \n     impl<T: ToTokens> ToTokens for Option<T> {\n         fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            match self {\n-                &Some(ref t) => t.to_tokens(cx),\n-                &None => Vec::new(),\n+            match *self {\n+                Some(ref t) => t.to_tokens(cx),\n+                None => Vec::new(),\n             }\n         }\n     }"}, {"sha": "675482fd644cd24f973bb0bdfef3172c64372c91", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b2f539375a24511f8dff5e67e549e0f08e5b961d", "patch": "@@ -107,16 +107,16 @@ enum TokenTreeOrTokenTreeVec {\n \n impl TokenTreeOrTokenTreeVec {\n     fn len(&self) -> usize {\n-        match self {\n-            &TtSeq(ref v) => v.len(),\n-            &Tt(ref tt) => tt.len(),\n+        match *self {\n+            TtSeq(ref v) => v.len(),\n+            Tt(ref tt) => tt.len(),\n         }\n     }\n \n     fn get_tt(&self, index: usize) -> TokenTree {\n-        match self {\n-            &TtSeq(ref v) => v[index].clone(),\n-            &Tt(ref tt) => tt.get_tt(index),\n+        match *self {\n+            TtSeq(ref v) => v[index].clone(),\n+            Tt(ref tt) => tt.get_tt(index),\n         }\n     }\n }\n@@ -144,17 +144,17 @@ pub struct MatcherPos {\n \n pub fn count_names(ms: &[TokenTree]) -> usize {\n     ms.iter().fold(0, |count, elt| {\n-        count + match elt {\n-            &TokenTree::Sequence(_, ref seq) => {\n+        count + match *elt {\n+            TokenTree::Sequence(_, ref seq) => {\n                 seq.num_captures\n             }\n-            &TokenTree::Delimited(_, ref delim) => {\n+            TokenTree::Delimited(_, ref delim) => {\n                 count_names(&delim.tts)\n             }\n-            &TokenTree::Token(_, MatchNt(..)) => {\n+            TokenTree::Token(_, MatchNt(..)) => {\n                 1\n             }\n-            &TokenTree::Token(_, _) => 0,\n+            TokenTree::Token(_, _) => 0,\n         }\n     })\n }\n@@ -203,18 +203,18 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n             -> HashMap<Name, Rc<NamedMatch>> {\n     fn n_rec(p_s: &ParseSess, m: &TokenTree, res: &[Rc<NamedMatch>],\n              ret_val: &mut HashMap<Name, Rc<NamedMatch>>, idx: &mut usize) {\n-        match m {\n-            &TokenTree::Sequence(_, ref seq) => {\n+        match *m {\n+            TokenTree::Sequence(_, ref seq) => {\n                 for next_m in &seq.tts {\n                     n_rec(p_s, next_m, res, ret_val, idx)\n                 }\n             }\n-            &TokenTree::Delimited(_, ref delim) => {\n+            TokenTree::Delimited(_, ref delim) => {\n                 for next_m in &delim.tts {\n                     n_rec(p_s, next_m, res, ret_val, idx)\n                 }\n             }\n-            &TokenTree::Token(sp, MatchNt(bind_name, _, _, _)) => {\n+            TokenTree::Token(sp, MatchNt(bind_name, _, _, _)) => {\n                 match ret_val.entry(bind_name.name) {\n                     Vacant(spot) => {\n                         spot.insert(res[*idx].clone());\n@@ -228,8 +228,8 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                     }\n                 }\n             }\n-            &TokenTree::Token(_, SubstNt(..)) => panic!(\"Cannot fill in a NT\"),\n-            &TokenTree::Token(_, _) => (),\n+            TokenTree::Token(_, SubstNt(..)) => panic!(\"Cannot fill in a NT\"),\n+            TokenTree::Token(_, _) => (),\n         }\n     }\n     let mut ret_val = HashMap::new();"}, {"sha": "e9c716017c0b3a40b05ff4668fe3ffc82c02be30", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b2f539375a24511f8dff5e67e549e0f08e5b961d", "patch": "@@ -1263,13 +1263,13 @@ impl<'a> State<'a> {\n                     _ => {}\n                 }\n \n-                match opt_trait {\n-                    &Some(ref t) => {\n+                match *opt_trait {\n+                    Some(ref t) => {\n                         try!(self.print_trait_ref(t));\n                         try!(space(&mut self.s));\n                         try!(self.word_space(\"for\"));\n                     }\n-                    &None => {}\n+                    None => {}\n                 }\n \n                 try!(self.print_type(&**ty));\n@@ -1499,10 +1499,10 @@ impl<'a> State<'a> {\n             try!(self.print_tt(tt));\n             // There should be no space between the module name and the following `::` in paths,\n             // otherwise imported macros get re-parsed from crate metadata incorrectly (#20701)\n-            suppress_space = match tt {\n-                &TokenTree::Token(_, token::Ident(_, token::ModName)) |\n-                &TokenTree::Token(_, token::MatchNt(_, _, _, token::ModName)) |\n-                &TokenTree::Token(_, token::SubstNt(_, token::ModName)) => true,\n+            suppress_space = match *tt {\n+                TokenTree::Token(_, token::Ident(_, token::ModName)) |\n+                TokenTree::Token(_, token::MatchNt(_, _, _, token::ModName)) |\n+                TokenTree::Token(_, token::SubstNt(_, token::ModName)) => true,\n                 _ => false\n             }\n         }\n@@ -2618,8 +2618,8 @@ impl<'a> State<'a> {\n         try!(self.rbox(0, Inconsistent));\n         let mut first = true;\n         if let Some(explicit_self) = opt_explicit_self {\n-            let m = match explicit_self {\n-                &ast::SelfStatic => ast::MutImmutable,\n+            let m = match *explicit_self {\n+                ast::SelfStatic => ast::MutImmutable,\n                 _ => match decl.inputs[0].pat.node {\n                     ast::PatIdent(ast::BindByValue(m), _, _) => m,\n                     _ => ast::MutImmutable\n@@ -2804,18 +2804,18 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\",\"));\n             }\n \n-            match predicate {\n-                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bound_lifetimes,\n-                                                                              ref bounded_ty,\n-                                                                              ref bounds,\n-                                                                              ..}) => {\n+            match *predicate {\n+                ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bound_lifetimes,\n+                                                                             ref bounded_ty,\n+                                                                             ref bounds,\n+                                                                             ..}) => {\n                     try!(self.print_formal_lifetime_list(bound_lifetimes));\n                     try!(self.print_type(&**bounded_ty));\n                     try!(self.print_bounds(\":\", bounds));\n                 }\n-                &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n-                                                                                ref bounds,\n-                                                                                ..}) => {\n+                ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+                                                                               ref bounds,\n+                                                                               ..}) => {\n                     try!(self.print_lifetime(lifetime));\n                     try!(word(&mut self.s, \":\"));\n \n@@ -2827,7 +2827,7 @@ impl<'a> State<'a> {\n                         }\n                     }\n                 }\n-                &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n+                ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n                     try!(self.print_path(path, false, 0));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));"}, {"sha": "3e02476443a990a04ea1822606cda11ea8c00d9a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=b2f539375a24511f8dff5e67e549e0f08e5b961d", "patch": "@@ -353,8 +353,8 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     let has_test_attr = attr::contains_name(&i.attrs, \"test\");\n \n     fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n-        match &i.node {\n-          &ast::ItemFn(ref decl, _, _, _, ref generics, _) => {\n+        match i.node {\n+          ast::ItemFn(ref decl, _, _, _, ref generics, _) => {\n             let no_output = match decl.output {\n                 ast::DefaultReturn(..) => true,\n                 ast::Return(ref t) if t.node == ast::TyTup(vec![]) => true,"}, {"sha": "5d4a462e844916dd9dd5303ddfb0be783d57f62d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f539375a24511f8dff5e67e549e0f08e5b961d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b2f539375a24511f8dff5e67e549e0f08e5b961d", "patch": "@@ -496,25 +496,25 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n     }\n     walk_list!(visitor, visit_lifetime_def, &generics.lifetimes);\n     for predicate in &generics.where_clause.predicates {\n-        match predicate {\n-            &WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n-                                                                          ref bounds,\n-                                                                          ref bound_lifetimes,\n-                                                                          ..}) => {\n+        match *predicate {\n+            WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n+                                                               ref bounds,\n+                                                               ref bound_lifetimes,\n+                                                               ..}) => {\n                 visitor.visit_ty(bounded_ty);\n                 walk_list!(visitor, visit_ty_param_bound, bounds);\n                 walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n             }\n-            &WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n-                                                                            ref bounds,\n-                                                                            ..}) => {\n+            WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n+                                                                 ref bounds,\n+                                                                 ..}) => {\n                 visitor.visit_lifetime(lifetime);\n                 walk_list!(visitor, visit_lifetime, bounds);\n             }\n-            &WherePredicate::EqPredicate(WhereEqPredicate{id,\n-                                                                    ref path,\n-                                                                    ref ty,\n-                                                                    ..}) => {\n+            WherePredicate::EqPredicate(WhereEqPredicate{id,\n+                                                         ref path,\n+                                                         ref ty,\n+                                                         ..}) => {\n                 visitor.visit_path(path, id);\n                 visitor.visit_ty(ty);\n             }"}]}