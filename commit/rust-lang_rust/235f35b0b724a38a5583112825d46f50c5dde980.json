{"sha": "235f35b0b724a38a5583112825d46f50c5dde980", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNWYzNWIwYjcyNGEzOGE1NTgzMTEyODI1ZDQ2ZjUwYzVkZGU5ODA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-17T21:58:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-17T21:58:34Z"}, "message": "std: Stabilize the `ascii` module\n\nThis commit performs a stabilization pass over the `std::ascii` module taking\nthe following actions:\n\n* the module name is now stable\n* `AsciiExt` is now stable after moving its type parameter to an `Owned`\n  associated type\n* `AsciiExt::is_ascii` is now stable\n* `AsciiExt::to_ascii_uppercase` is now stable\n* `AsciiExt::to_ascii_lowercase` is now stable\n* `AsciiExt::eq_ignore_ascii_case` is now stable\n* `AsciiExt::make_ascii_uppercase` is added to possibly replace\n  `OwnedAsciiExt::into_ascii_uppercase` (similarly for lowercase variants).\n* `escape_default` now returns an iterator and is stable\n* `EscapeDefault` is now stable\n\nTrait implementations are now also marked stable.\n\nPrimarily it is still unstable to *implement* the `AsciiExt` trait due to it\ncontaining some unstable methods.\n\n[breaking-change]", "tree": {"sha": "67bf45c78e1eecfdbaff51727174a932759af02c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67bf45c78e1eecfdbaff51727174a932759af02c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/235f35b0b724a38a5583112825d46f50c5dde980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/235f35b0b724a38a5583112825d46f50c5dde980", "html_url": "https://github.com/rust-lang/rust/commit/235f35b0b724a38a5583112825d46f50c5dde980", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/235f35b0b724a38a5583112825d46f50c5dde980/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cf2d00f0e034c8844bc9899b7e1df8c5eced60e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cf2d00f0e034c8844bc9899b7e1df8c5eced60e", "html_url": "https://github.com/rust-lang/rust/commit/0cf2d00f0e034c8844bc9899b7e1df8c5eced60e"}], "stats": {"total": 210, "additions": 132, "deletions": 78}, "files": [{"sha": "4d38d17576ddb2a15ee7fe13624ff1a993a979e6", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 122, "deletions": 70, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/235f35b0b724a38a5583112825d46f50c5dde980/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235f35b0b724a38a5583112825d46f50c5dde980/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=235f35b0b724a38a5583112825d46f50c5dde980", "patch": "@@ -12,15 +12,12 @@\n \n //! Operations on ASCII strings and characters\n \n-#![unstable(feature = \"std_misc\",\n-            reason = \"unsure about placement and naming\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use iter::IteratorExt;\n-use ops::FnMut;\n-use slice::SliceExt;\n-use str::StrExt;\n-use string::String;\n-use vec::Vec;\n+use prelude::v1::*;\n+\n+use mem;\n+use iter::Range;\n \n /// Extension methods for ASCII-subset only operations on owned strings\n #[unstable(feature = \"std_misc\",\n@@ -38,52 +35,79 @@ pub trait OwnedAsciiExt {\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n-pub trait AsciiExt<T = Self> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsciiExt {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Owned;\n+\n     /// Check if within the ASCII range.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_ascii(&self) -> bool;\n \n     /// Makes a copy of the string in ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n-    fn to_ascii_uppercase(&self) -> T;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_ascii_uppercase(&self) -> Self::Owned;\n \n     /// Makes a copy of the string in ASCII lower case:\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n-    fn to_ascii_lowercase(&self) -> T;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_ascii_lowercase(&self) -> Self::Owned;\n \n     /// Check that two strings are an ASCII case-insensitive match.\n     /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n     /// but without allocating and copying temporary strings.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n+\n+    /// Convert this type to its ASCII upper case equivalent in-place.\n+    ///\n+    /// See `to_ascii_uppercase` for more information.\n+    #[unstable(feature = \"ascii\")]\n+    fn make_ascii_uppercase(&mut self);\n+\n+    /// Convert this type to its ASCII lower case equivalent in-place.\n+    ///\n+    /// See `to_ascii_lowercase` for more information.\n+    #[unstable(feature = \"ascii\")]\n+    fn make_ascii_lowercase(&mut self);\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n-impl AsciiExt<String> for str {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for str {\n+    type Owned = String;\n+\n     #[inline]\n     fn is_ascii(&self) -> bool {\n         self.bytes().all(|b| b.is_ascii())\n     }\n \n     #[inline]\n     fn to_ascii_uppercase(&self) -> String {\n-        // Vec<u8>::to_ascii_uppercase() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(self.as_bytes().to_ascii_uppercase()) }\n+        self.to_string().into_ascii_uppercase()\n     }\n \n     #[inline]\n     fn to_ascii_lowercase(&self) -> String {\n-        // Vec<u8>::to_ascii_lowercase() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(self.as_bytes().to_ascii_lowercase()) }\n+        self.to_string().into_ascii_lowercase()\n     }\n \n     #[inline]\n     fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n         self.as_bytes().eq_ignore_ascii_case(other.as_bytes())\n     }\n+\n+    fn make_ascii_uppercase(&mut self) {\n+        let me: &mut [u8] = unsafe { mem::transmute(self) };\n+        me.make_ascii_uppercase()\n+    }\n+\n+    fn make_ascii_lowercase(&mut self) {\n+        let me: &mut [u8] = unsafe { mem::transmute(self) };\n+        me.make_ascii_lowercase()\n+    }\n }\n \n #[unstable(feature = \"std_misc\",\n@@ -102,22 +126,22 @@ impl OwnedAsciiExt for String {\n     }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n-impl AsciiExt<Vec<u8>> for [u8] {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for [u8] {\n+    type Owned = Vec<u8>;\n     #[inline]\n     fn is_ascii(&self) -> bool {\n         self.iter().all(|b| b.is_ascii())\n     }\n \n     #[inline]\n     fn to_ascii_uppercase(&self) -> Vec<u8> {\n-        self.iter().map(|b| b.to_ascii_uppercase()).collect()\n+        self.to_vec().into_ascii_uppercase()\n     }\n \n     #[inline]\n     fn to_ascii_lowercase(&self) -> Vec<u8> {\n-        self.iter().map(|b| b.to_ascii_lowercase()).collect()\n+        self.to_vec().into_ascii_lowercase()\n     }\n \n     #[inline]\n@@ -127,55 +151,58 @@ impl AsciiExt<Vec<u8>> for [u8] {\n             a.eq_ignore_ascii_case(b)\n         })\n     }\n+\n+    fn make_ascii_uppercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_uppercase();\n+        }\n+    }\n+\n+    fn make_ascii_lowercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_lowercase();\n+        }\n+    }\n }\n \n #[unstable(feature = \"std_misc\",\n            reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_uppercase(mut self) -> Vec<u8> {\n-        for byte in &mut self {\n-            *byte = byte.to_ascii_uppercase();\n-        }\n+        self.make_ascii_uppercase();\n         self\n     }\n \n     #[inline]\n     fn into_ascii_lowercase(mut self) -> Vec<u8> {\n-        for byte in &mut self {\n-            *byte = byte.to_ascii_lowercase();\n-        }\n+        self.make_ascii_lowercase();\n         self\n     }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsciiExt for u8 {\n+    type Owned = u8;\n     #[inline]\n-    fn is_ascii(&self) -> bool {\n-        *self & 128 == 0u8\n-    }\n-\n+    fn is_ascii(&self) -> bool { *self & 128 == 0u8 }\n     #[inline]\n-    fn to_ascii_uppercase(&self) -> u8 {\n-        ASCII_UPPERCASE_MAP[*self as usize]\n-    }\n-\n+    fn to_ascii_uppercase(&self) -> u8 { ASCII_UPPERCASE_MAP[*self as usize] }\n     #[inline]\n-    fn to_ascii_lowercase(&self) -> u8 {\n-        ASCII_LOWERCASE_MAP[*self as usize]\n-    }\n-\n+    fn to_ascii_lowercase(&self) -> u8 { ASCII_LOWERCASE_MAP[*self as usize] }\n     #[inline]\n     fn eq_ignore_ascii_case(&self, other: &u8) -> bool {\n         self.to_ascii_lowercase() == other.to_ascii_lowercase()\n     }\n+    #[inline]\n+    fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }\n+    #[inline]\n+    fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsciiExt for char {\n+    type Owned = char;\n     #[inline]\n     fn is_ascii(&self) -> bool {\n         *self as u32 <= 0x7F\n@@ -203,6 +230,19 @@ impl AsciiExt for char {\n     fn eq_ignore_ascii_case(&self, other: &char) -> bool {\n         self.to_ascii_lowercase() == other.to_ascii_lowercase()\n     }\n+\n+    #[inline]\n+    fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }\n+    #[inline]\n+    fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }\n+}\n+\n+/// An iterator over the escaped version of a byte, constructed via\n+/// `std::ascii::escape_default`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct EscapeDefault {\n+    range: Range<usize>,\n+    data: [u8; 4],\n }\n \n /// Returns a 'default' ASCII and C++11-like literal escape of a `u8`\n@@ -214,34 +254,46 @@ impl AsciiExt for char {\n /// - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n /// - Single-quote, double-quote and backslash chars are backslash-escaped.\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n-/// - Any other chars are given hex escapes.\n+/// - Any other chars are given hex escapes of the form '\\xNN'.\n /// - Unicode escapes are never generated by this function.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"needs to be updated to use an iterator\")]\n-pub fn escape_default<F>(c: u8, mut f: F) where\n-    F: FnMut(u8),\n-{\n-    match c {\n-        b'\\t' => { f(b'\\\\'); f(b't'); }\n-        b'\\r' => { f(b'\\\\'); f(b'r'); }\n-        b'\\n' => { f(b'\\\\'); f(b'n'); }\n-        b'\\\\' => { f(b'\\\\'); f(b'\\\\'); }\n-        b'\\'' => { f(b'\\\\'); f(b'\\''); }\n-        b'\"'  => { f(b'\\\\'); f(b'\"'); }\n-        b'\\x20' ... b'\\x7e' => { f(c); }\n-        _ => {\n-            f(b'\\\\');\n-            f(b'x');\n-            for &offset in &[4u, 0u] {\n-                match ((c as i32) >> offset) & 0xf {\n-                    i @ 0 ... 9 => f(b'0' + (i as u8)),\n-                    i => f(b'a' + (i as u8 - 10)),\n-                }\n-            }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn escape_default(c: u8) -> EscapeDefault {\n+    let (data, len) = match c {\n+        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n+        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n+        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n+        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n+        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n+        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n+        b'\\x20' ... b'\\x7e' => ([c, 0, 0, 0], 1),\n+        _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n+    };\n+\n+    return EscapeDefault { range: range(0, len), data: data };\n+\n+    fn hexify(b: u8) -> u8 {\n+        match b {\n+            0 ... 9 => b'0' + b,\n+            _ => b'a' + b - 10,\n         }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for EscapeDefault {\n+    type Item = u8;\n+    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl DoubleEndedIterator for EscapeDefault {\n+    fn next_back(&mut self) -> Option<u8> {\n+        self.range.next_back().map(|i| self.data[i])\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExactSizeIterator for EscapeDefault {}\n+\n static ASCII_LOWERCASE_MAP: [u8; 256] = [\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,"}, {"sha": "b610f6c370bb3bcfcc99db2c47e99180f538cc8c", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/235f35b0b724a38a5583112825d46f50c5dde980/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235f35b0b724a38a5583112825d46f50c5dde980/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=235f35b0b724a38a5583112825d46f50c5dde980", "patch": "@@ -817,7 +817,9 @@ impl<'a, S: Writer + Hasher> Hash<S> for Wtf8 {\n     }\n }\n \n-impl AsciiExt<Wtf8Buf> for Wtf8 {\n+impl AsciiExt for Wtf8 {\n+    type Owned = Wtf8Buf;\n+\n     fn is_ascii(&self) -> bool {\n         self.bytes.is_ascii()\n     }\n@@ -830,6 +832,9 @@ impl AsciiExt<Wtf8Buf> for Wtf8 {\n     fn eq_ignore_ascii_case(&self, other: &Wtf8) -> bool {\n         self.bytes.eq_ignore_ascii_case(&other.bytes)\n     }\n+\n+    fn make_ascii_uppercase(&mut self) { self.bytes.make_ascii_uppercase() }\n+    fn make_ascii_lowercase(&mut self) { self.bytes.make_ascii_lowercase() }\n }\n \n #[cfg(test)]"}, {"sha": "4b021f2434f054d8a45ab599a13d67a287ad48ce", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/235f35b0b724a38a5583112825d46f50c5dde980/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235f35b0b724a38a5583112825d46f50c5dde980/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=235f35b0b724a38a5583112825d46f50c5dde980", "patch": "@@ -2761,15 +2761,13 @@ impl<'a> State<'a> {\n             ast::LitStr(ref st, style) => self.print_string(&st, style),\n             ast::LitByte(byte) => {\n                 let mut res = String::from_str(\"b'\");\n-                ascii::escape_default(byte, |c| res.push(c as char));\n+                res.extend(ascii::escape_default(byte).map(|c| c as char));\n                 res.push('\\'');\n                 word(&mut self.s, &res[])\n             }\n             ast::LitChar(ch) => {\n                 let mut res = String::from_str(\"'\");\n-                for c in ch.escape_default() {\n-                    res.push(c);\n-                }\n+                res.extend(ch.escape_default());\n                 res.push('\\'');\n                 word(&mut self.s, &res[])\n             }\n@@ -2809,8 +2807,8 @@ impl<'a> State<'a> {\n             ast::LitBinary(ref v) => {\n                 let mut escaped: String = String::new();\n                 for &ch in &**v {\n-                    ascii::escape_default(ch as u8,\n-                                          |ch| escaped.push(ch as char));\n+                    escaped.extend(ascii::escape_default(ch as u8)\n+                                         .map(|c| c as char));\n                 }\n                 word(&mut self.s, &format!(\"b\\\"{}\\\"\", escaped)[])\n             }"}, {"sha": "276e2f3ca38b6bded9e573425c849b75ec0a5d75", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/235f35b0b724a38a5583112825d46f50c5dde980/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235f35b0b724a38a5583112825d46f50c5dde980/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=235f35b0b724a38a5583112825d46f50c5dde980", "patch": "@@ -58,7 +58,6 @@\n #![feature(path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n #![feature(unicode)]\n #![feature(env)]\n #![cfg_attr(windows, feature(libc))]"}]}