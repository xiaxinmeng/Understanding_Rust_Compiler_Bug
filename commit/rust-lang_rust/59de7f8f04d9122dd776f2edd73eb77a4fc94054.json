{"sha": "59de7f8f04d9122dd776f2edd73eb77a4fc94054", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZGU3ZjhmMDRkOTEyMmRkNzc2ZjJlZGQ3M2ViNzdhNGZjOTQwNTQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-29T02:07:12Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-18T23:26:22Z"}, "message": "Add `ident.unhygienize()` and use `Ident` more instead of `Name` in `resolve`.", "tree": {"sha": "9ed1e83114aaa9cbdc3157414429349916507760", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ed1e83114aaa9cbdc3157414429349916507760"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59de7f8f04d9122dd776f2edd73eb77a4fc94054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59de7f8f04d9122dd776f2edd73eb77a4fc94054", "html_url": "https://github.com/rust-lang/rust/commit/59de7f8f04d9122dd776f2edd73eb77a4fc94054", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59de7f8f04d9122dd776f2edd73eb77a4fc94054/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83ab9f7faccddee23545e12d323791f9e2d06380", "url": "https://api.github.com/repos/rust-lang/rust/commits/83ab9f7faccddee23545e12d323791f9e2d06380", "html_url": "https://github.com/rust-lang/rust/commit/83ab9f7faccddee23545e12d323791f9e2d06380"}], "stats": {"total": 306, "additions": 156, "deletions": 150}, "files": [{"sha": "4aa04dc34fedaeee7ecd7ef33400b29e3ad7797e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/59de7f8f04d9122dd776f2edd73eb77a4fc94054/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59de7f8f04d9122dd776f2edd73eb77a4fc94054/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=59de7f8f04d9122dd776f2edd73eb77a4fc94054", "patch": "@@ -28,7 +28,7 @@ use rustc::ty;\n use std::cell::Cell;\n use std::rc::Rc;\n \n-use syntax::ast::Name;\n+use syntax::ast::{Name, Ident};\n use syntax::attr;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n@@ -76,12 +76,12 @@ struct LegacyMacroImports {\n impl<'b> Resolver<'b> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    fn define<T>(&mut self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n+    fn define<T>(&mut self, parent: Module<'b>, ident: Ident, ns: Namespace, def: T)\n         where T: ToNameBinding<'b>,\n     {\n         let binding = def.to_name_binding();\n-        if let Err(old_binding) = self.try_define(parent, name, ns, binding.clone()) {\n-            self.report_conflict(parent, name, ns, old_binding, &binding);\n+        if let Err(old_binding) = self.try_define(parent, ident, ns, binding.clone()) {\n+            self.report_conflict(parent, ident, ns, old_binding, &binding);\n         }\n     }\n \n@@ -102,7 +102,7 @@ impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n         let parent = self.current_module;\n-        let name = item.ident.name;\n+        let ident = item.ident;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n \n@@ -157,8 +157,8 @@ impl<'b> Resolver<'b> {\n                         }\n \n                         let subclass = SingleImport {\n-                            target: binding.name,\n-                            source: source.name,\n+                            target: binding,\n+                            source: source,\n                             result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n                         };\n                         self.add_import_directive(\n@@ -187,13 +187,13 @@ impl<'b> Resolver<'b> {\n \n                         for source_item in source_items {\n                             let node = source_item.node;\n-                            let (module_path, name, rename) = {\n+                            let (module_path, ident, rename) = {\n                                 if node.name.name != keywords::SelfValue.name() {\n-                                    let rename = node.rename.unwrap_or(node.name).name;\n-                                    (module_path.clone(), node.name.name, rename)\n+                                    let rename = node.rename.unwrap_or(node.name);\n+                                    (module_path.clone(), node.name, rename)\n                                 } else {\n-                                    let name = match module_path.last() {\n-                                        Some(ident) => ident.name,\n+                                    let ident = match module_path.last() {\n+                                        Some(&ident) => ident,\n                                         None => {\n                                             resolve_error(\n                                                 self,\n@@ -205,13 +205,13 @@ impl<'b> Resolver<'b> {\n                                         }\n                                     };\n                                     let module_path = module_path.split_last().unwrap().1;\n-                                    let rename = node.rename.map(|i| i.name).unwrap_or(name);\n-                                    (module_path.to_vec(), name, rename)\n+                                    let rename = node.rename.unwrap_or(ident);\n+                                    (module_path.to_vec(), ident, rename)\n                                 }\n                             };\n                             let subclass = SingleImport {\n                                 target: rename,\n-                                source: name,\n+                                source: ident,\n                                 result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n                             };\n                             let id = source_item.node.id;\n@@ -251,7 +251,7 @@ impl<'b> Resolver<'b> {\n                     expansion: expansion,\n                 });\n                 let imported_binding = self.import(binding, directive);\n-                self.define(parent, name, TypeNS, imported_binding);\n+                self.define(parent, ident, TypeNS, imported_binding);\n                 self.populate_module_if_necessary(module);\n                 self.process_legacy_macro_imports(item, module, expansion);\n             }\n@@ -265,9 +265,9 @@ impl<'b> Resolver<'b> {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n                     normal_ancestor_id: Some(item.id),\n-                    ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n+                    ..ModuleS::new(Some(parent), ModuleKind::Def(def, ident.name))\n                 });\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.module_map.insert(item.id, module);\n \n                 // Descend into the module.\n@@ -280,27 +280,27 @@ impl<'b> Resolver<'b> {\n             ItemKind::Static(_, m, _) => {\n                 let mutbl = m == Mutability::Mutable;\n                 let def = Def::Static(self.definitions.local_def_id(item.id), mutbl);\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n                 let def = Def::Const(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n                 let def = Def::Fn(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n \n             // These items live in the type namespace.\n             ItemKind::Ty(..) => {\n                 let def = Def::TyAlias(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), true);\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n+                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), true);\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n                     self.build_reduced_graph_for_variant(variant, module, vis, expansion);\n@@ -311,14 +311,14 @@ impl<'b> Resolver<'b> {\n             ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def = Def::Struct(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if !struct_def.is_struct() {\n                     let ctor_def = Def::StructCtor(self.definitions.local_def_id(struct_def.id()),\n                                                    CtorKind::from_ast(struct_def));\n-                    self.define(parent, name, ValueNS, (ctor_def, vis, sp, expansion));\n+                    self.define(parent, ident, ValueNS, (ctor_def, vis, sp, expansion));\n                 }\n \n                 // Record field names for error reporting.\n@@ -332,7 +332,7 @@ impl<'b> Resolver<'b> {\n \n             ItemKind::Union(ref vdata, _) => {\n                 let def = Def::Union(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = vdata.fields().iter().filter_map(|field| {\n@@ -350,8 +350,8 @@ impl<'b> Resolver<'b> {\n \n                 // Add all the items within to a new module.\n                 let module =\n-                    self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), name), true);\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n+                    self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), ident.name), true);\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n             }\n             ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n@@ -365,26 +365,23 @@ impl<'b> Resolver<'b> {\n                                        parent: Module<'b>,\n                                        vis: ty::Visibility,\n                                        expansion: Mark) {\n-        let name = variant.node.name.name;\n+        let ident = variant.node.name;\n         let def_id = self.definitions.local_def_id(variant.node.data.id());\n \n         // Define a name in the type namespace.\n         let def = Def::Variant(def_id);\n-        self.define(parent, name, TypeNS, (def, vis, variant.span, expansion));\n+        self.define(parent, ident, TypeNS, (def, vis, variant.span, expansion));\n \n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-        self.define(parent, name, ValueNS, (ctor_def, vis, variant.span, expansion));\n+        self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: Mark) {\n-        let parent = self.current_module;\n-        let name = item.ident.name;\n-\n         let def = match item.node {\n             ForeignItemKind::Fn(..) => {\n                 Def::Fn(self.definitions.local_def_id(item.id))\n@@ -393,8 +390,9 @@ impl<'b> Resolver<'b> {\n                 Def::Static(self.definitions.local_def_id(item.id), m)\n             }\n         };\n+        let parent = self.current_module;\n         let vis = self.resolve_visibility(&item.vis);\n-        self.define(parent, name, ValueNS, (def, vis, item.span, expansion));\n+        self.define(parent, item.ident, ValueNS, (def, vis, item.span, expansion));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n@@ -414,7 +412,7 @@ impl<'b> Resolver<'b> {\n \n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>, child: Export) {\n-        let name = child.name;\n+        let ident = Ident::with_empty_ctxt(child.name);\n         let def = child.def;\n         let def_id = def.def_id();\n         let vis = match def {\n@@ -425,25 +423,25 @@ impl<'b> Resolver<'b> {\n \n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), false);\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Variant(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::VariantCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Fn(..) |\n             Def::Static(..) |\n             Def::Const(..) |\n             Def::AssociatedConst(..) |\n             Def::Method(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Trait(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), false);\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n \n                 // If this is a trait, add all the trait item names to the trait info.\n                 let trait_item_def_ids = self.session.cstore.associated_item_def_ids(def_id);\n@@ -455,27 +453,27 @@ impl<'b> Resolver<'b> {\n                 }\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Struct(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::StructCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Union(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::Macro(..) => {\n-                self.define(parent, name, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Local(..) |\n             Def::PrimTy(..) |\n@@ -574,12 +572,13 @@ impl<'b> Resolver<'b> {\n         }\n \n         if let Some(span) = legacy_imports.import_all {\n-            module.for_each_child(|name, ns, binding| if ns == MacroNS {\n-                self.legacy_import_macro(name, binding, span, allow_shadowing);\n+            module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n+                self.legacy_import_macro(ident.name, binding, span, allow_shadowing);\n             });\n         } else {\n             for (name, span) in legacy_imports.imports {\n-                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+                let ident = Ident::with_empty_ctxt(name);\n+                let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n                 if let Ok(binding) = result {\n                     self.legacy_import_macro(name, binding, span, allow_shadowing);\n                 } else {\n@@ -591,7 +590,8 @@ impl<'b> Resolver<'b> {\n             let krate = module.def_id().unwrap().krate;\n             self.used_crates.insert(krate);\n             self.session.cstore.export_macros(krate);\n-            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+            let ident = Ident::with_empty_ctxt(name);\n+            let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n             if let Ok(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {\n@@ -759,7 +759,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         self.resolver.trait_item_map.insert((item.ident.name, def_id), is_static_method);\n \n         let vis = ty::Visibility::Public;\n-        self.resolver.define(parent, item.ident.name, ns, (def, vis, item.span, self.expansion));\n+        self.resolver.define(parent, item.ident, ns, (def, vis, item.span, self.expansion));\n \n         self.resolver.current_module = parent.parent.unwrap(); // nearest normal ancestor\n         visit::walk_trait_item(self, item);"}, {"sha": "4d4f4629c753469a6cdd0b14de3415c48a89fcb5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/59de7f8f04d9122dd776f2edd73eb77a4fc94054/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59de7f8f04d9122dd776f2edd73eb77a4fc94054/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=59de7f8f04d9122dd776f2edd73eb77a4fc94054", "patch": "@@ -781,8 +781,8 @@ pub struct ModuleS<'a> {\n     // The node id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: Option<NodeId>,\n \n-    resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Mark, Name, Span)>>,\n+    resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, Span)>>,\n     macro_resolutions: RefCell<Vec<(Box<[Ident]>, PathScope, Span)>>,\n \n     // Macro invocations that can expand into items in this module.\n@@ -794,7 +794,7 @@ pub struct ModuleS<'a> {\n     globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n-    traits: RefCell<Option<Box<[(Name, &'a NameBinding<'a>)]>>>,\n+    traits: RefCell<Option<Box<[(Ident, &'a NameBinding<'a>)]>>>,\n \n     // Whether this module is populated. If not populated, any attempt to\n     // access the children must be preceded with a\n@@ -822,9 +822,9 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n-    fn for_each_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        for (&(name, ns), name_resolution) in self.resolutions.borrow().iter() {\n-            name_resolution.borrow().binding.map(|binding| f(name, ns, binding));\n+    fn for_each_child<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n+        for (&(ident, ns), name_resolution) in self.resolutions.borrow().iter() {\n+            name_resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n         }\n     }\n \n@@ -1334,7 +1334,7 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n+    fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n                   -> bool /* true if an error was reported */ {\n         // track extern crates for unused_extern_crate lint\n         if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleS::def_id) {\n@@ -1345,23 +1345,23 @@ impl<'a> Resolver<'a> {\n             NameBindingKind::Import { directive, binding, ref used } if !used.get() => {\n                 used.set(true);\n                 self.used_imports.insert((directive.id, ns));\n-                self.add_to_glob_map(directive.id, name);\n-                self.record_use(name, ns, binding, span)\n+                self.add_to_glob_map(directive.id, ident);\n+                self.record_use(ident, ns, binding, span)\n             }\n             NameBindingKind::Import { .. } => false,\n             NameBindingKind::Ambiguity { b1, b2 } => {\n                 self.ambiguity_errors.push(AmbiguityError {\n-                    span: span, name: name, lexical: false, b1: b1, b2: b2,\n+                    span: span, name: ident.name, lexical: false, b1: b1, b2: b2,\n                 });\n                 true\n             }\n             _ => false\n         }\n     }\n \n-    fn add_to_glob_map(&mut self, id: NodeId, name: Name) {\n+    fn add_to_glob_map(&mut self, id: NodeId, ident: Ident) {\n         if self.make_glob_map {\n-            self.glob_map.entry(id).or_insert_with(FxHashSet).insert(name);\n+            self.glob_map.entry(id).or_insert_with(FxHashSet).insert(ident.name);\n         }\n     }\n \n@@ -1388,7 +1388,7 @@ impl<'a> Resolver<'a> {\n                                       record_used: Option<Span>)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n-            ident = Ident::with_empty_ctxt(ident.name);\n+            ident = ident.unhygienize();\n         }\n \n         // Walk backwards up the ribs in scope.\n@@ -1403,8 +1403,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n-                let name = ident.name;\n-                let item = self.resolve_name_in_module(module, name, ns, false, record_used);\n+                let item = self.resolve_ident_in_module(module, ident, ns, false, record_used);\n                 if let Ok(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -1413,7 +1412,7 @@ impl<'a> Resolver<'a> {\n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_name_in_module(prelude, name, ns, false, None).ok()\n+                        self.resolve_ident_in_module(prelude, ident, ns, false, None).ok()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n@@ -2183,8 +2182,7 @@ impl<'a> Resolver<'a> {\n                             Def::VariantCtor(_, CtorKind::Const) |\n                             Def::Const(..) if !always_binding => {\n                                 // A unit struct/variant or constant pattern.\n-                                let name = ident.node.name;\n-                                self.record_use(name, ValueNS, binding.unwrap(), ident.span);\n+                                self.record_use(ident.node, ValueNS, binding.unwrap(), ident.span);\n                                 Some(PathResolution::new(def))\n                             }\n                             Def::StructCtor(..) | Def::VariantCtor(..) |\n@@ -2363,9 +2361,9 @@ impl<'a> Resolver<'a> {\n             allow_super = false;\n \n             let binding = if let Some(module) = module {\n-                self.resolve_name_in_module(module, ident.name, ns, false, record_used)\n+                self.resolve_ident_in_module(module, ident, ns, false, record_used)\n             } else if opt_ns == Some(MacroNS) {\n-                self.resolve_lexical_macro_path_segment(ident.name, ns, record_used)\n+                self.resolve_lexical_macro_path_segment(ident, ns, record_used)\n             } else {\n                 match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n@@ -2953,16 +2951,15 @@ impl<'a> Resolver<'a> {\n                         in_module_is_extern)) = worklist.pop() {\n             self.populate_module_if_necessary(in_module);\n \n-            in_module.for_each_child(|name, ns, name_binding| {\n+            in_module.for_each_child(|ident, ns, name_binding| {\n \n                 // avoid imports entirely\n                 if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n \n                 // collect results based on the filter function\n-                if name == lookup_name && ns == namespace {\n+                if ident.name == lookup_name && ns == namespace {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n-                        let ident = Ident::with_empty_ctxt(name);\n                         let params = PathParameters::none();\n                         let segment = PathSegment {\n                             identifier: ident,\n@@ -2994,7 +2991,7 @@ impl<'a> Resolver<'a> {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n                     path_segments.push(PathSegment {\n-                        identifier: Ident::with_empty_ctxt(name),\n+                        identifier: ident,\n                         parameters: PathParameters::none(),\n                     });\n \n@@ -3124,13 +3121,13 @@ impl<'a> Resolver<'a> {\n \n     fn report_conflict(&mut self,\n                        parent: Module,\n-                       name: Name,\n+                       ident: Ident,\n                        ns: Namespace,\n                        binding: &NameBinding,\n                        old_binding: &NameBinding) {\n         // Error on the second of two conflicting names\n         if old_binding.span.lo > binding.span.lo {\n-            return self.report_conflict(parent, name, ns, old_binding, binding);\n+            return self.report_conflict(parent, ident, ns, old_binding, binding);\n         }\n \n         let container = match parent.kind {\n@@ -3145,7 +3142,7 @@ impl<'a> Resolver<'a> {\n             false => (\"defined\", \"definition\"),\n         };\n \n-        let span = binding.span;\n+        let (name, span) = (ident.name, binding.span);\n \n         if let Some(s) = self.name_already_seen.get(&name) {\n             if s == &span {"}, {"sha": "b2e31d5490962f62fcd74cb41552b883ad4a90e4", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/59de7f8f04d9122dd776f2edd73eb77a4fc94054/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59de7f8f04d9122dd776f2edd73eb77a4fc94054/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=59de7f8f04d9122dd776f2edd73eb77a4fc94054", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::map::{self, DefCollector};\n use rustc::ty;\n use std::cell::Cell;\n use std::rc::Rc;\n-use syntax::ast::{self, Name};\n+use syntax::ast::{self, Name, Ident};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n@@ -246,7 +246,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let result = match self.resolve_legacy_scope(&invocation.legacy_scope, name, false) {\n             Some(MacroBinding::Legacy(binding)) => Ok(binding.ext.clone()),\n             Some(MacroBinding::Modern(binding)) => Ok(binding.get_macro(self)),\n-            None => match self.resolve_lexical_macro_path_segment(name, MacroNS, None) {\n+            None => match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n                 Ok(binding) => Ok(binding.get_macro(self)),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 _ => {\n@@ -260,7 +260,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         };\n \n         if self.use_extern_macros {\n-            self.current_module.legacy_macro_resolutions.borrow_mut().push((scope, name, span));\n+            self.current_module.legacy_macro_resolutions.borrow_mut().push((scope, path[0], span));\n         }\n         result\n     }\n@@ -269,7 +269,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n impl<'a> Resolver<'a> {\n     // Resolve the initial segment of a non-global macro path (e.g. `foo` in `foo::bar!();`)\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n-                                              name: Name,\n+                                              ident: Ident,\n                                               ns: Namespace,\n                                               record_used: Option<Span>)\n                                               -> Result<&'a NameBinding<'a>, Determinacy> {\n@@ -278,14 +278,15 @@ impl<'a> Resolver<'a> {\n         loop {\n             // Since expanded macros may not shadow the lexical scope (enforced below),\n             // we can ignore unresolved invocations (indicated by the penultimate argument).\n-            match self.resolve_name_in_module(module, name, ns, true, record_used) {\n+            match self.resolve_ident_in_module(module, ident, ns, true, record_used) {\n                 Ok(binding) => {\n                     let span = match record_used {\n                         Some(span) => span,\n                         None => return Ok(binding),\n                     };\n                     match potential_expanded_shadower {\n                         Some(shadower) if shadower.def() != binding.def() => {\n+                            let name = ident.name;\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 span: span, name: name, b1: shadower, b2: binding, lexical: true,\n                             });\n@@ -383,10 +384,10 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        for &(mark, name, span) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(mark, ident, span) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n-            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, name, true);\n-            let resolution = self.resolve_lexical_macro_path_segment(name, MacroNS, Some(span));\n+            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n+            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n             let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n                 (Some(legacy_resolution), Ok(resolution)) => (legacy_resolution, resolution),\n                 _ => continue,\n@@ -396,9 +397,9 @@ impl<'a> Resolver<'a> {\n                 MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n                 MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n             };\n-            let msg1 = format!(\"`{}` could resolve to the macro {} here\", name, participle);\n-            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", name);\n-            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n+            let msg1 = format!(\"`{}` could resolve to the macro {} here\", ident, participle);\n+            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", ident);\n+            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n                 .span_note(legacy_span, &msg1)\n                 .span_note(resolution.span, &msg2)\n                 .emit();"}, {"sha": "7c7908d24010bfb40c92e1d4bba067c6911db3d3", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 58, "deletions": 54, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/59de7f8f04d9122dd776f2edd73eb77a4fc94054/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59de7f8f04d9122dd776f2edd73eb77a4fc94054/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=59de7f8f04d9122dd776f2edd73eb77a4fc94054", "patch": "@@ -21,7 +21,7 @@ use rustc::ty;\n use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n use rustc::hir::def::*;\n \n-use syntax::ast::{Ident, NodeId, Name};\n+use syntax::ast::{Ident, NodeId};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::keywords;\n@@ -35,8 +35,8 @@ use std::mem;\n #[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass<'a> {\n     SingleImport {\n-        target: Name,\n-        source: Name,\n+        target: Ident,\n+        source: Ident,\n         result: PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n     },\n     GlobImport {\n@@ -126,31 +126,32 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    fn resolution(&self, module: Module<'a>, name: Name, ns: Namespace)\n+    fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n                   -> &'a RefCell<NameResolution<'a>> {\n-        *module.resolutions.borrow_mut().entry((name, ns))\n+        *module.resolutions.borrow_mut().entry((ident, ns))\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n \n-    /// Attempts to resolve the supplied name in the given module for the given namespace.\n-    /// If successful, returns the binding corresponding to the name.\n+    /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n     /// Invariant: if `record_used` is `Some`, import resolution must be complete.\n-    pub fn resolve_name_in_module(&mut self,\n-                                  module: Module<'a>,\n-                                  name: Name,\n-                                  ns: Namespace,\n-                                  ignore_unresolved_invocations: bool,\n-                                  record_used: Option<Span>)\n-                                  -> Result<&'a NameBinding<'a>, Determinacy> {\n+    pub fn resolve_ident_in_module(&mut self,\n+                                   module: Module<'a>,\n+                                   ident: Ident,\n+                                   ns: Namespace,\n+                                   ignore_unresolved_invocations: bool,\n+                                   record_used: Option<Span>)\n+                                   -> Result<&'a NameBinding<'a>, Determinacy> {\n+        let ident = ident.unhygienize();\n         self.populate_module_if_necessary(module);\n \n-        let resolution = self.resolution(module, name, ns)\n+        let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n             .map_err(|_| Determined)?; // This happens when there is a cycle of imports\n \n         if let Some(span) = record_used {\n             if let Some(binding) = resolution.binding {\n                 if let Some(shadowed_glob) = resolution.shadows_glob {\n+                    let name = ident.name;\n                     // If we ignore unresolved invocations, we must forbid\n                     // expanded shadowing to avoid time travel.\n                     if ignore_unresolved_invocations &&\n@@ -162,11 +163,11 @@ impl<'a> Resolver<'a> {\n                         });\n                     }\n                 }\n-                if self.record_use(name, ns, binding, span) {\n+                if self.record_use(ident, ns, binding, span) {\n                     return Ok(self.dummy_binding);\n                 }\n                 if !self.is_accessible(binding.vis) {\n-                    self.privacy_errors.push(PrivacyError(span, name, binding));\n+                    self.privacy_errors.push(PrivacyError(span, ident.name, binding));\n                 }\n             }\n \n@@ -194,11 +195,11 @@ impl<'a> Resolver<'a> {\n                     Some(module) => module,\n                     None => return Err(Undetermined),\n                 };\n-                let name = match directive.subclass {\n+                let ident = match directive.subclass {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(module, name, ns, false, None) {\n+                match self.resolve_ident_in_module(module, ident, ns, false, None) {\n                     Err(Determined) => {}\n                     _ => return Err(Undetermined),\n                 }\n@@ -220,7 +221,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_name_in_module(module, name, ns, false, None);\n+                    let result = self.resolve_ident_in_module(module, ident, ns, false, None);\n                     if let Err(Undetermined) = result {\n                         return Err(Undetermined);\n                     }\n@@ -299,12 +300,13 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Define the name or return the existing binding if there is a collision.\n-    pub fn try_define<T>(&mut self, module: Module<'a>, name: Name, ns: Namespace, binding: T)\n+    pub fn try_define<T>(&mut self, module: Module<'a>, ident: Ident, ns: Namespace, binding: T)\n                          -> Result<(), &'a NameBinding<'a>>\n         where T: ToNameBinding<'a>\n     {\n+        let ident = ident.unhygienize();\n         let binding = self.arenas.alloc_name_binding(binding.to_name_binding());\n-        self.update_resolution(module, name, ns, |this, resolution| {\n+        self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {\n                     if !old_binding.is_glob_import() &&\n@@ -347,13 +349,14 @@ impl<'a> Resolver<'a> {\n \n     // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n-    fn update_resolution<T, F>(&mut self, module: Module<'a>, name: Name, ns: Namespace, f: F) -> T\n+    fn update_resolution<T, F>(&mut self, module: Module<'a>, ident: Ident, ns: Namespace, f: F)\n+                               -> T\n         where F: FnOnce(&mut Resolver<'a>, &mut NameResolution<'a>) -> T\n     {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n         let (binding, t) = {\n-            let mut resolution = &mut *self.resolution(module, name, ns).borrow_mut();\n+            let mut resolution = &mut *self.resolution(module, ident, ns).borrow_mut();\n             let old_binding = resolution.binding();\n \n             let t = f(self, resolution);\n@@ -372,7 +375,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.glob_importers.borrow_mut().iter() {\n             if self.is_accessible_from(binding.vis, directive.parent) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, name, ns, imported_binding);\n+                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }\n         }\n \n@@ -508,7 +511,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut indeterminate = false;\n         self.per_ns(|this, ns| {\n             if let Err(Undetermined) = result[ns].get() {\n-                result[ns].set(this.resolve_name_in_module(module, source, ns, false, None));\n+                result[ns].set(this.resolve_ident_in_module(module, source, ns, false, None));\n             } else {\n                 return\n             };\n@@ -564,7 +567,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => return None,\n         };\n \n-        let (name, result) = match directive.subclass {\n+        let (ident, result) = match directive.subclass {\n             SingleImport { source, ref result, .. } => (source, result),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n@@ -586,8 +589,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.per_ns(|this, ns| {\n             if let Ok(binding) = result[ns].get() {\n                 all_ns_err = false;\n-                if this.record_use(name, ns, binding, directive.span) {\n-                    this.resolution(module, name, ns).borrow_mut().binding =\n+                if this.record_use(ident, ns, binding, directive.span) {\n+                    this.resolution(module, ident, ns).borrow_mut().binding =\n                         Some(this.dummy_binding);\n                 }\n             }\n@@ -596,35 +599,36 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| {\n-                match this.resolve_name_in_module(module, name, ns, false, Some(span)) {\n+                match this.resolve_ident_in_module(module, ident, ns, false, Some(span)) {\n                     Ok(_) => all_ns_failed = false,\n                     _ => {}\n                 }\n             });\n \n             return if all_ns_failed {\n                 let resolutions = module.resolutions.borrow();\n-                let names = resolutions.iter().filter_map(|(&(ref n, _), resolution)| {\n-                    if *n == name { return None; } // Never suggest the same name\n+                let names = resolutions.iter().filter_map(|(&(ref i, _), resolution)| {\n+                    if *i == ident { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n-                        NameResolution { binding: Some(_), .. } => Some(n),\n+                        NameResolution { binding: Some(_), .. } => Some(&i.name),\n                         NameResolution { single_imports: SingleImports::None, .. } => None,\n-                        _ => Some(n),\n+                        _ => Some(&i.name),\n                     }\n                 });\n-                let lev_suggestion = match find_best_match_for_name(names, &name.as_str(), None) {\n-                    Some(name) => format!(\". Did you mean to use `{}`?\", name),\n-                    None => \"\".to_owned(),\n-                };\n+                let lev_suggestion =\n+                    match find_best_match_for_name(names, &ident.name.as_str(), None) {\n+                        Some(name) => format!(\". Did you mean to use `{}`?\", name),\n+                        None => \"\".to_owned(),\n+                    };\n                 let module_str = module_to_string(module);\n                 let msg = if &module_str == \"???\" {\n-                    format!(\"no `{}` in the root{}\", name, lev_suggestion)\n+                    format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n                 } else {\n-                    format!(\"no `{}` in `{}`{}\", name, module_str, lev_suggestion)\n+                    format!(\"no `{}` in `{}`{}\", ident, module_str, lev_suggestion)\n                 };\n                 Some(msg)\n             } else {\n-                // `resolve_name_in_module` reported a privacy error.\n+                // `resolve_ident_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);\n                 None\n             }\n@@ -649,18 +653,18 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             if ns == TypeNS && binding.is_extern_crate() {\n                 let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                    (error E0364), consider declaring with `pub`\",\n-                                   name);\n+                                   ident);\n                 self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n             } else if ns == TypeNS {\n                 struct_span_err!(self.session, directive.span, E0365,\n-                                 \"`{}` is private, and cannot be reexported\", name)\n-                    .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n-                    .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n+                                 \"`{}` is private, and cannot be reexported\", ident)\n+                    .span_label(directive.span, &format!(\"reexport of private `{}`\", ident))\n+                    .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                     .emit();\n             } else {\n-                let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n+                let msg = format!(\"`{}` is private, and cannot be reexported\", ident);\n                 let note_msg =\n-                    format!(\"consider marking `{}` as `pub` in the imported module\", name);\n+                    format!(\"consider marking `{}` as `pub` in the imported module\", ident);\n                 struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n                     .emit();\n@@ -697,13 +701,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = module.resolutions.borrow().iter().filter_map(|(name, resolution)| {\n-            resolution.borrow().binding().map(|binding| (*name, binding))\n+        let bindings = module.resolutions.borrow().iter().filter_map(|(&ident, resolution)| {\n+            resolution.borrow().binding().map(|binding| (ident, binding))\n         }).collect::<Vec<_>>();\n-        for ((name, ns), binding) in bindings {\n+        for ((ident, ns), binding) in bindings {\n             if binding.pseudo_vis() == ty::Visibility::Public || self.is_accessible(binding.vis) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, name, ns, imported_binding);\n+                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }\n         }\n \n@@ -722,7 +726,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             reexports = mem::replace(&mut self.macro_exports, Vec::new());\n         }\n \n-        for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n+        for (&(ident, ns), resolution) in module.resolutions.borrow().iter() {\n             let resolution = resolution.borrow();\n             let binding = match resolution.binding {\n                 Some(binding) => binding,\n@@ -736,7 +740,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     if !def.def_id().is_local() {\n                         self.session.cstore.export_macros(def.def_id().krate);\n                     }\n-                    reexports.push(Export { name: name, def: def });\n+                    reexports.push(Export { name: ident.name, def: def });\n                 }\n             }\n \n@@ -745,7 +749,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                    !orig_binding.vis.is_at_least(binding.vis, self) {\n                     let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring its enum as `pub`\",\n-                                      name);\n+                                      ident);\n                     self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, binding.span, msg);\n                 }\n             }"}, {"sha": "2369cc5714ec170ff08ff867e4e0f455c8202b2c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59de7f8f04d9122dd776f2edd73eb77a4fc94054/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59de7f8f04d9122dd776f2edd73eb77a4fc94054/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=59de7f8f04d9122dd776f2edd73eb77a4fc94054", "patch": "@@ -47,10 +47,14 @@ impl Ident {\n         Ident { name: name, ctxt: SyntaxContext::empty() }\n     }\n \n-   /// Maps a string to an identifier with an empty syntax context.\n-   pub fn from_str(s: &str) -> Ident {\n-       Ident::with_empty_ctxt(Symbol::intern(s))\n-   }\n+    /// Maps a string to an identifier with an empty syntax context.\n+    pub fn from_str(s: &str) -> Ident {\n+        Ident::with_empty_ctxt(Symbol::intern(s))\n+    }\n+\n+    pub fn unhygienize(&self) -> Ident {\n+        Ident { name: self.name, ctxt: SyntaxContext::empty() }\n+    }\n }\n \n impl fmt::Debug for Ident {"}]}