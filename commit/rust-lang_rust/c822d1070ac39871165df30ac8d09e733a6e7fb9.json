{"sha": "c822d1070ac39871165df30ac8d09e733a6e7fb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MjJkMTA3MGFjMzk4NzExNjVkZjMwYWM4ZDA5ZTczM2E2ZTdmYjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-27T18:35:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-27T18:35:51Z"}, "message": "auto merge of #8581 : FlaPer87/rust/issue/8232, r=bblum\n\nAs for now, rekillable is an unsafe function, instead, it should behave\r\njust like unkillable by encapsulating unsafe code within an unsafe\r\nblock.\r\n\r\nThis patch does that and removes unsafe blocks that were encapsulating\r\nrekillable calls throughout rust's libs.\r\n\r\nFixes #8232", "tree": {"sha": "10a9f4f2282ba97a33ecde8d45984183608fafb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10a9f4f2282ba97a33ecde8d45984183608fafb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c822d1070ac39871165df30ac8d09e733a6e7fb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c822d1070ac39871165df30ac8d09e733a6e7fb9", "html_url": "https://github.com/rust-lang/rust/commit/c822d1070ac39871165df30ac8d09e733a6e7fb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c822d1070ac39871165df30ac8d09e733a6e7fb9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7841b77676662ed657da7b8911dd0989ac743ca0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7841b77676662ed657da7b8911dd0989ac743ca0", "html_url": "https://github.com/rust-lang/rust/commit/7841b77676662ed657da7b8911dd0989ac743ca0"}, {"sha": "cc59d9609740bd325a796ba0831af15b87f502ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc59d9609740bd325a796ba0831af15b87f502ed", "html_url": "https://github.com/rust-lang/rust/commit/cc59d9609740bd325a796ba0831af15b87f502ed"}], "stats": {"total": 135, "additions": 87, "deletions": 48}, "files": [{"sha": "1952c35eb9df295b3d8c342f8aa2d4f5ce05448e", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 19, "deletions": 29, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c822d1070ac39871165df30ac8d09e733a6e7fb9/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c822d1070ac39871165df30ac8d09e733a6e7fb9/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=c822d1070ac39871165df30ac8d09e733a6e7fb9", "patch": "@@ -135,9 +135,7 @@ impl<Q:Send> Sem<Q> {\n         do task::unkillable {\n             do (|| {\n                 self.acquire();\n-                unsafe {\n-                    do task::rekillable { blk() }\n-                }\n+                do task::rekillable { blk() }\n             }).finally {\n                 self.release();\n             }\n@@ -234,10 +232,8 @@ impl<'self> Condvar<'self> {\n                 // signaller already sent -- I mean 'unconditionally' in contrast\n                 // with acquire().)\n                 do (|| {\n-                    unsafe {\n-                        do task::rekillable {\n-                            let _ = WaitEnd.take_unwrap().recv();\n-                        }\n+                    do task::rekillable {\n+                        let _ = WaitEnd.take_unwrap().recv();\n                     }\n                 }).finally {\n                     // Reacquire the condvar. Note this is back in the unkillable\n@@ -516,14 +512,12 @@ impl RWLock {\n      * 'write' from other tasks will run concurrently with this one.\n      */\n     pub fn write<U>(&self, blk: &fn() -> U) -> U {\n-        unsafe {\n-            do task::unkillable {\n-                (&self.order_lock).acquire();\n-                do (&self.access_lock).access {\n-                    (&self.order_lock).release();\n-                    do task::rekillable {\n-                        blk()\n-                    }\n+        do task::unkillable {\n+            (&self.order_lock).acquire();\n+            do (&self.access_lock).access {\n+                (&self.order_lock).release();\n+                do task::rekillable {\n+                    blk()\n                 }\n             }\n         }\n@@ -562,16 +556,14 @@ impl RWLock {\n         // which can't happen until T2 finishes the downgrade-read entirely.\n         // The astute reader will also note that making waking writers use the\n         // order_lock is better for not starving readers.\n-        unsafe {\n-            do task::unkillable {\n-                (&self.order_lock).acquire();\n-                do (&self.access_lock).access_cond |cond| {\n-                    (&self.order_lock).release();\n-                    do task::rekillable {\n-                        let opt_lock = Just(&self.order_lock);\n-                        blk(&Condvar { sem: cond.sem, order: opt_lock,\n-                                       token: NonCopyable::new() })\n-                    }\n+        do task::unkillable {\n+            (&self.order_lock).acquire();\n+            do (&self.access_lock).access_cond |cond| {\n+                (&self.order_lock).release();\n+                do task::rekillable {\n+                    let opt_lock = Just(&self.order_lock);\n+                    blk(&Condvar { sem: cond.sem, order: opt_lock,\n+                                   token: NonCopyable::new() })\n                 }\n             }\n         }\n@@ -606,10 +598,8 @@ impl RWLock {\n             (&self.access_lock).acquire();\n             (&self.order_lock).release();\n             do (|| {\n-                unsafe {\n-                    do task::rekillable {\n-                        blk(RWLockWriteMode { lock: self, token: NonCopyable::new() })\n-                    }\n+                do task::rekillable {\n+                    blk(RWLockWriteMode { lock: self, token: NonCopyable::new() })\n                 }\n             }).finally {\n                 let writer_or_last_reader;"}, {"sha": "94df621ce766626b81062d603fc0c48c1a68d66d", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c822d1070ac39871165df30ac8d09e733a6e7fb9/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c822d1070ac39871165df30ac8d09e733a6e7fb9/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=c822d1070ac39871165df30ac8d09e733a6e7fb9", "patch": "@@ -647,7 +647,11 @@ impl Death {\n     /// All calls must be paired with a preceding call to inhibit_kill.\n     #[inline]\n     pub fn allow_kill(&mut self, already_failing: bool) {\n-        rtassert!(self.unkillable != 0);\n+        if self.unkillable == 0 {\n+            // we need to decrement the counter before failing.\n+            self.unkillable -= 1;\n+            fail!(\"Cannot enter a rekillable() block without a surrounding unkillable()\");\n+        }\n         self.unkillable -= 1;\n         if self.unkillable == 0 {\n             rtassert!(self.kill_handle.is_some());"}, {"sha": "f872c2614b9f6b4e167d3f81b28f07f6380c5b8c", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 63, "deletions": 18, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c822d1070ac39871165df30ac8d09e733a6e7fb9/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c822d1070ac39871165df30ac8d09e733a6e7fb9/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=c822d1070ac39871165df30ac8d09e733a6e7fb9", "patch": "@@ -597,21 +597,36 @@ pub fn unkillable<U>(f: &fn() -> U) -> U {\n     }\n }\n \n-/// The inverse of unkillable. Only ever to be used nested in unkillable().\n-pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n+/**\n+ * Makes killable a task marked as unkillable. This\n+ * is meant to be used only nested in unkillable.\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * do task::unkillable {\n+ *     do task::rekillable {\n+ *          // Task is killable\n+ *     }\n+ *    // Task is unkillable again\n+ * }\n+ */\n+pub fn rekillable<U>(f: &fn() -> U) -> U {\n     use rt::task::Task;\n \n-    if in_green_task_context() {\n-        let t = Local::unsafe_borrow::<Task>();\n-        do (|| {\n-            (*t).death.allow_kill((*t).unwinder.unwinding);\n+    unsafe {\n+        if in_green_task_context() {\n+            let t = Local::unsafe_borrow::<Task>();\n+            do (|| {\n+                (*t).death.allow_kill((*t).unwinder.unwinding);\n+                f()\n+            }).finally {\n+                (*t).death.inhibit_kill((*t).unwinder.unwinding);\n+            }\n+        } else {\n+            // FIXME(#3095): As in unkillable().\n             f()\n-        }).finally {\n-            (*t).death.inhibit_kill((*t).unwinder.unwinding);\n         }\n-    } else {\n-        // FIXME(#3095): As in unkillable().\n-        f()\n     }\n }\n \n@@ -636,8 +651,8 @@ fn test_kill_unkillable_task() {\n     }\n }\n \n-#[ignore(reason = \"linked failure\")]\n #[test]\n+#[ignore(cfg(windows))]\n fn test_kill_rekillable_task() {\n     use rt::test::*;\n \n@@ -646,19 +661,49 @@ fn test_kill_rekillable_task() {\n     do run_in_newsched_task {\n         do task::try {\n             do task::unkillable {\n-                unsafe {\n-                    do task::rekillable {\n-                        do task::spawn {\n-                            fail!();\n-                        }\n+                do task::rekillable {\n+                    do task::spawn {\n+                        fail!();\n                     }\n                 }\n             }\n         };\n     }\n }\n \n-#[test] #[should_fail]\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(windows))]\n+fn test_rekillable_not_nested() {\n+    do rekillable {\n+        // This should fail before\n+        // receiving anything since\n+        // this block should be nested\n+        // into a unkillable block.\n+        deschedule();\n+    }\n+}\n+\n+\n+#[test]\n+#[ignore(cfg(windows))]\n+fn test_rekillable_nested_failure() {\n+\n+    let result = do task::try {\n+        do unkillable {\n+            do rekillable {\n+                let (port,chan) = comm::stream();\n+                do task::spawn { chan.send(()); fail!(); }\n+                port.recv(); // wait for child to exist\n+                port.recv(); // block forever, expect to get killed.\n+            }\n+        }\n+    };\n+    assert!(result.is_err());\n+}\n+\n+\n+#[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_cant_dup_task_builder() {\n     let mut builder = task();\n     builder.unlinked();"}]}