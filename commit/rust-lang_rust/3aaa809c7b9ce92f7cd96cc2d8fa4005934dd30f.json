{"sha": "3aaa809c7b9ce92f7cd96cc2d8fa4005934dd30f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYWE4MDljN2I5Y2U5MmY3Y2Q5NmNjMmQ4ZmE0MDA1OTM0ZGQzMGY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-07-13T14:45:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-13T14:45:16Z"}, "message": "Rollup merge of #42926 - Havvy:doc-path-ext, r=steveklabnik\n\nDocument what happens on failure in path ext is_file is_dir\n\nr? @steveklabnik\n\nAlso, what other ways could there be an error that gets discarded and returns false? Should we list them all? Should we say that any errors trying to access the metadata at that path causes it to return false, even if there might be a file or directory there?\n\nShould I add a See also link to the original functions that do return Results?", "tree": {"sha": "e95a7a91fdbbe618f6cbca656fea0895f1d22a8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e95a7a91fdbbe618f6cbca656fea0895f1d22a8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3aaa809c7b9ce92f7cd96cc2d8fa4005934dd30f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3aaa809c7b9ce92f7cd96cc2d8fa4005934dd30f", "html_url": "https://github.com/rust-lang/rust/commit/3aaa809c7b9ce92f7cd96cc2d8fa4005934dd30f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3aaa809c7b9ce92f7cd96cc2d8fa4005934dd30f/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2c0707872082c890f332178f59fd02eea5b98f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c0707872082c890f332178f59fd02eea5b98f3", "html_url": "https://github.com/rust-lang/rust/commit/b2c0707872082c890f332178f59fd02eea5b98f3"}, {"sha": "a01c91c8bc251f46b94c5124f31df6bc094fb0a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a01c91c8bc251f46b94c5124f31df6bc094fb0a1", "html_url": "https://github.com/rust-lang/rust/commit/a01c91c8bc251f46b94c5124f31df6bc094fb0a1"}], "stats": {"total": 34, "additions": 34, "deletions": 0}, "files": [{"sha": "3f466d5031e7b6f4bd0d71838c0a11350dd517ec", "filename": "src/libstd/path.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3aaa809c7b9ce92f7cd96cc2d8fa4005934dd30f/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aaa809c7b9ce92f7cd96cc2d8fa4005934dd30f/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=3aaa809c7b9ce92f7cd96cc2d8fa4005934dd30f", "patch": "@@ -2216,12 +2216,22 @@ impl Path {\n     /// This function will traverse symbolic links to query information about the\n     /// destination file. In case of broken symbolic links this will return `false`.\n     ///\n+    /// If you cannot access the directory containing the file, e.g. because of a\n+    /// permission error, this will return `false`.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::path::Path;\n     /// assert_eq!(Path::new(\"does_not_exist.txt\").exists(), false);\n     /// ```\n+    ///\n+    /// # See Also\n+    ///\n+    /// This is a convenience function that coerces errors to false. If you want to\n+    /// check errors, call [fs::metadata].\n+    ///\n+    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn exists(&self) -> bool {\n         fs::metadata(self).is_ok()\n@@ -2232,13 +2242,25 @@ impl Path {\n     /// This function will traverse symbolic links to query information about the\n     /// destination file. In case of broken symbolic links this will return `false`.\n     ///\n+    /// If you cannot access the directory containing the file, e.g. because of a\n+    /// permission error, this will return `false`.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::path::Path;\n     /// assert_eq!(Path::new(\"./is_a_directory/\").is_file(), false);\n     /// assert_eq!(Path::new(\"a_file.txt\").is_file(), true);\n     /// ```\n+    ///\n+    /// # See Also\n+    ///\n+    /// This is a convenience function that coerces errors to false. If you want to\n+    /// check errors, call [fs::metadata] and handle its Result. Then call\n+    /// [fs::Metadata::is_file] if it was Ok.\n+    ///\n+    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n+    /// [fs::Metadata::is_file]: ../../std/fs/struct.Metadata.html#method.is_file\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn is_file(&self) -> bool {\n         fs::metadata(self).map(|m| m.is_file()).unwrap_or(false)\n@@ -2249,13 +2271,25 @@ impl Path {\n     /// This function will traverse symbolic links to query information about the\n     /// destination file. In case of broken symbolic links this will return `false`.\n     ///\n+    /// If you cannot access the directory containing the file, e.g. because of a\n+    /// permission error, this will return `false`.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::path::Path;\n     /// assert_eq!(Path::new(\"./is_a_directory/\").is_dir(), true);\n     /// assert_eq!(Path::new(\"a_file.txt\").is_dir(), false);\n     /// ```\n+    ///\n+    /// # See Also\n+    ///\n+    /// This is a convenience function that coerces errors to false. If you want to\n+    /// check errors, call [fs::metadata] and handle its Result. Then call\n+    /// [fs::Metadata::is_dir] if it was Ok.\n+    ///\n+    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n+    /// [fs::Metadata::is_dir]: ../../std/fs/struct.Metadata.html#method.is_dir\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn is_dir(&self) -> bool {\n         fs::metadata(self).map(|m| m.is_dir()).unwrap_or(false)"}]}