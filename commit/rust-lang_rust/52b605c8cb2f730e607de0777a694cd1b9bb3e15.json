{"sha": "52b605c8cb2f730e607de0777a694cd1b9bb3e15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYjYwNWM4Y2IyZjczMGU2MDdkZTA3NzdhNjk0Y2QxYjliYjNlMTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-24T04:15:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-24T04:15:08Z"}, "message": "Auto merge of #72362 - matthewjasper:remove-rescope, r=nikomatsakis\n\nRemove ReScope\n\n`ReScope` is unnecessary now that AST borrowck is gone and we're erasing the results of region inference in function bodies. This removes about as much of the old regionck code as possible without having to enable NLL fully.\n\ncc #68261\n\nr? @nikomatsakis", "tree": {"sha": "76b2d8ffdbf91406cecabaf3c63ed9e9104b25a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76b2d8ffdbf91406cecabaf3c63ed9e9104b25a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52b605c8cb2f730e607de0777a694cd1b9bb3e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52b605c8cb2f730e607de0777a694cd1b9bb3e15", "html_url": "https://github.com/rust-lang/rust/commit/52b605c8cb2f730e607de0777a694cd1b9bb3e15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52b605c8cb2f730e607de0777a694cd1b9bb3e15/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3137f8e2d141d7d7c65040a718a9193f50e1282e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3137f8e2d141d7d7c65040a718a9193f50e1282e", "html_url": "https://github.com/rust-lang/rust/commit/3137f8e2d141d7d7c65040a718a9193f50e1282e"}, {"sha": "9754b3fc1d9d24bc1e65136e5798cc5a6d226a4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9754b3fc1d9d24bc1e65136e5798cc5a6d226a4f", "html_url": "https://github.com/rust-lang/rust/commit/9754b3fc1d9d24bc1e65136e5798cc5a6d226a4f"}], "stats": {"total": 3373, "additions": 614, "deletions": 2759}, "files": [{"sha": "c2dae6ba4f83db32e9e5dfe0120e35f21d092950", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -332,7 +332,6 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n-            | ty::ReScope(_)\n             | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n             | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),"}, {"sha": "70a2122a9ea5d26c611b07269f9de70c5522d53f", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -619,7 +619,6 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n             | ty::ReVar(..)\n             | ty::ReEmpty(_)\n             | ty::ReStatic\n-            | ty::ReScope(..)\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(..) => {\n                 // see common code below"}, {"sha": "cc479aa17ce95e94735d73cbac12d0dabc453766", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 52, "deletions": 147, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -61,7 +61,6 @@ use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n-use rustc_middle::middle::region;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{\n     self,\n@@ -81,58 +80,12 @@ pub mod nice_region_error;\n \n pub(super) fn note_and_explain_region(\n     tcx: TyCtxt<'tcx>,\n-    region_scope_tree: &region::ScopeTree,\n     err: &mut DiagnosticBuilder<'_>,\n     prefix: &str,\n     region: ty::Region<'tcx>,\n     suffix: &str,\n ) {\n     let (description, span) = match *region {\n-        ty::ReScope(scope) => {\n-            let new_string;\n-            let unknown_scope =\n-                || format!(\"{}unknown scope: {:?}{}.  Please report a bug.\", prefix, scope, suffix);\n-            let span = scope.span(tcx, region_scope_tree);\n-            let hir_id = scope.hir_id(region_scope_tree);\n-            let tag = match hir_id.and_then(|hir_id| tcx.hir().find(hir_id)) {\n-                Some(Node::Block(_)) => \"block\",\n-                Some(Node::Expr(expr)) => match expr.kind {\n-                    hir::ExprKind::Call(..) => \"call\",\n-                    hir::ExprKind::MethodCall(..) => \"method call\",\n-                    hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                    hir::ExprKind::Match(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n-                    hir::ExprKind::Match(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n-                    hir::ExprKind::Match(..) => \"match\",\n-                    _ => \"expression\",\n-                },\n-                Some(Node::Stmt(_)) => \"statement\",\n-                Some(Node::Item(it)) => item_scope_tag(&it),\n-                Some(Node::TraitItem(it)) => trait_item_scope_tag(&it),\n-                Some(Node::ImplItem(it)) => impl_item_scope_tag(&it),\n-                Some(_) | None => {\n-                    err.span_note(span, &unknown_scope());\n-                    return;\n-                }\n-            };\n-            let scope_decorated_tag = match scope.data {\n-                region::ScopeData::Node => tag,\n-                region::ScopeData::CallSite => \"scope of call-site for function\",\n-                region::ScopeData::Arguments => \"scope of function body\",\n-                region::ScopeData::Destruction => {\n-                    new_string = format!(\"destruction scope surrounding {}\", tag);\n-                    &new_string[..]\n-                }\n-                region::ScopeData::Remainder(first_statement_index) => {\n-                    new_string = format!(\n-                        \"block suffix following statement {}\",\n-                        first_statement_index.index()\n-                    );\n-                    &new_string[..]\n-                }\n-            };\n-            explain_span(tcx, scope_decorated_tag, span)\n-        }\n-\n         ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n             msg_span_from_free_region(tcx, region)\n         }\n@@ -284,7 +237,6 @@ fn explain_span(tcx: TyCtxt<'tcx>, heading: &str, span: Span) -> (String, Option\n \n pub fn unexpected_hidden_region_diagnostic(\n     tcx: TyCtxt<'tcx>,\n-    region_scope_tree: Option<&region::ScopeTree>,\n     span: Span,\n     hidden_ty: Ty<'tcx>,\n     hidden_region: ty::Region<'tcx>,\n@@ -297,64 +249,56 @@ pub fn unexpected_hidden_region_diagnostic(\n     );\n \n     // Explain the region we are capturing.\n-    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) = hidden_region {\n-        // Assuming regionck succeeded (*), we ought to always be\n-        // capturing *some* region from the fn header, and hence it\n-        // ought to be free. So under normal circumstances, we will go\n-        // down this path which gives a decent human readable\n-        // explanation.\n-        //\n-        // (*) if not, the `tainted_by_errors` field would be set to\n-        // `Some(ErrorReported)` in any case, so we wouldn't be here at all.\n-        note_and_explain_free_region(\n-            tcx,\n-            &mut err,\n-            &format!(\"hidden type `{}` captures \", hidden_ty),\n-            hidden_region,\n-            \"\",\n-        );\n-    } else {\n-        // Ugh. This is a painful case: the hidden region is not one\n-        // that we can easily summarize or explain. This can happen\n-        // in a case like\n-        // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n-        //\n-        // ```\n-        // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n-        //   if condition() { a } else { b }\n-        // }\n-        // ```\n-        //\n-        // Here the captured lifetime is the intersection of `'a` and\n-        // `'b`, which we can't quite express.\n-\n-        if let Some(region_scope_tree) = region_scope_tree {\n-            // If the `region_scope_tree` is available, this is being\n-            // invoked from the \"region inferencer error\". We can at\n-            // least report a really cryptic error for now.\n-            note_and_explain_region(\n+    match hidden_region {\n+        ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n+            // All lifetimes shorter than the function body are `empty` in\n+            // lexical region resolution. The default explanation of \"an empty\n+            // lifetime\" isn't really accurate here.\n+            let message = format!(\n+                \"hidden type `{}` captures lifetime smaller than the function body\",\n+                hidden_ty\n+            );\n+            err.span_note(span, &message);\n+        }\n+        ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) => {\n+            // Assuming regionck succeeded (*), we ought to always be\n+            // capturing *some* region from the fn header, and hence it\n+            // ought to be free. So under normal circumstances, we will go\n+            // down this path which gives a decent human readable\n+            // explanation.\n+            //\n+            // (*) if not, the `tainted_by_errors` field would be set to\n+            // `Some(ErrorReported)` in any case, so we wouldn't be here at all.\n+            note_and_explain_free_region(\n                 tcx,\n-                region_scope_tree,\n                 &mut err,\n                 &format!(\"hidden type `{}` captures \", hidden_ty),\n                 hidden_region,\n                 \"\",\n             );\n-        } else {\n-            // If the `region_scope_tree` is *unavailable*, this is\n-            // being invoked by the code that comes *after* region\n-            // inferencing. This is a bug, as the region inferencer\n-            // ought to have noticed the failed constraint and invoked\n-            // error reporting, which in turn should have prevented us\n-            // from getting trying to infer the hidden type\n-            // completely.\n-            tcx.sess.delay_span_bug(\n-                span,\n-                &format!(\n-                    \"hidden type captures unexpected lifetime `{:?}` \\\n-                     but no region inference failure\",\n-                    hidden_region,\n-                ),\n+        }\n+        _ => {\n+            // Ugh. This is a painful case: the hidden region is not one\n+            // that we can easily summarize or explain. This can happen\n+            // in a case like\n+            // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n+            //\n+            // ```\n+            // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n+            //   if condition() { a } else { b }\n+            // }\n+            // ```\n+            //\n+            // Here the captured lifetime is the intersection of `'a` and\n+            // `'b`, which we can't quite express.\n+\n+            // We can at least report a really cryptic error for now.\n+            note_and_explain_region(\n+                tcx,\n+                &mut err,\n+                &format!(\"hidden type `{}` captures \", hidden_ty),\n+                hidden_region,\n+                \"\",\n             );\n         }\n     }\n@@ -363,11 +307,7 @@ pub fn unexpected_hidden_region_diagnostic(\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn report_region_errors(\n-        &self,\n-        region_scope_tree: &region::ScopeTree,\n-        errors: &Vec<RegionResolutionError<'tcx>>,\n-    ) {\n+    pub fn report_region_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -390,17 +330,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // general bit of code that displays the error information\n                     RegionResolutionError::ConcreteFailure(origin, sub, sup) => {\n                         if sub.is_placeholder() || sup.is_placeholder() {\n-                            self.report_placeholder_failure(region_scope_tree, origin, sub, sup)\n-                                .emit();\n+                            self.report_placeholder_failure(origin, sub, sup).emit();\n                         } else {\n-                            self.report_concrete_failure(region_scope_tree, origin, sub, sup)\n-                                .emit();\n+                            self.report_concrete_failure(origin, sub, sup).emit();\n                         }\n                     }\n \n                     RegionResolutionError::GenericBoundFailure(origin, param_ty, sub) => {\n                         self.report_generic_bound_failure(\n-                            region_scope_tree,\n                             origin.span(),\n                             Some(origin),\n                             param_ty,\n@@ -417,29 +354,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         sup_r,\n                     ) => {\n                         if sub_r.is_placeholder() {\n-                            self.report_placeholder_failure(\n-                                region_scope_tree,\n-                                sub_origin,\n-                                sub_r,\n-                                sup_r,\n-                            )\n-                            .emit();\n+                            self.report_placeholder_failure(sub_origin, sub_r, sup_r).emit();\n                         } else if sup_r.is_placeholder() {\n-                            self.report_placeholder_failure(\n-                                region_scope_tree,\n-                                sup_origin,\n-                                sub_r,\n-                                sup_r,\n-                            )\n-                            .emit();\n+                            self.report_placeholder_failure(sup_origin, sub_r, sup_r).emit();\n                         } else {\n                             self.report_sub_sup_conflict(\n-                                region_scope_tree,\n-                                var_origin,\n-                                sub_origin,\n-                                sub_r,\n-                                sup_origin,\n-                                sup_r,\n+                                var_origin, sub_origin, sub_r, sup_origin, sup_r,\n                             );\n                         }\n                     }\n@@ -460,13 +380,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // value.\n                         let sub_r = self.tcx.mk_region(ty::ReEmpty(var_universe));\n \n-                        self.report_placeholder_failure(\n-                            region_scope_tree,\n-                            sup_origin,\n-                            sub_r,\n-                            sup_r,\n-                        )\n-                        .emit();\n+                        self.report_placeholder_failure(sup_origin, sub_r, sup_r).emit();\n                     }\n \n                     RegionResolutionError::MemberConstraintFailure {\n@@ -477,7 +391,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n                         unexpected_hidden_region_diagnostic(\n                             self.tcx,\n-                            Some(region_scope_tree),\n                             span,\n                             hidden_ty,\n                             member_region,\n@@ -1754,19 +1667,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn report_generic_bound_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         span: Span,\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) {\n-        self.construct_generic_bound_failure(region_scope_tree, span, origin, bound_kind, sub)\n-            .emit();\n+        self.construct_generic_bound_failure(span, origin, bound_kind, sub).emit();\n     }\n \n     pub fn construct_generic_bound_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         span: Span,\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n@@ -1918,7 +1828,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ));\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n@@ -1936,7 +1845,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     fn report_sub_sup_conflict(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         var_origin: RegionVariableOrigin,\n         sub_origin: SubregionOrigin<'tcx>,\n         sub_region: Region<'tcx>,\n@@ -1947,7 +1855,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         note_and_explain_region(\n             self.tcx,\n-            region_scope_tree,\n             &mut err,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n@@ -1973,7 +1880,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if sub_expected == sup_expected && sub_found == sup_found {\n                     note_and_explain_region(\n                         self.tcx,\n-                        region_scope_tree,\n                         &mut err,\n                         \"...but the lifetime must also be valid for \",\n                         sub_region,\n@@ -1995,7 +1901,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         note_and_explain_region(\n             self.tcx,\n-            region_scope_tree,\n             &mut err,\n             \"but, the lifetime must be valid for \",\n             sub_region,"}, {"sha": "efe52689550c47c82da93bbd55945e1ac1b881b1", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -8,7 +8,6 @@ use rustc_span::source_map::Span;\n mod different_lifetimes;\n mod find_anon_type;\n mod named_anon_conflict;\n-mod outlives_closure;\n mod placeholder_error;\n mod static_impl_trait;\n mod trait_impl_difference;\n@@ -57,7 +56,6 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n                 ErrorReported\n             })\n             .or_else(|| self.try_report_anon_anon_conflict())\n-            .or_else(|| self.try_report_outlives_closure())\n             .or_else(|| self.try_report_static_impl_trait())\n             .or_else(|| self.try_report_impl_not_conforming_to_trait())\n     }"}, {"sha": "fc858a497597e5bad0f2e02bd935c33089a201d5", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,117 +0,0 @@\n-//! Error Reporting for Anonymous Region Lifetime Errors\n-//! where both the regions are anonymous.\n-\n-use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n-use crate::infer::SubregionOrigin;\n-use rustc_errors::ErrorReported;\n-use rustc_hir::{Expr, ExprKind::Closure, Node};\n-use rustc_middle::ty::RegionKind;\n-\n-impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    /// Print the error message for lifetime errors when binding escapes a closure.\n-    ///\n-    /// Consider a case where we have\n-    ///\n-    /// ```no_run\n-    /// fn with_int<F>(f: F) where F: FnOnce(&isize) {\n-    ///     let x = 3;\n-    ///     f(&x);\n-    /// }\n-    /// fn main() {\n-    ///     let mut x = None;\n-    ///     with_int(|y| x = Some(y));\n-    /// }\n-    /// ```\n-    ///\n-    /// the output will be\n-    ///\n-    /// ```text\n-    ///     let mut x = None;\n-    ///         ----- borrowed data cannot be stored into here...\n-    ///     with_int(|y| x = Some(y));\n-    ///              ---          ^ cannot be stored outside of its closure\n-    ///              |\n-    ///              ...because it cannot outlive this closure\n-    /// ```\n-    pub(super) fn try_report_outlives_closure(&self) -> Option<ErrorReported> {\n-        if let Some(SubSupConflict(_, origin, ref sub_origin, _, ref sup_origin, sup_region)) =\n-            self.error\n-        {\n-            // #45983: when trying to assign the contents of an argument to a binding outside of a\n-            // closure, provide a specific message pointing this out.\n-            if let (\n-                &SubregionOrigin::BindingTypeIsNotValidAtDecl(ref external_span),\n-                &RegionKind::ReFree(ref free_region),\n-            ) = (&sub_origin, sup_region)\n-            {\n-                let hir = &self.tcx().hir();\n-                if let Some(def_id) = free_region.scope.as_local() {\n-                    let hir_id = hir.as_local_hir_id(def_id);\n-                    if let Node::Expr(Expr { kind: Closure(_, _, _, closure_span, None), .. }) =\n-                        hir.get(hir_id)\n-                    {\n-                        let sup_sp = sup_origin.span();\n-                        let origin_sp = origin.span();\n-                        let mut err = self.tcx().sess.struct_span_err(\n-                            sup_sp,\n-                            \"borrowed data cannot be stored outside of its closure\",\n-                        );\n-                        err.span_label(sup_sp, \"cannot be stored outside of its closure\");\n-                        if origin_sp == sup_sp || origin_sp.contains(sup_sp) {\n-                            // // sup_sp == origin.span():\n-                            //\n-                            // let mut x = None;\n-                            //     ----- borrowed data cannot be stored into here...\n-                            // with_int(|y| x = Some(y));\n-                            //          ---          ^ cannot be stored outside of its closure\n-                            //          |\n-                            //          ...because it cannot outlive this closure\n-                            //\n-                            // // origin.contains(&sup_sp):\n-                            //\n-                            // let mut f: Option<&u32> = None;\n-                            //     ----- borrowed data cannot be stored into here...\n-                            // closure_expecting_bound(|x: &'x u32| {\n-                            //                         ------------ ... because it cannot outlive this closure\n-                            //     f = Some(x);\n-                            //              ^ cannot be stored outside of its closure\n-                            err.span_label(\n-                                *external_span,\n-                                \"borrowed data cannot be stored into here...\",\n-                            );\n-                            err.span_label(\n-                                *closure_span,\n-                                \"...because it cannot outlive this closure\",\n-                            );\n-                        } else {\n-                            // FIXME: the wording for this case could be much improved\n-                            //\n-                            // let mut lines_to_use: Vec<&CrateId> = Vec::new();\n-                            //                           - cannot infer an appropriate lifetime...\n-                            // let push_id = |installed_id: &CrateId| {\n-                            //     -------   ------------------------ borrowed data cannot outlive this closure\n-                            //     |\n-                            //     ...so that variable is valid at time of its declaration\n-                            //     lines_to_use.push(installed_id);\n-                            //                       ^^^^^^^^^^^^ cannot be stored outside of its closure\n-                            err.span_label(origin_sp, \"cannot infer an appropriate lifetime...\");\n-                            err.span_label(\n-                                *external_span,\n-                                \"...so that variable is valid at time of its \\\n-                                            declaration\",\n-                            );\n-                            err.span_label(\n-                                *closure_span,\n-                                \"borrowed data cannot outlive this closure\",\n-                            );\n-                        }\n-                        err.emit();\n-                        return Some(ErrorReported);\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-}"}, {"sha": "8fbb89da5af416d5da50dd35ac2186393031794f", "filename": "src/librustc_infer/infer/error_reporting/note.rs", "status": "modified", "additions": 10, "deletions": 418, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,7 +1,6 @@\n use crate::infer::error_reporting::{note_and_explain_region, ObligationCauseExt};\n use crate::infer::{self, InferCtxt, SubregionOrigin};\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n-use rustc_middle::middle::region;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{self, Region};\n \n@@ -38,65 +37,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n                 err.span_note(span, &format!(\"...so that closure can access `{}`\", var_name));\n             }\n-            infer::InfStackClosure(span) => {\n-                err.span_note(span, \"...so that closure does not outlive its stack frame\");\n-            }\n-            infer::InvokeClosure(span) => {\n-                err.span_note(span, \"...so that closure is not invoked outside its lifetime\");\n-            }\n-            infer::DerefPointer(span) => {\n-                err.span_note(span, \"...so that pointer is not dereferenced outside its lifetime\");\n-            }\n-            infer::ClosureCapture(span, id) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so that captured variable `{}` does not outlive the \\\n-                                        enclosing closure\",\n-                        self.tcx.hir().name(id)\n-                    ),\n-                );\n-            }\n-            infer::IndexSlice(span) => {\n-                err.span_note(span, \"...so that slice is not indexed outside the lifetime\");\n-            }\n             infer::RelateObjectBound(span) => {\n                 err.span_note(span, \"...so that it can be closed over into an object\");\n             }\n-            infer::CallRcvr(span) => {\n-                err.span_note(span, \"...so that method receiver is valid for the method call\");\n-            }\n-            infer::CallArg(span) => {\n-                err.span_note(span, \"...so that argument is valid for the call\");\n-            }\n             infer::CallReturn(span) => {\n                 err.span_note(span, \"...so that return value is valid for the call\");\n             }\n-            infer::Operand(span) => {\n-                err.span_note(span, \"...so that operand is valid for operation\");\n-            }\n-            infer::AddrOf(span) => {\n-                err.span_note(span, \"...so that reference is valid at the time of borrow\");\n-            }\n-            infer::AutoBorrow(span) => {\n-                err.span_note(span, \"...so that auto-reference is valid at the time of borrow\");\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so type `{}` of expression is valid during the \\\n-                                        expression\",\n-                        self.ty_to_string(t)\n-                    ),\n-                );\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                err.span_note(span, \"...so that variable is valid at time of its declaration\");\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                err.span_note(span, \"...so that a type/lifetime parameter is in scope here\");\n-            }\n             infer::DataBorrowed(ty, span) => {\n                 err.span_note(\n                     span,\n@@ -126,25 +72,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     ),\n                 );\n             }\n-            infer::RelateDefaultParamBound(span, t) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so that type parameter instantiated with `{}`, will \\\n-                                        meet its declared lifetime bounds\",\n-                        self.ty_to_string(t)\n-                    ),\n-                );\n-            }\n             infer::RelateRegionParamBound(span) => {\n                 err.span_note(\n                     span,\n                     \"...so that the declared lifetime parameter bounds are satisfied\",\n                 );\n             }\n-            infer::SafeDestructor(span) => {\n-                err.span_note(span, \"...so that references are valid when the destructor runs\");\n-            }\n             infer::CompareImplMethodObligation { span, .. } => {\n                 err.span_note(\n                     span,\n@@ -157,7 +90,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub(super) fn report_concrete_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n         sup: Region<'tcx>,\n@@ -166,10 +98,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 let mut err = self.report_and_explain_type_error(trace, &terr);\n-                note_and_explain_region(self.tcx, region_scope_tree, &mut err, \"\", sup, \"...\");\n+                note_and_explain_region(self.tcx, &mut err, \"\", sup, \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...does not necessarily outlive \",\n                     sub,\n@@ -187,15 +118,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...the reference is valid for \",\n                     sub,\n                     \"...\",\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...but the borrowed content is only valid for \",\n                     sup,\n@@ -215,122 +144,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...the borrowed pointer is valid for \",\n                     sub,\n                     \"...\",\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     &format!(\"...but `{}` is only valid for \", var_name),\n                     sup,\n                     \"\",\n                 );\n                 err\n             }\n-            infer::InfStackClosure(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"...the closure must be valid for \",\n-                    sub,\n-                    \"...\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"...but the closure's stack frame is only valid \\\n-                                                  for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::InvokeClosure(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0315,\n-                    \"cannot invoke closure outside of its lifetime\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the closure is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::DerefPointer(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0473,\n-                    \"dereference of reference outside its lifetime\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the reference is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::ClosureCapture(span, id) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0474,\n-                    \"captured variable `{}` does not outlive the \\\n-                                                enclosing closure\",\n-                    self.tcx.hir().name(id)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"captured variable is valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"closure is valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::IndexSlice(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0475,\n-                    \"index of slice outside its lifetime\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the slice is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n             infer::RelateObjectBound(span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n@@ -339,17 +166,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of the source pointer does not outlive \\\n                                                 lifetime bound of the object type\"\n                 );\n+                note_and_explain_region(self.tcx, &mut err, \"object type is valid for \", sub, \"\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"object type is valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"source pointer is only valid for \",\n                     sup,\n@@ -367,22 +186,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.ty_to_string(ty)\n                 );\n                 match *sub {\n-                    ty::ReStatic => note_and_explain_region(\n-                        self.tcx,\n-                        region_scope_tree,\n-                        &mut err,\n-                        \"type must satisfy \",\n-                        sub,\n-                        \"\",\n-                    ),\n-                    _ => note_and_explain_region(\n-                        self.tcx,\n-                        region_scope_tree,\n-                        &mut err,\n-                        \"type must outlive \",\n-                        sub,\n-                        \"\",\n-                    ),\n+                    ty::ReStatic => {\n+                        note_and_explain_region(self.tcx, &mut err, \"type must satisfy \", sub, \"\")\n+                    }\n+                    _ => note_and_explain_region(self.tcx, &mut err, \"type must outlive \", sub, \"\"),\n                 }\n                 err\n             }\n@@ -391,77 +198,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"lifetime parameter instantiated with \",\n                     sup,\n                     \"\",\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"but lifetime parameter must outlive \",\n                     sub,\n                     \"\",\n                 );\n                 err\n             }\n-            infer::RelateDefaultParamBound(span, ty) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0479,\n-                    \"the type `{}` (provided as the value of a type \\\n-                                                parameter) is not valid at this point\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"type must outlive \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::CallRcvr(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0480,\n-                    \"lifetime of method receiver does not outlive the \\\n-                                                method call\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the receiver is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::CallArg(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0481,\n-                    \"lifetime of function argument does not outlive \\\n-                                                the function call\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the function argument is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n             infer::CallReturn(span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n@@ -472,148 +222,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"the return value is only valid for \",\n                     sup,\n                     \"\",\n                 );\n                 err\n             }\n-            infer::Operand(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0483,\n-                    \"lifetime of operand does not outlive the \\\n-                                                operation\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the operand is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::AddrOf(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0484,\n-                    \"reference is not valid at the time of borrow\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the borrow is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::AutoBorrow(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0485,\n-                    \"automatically reference is not valid at the time \\\n-                                                of borrow\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the automatic borrow is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0486,\n-                    \"type of expression contains references that are \\\n-                                                not valid during the expression: `{}`\",\n-                    self.ty_to_string(t)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"type is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::SafeDestructor(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0487,\n-                    \"unsafe use of destructor: destructor might be \\\n-                                                called while references are dead\"\n-                );\n-                // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"superregion: \",\n-                    sup,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"subregion: \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0488,\n-                    \"lifetime of variable does not enclose its \\\n-                                                declaration\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the variable is only valid for \",\n-                    sup,\n-                    \"\",\n-                );\n-                err\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0489,\n-                    \"type/lifetime parameter not in scope here\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the parameter is only valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                err\n-            }\n             infer::DataBorrowed(ty, span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n@@ -622,22 +237,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"a value of type `{}` is borrowed for too long\",\n                     self.ty_to_string(ty)\n                 );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the type is valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"but the borrow lasts for \",\n-                    sup,\n-                    \"\",\n-                );\n+                note_and_explain_region(self.tcx, &mut err, \"the type is valid for \", sub, \"\");\n+                note_and_explain_region(self.tcx, &mut err, \"but the borrow lasts for \", sup, \"\");\n                 err\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n@@ -648,17 +249,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"in type `{}`, reference has a longer lifetime than the data it references\",\n                     self.ty_to_string(ty)\n                 );\n+                note_and_explain_region(self.tcx, &mut err, \"the pointer is valid for \", sub, \"\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the pointer is valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"but the referenced data is only valid for \",\n                     sup,\n@@ -683,7 +276,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub(super) fn report_placeholder_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         placeholder_origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n         sup: Region<'tcx>,\n@@ -695,7 +287,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 self.report_and_explain_type_error(trace, &terr)\n             }\n \n-            _ => self.report_concrete_failure(region_scope_tree, placeholder_origin, sub, sup),\n+            _ => self.report_concrete_failure(placeholder_origin, sub, sup),\n         }\n     }\n }"}, {"sha": "d975038b010b9dabdd320349117a621a5fc8ad49", "filename": "src/librustc_infer/infer/free_regions.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -5,7 +5,6 @@\n \n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::middle::region;\n use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n \n /// Combines a `region::ScopeTree` (which governs relationships between\n@@ -21,21 +20,13 @@ pub struct RegionRelations<'a, 'tcx> {\n     /// The context used to fetch the region maps.\n     pub context: DefId,\n \n-    /// The region maps for the given context.\n-    pub region_scope_tree: &'a region::ScopeTree,\n-\n     /// Free-region relationships.\n     pub free_regions: &'a FreeRegionMap<'tcx>,\n }\n \n impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        context: DefId,\n-        region_scope_tree: &'a region::ScopeTree,\n-        free_regions: &'a FreeRegionMap<'tcx>,\n-    ) -> Self {\n-        Self { tcx, context, region_scope_tree, free_regions }\n+    pub fn new(tcx: TyCtxt<'tcx>, context: DefId, free_regions: &'a FreeRegionMap<'tcx>) -> Self {\n+        Self { tcx, context, free_regions }\n     }\n \n     pub fn lub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> Region<'tcx> {"}, {"sha": "b4cfcb3a1c3256c708450472cad47b7cf2c9d33e", "filename": "src/librustc_infer/infer/freshen.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -127,7 +127,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n-            | ty::ReScope(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)"}, {"sha": "5d3e8f440d6fd6fd44785b99c6907f6a20f45fd4", "filename": "src/librustc_infer/infer/lexical_region_resolve/graphviz.rs", "status": "removed", "additions": 0, "deletions": 253, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,253 +0,0 @@\n-//! This module provides linkage between libgraphviz traits and\n-//! `rustc_trait_selection::infer::region_constraints`, generating a\n-//! rendering of the graph represented by the list of `Constraint`\n-//! instances (which make up the edges of the graph), as well as the\n-//! origin for each constraint (which are attached to the labels on\n-//! each edge).\n-\n-/// For clarity, rename the graphviz crate locally to dot.\n-use graphviz as dot;\n-\n-use super::Constraint;\n-use crate::infer::region_constraints::RegionConstraintData;\n-use crate::infer::RegionRelations;\n-use crate::infer::SubregionOrigin;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::DefIndex;\n-use rustc_middle::middle::region;\n-use rustc_middle::ty;\n-\n-use std::borrow::Cow;\n-use std::collections::btree_map::BTreeMap;\n-use std::collections::hash_map::Entry::Vacant;\n-use std::env;\n-use std::fs;\n-use std::io;\n-use std::sync::atomic::{AtomicBool, Ordering};\n-\n-fn print_help_message() {\n-    println!(\n-        \"\\\n--Z print-region-graph by default prints a region constraint graph for every \\n\\\n-function body, to the path `constraints.nodeXXX.dot`, where the XXX is \\n\\\n-replaced with the node id of the function under analysis.                   \\n\\\n-                                                                            \\n\\\n-To select one particular function body, set `RUST_REGION_GRAPH_NODE=XXX`,   \\n\\\n-where XXX is the node id desired.                                           \\n\\\n-                                                                            \\n\\\n-To generate output to some path other than the default                      \\n\\\n-`constraints.nodeXXX.dot`, set `RUST_REGION_GRAPH=/path/desired.dot`;  \\n\\\n-occurrences of the character `%` in the requested path will be replaced with\\n\\\n-the node id of the function under analysis.                                 \\n\\\n-                                                                            \\n\\\n-(Since you requested help via RUST_REGION_GRAPH=help, no region constraint  \\n\\\n-graphs will be printed.                                                     \\n\\\n-\"\n-    );\n-}\n-\n-pub fn maybe_print_constraints_for<'a, 'tcx>(\n-    region_data: &RegionConstraintData<'tcx>,\n-    region_rels: &RegionRelations<'a, 'tcx>,\n-) {\n-    let tcx = region_rels.tcx;\n-    let context = region_rels.context;\n-\n-    if !tcx.sess.opts.debugging_opts.print_region_graph {\n-        return;\n-    }\n-\n-    let requested_node = env::var(\"RUST_REGION_GRAPH_NODE\")\n-        .ok()\n-        .and_then(|s| s.parse().map(DefIndex::from_u32).ok());\n-\n-    if requested_node.is_some() && requested_node != Some(context.index) {\n-        return;\n-    }\n-\n-    let requested_output = env::var(\"RUST_REGION_GRAPH\");\n-    debug!(\"requested_output: {:?} requested_node: {:?}\", requested_output, requested_node);\n-\n-    let output_path = {\n-        let output_template = match requested_output {\n-            Ok(ref s) if s == \"help\" => {\n-                static PRINTED_YET: AtomicBool = AtomicBool::new(false);\n-                if !PRINTED_YET.load(Ordering::SeqCst) {\n-                    print_help_message();\n-                    PRINTED_YET.store(true, Ordering::SeqCst);\n-                }\n-                return;\n-            }\n-\n-            Ok(other_path) => other_path,\n-            Err(_) => \"constraints.node%.dot\".to_string(),\n-        };\n-\n-        if output_template.is_empty() {\n-            panic!(\"empty string provided as RUST_REGION_GRAPH\");\n-        }\n-\n-        if output_template.contains('%') {\n-            let mut new_str = String::new();\n-            for c in output_template.chars() {\n-                if c == '%' {\n-                    new_str.push_str(&context.index.as_u32().to_string());\n-                } else {\n-                    new_str.push(c);\n-                }\n-            }\n-            new_str\n-        } else {\n-            output_template\n-        }\n-    };\n-\n-    if let Err(e) = dump_region_data_to(region_rels, &region_data.constraints, &output_path) {\n-        let msg = format!(\"io error dumping region constraints: {}\", e);\n-        tcx.sess.err(&msg)\n-    }\n-}\n-\n-struct ConstraintGraph<'a, 'tcx> {\n-    graph_name: String,\n-    region_rels: &'a RegionRelations<'a, 'tcx>,\n-    map: &'a BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n-    node_ids: FxHashMap<Node, usize>,\n-}\n-\n-#[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]\n-enum Node {\n-    RegionVid(ty::RegionVid),\n-    Region(ty::RegionKind),\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Copy)]\n-enum Edge<'tcx> {\n-    Constraint(Constraint<'tcx>),\n-    EnclScope(region::Scope, region::Scope),\n-}\n-\n-impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n-    fn new(\n-        name: String,\n-        region_rels: &'a RegionRelations<'a, 'tcx>,\n-        map: &'a ConstraintMap<'tcx>,\n-    ) -> ConstraintGraph<'a, 'tcx> {\n-        let mut i = 0;\n-        let mut node_ids = FxHashMap::default();\n-        {\n-            let mut add_node = |node| {\n-                if let Vacant(e) = node_ids.entry(node) {\n-                    e.insert(i);\n-                    i += 1;\n-                }\n-            };\n-\n-            for (n1, n2) in map.keys().map(|c| constraint_to_nodes(c)) {\n-                add_node(n1);\n-                add_node(n2);\n-            }\n-\n-            region_rels.region_scope_tree.each_encl_scope(|sub, sup| {\n-                add_node(Node::Region(ty::ReScope(sub)));\n-                add_node(Node::Region(ty::ReScope(sup)));\n-            });\n-        }\n-\n-        ConstraintGraph { map, node_ids, region_rels, graph_name: name }\n-    }\n-}\n-\n-impl<'a, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'tcx> {\n-    type Node = Node;\n-    type Edge = Edge<'tcx>;\n-    fn graph_id(&self) -> dot::Id<'_> {\n-        dot::Id::new(&*self.graph_name).unwrap()\n-    }\n-    fn node_id(&self, n: &Node) -> dot::Id<'_> {\n-        let node_id = match self.node_ids.get(n) {\n-            Some(node_id) => node_id,\n-            None => bug!(\"no node_id found for node: {:?}\", n),\n-        };\n-        let name = || format!(\"node_{}\", node_id);\n-\n-        dot::Id::new(name())\n-            .unwrap_or_else(|_| bug!(\"failed to create graphviz node identified by {}\", name()))\n-    }\n-    fn node_label(&self, n: &Node) -> dot::LabelText<'_> {\n-        match *n {\n-            Node::RegionVid(n_vid) => dot::LabelText::label(format!(\"{:?}\", n_vid)),\n-            Node::Region(n_rgn) => dot::LabelText::label(format!(\"{:?}\", n_rgn)),\n-        }\n-    }\n-    fn edge_label(&self, e: &Edge<'_>) -> dot::LabelText<'_> {\n-        match *e {\n-            Edge::Constraint(ref c) => {\n-                dot::LabelText::label(format!(\"{:?}\", self.map.get(c).unwrap()))\n-            }\n-            Edge::EnclScope(..) => dot::LabelText::label(\"(enclosed)\".to_owned()),\n-        }\n-    }\n-}\n-\n-fn constraint_to_nodes(c: &Constraint<'_>) -> (Node, Node) {\n-    match *c {\n-        Constraint::VarSubVar(rv_1, rv_2) => (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n-        Constraint::RegSubVar(r_1, rv_2) => (Node::Region(*r_1), Node::RegionVid(rv_2)),\n-        Constraint::VarSubReg(rv_1, r_2) => (Node::RegionVid(rv_1), Node::Region(*r_2)),\n-        Constraint::RegSubReg(r_1, r_2) => (Node::Region(*r_1), Node::Region(*r_2)),\n-    }\n-}\n-\n-fn edge_to_nodes(e: &Edge<'_>) -> (Node, Node) {\n-    match *e {\n-        Edge::Constraint(ref c) => constraint_to_nodes(c),\n-        Edge::EnclScope(sub, sup) => {\n-            (Node::Region(ty::ReScope(sub)), Node::Region(ty::ReScope(sup)))\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n-    type Node = Node;\n-    type Edge = Edge<'tcx>;\n-    fn nodes(&self) -> dot::Nodes<'_, Node> {\n-        let set = self.node_ids.keys().cloned().collect::<FxHashSet<_>>();\n-        debug!(\"constraint graph has {} nodes\", set.len());\n-        set.into_iter().collect()\n-    }\n-    fn edges(&self) -> dot::Edges<'_, Edge<'tcx>> {\n-        debug!(\"constraint graph has {} edges\", self.map.len());\n-        let mut v: Vec<_> = self.map.keys().map(|e| Edge::Constraint(*e)).collect();\n-        self.region_rels\n-            .region_scope_tree\n-            .each_encl_scope(|sub, sup| v.push(Edge::EnclScope(sub, sup)));\n-        debug!(\"region graph has {} edges\", v.len());\n-        Cow::Owned(v)\n-    }\n-    fn source(&self, edge: &Edge<'tcx>) -> Node {\n-        let (n1, _) = edge_to_nodes(edge);\n-        debug!(\"edge {:?} has source {:?}\", edge, n1);\n-        n1\n-    }\n-    fn target(&self, edge: &Edge<'tcx>) -> Node {\n-        let (_, n2) = edge_to_nodes(edge);\n-        debug!(\"edge {:?} has target {:?}\", edge, n2);\n-        n2\n-    }\n-}\n-\n-pub type ConstraintMap<'tcx> = BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n-\n-fn dump_region_data_to<'a, 'tcx>(\n-    region_rels: &RegionRelations<'a, 'tcx>,\n-    map: &ConstraintMap<'tcx>,\n-    path: &str,\n-) -> io::Result<()> {\n-    debug!(\"dump_region_data map (len: {}) path: {}\", map.len(), path);\n-    let g = ConstraintGraph::new(\"region_data\".to_string(), region_rels, map);\n-    debug!(\"dump_region_data calling render\");\n-    let mut v = Vec::new();\n-    dot::render(&g, &mut v).unwrap();\n-    fs::write(path, &v)\n-}"}, {"sha": "fcf1949933b1137c58437b279143a0a4e43f62ce", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 41, "deletions": 74, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -18,13 +18,11 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use rustc_middle::ty::{ReLateBound, RePlaceholder, ReScope, ReVar};\n+use rustc_middle::ty::{ReLateBound, RePlaceholder, ReVar};\n use rustc_middle::ty::{Region, RegionVid};\n use rustc_span::Span;\n use std::fmt;\n \n-mod graphviz;\n-\n /// This function performs lexical region resolution given a complete\n /// set of constraints and variable origins. It performs a fixed-point\n /// iteration to find region values which satisfy all constraints,\n@@ -49,7 +47,10 @@ pub fn resolve<'tcx>(\n             let mut values = resolver.infer_variable_values(&mut errors);\n             let re_erased = region_rels.tcx.lifetimes.re_erased;\n \n-            values.values.iter_mut().for_each(|v| *v = VarValue::Value(re_erased));\n+            values.values.iter_mut().for_each(|v| match *v {\n+                VarValue::Value(ref mut r) => *r = re_erased,\n+                VarValue::ErrorValue => {}\n+            });\n             (values, errors)\n         }\n         RegionckMode::Erase { suppress_errors: true } => {\n@@ -146,7 +147,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             self.region_rels.context,\n             self.dump_constraints(self.region_rels)\n         );\n-        graphviz::maybe_print_constraints_for(&self.data, self.region_rels);\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n@@ -290,8 +290,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         // Find all the \"upper bounds\" -- that is, each region `b` such that\n         // `r0 <= b` must hold.\n-        let (member_upper_bounds, _) =\n-            self.collect_concrete_regions(graph, member_vid, OUTGOING, None);\n+        let (member_upper_bounds, ..) =\n+            self.collect_bounding_regions(graph, member_vid, OUTGOING, None);\n \n         // Get an iterator over the *available choice* -- that is,\n         // each choice region `c` where `lb <= c` and `c <= ub` for all the\n@@ -423,15 +423,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         match *b_data {\n             VarValue::Value(cur_region) => {\n-                // Identical scopes can show up quite often, if the fixed point\n-                // iteration converges slowly. Skip them. This is purely an\n-                // optimization.\n-                if let (ReScope(a_scope), ReScope(cur_scope)) = (a_region, cur_region) {\n-                    if a_scope == cur_scope {\n-                        return false;\n-                    }\n-                }\n-\n                 // This is a specialized version of the `lub_concrete_regions`\n                 // check below for a common case, here purely as an\n                 // optimization.\n@@ -525,8 +516,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 self.tcx().lifetimes.re_static\n             }\n \n-            (&ReEmpty(_), r @ (ReEarlyBound(_) | ReFree(_) | ReScope(_)))\n-            | (r @ (ReEarlyBound(_) | ReFree(_) | ReScope(_)), &ReEmpty(_)) => {\n+            (&ReEmpty(_), r @ (ReEarlyBound(_) | ReFree(_)))\n+            | (r @ (ReEarlyBound(_) | ReFree(_)), &ReEmpty(_)) => {\n                 // All empty regions are less than early-bound, free,\n                 // and scope regions.\n                 r\n@@ -551,46 +542,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 }\n             }\n \n-            (&ReEarlyBound(_) | &ReFree(_), &ReScope(s_id))\n-            | (&ReScope(s_id), &ReEarlyBound(_) | &ReFree(_)) => {\n-                // A \"free\" region can be interpreted as \"some region\n-                // at least as big as fr.scope\".  So, we can\n-                // reasonably compare free regions and scopes:\n-                let fr_scope = match (a, b) {\n-                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n-                        self.region_rels.region_scope_tree.early_free_scope(self.tcx(), br)\n-                    }\n-                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n-                        self.region_rels.region_scope_tree.free_scope(self.tcx(), fr)\n-                    }\n-                    _ => bug!(),\n-                };\n-                let r_id =\n-                    self.region_rels.region_scope_tree.nearest_common_ancestor(fr_scope, s_id);\n-                if r_id == fr_scope {\n-                    // if the free region's scope `fr.scope` is bigger than\n-                    // the scope region `s_id`, then the LUB is the free\n-                    // region itself:\n-                    match (a, b) {\n-                        (_, &ReScope(_)) => return a,\n-                        (&ReScope(_), _) => return b,\n-                        _ => bug!(),\n-                    }\n-                }\n-\n-                // otherwise, we don't know what the free region is,\n-                // so we must conservatively say the LUB is static:\n-                self.tcx().lifetimes.re_static\n-            }\n-\n-            (&ReScope(a_id), &ReScope(b_id)) => {\n-                // The region corresponding to an outer block is a\n-                // subtype of the region corresponding to an inner\n-                // block.\n-                let lub = self.region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n-                self.tcx().mk_region(ReScope(lub))\n-            }\n-\n             (&ReEarlyBound(_) | &ReFree(_), &ReEarlyBound(_) | &ReFree(_)) => {\n                 self.region_rels.lub_free_regions(a, b)\n             }\n@@ -659,7 +610,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     if !self.sub_concrete_regions(a_region, b_region) {\n                         debug!(\n                             \"collect_errors: region error at {:?}: \\\n-                             cannot verify that {:?}={:?} <= {:?}\",\n+                            cannot verify that {:?}={:?} <= {:?}\",\n                             origin, a_vid, a_region, b_region\n                         );\n                         *a_data = VarValue::ErrorValue;\n@@ -716,7 +667,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         graph: &RegionGraph<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n-        debug!(\"collect_var_errors\");\n+        debug!(\"collect_var_errors, var_data = {:#?}\", var_data.values);\n \n         // This is the best way that I have found to suppress\n         // duplicate and related errors. Basically we keep a set of\n@@ -815,10 +766,10 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n-        let (mut lower_bounds, lower_dup) =\n-            self.collect_concrete_regions(graph, node_idx, INCOMING, Some(dup_vec));\n-        let (mut upper_bounds, upper_dup) =\n-            self.collect_concrete_regions(graph, node_idx, OUTGOING, Some(dup_vec));\n+        let (mut lower_bounds, lower_vid_bounds, lower_dup) =\n+            self.collect_bounding_regions(graph, node_idx, INCOMING, Some(dup_vec));\n+        let (mut upper_bounds, _, upper_dup) =\n+            self.collect_bounding_regions(graph, node_idx, OUTGOING, Some(dup_vec));\n \n         if lower_dup || upper_dup {\n             return;\n@@ -874,15 +825,22 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // If we have a scenario like `exists<'a> { forall<'b> { 'b:\n         // 'a } }`, we wind up without any lower-bound -- all we have\n         // are placeholders as upper bounds, but the universe of the\n-        // variable `'a` doesn't permit those placeholders.\n+        // variable `'a`, or some variable that `'a` has to outlive, doesn't\n+        // permit those placeholders.\n+        let min_universe = lower_vid_bounds\n+            .into_iter()\n+            .map(|vid| self.var_infos[vid].universe)\n+            .min()\n+            .expect(\"lower_vid_bounds should at least include `node_idx`\");\n+\n         for upper_bound in &upper_bounds {\n             if let ty::RePlaceholder(p) = upper_bound.region {\n-                if node_universe.cannot_name(p.universe) {\n+                if min_universe.cannot_name(p.universe) {\n                     let origin = self.var_infos[node_idx].origin;\n                     errors.push(RegionResolutionError::UpperBoundUniverseConflict(\n                         node_idx,\n                         origin,\n-                        node_universe,\n+                        min_universe,\n                         upper_bound.origin.clone(),\n                         upper_bound.region,\n                     ));\n@@ -904,13 +862,24 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         );\n     }\n \n-    fn collect_concrete_regions(\n+    /// Collects all regions that \"bound\" the variable `orig_node_idx` in the\n+    /// given direction.\n+    ///\n+    /// If `dup_vec` is `Some` it's used to track duplicates between successive\n+    /// calls of this function.\n+    ///\n+    /// The return tuple fields are:\n+    /// - a list of all concrete regions bounding the given region.\n+    /// - the set of all region variables bounding the given region.\n+    /// - a `bool` that's true if the returned region variables overlap with\n+    ///   those returned by a previous call for another region.\n+    fn collect_bounding_regions(\n         &self,\n         graph: &RegionGraph<'tcx>,\n         orig_node_idx: RegionVid,\n         dir: Direction,\n         mut dup_vec: Option<&mut IndexVec<RegionVid, Option<RegionVid>>>,\n-    ) -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n+    ) -> (Vec<RegionAndOrigin<'tcx>>, FxHashSet<RegionVid>, bool) {\n         struct WalkState<'tcx> {\n             set: FxHashSet<RegionVid>,\n             stack: Vec<RegionVid>,\n@@ -929,9 +898,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // direction specified\n         process_edges(&self.data, &mut state, graph, orig_node_idx, dir);\n \n-        while !state.stack.is_empty() {\n-            let node_idx = state.stack.pop().unwrap();\n-\n+        while let Some(node_idx) = state.stack.pop() {\n             // check whether we've visited this node on some previous walk\n             if let Some(dup_vec) = &mut dup_vec {\n                 if dup_vec[node_idx].is_none() {\n@@ -949,8 +916,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             process_edges(&self.data, &mut state, graph, node_idx, dir);\n         }\n \n-        let WalkState { result, dup_found, .. } = state;\n-        return (result, dup_found);\n+        let WalkState { result, dup_found, set, .. } = state;\n+        return (result, set, dup_found);\n \n         fn process_edges<'tcx>(\n             this: &RegionConstraintData<'tcx>,"}, {"sha": "30af7d06744d78f3a20181ed72e29f643c3e613e", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 71, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -20,7 +20,6 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-use rustc_middle::middle::region;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::ConstEvalResult;\n use rustc_middle::traits::select;\n@@ -378,22 +377,6 @@ pub enum SubregionOrigin<'tcx> {\n     /// Arose from a subtyping relation\n     Subtype(Box<TypeTrace<'tcx>>),\n \n-    /// Stack-allocated closures cannot outlive innermost loop\n-    /// or function so as to ensure we only require finite stack\n-    InfStackClosure(Span),\n-\n-    /// Invocation of closure must be within its lifetime\n-    InvokeClosure(Span),\n-\n-    /// Dereference of reference must be within its lifetime\n-    DerefPointer(Span),\n-\n-    /// Closure bound must not outlive captured variables\n-    ClosureCapture(Span, hir::HirId),\n-\n-    /// Index into slice must be within its lifetime\n-    IndexSlice(Span),\n-\n     /// When casting `&'a T` to an `&'b Trait` object,\n     /// relating `'a` to `'b`\n     RelateObjectBound(Span),\n@@ -406,10 +389,6 @@ pub enum SubregionOrigin<'tcx> {\n     /// that must outlive some other region.\n     RelateRegionParamBound(Span),\n \n-    /// A bound placed on type parameters that states that must outlive\n-    /// the moment of their instantiation.\n-    RelateDefaultParamBound(Span, Ty<'tcx>),\n-\n     /// Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n \n@@ -422,36 +401,9 @@ pub enum SubregionOrigin<'tcx> {\n     /// (&'a &'b T) where a >= b\n     ReferenceOutlivesReferent(Ty<'tcx>, Span),\n \n-    /// Type or region parameters must be in scope.\n-    ParameterInScope(ParameterOrigin, Span),\n-\n-    /// The type T of an expression E must outlive the lifetime for E.\n-    ExprTypeIsNotInScope(Ty<'tcx>, Span),\n-\n-    /// A `ref b` whose region does not enclose the decl site\n-    BindingTypeIsNotValidAtDecl(Span),\n-\n-    /// Regions appearing in a method receiver must outlive method call\n-    CallRcvr(Span),\n-\n-    /// Regions appearing in a function argument must outlive func call\n-    CallArg(Span),\n-\n     /// Region in return type of invoked fn must enclose call\n     CallReturn(Span),\n \n-    /// Operands must be in scope\n-    Operand(Span),\n-\n-    /// Region resulting from a `&` expr must enclose the `&` expr\n-    AddrOf(Span),\n-\n-    /// An auto-borrow that does not enclose the expr where it occurs\n-    AutoBorrow(Span),\n-\n-    /// Region constraint arriving from destructor safety\n-    SafeDestructor(Span),\n-\n     /// Comparing the signature and requirements of an impl method against\n     /// the containing trait.\n     CompareImplMethodObligation {\n@@ -1260,7 +1212,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn resolve_regions_and_report_errors(\n         &self,\n         region_context: DefId,\n-        region_map: &region::ScopeTree,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n         mode: RegionckMode,\n     ) {\n@@ -1280,12 +1231,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .into_infos_and_data()\n         };\n \n-        let region_rels = &RegionRelations::new(\n-            self.tcx,\n-            region_context,\n-            region_map,\n-            outlives_env.free_region_map(),\n-        );\n+        let region_rels =\n+            &RegionRelations::new(self.tcx, region_context, outlives_env.free_region_map());\n \n         let (lexical_region_resolutions, errors) =\n             lexical_region_resolve::resolve(region_rels, var_infos, data, mode);\n@@ -1299,7 +1246,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(region_map, &errors);\n+            self.report_region_errors(&errors);\n         }\n     }\n \n@@ -1809,29 +1756,14 @@ impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n             Subtype(ref a) => a.span(),\n-            InfStackClosure(a) => a,\n-            InvokeClosure(a) => a,\n-            DerefPointer(a) => a,\n-            ClosureCapture(a, _) => a,\n-            IndexSlice(a) => a,\n             RelateObjectBound(a) => a,\n             RelateParamBound(a, _) => a,\n             RelateRegionParamBound(a) => a,\n-            RelateDefaultParamBound(a, _) => a,\n             Reborrow(a) => a,\n             ReborrowUpvar(a, _) => a,\n             DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n-            ParameterInScope(_, a) => a,\n-            ExprTypeIsNotInScope(_, a) => a,\n-            BindingTypeIsNotValidAtDecl(a) => a,\n-            CallRcvr(a) => a,\n-            CallArg(a) => a,\n             CallReturn(a) => a,\n-            Operand(a) => a,\n-            AddrOf(a) => a,\n-            AutoBorrow(a) => a,\n-            SafeDestructor(a) => a,\n             CompareImplMethodObligation { span, .. } => span,\n         }\n     }"}, {"sha": "f45b224275574d6f3c802e3e4d42838c5a4eda67", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -758,11 +758,9 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n \n     pub fn universe(&self, region: Region<'tcx>) -> ty::UniverseIndex {\n         match *region {\n-            ty::ReScope(..)\n-            | ty::ReStatic\n-            | ty::ReErased\n-            | ty::ReFree(..)\n-            | ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n+            ty::ReStatic | ty::ReErased | ty::ReFree(..) | ty::ReEarlyBound(..) => {\n+                ty::UniverseIndex::ROOT\n+            }\n             ty::ReEmpty(ui) => ui,\n             ty::RePlaceholder(placeholder) => placeholder.universe,\n             ty::ReVar(vid) => self.var_universe(vid),"}, {"sha": "ef6247881c0be12995dba134bf176f38d38046ff", "filename": "src/librustc_middle/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -87,9 +87,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n                 index.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n-            ty::ReScope(scope) => {\n-                scope.hash_stable(hcx, hasher);\n-            }\n             ty::ReFree(ref free_region) => {\n                 free_region.hash_stable(hcx, hasher);\n             }"}, {"sha": "943a065a8b5e8ef0fed990a8e4bd799bb8fd2eee", "filename": "src/librustc_middle/middle/region.rs", "status": "modified", "additions": 2, "deletions": 158, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -7,7 +7,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/borrow_check.html\n \n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n-use crate::ty::{self, DefIdTree, TyCtxt};\n+use crate::ty::TyCtxt;\n use rustc_hir as hir;\n use rustc_hir::Node;\n \n@@ -333,7 +333,7 @@ pub struct YieldData {\n     pub source: hir::YieldSource,\n }\n \n-impl<'tcx> ScopeTree {\n+impl ScopeTree {\n     pub fn record_scope_parent(&mut self, child: Scope, parent: Option<(Scope, ScopeDepth)>) {\n         debug!(\"{:?}.parent = {:?}\", child, parent);\n \n@@ -348,24 +348,6 @@ impl<'tcx> ScopeTree {\n         }\n     }\n \n-    pub fn each_encl_scope<E>(&self, mut e: E)\n-    where\n-        E: FnMut(Scope, Scope),\n-    {\n-        for (&child, &parent) in &self.parent_map {\n-            e(child, parent.0)\n-        }\n-    }\n-\n-    pub fn each_var_scope<E>(&self, mut e: E)\n-    where\n-        E: FnMut(&hir::ItemLocalId, Scope),\n-    {\n-        for (child, &parent) in self.var_map.iter() {\n-            e(child, parent)\n-        }\n-    }\n-\n     pub fn opt_destruction_scope(&self, n: hir::ItemLocalId) -> Option<Scope> {\n         self.destruction_scopes.get(&n).cloned()\n     }\n@@ -406,12 +388,6 @@ impl<'tcx> ScopeTree {\n         self.parent_map.get(&id).cloned().map(|(p, _)| p)\n     }\n \n-    /// Returns the narrowest scope that encloses `id`, if any.\n-    #[allow(dead_code)] // used in cfg\n-    pub fn encl_scope(&self, id: Scope) -> Scope {\n-        self.opt_encl_scope(id).unwrap()\n-    }\n-\n     /// Returns the lifetime of the local variable `var_id`\n     pub fn var_scope(&self, var_id: hir::ItemLocalId) -> Scope {\n         self.var_map\n@@ -448,17 +424,6 @@ impl<'tcx> ScopeTree {\n         None\n     }\n \n-    /// Returns the lifetime of the variable `id`.\n-    pub fn var_region(&self, id: hir::ItemLocalId) -> ty::RegionKind {\n-        let scope = ty::ReScope(self.var_scope(id));\n-        debug!(\"var_region({:?}) = {:?}\", id, scope);\n-        scope\n-    }\n-\n-    pub fn scopes_intersect(&self, scope1: Scope, scope2: Scope) -> bool {\n-        self.is_subscope_of(scope1, scope2) || self.is_subscope_of(scope2, scope1)\n-    }\n-\n     /// Returns `true` if `subscope` is equal to or is lexically nested inside `superscope`, and\n     /// `false` otherwise.\n     pub fn is_subscope_of(&self, subscope: Scope, superscope: Scope) -> bool {\n@@ -479,127 +444,6 @@ impl<'tcx> ScopeTree {\n         true\n     }\n \n-    /// Returns the ID of the innermost containing body.\n-    pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n-        loop {\n-            if let ScopeData::CallSite = scope.data {\n-                return Some(scope.item_local_id());\n-            }\n-\n-            scope = self.opt_encl_scope(scope)?;\n-        }\n-    }\n-\n-    /// Finds the nearest common ancestor of two scopes. That is, finds the\n-    /// smallest scope which is greater than or equal to both `scope_a` and\n-    /// `scope_b`.\n-    pub fn nearest_common_ancestor(&self, scope_a: Scope, scope_b: Scope) -> Scope {\n-        if scope_a == scope_b {\n-            return scope_a;\n-        }\n-\n-        let mut a = scope_a;\n-        let mut b = scope_b;\n-\n-        // Get the depth of each scope's parent. If either scope has no parent,\n-        // it must be the root, which means we can stop immediately because the\n-        // root must be the nearest common ancestor. (In practice, this is\n-        // moderately common.)\n-        let (parent_a, parent_a_depth) = match self.parent_map.get(&a) {\n-            Some(pd) => *pd,\n-            None => return a,\n-        };\n-        let (parent_b, parent_b_depth) = match self.parent_map.get(&b) {\n-            Some(pd) => *pd,\n-            None => return b,\n-        };\n-\n-        if parent_a_depth > parent_b_depth {\n-            // `a` is lower than `b`. Move `a` up until it's at the same depth\n-            // as `b`. The first move up is trivial because we already found\n-            // `parent_a` above; the loop does the remaining N-1 moves.\n-            a = parent_a;\n-            for _ in 0..(parent_a_depth - parent_b_depth - 1) {\n-                a = self.parent_map.get(&a).unwrap().0;\n-            }\n-        } else if parent_b_depth > parent_a_depth {\n-            // `b` is lower than `a`.\n-            b = parent_b;\n-            for _ in 0..(parent_b_depth - parent_a_depth - 1) {\n-                b = self.parent_map.get(&b).unwrap().0;\n-            }\n-        } else {\n-            // Both scopes are at the same depth, and we know they're not equal\n-            // because that case was tested for at the top of this function. So\n-            // we can trivially move them both up one level now.\n-            assert!(parent_a_depth != 0);\n-            a = parent_a;\n-            b = parent_b;\n-        }\n-\n-        // Now both scopes are at the same level. We move upwards in lockstep\n-        // until they match. In practice, this loop is almost always executed\n-        // zero times because `a` is almost always a direct ancestor of `b` or\n-        // vice versa.\n-        while a != b {\n-            a = self.parent_map.get(&a).unwrap().0;\n-            b = self.parent_map.get(&b).unwrap().0;\n-        }\n-\n-        a\n-    }\n-\n-    /// Assuming that the provided region was defined within this `ScopeTree`,\n-    /// returns the outermost `Scope` that the region outlives.\n-    pub fn early_free_scope(&self, tcx: TyCtxt<'tcx>, br: &ty::EarlyBoundRegion) -> Scope {\n-        let param_owner = tcx.parent(br.def_id).unwrap();\n-\n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local());\n-        let scope = tcx\n-            .hir()\n-            .maybe_body_owned_by(param_owner_id)\n-            .map(|body_id| tcx.hir().body(body_id).value.hir_id.local_id)\n-            .unwrap_or_else(|| {\n-                // The lifetime was defined on node that doesn't own a body,\n-                // which in practice can only mean a trait or an impl, that\n-                // is the parent of a method, and that is enforced below.\n-                if Some(param_owner_id) != self.root_parent {\n-                    tcx.sess.delay_span_bug(\n-                        DUMMY_SP,\n-                        &format!(\n-                            \"free_scope: {:?} not recognized by the \\\n-                              region scope tree for {:?} / {:?}\",\n-                            param_owner,\n-                            self.root_parent.map(|id| tcx.hir().local_def_id(id)),\n-                            self.root_body.map(|hir_id| hir_id.owner)\n-                        ),\n-                    );\n-                }\n-\n-                // The trait/impl lifetime is in scope for the method's body.\n-                self.root_body.unwrap().local_id\n-            });\n-\n-        Scope { id: scope, data: ScopeData::CallSite }\n-    }\n-\n-    /// Assuming that the provided region was defined within this `ScopeTree`,\n-    /// returns the outermost `Scope` that the region outlives.\n-    pub fn free_scope(&self, tcx: TyCtxt<'tcx>, fr: &ty::FreeRegion) -> Scope {\n-        let param_owner = match fr.bound_region {\n-            ty::BoundRegion::BrNamed(def_id, _) => tcx.parent(def_id).unwrap(),\n-            _ => fr.scope,\n-        };\n-\n-        // Ensure that the named late-bound lifetimes were defined\n-        // on the same function that they ended up being freed in.\n-        assert_eq!(param_owner, fr.scope);\n-\n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local());\n-        let body_id = tcx.hir().body_owned_by(param_owner_id);\n-        Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n-    }\n-\n     /// Checks whether the given scope contains a `yield`. If so,\n     /// returns `Some((span, expr_count))` with the span of a yield we found and\n     /// the number of expressions and patterns appearing before the `yield` in the body + 1."}, {"sha": "f03d91aa64b781c07a75a5cf40027cad0641118a", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,5 +1,4 @@\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n-use crate::middle::region;\n use crate::mir::interpret::{sign_extend, truncate, AllocId, ConstValue, Pointer, Scalar};\n use crate::ty::layout::IntegerExt;\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n@@ -1588,9 +1587,9 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n                 false\n             }\n \n-            ty::ReScope(_) | ty::ReVar(_) if identify_regions => true,\n+            ty::ReVar(_) if identify_regions => true,\n \n-            ty::ReVar(_) | ty::ReScope(_) | ty::ReErased => false,\n+            ty::ReVar(_) | ty::ReErased => false,\n \n             ty::ReStatic | ty::ReEmpty(_) => true,\n         }\n@@ -1666,32 +1665,12 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n                     }\n                 }\n             }\n-            ty::ReScope(scope) if identify_regions => {\n-                match scope.data {\n-                    region::ScopeData::Node => p!(write(\"'{}s\", scope.item_local_id().as_usize())),\n-                    region::ScopeData::CallSite => {\n-                        p!(write(\"'{}cs\", scope.item_local_id().as_usize()))\n-                    }\n-                    region::ScopeData::Arguments => {\n-                        p!(write(\"'{}as\", scope.item_local_id().as_usize()))\n-                    }\n-                    region::ScopeData::Destruction => {\n-                        p!(write(\"'{}ds\", scope.item_local_id().as_usize()))\n-                    }\n-                    region::ScopeData::Remainder(first_statement_index) => p!(write(\n-                        \"'{}_{}rs\",\n-                        scope.item_local_id().as_usize(),\n-                        first_statement_index.index()\n-                    )),\n-                }\n-                return Ok(self);\n-            }\n             ty::ReVar(region_vid) if identify_regions => {\n                 p!(write(\"{:?}\", region_vid));\n                 return Ok(self);\n             }\n             ty::ReVar(_) => {}\n-            ty::ReScope(_) | ty::ReErased => {}\n+            ty::ReErased => {}\n             ty::ReStatic => {\n                 p!(write(\"'static\"));\n                 return Ok(self);"}, {"sha": "569a8d90bfcc3cbb533f6b7c8abd1b79f2cd40eb", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -87,8 +87,6 @@ impl fmt::Debug for ty::RegionKind {\n \n             ty::ReFree(ref fr) => fr.fmt(f),\n \n-            ty::ReScope(id) => write!(f, \"ReScope({:?})\", id),\n-\n             ty::ReStatic => write!(f, \"ReStatic\"),\n \n             ty::ReVar(ref vid) => vid.fmt(f),"}, {"sha": "370702f7f221dacd723d069a31e74f5d180b1b99", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -6,7 +6,6 @@ use self::InferTy::*;\n use self::TyKind::*;\n \n use crate::infer::canonical::Canonical;\n-use crate::middle::region;\n use crate::mir::interpret::ConstValue;\n use crate::mir::interpret::{LitToConstInput, Scalar};\n use crate::mir::Promoted;\n@@ -1179,25 +1178,22 @@ rustc_index::newtype_index! {\n \n pub type Region<'tcx> = &'tcx RegionKind;\n \n-/// Representation of (lexical) regions. Note that the NLL checker\n-/// uses a distinct representation of regions. For this reason, it\n-/// internally replaces all the regions with inference variables --\n-/// the index of the variable is then used to index into internal NLL\n-/// data structures. See `rustc_mir::borrow_check` module for more\n-/// information.\n+/// Representation of regions. Note that the NLL checker uses a distinct\n+/// representation of regions. For this reason, it internally replaces all the\n+/// regions with inference variables -- the index of the variable is then used\n+/// to index into internal NLL data structures. See `rustc_mir::borrow_check`\n+/// module for more information.\n ///\n /// ## The Region lattice within a given function\n ///\n-/// In general, the (lexical, and hence deprecated) region lattice\n-/// looks like\n+/// In general, the region lattice looks like\n ///\n /// ```\n /// static ----------+-----...------+       (greatest)\n /// |                |              |\n /// early-bound and  |              |\n /// free regions     |              |\n /// |                |              |\n-/// scope regions    |              |\n /// |                |              |\n /// empty(root)   placeholder(U1)   |\n /// |            /                  |\n@@ -1212,13 +1208,7 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// Early-bound/free regions are the named lifetimes in scope from the\n /// function declaration. They have relationships to one another\n /// determined based on the declared relationships from the\n-/// function. They all collectively outlive the scope regions. (See\n-/// `RegionRelations` type, and particularly\n-/// `crate::infer::outlives::free_region_map::FreeRegionMap`.)\n-///\n-/// The scope regions are related to one another based on the AST\n-/// structure. (See `RegionRelations` type, and particularly the\n-/// `rustc_middle::middle::region::ScopeTree`.)\n+/// function.\n ///\n /// Note that inference variables and bound regions are not included\n /// in this diagram. In the case of inference variables, they should\n@@ -1307,11 +1297,6 @@ pub enum RegionKind {\n     /// region parameters.\n     ReFree(FreeRegion),\n \n-    /// A concrete region naming some statically determined scope\n-    /// (e.g., an expression or sequence of statements) within the\n-    /// current function.\n-    ReScope(region::Scope),\n-\n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     ReStatic,\n \n@@ -1535,7 +1520,6 @@ impl RegionKind {\n             RegionKind::ReEarlyBound(ebr) => ebr.has_name(),\n             RegionKind::ReLateBound(_, br) => br.is_named(),\n             RegionKind::ReFree(fr) => fr.bound_region.is_named(),\n-            RegionKind::ReScope(..) => false,\n             RegionKind::ReStatic => true,\n             RegionKind::ReVar(..) => false,\n             RegionKind::RePlaceholder(placeholder) => placeholder.name.is_named(),\n@@ -1616,7 +1600,7 @@ impl RegionKind {\n                 flags = flags | TypeFlags::HAS_RE_PARAM;\n                 flags = flags | TypeFlags::STILL_FURTHER_SPECIALIZABLE;\n             }\n-            ty::ReFree { .. } | ty::ReScope { .. } => {\n+            ty::ReFree { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n             }"}, {"sha": "e19fab89eabfee105ac0b47c59a5c91e95e52f89", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -162,10 +162,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     let type_test_span = type_test.locations.span(&self.body);\n \n                     if let Some(lower_bound_region) = lower_bound_region {\n-                        let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n                         self.infcx\n                             .construct_generic_bound_failure(\n-                                region_scope_tree,\n                                 type_test_span,\n                                 None,\n                                 type_test.generic_kind,\n@@ -194,12 +192,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n \n                 RegionErrorKind::UnexpectedHiddenRegion { span, hidden_ty, member_region } => {\n-                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n                     let named_ty = self.regioncx.name_regions(self.infcx.tcx, hidden_ty);\n                     let named_region = self.regioncx.name_regions(self.infcx.tcx, member_region);\n                     unexpected_hidden_region_diagnostic(\n                         self.infcx.tcx,\n-                        Some(region_scope_tree),\n                         span,\n                         named_ty,\n                         named_region,"}, {"sha": "e912ef7b20202f6595d993709757eeed01987a3e", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -284,7 +284,6 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             },\n \n             ty::ReLateBound(..)\n-            | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)"}, {"sha": "484677ded249f9b079fff5ee4e3e329786dad050", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -670,7 +670,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n // `least_region`. We cannot use `push_outlives_components` because regions in\n // closure signatures are not included in their outlives components. We need to\n // ensure all regions outlive the given bound so that we don't end up with,\n-// say, `ReScope` appearing in a return type and causing ICEs when other\n+// say, `ReVar` appearing in a return type and causing ICEs when other\n // functions end up with region constraints involving regions from other\n // functions.\n //\n@@ -816,7 +816,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             // The regions that we expect from borrow checking.\n             ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n \n-            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) | ty::ReScope(_) => {\n+            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) => {\n                 // All of the regions in the type should either have been\n                 // erased by writeback, or mapped back to named regions by\n                 // borrow checking.\n@@ -835,7 +835,6 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 if let Some(hidden_ty) = self.hidden_ty.take() {\n                     unexpected_hidden_region_diagnostic(\n                         self.tcx,\n-                        None,\n                         self.tcx.def_span(self.opaque_type_def_id),\n                         hidden_ty,\n                         r,"}, {"sha": "d8e99dc10af2a25140172a39ee65ddc72ee319c8", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -28,7 +28,6 @@ use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::middle::region;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{\n@@ -237,15 +236,12 @@ fn do_normalize_predicates<'tcx>(\n \n         debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n \n-        let region_scope_tree = region::ScopeTree::default();\n-\n         // We can use the `elaborated_env` here; the region code only\n         // cares about declarations like `'a: 'b`.\n         let outlives_env = OutlivesEnvironment::new(elaborated_env);\n \n         infcx.resolve_regions_and_report_errors(\n             region_context,\n-            &region_scope_tree,\n             &outlives_env,\n             RegionckMode::default(),\n         );"}, {"sha": "a33ada2fb6ef193cb96759f6fb4d84ef0e9bff7d", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -394,7 +394,6 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n                 ty::BrEnv => unimplemented!(),\n             },\n             ReFree(_) => unimplemented!(),\n-            ReScope(_) => unimplemented!(),\n             ReStatic => unimplemented!(),\n             ReVar(_) => unimplemented!(),\n             RePlaceholder(placeholder_region) => {"}, {"sha": "8fa901d8a984a6969cd368c09a195bf029a95ba2", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -3,7 +3,6 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use crate::astconv::AstConv;\n-use crate::middle::region;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{FutureTraitLangItem, GeneratorTraitLangItem};\n@@ -12,12 +11,11 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty};\n+use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n-use rustc_trait_selection::traits::Obligation;\n use std::cmp;\n use std::iter;\n \n@@ -518,22 +516,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let InferOk { value: (), obligations } =\n                     self.at(&cause, self.param_env).eq(*expected_ty, supplied_ty)?;\n                 all_obligations.extend(obligations);\n-\n-                // Also, require that the supplied type must outlive\n-                // the closure body.\n-                let closure_body_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n-                    id: body.value.hir_id.local_id,\n-                    data: region::ScopeData::Node,\n-                }));\n-                all_obligations.push(Obligation::new(\n-                    cause,\n-                    self.param_env,\n-                    ty::PredicateKind::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n-                        supplied_ty,\n-                        closure_body_region,\n-                    )))\n-                    .to_predicate(self.tcx),\n-                ));\n             }\n \n             let (supplied_output_ty, _) = self.infcx.replace_bound_vars_with_fresh_vars("}, {"sha": "24c319f26e71f25fb666a9ae43b5630c6de6b87a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -5,7 +5,6 @@ use rustc_errors::{struct_span_err, ErrorReported};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{InferOk, RegionckMode, TyCtxtInferExt};\n use rustc_infer::traits::TraitEngineExt as _;\n-use rustc_middle::middle::region;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n@@ -120,8 +119,6 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n             return Err(ErrorReported);\n         }\n \n-        let region_scope_tree = region::ScopeTree::default();\n-\n         // NB. It seems a bit... suspicious to use an empty param-env\n         // here. The correct thing, I imagine, would be\n         // `OutlivesEnvironment::new(impl_param_env)`, which would\n@@ -134,7 +131,6 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n \n         infcx.resolve_regions_and_report_errors(\n             drop_impl_did.to_def_id(),\n-            &region_scope_tree,\n             &outlives_env,\n             RegionckMode::default(),\n         );"}, {"sha": "6b7adb728e7e6ae06c3067f995c9976a4445c9b9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -106,13 +106,13 @@ use rustc_hir::lang_items::{\n use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, QPath};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n+use rustc_infer::infer;\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_infer::infer::{self, InferCtxt, InferOk, InferResult, TyCtxtInferExt};\n+use rustc_infer::infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin, TyCtxtInferExt};\n use rustc_middle::hir::map::blocks::FnLikeNode;\n-use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -667,13 +667,6 @@ impl Inherited<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let body_id = tcx.hir().maybe_body_owned_by(item_id);\n-        let implicit_region_bound = body_id.map(|body_id| {\n-            let body = tcx.hir().body(body_id);\n-            tcx.mk_region(ty::ReScope(region::Scope {\n-                id: body.value.hir_id.local_id,\n-                data: region::ScopeData::CallSite,\n-            }))\n-        });\n \n         Inherited {\n             tables: MaybeInProgressTables { maybe_tables: infcx.in_progress_tables },\n@@ -686,7 +679,7 @@ impl Inherited<'a, 'tcx> {\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n             opaque_types: RefCell::new(Default::default()),\n             opaque_types_vars: RefCell::new(Default::default()),\n-            implicit_region_bound,\n+            implicit_region_bound: None,\n             body_id,\n         }\n     }\n@@ -1337,12 +1330,9 @@ fn check_fn<'a, 'tcx>(\n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n     // (as it's created inside the body itself, not passed in from outside).\n     let maybe_va_list = if fn_sig.c_variadic {\n-        let va_list_did =\n-            tcx.require_lang_item(VaListTypeLangItem, Some(body.params.last().unwrap().span));\n-        let region = tcx.mk_region(ty::ReScope(region::Scope {\n-            id: body.value.hir_id.local_id,\n-            data: region::ScopeData::CallSite,\n-        }));\n+        let span = body.params.last().unwrap().span;\n+        let va_list_did = tcx.require_lang_item(VaListTypeLangItem, Some(span));\n+        let region = fcx.next_region_var(RegionVariableOrigin::MiscVariable(span));\n \n         Some(tcx.type_of(va_list_did).subst(tcx, &[region.into()]))\n     } else {"}, {"sha": "90ba15aa089887d70283db8b1687c17e87cee56d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 17, "deletions": 492, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -83,12 +83,10 @@ use rustc_hir::PatKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{self, RegionObligation, RegionckMode};\n use rustc_middle::ty::adjustment;\n-use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n use rustc_trait_selection::infer::OutlivesEnvironmentExt;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n-use std::mem;\n use std::ops::Deref;\n \n // a variation on try that just returns unit\n@@ -111,8 +109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn regionck_expr(&self, body: &'tcx hir::Body<'tcx>) {\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let id = body.value.hir_id;\n-        let mut rcx =\n-            RegionCtxt::new(self, RepeatingScope(id), id, Subject(subject), self.param_env);\n+        let mut rcx = RegionCtxt::new(self, id, Subject(subject), self.param_env);\n \n         // There are no add'l implied bounds when checking a\n         // standalone expr (e.g., the `E` in a type like `[u32; E]`).\n@@ -131,13 +128,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn regionck_item(&self, item_id: hir::HirId, span: Span, wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?})\", item_id, wf_tys);\n         let subject = self.tcx.hir().local_def_id(item_id);\n-        let mut rcx = RegionCtxt::new(\n-            self,\n-            RepeatingScope(item_id),\n-            item_id,\n-            Subject(subject),\n-            self.param_env,\n-        );\n+        let mut rcx = RegionCtxt::new(self, item_id, Subject(subject), self.param_env);\n         rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);\n         rcx.outlives_environment.save_implied_bounds(item_id);\n         rcx.visit_region_obligations(item_id);\n@@ -156,8 +147,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let hir_id = body.value.hir_id;\n-        let mut rcx =\n-            RegionCtxt::new(self, RepeatingScope(hir_id), hir_id, Subject(subject), self.param_env);\n+        let mut rcx = RegionCtxt::new(self, hir_id, Subject(subject), self.param_env);\n \n         if !self.errors_reported_since_creation() {\n             // regionck assumes typeck succeeded\n@@ -182,12 +172,6 @@ pub struct RegionCtxt<'a, 'tcx> {\n     body_id: hir::HirId,\n     body_owner: LocalDefId,\n \n-    // call_site scope of innermost fn\n-    call_site_scope: Option<region::Scope>,\n-\n-    // id of innermost fn or loop\n-    repeating_scope: hir::HirId,\n-\n     // id of AST node being analyzed (the subject of the analysis).\n     subject_def_id: LocalDefId,\n }\n@@ -199,13 +183,11 @@ impl<'a, 'tcx> Deref for RegionCtxt<'a, 'tcx> {\n     }\n }\n \n-pub struct RepeatingScope(hir::HirId);\n pub struct Subject(LocalDefId);\n \n impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     pub fn new(\n         fcx: &'a FnCtxt<'a, 'tcx>,\n-        RepeatingScope(initial_repeating_scope): RepeatingScope,\n         initial_body_id: hir::HirId,\n         Subject(subject): Subject,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -215,19 +197,13 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         RegionCtxt {\n             fcx,\n             region_scope_tree,\n-            repeating_scope: initial_repeating_scope,\n             body_id: initial_body_id,\n             body_owner: subject,\n-            call_site_scope: None,\n             subject_def_id: subject,\n             outlives_environment,\n         }\n     }\n \n-    fn set_repeating_scope(&mut self, scope: hir::HirId) -> hir::HirId {\n-        mem::replace(&mut self.repeating_scope, scope)\n-    }\n-\n     /// Try to resolve the type for the given node, returning `t_err` if an error results. Note that\n     /// we never care about the details of the error, the same error will be detected and reported\n     /// in the writeback phase.\n@@ -261,16 +237,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.resolve_type(t)\n     }\n \n-    /// Try to resolve the type for the given node.\n-    pub fn resolve_expr_type_adjusted(&mut self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n-        let ty = self.tables.borrow().expr_ty_adjusted(expr);\n-        self.resolve_type(ty)\n-    }\n-\n-    /// This is the \"main\" function when region-checking a function item or a closure\n-    /// within a function item. It begins by updating various fields (e.g., `call_site_scope`\n-    /// and `outlives_environment`) to be appropriate to the function and then adds constraints\n-    /// derived from the function body.\n+    /// This is the \"main\" function when region-checking a function item or a\n+    /// closure within a function item. It begins by updating various fields\n+    /// (e.g., `outlives_environment`) to be appropriate to the function and\n+    /// then adds constraints derived from the function body.\n     ///\n     /// Note that it does **not** restore the state of the fields that\n     /// it updates! This is intentional, since -- for the main\n@@ -292,10 +262,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.body_id = body_id.hir_id;\n         self.body_owner = self.tcx.hir().body_owner_def_id(body_id);\n \n-        let call_site =\n-            region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::CallSite };\n-        self.call_site_scope = Some(call_site);\n-\n         let fn_sig = {\n             match self.tables.borrow().liberated_fn_sigs().get(id) {\n                 Some(f) => *f,\n@@ -324,12 +290,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.hir_id);\n \n-        let call_site_scope = self.call_site_scope.unwrap();\n-        debug!(\"visit_fn_body body.id {:?} call_site_scope: {:?}\", body.id(), call_site_scope);\n-        let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n-\n-        self.type_of_node_must_outlive(infer::CallReturn(span), body_id.hir_id, call_site_region);\n-\n         self.constrain_opaque_types(\n             &self.fcx.opaque_types.borrow(),\n             self.outlives_environment.free_region_map(),\n@@ -354,7 +314,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n         self.fcx.resolve_regions_and_report_errors(\n             self.subject_def_id.to_def_id(),\n-            &self.region_scope_tree,\n             &self.outlives_environment,\n             mode,\n         );\n@@ -363,34 +322,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat<'_>) {\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n         pat.each_binding(|_, hir_id, span, _| {\n-            // If we have a variable that contains region'd data, that\n-            // data will be accessible from anywhere that the variable is\n-            // accessed. We must be wary of loops like this:\n-            //\n-            //     // from src/test/compile-fail/borrowck-lend-flow.rs\n-            //     let mut v = box 3, w = box 4;\n-            //     let mut x = &mut w;\n-            //     loop {\n-            //         **x += 1;   // (2)\n-            //         borrow(v);  //~ ERROR cannot borrow\n-            //         x = &mut v; // (1)\n-            //     }\n-            //\n-            // Typically, we try to determine the region of a borrow from\n-            // those points where it is dereferenced. In this case, one\n-            // might imagine that the lifetime of `x` need only be the\n-            // body of the loop. But of course this is incorrect because\n-            // the pointer that is created at point (1) is consumed at\n-            // point (2), meaning that it must be live across the loop\n-            // iteration. The easiest way to guarantee this is to require\n-            // that the lifetime of any regions that appear in a\n-            // variable's type enclose at least the variable's scope.\n-            let var_scope = self.region_scope_tree.var_scope(hir_id.local_id);\n-            let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n-\n-            let origin = infer::BindingTypeIsNotValidAtDecl(span);\n-            self.type_of_node_must_outlive(origin, hir_id, var_region);\n-\n             let typ = self.resolve_node_type(hir_id);\n             let body_id = self.body_id;\n             let _ = dropck::check_drop_obligations(self, typ, span, body_id);\n@@ -433,15 +364,13 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n         // `visit_fn_body`.  We will restore afterwards.\n         let old_body_id = self.body_id;\n         let old_body_owner = self.body_owner;\n-        let old_call_site_scope = self.call_site_scope;\n         let env_snapshot = self.outlives_environment.push_snapshot_pre_closure();\n \n         let body = self.tcx.hir().body(body_id);\n         self.visit_fn_body(hir_id, body, span);\n \n         // Restore state from previous function.\n         self.outlives_environment.pop_snapshot_post_closure(env_snapshot);\n-        self.call_site_scope = old_call_site_scope;\n         self.body_id = old_body_id;\n         self.body_owner = old_body_owner;\n     }\n@@ -462,42 +391,6 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n-        debug!(\"regionck::visit_expr(e={:?}, repeating_scope={:?})\", expr, self.repeating_scope);\n-\n-        // No matter what, the type of each expression must outlive the\n-        // scope of that expression. This also guarantees basic WF.\n-        let expr_ty = self.resolve_node_type(expr.hir_id);\n-        // the region corresponding to this expression\n-        let expr_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n-            id: expr.hir_id.local_id,\n-            data: region::ScopeData::Node,\n-        }));\n-        self.type_must_outlive(\n-            infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n-            expr_ty,\n-            expr_region,\n-        );\n-\n-        let is_method_call = self.tables.borrow().is_method_call(expr);\n-\n-        // If we are calling a method (either explicitly or via an\n-        // overloaded operator), check that all of the types provided as\n-        // arguments for its type parameters are well-formed, and all the regions\n-        // provided as arguments outlive the call.\n-        if is_method_call {\n-            let origin = match expr.kind {\n-                hir::ExprKind::MethodCall(..) => infer::ParameterOrigin::MethodCall,\n-                hir::ExprKind::Unary(op, _) if op == hir::UnOp::UnDeref => {\n-                    infer::ParameterOrigin::OverloadedDeref\n-                }\n-                _ => infer::ParameterOrigin::OverloadedOperator,\n-            };\n-\n-            let substs = self.tables.borrow().node_substs(expr.hir_id);\n-            self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n-            // Arguments (sub-expressions) are checked via `constrain_call`, below.\n-        }\n-\n         // Check any autoderefs or autorefs that appear.\n         let cmt_result = self.constrain_adjustments(expr);\n \n@@ -512,117 +405,10 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n             }\n         }\n \n-        debug!(\n-            \"regionck::visit_expr(e={:?}, repeating_scope={:?}) - visiting subexprs\",\n-            expr, self.repeating_scope\n-        );\n         match expr.kind {\n-            hir::ExprKind::Path(_) => {\n-                let substs = self.tables.borrow().node_substs(expr.hir_id);\n-                let origin = infer::ParameterOrigin::Path;\n-                self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n-            }\n-\n-            hir::ExprKind::Call(ref callee, ref args) => {\n-                if is_method_call {\n-                    self.constrain_call(expr, Some(&callee), args.iter().map(|e| &*e));\n-                } else {\n-                    self.constrain_callee(&callee);\n-                    self.constrain_call(expr, None, args.iter().map(|e| &*e));\n-                }\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::MethodCall(.., ref args) => {\n-                self.constrain_call(expr, Some(&args[0]), args[1..].iter().map(|e| &*e));\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::AssignOp(_, ref lhs, ref rhs) => {\n-                if is_method_call {\n-                    self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n-                }\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Index(ref lhs, ref rhs) if is_method_call => {\n-                self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Binary(_, ref lhs, ref rhs) if is_method_call => {\n-                // As `ExprKind::MethodCall`, but the call is via an overloaded op.\n-                self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n-                // If you do `x OP y`, then the types of `x` and `y` must\n-                // outlive the operation you are performing.\n-                let lhs_ty = self.resolve_expr_type_adjusted(&lhs);\n-                let rhs_ty = self.resolve_expr_type_adjusted(&rhs);\n-                for &ty in &[lhs_ty, rhs_ty] {\n-                    self.type_must_outlive(infer::Operand(expr.span), ty, expr_region);\n-                }\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base) => {\n-                // For *a, the lifetime of a must enclose the deref\n-                if is_method_call {\n-                    self.constrain_call(expr, Some(base), None::<hir::Expr<'_>>.iter());\n-                }\n-                // For overloaded derefs, base_ty is the input to `Deref::deref`,\n-                // but it's a reference type uing the same region as the output.\n-                let base_ty = self.resolve_expr_type_adjusted(base);\n-                if let ty::Ref(r_ptr, _, _) = base_ty.kind {\n-                    self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n-                }\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Unary(_, ref lhs) if is_method_call => {\n-                // As above.\n-                self.constrain_call(expr, Some(&lhs), None::<hir::Expr<'_>>.iter());\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Index(ref vec_expr, _) => {\n-                // For a[b], the lifetime of a must enclose the deref\n-                let vec_type = self.resolve_expr_type_adjusted(&vec_expr);\n-                self.constrain_index(expr, vec_type);\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Cast(ref source, _) => {\n-                // Determine if we are casting `source` to a trait\n-                // instance.  If so, we have to be sure that the type of\n-                // the source obeys the trait's region bound.\n-                self.constrain_cast(expr, &source);\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref base) => {\n                 self.link_addr_of(expr, m, &base);\n \n-                // Require that when you write a `&expr` expression, the\n-                // resulting pointer has a lifetime that encompasses the\n-                // `&expr` expression itself. Note that we constraining\n-                // the type of the node expr.id here *before applying\n-                // adjustments*.\n-                //\n-                // FIXME(https://github.com/rust-lang/rfcs/issues/811)\n-                // nested method calls requires that this rule change\n-                let ty0 = self.resolve_node_type(expr.hir_id);\n-                self.type_must_outlive(infer::AddrOf(expr.span), ty0, expr_region);\n                 intravisit::walk_expr(self, expr);\n             }\n \n@@ -632,140 +418,12 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprKind::Closure(.., body_id, _, _) => {\n-                self.check_expr_fn_block(expr, body_id);\n-            }\n-\n-            hir::ExprKind::Loop(ref body, _, _) => {\n-                let repeating_scope = self.set_repeating_scope(body.hir_id);\n-                intravisit::walk_expr(self, expr);\n-                self.set_repeating_scope(repeating_scope);\n-            }\n-\n-            hir::ExprKind::Ret(Some(ref ret_expr)) => {\n-                let call_site_scope = self.call_site_scope;\n-                debug!(\n-                    \"visit_expr ExprKind::Ret ret_expr.hir_id {} call_site_scope: {:?}\",\n-                    ret_expr.hir_id, call_site_scope\n-                );\n-                let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n-                self.type_of_node_must_outlive(\n-                    infer::CallReturn(ret_expr.span),\n-                    ret_expr.hir_id,\n-                    call_site_region,\n-                );\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            _ => {\n-                intravisit::walk_expr(self, expr);\n-            }\n+            _ => intravisit::walk_expr(self, expr),\n         }\n     }\n }\n \n impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n-    fn constrain_cast(&mut self, cast_expr: &hir::Expr<'_>, source_expr: &hir::Expr<'_>) {\n-        debug!(\"constrain_cast(cast_expr={:?}, source_expr={:?})\", cast_expr, source_expr);\n-\n-        let source_ty = self.resolve_node_type(source_expr.hir_id);\n-        let target_ty = self.resolve_node_type(cast_expr.hir_id);\n-\n-        self.walk_cast(cast_expr, source_ty, target_ty);\n-    }\n-\n-    fn walk_cast(&mut self, cast_expr: &hir::Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n-        debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\", from_ty, to_ty);\n-        match (&from_ty.kind, &to_ty.kind) {\n-            /*From:*/\n-            (&ty::Ref(from_r, from_ty, _), /*To:  */ &ty::Ref(to_r, to_ty, _)) => {\n-                // Target cannot outlive source, naturally.\n-                self.sub_regions(infer::Reborrow(cast_expr.span), to_r, from_r);\n-                self.walk_cast(cast_expr, from_ty, to_ty);\n-            }\n-\n-            /*From:*/\n-            (_, /*To:  */ &ty::Dynamic(.., r)) => {\n-                // When T is existentially quantified as a trait\n-                // `Foo+'to`, it must outlive the region bound `'to`.\n-                self.type_must_outlive(infer::RelateObjectBound(cast_expr.span), from_ty, r);\n-            }\n-\n-            /*From:*/\n-            (&ty::Adt(from_def, _), /*To:  */ &ty::Adt(to_def, _))\n-                if from_def.is_box() && to_def.is_box() =>\n-            {\n-                self.walk_cast(cast_expr, from_ty.boxed_ty(), to_ty.boxed_ty());\n-            }\n-\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_expr_fn_block(&mut self, expr: &'tcx hir::Expr<'tcx>, body_id: hir::BodyId) {\n-        let repeating_scope = self.set_repeating_scope(body_id.hir_id);\n-        intravisit::walk_expr(self, expr);\n-        self.set_repeating_scope(repeating_scope);\n-    }\n-\n-    fn constrain_callee(&mut self, callee_expr: &hir::Expr<'_>) {\n-        let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n-        match callee_ty.kind {\n-            ty::FnDef(..) | ty::FnPtr(_) => {}\n-            _ => {\n-                // this should not happen, but it does if the program is\n-                // erroneous\n-                //\n-                // bug!(\n-                //     callee_expr.span,\n-                //     \"Calling non-function: {}\",\n-                //     callee_ty);\n-            }\n-        }\n-    }\n-\n-    fn constrain_call<'b, I: Iterator<Item = &'b hir::Expr<'b>>>(\n-        &mut self,\n-        call_expr: &hir::Expr<'_>,\n-        receiver: Option<&hir::Expr<'_>>,\n-        arg_exprs: I,\n-    ) {\n-        //! Invoked on every call site (i.e., normal calls, method calls,\n-        //! and overloaded operators). Constrains the regions which appear\n-        //! in the type of the function. Also constrains the regions that\n-        //! appear in the arguments appropriately.\n-\n-        debug!(\"constrain_call(call_expr={:?}, receiver={:?})\", call_expr, receiver);\n-\n-        // `callee_region` is the scope representing the time in which the\n-        // call occurs.\n-        //\n-        // FIXME(#6268) to support nested method calls, should be callee_id\n-        let callee_scope =\n-            region::Scope { id: call_expr.hir_id.local_id, data: region::ScopeData::Node };\n-        let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n-\n-        debug!(\"callee_region={:?}\", callee_region);\n-\n-        for arg_expr in arg_exprs {\n-            debug!(\"argument: {:?}\", arg_expr);\n-\n-            // ensure that any regions appearing in the argument type are\n-            // valid for at least the lifetime of the function:\n-            self.type_of_node_must_outlive(\n-                infer::CallArg(arg_expr.span),\n-                arg_expr.hir_id,\n-                callee_region,\n-            );\n-        }\n-\n-        // as loop above, but for receiver\n-        if let Some(r) = receiver {\n-            debug!(\"receiver: {:?}\", r);\n-            self.type_of_node_must_outlive(infer::CallRcvr(r.span), r.hir_id, callee_region);\n-        }\n-    }\n-\n     /// Creates a temporary `MemCategorizationContext` and pass it to the closure.\n     fn with_mc<F, R>(&self, f: F) -> R\n     where\n@@ -784,79 +442,40 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn constrain_adjustments(&mut self, expr: &hir::Expr<'_>) -> mc::McResult<mc::Place<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n-        let mut cmt = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n+        let mut place = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n \n         let tables = self.tables.borrow();\n         let adjustments = tables.expr_adjustments(&expr);\n         if adjustments.is_empty() {\n-            return Ok(cmt);\n+            return Ok(place);\n         }\n \n         debug!(\"constrain_adjustments: adjustments={:?}\", adjustments);\n \n         // If necessary, constrain destructors in the unadjusted form of this\n         // expression.\n-        self.check_safety_of_rvalue_destructor_if_necessary(&cmt, expr.span);\n+        self.check_safety_of_rvalue_destructor_if_necessary(&place, expr.span);\n \n-        let expr_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n-            id: expr.hir_id.local_id,\n-            data: region::ScopeData::Node,\n-        }));\n         for adjustment in adjustments {\n-            debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\", adjustment, cmt);\n+            debug!(\"constrain_adjustments: adjustment={:?}, place={:?}\", adjustment, place);\n \n             if let adjustment::Adjust::Deref(Some(deref)) = adjustment.kind {\n-                debug!(\"constrain_adjustments: overloaded deref: {:?}\", deref);\n-\n-                // Treat overloaded autoderefs as if an AutoBorrow adjustment\n-                // was applied on the base type, as that is always the case.\n-                let input = self\n-                    .tcx\n-                    .mk_ref(deref.region, ty::TypeAndMut { ty: cmt.ty, mutbl: deref.mutbl });\n-                let output = self.tcx.mk_ref(\n-                    deref.region,\n-                    ty::TypeAndMut { ty: adjustment.target, mutbl: deref.mutbl },\n-                );\n-\n                 self.link_region(\n                     expr.span,\n                     deref.region,\n                     ty::BorrowKind::from_mutbl(deref.mutbl),\n-                    &cmt,\n+                    &place,\n                 );\n-\n-                // Specialized version of constrain_call.\n-                self.type_must_outlive(infer::CallRcvr(expr.span), input, expr_region);\n-                self.type_must_outlive(infer::CallReturn(expr.span), output, expr_region);\n             }\n \n             if let adjustment::Adjust::Borrow(ref autoref) = adjustment.kind {\n-                self.link_autoref(expr, &cmt, autoref);\n-\n-                // Require that the resulting region encompasses\n-                // the current node.\n-                //\n-                // FIXME(#6268) remove to support nested method calls\n-                self.type_of_node_must_outlive(\n-                    infer::AutoBorrow(expr.span),\n-                    expr.hir_id,\n-                    expr_region,\n-                );\n+                self.link_autoref(expr, &place, autoref);\n             }\n \n-            cmt = self.with_mc(|mc| mc.cat_expr_adjusted(expr, cmt, &adjustment))?;\n+            place = self.with_mc(|mc| mc.cat_expr_adjusted(expr, place, &adjustment))?;\n         }\n \n-        Ok(cmt)\n-    }\n-\n-    pub fn mk_subregion_due_to_dereference(\n-        &mut self,\n-        deref_span: Span,\n-        minimum_lifetime: ty::Region<'tcx>,\n-        maximum_lifetime: ty::Region<'tcx>,\n-    ) {\n-        self.sub_regions(infer::DerefPointer(deref_span), minimum_lifetime, maximum_lifetime)\n+        Ok(place)\n     }\n \n     fn check_safety_of_rvalue_destructor_if_necessary(\n@@ -872,59 +491,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Invoked on any index expression that occurs. Checks that if this is a slice\n-    /// being indexed, the lifetime of the pointer includes the deref expr.\n-    fn constrain_index(&mut self, index_expr: &hir::Expr<'_>, indexed_ty: Ty<'tcx>) {\n-        debug!(\"constrain_index(index_expr=?, indexed_ty={}\", self.ty_to_string(indexed_ty));\n-\n-        let r_index_expr = ty::ReScope(region::Scope {\n-            id: index_expr.hir_id.local_id,\n-            data: region::ScopeData::Node,\n-        });\n-        if let ty::Ref(r_ptr, r_ty, _) = indexed_ty.kind {\n-            match r_ty.kind {\n-                ty::Slice(_) | ty::Str => {\n-                    self.sub_regions(\n-                        infer::IndexSlice(index_expr.span),\n-                        self.tcx.mk_region(r_index_expr),\n-                        r_ptr,\n-                    );\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    /// Guarantees that any lifetimes that appear in the type of the node `id` (after applying\n-    /// adjustments) are valid for at least `minimum_lifetime`.\n-    fn type_of_node_must_outlive(\n-        &mut self,\n-        origin: infer::SubregionOrigin<'tcx>,\n-        hir_id: hir::HirId,\n-        minimum_lifetime: ty::Region<'tcx>,\n-    ) {\n-        // Try to resolve the type.  If we encounter an error, then typeck\n-        // is going to fail anyway, so just stop here and let typeck\n-        // report errors later on in the writeback phase.\n-        let ty0 = self.resolve_node_type(hir_id);\n-\n-        let ty = self\n-            .tables\n-            .borrow()\n-            .adjustments()\n-            .get(hir_id)\n-            .and_then(|adj| adj.last())\n-            .map_or(ty0, |adj| adj.target);\n-        let ty = self.resolve_type(ty);\n-        debug!(\n-            \"constrain_regions_in_type_of_node(\\\n-             ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n-            ty, ty0, hir_id, minimum_lifetime\n-        );\n-        self.type_must_outlive(origin, ty, minimum_lifetime);\n-    }\n-\n     /// Adds constraints to inference such that `T: 'a` holds (or\n     /// reports an error if it cannot).\n     ///\n@@ -1035,13 +601,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m.into()), expr_cmt);\n             }\n \n-            adjustment::AutoBorrow::RawPtr(m) => {\n-                let r = self.tcx.mk_region(ty::ReScope(region::Scope {\n-                    id: expr.hir_id.local_id,\n-                    data: region::ScopeData::Node,\n-                }));\n-                self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n-            }\n+            adjustment::AutoBorrow::RawPtr(_) => {}\n         }\n     }\n \n@@ -1251,39 +811,4 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Checks that the values provided for type/region arguments in a given\n-    /// expression are well-formed and in-scope.\n-    fn substs_wf_in_scope(\n-        &mut self,\n-        origin: infer::ParameterOrigin,\n-        substs: SubstsRef<'tcx>,\n-        expr_span: Span,\n-        expr_region: ty::Region<'tcx>,\n-    ) {\n-        debug!(\n-            \"substs_wf_in_scope(substs={:?}, \\\n-             expr_region={:?}, \\\n-             origin={:?}, \\\n-             expr_span={:?})\",\n-            substs, expr_region, origin, expr_span\n-        );\n-\n-        let origin = infer::ParameterInScope(origin, expr_span);\n-\n-        for kind in substs {\n-            match kind.unpack() {\n-                GenericArgKind::Lifetime(lt) => {\n-                    self.sub_regions(origin.clone(), expr_region, lt);\n-                }\n-                GenericArgKind::Type(ty) => {\n-                    let ty = self.resolve_type(ty);\n-                    self.type_must_outlive(origin.clone(), ty, expr_region);\n-                }\n-                GenericArgKind::Const(_) => {\n-                    // Const parameters don't impose constraints.\n-                }\n-            }\n-        }\n-    }\n }"}, {"sha": "c5dd314dc655881fa8f6ee2c82b98b9fb96cfe1e", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -11,7 +11,6 @@ use rustc_hir::ItemKind;\n use rustc_infer::infer;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{RegionckMode, TyCtxtInferExt};\n-use rustc_middle::middle::region;\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -293,11 +292,9 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                     }\n \n                     // Finally, resolve all regions.\n-                    let region_scope_tree = region::ScopeTree::default();\n                     let outlives_env = OutlivesEnvironment::new(param_env);\n                     infcx.resolve_regions_and_report_errors(\n                         impl_did.to_def_id(),\n-                        &region_scope_tree,\n                         &outlives_env,\n                         RegionckMode::default(),\n                     );\n@@ -552,14 +549,8 @@ pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedI\n         }\n \n         // Finally, resolve all regions.\n-        let region_scope_tree = region::ScopeTree::default();\n         let outlives_env = OutlivesEnvironment::new(param_env);\n-        infcx.resolve_regions_and_report_errors(\n-            impl_did,\n-            &region_scope_tree,\n-            &outlives_env,\n-            RegionckMode::default(),\n-        );\n+        infcx.resolve_regions_and_report_errors(impl_did, &outlives_env, RegionckMode::default());\n \n         CoerceUnsizedInfo { custom_kind: kind }\n     })"}, {"sha": "08404bea56138638aecf4131aa3b94de2f2fded6", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -73,7 +73,6 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{InferCtxt, RegionckMode, TyCtxtInferExt};\n use rustc_infer::traits::specialization_graph::Node;\n-use rustc_middle::middle::region::ScopeTree;\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{self, InstantiatedPredicates, TyCtxt, TypeFoldable};\n@@ -165,12 +164,7 @@ fn get_impl_substs<'tcx>(\n \n     // Conservatively use an empty `ParamEnv`.\n     let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n-    infcx.resolve_regions_and_report_errors(\n-        impl1_def_id,\n-        &ScopeTree::default(),\n-        &outlives_env,\n-        RegionckMode::default(),\n-    );\n+    infcx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env, RegionckMode::default());\n     let impl2_substs = match infcx.fully_resolve(&impl2_substs) {\n         Ok(s) => s,\n         Err(_) => {"}, {"sha": "8b06967879638aa3c1e06b6bc2fedefac2bb4ace", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -170,7 +170,6 @@ fn is_free_region(tcx: TyCtxt<'_>, region: Region<'_>) -> bool {\n \n         // These regions don't appear in types from type declarations:\n         RegionKind::ReErased\n-        | RegionKind::ReScope(..)\n         | RegionKind::ReVar(..)\n         | RegionKind::RePlaceholder(..)\n         | RegionKind::ReFree(..) => {"}, {"sha": "e04af6850dea198fc437466249b1fabda0123c81", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -444,7 +444,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ReFree(..)\n-            | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)"}, {"sha": "702c7d1e0f1203568e73a7af01a4431694ffe648", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -447,7 +447,6 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n \n             ty::ReLateBound(..)\n             | ty::ReFree(..)\n-            | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)"}, {"sha": "c1564cf07e68aa9f629855975a15f3448c4011a1", "filename": "src/test/ui/borrowck/issue-45983.migrate.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.migrate.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,12 +0,0 @@\n-error: borrowed data cannot be stored outside of its closure\n-  --> $DIR/issue-45983.rs:20:27\n-   |\n-LL |     let x = None;\n-   |         - borrowed data cannot be stored into here...\n-LL |     give_any(|y| x = Some(y));\n-   |              ---          ^ cannot be stored outside of its closure\n-   |              |\n-   |              ...because it cannot outlive this closure\n-\n-error: aborting due to previous error\n-"}, {"sha": "51bb4dee6762a3a688d9b01548d77969d6bf0d94", "filename": "src/test/ui/borrowck/issue-45983.nll.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,21 +0,0 @@\n-error[E0521]: borrowed data escapes outside of closure\n-  --> $DIR/issue-45983.rs:20:18\n-   |\n-LL |     let x = None;\n-   |         - `x` declared here, outside of the closure body\n-LL |     give_any(|y| x = Some(y));\n-   |               -  ^^^^^^^^^^^ `y` escapes the closure body here\n-   |               |\n-   |               `y` is a reference that is only valid in the closure body\n-\n-error[E0594]: cannot assign to `x`, as it is not declared as mutable\n-  --> $DIR/issue-45983.rs:20:18\n-   |\n-LL |     let x = None;\n-   |         - help: consider changing this to be mutable: `mut x`\n-LL |     give_any(|y| x = Some(y));\n-   |                  ^^^^^^^^^^^ cannot assign\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0594`."}, {"sha": "6784f6f86a010a31eb7590be12834b58624b9117", "filename": "src/test/ui/borrowck/issue-45983.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,24 +1,12 @@\n // As documented in Issue #45983, this test is evaluating the quality\n // of our diagnostics on erroneous code using higher-ranked closures.\n \n-// revisions: migrate nll\n-\n-// Since we are testing nll (and migration) explicitly as a separate\n-// revisions, don't worry about the --compare-mode=nll on this test.\n-\n-// ignore-compare-mode-nll\n-// ignore-compare-mode-polonius\n-\n-//[nll]compile-flags: -Z borrowck=mir\n-\n fn give_any<F: for<'r> FnOnce(&'r ())>(f: F) {\n     f(&());\n }\n \n fn main() {\n-    let x = None;\n+    let mut x = None;\n     give_any(|y| x = Some(y));\n-    //[migrate]~^ ERROR borrowed data cannot be stored outside of its closure\n-    //[nll]~^^ ERROR borrowed data escapes outside of closure\n-    //[nll]~| ERROR cannot assign to `x`, as it is not declared as mutable\n+    //~^ ERROR borrowed data escapes outside of closure\n }"}, {"sha": "efd414a2d44fffd30f6f5fc8dc551b4324f45445", "filename": "src/test/ui/borrowck/issue-45983.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,9 +1,9 @@\n error[E0521]: borrowed data escapes outside of closure\n-  --> $DIR/regions-escape-bound-fn-2.rs:8:18\n+  --> $DIR/issue-45983.rs:10:18\n    |\n LL |     let mut x = None;\n    |         ----- `x` declared here, outside of the closure body\n-LL |     with_int(|y| x = Some(y));\n+LL |     give_any(|y| x = Some(y));\n    |               -  ^^^^^^^^^^^ `y` escapes the closure body here\n    |               |\n    |               `y` is a reference that is only valid in the closure body", "previous_filename": "src/test/ui/borrowck/regions-escape-bound-fn-2.nll.stderr"}, {"sha": "20afecfe5de79f01db7429d9ae5aefc98fce5528", "filename": "src/test/ui/borrowck/issue-7573.nll.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,14 +0,0 @@\n-error[E0521]: borrowed data escapes outside of closure\n-  --> $DIR/issue-7573.rs:21:9\n-   |\n-LL |     let mut lines_to_use: Vec<&CrateId> = Vec::new();\n-   |         ---------------- `lines_to_use` declared here, outside of the closure body\n-LL |\n-LL |     let push_id = |installed_id: &CrateId| {\n-   |                    ------------ `installed_id` is a reference that is only valid in the closure body\n-...\n-LL |         lines_to_use.push(installed_id);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `installed_id` escapes the closure body here\n-\n-error: aborting due to previous error\n-"}, {"sha": "7c07411533ff072b63e3743b284c85941039a1e1", "filename": "src/test/ui/borrowck/issue-7573.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,36 +1,34 @@\n pub struct CrateId {\n     local_path: String,\n-    junk: String\n+    junk: String,\n }\n \n impl CrateId {\n     fn new(s: &str) -> CrateId {\n-        CrateId {\n-            local_path: s.to_string(),\n-            junk: \"wutevs\".to_string()\n-        }\n+        CrateId { local_path: s.to_string(), junk: \"wutevs\".to_string() }\n     }\n }\n \n pub fn remove_package_from_database() {\n     let mut lines_to_use: Vec<&CrateId> = Vec::new();\n-        //~^ NOTE cannot infer an appropriate lifetime\n+    //~^ NOTE `lines_to_use` declared here, outside of the closure body\n     let push_id = |installed_id: &CrateId| {\n-        //~^ NOTE borrowed data cannot outlive this closure\n-        //~| NOTE ...so that variable is valid at time of its declaration\n+        //~^ NOTE `installed_id` is a reference that is only valid in the closure body\n         lines_to_use.push(installed_id);\n-        //~^ ERROR borrowed data cannot be stored outside of its closure\n-        //~| NOTE cannot be stored outside of its closure\n+        //~^ ERROR borrowed data escapes outside of closure\n+        //~| NOTE `installed_id` escapes the closure body here\n     };\n     list_database(push_id);\n \n     for l in &lines_to_use {\n         println!(\"{}\", l.local_path);\n     }\n-\n }\n \n-pub fn list_database<F>(mut f: F) where F: FnMut(&CrateId) {\n+pub fn list_database<F>(mut f: F)\n+where\n+    F: FnMut(&CrateId),\n+{\n     let stuff = [\"foo\", \"bar\"];\n \n     for l in &stuff {"}, {"sha": "815419db833e55362d82b5b739086e7d384a24f3", "filename": "src/test/ui/borrowck/issue-7573.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,16 +1,14 @@\n-error: borrowed data cannot be stored outside of its closure\n-  --> $DIR/issue-7573.rs:21:27\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/issue-7573.rs:17:9\n    |\n LL |     let mut lines_to_use: Vec<&CrateId> = Vec::new();\n-   |                               - cannot infer an appropriate lifetime...\n+   |         ---------------- `lines_to_use` declared here, outside of the closure body\n LL |\n LL |     let push_id = |installed_id: &CrateId| {\n-   |         -------   ------------------------ borrowed data cannot outlive this closure\n-   |         |\n-   |         ...so that variable is valid at time of its declaration\n-...\n+   |                    ------------ `installed_id` is a reference that is only valid in the closure body\n+LL |\n LL |         lines_to_use.push(installed_id);\n-   |                           ^^^^^^^^^^^^ cannot be stored outside of its closure\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `installed_id` escapes the closure body here\n \n error: aborting due to previous error\n "}, {"sha": "0e98d98cf87b3f1c36bb297ae8683d2059fca4ed", "filename": "src/test/ui/borrowck/regions-escape-bound-fn-2.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,10 +1,13 @@\n-fn with_int<F>(f: F) where F: FnOnce(&isize) {\n+fn with_int<F>(f: F)\n+where\n+    F: FnOnce(&isize),\n+{\n     let x = 3;\n     f(&x);\n }\n \n fn main() {\n     let mut x = None;\n     with_int(|y| x = Some(y));\n-    //~^ ERROR borrowed data cannot be stored outside of its closure\n+    //~^ ERROR borrowed data escapes outside of closure\n }"}, {"sha": "1dc60bb15545223e37ca33a8d3991c976f5679eb", "filename": "src/test/ui/borrowck/regions-escape-bound-fn-2.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,12 +1,12 @@\n-error: borrowed data cannot be stored outside of its closure\n-  --> $DIR/regions-escape-bound-fn-2.rs:8:27\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/regions-escape-bound-fn-2.rs:11:18\n    |\n LL |     let mut x = None;\n-   |         ----- borrowed data cannot be stored into here...\n+   |         ----- `x` declared here, outside of the closure body\n LL |     with_int(|y| x = Some(y));\n-   |              ---          ^ cannot be stored outside of its closure\n-   |              |\n-   |              ...because it cannot outlive this closure\n+   |               -  ^^^^^^^^^^^ `y` escapes the closure body here\n+   |               |\n+   |               `y` is a reference that is only valid in the closure body\n \n error: aborting due to previous error\n "}, {"sha": "d304de92c7e1891462515dee167bfcbd735d3c8d", "filename": "src/test/ui/borrowck/regions-escape-bound-fn.nll.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,12 +0,0 @@\n-error[E0521]: borrowed data escapes outside of closure\n-  --> $DIR/regions-escape-bound-fn.rs:8:18\n-   |\n-LL |     let mut x: Option<&isize> = None;\n-   |         ----- `x` declared here, outside of the closure body\n-LL |     with_int(|y| x = Some(y));\n-   |               -  ^^^^^^^^^^^ `y` escapes the closure body here\n-   |               |\n-   |               `y` is a reference that is only valid in the closure body\n-\n-error: aborting due to previous error\n-"}, {"sha": "f896ae7bdada25cf22c3b6b8cc387b5b135c5188", "filename": "src/test/ui/borrowck/regions-escape-bound-fn.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,10 +1,13 @@\n-fn with_int<F>(f: F) where F: FnOnce(&isize) {\n+fn with_int<F>(f: F)\n+where\n+    F: FnOnce(&isize),\n+{\n     let x = 3;\n     f(&x);\n }\n \n fn main() {\n     let mut x: Option<&isize> = None;\n     with_int(|y| x = Some(y));\n-    //~^ ERROR borrowed data cannot be stored outside of its closure\n+    //~^ ERROR borrowed data escapes outside of closure\n }"}, {"sha": "5c548ec2876a33cd760d3094b0db063593a9c305", "filename": "src/test/ui/borrowck/regions-escape-bound-fn.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,12 +1,12 @@\n-error: borrowed data cannot be stored outside of its closure\n-  --> $DIR/regions-escape-bound-fn.rs:8:27\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/regions-escape-bound-fn.rs:11:18\n    |\n LL |     let mut x: Option<&isize> = None;\n-   |         ----- borrowed data cannot be stored into here...\n+   |         ----- `x` declared here, outside of the closure body\n LL |     with_int(|y| x = Some(y));\n-   |              ---          ^ cannot be stored outside of its closure\n-   |              |\n-   |              ...because it cannot outlive this closure\n+   |               -  ^^^^^^^^^^^ `y` escapes the closure body here\n+   |               |\n+   |               `y` is a reference that is only valid in the closure body\n \n error: aborting due to previous error\n "}, {"sha": "d9931302f75fcbe428ddce88e052d61d3975c12a", "filename": "src/test/ui/borrowck/regions-escape-unboxed-closure.nll.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,12 +0,0 @@\n-error[E0521]: borrowed data escapes outside of closure\n-  --> $DIR/regions-escape-unboxed-closure.rs:6:23\n-   |\n-LL |     let mut x: Option<&isize> = None;\n-   |         ----- `x` declared here, outside of the closure body\n-LL |     with_int(&mut |y| x = Some(y));\n-   |                    -  ^^^^^^^^^^^ `y` escapes the closure body here\n-   |                    |\n-   |                    `y` is a reference that is only valid in the closure body\n-\n-error: aborting due to previous error\n-"}, {"sha": "f01e47122d1e1cf6678b1d58d266f718b8085961", "filename": "src/test/ui/borrowck/regions-escape-unboxed-closure.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,8 +1,7 @@\n-fn with_int(f: &mut dyn FnMut(&isize)) {\n-}\n+fn with_int(f: &mut dyn FnMut(&isize)) {}\n \n fn main() {\n     let mut x: Option<&isize> = None;\n     with_int(&mut |y| x = Some(y));\n-    //~^ ERROR borrowed data cannot be stored outside of its closure\n+    //~^ ERROR borrowed data escapes outside of closure\n }"}, {"sha": "f2a49e70d27164bfa61740c803eeebed4cd02e45", "filename": "src/test/ui/borrowck/regions-escape-unboxed-closure.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,12 +1,12 @@\n-error: borrowed data cannot be stored outside of its closure\n-  --> $DIR/regions-escape-unboxed-closure.rs:6:32\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/regions-escape-unboxed-closure.rs:5:23\n    |\n LL |     let mut x: Option<&isize> = None;\n-   |         ----- borrowed data cannot be stored into here...\n+   |         ----- `x` declared here, outside of the closure body\n LL |     with_int(&mut |y| x = Some(y));\n-   |                   ---          ^ cannot be stored outside of its closure\n-   |                   |\n-   |                   ...because it cannot outlive this closure\n+   |                    -  ^^^^^^^^^^^ `y` escapes the closure body here\n+   |                    |\n+   |                    `y` is a reference that is only valid in the closure body\n \n error: aborting due to previous error\n "}, {"sha": "89107e799bd2207c4f26a4f62e38ceb0cf27c35a", "filename": "src/test/ui/c-variadic/variadic-ffi-4.nll.stderr", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,123 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:8:5\n-   |\n-LL | pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n-   |                                     --            -- has type `core::ffi::VaListImpl<'1>`\n-   |                                     |\n-   |                                     lifetime `'f` defined here\n-LL |     ap\n-   |     ^^ function was supposed to return data with lifetime `'1` but it is returning data with lifetime `'f`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:8:5\n-   |\n-LL | pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n-   |                                     --            -- has type `core::ffi::VaListImpl<'1>`\n-   |                                     |\n-   |                                     lifetime `'f` defined here\n-LL |     ap\n-   |     ^^ returning this value requires that `'1` must outlive `'f`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:12:5\n-   |\n-LL | pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaListImpl<'static> {\n-   |                                               -- has type `core::ffi::VaListImpl<'1>`\n-LL |     ap\n-   |     ^^ returning this value requires that `'1` must outlive `'static`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:16:33\n-   |\n-LL |     let _ = ap.with_copy(|ap| { ap });\n-   |                           ---   ^^ returning this value requires that `'1` must outlive `'2`\n-   |                           | |\n-   |                           | return type of closure is core::ffi::VaList<'2, '_>\n-   |                           has type `core::ffi::VaList<'1, '_>`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:20:5\n-   |\n-LL | pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n-   |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n-LL |     *ap0 = ap1;\n-   |     ^^^^ assignment requires that `'1` must outlive `'2`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:20:5\n-   |\n-LL | pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n-   |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n-LL |     *ap0 = ap1;\n-   |     ^^^^ assignment requires that `'2` must outlive `'1`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:24:5\n-   |\n-LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               ---                   ------- has type `core::ffi::VaListImpl<'2>`\n-   |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n-LL |     ap0 = &mut ap1;\n-   |     ^^^^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:24:5\n-   |\n-LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               ---                   ------- has type `core::ffi::VaListImpl<'2>`\n-   |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n-LL |     ap0 = &mut ap1;\n-   |     ^^^^^^^^^^^^^^ assignment requires that `'2` must outlive `'1`\n-\n-error[E0384]: cannot assign to immutable argument `ap0`\n-  --> $DIR/variadic-ffi-4.rs:24:5\n-   |\n-LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               --- help: make this binding mutable: `mut ap0`\n-LL |     ap0 = &mut ap1;\n-   |     ^^^^^^^^^^^^^^ cannot assign to immutable argument\n-\n-error[E0597]: `ap1` does not live long enough\n-  --> $DIR/variadic-ffi-4.rs:24:11\n-   |\n-LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                                    - let's call the lifetime of this reference `'3`\n-LL |     ap0 = &mut ap1;\n-   |     ------^^^^^^^^\n-   |     |     |\n-   |     |     borrowed value does not live long enough\n-   |     assignment requires that `ap1` is borrowed for `'3`\n-...\n-LL | }\n-   | - `ap1` dropped here while still borrowed\n-\n-error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:31:12\n-   |\n-LL | pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n-   |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n-LL |     *ap0 = ap1.clone();\n-   |            ^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/variadic-ffi-4.rs:31:12\n-   |\n-LL | pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n-   |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n-LL |     *ap0 = ap1.clone();\n-   |            ^^^^^^^^^^^ argument requires that `'2` must outlive `'1`\n-\n-error: aborting due to 12 previous errors\n-\n-Some errors have detailed explanations: E0384, E0597.\n-For more information about an error, try `rustc --explain E0384`."}, {"sha": "80640379422590b8e6391c1406d048c6b87326d1", "filename": "src/test/ui/c-variadic/variadic-ffi-4.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,32 +1,38 @@\n-#![crate_type=\"lib\"]\n+#![crate_type = \"lib\"]\n #![no_std]\n #![feature(c_variadic)]\n \n use core::ffi::{VaList, VaListImpl};\n \n pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n-    ap //~ ERROR: mismatched types\n+    ap\n+    //~^ ERROR: lifetime may not live long enough\n+    //~| ERROR: lifetime may not live long enough\n }\n \n pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaListImpl<'static> {\n-    ap //~ ERROR: mismatched types\n+    ap //~ ERROR: lifetime may not live long enough\n }\n \n pub unsafe extern \"C\" fn no_escape2(_: usize, ap: ...) {\n-    let _ = ap.with_copy(|ap| { ap }); //~ ERROR: cannot infer an appropriate lifetime\n+    let _ = ap.with_copy(|ap| ap); //~ ERROR: lifetime may not live long enough\n }\n \n pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-    *ap0 = ap1; //~ ERROR: mismatched types\n+    *ap0 = ap1;\n+    //~^ ERROR: lifetime may not live long enough\n+    //~| ERROR: lifetime may not live long enough\n }\n \n-pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n+pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n     ap0 = &mut ap1;\n-    //~^ ERROR: a value of type `core::ffi::VaListImpl<'_>` is borrowed for too long\n-    //~| ERROR: mismatched types\n-    //~| ERROR: cannot infer an appropriate lifetime\n+    //~^ ERROR: `ap1` does not live long enough\n+    //~| ERROR: lifetime may not live long enough\n+    //~| ERROR: lifetime may not live long enough\n }\n \n pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-    *ap0 = ap1.clone(); //~ ERROR: mismatched types\n+    *ap0 = ap1.clone();\n+    //~^ ERROR: lifetime may not live long enough\n+    //~| ERROR: lifetime may not live long enough\n }"}, {"sha": "65623501569e1099957f6ab89dece3c21b925b39", "filename": "src/test/ui/c-variadic/variadic-ffi-4.stderr", "status": "modified", "additions": 86, "deletions": 189, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,217 +1,114 @@\n-error[E0308]: mismatched types\n+error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:8:5\n    |\n+LL | pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n+   |                                     --            -- has type `core::ffi::VaListImpl<'1>`\n+   |                                     |\n+   |                                     lifetime `'f` defined here\n LL |     ap\n-   |     ^^ lifetime mismatch\n-   |\n-   = note: expected struct `core::ffi::VaListImpl<'f>`\n-              found struct `core::ffi::VaListImpl<'_>`\n-note: the scope of call-site for function at 7:78...\n-  --> $DIR/variadic-ffi-4.rs:7:78\n-   |\n-LL |   pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n-   |  ______________________________________________________________________________^\n-LL | |     ap\n-LL | | }\n-   | |_^\n-note: ...does not necessarily outlive the lifetime `'f` as defined on the function body at 7:37\n-  --> $DIR/variadic-ffi-4.rs:7:37\n+   |     ^^ function was supposed to return data with lifetime `'1` but it is returning data with lifetime `'f`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-4.rs:8:5\n    |\n LL | pub unsafe extern \"C\" fn no_escape0<'f>(_: usize, ap: ...) -> VaListImpl<'f> {\n-   |                                     ^^\n+   |                                     --            -- has type `core::ffi::VaListImpl<'1>`\n+   |                                     |\n+   |                                     lifetime `'f` defined here\n+LL |     ap\n+   |     ^^ returning this value requires that `'1` must outlive `'f`\n \n-error[E0308]: mismatched types\n-  --> $DIR/variadic-ffi-4.rs:12:5\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-4.rs:14:5\n    |\n+LL | pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaListImpl<'static> {\n+   |                                               -- has type `core::ffi::VaListImpl<'1>`\n LL |     ap\n-   |     ^^ lifetime mismatch\n-   |\n-   = note: expected struct `core::ffi::VaListImpl<'static>`\n-              found struct `core::ffi::VaListImpl<'_>`\n-note: the scope of call-site for function at 11:79...\n-  --> $DIR/variadic-ffi-4.rs:11:79\n-   |\n-LL |   pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaListImpl<'static> {\n-   |  _______________________________________________________________________________^\n-LL | |     ap\n-LL | | }\n-   | |_^\n-   = note: ...does not necessarily outlive the static lifetime\n+   |     ^^ returning this value requires that `'1` must outlive `'static`\n \n-error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n-  --> $DIR/variadic-ffi-4.rs:16:33\n-   |\n-LL |     let _ = ap.with_copy(|ap| { ap });\n-   |                                 ^^\n-   |\n-note: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the body at 16:26...\n-  --> $DIR/variadic-ffi-4.rs:16:26\n-   |\n-LL |     let _ = ap.with_copy(|ap| { ap });\n-   |                          ^^^^^^^^^^^\n-note: ...so that the expression is assignable\n-  --> $DIR/variadic-ffi-4.rs:16:33\n-   |\n-LL |     let _ = ap.with_copy(|ap| { ap });\n-   |                                 ^^\n-   = note: expected  `core::ffi::VaList<'_, '_>`\n-              found  `core::ffi::VaList<'_, '_>`\n-note: but, the lifetime must be valid for the method call at 16:13...\n-  --> $DIR/variadic-ffi-4.rs:16:13\n-   |\n-LL |     let _ = ap.with_copy(|ap| { ap });\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...so type `core::ffi::VaList<'_, '_>` of expression is valid during the expression\n-  --> $DIR/variadic-ffi-4.rs:16:13\n-   |\n-LL |     let _ = ap.with_copy(|ap| { ap });\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-4.rs:18:31\n+   |\n+LL |     let _ = ap.with_copy(|ap| ap);\n+   |                           --- ^^ returning this value requires that `'1` must outlive `'2`\n+   |                           | |\n+   |                           | return type of closure is core::ffi::VaList<'2, '_>\n+   |                           has type `core::ffi::VaList<'1, '_>`\n \n-error[E0308]: mismatched types\n-  --> $DIR/variadic-ffi-4.rs:20:12\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-4.rs:22:5\n    |\n+LL | pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n+   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n LL |     *ap0 = ap1;\n-   |            ^^^ lifetime mismatch\n-   |\n-   = note: expected struct `core::ffi::VaListImpl<'_>`\n-              found struct `core::ffi::VaListImpl<'_>`\n-note: the scope of call-site for function at 19:87...\n-  --> $DIR/variadic-ffi-4.rs:19:87\n-   |\n-LL |   pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-   |  _______________________________________________________________________________________^\n-LL | |     *ap0 = ap1;\n-LL | | }\n-   | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 19:1\n-  --> $DIR/variadic-ffi-4.rs:19:1\n-   |\n-LL | / pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-LL | |     *ap0 = ap1;\n-LL | | }\n-   | |_^\n+   |     ^^^^ assignment requires that `'1` must outlive `'2`\n \n-error[E0490]: a value of type `core::ffi::VaListImpl<'_>` is borrowed for too long\n-  --> $DIR/variadic-ffi-4.rs:24:11\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-4.rs:22:5\n    |\n-LL |     ap0 = &mut ap1;\n-   |           ^^^^^^^^\n-   |\n-note: the type is valid for the anonymous lifetime #1 defined on the function body at 23:1\n-  --> $DIR/variadic-ffi-4.rs:23:1\n-   |\n-LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-LL | |     ap0 = &mut ap1;\n-LL | |\n-LL | |\n-LL | |\n-LL | | }\n-   | |_^\n-note: but the borrow lasts for the scope of call-site for function at 23:83\n-  --> $DIR/variadic-ffi-4.rs:23:83\n-   |\n-LL |   pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |  ___________________________________________________________________________________^\n-LL | |     ap0 = &mut ap1;\n-LL | |\n-LL | |\n-LL | |\n-LL | | }\n-   | |_^\n+LL | pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n+   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n+LL |     *ap0 = ap1;\n+   |     ^^^^ assignment requires that `'2` must outlive `'1`\n \n-error[E0308]: mismatched types\n-  --> $DIR/variadic-ffi-4.rs:24:11\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-4.rs:28:5\n    |\n+LL | pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n+   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n LL |     ap0 = &mut ap1;\n-   |           ^^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected mutable reference `&mut core::ffi::VaListImpl<'_>`\n-              found mutable reference `&mut core::ffi::VaListImpl<'_>`\n-note: the scope of call-site for function at 23:83...\n-  --> $DIR/variadic-ffi-4.rs:23:83\n-   |\n-LL |   pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |  ___________________________________________________________________________________^\n-LL | |     ap0 = &mut ap1;\n-LL | |\n-LL | |\n-LL | |\n-LL | | }\n-   | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 23:1\n-  --> $DIR/variadic-ffi-4.rs:23:1\n-   |\n-LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-LL | |     ap0 = &mut ap1;\n-LL | |\n-LL | |\n-LL | |\n-LL | | }\n-   | |_^\n+   |     ^^^^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n \n-error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n-  --> $DIR/variadic-ffi-4.rs:24:11\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-4.rs:28:5\n    |\n+LL | pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n+   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n LL |     ap0 = &mut ap1;\n-   |           ^^^^^^^^\n-   |\n-note: first, the lifetime cannot outlive the scope of call-site for function at 23:83...\n-  --> $DIR/variadic-ffi-4.rs:23:83\n-   |\n-LL |   pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |  ___________________________________________________________________________________^\n-LL | |     ap0 = &mut ap1;\n-LL | |\n-LL | |\n-LL | |\n-LL | | }\n-   | |_^\n-note: ...so that the type `core::ffi::VaListImpl<'_>` is not borrowed for too long\n-  --> $DIR/variadic-ffi-4.rs:24:11\n-   |\n-LL |     ap0 = &mut ap1;\n-   |           ^^^^^^^^\n-note: but, the lifetime must be valid for the anonymous lifetime #1 defined on the function body at 23:1...\n-  --> $DIR/variadic-ffi-4.rs:23:1\n-   |\n-LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-LL | |     ap0 = &mut ap1;\n-LL | |\n-LL | |\n-LL | |\n-LL | | }\n-   | |_^\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/variadic-ffi-4.rs:24:11\n+   |     ^^^^^^^^^^^^^^ assignment requires that `'2` must outlive `'1`\n+\n+error[E0597]: `ap1` does not live long enough\n+  --> $DIR/variadic-ffi-4.rs:28:11\n    |\n+LL | pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n+   |                                                        - let's call the lifetime of this reference `'3`\n LL |     ap0 = &mut ap1;\n-   |           ^^^^^^^^\n+   |     ------^^^^^^^^\n+   |     |     |\n+   |     |     borrowed value does not live long enough\n+   |     assignment requires that `ap1` is borrowed for `'3`\n+...\n+LL | }\n+   | - `ap1` dropped here while still borrowed\n \n-error[E0308]: mismatched types\n-  --> $DIR/variadic-ffi-4.rs:31:12\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-4.rs:35:12\n    |\n+LL | pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n+   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n LL |     *ap0 = ap1.clone();\n-   |            ^^^^^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected struct `core::ffi::VaListImpl<'_>`\n-              found struct `core::ffi::VaListImpl<'_>`\n-note: the scope of call-site for function at 30:87...\n-  --> $DIR/variadic-ffi-4.rs:30:87\n-   |\n-LL |   pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-   |  _______________________________________________________________________________________^\n-LL | |     *ap0 = ap1.clone();\n-LL | | }\n-   | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 30:1\n-  --> $DIR/variadic-ffi-4.rs:30:1\n+   |            ^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-4.rs:35:12\n    |\n-LL | / pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-LL | |     *ap0 = ap1.clone();\n-LL | | }\n-   | |_^\n+LL | pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n+   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n+LL |     *ap0 = ap1.clone();\n+   |            ^^^^^^^^^^^ argument requires that `'2` must outlive `'1`\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 11 previous errors\n \n-Some errors have detailed explanations: E0308, E0495.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "52bca8dd63e1f6c47094033476be55389f1eb5cc", "filename": "src/test/ui/closures/closure-expected-type/expect-region-supply-region-2.nll.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region-2.nll.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -0,0 +1,24 @@\n+error: lifetime may not live long enough\n+  --> $DIR/expect-region-supply-region-2.rs:14:30\n+   |\n+LL | fn expect_bound_supply_named<'x>() {\n+   |                              -- lifetime `'x` defined here\n+...\n+LL |     closure_expecting_bound(|x: &'x u32| {\n+   |                              ^  - let's call the lifetime of this reference `'1`\n+   |                              |\n+   |                              requires that `'1` must outlive `'x`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/expect-region-supply-region-2.rs:14:30\n+   |\n+LL | fn expect_bound_supply_named<'x>() {\n+   |                              -- lifetime `'x` defined here\n+...\n+LL |     closure_expecting_bound(|x: &'x u32| {\n+   |                              ^ requires that `'x` must outlive `'static`\n+   |\n+   = help: consider replacing `'x` with `'static`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7405b1a1e3a288d0eadadc7218c232b15f129d92", "filename": "src/test/ui/closures/closure-expected-type/expect-region-supply-region-2.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region-2.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -0,0 +1,24 @@\n+#![allow(warnings)]\n+\n+fn closure_expecting_bound<F>(_: F)\n+where\n+    F: FnOnce(&u32),\n+{\n+}\n+\n+fn expect_bound_supply_named<'x>() {\n+    let mut f: Option<&u32> = None;\n+\n+    // Here we give a type annotation that `x` should be free. We get\n+    // an error because of that.\n+    closure_expecting_bound(|x: &'x u32| {\n+        //~^ ERROR mismatched types\n+        //~| ERROR mismatched types\n+\n+        // Borrowck doesn't get a chance to run, but if it did it should error\n+        // here.\n+        f = Some(x);\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "7f527904a69e5c3fbf6a4c7682a4905f99fceafb", "filename": "src/test/ui/closures/closure-expected-type/expect-region-supply-region-2.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region-2.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -0,0 +1,55 @@\n+error[E0308]: mismatched types\n+  --> $DIR/expect-region-supply-region-2.rs:14:33\n+   |\n+LL |     closure_expecting_bound(|x: &'x u32| {\n+   |                                 ^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected reference `&u32`\n+              found reference `&'x u32`\n+note: the anonymous lifetime #2 defined on the body at 14:29...\n+  --> $DIR/expect-region-supply-region-2.rs:14:29\n+   |\n+LL |       closure_expecting_bound(|x: &'x u32| {\n+   |  _____________________________^\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |         f = Some(x);\n+LL | |     });\n+   | |_____^\n+note: ...does not necessarily outlive the lifetime `'x` as defined on the function body at 9:30\n+  --> $DIR/expect-region-supply-region-2.rs:9:30\n+   |\n+LL | fn expect_bound_supply_named<'x>() {\n+   |                              ^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/expect-region-supply-region-2.rs:14:33\n+   |\n+LL |     closure_expecting_bound(|x: &'x u32| {\n+   |                                 ^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected reference `&u32`\n+              found reference `&'x u32`\n+note: the lifetime `'x` as defined on the function body at 9:30...\n+  --> $DIR/expect-region-supply-region-2.rs:9:30\n+   |\n+LL | fn expect_bound_supply_named<'x>() {\n+   |                              ^^\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the body at 14:29\n+  --> $DIR/expect-region-supply-region-2.rs:14:29\n+   |\n+LL |       closure_expecting_bound(|x: &'x u32| {\n+   |  _____________________________^\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |         f = Some(x);\n+LL | |     });\n+   | |_____^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d7d716ed4cb0a52b572470d55ef6519080a5f51c", "filename": "src/test/ui/closures/closure-expected-type/expect-region-supply-region.nll.stderr", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,44 +0,0 @@\n-error[E0521]: borrowed data escapes outside of closure\n-  --> $DIR/expect-region-supply-region.rs:18:9\n-   |\n-LL |     let mut f: Option<&u32> = None;\n-   |         ----- `f` declared here, outside of the closure body\n-LL |     closure_expecting_bound(|x| {\n-   |                              - `x` is a reference that is only valid in the closure body\n-LL |         f = Some(x);\n-   |         ^^^^^^^^^^^ `x` escapes the closure body here\n-\n-error[E0521]: borrowed data escapes outside of closure\n-  --> $DIR/expect-region-supply-region.rs:28:9\n-   |\n-LL |     let mut f: Option<&u32> = None;\n-   |         ----- `f` declared here, outside of the closure body\n-LL |     closure_expecting_bound(|x: &u32| {\n-   |                              - `x` is a reference that is only valid in the closure body\n-LL |         f = Some(x);\n-   |         ^^^^^^^^^^^ `x` escapes the closure body here\n-\n-error: lifetime may not live long enough\n-  --> $DIR/expect-region-supply-region.rs:37:30\n-   |\n-LL | fn expect_bound_supply_named<'x>() {\n-   |                              -- lifetime `'x` defined here\n-...\n-LL |     closure_expecting_bound(|x: &'x u32| {\n-   |                              ^  - let's call the lifetime of this reference `'1`\n-   |                              |\n-   |                              requires that `'1` must outlive `'x`\n-\n-error: lifetime may not live long enough\n-  --> $DIR/expect-region-supply-region.rs:37:30\n-   |\n-LL | fn expect_bound_supply_named<'x>() {\n-   |                              -- lifetime `'x` defined here\n-...\n-LL |     closure_expecting_bound(|x: &'x u32| {\n-   |                              ^ requires that `'x` must outlive `'static`\n-   |\n-   = help: consider replacing `'x` with `'static`\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "55c6aa795c26a8ad0d9e99c466b1d6fc5e4323ff", "filename": "src/test/ui/closures/closure-expected-type/expect-region-supply-region.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,12 +1,14 @@\n #![allow(warnings)]\n \n fn closure_expecting_bound<F>(_: F)\n-    where F: FnOnce(&u32)\n+where\n+    F: FnOnce(&u32),\n {\n }\n \n fn closure_expecting_free<'a, F>(_: F)\n-    where F: FnOnce(&'a u32)\n+where\n+    F: FnOnce(&'a u32),\n {\n }\n \n@@ -15,7 +17,7 @@ fn expect_bound_supply_nothing() {\n     // it to escape into `f`:\n     let mut f: Option<&u32> = None;\n     closure_expecting_bound(|x| {\n-        f = Some(x); //~ ERROR borrowed data cannot be stored outside of its closure\n+        f = Some(x); //~ ERROR borrowed data escapes outside of closure\n     });\n }\n \n@@ -25,22 +27,7 @@ fn expect_bound_supply_bound() {\n     // closure:\n     let mut f: Option<&u32> = None;\n     closure_expecting_bound(|x: &u32| {\n-        f = Some(x); //~ ERROR borrowed data cannot be stored outside of its closure\n-    });\n-}\n-\n-fn expect_bound_supply_named<'x>() {\n-    let mut f: Option<&u32> = None;\n-\n-    // Here we give a type annotation that `x` should be free. We get\n-    // an error because of that.\n-    closure_expecting_bound(|x: &'x u32| {\n-        //~^ ERROR mismatched types\n-        //~| ERROR mismatched types\n-\n-        // And we still cannot let `x` escape into `f`.\n-        f = Some(x);\n-        //~^ ERROR borrowed data cannot be stored outside of its closure\n+        f = Some(x); //~ ERROR borrowed data escapes outside of closure\n     });\n }\n \n@@ -67,4 +54,4 @@ fn expect_free_supply_named<'x>() {\n     closure_expecting_free(|x: &'x u32| f = Some(x)); // OK\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "213071abfffc3252ea1009728c72078c59cb68ea", "filename": "src/test/ui/closures/closure-expected-type/expect-region-supply-region.stderr", "status": "modified", "additions": 11, "deletions": 76, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,87 +1,22 @@\n-error: borrowed data cannot be stored outside of its closure\n-  --> $DIR/expect-region-supply-region.rs:18:18\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/expect-region-supply-region.rs:20:9\n    |\n LL |     let mut f: Option<&u32> = None;\n-   |         ----- borrowed data cannot be stored into here...\n+   |         ----- `f` declared here, outside of the closure body\n LL |     closure_expecting_bound(|x| {\n-   |                             --- ...because it cannot outlive this closure\n+   |                              - `x` is a reference that is only valid in the closure body\n LL |         f = Some(x);\n-   |                  ^ cannot be stored outside of its closure\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n \n-error: borrowed data cannot be stored outside of its closure\n-  --> $DIR/expect-region-supply-region.rs:28:18\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/expect-region-supply-region.rs:30:9\n    |\n LL |     let mut f: Option<&u32> = None;\n-   |         ----- borrowed data cannot be stored into here...\n+   |         ----- `f` declared here, outside of the closure body\n LL |     closure_expecting_bound(|x: &u32| {\n-   |                             --------- ...because it cannot outlive this closure\n+   |                              - `x` is a reference that is only valid in the closure body\n LL |         f = Some(x);\n-   |                  ^ cannot be stored outside of its closure\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n \n-error[E0308]: mismatched types\n-  --> $DIR/expect-region-supply-region.rs:37:33\n-   |\n-LL |     closure_expecting_bound(|x: &'x u32| {\n-   |                                 ^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected reference `&u32`\n-              found reference `&'x u32`\n-note: the anonymous lifetime #2 defined on the body at 37:29...\n-  --> $DIR/expect-region-supply-region.rs:37:29\n-   |\n-LL |       closure_expecting_bound(|x: &'x u32| {\n-   |  _____________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |\n-LL | |     });\n-   | |_____^\n-note: ...does not necessarily outlive the lifetime `'x` as defined on the function body at 32:30\n-  --> $DIR/expect-region-supply-region.rs:32:30\n-   |\n-LL | fn expect_bound_supply_named<'x>() {\n-   |                              ^^\n-\n-error[E0308]: mismatched types\n-  --> $DIR/expect-region-supply-region.rs:37:33\n-   |\n-LL |     closure_expecting_bound(|x: &'x u32| {\n-   |                                 ^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected reference `&u32`\n-              found reference `&'x u32`\n-note: the lifetime `'x` as defined on the function body at 32:30...\n-  --> $DIR/expect-region-supply-region.rs:32:30\n-   |\n-LL | fn expect_bound_supply_named<'x>() {\n-   |                              ^^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the body at 37:29\n-  --> $DIR/expect-region-supply-region.rs:37:29\n-   |\n-LL |       closure_expecting_bound(|x: &'x u32| {\n-   |  _____________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |\n-LL | |     });\n-   | |_____^\n-\n-error: borrowed data cannot be stored outside of its closure\n-  --> $DIR/expect-region-supply-region.rs:42:18\n-   |\n-LL |     let mut f: Option<&u32> = None;\n-   |         ----- borrowed data cannot be stored into here...\n-...\n-LL |     closure_expecting_bound(|x: &'x u32| {\n-   |                             ------------ ...because it cannot outlive this closure\n-...\n-LL |         f = Some(x);\n-   |                  ^ cannot be stored outside of its closure\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "a1c33bbcd5f751a1ec2254bbf2e16e9db7061bab", "filename": "src/test/ui/error-codes/E0490.nll.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Ferror-codes%2FE0490.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Ferror-codes%2FE0490.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0490.nll.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -0,0 +1,28 @@\n+error: lifetime may not live long enough\n+  --> $DIR/E0490.rs:2:12\n+   |\n+LL | fn f<'a, 'b>(y: &'b ()) {\n+   |      --  -- lifetime `'b` defined here\n+   |      |\n+   |      lifetime `'a` defined here\n+LL |     let x: &'a _ = &y;\n+   |            ^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error[E0597]: `y` does not live long enough\n+  --> $DIR/E0490.rs:2:20\n+   |\n+LL | fn f<'a, 'b>(y: &'b ()) {\n+   |      -- lifetime `'a` defined here\n+LL |     let x: &'a _ = &y;\n+   |            -----   ^^ borrowed value does not live long enough\n+   |            |\n+   |            type annotation requires that `y` is borrowed for `'a`\n+...\n+LL | }\n+   |  - `y` dropped here while still borrowed\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "36bafa2bd868c74297ca6cb37d30635846d77b25", "filename": "src/test/ui/error-codes/E0490.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Ferror-codes%2FE0490.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Ferror-codes%2FE0490.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0490.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -0,0 +1,8 @@\n+fn f<'a, 'b>(y: &'b ()) {\n+    let x: &'a _ = &y;\n+    //~^ E0490\n+    //~| E0495\n+    //~| E0495\n+}\n+\n+fn main() {}"}, {"sha": "03fce213605e3dfed04fc0e428d93561ed055533", "filename": "src/test/ui/error-codes/E0490.stderr", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Ferror-codes%2FE0490.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Ferror-codes%2FE0490.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0490.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -0,0 +1,76 @@\n+error[E0490]: a value of type `&'b ()` is borrowed for too long\n+  --> $DIR/E0490.rs:2:20\n+   |\n+LL |     let x: &'a _ = &y;\n+   |                    ^^\n+   |\n+note: the type is valid for the lifetime `'a` as defined on the function body at 1:6\n+  --> $DIR/E0490.rs:1:6\n+   |\n+LL | fn f<'a, 'b>(y: &'b ()) {\n+   |      ^^\n+note: but the borrow lasts for the lifetime `'b` as defined on the function body at 1:10\n+  --> $DIR/E0490.rs:1:10\n+   |\n+LL | fn f<'a, 'b>(y: &'b ()) {\n+   |          ^^\n+\n+error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n+  --> $DIR/E0490.rs:2:20\n+   |\n+LL |     let x: &'a _ = &y;\n+   |                    ^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime `'b` as defined on the function body at 1:10...\n+  --> $DIR/E0490.rs:1:10\n+   |\n+LL | fn f<'a, 'b>(y: &'b ()) {\n+   |          ^^\n+note: ...so that the type `&'b ()` is not borrowed for too long\n+  --> $DIR/E0490.rs:2:20\n+   |\n+LL |     let x: &'a _ = &y;\n+   |                    ^^\n+note: but, the lifetime must be valid for the lifetime `'a` as defined on the function body at 1:6...\n+  --> $DIR/E0490.rs:1:6\n+   |\n+LL | fn f<'a, 'b>(y: &'b ()) {\n+   |      ^^\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/E0490.rs:2:20\n+   |\n+LL |     let x: &'a _ = &y;\n+   |                    ^^\n+\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+  --> $DIR/E0490.rs:2:20\n+   |\n+LL |     let x: &'a _ = &y;\n+   |                    ^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime `'b` as defined on the function body at 1:10...\n+  --> $DIR/E0490.rs:1:10\n+   |\n+LL | fn f<'a, 'b>(y: &'b ()) {\n+   |          ^^\n+note: ...so that the expression is assignable\n+  --> $DIR/E0490.rs:2:20\n+   |\n+LL |     let x: &'a _ = &y;\n+   |                    ^^\n+   = note: expected  `&'a &()`\n+              found  `&'a &'b ()`\n+note: but, the lifetime must be valid for the lifetime `'a` as defined on the function body at 1:6...\n+  --> $DIR/E0490.rs:1:6\n+   |\n+LL | fn f<'a, 'b>(y: &'b ()) {\n+   |      ^^\n+note: ...so that the reference type `&'a &()` does not outlive the data it points at\n+  --> $DIR/E0490.rs:2:12\n+   |\n+LL |     let x: &'a _ = &y;\n+   |            ^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0495`."}, {"sha": "5140d1a9a7add00c84aa82def33936333a355888", "filename": "src/test/ui/error-codes/E0621-does-not-trigger-for-closures.nll.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.nll.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,11 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/E0621-does-not-trigger-for-closures.rs:15:45\n-   |\n-LL |     invoke(&x, |a, b| if a > b { a } else { b });\n-   |                    --                       ^ returning this value requires that `'1` must outlive `'2`\n-   |                    ||\n-   |                    |return type of closure is &'2 i32\n-   |                    has type `&'1 i32`\n-\n-error: aborting due to previous error\n-"}, {"sha": "44f174c0fb76f3692993567ec98a62ab3e18606c", "filename": "src/test/ui/error-codes/E0621-does-not-trigger-for-closures.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,9 +1,7 @@\n-// Test that we give the generic E0495 when one of the free regions is\n+// Test that we give the generic error when one of the free regions is\n // bound in a closure (rather than suggesting a change to the signature\n // of the closure, which is not specified in `foo` but rather in `invoke`).\n \n-// FIXME - This might be better as a UI test, but the finer details\n-// of the error seem to vary on different machines.\n fn invoke<'a, F>(x: &'a i32, f: F) -> &'a i32\n where F: FnOnce(&'a i32, &i32) -> &'a i32\n {\n@@ -12,7 +10,7 @@ where F: FnOnce(&'a i32, &i32) -> &'a i32\n }\n \n fn foo<'a>(x: &'a i32) {\n-    invoke(&x, |a, b| if a > b { a } else { b }); //~ ERROR E0495\n+    invoke(&x, |a, b| if a > b { a } else { b }); //~ ERROR lifetime may not live long enough\n }\n \n fn main() {}"}, {"sha": "b9edeb8346bdc9973cd712f3a3ffad0f91317ffb", "filename": "src/test/ui/error-codes/E0621-does-not-trigger-for-closures.stderr", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,30 +1,11 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/E0621-does-not-trigger-for-closures.rs:15:5\n+error: lifetime may not live long enough\n+  --> $DIR/E0621-does-not-trigger-for-closures.rs:13:45\n    |\n LL |     invoke(&x, |a, b| if a > b { a } else { b });\n-   |     ^^^^^^\n-   |\n-note: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the body at 15:16...\n-  --> $DIR/E0621-does-not-trigger-for-closures.rs:15:16\n-   |\n-LL |     invoke(&x, |a, b| if a > b { a } else { b });\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/E0621-does-not-trigger-for-closures.rs:15:45\n-   |\n-LL |     invoke(&x, |a, b| if a > b { a } else { b });\n-   |                                             ^\n-note: but, the lifetime must be valid for the call at 15:5...\n-  --> $DIR/E0621-does-not-trigger-for-closures.rs:15:5\n-   |\n-LL |     invoke(&x, |a, b| if a > b { a } else { b });\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...so type `&i32` of expression is valid during the expression\n-  --> $DIR/E0621-does-not-trigger-for-closures.rs:15:5\n-   |\n-LL |     invoke(&x, |a, b| if a > b { a } else { b });\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    --                       ^ returning this value requires that `'1` must outlive `'2`\n+   |                    ||\n+   |                    |return type of closure is &'2 i32\n+   |                    has type `&'1 i32`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`."}, {"sha": "b42ff1486f0a85b3cee9b368831e4bd26a0c5809", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -4,17 +4,11 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n    |                                                                          ^^^^^^^^^^^^^^^^^^\n    |\n-note: hidden type `Ordinary<'_>` captures the scope of call-site for function at 23:1\n-  --> $DIR/ordinary-bounds-unrelated.rs:23:1\n+note: hidden type `Ordinary<'_>` captures lifetime smaller than the function body\n+  --> $DIR/ordinary-bounds-unrelated.rs:18:74\n    |\n-LL | / {\n-LL | |     // Hidden type `Ordinary<'0>` with constraints:\n-LL | |     //\n-LL | |     // ```\n-...  |\n-LL | |     if condition() { a } else { b }\n-LL | | }\n-   | |_^\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+   |                                                                          ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "254643c406caefe00f7b071da26d1d720c8c1cff", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -4,17 +4,11 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n    |                                                              ^^^^^^^^^^^^^^^^^^\n    |\n-note: hidden type `Ordinary<'_>` captures the scope of call-site for function at 22:1\n-  --> $DIR/ordinary-bounds-unsuited.rs:22:1\n+note: hidden type `Ordinary<'_>` captures lifetime smaller than the function body\n+  --> $DIR/ordinary-bounds-unsuited.rs:20:62\n    |\n-LL | / {\n-LL | |     // We return a value:\n-LL | |     //\n-LL | |     // ```\n-...  |\n-LL | |     if condition() { a } else { b }\n-LL | | }\n-   | |_^\n+LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n+   |                                                              ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ff35b9ada45cd379dd66bc40e5e806ce62f5e22d", "filename": "src/test/ui/regions/regions-close-object-into-object-5.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -6,22 +6,21 @@ trait A<T>\n     fn get(&self) -> T { panic!() }\n }\n \n-struct B<'a, T:'a>(&'a (A<T>+'a));\n+struct B<'a, T: 'a>(&'a (A<T> + 'a));\n \n trait X { fn foo(&self) {} }\n \n impl<'a, T> X for B<'a, T> {}\n \n-fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n+fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n     // oh dear!\n     box B(&*v) as Box<X>\n-        //~^ ERROR the parameter type `T` may not live long enough\n-        //~| ERROR the parameter type `T` may not live long enough\n-        //~| ERROR the parameter type `T` may not live long enough\n-        //~| ERROR the parameter type `T` may not live long enough\n-        //~| ERROR the parameter type `T` may not live long enough\n-        //~| ERROR the parameter type `T` may not live long enough\n-        //~| ERROR the parameter type `T` may not live long enough\n+    //~^ ERROR the parameter type `T` may not live long enough\n+    //~| ERROR the parameter type `T` may not live long enough\n+    //~| ERROR the parameter type `T` may not live long enough\n+    //~| ERROR the parameter type `T` may not live long enough\n+    //~| ERROR the parameter type `T` may not live long enough\n+    //~| ERROR the parameter type `T` may not live long enough\n }\n \n fn main() {}"}, {"sha": "2bcdcd1864e2f1772a6e0f6294d66cfceb620223", "filename": "src/test/ui/regions/regions-close-object-into-object-5.stderr", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,7 +1,7 @@\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:5\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n+LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n@@ -13,25 +13,10 @@ note: ...so that the type `B<'_, T>` will meet its required lifetime bounds\n LL |     box B(&*v) as Box<X>\n    |     ^^^^^^^^^^\n \n-error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-close-object-into-object-5.rs:17:5\n-   |\n-LL | fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n-   |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n-LL |     // oh dear!\n-LL |     box B(&*v) as Box<X>\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that it can be closed over into an object\n-  --> $DIR/regions-close-object-into-object-5.rs:17:5\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:9\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n+LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n@@ -46,7 +31,7 @@ LL |     box B(&*v) as Box<X>\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:9\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n+LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n@@ -61,7 +46,7 @@ LL |     box B(&*v) as Box<X>\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:11\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n+LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n@@ -76,7 +61,7 @@ LL |     box B(&*v) as Box<X>\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:11\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n+LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n@@ -91,7 +76,7 @@ LL |     box B(&*v) as Box<X>\n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:11\n    |\n-LL | fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n+LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n@@ -103,6 +88,6 @@ note: ...so that the type `(dyn A<T> + 'static)` is not borrowed for too long\n LL |     box B(&*v) as Box<X>\n    |           ^^^\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0310`."}, {"sha": "3101d815881b17fcd6442581dcefd58cd99acd00", "filename": "src/test/ui/regions/regions-close-over-type-parameter-1.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.nll.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,13 +1,13 @@\n error[E0310]: the parameter type `A` may not live long enough\n-  --> $DIR/regions-close-over-type-parameter-1.rs:10:5\n+  --> $DIR/regions-close-over-type-parameter-1.rs:12:5\n    |\n LL |     box v as Box<dyn SomeTrait + 'static>\n    |     ^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `A: 'static`...\n \n error[E0309]: the parameter type `A` may not live long enough\n-  --> $DIR/regions-close-over-type-parameter-1.rs:20:5\n+  --> $DIR/regions-close-over-type-parameter-1.rs:21:5\n    |\n LL |     box v as Box<dyn SomeTrait + 'b>\n    |     ^^^^^"}, {"sha": "6e708a5f70fbd828edd106b96fed18ea85042e00", "filename": "src/test/ui/regions/regions-close-over-type-parameter-1.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -4,22 +4,22 @@\n // an object. This should yield errors unless `A` (and the object)\n // both have suitable bounds.\n \n-trait SomeTrait { fn get(&self) -> isize; }\n+trait SomeTrait {\n+    fn get(&self) -> isize;\n+}\n \n-fn make_object1<A:SomeTrait>(v: A) -> Box<dyn SomeTrait + 'static> {\n+fn make_object1<A: SomeTrait>(v: A) -> Box<dyn SomeTrait + 'static> {\n     box v as Box<dyn SomeTrait + 'static>\n-        //~^ ERROR the parameter type `A` may not live long enough\n-        //~| ERROR the parameter type `A` may not live long enough\n+    //~^ ERROR the parameter type `A` may not live long enough\n }\n \n-fn make_object2<'a,A:SomeTrait+'a>(v: A) -> Box<dyn SomeTrait + 'a> {\n+fn make_object2<'a, A: SomeTrait + 'a>(v: A) -> Box<dyn SomeTrait + 'a> {\n     box v as Box<dyn SomeTrait + 'a>\n }\n \n-fn make_object3<'a,'b,A:SomeTrait+'a>(v: A) -> Box<dyn SomeTrait + 'b> {\n+fn make_object3<'a, 'b, A: SomeTrait + 'a>(v: A) -> Box<dyn SomeTrait + 'b> {\n     box v as Box<dyn SomeTrait + 'b>\n-        //~^ ERROR the parameter type `A` may not live long enough\n-        //~| ERROR the parameter type `A` may not live long enough\n+    //~^ ERROR the parameter type `A` may not live long enough\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "a7509cb608c6b71aa19e3991a054b36242795efc", "filename": "src/test/ui/regions/regions-close-over-type-parameter-1.stderr", "status": "modified", "additions": 8, "deletions": 36, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,60 +1,32 @@\n error[E0310]: the parameter type `A` may not live long enough\n-  --> $DIR/regions-close-over-type-parameter-1.rs:10:5\n+  --> $DIR/regions-close-over-type-parameter-1.rs:12:5\n    |\n-LL | fn make_object1<A:SomeTrait>(v: A) -> Box<dyn SomeTrait + 'static> {\n+LL | fn make_object1<A: SomeTrait>(v: A) -> Box<dyn SomeTrait + 'static> {\n    |                 -- help: consider adding an explicit lifetime bound...: `A: 'static +`\n LL |     box v as Box<dyn SomeTrait + 'static>\n    |     ^^^^^\n    |\n note: ...so that the type `A` will meet its required lifetime bounds\n-  --> $DIR/regions-close-over-type-parameter-1.rs:10:5\n+  --> $DIR/regions-close-over-type-parameter-1.rs:12:5\n    |\n LL |     box v as Box<dyn SomeTrait + 'static>\n    |     ^^^^^\n \n-error[E0310]: the parameter type `A` may not live long enough\n-  --> $DIR/regions-close-over-type-parameter-1.rs:10:5\n-   |\n-LL | fn make_object1<A:SomeTrait>(v: A) -> Box<dyn SomeTrait + 'static> {\n-   |                 -- help: consider adding an explicit lifetime bound...: `A: 'static +`\n-LL |     box v as Box<dyn SomeTrait + 'static>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that it can be closed over into an object\n-  --> $DIR/regions-close-over-type-parameter-1.rs:10:5\n-   |\n-LL |     box v as Box<dyn SomeTrait + 'static>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error[E0309]: the parameter type `A` may not live long enough\n-  --> $DIR/regions-close-over-type-parameter-1.rs:20:5\n+  --> $DIR/regions-close-over-type-parameter-1.rs:21:5\n    |\n-LL | fn make_object3<'a,'b,A:SomeTrait+'a>(v: A) -> Box<dyn SomeTrait + 'b> {\n-   |                       -- help: consider adding an explicit lifetime bound...: `A: 'b +`\n+LL | fn make_object3<'a, 'b, A: SomeTrait + 'a>(v: A) -> Box<dyn SomeTrait + 'b> {\n+   |                         -- help: consider adding an explicit lifetime bound...: `A: 'b +`\n LL |     box v as Box<dyn SomeTrait + 'b>\n    |     ^^^^^\n    |\n note: ...so that the type `A` will meet its required lifetime bounds\n-  --> $DIR/regions-close-over-type-parameter-1.rs:20:5\n+  --> $DIR/regions-close-over-type-parameter-1.rs:21:5\n    |\n LL |     box v as Box<dyn SomeTrait + 'b>\n    |     ^^^^^\n \n-error[E0309]: the parameter type `A` may not live long enough\n-  --> $DIR/regions-close-over-type-parameter-1.rs:20:5\n-   |\n-LL | fn make_object3<'a,'b,A:SomeTrait+'a>(v: A) -> Box<dyn SomeTrait + 'b> {\n-   |                       -- help: consider adding an explicit lifetime bound...: `A: 'b +`\n-LL |     box v as Box<dyn SomeTrait + 'b>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that it can be closed over into an object\n-  --> $DIR/regions-close-over-type-parameter-1.rs:20:5\n-   |\n-LL |     box v as Box<dyn SomeTrait + 'b>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0309, E0310.\n For more information about an error, try `rustc --explain E0309`."}, {"sha": "9f425125b9896eca564b1efc5b232e9c0e3a2564", "filename": "src/test/ui/regions/regions-escape-method.nll.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fregions%2Fregions-escape-method.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fregions%2Fregions-escape-method.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-escape-method.nll.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,11 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/regions-escape-method.rs:15:13\n-   |\n-LL |     s.f(|p| p)\n-   |          -- ^ returning this value requires that `'1` must outlive `'2`\n-   |          ||\n-   |          |return type of closure is &'2 i32\n-   |          has type `&'1 i32`\n-\n-error: aborting due to previous error\n-"}, {"sha": "69c01ae6906cb86c20df592de359a87a68a82cf1", "filename": "src/test/ui/regions/regions-escape-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-escape-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-escape-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-escape-method.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -12,5 +12,5 @@ impl S {\n \n fn main() {\n     let s = S;\n-    s.f(|p| p) //~ ERROR cannot infer\n+    s.f(|p| p) //~ ERROR lifetime may not live long enough\n }"}, {"sha": "9f425125b9896eca564b1efc5b232e9c0e3a2564", "filename": "src/test/ui/regions/regions-escape-method.stderr", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-escape-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-escape-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-escape-method.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,32 +1,11 @@\n-error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+error: lifetime may not live long enough\n   --> $DIR/regions-escape-method.rs:15:13\n    |\n LL |     s.f(|p| p)\n-   |             ^\n-   |\n-note: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the body at 15:9...\n-  --> $DIR/regions-escape-method.rs:15:9\n-   |\n-LL |     s.f(|p| p)\n-   |         ^^^^^\n-note: ...so that the expression is assignable\n-  --> $DIR/regions-escape-method.rs:15:13\n-   |\n-LL |     s.f(|p| p)\n-   |             ^\n-   = note: expected  `&i32`\n-              found  `&i32`\n-note: but, the lifetime must be valid for the method call at 15:5...\n-  --> $DIR/regions-escape-method.rs:15:5\n-   |\n-LL |     s.f(|p| p)\n-   |     ^^^^^^^^^^\n-note: ...so that a type/lifetime parameter is in scope here\n-  --> $DIR/regions-escape-method.rs:15:5\n-   |\n-LL |     s.f(|p| p)\n-   |     ^^^^^^^^^^\n+   |          -- ^ returning this value requires that `'1` must outlive `'2`\n+   |          ||\n+   |          |return type of closure is &'2 i32\n+   |          has type `&'1 i32`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`."}, {"sha": "cae6c33ac6e1759b00ff891f06aaf16cfa6f338a", "filename": "src/test/ui/regions/regions-escape-via-trait-or-not.nll.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fregions%2Fregions-escape-via-trait-or-not.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fregions%2Fregions-escape-via-trait-or-not.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-escape-via-trait-or-not.nll.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,11 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/regions-escape-via-trait-or-not.rs:18:14\n-   |\n-LL |     with(|o| o)\n-   |           -- ^ returning this value requires that `'1` must outlive `'2`\n-   |           ||\n-   |           |return type of closure is &'2 isize\n-   |           has type `&'1 isize`\n-\n-error: aborting due to previous error\n-"}, {"sha": "ac0e56de4a0300eb73839fae3503dd2250bd64a2", "filename": "src/test/ui/regions/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-escape-via-trait-or-not.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -15,7 +15,7 @@ fn with<R:Deref, F>(f: F) -> isize where F: FnOnce(&isize) -> R {\n }\n \n fn return_it() -> isize {\n-    with(|o| o) //~ ERROR cannot infer\n+    with(|o| o) //~ ERROR lifetime may not live long enough\n }\n \n fn main() {"}, {"sha": "cae6c33ac6e1759b00ff891f06aaf16cfa6f338a", "filename": "src/test/ui/regions/regions-escape-via-trait-or-not.stderr", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-escape-via-trait-or-not.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-escape-via-trait-or-not.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-escape-via-trait-or-not.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,32 +1,11 @@\n-error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+error: lifetime may not live long enough\n   --> $DIR/regions-escape-via-trait-or-not.rs:18:14\n    |\n LL |     with(|o| o)\n-   |              ^\n-   |\n-note: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the body at 18:10...\n-  --> $DIR/regions-escape-via-trait-or-not.rs:18:10\n-   |\n-LL |     with(|o| o)\n-   |          ^^^^^\n-note: ...so that the expression is assignable\n-  --> $DIR/regions-escape-via-trait-or-not.rs:18:14\n-   |\n-LL |     with(|o| o)\n-   |              ^\n-   = note: expected  `&isize`\n-              found  `&isize`\n-note: but, the lifetime must be valid for the expression at 18:5...\n-  --> $DIR/regions-escape-via-trait-or-not.rs:18:5\n-   |\n-LL |     with(|o| o)\n-   |     ^^^^\n-note: ...so type `fn([closure@$DIR/regions-escape-via-trait-or-not.rs:18:10: 18:15]) -> isize {with::<&isize, [closure@$DIR/regions-escape-via-trait-or-not.rs:18:10: 18:15]>}` of expression is valid during the expression\n-  --> $DIR/regions-escape-via-trait-or-not.rs:18:5\n-   |\n-LL |     with(|o| o)\n-   |     ^^^^\n+   |           -- ^ returning this value requires that `'1` must outlive `'2`\n+   |           ||\n+   |           |return type of closure is &'2 isize\n+   |           has type `&'1 isize`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`."}, {"sha": "ca51555a07749355b46a7d02bdd995d97022a486", "filename": "src/test/ui/regions/regions-infer-call-3.nll.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fregions%2Fregions-infer-call-3.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fregions%2Fregions-infer-call-3.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-call-3.nll.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,11 +0,0 @@\n-error: lifetime may not live long enough\n-  --> $DIR/regions-infer-call-3.rs:8:24\n-   |\n-LL |     let z = with(|y| { select(x, y) });\n-   |                   --   ^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'2`\n-   |                   ||\n-   |                   |return type of closure is &'2 isize\n-   |                   has type `&'1 isize`\n-\n-error: aborting due to previous error\n-"}, {"sha": "063ec84288d1f79a57dde81a7362d86392b6fb3d", "filename": "src/test/ui/regions/regions-infer-call-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-infer-call-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-infer-call-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-call-3.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -6,7 +6,7 @@ fn with<T, F>(f: F) -> T where F: FnOnce(&isize) -> T {\n \n fn manip<'a>(x: &'a isize) -> isize {\n     let z = with(|y| { select(x, y) });\n-    //~^ ERROR cannot infer\n+    //~^ ERROR lifetime may not live long enough\n     *z\n }\n "}, {"sha": "ca51555a07749355b46a7d02bdd995d97022a486", "filename": "src/test/ui/regions/regions-infer-call-3.stderr", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-infer-call-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-infer-call-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-call-3.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,30 +1,11 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter 'r in function call due to conflicting requirements\n+error: lifetime may not live long enough\n   --> $DIR/regions-infer-call-3.rs:8:24\n    |\n LL |     let z = with(|y| { select(x, y) });\n-   |                        ^^^^^^^^^^^^\n-   |\n-note: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the body at 8:18...\n-  --> $DIR/regions-infer-call-3.rs:8:18\n-   |\n-LL |     let z = with(|y| { select(x, y) });\n-   |                  ^^^^^^^^^^^^^^^^^^^^\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/regions-infer-call-3.rs:8:34\n-   |\n-LL |     let z = with(|y| { select(x, y) });\n-   |                                  ^\n-note: but, the lifetime must be valid for the call at 8:13...\n-  --> $DIR/regions-infer-call-3.rs:8:13\n-   |\n-LL |     let z = with(|y| { select(x, y) });\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...so type `&isize` of expression is valid during the expression\n-  --> $DIR/regions-infer-call-3.rs:8:13\n-   |\n-LL |     let z = with(|y| { select(x, y) });\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                   --   ^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'2`\n+   |                   ||\n+   |                   |return type of closure is &'2 isize\n+   |                   has type `&'1 isize`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`."}, {"sha": "4c275b19492c69a0d6088f0721969a2badfee555", "filename": "src/test/ui/regions/regions-return-ref-to-upvar-issue-17403.nll.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3137f8e2d141d7d7c65040a718a9193f50e1282e/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.nll.stderr?ref=3137f8e2d141d7d7c65040a718a9193f50e1282e", "patch": "@@ -1,13 +0,0 @@\n-error: captured variable cannot escape `FnMut` closure body\n-  --> $DIR/regions-return-ref-to-upvar-issue-17403.rs:7:24\n-   |\n-LL |         let mut f = || &mut x;\n-   |                      - ^^^^^^ returns a reference to a captured variable which escapes the closure body\n-   |                      |\n-   |                      inferred to be a `FnMut` closure\n-   |\n-   = note: `FnMut` closures only have access to their captured variables while they are executing...\n-   = note: ...therefore, they cannot allow references to captured variables to escape\n-\n-error: aborting due to previous error\n-"}, {"sha": "86e759f088a549e7d4aa8f87577810e28b8bb1c7", "filename": "src/test/ui/regions/regions-return-ref-to-upvar-issue-17403.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     // Unboxed closure case\n     {\n         let mut x = 0;\n-        let mut f = || &mut x; //~ ERROR cannot infer\n+        let mut f = || &mut x; //~ ERROR captured variable cannot escape `FnMut` closure body\n         let x = f();\n         let y = f();\n     }"}, {"sha": "4c275b19492c69a0d6088f0721969a2badfee555", "filename": "src/test/ui/regions/regions-return-ref-to-upvar-issue-17403.stderr", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -1,30 +1,13 @@\n-error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n+error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/regions-return-ref-to-upvar-issue-17403.rs:7:24\n    |\n LL |         let mut f = || &mut x;\n-   |                        ^^^^^^\n+   |                      - ^^^^^^ returns a reference to a captured variable which escapes the closure body\n+   |                      |\n+   |                      inferred to be a `FnMut` closure\n    |\n-note: first, the lifetime cannot outlive the lifetime `'_` as defined on the body at 7:21...\n-  --> $DIR/regions-return-ref-to-upvar-issue-17403.rs:7:21\n-   |\n-LL |         let mut f = || &mut x;\n-   |                     ^^^^^^^^^\n-note: ...so that closure can access `x`\n-  --> $DIR/regions-return-ref-to-upvar-issue-17403.rs:7:24\n-   |\n-LL |         let mut f = || &mut x;\n-   |                        ^^^^^^\n-note: but, the lifetime must be valid for the call at 9:17...\n-  --> $DIR/regions-return-ref-to-upvar-issue-17403.rs:9:17\n-   |\n-LL |         let y = f();\n-   |                 ^^^\n-note: ...so type `&mut i32` of expression is valid during the expression\n-  --> $DIR/regions-return-ref-to-upvar-issue-17403.rs:9:17\n-   |\n-LL |         let y = f();\n-   |                 ^^^\n+   = note: `FnMut` closures only have access to their captured variables while they are executing...\n+   = note: ...therefore, they cannot allow references to captured variables to escape\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`."}, {"sha": "cdcf89e4e614e31263fc0b327eceafb6fe410f24", "filename": "src/test/ui/symbol-names/impl1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b605c8cb2f730e607de0777a694cd1b9bb3e15/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs?ref=52b605c8cb2f730e607de0777a694cd1b9bb3e15", "patch": "@@ -3,8 +3,8 @@\n // revisions: legacy v0\n //[legacy]compile-flags: -Z symbol-mangling-version=legacy\n     //[v0]compile-flags: -Z symbol-mangling-version=v0\n-//[legacy]normalize-stderr-32bit: \"hdb62078998ce7ea8\" -> \"SYMBOL_HASH\"\n-//[legacy]normalize-stderr-64bit: \"h62e540f14f879d56\" -> \"SYMBOL_HASH\"\n+//[legacy]normalize-stderr-32bit: \"h5ef5dfc14aeecbfc\" -> \"SYMBOL_HASH\"\n+//[legacy]normalize-stderr-64bit: \"h9e54d216f70fcbc5\" -> \"SYMBOL_HASH\"\n \n #![feature(optin_builtin_traits, rustc_attrs)]\n #![allow(dead_code)]"}]}