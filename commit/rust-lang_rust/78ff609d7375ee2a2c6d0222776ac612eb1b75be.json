{"sha": "78ff609d7375ee2a2c6d0222776ac612eb1b75be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZmY2MDlkNzM3NWVlMmEyYzZkMDIyMjc3NmFjNjEyZWIxYjc1YmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-19T20:20:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-19T20:20:12Z"}, "message": "Auto merge of #55152 - nikomatsakis:nll-issue-54571-type-annot-in-constants, r=pnkfelix\n\nsupport type annot in constants, casts\n\nFixes #54571\nFixes #54332\nFixes #55183\n\nr? @pnkfelix", "tree": {"sha": "96657ab509a45e40af4d17261b53244a67d1293c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96657ab509a45e40af4d17261b53244a67d1293c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78ff609d7375ee2a2c6d0222776ac612eb1b75be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78ff609d7375ee2a2c6d0222776ac612eb1b75be", "html_url": "https://github.com/rust-lang/rust/commit/78ff609d7375ee2a2c6d0222776ac612eb1b75be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78ff609d7375ee2a2c6d0222776ac612eb1b75be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "url": "https://api.github.com/repos/rust-lang/rust/commits/74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "html_url": "https://github.com/rust-lang/rust/commit/74ff7dcb1388e60a613cd6050bcd372a3cc4998b"}, {"sha": "9a7bb0ef249258aacf144d04f5d437ba70533128", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a7bb0ef249258aacf144d04f5d437ba70533128", "html_url": "https://github.com/rust-lang/rust/commit/9a7bb0ef249258aacf144d04f5d437ba70533128"}], "stats": {"total": 829, "additions": 553, "deletions": 276}, "files": [{"sha": "a82a8ca6bdff0e1ef312a615b0984010a21596f5", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -597,11 +597,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::UserTypeAnnotation<\n             mir::UserTypeAnnotation::Ty(ref ty) => {\n                 ty.hash_stable(hcx, hasher);\n             }\n-            mir::UserTypeAnnotation::FnDef(ref def_id, ref substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            mir::UserTypeAnnotation::AdtDef(ref def_id, ref substs) => {\n+            mir::UserTypeAnnotation::TypeOf(ref def_id, ref substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }"}, {"sha": "b9edc9f51eaa890d8be3297b1784b42aa346662d", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -19,7 +19,7 @@\n \n use infer::canonical::substitute::substitute_value;\n use infer::canonical::{\n-    Canonical, CanonicalVarKind, CanonicalVarValues, CanonicalizedQueryResponse, Certainty,\n+    Canonical, CanonicalVarValues, CanonicalizedQueryResponse, Certainty,\n     OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n };\n use infer::region_constraints::{Constraint, RegionConstraintData};\n@@ -262,13 +262,6 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n-        // In an NLL query, there should be no type variables in the\n-        // query, only region variables.\n-        debug_assert!(query_response.variables.iter().all(|v| match v.kind {\n-            CanonicalVarKind::Ty(_) => false,\n-            CanonicalVarKind::Region => true,\n-        }));\n-\n         let result_subst =\n             self.query_response_substitution_guess(cause, original_values, query_response);\n "}, {"sha": "df30ad360062c22083a3a4df3471b8c30352fd04", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -149,7 +149,7 @@ pub struct Verify<'tcx> {\n     pub bound: VerifyBound<'tcx>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum GenericKind<'tcx> {\n     Param(ty::ParamTy),\n     Projection(ty::ProjectionTy<'tcx>),"}, {"sha": "34fc81a495e249682fa9ccd9bf63c2ab47b731e5", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -2425,15 +2425,16 @@ pub struct Constant<'tcx> {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum UserTypeAnnotation<'tcx> {\n     Ty(CanonicalTy<'tcx>),\n-    FnDef(DefId, CanonicalUserSubsts<'tcx>),\n-    AdtDef(&'tcx AdtDef, CanonicalUserSubsts<'tcx>),\n+\n+    /// The canonical type is the result of `type_of(def_id)` with the\n+    /// given substitutions applied.\n+    TypeOf(DefId, CanonicalUserSubsts<'tcx>),\n }\n \n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for UserTypeAnnotation<'tcx> {\n         (UserTypeAnnotation::Ty)(ty),\n-        (UserTypeAnnotation::FnDef)(def, substs),\n-        (UserTypeAnnotation::AdtDef)(def, substs),\n+        (UserTypeAnnotation::TypeOf)(def, substs),\n     }\n }\n "}, {"sha": "2c84a9e014e93ffcf6c71925fb3a50cc005dbc7e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -25,7 +25,7 @@ use rustc::mir::{\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common;\n use rustc_data_structures::bit_set::BitSet;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n@@ -67,10 +67,8 @@ pub struct RegionInferenceContext<'tcx> {\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n     /// Map closure bounds to a `Span` that should be used for error reporting.\n-    closure_bounds_mapping: FxHashMap<\n-        Location,\n-        FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n-    >,\n+    closure_bounds_mapping:\n+        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n     /// Contains the minimum universe of any variable within the same\n     /// SCC. We will ensure that no SCC contains values that are not\n@@ -580,6 +578,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         let tcx = infcx.tcx;\n \n+        // Sometimes we register equivalent type-tests that would\n+        // result in basically the exact same error being reported to\n+        // the user. Avoid that.\n+        let mut deduplicate_errors = FxHashSet::default();\n+\n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n@@ -605,11 +608,31 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n             }\n \n-            // Oh the humanity. Obviously we will do better than this error eventually.\n+            // Type-test failed. Report the error.\n+\n+            // Try to convert the lower-bound region into something named we can print for the user.\n             let lower_bound_region = self.to_error_region(type_test.lower_bound);\n+\n+            // Skip duplicate-ish errors.\n+            let type_test_span = type_test.locations.span(mir);\n+            let erased_generic_kind = tcx.erase_regions(&type_test.generic_kind);\n+            if !deduplicate_errors.insert((\n+                erased_generic_kind,\n+                lower_bound_region,\n+                type_test.locations,\n+            )) {\n+                continue;\n+            } else {\n+                debug!(\n+                    \"check_type_test: reporting error for erased_generic_kind={:?}, \\\n+                     lower_bound_region={:?}, \\\n+                     type_test.locations={:?}\",\n+                    erased_generic_kind, lower_bound_region, type_test.locations,\n+                );\n+            }\n+\n             if let Some(lower_bound_region) = lower_bound_region {\n                 let region_scope_tree = &tcx.region_scope_tree(mir_def_id);\n-                let type_test_span = type_test.locations.span(mir);\n                 infcx\n                     .construct_generic_bound_failure(\n                         region_scope_tree,\n@@ -629,7 +652,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // to report it; we could probably handle it by\n                 // iterating over the universal regions and reporting\n                 // an error that multiple bounds are required.\n-                let type_test_span = type_test.locations.span(mir);\n                 tcx.sess\n                     .struct_span_err(\n                         type_test_span,"}, {"sha": "994f20a011d650541e2fd4ec893aee6c1327f660", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -142,6 +142,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     }\n \n     fn add_type_test(&mut self, type_test: TypeTest<'tcx>) {\n+        debug!(\"add_type_test(type_test={:?})\", type_test);\n         self.type_tests.push(type_test);\n     }\n }"}, {"sha": "7737fcc765d801133f36a35790953d4c449f50a9", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 163, "deletions": 64, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -42,7 +42,7 @@ use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n+use rustc::ty::subst::{Subst, Substs, UnpackedKind, UserSelfTy, UserSubsts};\n use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use std::rc::Rc;\n use std::{fmt, iter};\n@@ -753,10 +753,8 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n \n     crate outlives_constraints: ConstraintSet,\n \n-    crate closure_bounds_mapping: FxHashMap<\n-        Location,\n-        FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n-    >,\n+    crate closure_bounds_mapping:\n+        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n     crate type_tests: Vec<TypeTest<'tcx>>,\n }\n@@ -866,7 +864,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         &mut self,\n         locations: Locations,\n         category: ConstraintCategory,\n-        op: impl type_op::TypeOp<'gcx, 'tcx, Output=R>,\n+        op: impl type_op::TypeOp<'gcx, 'tcx, Output = R>,\n     ) -> Fallible<R> {\n         let (r, opt_data) = op.fully_perform(self.infcx)?;\n \n@@ -903,23 +901,37 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn sub_types(\n+    /// Convenient wrapper around `relate_tys::relate_types` -- see\n+    /// that fn for docs.\n+    fn relate_types(\n         &mut self,\n-        sub: Ty<'tcx>,\n-        sup: Ty<'tcx>,\n+        a: Ty<'tcx>,\n+        v: ty::Variance,\n+        b: Ty<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        relate_tys::sub_types(\n+        relate_tys::relate_types(\n             self.infcx,\n-            sub,\n-            sup,\n+            a,\n+            v,\n+            b,\n             locations,\n             category,\n             self.borrowck_context.as_mut().map(|x| &mut **x),\n         )\n     }\n \n+    fn sub_types(\n+        &mut self,\n+        sub: Ty<'tcx>,\n+        sup: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n+        self.relate_types(sub, ty::Variance::Covariant, sup, locations, category)\n+    }\n+\n     /// Try to relate `sub <: sup`; if this fails, instantiate opaque\n     /// variables in `sub` with their inferred definitions and try\n     /// again. This is used for opaque types in places (e.g., `let x:\n@@ -952,41 +964,133 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        relate_tys::eq_types(\n-            self.infcx,\n-            a,\n-            b,\n-            locations,\n-            category,\n-            self.borrowck_context.as_mut().map(|x| &mut **x),\n-        )\n+        self.relate_types(a, ty::Variance::Invariant, b, locations, category)\n     }\n \n     fn relate_type_and_user_type(\n         &mut self,\n         a: Ty<'tcx>,\n         v: ty::Variance,\n-        b: UserTypeAnnotation<'tcx>,\n+        user_ty: UserTypeAnnotation<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        let ty = relate_tys::relate_type_and_user_type(\n-            self.infcx,\n-            a,\n-            v,\n-            b,\n-            locations,\n-            category,\n-            self.borrowck_context.as_mut().map(|x| &mut **x),\n-        )?;\n-        self.prove_predicate(\n-            ty::Predicate::WellFormed(ty),\n-            locations,\n-            category,\n+        let tcx = self.tcx();\n+\n+        debug!(\n+            \"relate_type_and_user_type(a={:?}, v={:?}, b={:?}, locations={:?})\",\n+            a, v, user_ty, locations\n         );\n+\n+        // The `TypeRelating` code assumes that \"unresolved inference\n+        // variables\" appear in the \"a\" side, so flip `Contravariant`\n+        // ambient variance to get the right relationship.\n+        let v1 = ty::Contravariant.xform(v);\n+\n+        match user_ty {\n+            UserTypeAnnotation::Ty(canonical_ty) => {\n+                let (ty, _) = self.infcx\n+                    .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_ty);\n+\n+                self.relate_types(ty, v1, a, locations, category)?;\n+\n+                self.prove_predicate(ty::Predicate::WellFormed(ty), locations, category);\n+            }\n+            UserTypeAnnotation::TypeOf(def_id, canonical_substs) => {\n+                let (\n+                    UserSubsts {\n+                        substs,\n+                        user_self_ty,\n+                    },\n+                    _,\n+                ) = self.infcx\n+                    .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n+\n+                let ty = self.tcx().type_of(def_id);\n+                let ty = ty.subst(tcx, substs);\n+                let ty = self.normalize(ty, locations);\n+\n+                self.relate_types(ty, v1, a, locations, category)?;\n+\n+                if let Some(UserSelfTy {\n+                    impl_def_id,\n+                    self_ty,\n+                }) = user_self_ty\n+                {\n+                    let impl_self_ty = tcx.type_of(impl_def_id);\n+                    let impl_self_ty = impl_self_ty.subst(tcx, &substs);\n+                    let impl_self_ty = self.normalize(impl_self_ty, locations);\n+\n+                    // There may be type variables in `substs` and hence\n+                    // in `impl_self_ty`, but they should all have been\n+                    // resolved to some fixed value during the first call\n+                    // to `relate`, above. Therefore, if we use\n+                    // `resolve_type_vars_if_possible` we should get to\n+                    // something without type variables. This is important\n+                    // because the `b` type in `relate_with_variance`\n+                    // below is not permitted to have inference variables.\n+                    let impl_self_ty = self.infcx.resolve_type_vars_if_possible(&impl_self_ty);\n+                    assert!(!impl_self_ty.has_infer_types());\n+\n+                    self.eq_types(self_ty, impl_self_ty, locations, category)?;\n+                }\n+\n+                // Prove the predicates coming along with `def_id`.\n+                //\n+                // Also, normalize the `instantiated_predicates`\n+                // because otherwise we wind up with duplicate \"type\n+                // outlives\" error messages.\n+                let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n+                let instantiated_predicates = self.fold_to_region_vid(instantiated_predicates);\n+                self.normalize_and_prove_instantiated_predicates(\n+                    instantiated_predicates,\n+                    locations,\n+                );\n+\n+                // In addition to proving the predicates, we have to\n+                // prove that `ty` is well-formed -- this is because\n+                // the WF of `ty` is predicated on the substs being\n+                // well-formed, and we haven't proven *that*. We don't\n+                // want to prove the WF of types from  `substs` directly because they\n+                // haven't been normalized.\n+                //\n+                // FIXME(nmatsakis): Well, perhaps we should normalize\n+                // them?  This would only be relevant if some input\n+                // type were ill-formed but did not appear in `ty`,\n+                // which...could happen with normalization...\n+                self.prove_predicate(ty::Predicate::WellFormed(ty), locations, category);\n+            }\n+        }\n+\n         Ok(())\n     }\n \n+    /// Replace all free regions in `value` with their NLL `RegionVid`\n+    /// equivalents; if not in NLL, does nothing. This is never\n+    /// particularly necessary -- we'll do it lazilly as we process\n+    /// the value anyway -- but in some specific cases it is useful to\n+    /// normalize so we can suppress duplicate error messages.\n+    fn fold_to_region_vid<T>(\n+        &self,\n+        value: T\n+    ) -> T\n+    where T: TypeFoldable<'tcx>\n+    {\n+        if let Some(borrowck_context) = &self.borrowck_context {\n+            self.tcx().fold_regions(&value, &mut false, |r, _debruijn| {\n+                if r.has_free_regions() {\n+                    self.tcx().mk_region(ty::RegionKind::ReVar(\n+                        borrowck_context.universal_regions.to_region_vid(r),\n+                    ))\n+                } else {\n+                    r\n+                }\n+            })\n+        } else {\n+            value\n+        }\n+    }\n+\n     fn eq_opaque_type_and_type(\n         &mut self,\n         revealed_ty: Ty<'tcx>,\n@@ -1115,17 +1219,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n                 if let Err(terr) =\n-                self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n-                    {\n-                        span_mirbug!(\n+                    self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n+                {\n+                    span_mirbug!(\n                         self,\n                         stmt,\n                         \"bad assignment ({:?} = {:?}): {:?}\",\n                         place_ty,\n                         rv_ty,\n                         terr\n                     );\n-                    }\n+                }\n \n                 if let Some(user_ty) = self.rvalue_user_ty(rv) {\n                     if let Err(terr) = self.relate_type_and_user_type(\n@@ -1245,17 +1349,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let locations = term_location.to_locations();\n                 if let Err(terr) =\n-                self.sub_types(rv_ty, place_ty, locations, ConstraintCategory::Assignment)\n-                    {\n-                        span_mirbug!(\n+                    self.sub_types(rv_ty, place_ty, locations, ConstraintCategory::Assignment)\n+                {\n+                    span_mirbug!(\n                         self,\n                         term,\n                         \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n                         place_ty,\n                         rv_ty,\n                         terr\n                     );\n-                    }\n+                }\n             }\n             TerminatorKind::SwitchInt {\n                 ref discr,\n@@ -1399,17 +1503,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let locations = term_location.to_locations();\n \n                 if let Err(terr) =\n-                self.sub_types_or_anon(sig.output(), dest_ty, locations, category)\n-                    {\n-                        span_mirbug!(\n+                    self.sub_types_or_anon(sig.output(), dest_ty, locations, category)\n+                {\n+                    span_mirbug!(\n                         self,\n                         term,\n                         \"call dest mismatch ({:?} <- {:?}): {:?}\",\n                         dest_ty,\n                         sig.output(),\n                         terr\n                     );\n-                    }\n+                }\n \n                 // When `#![feature(unsized_locals)]` is not enabled,\n                 // this check is done at `check_local`.\n@@ -2050,7 +2154,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             aggregate_kind, location\n         );\n \n-        let instantiated_predicates = match aggregate_kind  {\n+        let instantiated_predicates = match aggregate_kind {\n             AggregateKind::Adt(def, _, substs, _, _) => {\n                 tcx.predicates_of(def.did).instantiate(tcx, substs)\n             }\n@@ -2096,15 +2200,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n-        if let Some(closure_region_requirements) =\n-            tcx.mir_borrowck(def_id).closure_requirements\n-        {\n-            let closure_constraints = closure_region_requirements.apply_requirements(\n-                tcx,\n-                location,\n-                def_id,\n-                substs,\n-            );\n+        if let Some(closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n+            let closure_constraints =\n+                closure_region_requirements.apply_requirements(tcx, location, def_id, substs);\n \n             if let Some(ref mut borrowck_context) = self.borrowck_context {\n                 let bounds_mapping = closure_constraints\n@@ -2113,19 +2211,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     .filter_map(|(idx, constraint)| {\n                         let ty::OutlivesPredicate(k1, r2) =\n                             constraint.no_late_bound_regions().unwrap_or_else(|| {\n-                                bug!(\n-                                    \"query_constraint {:?} contained bound regions\",\n-                                    constraint,\n-                                );\n+                                bug!(\"query_constraint {:?} contained bound regions\", constraint,);\n                             });\n \n                         match k1.unpack() {\n                             UnpackedKind::Lifetime(r1) => {\n                                 // constraint is r1: r2\n                                 let r1_vid = borrowck_context.universal_regions.to_region_vid(r1);\n                                 let r2_vid = borrowck_context.universal_regions.to_region_vid(r2);\n-                                let outlives_requirements = &closure_region_requirements\n-                                    .outlives_requirements[idx];\n+                                let outlives_requirements =\n+                                    &closure_region_requirements.outlives_requirements[idx];\n                                 Some((\n                                     (r1_vid, r2_vid),\n                                     (\n@@ -2139,10 +2234,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     })\n                     .collect();\n \n-                let existing = borrowck_context.constraints\n+                let existing = borrowck_context\n+                    .constraints\n                     .closure_bounds_mapping\n                     .insert(location, bounds_mapping);\n-                assert!(existing.is_none(), \"Multiple closures at the same location.\");\n+                assert!(\n+                    existing.is_none(),\n+                    \"Multiple closures at the same location.\"\n+                );\n             }\n \n             self.push_region_constraints("}, {"sha": "13ebf46bdb14904fa56eb17bf9182e52668d376f", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 14, "deletions": 120, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -12,35 +12,23 @@ use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n-use rustc::mir::{ConstraintCategory, UserTypeAnnotation};\n+use rustc::mir::ConstraintCategory;\n use rustc::traits::query::Fallible;\n use rustc::ty::relate::TypeRelation;\n-use rustc::ty::subst::{Subst, UserSelfTy, UserSubsts};\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use syntax_pos::DUMMY_SP;\n-\n-/// Adds sufficient constraints to ensure that `a <: b`.\n-pub(super) fn sub_types<'tcx>(\n-    infcx: &InferCtxt<'_, '_, 'tcx>,\n-    a: Ty<'tcx>,\n-    b: Ty<'tcx>,\n-    locations: Locations,\n-    category: ConstraintCategory,\n-    borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n-) -> Fallible<()> {\n-    debug!(\"sub_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n-    TypeRelating::new(\n-        infcx,\n-        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n-        ty::Variance::Covariant,\n-    ).relate(&a, &b)?;\n-    Ok(())\n-}\n-\n-/// Adds sufficient constraints to ensure that `a == b`.\n-pub(super) fn eq_types<'tcx>(\n+use rustc::ty::{self, Ty};\n+\n+/// Adds sufficient constraints to ensure that `a R b` where `R` depends on `v`:\n+///\n+/// - \"Covariant\" `a <: b`\n+/// - \"Invariant\" `a == b`\n+/// - \"Contravariant\" `a :> b`\n+///\n+/// NB. The type `a` is permitted to have unresolved inference\n+/// variables, but not the type `b`.\n+pub(super) fn relate_types<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n     a: Ty<'tcx>,\n+    v: ty::Variance,\n     b: Ty<'tcx>,\n     locations: Locations,\n     category: ConstraintCategory,\n@@ -50,105 +38,11 @@ pub(super) fn eq_types<'tcx>(\n     TypeRelating::new(\n         infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n-        ty::Variance::Invariant,\n+        v,\n     ).relate(&a, &b)?;\n     Ok(())\n }\n \n-/// Adds sufficient constraints to ensure that `a <: b`, where `b` is\n-/// a user-given type (which means it may have canonical variables\n-/// encoding things like `_`).\n-pub(super) fn relate_type_and_user_type<'tcx>(\n-    infcx: &InferCtxt<'_, '_, 'tcx>,\n-    a: Ty<'tcx>,\n-    v: ty::Variance,\n-    user_ty: UserTypeAnnotation<'tcx>,\n-    locations: Locations,\n-    category: ConstraintCategory,\n-    borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n-) -> Fallible<Ty<'tcx>> {\n-    debug!(\n-        \"relate_type_and_user_type(a={:?}, v={:?}, b={:?}, locations={:?})\",\n-        a, v, user_ty, locations\n-    );\n-\n-    // The `TypeRelating` code assumes that the \"canonical variables\"\n-    // appear in the \"a\" side, so flip `Contravariant` ambient\n-    // variance to get the right relationship.\n-    let v1 = ty::Contravariant.xform(v);\n-\n-    let mut type_relating = TypeRelating::new(\n-        infcx,\n-        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n-        v1,\n-    );\n-\n-    match user_ty {\n-        UserTypeAnnotation::Ty(canonical_ty) => {\n-            let (ty, _) =\n-                infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_ty);\n-            type_relating.relate(&ty, &a)?;\n-            Ok(ty)\n-        }\n-        UserTypeAnnotation::FnDef(def_id, canonical_substs) => {\n-            let (\n-                UserSubsts {\n-                    substs,\n-                    user_self_ty,\n-                },\n-                _,\n-            ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n-            let ty = infcx.tcx.mk_fn_def(def_id, substs);\n-\n-            type_relating.relate(&ty, &a)?;\n-\n-            if let Some(UserSelfTy {\n-                impl_def_id,\n-                self_ty,\n-            }) = user_self_ty\n-            {\n-                let impl_self_ty = infcx.tcx.type_of(impl_def_id);\n-                let impl_self_ty = impl_self_ty.subst(infcx.tcx, &substs);\n-\n-                // There may be type variables in `substs` and hence\n-                // in `impl_self_ty`, but they should all have been\n-                // resolved to some fixed value during the first call\n-                // to `relate`, above. Therefore, if we use\n-                // `resolve_type_vars_if_possible` we should get to\n-                // something without type variables. This is important\n-                // because the `b` type in `relate_with_variance`\n-                // below is not permitted to have inference variables.\n-                let impl_self_ty = infcx.resolve_type_vars_if_possible(&impl_self_ty);\n-                assert!(!impl_self_ty.has_infer_types());\n-\n-                type_relating.relate_with_variance(\n-                    ty::Variance::Invariant,\n-                    &self_ty,\n-                    &impl_self_ty,\n-                )?;\n-            }\n-\n-            Ok(ty)\n-        }\n-        UserTypeAnnotation::AdtDef(adt_def, canonical_substs) => {\n-            let (\n-                UserSubsts {\n-                    substs,\n-                    user_self_ty,\n-                },\n-                _,\n-            ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n-\n-            // We don't extract adt-defs with a self-type.\n-            assert!(user_self_ty.is_none());\n-\n-            let ty = infcx.tcx.mk_adt(adt_def, substs);\n-            type_relating.relate(&ty, &a)?;\n-            Ok(ty)\n-        }\n-    }\n-}\n-\n struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n     infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n     borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,"}, {"sha": "820822b7f5bbde45382465ef4a35ce3183580a52", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -139,35 +139,39 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n                 let place = unpack!(block = this.as_place(block, source));\n-                this.cfg.push(\n-                    block,\n-                    Statement {\n-                        source_info,\n-                        kind: StatementKind::AscribeUserType(\n-                            place.clone(),\n-                            Variance::Invariant,\n-                            user_ty,\n-                        ),\n-                    },\n-                );\n+                if let Some(user_ty) = user_ty {\n+                    this.cfg.push(\n+                        block,\n+                        Statement {\n+                            source_info,\n+                            kind: StatementKind::AscribeUserType(\n+                                place.clone(),\n+                                Variance::Invariant,\n+                                user_ty,\n+                            ),\n+                        },\n+                    );\n+                }\n                 block.and(place)\n             }\n             ExprKind::ValueTypeAscription { source, user_ty } => {\n                 let source = this.hir.mirror(source);\n                 let temp = unpack!(\n                     block = this.as_temp(block, source.temp_lifetime, source, mutability)\n                 );\n-                this.cfg.push(\n-                    block,\n-                    Statement {\n-                        source_info,\n-                        kind: StatementKind::AscribeUserType(\n-                            Place::Local(temp.clone()),\n-                            Variance::Invariant,\n-                            user_ty,\n-                        ),\n-                    },\n-                );\n+                if let Some(user_ty) = user_ty {\n+                    this.cfg.push(\n+                        block,\n+                        Statement {\n+                            source_info,\n+                            kind: StatementKind::AscribeUserType(\n+                                Place::Local(temp.clone()),\n+                                Variance::Invariant,\n+                                user_ty,\n+                            ),\n+                        },\n+                    );\n+                }\n                 block.and(Place::Local(temp))\n             }\n "}, {"sha": "1df5f789751399dfeed2fef1b89b648e0db3c3cc", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 66, "deletions": 33, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -295,7 +295,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     let substs = cx.tables().node_substs(fun.hir_id);\n \n                     let user_ty = cx.tables().user_substs(fun.hir_id)\n-                        .map(|user_substs| UserTypeAnnotation::AdtDef(adt_def, user_substs));\n+                        .map(|user_substs| UserTypeAnnotation::TypeOf(adt_def.did, user_substs));\n \n                     let field_refs = args.iter()\n                         .enumerate()\n@@ -637,12 +637,25 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 name: Field::new(cx.tcx.field_index(expr.id, cx.tables)),\n             }\n         }\n-        hir::ExprKind::Cast(ref source, _) => {\n+        hir::ExprKind::Cast(ref source, ref cast_ty) => {\n+            // Check for a user-given type annotation on this `cast`\n+            let user_ty = cx.tables.user_provided_tys().get(cast_ty.hir_id)\n+                .map(|&t| UserTypeAnnotation::Ty(t));\n+\n+            debug!(\n+                \"cast({:?}) has ty w/ hir_id {:?} and user provided ty {:?}\",\n+                expr,\n+                cast_ty.hir_id,\n+                user_ty,\n+            );\n+\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n-            if let Some(&TyCastKind::CoercionCast) = cx.tables()\n-                                                    .cast_kinds()\n-                                                    .get(source.hir_id) {\n+            let cast = if let Some(&TyCastKind::CoercionCast) =\n+                cx.tables()\n+                .cast_kinds()\n+                .get(source.hir_id)\n+            {\n                 // Convert the lexpr to a vexpr.\n                 ExprKind::Use { source: source.to_ref() }\n             } else {\n@@ -679,32 +692,38 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 } else {\n                     None\n                 };\n-                let source = if let Some((did, offset, ty)) = var {\n+\n+                let source = if let Some((did, offset, var_ty)) = var {\n                     let mk_const = |literal| Expr {\n                         temp_lifetime,\n-                        ty,\n+                        ty: var_ty,\n                         span: expr.span,\n                         kind: ExprKind::Literal { literal, user_ty: None },\n                     }.to_ref();\n                     let offset = mk_const(ty::Const::from_bits(\n                         cx.tcx,\n                         offset as u128,\n-                        cx.param_env.and(ty),\n+                        cx.param_env.and(var_ty),\n                     ));\n                     match did {\n                         Some(did) => {\n                             // in case we are offsetting from a computed discriminant\n                             // and not the beginning of discriminants (which is always `0`)\n                             let substs = Substs::identity_for_item(cx.tcx(), did);\n-                            let lhs = mk_const(ty::Const::unevaluated(cx.tcx(), did, substs, ty));\n+                            let lhs = mk_const(ty::Const::unevaluated(\n+                                cx.tcx(),\n+                                did,\n+                                substs,\n+                                var_ty,\n+                            ));\n                             let bin = ExprKind::Binary {\n                                 op: BinOp::Add,\n                                 lhs,\n                                 rhs: offset,\n                             };\n                             Expr {\n                                 temp_lifetime,\n-                                ty,\n+                                ty: var_ty,\n                                 span: expr.span,\n                                 kind: bin,\n                             }.to_ref()\n@@ -714,20 +733,33 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 } else {\n                     source.to_ref()\n                 };\n+\n                 ExprKind::Cast { source }\n+            };\n+\n+            if let Some(user_ty) = user_ty {\n+                // NOTE: Creating a new Expr and wrapping a Cast inside of it may be\n+                //       inefficient, revisit this when performance becomes an issue.\n+                let cast_expr = Expr {\n+                    temp_lifetime,\n+                    ty: expr_ty,\n+                    span: expr.span,\n+                    kind: cast,\n+                };\n+\n+                ExprKind::ValueTypeAscription {\n+                    source: cast_expr.to_ref(),\n+                    user_ty: Some(user_ty),\n+                }\n+            } else {\n+                cast\n             }\n         }\n         hir::ExprKind::Type(ref source, ref ty) => {\n             let user_provided_tys = cx.tables.user_provided_tys();\n-            let user_ty = UserTypeAnnotation::Ty(\n-                *user_provided_tys\n-                    .get(ty.hir_id)\n-                    .expect(&format!(\n-                        \"{:?} not found in user_provided_tys, source: {:?}\",\n-                        ty,\n-                        source,\n-                    ))\n-            );\n+            let user_ty = user_provided_tys\n+                .get(ty.hir_id)\n+                .map(|&c_ty| UserTypeAnnotation::Ty(c_ty));\n             if source.is_place_expr() {\n                 ExprKind::PlaceTypeAscription {\n                     source: source.to_ref(),\n@@ -771,12 +803,10 @@ fn user_substs_applied_to_def(\n         Def::Fn(_) |\n         Def::Method(_) |\n         Def::StructCtor(_, CtorKind::Fn) |\n-        Def::VariantCtor(_, CtorKind::Fn) =>\n-            Some(UserTypeAnnotation::FnDef(def.def_id(), cx.tables().user_substs(hir_id)?)),\n-\n-        Def::Const(_def_id) |\n-        Def::AssociatedConst(_def_id) =>\n-            bug!(\"unimplemented\"),\n+        Def::VariantCtor(_, CtorKind::Fn) |\n+        Def::Const(_) |\n+        Def::AssociatedConst(_) =>\n+            Some(UserTypeAnnotation::TypeOf(def.def_id(), cx.tables().user_substs(hir_id)?)),\n \n         // A unit struct/variant which is used as a value (e.g.,\n         // `None`). This has the type of the enum/struct that defines\n@@ -889,14 +919,17 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         },\n \n         Def::Const(def_id) |\n-        Def::AssociatedConst(def_id) => ExprKind::Literal {\n-            literal: ty::Const::unevaluated(\n-                cx.tcx,\n-                def_id,\n-                substs,\n-                cx.tables().node_id_to_type(expr.hir_id),\n-            ),\n-            user_ty: None, // FIXME(#47184) -- user given type annot on constants\n+        Def::AssociatedConst(def_id) => {\n+            let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n+            ExprKind::Literal {\n+                literal: ty::Const::unevaluated(\n+                    cx.tcx,\n+                    def_id,\n+                    substs,\n+                    cx.tables().node_id_to_type(expr.hir_id),\n+                ),\n+                user_ty,\n+            }\n         },\n \n         Def::StructCtor(def_id, CtorKind::Const) |"}, {"sha": "788db5c0b7e5217ac94d32940b12df8e17ad0ea8", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -276,12 +276,12 @@ pub enum ExprKind<'tcx> {\n     PlaceTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: UserTypeAnnotation<'tcx>,\n+        user_ty: Option<UserTypeAnnotation<'tcx>>,\n     },\n     ValueTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: UserTypeAnnotation<'tcx>,\n+        user_ty: Option<UserTypeAnnotation<'tcx>>,\n     },\n     Closure {\n         closure_id: DefId,"}, {"sha": "f81a0fa5dfadbac95d5717ce9897b58e4652bde2", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -23,7 +23,7 @@ crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n         adt_def: &'tcx AdtDef,\n     ) -> Option<UserTypeAnnotation<'tcx>> {\n         let user_substs = self.tables().user_substs(hir_id)?;\n-        Some(UserTypeAnnotation::AdtDef(adt_def, user_substs))\n+        Some(UserTypeAnnotation::TypeOf(adt_def.did, user_substs))\n     }\n \n     /// Looks up the type associated with this hir-id and applies the\n@@ -35,8 +35,8 @@ crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n     ) -> Option<UserTypeAnnotation<'tcx>> {\n         let user_substs = self.tables().user_substs(hir_id)?;\n         match &self.tables().node_id_to_type(hir_id).sty {\n-            ty::Adt(adt_def, _) => Some(UserTypeAnnotation::AdtDef(adt_def, user_substs)),\n-            ty::FnDef(def_id, _) => Some(UserTypeAnnotation::FnDef(*def_id, user_substs)),\n+            ty::Adt(adt_def, _) => Some(UserTypeAnnotation::TypeOf(adt_def.did, user_substs)),\n+            ty::FnDef(def_id, _) => Some(UserTypeAnnotation::TypeOf(*def_id, user_substs)),\n             sty => bug!(\n                 \"sty: {:?} should not have user-substs {:?} recorded \",\n                 sty,"}, {"sha": "ffa21e1fc22a5b549be85cdb964dd9c8e9964a4f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -2357,6 +2357,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         t\n     }\n \n+    pub fn to_ty_saving_user_provided_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+        let ty = self.to_ty(ast_ty);\n+\n+        // If the type given by the user has free regions, save it for\n+        // later, since NLL would like to enforce those. Also pass in\n+        // types that involve projections, since those can resolve to\n+        // `'static` bounds (modulo #54940, which hopefully will be\n+        // fixed by the time you see this comment, dear reader,\n+        // although I have my doubts). Other sorts of things are\n+        // already sufficiently enforced with erased regions. =)\n+        if ty.has_free_regions() || ty.has_projections() {\n+            let c_ty = self.infcx.canonicalize_response(&ty);\n+            self.tables.borrow_mut().user_provided_tys_mut().insert(ast_ty.hir_id, c_ty);\n+        }\n+\n+        ty\n+    }\n+\n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.tables.borrow().node_types().get(id) {\n             Some(&t) => t,\n@@ -4153,7 +4171,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Cast(ref e, ref t) => {\n                 // Find the type of `e`. Supply hints based on the type we are casting to,\n                 // if appropriate.\n-                let t_cast = self.to_ty(t);\n+                let t_cast = self.to_ty_saving_user_provided_ty(t);\n                 let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n                 let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n                 let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n@@ -4176,10 +4194,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             hir::ExprKind::Type(ref e, ref t) => {\n-                let ty = self.to_ty(&t);\n+                let ty = self.to_ty_saving_user_provided_ty(&t);\n                 self.check_expr_eq_type(&e, ty);\n-                let c_ty = self.infcx.canonicalize_response(&ty);\n-                self.tables.borrow_mut().user_provided_tys_mut().insert(t.hir_id, c_ty);\n                 ty\n             }\n             hir::ExprKind::Array(ref args) => {"}, {"sha": "8142ed0155aaebc581d2d990c98886c6f6821111", "filename": "src/test/ui/consts/const-eval/conditional_array_execution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -17,6 +17,6 @@ const FOO: u32 = [X - Y, Y - X][(X < Y) as usize];\n \n fn main() {\n     println!(\"{}\", FOO);\n-    //~^ ERROR erroneous constant used\n-    //~| E0080\n+    //~^ ERROR\n+    //~| ERROR\n }"}, {"sha": "aa2cf85dfd9992c7cc8416f97f0bcba28b19a394", "filename": "src/test/ui/nll/user-annotations/cast_static_lifetime.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fcast_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fcast_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fcast_static_lifetime.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(nll)]\n+\n+fn main() {\n+    let x = 22_u32;\n+    let y: &u32 = (&x) as &'static u32;\n+}"}, {"sha": "a35035b07ba5463256bf0e95a9f4b3deddb27adc", "filename": "src/test/ui/nll/user-annotations/cast_static_lifetime.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fcast_static_lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fcast_static_lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fcast_static_lifetime.stderr?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,13 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/cast_static_lifetime.rs:16:19\n+   |\n+LL |     let y: &u32 = (&x) as &'static u32;\n+   |                   ^^^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "058ebaee9e512cae26f8fb172ae9468d09783d30", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-inherent-1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,15 @@\n+#![feature(nll)]\n+\n+struct Foo<'a> { x: &'a u32 }\n+\n+impl<'a> Foo<'a> {\n+    const C: &'a u32 = &22;\n+}\n+\n+fn foo<'a>(_: &'a u32) -> &'static u32 {\n+    <Foo<'a>>::C //~ ERROR\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "94fbe01772412081a4fd5f03fc4661cf5fec00aa", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-inherent-1.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,10 @@\n+error: unsatisfied lifetime constraints\n+  --> $DIR/constant-in-expr-inherent-1.rs:10:5\n+   |\n+LL | fn foo<'a>(_: &'a u32) -> &'static u32 {\n+   |        -- lifetime `'a` defined here\n+LL |     <Foo<'a>>::C //~ ERROR\n+   |     ^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "4292fc710e98bb58c49bd7eb2a234614c6a56dee", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-normalize.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-normalize.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,24 @@\n+#![feature(nll)]\n+\n+trait Mirror {\n+    type Me;\n+}\n+\n+impl<T> Mirror for T {\n+    type Me = T;\n+}\n+\n+trait Foo<'a> {\n+    const C: <&'a u32 as Mirror>::Me;\n+}\n+\n+impl<'a, T> Foo<'a> for T {\n+    const C: &'a u32 = &22;\n+}\n+\n+fn foo<'a>(_: &'a u32) -> &'static u32 {\n+    <() as Foo<'a>>::C //~ ERROR\n+}\n+\n+fn main() {\n+}"}, {"sha": "7aeb276eeb929b28a67a50ebade0d081283bbca2", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-normalize.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-normalize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-normalize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-normalize.stderr?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,10 @@\n+error: unsatisfied lifetime constraints\n+  --> $DIR/constant-in-expr-normalize.rs:20:5\n+   |\n+LL | fn foo<'a>(_: &'a u32) -> &'static u32 {\n+   |        -- lifetime `'a` defined here\n+LL |     <() as Foo<'a>>::C //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "daa0d7bc24140b1cbf6d5906b07e950fe8616d14", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-trait-item-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-1.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,16 @@\n+#![feature(nll)]\n+\n+trait Foo<'a> {\n+    const C: &'a u32;\n+}\n+\n+impl<'a, T> Foo<'a> for T {\n+    const C: &'a u32 = &22;\n+}\n+\n+fn foo<'a>(_: &'a u32) -> &'static u32 {\n+    <() as Foo<'a>>::C //~ ERROR\n+}\n+\n+fn main() {\n+}"}, {"sha": "fee9abc1ed83af17f9e09ccdbfca1315b88cea43", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-trait-item-1.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-1.stderr?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,10 @@\n+error: unsatisfied lifetime constraints\n+  --> $DIR/constant-in-expr-trait-item-1.rs:12:5\n+   |\n+LL | fn foo<'a>(_: &'a u32) -> &'static u32 {\n+   |        -- lifetime `'a` defined here\n+LL |     <() as Foo<'a>>::C //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "cd66e7a49cb83d1bc9350b593e1e4ee6047d88e6", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-trait-item-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-2.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,16 @@\n+#![feature(nll)]\n+\n+trait Foo<'a> {\n+    const C: &'a u32;\n+}\n+\n+impl<'a, T> Foo<'a> for T {\n+    const C: &'a u32 = &22;\n+}\n+\n+fn foo<'a, T: Foo<'a>>() -> &'static u32 {\n+    <T as Foo<'a>>::C //~ ERROR\n+}\n+\n+fn main() {\n+}"}, {"sha": "047aad98319232d12dc9a8e6fe3bf31c5fd39791", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-trait-item-2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-2.stderr?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,10 @@\n+error: unsatisfied lifetime constraints\n+  --> $DIR/constant-in-expr-trait-item-2.rs:12:5\n+   |\n+LL | fn foo<'a, T: Foo<'a>>() -> &'static u32 {\n+   |        -- lifetime `'a` defined here\n+LL |     <T as Foo<'a>>::C //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "f83ae2438e6d5dd1fffa6a9eeadd96c0afb575e9", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-trait-item-3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,16 @@\n+#![feature(nll)]\n+\n+trait Foo<'a> {\n+    const C: &'a u32;\n+}\n+\n+impl<'a, T> Foo<'a> for T {\n+    const C: &'a u32 = &22;\n+}\n+\n+fn foo<'a, T: Foo<'a>>() -> &'static u32 {\n+    T::C //~ ERROR\n+}\n+\n+fn main() {\n+}"}, {"sha": "b373cebacb063cb8fd46750373fcba1989f18681", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-trait-item-3.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.stderr?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,10 @@\n+error: unsatisfied lifetime constraints\n+  --> $DIR/constant-in-expr-trait-item-3.rs:12:5\n+   |\n+LL | fn foo<'a, T: Foo<'a>>() -> &'static u32 {\n+   |        -- lifetime `'a` defined here\n+LL |     T::C //~ ERROR\n+   |     ^^^^ returning this value requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "51d9adccd7372184b1c14fb713a0fe1e088b264f", "filename": "src/test/ui/nll/user-annotations/normalization.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,13 @@\n+// Test that we enforce a `&'static` requirement that is only visible\n+// after normalization.\n+\n+#![feature(nll)]\n+#![ignore(unused)]\n+\n+trait Foo { type Out; }\n+impl Foo for () { type Out = &'static u32; }\n+\n+fn main() {\n+    let a = 22;\n+    let b: <() as Foo>::Out = &a; //~ ERROR\n+}"}, {"sha": "489f9feb044c83f0c64fa3c5328ad9a584d47d7b", "filename": "src/test/ui/nll/user-annotations/normalization.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization.stderr?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,13 @@\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/normalization.rs:12:31\n+   |\n+LL |     let b: <() as Foo>::Out = &a; //~ ERROR\n+   |                               ^^ borrowed value does not live long enough\n+LL | }\n+   | - `a` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "d97cc88dd9af4e194fbd659ec0bfd451fa3f69db", "filename": "src/test/ui/nll/user-annotations/normalize-self-ty.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalize-self-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff609d7375ee2a2c6d0222776ac612eb1b75be/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalize-self-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalize-self-ty.rs?ref=78ff609d7375ee2a2c6d0222776ac612eb1b75be", "patch": "@@ -0,0 +1,25 @@\n+// Regression test for #55183: check a case where the self type from\n+// the inherent impl requires normalization to be equal to the\n+// user-provided type.\n+//\n+// run-pass\n+\n+#![feature(nll)]\n+\n+trait Mirror {\n+    type Me;\n+}\n+\n+impl<T> Mirror for T {\n+    type Me = T;\n+}\n+\n+struct Foo<A, B>(A, B);\n+\n+impl<A> Foo<A, <A as Mirror>::Me> {\n+    fn m(b: A) { }\n+}\n+\n+fn main() {\n+    <Foo<&'static u32, &u32>>::m(&22);\n+}"}]}