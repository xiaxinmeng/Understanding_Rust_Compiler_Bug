{"sha": "528379121ceb5fca5382b4337be7ac064890ec8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyODM3OTEyMWNlYjVmY2E1MzgyYjQzMzdiZTdhYzA2NDg5MGVjOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-17T22:21:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-17T22:21:10Z"}, "message": "Auto merge of #64562 - tmandry:rollup-kfk0nuo, r=tmandry\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #61626 (Get rid of special const intrinsic query in favour of `const_eval`)\n - #64283 (Updated RELEASES.md for 1.38.0)\n - #64394 (Shrink `SubregionOrigin`.)\n - #64429 (Fix failure note `to_str` implementation)\n - #64436 (improve Vec example soundness in mem::transmute docs)\n - #64502 (avoid duplicate issues for Miri build failures)\n - #64505 (Fix inconsistent link formatting)\n - #64529 (Add an example to Pin::as_mut)\n - #64541 (document Miri error categories)\n - #64544 (build-manifest: re-add some comments)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8f72f66faa429c166d84a8da85a65b68b408cf81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f72f66faa429c166d84a8da85a65b68b408cf81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/528379121ceb5fca5382b4337be7ac064890ec8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/528379121ceb5fca5382b4337be7ac064890ec8c", "html_url": "https://github.com/rust-lang/rust/commit/528379121ceb5fca5382b4337be7ac064890ec8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/528379121ceb5fca5382b4337be7ac064890ec8c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "html_url": "https://github.com/rust-lang/rust/commit/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5"}, {"sha": "93d610821d9b6d46d93a754df2944e13929c5b31", "url": "https://api.github.com/repos/rust-lang/rust/commits/93d610821d9b6d46d93a754df2944e13929c5b31", "html_url": "https://github.com/rust-lang/rust/commit/93d610821d9b6d46d93a754df2944e13929c5b31"}], "stats": {"total": 531, "additions": 347, "deletions": 184}, "files": [{"sha": "d634feba33ac5ec4be4f43369962f57eda16da8e", "filename": "RELEASES.md", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -1,3 +1,108 @@\n+Version 1.38.0 (2019-09-26)\n+==========================\n+\n+Language\n+--------\n+- [The `#[global_allocator]` attribute can now be used in submodules.][62735]\n+- [The `#[deprecated]` attribute can now be used on macros.][62042]\n+\n+Compiler\n+--------\n+- [Added pipelined compilation support to `rustc`.][62766] This will\n+  improve compilation times in some cases. For further information please refer\n+  to the [_\"Evaluating pipelined rustc compilation\"_][pipeline-internals] thread.\n+- [Added tier 3\\* support for the `aarch64-uwp-windows-msvc`, `i686-uwp-windows-gnu`,\n+  `i686-uwp-windows-msvc`, `x86_64-uwp-windows-gnu`, and\n+  `x86_64-uwp-windows-msvc` targets.][60260]\n+- [Added tier 3 support for the `armv7-unknown-linux-gnueabi` and\n+  `armv7-unknown-linux-musleabi` targets.][63107]\n+- [Added tier 3 support for the `hexagon-unknown-linux-musl` target.][62814]\n+- [Added tier 3 support for the `riscv32i-unknown-none-elf` target.][62784]\n+\n+\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+- [`ascii::EscapeDefault` now implements `Clone` and `Display`.][63421]\n+- [Derive macros for prelude traits (e.g. `Clone`, `Debug`, `Hash`) are now\n+  available at the same path as the trait.][63056] (e.g. The `Clone` derive macro\n+  is available at `std::clone::Clone`). This also makes all built-in macros\n+  available in `std`/`core` root. e.g. `std::include_bytes!`.\n+- [`str::Chars` now implements `Debug`.][63000]\n+- [`slice::{concat, connect, join}` now accepts `&[T]` in addition to `&T`.][62528]\n+- [`*const T` and `*mut T` now implement `marker::Unpin`.][62583]\n+- [`Arc<[T]>` and `Rc<[T]>` now implement `FromIterator<T>`.][61953]\n+- [Added euclidean remainder and division operations (`div_euclid`,\n+  `rem_euclid`) to all numeric primitives.][61884] Additionally `checked`,\n+  `overflowing`, and `wrapping` versions are available for all\n+  integer primitives.\n+- [`thread::AccessError` now implements `Clone`, `Copy`, `Eq`, `Error`, and\n+  `PartialEq`.][61491]\n+- [`iter::{StepBy, Peekable, Take}` now implement `DoubleEndedIterator`.][61457]\n+\n+Stabilized APIs\n+---------------\n+- [`<*const T>::cast`]\n+- [`<*mut T>::cast`]\n+- [`Duration::as_secs_f32`]\n+- [`Duration::as_secs_f64`]\n+- [`Duration::div_duration_f32`]\n+- [`Duration::div_duration_f64`]\n+- [`Duration::div_f32`]\n+- [`Duration::div_f64`]\n+- [`Duration::from_secs_f32`]\n+- [`Duration::from_secs_f64`]\n+- [`Duration::mul_f32`]\n+- [`Duration::mul_f64`]\n+- [`any::type_name`]\n+\n+Cargo\n+-----\n+- [Added pipelined compilation support to `cargo`.][cargo/7143]\n+- [You can now pass the `--features` option multiple times to enable\n+  multiple features.][cargo/7084]\n+\n+Misc\n+----\n+- [`rustc` will now warn about some incorrect uses of\n+  `mem::{uninitialized, zeroed}` that are known to cause undefined behaviour.][63346]\n+\n+[60260]: https://github.com/rust-lang/rust/pull/60260/\n+[61457]: https://github.com/rust-lang/rust/pull/61457/\n+[61491]: https://github.com/rust-lang/rust/pull/61491/\n+[61884]: https://github.com/rust-lang/rust/pull/61884/\n+[61953]: https://github.com/rust-lang/rust/pull/61953/\n+[62042]: https://github.com/rust-lang/rust/pull/62042/\n+[62528]: https://github.com/rust-lang/rust/pull/62528/\n+[62583]: https://github.com/rust-lang/rust/pull/62583/\n+[62735]: https://github.com/rust-lang/rust/pull/62735/\n+[62766]: https://github.com/rust-lang/rust/pull/62766/\n+[62784]: https://github.com/rust-lang/rust/pull/62784/\n+[62814]: https://github.com/rust-lang/rust/pull/62814/\n+[63000]: https://github.com/rust-lang/rust/pull/63000/\n+[63056]: https://github.com/rust-lang/rust/pull/63056/\n+[63107]: https://github.com/rust-lang/rust/pull/63107/\n+[63346]: https://github.com/rust-lang/rust/pull/63346/\n+[63421]: https://github.com/rust-lang/rust/pull/63421/\n+[cargo/7084]: https://github.com/rust-lang/cargo/pull/7084/\n+[cargo/7143]: https://github.com/rust-lang/cargo/pull/7143/\n+[`<*const T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n+[`<*mut T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n+[`Duration::as_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f32\n+[`Duration::as_secs_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f64\n+[`Duration::div_duration_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f32\n+[`Duration::div_duration_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f64\n+[`Duration::div_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f32\n+[`Duration::div_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f64\n+[`Duration::from_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs_f32\n+[`Duration::from_secs_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs_f64\n+[`Duration::mul_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f32\n+[`Duration::mul_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f64\n+[`any::type_name`]: https://doc.rust-lang.org/std/any/fn.type_name.html\n+[forge-platform-support]: https://forge.rust-lang.org/platform-support.html\n+[pipeline-internals]: https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199\n+\n Version 1.37.0 (2019-08-15)\n ==========================\n "}, {"sha": "076bcd878df7196a23fa23d0b4c617ba88850d41", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -2000,6 +2000,8 @@ impl Step for HashSign {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n+        // This gets called by `promote-release`\n+        // (https://github.com/rust-lang/rust-central-station/tree/master/promote-release).\n         let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n         if builder.config.dry_run {\n             return;\n@@ -2010,10 +2012,14 @@ impl Step for HashSign {\n         let addr = builder.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n         });\n-        let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n-            panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n-        });\n-        let pass = t!(fs::read_to_string(&file));\n+        let pass = if env::var(\"BUILD_MANIFEST_DISABLE_SIGNING\").is_err() {\n+            let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n+                panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n+            });\n+            t!(fs::read_to_string(&file))\n+        } else {\n+            String::new()\n+        };\n \n         let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n "}, {"sha": "ecff40a75978dbca8587d61c8f147781afb1dc67", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -845,21 +845,26 @@ extern \"rust-intrinsic\" {\n     ///\n     /// ```\n     /// let store = [0, 1, 2, 3];\n-    /// let mut v_orig = store.iter().collect::<Vec<&i32>>();\n+    /// let v_orig = store.iter().collect::<Vec<&i32>>();\n+    ///\n+    /// // clone the vector as we will reuse them later\n+    /// let v_clone = v_orig.clone();\n     ///\n     /// // Using transmute: this is Undefined Behavior, and a bad idea.\n     /// // However, it is no-copy.\n     /// let v_transmuted = unsafe {\n-    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(\n-    ///         v_orig.clone())\n+    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(v_clone)\n     /// };\n     ///\n+    /// let v_clone = v_orig.clone();\n+    ///\n     /// // This is the suggested, safe way.\n     /// // It does copy the entire vector, though, into a new array.\n-    /// let v_collected = v_orig.clone()\n-    ///                         .into_iter()\n-    ///                         .map(|r| Some(r))\n-    ///                         .collect::<Vec<Option<&i32>>>();\n+    /// let v_collected = v_clone.into_iter()\n+    ///                          .map(Some)\n+    ///                          .collect::<Vec<Option<&i32>>>();\n+    ///\n+    /// let v_clone = v_orig.clone();\n     ///\n     /// // The no-copy, unsafe way, still using transmute, but not UB.\n     /// // This is equivalent to the original, but safer, and reuses the\n@@ -869,11 +874,12 @@ extern \"rust-intrinsic\" {\n     /// // the original inner type (`&i32`) to the converted inner type\n     /// // (`Option<&i32>`), so read the nomicon pages linked above.\n     /// let v_from_raw = unsafe {\n-    ///     Vec::from_raw_parts(v_orig.as_mut_ptr() as *mut Option<&i32>,\n-    ///                         v_orig.len(),\n-    ///                         v_orig.capacity())\n+    ///     // Ensure the original vector is not dropped.\n+    ///     let mut v_clone = std::mem::ManuallyDrop::new(v_clone);\n+    ///     Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option<&i32>,\n+    ///                         v_clone.len(),\n+    ///                         v_clone.capacity())\n     /// };\n-    /// std::mem::forget(v_orig);\n     /// ```\n     ///\n     /// Implementing `split_at_mut`:"}, {"sha": "1dc6d54b08a5aa7700a48f674487bbf1d89755b8", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -584,6 +584,27 @@ impl<P: DerefMut> Pin<P> {\n     /// the pointee cannot move after `Pin<Pointer<T>>` got created.\n     /// \"Malicious\" implementations of `Pointer::DerefMut` are likewise\n     /// ruled out by the contract of `Pin::new_unchecked`.\n+    ///\n+    /// This method is useful when doing multiple calls to functions that consume the pinned type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::pin::Pin;\n+    ///\n+    /// # struct Type {}\n+    /// impl Type {\n+    ///     fn method(self: Pin<&mut Self>) {\n+    ///         // do something\n+    ///     }\n+    ///\n+    ///     fn call_method_twice(mut self: Pin<&mut Self>) {\n+    ///         // `method` consumes `self`, so reborrow the `Pin<&mut Self>` via `as_mut`.\n+    ///         self.as_mut().method();\n+    ///         self.as_mut().method();\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_mut(&mut self) -> Pin<&mut P::Target> {"}, {"sha": "96d40bc81add2633eecb641999b0a4daf965baea", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -97,7 +97,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n                self.tag(),\n                a,\n                b);\n-        let origin = Subtype(self.fields.trace.clone());\n+        let origin = Subtype(box self.fields.trace.clone());\n         self.fields.infcx.borrow_region_constraints()\n                          .make_eqregion(origin, a, b);\n         Ok(a)"}, {"sha": "bfa8353ca343f0be89499f5a20a6feab856eb07f", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -30,7 +30,7 @@ impl NiceRegionError<'me, 'tcx> {\n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -50,7 +50,7 @@ impl NiceRegionError<'me, 'tcx> {\n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -70,7 +70,7 @@ impl NiceRegionError<'me, 'tcx> {\n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -92,7 +92,7 @@ impl NiceRegionError<'me, 'tcx> {\n                 _,\n                 _,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -108,7 +108,7 @@ impl NiceRegionError<'me, 'tcx> {\n             )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -125,7 +125,7 @@ impl NiceRegionError<'me, 'tcx> {\n             )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -142,7 +142,7 @@ impl NiceRegionError<'me, 'tcx> {\n             )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),"}, {"sha": "115ffea97bf1a47a3e3a0809f3a90163068d70e7", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                           sup: Region<'tcx>)\n                                           -> DiagnosticBuilder<'tcx> {\n         match origin {\n-            infer::Subtype(trace) => {\n+            infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 let mut err = self.report_and_explain_type_error(trace, &terr);\n                 self.tcx.note_and_explain_region(region_scope_tree, &mut err, \"\", sup, \"...\");\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> DiagnosticBuilder<'tcx> {\n         // I can't think how to do better than this right now. -nikomatsakis\n         match placeholder_origin {\n-            infer::Subtype(trace) => {\n+            infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsPlaceholderMismatch;\n                 self.report_and_explain_type_error(trace, &terr)\n             }"}, {"sha": "10e45321a6d6ae5e2d3ecf4fbc3b40546f7e6f13", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -57,7 +57,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n                a,\n                b);\n \n-        let origin = Subtype(self.fields.trace.clone());\n+        let origin = Subtype(box self.fields.trace.clone());\n         Ok(self.fields.infcx.borrow_region_constraints().glb_regions(self.tcx(), origin, a, b))\n     }\n "}, {"sha": "8b64cda7bd26d7e22e335c47f4fd3cfa4d5ed13d", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -57,7 +57,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n                a,\n                b);\n \n-        let origin = Subtype(self.fields.trace.clone());\n+        let origin = Subtype(box self.fields.trace.clone());\n         Ok(self.fields.infcx.borrow_region_constraints().lub_regions(self.tcx(), origin, a, b))\n     }\n "}, {"sha": "a886c44a4792d2513666a746e69cdf05ac251eb0", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -254,7 +254,7 @@ pub struct TypeTrace<'tcx> {\n #[derive(Clone, Debug)]\n pub enum SubregionOrigin<'tcx> {\n     /// Arose from a subtyping relation\n-    Subtype(TypeTrace<'tcx>),\n+    Subtype(Box<TypeTrace<'tcx>>),\n \n     /// Stack-allocated closures cannot outlive innermost loop\n     /// or function so as to ensure we only require finite stack\n@@ -340,6 +340,10 @@ pub enum SubregionOrigin<'tcx> {\n     },\n }\n \n+// `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(SubregionOrigin<'_>, 32);\n+\n /// Places that type/region parameters can appear.\n #[derive(Clone, Copy, Debug)]\n pub enum ParameterOrigin {"}, {"sha": "76db55ecfa8ef70a4dc8d28f44d8c59e155c98d3", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -130,7 +130,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         // FIXME -- we have more fine-grained information available\n         // from the \"cause\" field, we could perhaps give more tailored\n         // error messages.\n-        let origin = SubregionOrigin::Subtype(self.fields.trace.clone());\n+        let origin = SubregionOrigin::Subtype(box self.fields.trace.clone());\n         self.fields.infcx.borrow_region_constraints()\n                          .make_subregion(origin, a, b);\n "}, {"sha": "ac99ccd45eafe4e8b0c578a5d1c63d174e0bc3cf", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -213,6 +213,15 @@ fn print_backtrace(backtrace: &mut Backtrace) {\n     eprintln!(\"\\n\\nAn error occurred in miri:\\n{:?}\", backtrace);\n }\n \n+impl From<ErrorHandled> for InterpErrorInfo<'tcx> {\n+    fn from(err: ErrorHandled) -> Self {\n+        match err {\n+            ErrorHandled::Reported => err_inval!(ReferencedConstant),\n+            ErrorHandled::TooGeneric => err_inval!(TooGeneric),\n+        }.into()\n+    }\n+}\n+\n impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     fn from(kind: InterpError<'tcx>) -> Self {\n         let backtrace = match env::var(\"RUSTC_CTFE_BACKTRACE\") {\n@@ -313,6 +322,9 @@ impl<O: fmt::Debug> fmt::Debug for PanicInfo<O> {\n     }\n }\n \n+/// Error information for when the program we executed turned out not to actually be a valid\n+/// program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp\n+/// where we work on generic code or execution does not have all information available.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InvalidProgramInfo<'tcx> {\n     /// Resolution can fail if we are in a too generic context.\n@@ -342,6 +354,7 @@ impl fmt::Debug for InvalidProgramInfo<'tcx> {\n     }\n }\n \n+/// Error information for when the program caused Undefined Behavior.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UndefinedBehaviorInfo {\n     /// Free-form case. Only for errors that are never caught!\n@@ -364,12 +377,19 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n     }\n }\n \n+/// Error information for when the program did something that might (or might not) be correct\n+/// to do according to the Rust spec, but due to limitations in the interpreter, the\n+/// operation could not be carried out. These limitations can differ between CTFE and the\n+/// Miri engine, e.g., CTFE does not support casting pointers to \"real\" integers.\n+///\n+/// Currently, we also use this as fall-back error kind for errors that have not been\n+/// categorized yet.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsupportedOpInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n \n-    // -- Everything below is not classified yet --\n+    // -- Everything below is not categorized yet --\n     FunctionAbiMismatch(Abi, Abi),\n     FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n     FunctionRetMismatch(Ty<'tcx>, Ty<'tcx>),\n@@ -536,6 +556,8 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n     }\n }\n \n+/// Error information for when the program exhausted the resources granted to it\n+/// by the interpreter.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ResourceExhaustionInfo {\n     /// The stack grew too big."}, {"sha": "c7260945295a6e4c294dd48809ae030d64ffa945", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -462,15 +462,6 @@ rustc_queries! {\n             no_force\n             desc { \"extract field of const\" }\n         }\n-\n-        /// Produces an absolute path representation of the given type. See also the documentation\n-        /// on `std::any::type_name`.\n-        query type_name(key: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n-            eval_always\n-            no_force\n-            desc { \"get absolute path of type\" }\n-        }\n-\n     }\n \n     TypeChecking {"}, {"sha": "3f3c5ac1460a315d17bc8ced0c0fd1ce271c5652", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -15,6 +15,7 @@ use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::base::{to_immediate, wants_msvc_seh, compare_simd_types};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, Primitive};\n+use rustc::mir::interpret::GlobalId;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc::hir;\n use syntax::ast::{self, FloatTy};\n@@ -81,13 +82,14 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Valu\n impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn codegen_intrinsic_call(\n         &mut self,\n-        callee_ty: Ty<'tcx>,\n+        instance: ty::Instance<'tcx>,\n         fn_ty: &FnType<'tcx, Ty<'tcx>>,\n         args: &[OperandRef<'tcx, &'ll Value>],\n         llresult: &'ll Value,\n         span: Span,\n     ) {\n         let tcx = self.tcx;\n+        let callee_ty = instance.ty(tcx);\n \n         let (def_id, substs) = match callee_ty.sty {\n             ty::FnDef(def_id, substs) => (def_id, substs),\n@@ -133,10 +135,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n                 self.call(llfn, &[], None)\n             }\n-            \"size_of\" => {\n-                let tp_ty = substs.type_at(0);\n-                self.const_usize(self.size_of(tp_ty).bytes())\n-            }\n             \"va_start\" => {\n                 self.va_start(args[0].immediate())\n             }\n@@ -188,10 +186,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     self.const_usize(self.size_of(tp_ty).bytes())\n                 }\n             }\n-            \"min_align_of\" => {\n-                let tp_ty = substs.type_at(0);\n-                self.const_usize(self.align_of(tp_ty).bytes())\n-            }\n             \"min_align_of_val\" => {\n                 let tp_ty = substs.type_at(0);\n                 if let OperandValue::Pair(_, meta) = args[0].val {\n@@ -201,18 +195,19 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     self.const_usize(self.align_of(tp_ty).bytes())\n                 }\n             }\n-            \"pref_align_of\" => {\n-                let tp_ty = substs.type_at(0);\n-                self.const_usize(self.layout_of(tp_ty).align.pref.bytes())\n-            }\n+            \"size_of\" |\n+            \"pref_align_of\" |\n+            \"min_align_of\" |\n+            \"needs_drop\" |\n+            \"type_id\" |\n             \"type_name\" => {\n-                let tp_ty = substs.type_at(0);\n-                let ty_name = self.tcx.type_name(tp_ty);\n+                let gid = GlobalId {\n+                    instance,\n+                    promoted: None,\n+                };\n+                let ty_name = self.tcx.const_eval(ty::ParamEnv::reveal_all().and(gid)).unwrap();\n                 OperandRef::from_const(self, ty_name).immediate_or_packed_pair(self)\n             }\n-            \"type_id\" => {\n-                self.const_u64(self.tcx.type_id_hash(substs.type_at(0)))\n-            }\n             \"init\" => {\n                 let ty = substs.type_at(0);\n                 if !self.layout_of(ty).is_zst() {\n@@ -235,11 +230,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             \"uninit\" | \"forget\" => {\n                 return;\n             }\n-            \"needs_drop\" => {\n-                let tp_ty = substs.type_at(0);\n-\n-                self.const_bool(self.type_needs_drop(tp_ty))\n-            }\n             \"offset\" => {\n                 let ptr = args[0].immediate();\n                 let offset = args[1].immediate();"}, {"sha": "1bb0ea5dae44b4c21676fee9955281a6e7490725", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -667,8 +667,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }).collect();\n \n \n-            let callee_ty = instance.as_ref().unwrap().ty(bx.tcx());\n-            bx.codegen_intrinsic_call(callee_ty, &fn_ty, &args, dest,\n+            bx.codegen_intrinsic_call(*instance.as_ref().unwrap(), &fn_ty, &args, dest,\n                                       terminator.source_info.span);\n \n             if let ReturnDest::IndirectOperand(dst, _) = ret_dest {"}, {"sha": "7c79cd6021031d7691328453e672272ffdb657b6", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -1,6 +1,6 @@\n use super::BackendTypes;\n use crate::mir::operand::OperandRef;\n-use rustc::ty::Ty;\n+use rustc::ty::{self, Ty};\n use rustc_target::abi::call::FnType;\n use syntax_pos::Span;\n \n@@ -10,7 +10,7 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     /// add them to librustc_codegen_llvm/context.rs\n     fn codegen_intrinsic_call(\n         &mut self,\n-        callee_ty: Ty<'tcx>,\n+        instance: ty::Instance<'tcx>,\n         fn_ty: &FnType<'tcx, Ty<'tcx>>,\n         args: &[OperandRef<'tcx, Self::Value>],\n         llresult: Self::Value,"}, {"sha": "d238de2a17e29dade9065449f061a7427d6c12e4", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -1144,15 +1144,18 @@ impl EmitterWriter {\n                 buffer.prepend(0, \" \", Style::NoStyle);\n             }\n             draw_note_separator(&mut buffer, 0, max_line_num_len + 1);\n-            let level_str = level.to_string();\n-            if !level_str.is_empty() {\n-                buffer.append(0, &level_str, Style::MainHeaderMsg);\n-                buffer.append(0, \": \", Style::NoStyle);\n+            if *level != Level::FailureNote {\n+                let level_str = level.to_string();\n+                if !level_str.is_empty() {\n+                    buffer.append(0, &level_str, Style::MainHeaderMsg);\n+                    buffer.append(0, \": \", Style::NoStyle);\n+                }\n             }\n             self.msg_to_buffer(&mut buffer, msg, max_line_num_len, \"note\", None);\n         } else {\n             let level_str = level.to_string();\n-            if !level_str.is_empty() {\n+            // The failure note level itself does not provide any useful diagnostic information\n+            if *level != Level::FailureNote && !level_str.is_empty() {\n                 buffer.append(0, &level_str, Style::Level(level.clone()));\n             }\n             // only render error codes, not lint codes\n@@ -1161,7 +1164,7 @@ impl EmitterWriter {\n                 buffer.append(0, &code, Style::Level(level.clone()));\n                 buffer.append(0, \"]\", Style::Level(level.clone()));\n             }\n-            if !level_str.is_empty() {\n+            if *level != Level::FailureNote && !level_str.is_empty() {\n                 buffer.append(0, \": \", header_style);\n             }\n             for &(ref text, _) in msg.iter() {"}, {"sha": "8b543be6e6497ba5d750673e24c2a5142796f681", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -833,7 +833,7 @@ impl Level {\n             Warning => \"warning\",\n             Note => \"note\",\n             Help => \"help\",\n-            FailureNote => \"\",\n+            FailureNote => \"failure-note\",\n             Cancelled => panic!(\"Shouldn't call on cancelled error\"),\n         }\n     }"}, {"sha": "435159827e6c30d419b0e3ecc008ccf8adedfb82", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -15,6 +15,7 @@ use rustc::ty::{self, Ty, TyCtxt, subst::Subst};\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n use rustc::traits::Reveal;\n use rustc_data_structures::fx::FxHashMap;\n+use crate::interpret::eval_nullary_intrinsic;\n \n use syntax::source_map::{Span, DUMMY_SP};\n \n@@ -602,6 +603,23 @@ pub fn const_eval_provider<'tcx>(\n             other => return other,\n         }\n     }\n+\n+    // We call `const_eval` for zero arg intrinsics, too, in order to cache their value.\n+    // Catch such calls and evaluate them instead of trying to load a constant's MIR.\n+    if let ty::InstanceDef::Intrinsic(def_id) = key.value.instance.def {\n+        let ty = key.value.instance.ty(tcx);\n+        let substs = match ty.sty {\n+            ty::FnDef(_, substs) => substs,\n+            _ => bug!(\"intrinsic with type {:?}\", ty),\n+        };\n+        return eval_nullary_intrinsic(tcx, key.param_env, def_id, substs)\n+            .map_err(|error| {\n+                let span = tcx.def_span(def_id);\n+                let error = ConstEvalErr { error: error.kind, stacktrace: vec![], span };\n+                error.report_as_error(tcx.at(span), \"could not evaluate nullary intrinsic\")\n+            })\n+    }\n+\n     tcx.const_eval_raw(key).and_then(|val| {\n         validate_and_turn_into_const(tcx, val, key)\n     })"}, {"sha": "78996ed6939d8148a19624b7cc4ec4dc6b7e8ebb", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -14,7 +14,6 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::interpret::{\n-    ErrorHandled,\n     GlobalId, Scalar, Pointer, FrameInfo, AllocId,\n     InterpResult, truncate, sign_extend,\n };\n@@ -672,14 +671,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Our result will later be validated anyway, and there seems no good reason\n         // to have to fail early here.  This is also more consistent with\n         // `Memory::get_static_alloc` which has to use `const_eval_raw` to avoid cycles.\n-        let val = self.tcx.const_eval_raw(param_env.and(gid)).map_err(|err| {\n-            match err {\n-                ErrorHandled::Reported =>\n-                    err_inval!(ReferencedConstant),\n-                ErrorHandled::TooGeneric =>\n-                    err_inval!(TooGeneric),\n-            }\n-        })?;\n+        let val = self.tcx.const_eval_raw(param_env.and(gid))?;\n         self.raw_const_to_mplace(val)\n     }\n "}, {"sha": "ec09e69ec853741e1b24964925e91334263434e6", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -5,17 +5,18 @@\n use syntax::symbol::Symbol;\n use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Primitive, Size};\n+use rustc::ty::subst::SubstsRef;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::TyCtxt;\n use rustc::mir::BinOp;\n-use rustc::mir::interpret::{InterpResult, Scalar};\n+use rustc::mir::interpret::{InterpResult, Scalar, GlobalId, ConstValue};\n \n use super::{\n-    Machine, PlaceTy, OpTy, InterpCx, Immediate,\n+    Machine, PlaceTy, OpTy, InterpCx,\n };\n \n mod type_name;\n \n-pub use type_name::*;\n-\n fn numeric_intrinsic<'tcx, Tag>(\n     name: &str,\n     bits: u128,\n@@ -37,6 +38,50 @@ fn numeric_intrinsic<'tcx, Tag>(\n     Ok(Scalar::from_uint(bits_out, size))\n }\n \n+/// The logic for all nullary intrinsics is implemented here. These intrinsics don't get evaluated\n+/// inside an `InterpCx` and instead have their value computed directly from rustc internal info.\n+crate fn eval_nullary_intrinsic<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    def_id: DefId,\n+    substs: SubstsRef<'tcx>,\n+) -> InterpResult<'tcx, &'tcx ty::Const<'tcx>> {\n+    let tp_ty = substs.type_at(0);\n+    let name = &*tcx.item_name(def_id).as_str();\n+    Ok(match name {\n+        \"type_name\" => {\n+            let alloc = type_name::alloc_type_name(tcx, tp_ty);\n+            tcx.mk_const(ty::Const {\n+                val: ConstValue::Slice {\n+                    data: alloc,\n+                    start: 0,\n+                    end: alloc.len(),\n+                },\n+                ty: tcx.mk_static_str(),\n+            })\n+        },\n+        \"needs_drop\" => ty::Const::from_bool(tcx, tp_ty.needs_drop(tcx, param_env)),\n+        \"size_of\" |\n+        \"min_align_of\" |\n+        \"pref_align_of\" => {\n+            let layout = tcx.layout_of(param_env.and(tp_ty)).map_err(|e| err_inval!(Layout(e)))?;\n+            let n = match name {\n+                \"pref_align_of\" => layout.align.pref.bytes(),\n+                \"min_align_of\" => layout.align.abi.bytes(),\n+                \"size_of\" => layout.size.bytes(),\n+                _ => bug!(),\n+            };\n+            ty::Const::from_usize(tcx, n)\n+        },\n+        \"type_id\" => ty::Const::from_bits(\n+            tcx,\n+            tcx.type_id_hash(tp_ty).into(),\n+            param_env.and(tcx.types.u64),\n+        ),\n+        other => bug!(\"`{}` is not a zero arg intrinsic\", other),\n+    })\n+}\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n@@ -49,41 +94,19 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n-            \"min_align_of\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_align = self.layout_of(elem_ty)?.align.abi.bytes();\n-                let align_val = Scalar::from_uint(elem_align, dest.layout.size);\n-                self.write_scalar(align_val, dest)?;\n-            }\n-\n-            \"needs_drop\" => {\n-                let ty = substs.type_at(0);\n-                let ty_needs_drop = ty.needs_drop(self.tcx.tcx, self.param_env);\n-                let val = Scalar::from_bool(ty_needs_drop);\n-                self.write_scalar(val, dest)?;\n-            }\n-\n-            \"size_of\" => {\n-                let ty = substs.type_at(0);\n-                let size = self.layout_of(ty)?.size.bytes() as u128;\n-                let size_val = Scalar::from_uint(size, dest.layout.size);\n-                self.write_scalar(size_val, dest)?;\n-            }\n-\n-            \"type_id\" => {\n-                let ty = substs.type_at(0);\n-                let type_id = self.tcx.type_id_hash(ty) as u128;\n-                let id_val = Scalar::from_uint(type_id, dest.layout.size);\n-                self.write_scalar(id_val, dest)?;\n-            }\n-\n+            \"min_align_of\" |\n+            \"pref_align_of\" |\n+            \"needs_drop\" |\n+            \"size_of\" |\n+            \"type_id\" |\n             \"type_name\" => {\n-                let alloc = alloc_type_name(self.tcx.tcx, substs.type_at(0));\n-                let name_id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);\n-                let id_ptr = self.memory.tag_static_base_pointer(name_id.into());\n-                let alloc_len = alloc.size.bytes();\n-                let name_val = Immediate::new_slice(Scalar::Ptr(id_ptr), alloc_len, self);\n-                self.write_immediate(name_val, dest)?;\n+                let gid = GlobalId {\n+                    instance,\n+                    promoted: None,\n+                };\n+                let val = self.tcx.const_eval(self.param_env.and(gid))?;\n+                let val = self.eval_const_to_op(val, None)?;\n+                self.copy_op(val, dest)?;\n             }\n \n             | \"ctpop\""}, {"sha": "1e765a4ed982c7c56c19d1df26803088da0352cb", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::{\n use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n use rustc::hir::def_id::CrateNum;\n use std::fmt::Write;\n-use rustc::mir::interpret::{Allocation, ConstValue};\n+use rustc::mir::interpret::Allocation;\n \n struct AbsolutePathPrinter<'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -213,22 +213,11 @@ impl Write for AbsolutePathPrinter<'_> {\n     }\n }\n \n-/// Produces an absolute path representation of the given type. See also the documentation on\n-/// `std::any::type_name`\n-pub fn type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n-    let alloc = alloc_type_name(tcx, ty);\n-    tcx.mk_const(ty::Const {\n-        val: ConstValue::Slice {\n-            data: alloc,\n-            start: 0,\n-            end: alloc.len(),\n-        },\n-        ty: tcx.mk_static_str(),\n-    })\n-}\n-\n /// Directly returns an `Allocation` containing an absolute path representation of the given type.\n-pub(super) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Allocation {\n+crate fn alloc_type_name<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>\n+) -> &'tcx Allocation {\n     let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;\n     let alloc = Allocation::from_byte_aligned_bytes(path.into_bytes());\n     tcx.intern_const_alloc(alloc)"}, {"sha": "0c61be283dfd0d8469db45343145e7e5f7332a6a", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -34,6 +34,6 @@ pub use self::visitor::{ValueVisitor, MutValueVisitor};\n \n pub use self::validity::RefTracking;\n \n-pub(super) use self::intrinsics::type_name;\n-\n pub use self::intern::intern_const_alloc_recursive;\n+\n+crate use self::intrinsics::eval_nullary_intrinsic;"}, {"sha": "034ad5b01d346f2736de87a2859eed2efbf1a7bc", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -59,5 +59,4 @@ pub fn provide(providers: &mut Providers<'_>) {\n         let (param_env, (value, field)) = param_env_and_value.into_parts();\n         const_eval::const_field(tcx, param_env, None, field, value)\n     };\n-    providers.type_name = interpret::type_name;\n }"}, {"sha": "be364a10593da6bb9e3178af363f594a6f6fd192", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -2326,10 +2326,10 @@ impl<R: Read> Iterator for Bytes<R> {\n /// An iterator over the contents of an instance of `BufRead` split on a\n /// particular byte.\n ///\n-/// This struct is generally created by calling [`split`][split] on a\n-/// `BufRead`. Please see the documentation of `split()` for more details.\n+/// This struct is generally created by calling [`split`] on a `BufRead`.\n+/// Please see the documentation of [`split`] for more details.\n ///\n-/// [split]: trait.BufRead.html#method.split\n+/// [`split`]: trait.BufRead.html#method.split\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Split<B> {\n@@ -2358,10 +2358,10 @@ impl<B: BufRead> Iterator for Split<B> {\n \n /// An iterator over the lines of an instance of `BufRead`.\n ///\n-/// This struct is generally created by calling [`lines`][lines] on a\n-/// `BufRead`. Please see the documentation of `lines()` for more details.\n+/// This struct is generally created by calling [`lines`] on a `BufRead`.\n+/// Please see the documentation of [`lines`] for more details.\n ///\n-/// [lines]: trait.BufRead.html#method.lines\n+/// [`lines`]: trait.BufRead.html#method.lines\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Lines<B> {"}, {"sha": "763f85748736e315a3210f342874e1d09cf926bf", "filename": "src/test/compile-fail/issue-44415.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftest%2Fcompile-fail%2Fissue-44415.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftest%2Fcompile-fail%2Fissue-44415.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-44415.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "previous_filename": "src/test/ui/issues/issue-44415.rs"}, {"sha": "1ae39e7563a824b2c78b8e6243e1a93d35a69c3b", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -14,6 +14,11 @@ note: ...which requires const-evaluating `Foo::bytes::{{constant}}#0`...\n    |\n LL |     intrinsics::size_of::<T>()\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating + checking `std::intrinsics::size_of`...\n+  --> $SRC_DIR/libcore/intrinsics.rs:LL:COL\n+   |\n+LL |     pub fn size_of<T>() -> usize;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires computing layout of `Foo`...\n    = note: ...which requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All, def_id: None }, value: [u8; _] }`...\n    = note: ...which again requires const-evaluating + checking `Foo::bytes::{{constant}}#0`, completing the cycle"}, {"sha": "8008e53f65f4d3150ec23628386aba06b088b0d2", "filename": "src/test/ui/issues/issue-44415.stderr", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Ftest%2Fui%2Fissues%2Fissue-44415.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7efe1c6e678a263b9464f2e7f06f552b4d4db5a5/src%2Ftest%2Fui%2Fissues%2Fissue-44415.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44415.stderr?ref=7efe1c6e678a263b9464f2e7f06f552b4d4db5a5", "patch": "@@ -1,28 +0,0 @@\n-error[E0391]: cycle detected when const-evaluating + checking `Foo::bytes::{{constant}}#0`\n-  --> $DIR/issue-44415.rs:6:17\n-   |\n-LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n-   |                 ^^^^^^\n-   |\n-note: ...which requires const-evaluating + checking `Foo::bytes::{{constant}}#0`...\n-  --> $DIR/issue-44415.rs:6:17\n-   |\n-LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n-   |                 ^^^^^^\n-note: ...which requires const-evaluating `Foo::bytes::{{constant}}#0`...\n-  --> $DIR/issue-44415.rs:6:26\n-   |\n-LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing layout of `Foo`...\n-   = note: ...which requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: All, def_id: None }, value: [u8; _] }`...\n-   = note: ...which again requires const-evaluating + checking `Foo::bytes::{{constant}}#0`, completing the cycle\n-note: cycle used when processing `Foo`\n-  --> $DIR/issue-44415.rs:5:1\n-   |\n-LL | struct Foo {\n-   | ^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "0a1fb567714fbe25ca8cdf0a64fbfc113af480c7", "filename": "src/test/ui/json-short.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftest%2Fui%2Fjson-short.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftest%2Fui%2Fjson-short.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-short.stderr?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -15,5 +15,5 @@ started: https://doc.rust-lang.org/book/\n \"}\n {\"message\":\"aborting due to previous error\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to previous error\n \"}\n-{\"message\":\"For more information about this error, try `rustc --explain E0601`.\",\"code\":null,\"level\":\"\",\"spans\":[],\"children\":[],\"rendered\":\"For more information about this error, try `rustc --explain E0601`.\n+{\"message\":\"For more information about this error, try `rustc --explain E0601`.\",\"code\":null,\"level\":\"failure-note\",\"spans\":[],\"children\":[],\"rendered\":\"For more information about this error, try `rustc --explain E0601`.\n \"}"}, {"sha": "678c88849b561d6a112804264055d1134cb2cd68", "filename": "src/test/ui/lint/use_suggestion_json.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.stderr?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -412,7 +412,7 @@ mod foo {\n {\n   \"message\": \"For more information about this error, try `rustc --explain E0412`.\",\n   \"code\": null,\n-  \"level\": \"\",\n+  \"level\": \"failure-note\",\n   \"spans\": [],\n   \"children\": [],\n   \"rendered\": \"\\u001b[0m\\u001b[1mFor more information about this error, try `rustc --explain E0412`.\\u001b[0m"}, {"sha": "eab23f3cfffc4982036418693767a32a65719665", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -1,3 +1,9 @@\n+//! Build a dist manifest, hash and sign everything.\n+//! This gets called by `promote-release`\n+//! (https://github.com/rust-lang/rust-central-station/tree/master/promote-release)\n+//! via `x.py dist hash-and-sign`; the cmdline arguments are set up\n+//! by rustbuild (in `src/bootstrap/dist.rs`).\n+\n use toml;\n use serde::Serialize;\n \n@@ -270,6 +276,7 @@ fn main() {\n     // Do not ask for a passphrase while manually testing\n     let mut passphrase = String::new();\n     if should_sign {\n+        // `x.py` passes the passphrase via stdin.\n         t!(io::stdin().read_to_string(&mut passphrase));\n     }\n \n@@ -362,6 +369,7 @@ impl Builder {\n         }\n     }\n \n+    /// Hash all files, compute their signatures, and collect the hashes in `self.digests`.\n     fn digest_and_sign(&mut self) {\n         for file in t!(self.input.read_dir()).map(|e| t!(e).path()) {\n             let filename = file.file_name().unwrap().to_str().unwrap();\n@@ -532,19 +540,20 @@ impl Builder {\n             .as_ref()\n             .cloned()\n             .map(|version| (version, true))\n-            .unwrap_or_default();\n+            .unwrap_or_default(); // `is_present` defaults to `false` here.\n \n-        // miri needs to build std with xargo, which doesn't allow stable/beta:\n-        // <https://github.com/japaric/xargo/pull/204#issuecomment-374888868>\n+        // Miri is nightly-only; never ship it for other trains.\n         if pkgname == \"miri-preview\" && self.rust_release != \"nightly\" {\n-            is_present = false; // ignore it\n+            is_present = false; // Pretend the component is entirely missing.\n         }\n \n         let targets = targets.iter().map(|name| {\n             if is_present {\n+                // The component generally exists, but it might still be missing for this target.\n                 let filename = self.filename(pkgname, name);\n                 let digest = match self.digests.remove(&filename) {\n                     Some(digest) => digest,\n+                    // This component does not exist for this target -- skip it.\n                     None => return (name.to_string(), Target::unavailable()),\n                 };\n                 let xz_filename = filename.replace(\".tar.gz\", \".tar.xz\");"}, {"sha": "7cf3cc7663b470f35dedeaaf07a118c94f9d1bcf", "filename": "src/tools/publish_toolstate.py", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftools%2Fpublish_toolstate.py", "raw_url": "https://github.com/rust-lang/rust/raw/528379121ceb5fca5382b4337be7ac064890ec8c/src%2Ftools%2Fpublish_toolstate.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fpublish_toolstate.py?ref=528379121ceb5fca5382b4337be7ac064890ec8c", "patch": "@@ -201,7 +201,9 @@ def update_latest(\n                 new = s.get(tool, old)\n                 status[os] = new\n                 maintainers = ' '.join('@'+name for name in MAINTAINERS[tool])\n-                if new > old: # comparing the strings, but they are ordered appropriately!\n+                # comparing the strings, but they are ordered appropriately:\n+                # \"test-pass\" > \"test-fail\" > \"build-fail\"\n+                if new > old:\n                     # things got fixed or at least the status quo improved\n                     changed = True\n                     message += '\ud83c\udf89 {} on {}: {} \u2192 {} (cc {}, @rust-lang/infra).\\n' \\\n@@ -213,10 +215,17 @@ def update_latest(\n                         .format(tool, os, old, new)\n                     message += '{} (cc {}, @rust-lang/infra).\\n' \\\n                         .format(title, maintainers)\n-                    # Most tools only create issues for build failures.\n-                    # Other failures can be spurious.\n-                    if new == 'build-fail' or (tool == 'miri' and new == 'test-fail'):\n-                        create_issue_for_status = new\n+                    # See if we need to create an issue.\n+                    if tool == 'miri':\n+                        # Create issue if tests used to pass before. Don't open a *second*\n+                        # issue when we regress from \"test-fail\" to \"build-fail\".\n+                        if old == 'test-pass':\n+                            create_issue_for_status = new\n+                    else:\n+                        # Create issue if things no longer build.\n+                        # (No issue for mere test failures to avoid spurious issues.)\n+                        if new == 'build-fail':\n+                            create_issue_for_status = new\n \n             if create_issue_for_status is not None:\n                 try:"}]}