{"sha": "9a7576fe2cdd169313b5e25be6bf485407adb496", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNzU3NmZlMmNkZDE2OTMxM2I1ZTI1YmU2YmY0ODU0MDdhZGI0OTY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-07T20:05:45Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-07T22:15:30Z"}, "message": "Move to macro-based logging checks in the C++ code\n\nNo functions should be called for log statements that turn out to be\ninactive.", "tree": {"sha": "36f5c9a5baaae95be1fb3cdc9b5b76814b08e803", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36f5c9a5baaae95be1fb3cdc9b5b76814b08e803"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a7576fe2cdd169313b5e25be6bf485407adb496", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a7576fe2cdd169313b5e25be6bf485407adb496", "html_url": "https://github.com/rust-lang/rust/commit/9a7576fe2cdd169313b5e25be6bf485407adb496", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a7576fe2cdd169313b5e25be6bf485407adb496/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dcf6218b1e0e70e60afe8d1a9f336adad060362", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dcf6218b1e0e70e60afe8d1a9f336adad060362", "html_url": "https://github.com/rust-lang/rust/commit/6dcf6218b1e0e70e60afe8d1a9f336adad060362"}], "stats": {"total": 491, "additions": 254, "deletions": 237}, "files": [{"sha": "d5ba8e13c54efe10c7245b4f1e99deec5027a5d8", "filename": "src/rt/circular_buffer.cpp", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Fcircular_buffer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Fcircular_buffer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -14,7 +14,7 @@ circular_buffer::circular_buffer(rust_dom *dom, size_t unit_sz) :\n \n     A(dom, unit_sz, \"Unit size must be larger than zero.\");\n \n-    dom->log(rust_log::MEM | rust_log::COMM,\n+    DLOG(dom, rust_log::MEM | rust_log::COMM,\n              \"new circular_buffer(buffer_sz=%d, unread=%d)\"\n              \"-> circular_buffer=0x%\" PRIxPTR,\n              _buffer_sz, _unread, this);\n@@ -23,7 +23,7 @@ circular_buffer::circular_buffer(rust_dom *dom, size_t unit_sz) :\n }\n \n circular_buffer::~circular_buffer() {\n-    dom->log(rust_log::MEM, \"~circular_buffer 0x%\" PRIxPTR, this);\n+    DLOG(dom, rust_log::MEM, \"~circular_buffer 0x%\" PRIxPTR, this);\n     I(dom, _buffer);\n     W(dom, _unread == 0,\n       \"freeing circular_buffer with %d unread bytes\", _unread);\n@@ -79,7 +79,7 @@ circular_buffer::enqueue(void *src) {\n         grow();\n     }\n \n-    dom->log(rust_log::MEM | rust_log::COMM,\n+    DLOG(dom, rust_log::MEM | rust_log::COMM,\n              \"circular_buffer enqueue \"\n              \"unread: %d, next: %d, buffer_sz: %d, unit_sz: %d\",\n              _unread, _next, _buffer_sz, unit_sz);\n@@ -101,7 +101,7 @@ circular_buffer::enqueue(void *src) {\n     memcpy(&_buffer[dst_idx], src, unit_sz);\n     _unread += unit_sz;\n \n-    dom->log(rust_log::MEM | rust_log::COMM,\n+    DLOG(dom, rust_log::MEM | rust_log::COMM,\n              \"circular_buffer pushed data at index: %d\", dst_idx);\n }\n \n@@ -117,7 +117,7 @@ circular_buffer::dequeue(void *dst) {\n     I(dom, _unread <= _buffer_sz);\n     I(dom, _buffer);\n \n-    dom->log(rust_log::MEM | rust_log::COMM,\n+    DLOG(dom, rust_log::MEM | rust_log::COMM,\n              \"circular_buffer dequeue \"\n              \"unread: %d, next: %d, buffer_sz: %d, unit_sz: %d\",\n              _unread, _next, _buffer_sz, unit_sz);\n@@ -126,7 +126,7 @@ circular_buffer::dequeue(void *dst) {\n     if (dst != NULL) {\n         memcpy(dst, &_buffer[_next], unit_sz);\n     }\n-    dom->log(rust_log::MEM | rust_log::COMM,\n+    DLOG(dom, rust_log::MEM | rust_log::COMM,\n              \"shifted data from index %d\", _next);\n     _unread -= unit_sz;\n     _next += unit_sz;\n@@ -144,7 +144,7 @@ void\n circular_buffer::grow() {\n     size_t new_buffer_sz = _buffer_sz * 2;\n     I(dom, new_buffer_sz <= MAX_CIRCULAR_BUFFER_SIZE);\n-    dom->log(rust_log::MEM | rust_log::COMM,\n+    DLOG(dom, rust_log::MEM | rust_log::COMM,\n              \"circular_buffer is growing to %d bytes\", new_buffer_sz);\n     void *new_buffer = dom->malloc(new_buffer_sz);\n     transfer(new_buffer);\n@@ -158,7 +158,7 @@ void\n circular_buffer::shrink() {\n     size_t new_buffer_sz = _buffer_sz / 2;\n     I(dom, initial_size() <= new_buffer_sz);\n-    dom->log(rust_log::MEM | rust_log::COMM,\n+    DLOG(dom, rust_log::MEM | rust_log::COMM,\n              \"circular_buffer is shrinking to %d bytes\", new_buffer_sz);\n     void *new_buffer = dom->malloc(new_buffer_sz);\n     transfer(new_buffer);"}, {"sha": "9600b4d519b2d5c8d28429c58079e28fc8b20caf", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -87,10 +87,10 @@ rust_start(uintptr_t main_fn, rust_crate const *crate, int argc,\n     rust_dom *dom = handle->referent();\n     command_line_args *args = new (dom) command_line_args(dom, argc, argv);\n \n-    dom->log(rust_log::DOM, \"startup: %d args in 0x%\" PRIxPTR,\n+    DLOG(dom, rust_log::DOM, \"startup: %d args in 0x%\" PRIxPTR,\n              args->argc, (uintptr_t)args->args);\n     for (int i = 0; i < args->argc; i++) {\n-        dom->log(rust_log::DOM,\n+        DLOG(dom, rust_log::DOM,\n             \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n     }\n "}, {"sha": "9ef05ce0fece9b56f2015a294b785f20306c50b6", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -6,7 +6,7 @@\n extern \"C\" CDECL rust_str*\n last_os_error(rust_task *task) {\n     rust_dom *dom = task->dom;\n-    task->log(rust_log::TASK, \"last_os_error()\");\n+    LOG(task, rust_log::TASK, \"last_os_error()\");\n \n #if defined(__WIN32__)\n     LPTSTR buf;\n@@ -91,7 +91,7 @@ extern \"C\" CDECL rust_vec*\n vec_alloc(rust_task *task, type_desc *t, type_desc *elem_t, size_t n_elts)\n {\n     rust_dom *dom = task->dom;\n-    task->log(rust_log::MEM | rust_log::STDLIB,\n+    LOG(task, rust_log::MEM | rust_log::STDLIB,\n               \"vec_alloc %\" PRIdPTR \" elements of size %\" PRIdPTR,\n               n_elts, elem_t->size);\n     size_t fill = n_elts * elem_t->size;\n@@ -126,7 +126,7 @@ vec_len(rust_task *task, type_desc *ty, rust_vec *v)\n extern \"C\" CDECL void\n vec_len_set(rust_task *task, type_desc *ty, rust_vec *v, size_t len)\n {\n-    task->log(rust_log::STDLIB,\n+    LOG(task, rust_log::STDLIB,\n               \"vec_len_set(0x%\" PRIxPTR \", %\" PRIdPTR \") on vec with \"\n               \"alloc = %\" PRIdPTR\n               \", fill = %\" PRIdPTR\n@@ -139,7 +139,7 @@ vec_len_set(rust_task *task, type_desc *ty, rust_vec *v, size_t len)\n extern \"C\" CDECL void\n vec_print_debug_info(rust_task *task, type_desc *ty, rust_vec *v)\n {\n-    task->log(rust_log::STDLIB,\n+    LOG(task, rust_log::STDLIB,\n               \"vec_print_debug_info(0x%\" PRIxPTR \")\"\n               \" with tydesc 0x%\" PRIxPTR\n               \" (size = %\" PRIdPTR \", align = %\" PRIdPTR \")\"\n@@ -154,7 +154,7 @@ vec_print_debug_info(rust_task *task, type_desc *ty, rust_vec *v)\n               v->fill / ty->size);\n \n     for (size_t i = 0; i < v->fill; ++i) {\n-        task->log(rust_log::STDLIB,\n+        LOG(task, rust_log::STDLIB,\n                   \"  %\" PRIdPTR \":    0x%\" PRIxPTR,\n                   i, v->data[i]);\n     }\n@@ -306,7 +306,7 @@ task_sleep(rust_task *task, size_t time_in_us) {\n static void\n debug_tydesc_helper(rust_task *task, type_desc *t)\n {\n-    task->log(rust_log::STDLIB,\n+    LOG(task, rust_log::STDLIB,\n               \"  size %\" PRIdPTR \", align %\" PRIdPTR\n               \", stateful %\" PRIdPTR \", first_param 0x%\" PRIxPTR,\n               t->size, t->align, t->is_stateful, t->first_param);\n@@ -315,19 +315,19 @@ debug_tydesc_helper(rust_task *task, type_desc *t)\n extern \"C\" CDECL void\n debug_tydesc(rust_task *task, type_desc *t)\n {\n-    task->log(rust_log::STDLIB, \"debug_tydesc\");\n+    LOG(task, rust_log::STDLIB, \"debug_tydesc\");\n     debug_tydesc_helper(task, t);\n }\n \n extern \"C\" CDECL void\n debug_opaque(rust_task *task, type_desc *t, uint8_t *front)\n {\n-    task->log(rust_log::STDLIB, \"debug_opaque\");\n+    LOG(task, rust_log::STDLIB, \"debug_opaque\");\n     debug_tydesc_helper(task, t);\n     // FIXME may want to actually account for alignment.  `front` may not\n     // indeed be the front byte of the passed-in argument.\n     for (uintptr_t i = 0; i < t->size; ++front, ++i) {\n-        task->log(rust_log::STDLIB,\n+        LOG(task, rust_log::STDLIB,\n                   \"  byte %\" PRIdPTR \": 0x%\" PRIx8, i, *front);\n     }\n }\n@@ -340,14 +340,14 @@ struct rust_box : rc_base<rust_box> {\n extern \"C\" CDECL void\n debug_box(rust_task *task, type_desc *t, rust_box *box)\n {\n-    task->log(rust_log::STDLIB, \"debug_box(0x%\" PRIxPTR \")\", box);\n+    LOG(task, rust_log::STDLIB, \"debug_box(0x%\" PRIxPTR \")\", box);\n     debug_tydesc_helper(task, t);\n-    task->log(rust_log::STDLIB, \"  refcount %\" PRIdPTR,\n+    LOG(task, rust_log::STDLIB, \"  refcount %\" PRIdPTR,\n               box->ref_count == CONST_REFCOUNT\n               ? CONST_REFCOUNT\n               : box->ref_count - 1);  // -1 because we ref'ed for this call\n     for (uintptr_t i = 0; i < t->size; ++i) {\n-        task->log(rust_log::STDLIB,\n+        LOG(task, rust_log::STDLIB,\n                   \"  byte %\" PRIdPTR \": 0x%\" PRIx8, i, box->data[i]);\n     }\n }\n@@ -360,13 +360,13 @@ struct rust_tag {\n extern \"C\" CDECL void\n debug_tag(rust_task *task, type_desc *t, rust_tag *tag)\n {\n-    task->log(rust_log::STDLIB, \"debug_tag\");\n+    LOG(task, rust_log::STDLIB, \"debug_tag\");\n     debug_tydesc_helper(task, t);\n-    task->log(rust_log::STDLIB,\n+    LOG(task, rust_log::STDLIB,\n               \"  discriminant %\" PRIdPTR, tag->discriminant);\n \n     for (uintptr_t i = 0; i < t->size - sizeof(tag->discriminant); ++i)\n-        task->log(rust_log::STDLIB,\n+        LOG(task, rust_log::STDLIB,\n                   \"  byte %\" PRIdPTR \": 0x%\" PRIx8, i, tag->variant[i]);\n }\n \n@@ -379,17 +379,17 @@ extern \"C\" CDECL void\n debug_obj(rust_task *task, type_desc *t, rust_obj *obj,\n           size_t nmethods, size_t nbytes)\n {\n-    task->log(rust_log::STDLIB,\n+    LOG(task, rust_log::STDLIB,\n               \"debug_obj with %\" PRIdPTR \" methods\", nmethods);\n     debug_tydesc_helper(task, t);\n-    task->log(rust_log::STDLIB, \"  vtbl at 0x%\" PRIxPTR, obj->vtbl);\n-    task->log(rust_log::STDLIB, \"  body at 0x%\" PRIxPTR, obj->body);\n+    LOG(task, rust_log::STDLIB, \"  vtbl at 0x%\" PRIxPTR, obj->vtbl);\n+    LOG(task, rust_log::STDLIB, \"  body at 0x%\" PRIxPTR, obj->body);\n \n     for (uintptr_t *p = obj->vtbl; p < obj->vtbl + nmethods; ++p)\n-        task->log(rust_log::STDLIB, \"  vtbl word: 0x%\" PRIxPTR, *p);\n+        LOG(task, rust_log::STDLIB, \"  vtbl word: 0x%\" PRIxPTR, *p);\n \n     for (uintptr_t i = 0; i < nbytes; ++i)\n-        task->log(rust_log::STDLIB,\n+        LOG(task, rust_log::STDLIB,\n                   \"  body byte %\" PRIdPTR \": 0x%\" PRIxPTR,\n                   i, obj->body->data[i]);\n }\n@@ -402,12 +402,12 @@ struct rust_fn {\n extern \"C\" CDECL void\n debug_fn(rust_task *task, type_desc *t, rust_fn *fn)\n {\n-    task->log(rust_log::STDLIB, \"debug_fn\");\n+    LOG(task, rust_log::STDLIB, \"debug_fn\");\n     debug_tydesc_helper(task, t);\n-    task->log(rust_log::STDLIB, \"  thunk at 0x%\" PRIxPTR, fn->thunk);\n-    task->log(rust_log::STDLIB, \"  closure at 0x%\" PRIxPTR, fn->closure);\n+    LOG(task, rust_log::STDLIB, \"  thunk at 0x%\" PRIxPTR, fn->thunk);\n+    LOG(task, rust_log::STDLIB, \"  closure at 0x%\" PRIxPTR, fn->closure);\n     if (fn->closure) {\n-        task->log(rust_log::STDLIB, \"    refcount %\" PRIdPTR,\n+        LOG(task, rust_log::STDLIB, \"    refcount %\" PRIdPTR,\n                   fn->closure->ref_count);\n     }\n }\n@@ -418,17 +418,17 @@ debug_ptrcast(rust_task *task,\n               type_desc *to_ty,\n               void *ptr)\n {\n-    task->log(rust_log::STDLIB, \"debug_ptrcast from\");\n+    LOG(task, rust_log::STDLIB, \"debug_ptrcast from\");\n     debug_tydesc_helper(task, from_ty);\n-    task->log(rust_log::STDLIB, \"to\");\n+    LOG(task, rust_log::STDLIB, \"to\");\n     debug_tydesc_helper(task, to_ty);\n     return ptr;\n }\n \n extern \"C\" CDECL void\n debug_trap(rust_task *task, rust_str *s)\n {\n-    task->log(rust_log::STDLIB, \"trapping: %s\", s->data);\n+    LOG(task, rust_log::STDLIB, \"trapping: %s\", s->data);\n     // FIXME: x86-ism.\n     __asm__(\"int3\");\n }"}, {"sha": "a88579607c48fe6dddb578c3fe7d37cf7552fe0f", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -13,14 +13,14 @@ rust_chan::rust_chan(rust_task *task,\n     if (port) {\n         associate(port);\n     }\n-    task->log(rust_log::MEM | rust_log::COMM,\n+    LOG(task, rust_log::MEM | rust_log::COMM,\n               \"new rust_chan(task=0x%\" PRIxPTR\n               \", port=0x%\" PRIxPTR \") -> chan=0x%\" PRIxPTR,\n               (uintptr_t) task, (uintptr_t) port, (uintptr_t) this);\n }\n \n rust_chan::~rust_chan() {\n-    task->log(rust_log::MEM | rust_log::COMM,\n+    LOG(task, rust_log::MEM | rust_log::COMM,\n               \"del rust_chan(task=0x%\" PRIxPTR \")\", (uintptr_t) this);\n \n     A(task->dom, is_associated() == false,\n@@ -33,7 +33,7 @@ rust_chan::~rust_chan() {\n void rust_chan::associate(maybe_proxy<rust_port> *port) {\n     this->port = port;\n     if (port->is_proxy() == false) {\n-        task->log(rust_log::TASK,\n+        LOG(task, rust_log::TASK,\n             \"associating chan: 0x%\" PRIxPTR \" with port: 0x%\" PRIxPTR,\n             this, port);\n         this->port->referent()->chans.push(this);\n@@ -51,7 +51,7 @@ void rust_chan::disassociate() {\n     A(task->dom, is_associated(), \"Channel must be associated with a port.\");\n \n     if (port->is_proxy() == false) {\n-        task->log(rust_log::TASK,\n+        LOG(task, rust_log::TASK,\n             \"disassociating chan: 0x%\" PRIxPTR \" from port: 0x%\" PRIxPTR,\n             this, port->referent());\n         port->referent()->chans.swap_delete(this);\n@@ -84,7 +84,7 @@ void rust_chan::send(void *sptr) {\n     } else {\n         rust_port *target_port = port->referent();\n         if (target_port->task->blocked_on(target_port)) {\n-            dom->log(rust_log::COMM, \"dequeued in rendezvous_ptr\");\n+            DLOG(dom, rust_log::COMM, \"dequeued in rendezvous_ptr\");\n             buffer.dequeue(target_port->task->rendezvous_ptr);\n             target_port->task->rendezvous_ptr = 0;\n             target_port->task->wakeup(target_port);"}, {"sha": "23f01c0747fa7cf9288e702640dae77e8313fb4b", "filename": "src/rt/rust_crate.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_crate.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_crate.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -41,7 +41,7 @@ rust_crate::mem_area::mem_area(rust_dom *dom, uintptr_t pos, size_t sz)\n     base(pos),\n     lim(pos + sz)\n {\n-  dom->log(rust_log::MEM, \"new mem_area [0x%\" PRIxPTR \",0x%\" PRIxPTR \"]\",\n+  DLOG(dom, rust_log::MEM, \"new mem_area [0x%\" PRIxPTR \",0x%\" PRIxPTR \"]\",\n            base, lim);\n }\n "}, {"sha": "f9cc400d76bad0c95cfac2dee7b1bc6db7f326ee", "filename": "src/rt/rust_crate_cache.cpp", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_crate_cache.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_crate_cache.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_cache.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -10,12 +10,12 @@ rust_crate_cache::lib::lib(rust_dom *dom, char const *name)\n #else\n     handle = (uintptr_t)dlopen(name, RTLD_GLOBAL|RTLD_LAZY);\n #endif\n-    dom->log(rust_log::CACHE, \"loaded library '%s' as 0x%\"  PRIxPTR,\n+    DLOG(dom, rust_log::CACHE, \"loaded library '%s' as 0x%\"  PRIxPTR,\n              name, handle);\n }\n \n rust_crate_cache::lib::~lib() {\n-    dom->log(rust_log::CACHE, \"~rust_crate_cache::lib(0x%\" PRIxPTR \")\",\n+    DLOG(dom, rust_log::CACHE, \"~rust_crate_cache::lib(0x%\" PRIxPTR \")\",\n              handle);\n     if (handle) {\n #if defined(__WIN32__)\n@@ -46,17 +46,17 @@ rust_crate_cache::c_sym::c_sym(rust_dom *dom, lib *library, char const *name)\n #else\n         val = (uintptr_t)dlsym((void*)handle, name);\n #endif\n-        dom->log(rust_log::CACHE, \"resolved symbol '%s' to 0x%\"  PRIxPTR,\n+        DLOG(dom, rust_log::CACHE, \"resolved symbol '%s' to 0x%\"  PRIxPTR,\n                  name, val);\n     } else {\n-        dom->log(rust_log::CACHE | rust_log::ERR,\n+        DLOG(dom, rust_log::CACHE | rust_log::ERR,\n                  \"unresolved symbol '%s', null lib handle\",\n                  name);\n     }\n }\n \n rust_crate_cache::c_sym::~c_sym() {\n-    dom->log(rust_log::CACHE,\n+    DLOG(dom, rust_log::CACHE,\n             \"~rust_crate_cache::c_sym(0x%\" PRIxPTR \")\", val);\n     library->deref();\n }\n@@ -80,7 +80,7 @@ rust_crate_cache::rust_sym::rust_sym(rust_dom *dom,\n     typedef rust_crate_reader::die die;\n     rust_crate const *crate = (rust_crate*)crate_sym->get_val();\n     if (!crate) {\n-        dom->log(rust_log::CACHE | rust_log::ERR,\n+        DLOG(dom, rust_log::CACHE | rust_log::ERR,\n                  \"failed to resolve symbol, null crate symbol\");\n         return;\n     }\n@@ -98,15 +98,15 @@ rust_crate_cache::rust_sym::rust_sym(rust_dom *dom,\n               && !t1.is_null()\n               && t1.find_child_by_name(crate_rel(curr_crate, *c), t2));\n              ++c, t1=t2) {\n-            dom->log(rust_log::DWARF|rust_log::CACHE,\n+            DLOG(dom, rust_log::DWARF|rust_log::CACHE,\n                     \"matched die <0x%\"  PRIxPTR\n                     \">, child '%s' = die<0x%\" PRIxPTR \">\",\n                     t1.off, crate_rel(curr_crate, *c), t2.off);\n             found_root = found_root || true;\n             if (!*(c+1) && t2.find_num_attr(DW_AT_low_pc, val)) {\n-                dom->log(rust_log::DWARF|rust_log::CACHE,\n+                DLOG(dom, rust_log::DWARF|rust_log::CACHE,\n                          \"found relative address: 0x%\"  PRIxPTR, val);\n-                dom->log(rust_log::DWARF|rust_log::CACHE,\n+                DLOG(dom, rust_log::DWARF|rust_log::CACHE,\n                          \"plus image-base 0x%\"  PRIxPTR,\n                          crate->get_image_base());\n                 val += crate->get_image_base();\n@@ -118,15 +118,15 @@ rust_crate_cache::rust_sym::rust_sym(rust_dom *dom,\n             break;\n     }\n     if (found_leaf) {\n-        dom->log(rust_log::CACHE, \"resolved symbol to 0x%\"  PRIxPTR, val);\n+        DLOG(dom, rust_log::CACHE, \"resolved symbol to 0x%\"  PRIxPTR, val);\n     } else {\n-        dom->log(rust_log::CACHE | rust_log::ERR,\n+        DLOG(dom, rust_log::CACHE | rust_log::ERR,\n                  \"failed to resolve symbol\");\n     }\n }\n \n rust_crate_cache::rust_sym::~rust_sym() {\n-    dom->log(rust_log::CACHE,\n+    DLOG(dom, rust_log::CACHE,\n              \"~rust_crate_cache::rust_sym(0x%\" PRIxPTR \")\", val);\n     crate_sym->deref();\n }\n@@ -155,7 +155,7 @@ rust_crate_cache::get_c_sym(size_t n, lib *library, char const *name)\n {\n     I(dom, n < crate->n_c_syms);\n     c_sym *sym = c_syms[n];\n-    dom->log(rust_log::CACHE, \"cached C symbol %s = 0x%\" PRIxPTR, name, sym);\n+    DLOG(dom, rust_log::CACHE, \"cached C symbol %s = 0x%\" PRIxPTR, name, sym);\n     if (!sym) {\n         sym = new (dom) c_sym(dom, library, name);\n         c_syms[n] = sym;\n@@ -199,10 +199,10 @@ rust_crate_cache::get_type_desc(size_t size,\n     size_t keysz = n_descs * sizeof(type_desc*);\n     HASH_FIND(hh, this->type_descs, descs, keysz, td);\n     if (td) {\n-        dom->log(rust_log::CACHE, \"rust_crate_cache::get_type_desc hit\");\n+        DLOG(dom, rust_log::CACHE, \"rust_crate_cache::get_type_desc hit\");\n         return td;\n     }\n-    dom->log(rust_log::CACHE, \"rust_crate_cache::get_type_desc miss\");\n+    DLOG(dom, rust_log::CACHE, \"rust_crate_cache::get_type_desc miss\");\n     td = (type_desc*) dom->malloc(sizeof(type_desc) + keysz);\n     if (!td)\n         return NULL;\n@@ -214,7 +214,7 @@ rust_crate_cache::get_type_desc(size_t size,\n     td->size = size;\n     td->align = align;\n     for (size_t i = 0; i < n_descs; ++i) {\n-        dom->log(rust_log::CACHE,\n+        DLOG(dom, rust_log::CACHE,\n                  \"rust_crate_cache::descs[%\" PRIdPTR \"] = 0x%\" PRIxPTR,\n                  i, descs[i]);\n         td->descs[i] = descs[i];\n@@ -249,11 +249,11 @@ rust_crate_cache::rust_crate_cache(rust_dom *dom,\n \n void\n rust_crate_cache::flush() {\n-    dom->log(rust_log::CACHE, \"rust_crate_cache::flush()\");\n+    DLOG(dom, rust_log::CACHE, \"rust_crate_cache::flush()\");\n     for (size_t i = 0; i < crate->n_rust_syms; ++i) {\n         rust_sym *s = rust_syms[i];\n         if (s) {\n-            dom->log(rust_log::CACHE,\n+            DLOG(dom, rust_log::CACHE,\n                      \"rust_crate_cache::flush() deref rust_sym %\"\n                      PRIdPTR \" (rc=%\" PRIdPTR \")\", i, s->ref_count);\n             s->deref();\n@@ -264,7 +264,7 @@ rust_crate_cache::flush() {\n     for (size_t i = 0; i < crate->n_c_syms; ++i) {\n         c_sym *s = c_syms[i];\n         if (s) {\n-            dom->log(rust_log::CACHE,\n+            DLOG(dom, rust_log::CACHE,\n                      \"rust_crate_cache::flush() deref c_sym %\"\n                      PRIdPTR \" (rc=%\" PRIdPTR \")\", i, s->ref_count);\n             s->deref();\n@@ -275,7 +275,7 @@ rust_crate_cache::flush() {\n     for (size_t i = 0; i < crate->n_libs; ++i) {\n         lib *l = libs[i];\n         if (l) {\n-            dom->log(rust_log::CACHE, \"rust_crate_cache::flush() deref lib %\"\n+            DLOG(dom, rust_log::CACHE, \"rust_crate_cache::flush() deref lib %\"\n                      PRIdPTR \" (rc=%\" PRIdPTR \")\", i, l->ref_count);\n             l->deref();\n         }\n@@ -285,7 +285,7 @@ rust_crate_cache::flush() {\n     while (type_descs) {\n         type_desc *d = type_descs;\n         HASH_DEL(type_descs, d);\n-        dom->log(rust_log::MEM,\n+        DLOG(dom, rust_log::MEM,\n                  \"rust_crate_cache::flush() tydesc %\" PRIxPTR, d);\n         dom->free(d);\n     }"}, {"sha": "edad0c2eeee86ceae05411df807e0defcc740f51", "filename": "src/rt/rust_crate_reader.cpp", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_crate_reader.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_crate_reader.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_reader.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -92,7 +92,7 @@ rust_crate_reader::mem_reader::adv(size_t amt)\n     ok = false;\n   if (!ok)\n     return;\n-  // mem.dom->log(rust_log::MEM, \"adv %d bytes\", amt);\n+  // mem.DLOG(dom, rust_log::MEM, \"adv %d bytes\", amt);\n   pos += amt;\n   ok &= !at_end();\n   I(mem.dom, at_end() || (mem.base <= pos && pos < mem.lim));\n@@ -120,7 +120,7 @@ rust_crate_reader::abbrev_reader::abbrev_reader\n   rust_dom *dom = mem.dom;\n   while (is_ok() && !at_end()) {\n \n-    // dom->log(rust_log::DWARF, \"reading new abbrev at 0x%\" PRIxPTR,\n+    // DLOG(dom, rust_log::DWARF, \"reading new abbrev at 0x%\" PRIxPTR,\n     //          tell_off());\n \n     uintptr_t idx, tag;\n@@ -133,13 +133,13 @@ rust_crate_reader::abbrev_reader::abbrev_reader\n     size_t body_off = tell_off();\n     while (is_ok() && step_attr_form_pair(attr, form));\n \n-    // dom->log(rust_log::DWARF,\n+    // DLOG(dom, rust_log::DWARF,\n     //         \"finished scanning attr/form pairs, pos=0x%\"\n     //         PRIxPTR \", lim=0x%\" PRIxPTR \", is_ok=%d, at_end=%d\",\n     //        pos, mem.lim, is_ok(), at_end());\n \n     if (is_ok() || at_end()) {\n-      dom->log(rust_log::DWARF, \"read abbrev: %\" PRIdPTR, idx);\n+      DLOG(dom, rust_log::DWARF, \"read abbrev: %\" PRIdPTR, idx);\n       I(dom, idx = abbrevs.length() + 1);\n       abbrevs.push(new (dom) abbrev(dom, body_off,\n                                     tell_off() - body_off,\n@@ -162,11 +162,11 @@ rust_crate_reader::abbrev_reader::step_attr_form_pair(uintptr_t &attr,\n {\n   attr = 0;\n   form = 0;\n-  // mem.dom->log(rust_log::DWARF, \"reading attr/form pair at 0x%\" PRIxPTR,\n+  // mem.DLOG(dom, rust_log::DWARF, \"reading attr/form pair at 0x%\" PRIxPTR,\n   //              tell_off());\n   get_uleb(attr);\n   get_uleb(form);\n-  // mem.dom->log(rust_log::DWARF, \"attr 0x%\" PRIxPTR \", form 0x%\" PRIxPTR,\n+  // mem.DLOG(dom, rust_log::DWARF, \"attr 0x%\" PRIxPTR \", form 0x%\" PRIxPTR,\n   //              attr, form);\n   return ! (attr == 0 && form == 0);\n }\n@@ -254,18 +254,19 @@ rust_crate_reader::die::die(die_reader *rdr, uintptr_t off)\n   rdr->get_uleb(ab_idx);\n   if (!ab_idx) {\n     ab = NULL;\n-    dom->log(rust_log::DWARF, \"DIE <0x%\" PRIxPTR \"> (null)\", off);\n-    dom->get_log().outdent();\n+    DLOG(dom, rust_log::DWARF, \"DIE <0x%\" PRIxPTR \"> (null)\", off);\n+    if (dom->get_log().is_tracing(rust_log::DWARF))\n+        dom->get_log().outdent();\n   } else {\n     ab = rdr->abbrevs.get_abbrev(ab_idx);\n     if (!ab) {\n-        dom->log(rust_log::DWARF, \"  bad abbrev number: 0x%\"\n+        DLOG(dom, rust_log::DWARF, \"  bad abbrev number: 0x%\"\n                  PRIxPTR, ab_idx);\n         rdr->fail();\n     } else {\n-        dom->log(rust_log::DWARF, \"DIE <0x%\" PRIxPTR \"> abbrev 0x%\"\n+        DLOG(dom, rust_log::DWARF, \"DIE <0x%\" PRIxPTR \"> abbrev 0x%\"\n                  PRIxPTR, off, ab_idx);\n-        dom->log(rust_log::DWARF, \"  tag 0x%x, has children: %d\",\n+        DLOG(dom, rust_log::DWARF, \"  tag 0x%x, has children: %d\",\n                  ab->tag, ab->has_children);\n     }\n   }\n@@ -353,7 +354,7 @@ rust_crate_reader::die::step_attr(attr &a) const\n       break;\n \n     default:\n-      rdr->mem.dom->log(rust_log::DWARF, \"  unknown dwarf form: 0x%\"\n+      DLOG(rdr->mem.dom, rust_log::DWARF, \"  unknown dwarf form: 0x%\"\n                         PRIxPTR, a.form);\n       rdr->fail();\n       break;\n@@ -473,16 +474,16 @@ rust_crate_reader::die::next() const\n         while (step_attr(a)) {\n             I(dom, !(a.is_numeric() && a.is_string()));\n             if (a.is_numeric())\n-                dom->log(rust_log::DWARF, \"  attr num: 0x%\"\n+                DLOG(dom, rust_log::DWARF, \"  attr num: 0x%\"\n                          PRIxPTR, a.get_num(dom));\n             else if (a.is_string())\n-                dom->log(rust_log::DWARF, \"  attr str: %s\",\n+                DLOG(dom, rust_log::DWARF, \"  attr str: %s\",\n                          a.get_str(dom));\n             else\n-                dom->log(rust_log::DWARF, \"  attr ??:\");\n+                DLOG(dom, rust_log::DWARF, \"  attr ??:\");\n         }\n     }\n-    if (has_children())\n+    if (has_children() && dom->get_log().is_tracing(rust_log::DWARF))\n         dom->get_log().indent();\n   }\n   return die(rdr, rdr->tell_off());\n@@ -493,12 +494,12 @@ rust_crate_reader::die::next_sibling() const\n {\n   // FIXME: use DW_AT_sibling, when present.\n   if (has_children()) {\n-    // rdr->mem.dom->log(rust_log::DWARF, \"+++ children of die 0x%\"\n+    // DLOG(rdr->mem.dom, rust_log::DWARF, \"+++ children of die 0x%\"\n     //                   PRIxPTR, off);\n     die child = next();\n     while (!child.is_null())\n       child = child.next_sibling();\n-    // rdr->mem.dom->log(rust_log::DWARF, \"--- children of die 0x%\"\n+    // DLOG(rdr->mem.dom, rust_log::DWARF, \"--- children of die 0x%\"\n     //                   PRIxPTR, off);\n     return child.next();\n   } else {\n@@ -553,16 +554,16 @@ rust_crate_reader::die_reader::die_reader(rust_crate::mem_area &die_mem,\n   get(sizeof_addr);\n \n   if (is_ok()) {\n-    dom->log(rust_log::DWARF, \"new root CU at 0x%\" PRIxPTR, die_mem.base);\n-    dom->log(rust_log::DWARF, \"CU unit length: %\" PRId32, cu_unit_length);\n-    dom->log(rust_log::DWARF, \"dwarf version: %\" PRId16, dwarf_vers);\n-    dom->log(rust_log::DWARF, \"CU abbrev off: %\" PRId32, cu_abbrev_off);\n-    dom->log(rust_log::DWARF, \"size of address: %\" PRId8, sizeof_addr);\n+    DLOG(dom, rust_log::DWARF, \"new root CU at 0x%\" PRIxPTR, die_mem.base);\n+    DLOG(dom, rust_log::DWARF, \"CU unit length: %\" PRId32, cu_unit_length);\n+    DLOG(dom, rust_log::DWARF, \"dwarf version: %\" PRId16, dwarf_vers);\n+    DLOG(dom, rust_log::DWARF, \"CU abbrev off: %\" PRId32, cu_abbrev_off);\n+    DLOG(dom, rust_log::DWARF, \"size of address: %\" PRId8, sizeof_addr);\n     I(dom, sizeof_addr == sizeof(uintptr_t));\n     I(dom, dwarf_vers >= 2);\n     I(dom, cu_base + cu_unit_length == die_mem.lim - die_mem.base);\n   } else {\n-    dom->log(rust_log::DWARF, \"failed to read root CU header\");\n+    DLOG(dom, rust_log::DWARF, \"failed to read root CU header\");\n   }\n }\n \n@@ -579,9 +580,9 @@ rust_crate_reader::rust_crate_reader(rust_dom *dom,\n     die_mem(crate->get_debug_info(dom)),\n     dies(die_mem, abbrevs)\n {\n-  dom->log(rust_log::MEM, \"crate_reader on crate: 0x%\" PRIxPTR, this);\n-  dom->log(rust_log::MEM, \"debug_abbrev: 0x%\" PRIxPTR, abbrev_mem.base);\n-  dom->log(rust_log::MEM, \"debug_info: 0x%\" PRIxPTR, die_mem.base);\n+  DLOG(dom, rust_log::MEM, \"crate_reader on crate: 0x%\" PRIxPTR, this);\n+  DLOG(dom, rust_log::MEM, \"debug_abbrev: 0x%\" PRIxPTR, abbrev_mem.base);\n+  DLOG(dom, rust_log::MEM, \"debug_info: 0x%\" PRIxPTR, die_mem.base);\n   // For now, perform diagnostics only.\n   dies.dump();\n }"}, {"sha": "9512eeaa3cca459db3ab2bba63769deb5886f491", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -23,7 +23,7 @@ rust_dom::rust_dom(rust_kernel *kernel,\n     kernel(kernel),\n     message_queue(message_queue)\n {\n-    logptr(\"new dom\", (uintptr_t)this);\n+    LOGPTR(this, \"new dom\", (uintptr_t)this);\n     isaac_init(this, &rctx);\n #ifndef __WIN32__\n     pthread_attr_init(&attr);\n@@ -34,8 +34,8 @@ rust_dom::rust_dom(rust_kernel *kernel,\n }\n \n rust_dom::~rust_dom() {\n-    log(rust_log::MEM | rust_log::DOM,\n-        \"~rust_dom %s @0x%\" PRIxPTR, name, (uintptr_t)this);\n+    DLOG(this, rust_log::MEM | rust_log::DOM,\n+         \"~rust_dom %s @0x%\" PRIxPTR, name, (uintptr_t)this);\n     newborn_tasks.delete_all();\n     running_tasks.delete_all();\n     blocked_tasks.delete_all();\n@@ -79,11 +79,6 @@ rust_dom::log(uint32_t type_bits, char const *fmt, ...) {\n     }\n }\n \n-rust_log &\n-rust_dom::get_log() {\n-    return _log;\n-}\n-\n void\n rust_dom::logptr(char const *msg, uintptr_t ptrval) {\n     log(rust_log::MEM, \"%s 0x%\" PRIxPTR, msg, ptrval);\n@@ -156,7 +151,7 @@ rust_dom::free(void *mem) {\n \n void\n rust_dom::free(void *mem, memory_region::memory_region_type type) {\n-    log(rust_log::MEM, \"rust_dom::free(0x%\" PRIxPTR \")\", mem);\n+    DLOG(this, rust_log::MEM, \"rust_dom::free(0x%\" PRIxPTR \")\", mem);\n     if (type == memory_region::LOCAL) {\n         local_region.free(mem);\n     } else if (type == memory_region::SYNCHRONIZED) {\n@@ -177,7 +172,8 @@ rust_dom::win32_require(LPCTSTR fn, BOOL ok) {\n                       NULL, err,\n                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                       (LPTSTR) &buf, 0, NULL );\n-        log(rust_log::ERR, \"%s failed with error %ld: %s\", fn, err, buf);\n+        DLOG(this, rust_log::ERR, \"%s failed with error %ld: %s\",\n+             fn, err, buf);\n         LocalFree((HLOCAL)buf);\n         I(this, ok);\n     }\n@@ -199,7 +195,7 @@ rust_dom::reap_dead_tasks() {\n         if (task->ref_count == 0) {\n             I(this, task->tasks_waiting_to_join.is_empty());\n             dead_tasks.remove(task);\n-            log(rust_log::TASK,\n+            DLOG(this, rust_log::TASK,\n                 \"deleting unreferenced dead task %s @0x%\" PRIxPTR,\n                 task->name, task);\n             delete task;\n@@ -215,7 +211,7 @@ rust_dom::reap_dead_tasks() {\n void rust_dom::drain_incoming_message_queue(bool process) {\n     rust_message *message;\n     while (message_queue->dequeue(&message)) {\n-        log(rust_log::COMM, \"<== receiving \\\"%s\\\" \" PTR,\n+        DLOG(this, rust_log::COMM, \"<== receiving \\\"%s\\\" \" PTR,\n             message->label, message);\n         if (process) {\n             message->process();\n@@ -292,8 +288,8 @@ rust_dom::start_main_loop() {\n     // Make sure someone is watching, to pull us out of infinite loops.\n     rust_timer timer(this);\n \n-    log(rust_log::DOM, \"started domain loop\");\n-    log(rust_log::DOM | rust_log::MEM,\n+    DLOG(this, rust_log::DOM, \"started domain loop\");\n+    DLOG(this, rust_log::DOM | rust_log::MEM,\n         \"activate glue: \" PTR \", exit glue: \" PTR,\n         root_crate->get_activate_glue(), root_crate->get_exit_task_glue());\n \n@@ -312,17 +308,17 @@ rust_dom::start_main_loop() {\n             if (_log.is_tracing(rust_log::TASK)) {\n                 log_state();\n             }\n-            log(rust_log::TASK,\n+            DLOG(this, rust_log::TASK,\n                 \"all tasks are blocked, scheduler yielding ...\");\n             sync::sleep(100);\n-            log(rust_log::TASK,\n+            DLOG(this, rust_log::TASK,\n                 \"scheduler resuming ...\");\n             continue;\n         }\n \n         I(this, scheduled_task->running());\n \n-        log(rust_log::TASK,\n+        DLOG(this, rust_log::TASK,\n             \"activating task %s 0x%\" PRIxPTR\n             \", sp=0x%\" PRIxPTR\n             \", ref_count=%d\"\n@@ -337,7 +333,7 @@ rust_dom::start_main_loop() {\n \n         activate(scheduled_task);\n \n-        log(rust_log::TASK,\n+        DLOG(this, rust_log::TASK,\n                  \"returned from task %s @0x%\" PRIxPTR\n                  \" in state '%s', sp=0x%\" PRIxPTR,\n                  scheduled_task->name,\n@@ -352,11 +348,12 @@ rust_dom::start_main_loop() {\n         reap_dead_tasks();\n     }\n \n-    log(rust_log::DOM, \"terminated scheduler loop, reaping dead tasks ...\");\n+    DLOG(this, rust_log::DOM,\n+         \"terminated scheduler loop, reaping dead tasks ...\");\n \n     while (dead_tasks.length() > 0) {\n         if (message_queue->is_empty()) {\n-            log(rust_log::DOM,\n+            DLOG(this, rust_log::DOM,\n                 \"waiting for %d dead tasks to become dereferenced, \"\n                 \"scheduler yielding ...\",\n                 dead_tasks.length());\n@@ -370,14 +367,14 @@ rust_dom::start_main_loop() {\n         reap_dead_tasks();\n     }\n \n-    log(rust_log::DOM, \"finished main-loop (dom.rval = %d)\", rval);\n+    DLOG(this, rust_log::DOM, \"finished main-loop (dom.rval = %d)\", rval);\n     return rval;\n }\n \n \n rust_crate_cache *\n rust_dom::get_cache(rust_crate const *crate) {\n-    log(rust_log::CACHE,\n+    DLOG(this, rust_log::CACHE,\n         \"looking for crate-cache for crate 0x%\" PRIxPTR, crate);\n     rust_crate_cache *cache = NULL;\n     for (size_t i = 0; i < caches.length(); ++i) {\n@@ -388,7 +385,7 @@ rust_dom::get_cache(rust_crate const *crate) {\n         }\n     }\n     if (!cache) {\n-        log(rust_log::CACHE,\n+        DLOG(this, rust_log::CACHE,\n             \"making new crate-cache for crate 0x%\" PRIxPTR, crate);\n         cache = new (this) rust_crate_cache(this, crate);\n         caches.push(cache);\n@@ -401,7 +398,7 @@ rust_task *\n rust_dom::create_task(rust_task *spawner, const char *name) {\n     rust_task *task =\n         new (this) rust_task (this, &newborn_tasks, spawner, name);\n-    log(rust_log::TASK, \"created task: \" PTR \", spawner: %s, name: %s\",\n+    DLOG(this, rust_log::TASK, \"created task: \" PTR \", spawner: %s, name: %s\",\n                         task, spawner ? spawner->name : \"null\", name);\n     newborn_tasks.append(task);\n     return task;"}, {"sha": "be3ca2f9f18b0533f9c1f8cb27d75724cde5a8dd", "filename": "src/rt/rust_dom.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_dom.h", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_dom.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.h?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -88,6 +88,11 @@ struct rust_dom : public kernel_owned<rust_dom>, rc_base<rust_dom>\n     rust_task *create_task(rust_task *spawner, const char *name);\n };\n \n+inline rust_log &\n+rust_dom::get_log() {\n+    return _log;\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "9b8347bc1f8a9240bdcde2fa0de8d7a3a71ea55f", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -1,5 +1,10 @@\n #include \"rust_internal.h\"\n \n+#define KLOG(...)                                 \\\n+  if (_log.is_tracing(rust_log::KERN)) {          \\\n+      log(rust_log::KERN, __VA_ARGS__);           \\\n+  } else\n+\n rust_kernel::rust_kernel(rust_srv *srv) :\n     _region(&srv->local_region),\n     _log(srv, NULL),\n@@ -20,9 +25,8 @@ rust_kernel::create_domain(const rust_crate *crate, const char *name) {\n     message_queue->associate(handle);\n     domains.append(dom);\n     message_queues.append(message_queue);\n-    log(rust_log::KERN | rust_log::TASK,\n-        \"created domain: \" PTR \", name: %s, index: %d, domains %d\",\n-        dom, name, dom->list_index, domains.length());\n+    KLOG(\"created domain: \" PTR \", name: %s, index: %d, domains %d\",\n+         dom, name, dom->list_index, domains.length());\n     _kernel_lock.signal_all();\n     _kernel_lock.unlock();\n     return handle;\n@@ -31,8 +35,7 @@ rust_kernel::create_domain(const rust_crate *crate, const char *name) {\n void\n rust_kernel::destroy_domain(rust_dom *dom) {\n     _kernel_lock.lock();\n-    log(rust_log::KERN,\n-        \"deleting domain: \" PTR \", name: %s, index: %d, domains %d\",\n+    KLOG(\"deleting domain: \" PTR \", name: %s, index: %d, domains %d\",\n         dom, dom->name, dom->list_index, domains.length());\n     domains.remove(dom);\n     dom->message_queue->disassociate();\n@@ -98,12 +101,12 @@ rust_kernel::join_all_domains() {\n         _kernel_lock.wait();\n     }\n     _kernel_lock.unlock();\n-    log(rust_log::KERN, \"joined domains\");\n+    KLOG(\"joined domains\");\n }\n \n void\n rust_kernel::log_all_domain_state() {\n-    log(rust_log::KERN, \"log_all_domain_state: %d domains\", domains.length());\n+    KLOG(\"log_all_domain_state: %d domains\", domains.length());\n     for (uint32_t i = 0; i < domains.length(); i++) {\n         domains[i]->log_state();\n     }\n@@ -155,14 +158,14 @@ rust_kernel::start_kernel_loop() {\n \n void\n rust_kernel::run() {\n-    log(rust_log::KERN, \"started kernel loop\");\n+    KLOG(\"started kernel loop\");\n     start_kernel_loop();\n-    log(rust_log::KERN, \"finished kernel loop\");\n+    KLOG(\"finished kernel loop\");\n }\n \n void\n rust_kernel::terminate_kernel_loop() {\n-    log(rust_log::KERN, \"terminating kernel loop\");\n+    KLOG(\"terminating kernel loop\");\n     _interrupt_kernel_loop = true;\n     signal_kernel_lock();\n     join();\n@@ -181,13 +184,13 @@ rust_kernel::~rust_kernel() {\n     // messages.\n     pump_message_queues();\n \n-    log(rust_log::KERN, \"freeing handles\");\n+    KLOG(\"freeing handles\");\n \n     free_handles(_task_handles);\n     free_handles(_port_handles);\n     free_handles(_dom_handles);\n \n-    log(rust_log::KERN, \"freeing queues\");\n+    KLOG(\"freeing queues\");\n \n     rust_message_queue *queue = NULL;\n     while (message_queues.pop(&queue)) {"}, {"sha": "3017b549263b297e2e04009e44d9fa0def28ac0b", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -204,11 +204,6 @@ rust_log::trace_ln(rust_task *task, ansi_color color,\n     }\n }\n \n-bool\n-rust_log::is_tracing(uint32_t type_bits) {\n-    return type_bits & _type_bit_mask;\n-}\n-\n void\n rust_log::indent() {\n     _indent++;"}, {"sha": "8d3d4bcb9cadf910cbee9fbccbc1fc71e14484ea", "filename": "src/rt/rust_log.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -1,6 +1,21 @@\n #ifndef RUST_LOG_H\n #define RUST_LOG_H\n \n+#define DLOG(dom, mask, ...)                      \\\n+  if ((dom)->get_log().is_tracing(mask)) {        \\\n+      (dom)->log(mask, __VA_ARGS__);              \\\n+  } else\n+#define LOG(task, mask, ...)                      \\\n+  DLOG((task)->dom, mask, __VA_ARGS__)\n+#define LOG_I(task, mask, ...)                    \\\n+  if ((task)->dom->get_log().is_tracing(mask)) {  \\\n+      (task)->dom->get_log().reset_indent(0);     \\\n+      (task)->dom->log(mask, __VA_ARGS__);        \\\n+      (task)->dom->get_log().indent();            \\\n+  } else\n+#define LOGPTR(dom, msg, ptrval)                  \\\n+  DLOG(dom, rust_log::MEM, \"%s 0x%\" PRIxPTR, msg, ptrval)\n+\n class rust_dom;\n class rust_task;\n \n@@ -65,4 +80,9 @@ class rust_log {\n     void trace_ln(rust_task *task, char *message);\n };\n \n+inline bool\n+rust_log::is_tracing(uint32_t type_bits) {\n+    return type_bits & _type_bit_mask;\n+}\n+\n #endif /* RUST_LOG_H */"}, {"sha": "178b46a702bad68307d4f4d65c066ff7fd7021cb", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -5,7 +5,7 @@ rust_port::rust_port(rust_task *task, size_t unit_sz) :\n                      maybe_proxy<rust_port>(this), task(task),\n                      unit_sz(unit_sz), writers(task->dom), chans(task->dom) {\n \n-    task->log(rust_log::MEM | rust_log::COMM,\n+    LOG(task, rust_log::MEM | rust_log::COMM,\n               \"new rust_port(task=0x%\" PRIxPTR \", unit_sz=%d) -> port=0x%\"\n               PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n \n@@ -14,18 +14,18 @@ rust_port::rust_port(rust_task *task, size_t unit_sz) :\n }\n \n rust_port::~rust_port() {\n-    task->log(rust_log::COMM | rust_log::MEM,\n+    LOG(task, rust_log::COMM | rust_log::MEM,\n               \"~rust_port 0x%\" PRIxPTR, (uintptr_t) this);\n \n-    log_state();\n+    //    log_state();\n \n     // Disassociate channels from this port.\n     while (chans.is_empty() == false) {\n         rust_chan *chan = chans.peek();\n         chan->disassociate();\n \n         if (chan->ref_count == 0) {\n-            task->log(rust_log::COMM,\n+            LOG(task, rust_log::COMM,\n                 \"chan: 0x%\" PRIxPTR \" is dormant, freeing\", chan);\n             delete chan;\n         }\n@@ -39,20 +39,20 @@ bool rust_port::receive(void *dptr) {\n         rust_chan *chan = chans[i];\n         if (chan->buffer.is_empty() == false) {\n             chan->buffer.dequeue(dptr);\n-            task->log(rust_log::COMM, \"<=== read data ===\");\n+            LOG(task, rust_log::COMM, \"<=== read data ===\");\n             return true;\n         }\n     }\n     return false;\n }\n \n void rust_port::log_state() {\n-    task->log(rust_log::COMM,\n+    LOG(task, rust_log::COMM,\n               \"rust_port: 0x%\" PRIxPTR \", associated channel(s): %d\",\n               this, chans.length());\n     for (uint32_t i = 0; i < chans.length(); i++) {\n         rust_chan *chan = chans[i];\n-        task->log(rust_log::COMM,\n+        LOG(task, rust_log::COMM,\n             \"\\tchan: 0x%\" PRIxPTR \", size: %d, remote: %s\",\n             chan,\n             chan->buffer.size(),"}, {"sha": "4f7bbda61c66aea4e7e073ab2cb2987f0acb5c40", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -24,10 +24,10 @@ new_stk(rust_dom *dom, size_t minsz)\n         minsz = min_stk_bytes;\n     size_t sz = sizeof(stk_seg) + minsz;\n     stk_seg *stk = (stk_seg *)dom->malloc(sz);\n-    dom->logptr(\"new stk\", (uintptr_t)stk);\n+    LOGPTR(dom, \"new stk\", (uintptr_t)stk);\n     memset(stk, 0, sizeof(stk_seg));\n     stk->limit = (uintptr_t) &stk->data[minsz];\n-    dom->logptr(\"stk limit\", stk->limit);\n+    LOGPTR(dom, \"stk limit\", stk->limit);\n     stk->valgrind_id =\n         VALGRIND_STACK_REGISTER(&stk->data[0],\n                                 &stk->data[minsz]);\n@@ -38,7 +38,7 @@ static void\n del_stk(rust_dom *dom, stk_seg *stk)\n {\n     VALGRIND_STACK_DEREGISTER(stk->valgrind_id);\n-    dom->logptr(\"freeing stk segment\", (uintptr_t)stk);\n+    LOGPTR(dom, \"freeing stk segment\", (uintptr_t)stk);\n     dom->free(stk);\n }\n \n@@ -93,7 +93,7 @@ rust_task::rust_task(rust_dom *dom, rust_task_list *state,\n     alarm(this),\n     handle(NULL)\n {\n-    dom->logptr(\"new task\", (uintptr_t)this);\n+    LOGPTR(dom, \"new task\", (uintptr_t)this);\n \n     if (spawner == NULL) {\n         ref_count = 0;\n@@ -102,24 +102,24 @@ rust_task::rust_task(rust_dom *dom, rust_task_list *state,\n \n rust_task::~rust_task()\n {\n-    dom->log(rust_log::MEM|rust_log::TASK,\n+    DLOG(dom, rust_log::MEM|rust_log::TASK,\n              \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n              name, (uintptr_t)this, ref_count);\n \n     /*\n       for (uintptr_t fp = get_fp(); fp; fp = get_previous_fp(fp)) {\n       frame_glue_fns *glue_fns = get_frame_glue_fns(fp);\n-      dom->log(rust_log::MEM|rust_log::TASK,\n+      DLOG(dom, rust_log::MEM|rust_log::TASK,\n       \"~rust_task, frame fp=0x%\" PRIxPTR \", glue_fns=0x%\" PRIxPTR,\n       fp, glue_fns);\n       if (glue_fns) {\n-      dom->log(rust_log::MEM|rust_log::TASK,\n+      DLOG(dom, rust_log::MEM|rust_log::TASK,\n                \"~rust_task, mark_glue=0x%\" PRIxPTR,\n                glue_fns->mark_glue);\n-      dom->log(rust_log::MEM|rust_log::TASK,\n+      DLOG(dom, rust_log::MEM|rust_log::TASK,\n                \"~rust_task, drop_glue=0x%\" PRIxPTR,\n                glue_fns->drop_glue);\n-      dom->log(rust_log::MEM|rust_log::TASK,\n+      DLOG(dom, rust_log::MEM|rust_log::TASK,\n                \"~rust_task, reloc_glue=0x%\" PRIxPTR,\n                glue_fns->reloc_glue);\n       }\n@@ -143,8 +143,8 @@ rust_task::start(uintptr_t exit_task_glue,\n                  uintptr_t args,\n                  size_t callsz)\n {\n-    dom->logptr(\"exit-task glue\", exit_task_glue);\n-    dom->logptr(\"from spawnee\", spawnee_fn);\n+    LOGPTR(dom, \"exit-task glue\", exit_task_glue);\n+    LOGPTR(dom, \"from spawnee\", spawnee_fn);\n \n     // Set sp to last uintptr_t-sized cell of segment\n     rust_sp -= sizeof(uintptr_t);\n@@ -266,7 +266,7 @@ rust_task::grow(size_t n_frame_bytes)\n     uintptr_t old_bottom = (uintptr_t) &old_stk->data[0];\n     uintptr_t rust_sp_disp = old_top - this->rust_sp;\n     size_t ssz = old_top - old_bottom;\n-    dom->log(rust_log::MEM|rust_log::TASK|rust_log::UPCALL,\n+    DLOG(dom, rust_log::MEM|rust_log::TASK|rust_log::UPCALL,\n              \"upcall_grow_task(%\" PRIdPTR\n              \"), old size %\" PRIdPTR\n              \" bytes (old lim: 0x%\" PRIxPTR \")\",\n@@ -276,13 +276,13 @@ rust_task::grow(size_t n_frame_bytes)\n         ssz = n_frame_bytes;\n     ssz = next_power_of_two(ssz);\n \n-    dom->log(rust_log::MEM|rust_log::TASK, \"upcall_grow_task growing stk 0x%\"\n+    DLOG(dom, rust_log::MEM|rust_log::TASK, \"upcall_grow_task growing stk 0x%\"\n              PRIxPTR \" to %d bytes\", old_stk, ssz);\n \n     stk_seg *nstk = new_stk(dom, ssz);\n     uintptr_t new_top = (uintptr_t) &nstk->data[ssz];\n     size_t n_copy = old_top - old_bottom;\n-    dom->log(rust_log::MEM|rust_log::TASK,\n+    DLOG(dom, rust_log::MEM|rust_log::TASK,\n              \"copying %d bytes of stack from [0x%\" PRIxPTR \", 0x%\" PRIxPTR \"]\"\n              \" to [0x%\" PRIxPTR \", 0x%\" PRIxPTR \"]\",\n              n_copy,\n@@ -296,7 +296,7 @@ rust_task::grow(size_t n_frame_bytes)\n     this->stk = nstk;\n     this->rust_sp = new_top - rust_sp_disp;\n \n-    dom->log(rust_log::MEM|rust_log::TASK, \"processing relocations\");\n+    DLOG(dom, rust_log::MEM|rust_log::TASK, \"processing relocations\");\n \n     // FIXME (issue #32): this is the most ridiculously crude\n     // relocation scheme ever. Try actually, you know, writing out\n@@ -305,16 +305,16 @@ rust_task::grow(size_t n_frame_bytes)\n     for (uintptr_t* p = (uintptr_t*)(new_top - n_copy);\n          p < (uintptr_t*)new_top; ++p) {\n         if (old_bottom <= *p && *p < old_top) {\n-            //dom->log(rust_log::MEM, \"relocating pointer 0x%\" PRIxPTR\n+            //DLOG(dom, rust_log::MEM, \"relocating pointer 0x%\" PRIxPTR\n             //        \" by %d bytes\", *p, (new_top - old_top));\n             n_relocs++;\n             *p += (new_top - old_top);\n         }\n     }\n-    dom->log(rust_log::MEM|rust_log::TASK,\n+    DLOG(dom, rust_log::MEM|rust_log::TASK,\n              \"processed %d relocations\", n_relocs);\n     del_stk(dom, old_stk);\n-    dom->logptr(\"grown stk limit\", new_top);\n+    LOGPTR(dom, \"grown stk limit\", new_top);\n #endif\n }\n \n@@ -342,7 +342,7 @@ rust_task::run_after_return(size_t nargs, uintptr_t glue)\n     sp = align_down(sp - nargs * sizeof(uintptr_t));\n \n     uintptr_t *retpc = ((uintptr_t *) sp) - 1;\n-    dom->log(rust_log::TASK|rust_log::MEM,\n+    DLOG(dom, rust_log::TASK|rust_log::MEM,\n              \"run_after_return: overwriting retpc=0x%\" PRIxPTR\n              \" @ runtime_sp=0x%\" PRIxPTR\n              \" with glue=0x%\" PRIxPTR,\n@@ -363,7 +363,7 @@ rust_task::run_on_resume(uintptr_t glue)\n     // Inject glue as resume address in the suspended frame.\n     uintptr_t* rsp = (uintptr_t*) rust_sp;\n     rsp += n_callee_saves;\n-    dom->log(rust_log::TASK|rust_log::MEM,\n+    DLOG(dom, rust_log::TASK|rust_log::MEM,\n              \"run_on_resume: overwriting retpc=0x%\" PRIxPTR\n              \" @ rust_sp=0x%\" PRIxPTR\n              \" with glue=0x%\" PRIxPTR,\n@@ -415,15 +415,15 @@ rust_task::kill() {\n void\n rust_task::fail(size_t nargs) {\n     // See note in ::kill() regarding who should call this.\n-    dom->log(rust_log::TASK, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n+    DLOG(dom, rust_log::TASK, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n     backtrace();\n     // Unblock the task so it can unwind.\n     unblock();\n     if (this == dom->root_task)\n         dom->fail();\n     run_after_return(nargs, dom->root_crate->get_unwind_glue());\n     if (supervisor) {\n-        dom->log(rust_log::TASK,\n+        DLOG(dom, rust_log::TASK,\n                  \"task %s @0x%\" PRIxPTR\n                  \" propagating failure to supervisor %s @0x%\" PRIxPTR,\n                  name, this, supervisor->name, supervisor);\n@@ -434,15 +434,15 @@ rust_task::fail(size_t nargs) {\n void\n rust_task::gc(size_t nargs)\n {\n-    dom->log(rust_log::TASK|rust_log::MEM,\n+    DLOG(dom, rust_log::TASK|rust_log::MEM,\n              \"task %s @0x%\" PRIxPTR \" garbage collecting\", name, this);\n     run_after_return(nargs, dom->root_crate->get_gc_glue());\n }\n \n void\n rust_task::unsupervise()\n {\n-    dom->log(rust_log::TASK,\n+    DLOG(dom, rust_log::TASK,\n              \"task %s @0x%\" PRIxPTR\n              \" disconnecting from supervisor %s @0x%\" PRIxPTR,\n              name, this, supervisor->name, supervisor);\n@@ -551,7 +551,7 @@ rust_task::malloc(size_t sz, type_desc *td)\n         return mem;\n     if (td) {\n         gc_alloc *gcm = (gc_alloc*) mem;\n-        dom->log(rust_log::TASK|rust_log::MEM|rust_log::GC,\n+        DLOG(dom, rust_log::TASK|rust_log::MEM|rust_log::GC,\n                  \"task %s @0x%\" PRIxPTR\n                  \" allocated %d GC bytes = 0x%\" PRIxPTR,\n                  name, (uintptr_t)this, sz, gcm);\n@@ -575,7 +575,7 @@ rust_task::realloc(void *data, size_t sz, bool is_gc)\n         unlink_gc(gcm);\n         sz += sizeof(gc_alloc);\n         gcm = (gc_alloc*) dom->realloc((void*)gcm, sz);\n-        dom->log(rust_log::TASK|rust_log::MEM|rust_log::GC,\n+        DLOG(dom, rust_log::TASK|rust_log::MEM|rust_log::GC,\n                  \"task %s @0x%\" PRIxPTR\n                  \" reallocated %d GC bytes = 0x%\" PRIxPTR,\n                  name, (uintptr_t)this, sz, gcm);\n@@ -598,7 +598,7 @@ rust_task::free(void *p, bool is_gc)\n     if (is_gc) {\n         gc_alloc *gcm = (gc_alloc*)(((char *)p) - sizeof(gc_alloc));\n         unlink_gc(gcm);\n-        dom->log(rust_log::TASK|rust_log::MEM|rust_log::GC,\n+        DLOG(dom, rust_log::TASK|rust_log::MEM|rust_log::GC,\n                  \"task %s @0x%\" PRIxPTR \" freeing GC memory = 0x%\" PRIxPTR,\n                  name, (uintptr_t)this, gcm);\n         dom->free(gcm);\n@@ -610,7 +610,7 @@ rust_task::free(void *p, bool is_gc)\n void\n rust_task::transition(rust_task_list *src, rust_task_list *dst) {\n     I(dom, state == src);\n-    dom->log(rust_log::TASK,\n+    DLOG(dom, rust_log::TASK,\n              \"task %s \" PTR \" state change '%s' -> '%s'\",\n              name, (uintptr_t)this, src->name, dst->name);\n     src->remove(this);\n@@ -658,14 +658,14 @@ rust_crate_cache *\n rust_task::get_crate_cache(rust_crate const *curr_crate)\n {\n     if (cache && cache->crate != curr_crate) {\n-        dom->log(rust_log::TASK, \"switching task crate-cache to crate 0x%\"\n+        DLOG(dom, rust_log::TASK, \"switching task crate-cache to crate 0x%\"\n                  PRIxPTR, curr_crate);\n         cache->deref();\n         cache = NULL;\n     }\n \n     if (!cache) {\n-        dom->log(rust_log::TASK, \"fetching cache for current crate\");\n+        DLOG(dom, rust_log::TASK, \"fetching cache for current crate\");\n         cache = dom->get_cache(curr_crate);\n     }\n     return cache;"}, {"sha": "dd6aaeb59af5b10d64f01de4dd8caa76087aed7f", "filename": "src/rt/rust_task_list.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_task_list.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_task_list.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_list.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -7,10 +7,10 @@ rust_task_list::rust_task_list (rust_dom *dom, const char* name) :\n \n void\n rust_task_list::delete_all() {\n-    dom->log(rust_log::TASK, \"deleting all %s tasks\", name);\n+    DLOG(dom, rust_log::TASK, \"deleting all %s tasks\", name);\n     while (is_empty() == false) {\n         rust_task *task = pop_value();\n-        dom->log(rust_log::TASK, \"deleting task \" PTR, task);\n+        DLOG(dom, rust_log::TASK, \"deleting task \" PTR, task);\n         delete task;\n     }\n }"}, {"sha": "40044e03678a537d8ea15ffaa315ca1b31af171a", "filename": "src/rt/rust_timer.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_timer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_timer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_timer.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -30,7 +30,7 @@ timer_loop(void *ptr) {\n     // We were handed the rust_timer that owns us.\n     rust_timer *timer = (rust_timer *)ptr;\n     rust_dom *dom = timer->dom;\n-    dom->log(rust_log::TIMER, \"in timer 0x%\" PRIxPTR, (uintptr_t)timer);\n+    DLOG(dom, rust_log::TIMER, \"in timer 0x%\" PRIxPTR, (uintptr_t)timer);\n     size_t ms = TIME_SLICE_IN_MS;\n \n     while (!timer->exit_flag) {\n@@ -39,7 +39,7 @@ timer_loop(void *ptr) {\n #else\n         usleep(ms * 1000);\n #endif\n-        dom->log(rust_log::TIMER, \"timer 0x%\" PRIxPTR\n+        DLOG(dom, rust_log::TIMER, \"timer 0x%\" PRIxPTR\n         \" interrupting domain 0x%\" PRIxPTR, (uintptr_t) timer,\n                  (uintptr_t) dom);\n         dom->interrupt_flag = 1;\n@@ -54,7 +54,7 @@ timer_loop(void *ptr) {\n \n rust_timer::rust_timer(rust_dom *dom) :\n     dom(dom), exit_flag(0) {\n-    dom->log(rust_log::TIMER, \"creating timer for domain 0x%\" PRIxPTR, dom);\n+    DLOG(dom, rust_log::TIMER, \"creating timer for domain 0x%\" PRIxPTR, dom);\n #if defined(__WIN32__)\n     thread = CreateThread(NULL, 0, timer_loop, this, 0, NULL);\n     dom->win32_require(\"CreateThread\", thread != NULL);"}, {"sha": "6318b6e249de9948054cc48e9d9d37542970195c", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 57, "deletions": 61, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -4,23 +4,19 @@\n \n #ifdef __GNUC__\n #define LOG_UPCALL_ENTRY(task)                              \\\n-    (task)->dom->get_log().reset_indent(0);                 \\\n-    (task)->log(rust_log::UPCALL,                           \\\n-                \"> UPCALL %s - task: %s 0x%\" PRIxPTR        \\\n-                \" retpc: x%\" PRIxPTR                        \\\n-                \" ref_count: %d\",                           \\\n-                __FUNCTION__,                               \\\n-                (task)->name, (task),                       \\\n-                __builtin_return_address(0),                \\\n-                (task->ref_count));                         \\\n-    (task)->dom->get_log().indent();\n+    LOG_I(task, rust_log::UPCALL,                           \\\n+          \"> UPCALL %s - task: %s 0x%\" PRIxPTR              \\\n+          \" retpc: x%\" PRIxPTR                              \\\n+          \" ref_count: %d\",                                 \\\n+          __FUNCTION__,                                     \\\n+          (task)->name, (task),                             \\\n+          __builtin_return_address(0),                      \\\n+          (task->ref_count));\n #else\n #define LOG_UPCALL_ENTRY(task)                              \\\n-    (task)->dom->get_log().reset_indent(0);                 \\\n-    (task)->log(rust_log::UPCALL,                           \\\n-                \"> UPCALL task: %s @x%\" PRIxPTR,            \\\n-                (task)->name, (task));                      \\\n-    (task)->dom->get_log().indent();\n+    LOG_I(task, rust_log::UPCALL,                           \\\n+          \"> UPCALL task: %s @x%\" PRIxPTR,                  \\\n+          (task)->name, (task));\n #endif\n \n extern \"C\" CDECL char const *\n@@ -35,49 +31,49 @@ upcall_grow_task(rust_task *task, size_t n_frame_bytes) {\n extern \"C\" CDECL\n void upcall_log_int(rust_task *task, int32_t i) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::ULOG,\n-              \"rust: %\" PRId32 \" (0x%\" PRIx32 \")\", i, i);\n+    LOG(task, rust_log::UPCALL | rust_log::ULOG,\n+        \"rust: %\" PRId32 \" (0x%\" PRIx32 \")\", i, i);\n }\n \n extern \"C\" CDECL\n void upcall_log_float(rust_task *task, float f) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::ULOG,\n-              \"rust: %12.12f\", f);\n+    LOG(task, rust_log::UPCALL | rust_log::ULOG,\n+        \"rust: %12.12f\", f);\n }\n \n extern \"C\" CDECL\n void upcall_log_double(rust_task *task, double *f) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::ULOG,\n+    LOG(task, rust_log::UPCALL | rust_log::ULOG,\n               \"rust: %12.12f\", *f);\n }\n \n extern \"C\" CDECL void\n upcall_log_str(rust_task *task, rust_str *str) {\n     LOG_UPCALL_ENTRY(task);\n     const char *c = str_buf(task, str);\n-    task->log(rust_log::UPCALL | rust_log::ULOG, \"rust: %s\", c);\n+    LOG(task, rust_log::UPCALL | rust_log::ULOG, \"rust: %s\", c);\n }\n \n extern \"C\" CDECL void\n upcall_trace_word(rust_task *task, uintptr_t i) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::TRACE, \"trace: 0x%\" PRIxPTR \"\", i,\n+    LOG(task, rust_log::UPCALL | rust_log::TRACE, \"trace: 0x%\" PRIxPTR \"\", i,\n               i, (char) i);\n }\n \n extern \"C\" CDECL void\n upcall_trace_str(rust_task *task, char const *c) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::TRACE, \"trace: %s\", c);\n+    LOG(task, rust_log::UPCALL | rust_log::TRACE, \"trace: %s\", c);\n }\n \n extern \"C\" CDECL rust_port*\n upcall_new_port(rust_task *task, size_t unit_sz) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n+    LOG(task, rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n               \"upcall_new_port(task=0x%\" PRIxPTR \" (%s), unit_sz=%d)\",\n               (uintptr_t) task, task->name, unit_sz);\n     return new (dom) rust_port(task, unit_sz);\n@@ -86,7 +82,7 @@ upcall_new_port(rust_task *task, size_t unit_sz) {\n extern \"C\" CDECL void\n upcall_del_port(rust_task *task, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n+    LOG(task, rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n               \"upcall del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n     I(task->dom, !port->ref_count);\n     delete port;\n@@ -99,7 +95,7 @@ extern \"C\" CDECL rust_chan*\n upcall_new_chan(rust_task *task, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n+    LOG(task, rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n               \"upcall_new_chan(\"\n               \"task=0x%\" PRIxPTR \" (%s), port=0x%\" PRIxPTR \")\",\n               (uintptr_t) task, task->name, port);\n@@ -128,7 +124,7 @@ extern \"C\" CDECL\n void upcall_del_chan(rust_task *task, rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n \n-    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n+    LOG(task, rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n               \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t) chan);\n \n     A(task->dom, chan->ref_count == 0,\n@@ -179,7 +175,7 @@ upcall_clone_chan(rust_task *task, maybe_proxy<rust_task> *target,\n         rust_handle<rust_port> *handle =\n             task->dom->kernel->get_port_handle(port->as_referent());\n         maybe_proxy<rust_port> *proxy = new rust_proxy<rust_port> (handle);\n-        task->log(rust_log::MEM, \"new proxy: \" PTR, proxy);\n+        LOG(task, rust_log::MEM, \"new proxy: \" PTR, proxy);\n         port = proxy;\n         target_task = target->as_proxy()->handle()->referent();\n     }\n@@ -189,16 +185,16 @@ upcall_clone_chan(rust_task *task, maybe_proxy<rust_task> *target,\n extern \"C\" CDECL void\n upcall_yield(rust_task *task) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::COMM, \"upcall yield()\");\n+    LOG(task, rust_log::UPCALL | rust_log::COMM, \"upcall yield()\");\n     task->yield(1);\n }\n \n extern \"C\" CDECL void\n upcall_sleep(rust_task *task, size_t time_in_us) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::TASK, \"elapsed %d\",\n+    LOG(task, rust_log::UPCALL | rust_log::TASK, \"elapsed %d\",\n               task->yield_timer.get_elapsed_time());\n-    task->log(rust_log::UPCALL | rust_log::TASK, \"sleep %d us\", time_in_us);\n+    LOG(task, rust_log::UPCALL | rust_log::TASK, \"sleep %d us\", time_in_us);\n     task->yield(2, time_in_us);\n }\n \n@@ -232,13 +228,13 @@ extern \"C\" CDECL void\n upcall_send(rust_task *task, rust_chan *chan, void *sptr) {\n     LOG_UPCALL_ENTRY(task);\n     chan->send(sptr);\n-    task->log(rust_log::COMM, \"=== sent data ===>\");\n+    LOG(task, rust_log::COMM, \"=== sent data ===>\");\n }\n \n extern \"C\" CDECL void\n upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::COMM,\n+    LOG(task, rust_log::UPCALL | rust_log::COMM,\n               \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n               \", size: 0x%\" PRIxPTR \", chan_no: %d\",\n               (uintptr_t) port, (uintptr_t) dptr, port->unit_sz,\n@@ -252,7 +248,7 @@ upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n     // on the port. Remember the rendezvous location so that any sender\n     // task can write to it before waking up this task.\n \n-    task->log(rust_log::COMM, \"<=== waiting for rendezvous data ===\");\n+    LOG(task, rust_log::COMM, \"<=== waiting for rendezvous data ===\");\n     task->rendezvous_ptr = dptr;\n     task->block(port, \"waiting for rendezvous data\");\n     task->yield(3);\n@@ -264,7 +260,7 @@ upcall_fail(rust_task *task,\n             char const *file,\n             size_t line) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::ERR,\n+    LOG(task, rust_log::UPCALL | rust_log::ERR,\n               \"upcall fail '%s', %s:%\" PRIdPTR, expr, file, line);\n     task->fail(4);\n     if (getenv(\"RUST_TRAP_FAILURE\")) {\n@@ -296,7 +292,7 @@ upcall_kill(rust_task *task, maybe_proxy<rust_task> *target) {\n extern \"C\" CDECL void\n upcall_exit(rust_task *task) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::TASK,\n+    LOG(task, rust_log::UPCALL | rust_log::TASK,\n               \"task ref_count: %d\", task->ref_count);\n     A(task->dom, task->ref_count >= 0,\n       \"Task ref_count should not be negative on exit!\");\n@@ -309,12 +305,12 @@ extern \"C\" CDECL uintptr_t\n upcall_malloc(rust_task *task, size_t nbytes, type_desc *td) {\n     LOG_UPCALL_ENTRY(task);\n \n-    task->dom->log(rust_log::UPCALL|rust_log::MEM,\n+    LOG(task, rust_log::UPCALL|rust_log::MEM,\n                    \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\"\n                    \" with gc-chain head = 0x%\" PRIxPTR,\n                    nbytes, td, task->gc_alloc_chain);\n     void *p = task->malloc(nbytes, td);\n-    task->dom->log(rust_log::UPCALL|rust_log::MEM,\n+    LOG(task, rust_log::UPCALL|rust_log::MEM,\n                    \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR\n                    \") = 0x%\" PRIxPTR\n                    \" with gc-chain head = 0x%\" PRIxPTR,\n@@ -329,7 +325,7 @@ extern \"C\" CDECL void\n upcall_free(rust_task *task, void* ptr, uintptr_t is_gc) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::MEM,\n+    DLOG(dom, rust_log::UPCALL|rust_log::MEM,\n              \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n              (uintptr_t)ptr, is_gc);\n     task->free(ptr, (bool) is_gc);\n@@ -343,7 +339,7 @@ upcall_mark(rust_task *task, void* ptr) {\n     if (ptr) {\n         gc_alloc *gcm = (gc_alloc*) (((char*)ptr) - sizeof(gc_alloc));\n         uintptr_t marked = (uintptr_t) gcm->mark();\n-        dom->log(rust_log::UPCALL|rust_log::MEM|rust_log::GC,\n+        DLOG(dom, rust_log::UPCALL|rust_log::MEM|rust_log::GC,\n                  \"upcall mark(0x%\" PRIxPTR \") = %\" PRIdPTR,\n                  (uintptr_t)gcm, marked);\n         return marked;\n@@ -362,7 +358,7 @@ upcall_new_str(rust_task *task, char const *s, size_t fill) {\n         return NULL;\n     }\n     rust_str *st = new (mem) rust_str(dom, alloc, fill, (uint8_t const *) s);\n-    task->log(rust_log::UPCALL | rust_log::MEM,\n+    LOG(task, rust_log::UPCALL | rust_log::MEM,\n               \"upcall new_str('%s', %\" PRIdPTR \") = 0x%\" PRIxPTR,\n               s, fill, st);\n     return st;\n@@ -372,7 +368,7 @@ extern \"C\" CDECL rust_vec *\n upcall_new_vec(rust_task *task, size_t fill, type_desc *td) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::MEM,\n+    DLOG(dom, rust_log::UPCALL|rust_log::MEM,\n              \"upcall new_vec(%\" PRIdPTR \")\",\n              fill);\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + fill);\n@@ -382,7 +378,7 @@ upcall_new_vec(rust_task *task, size_t fill, type_desc *td) {\n         return NULL;\n     }\n     rust_vec *v = new (mem) rust_vec(dom, alloc, 0, NULL);\n-    task->log(rust_log::UPCALL | rust_log::MEM,\n+    LOG(task, rust_log::UPCALL | rust_log::MEM,\n               \"upcall new_vec(%\" PRIdPTR \") = 0x%\" PRIxPTR, fill, v);\n     return v;\n }\n@@ -396,7 +392,7 @@ upcall_vec_grow(rust_task *task,\n {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    task->log(rust_log::UPCALL | rust_log::MEM,\n+    LOG(task, rust_log::UPCALL | rust_log::MEM,\n               \"upcall vec_grow(0x%\" PRIxPTR \", %\" PRIdPTR\n               \"), alloc=%\" PRIdPTR \", fill=%\" PRIdPTR\n               \", need_copy=0x%\" PRIxPTR,\n@@ -409,12 +405,12 @@ upcall_vec_grow(rust_task *task,\n \n         // Fastest path: already large enough.\n         if (v->alloc >= alloc) {\n-            task->log(rust_log::UPCALL | rust_log::MEM, \"no-growth path\");\n+            LOG(task, rust_log::UPCALL | rust_log::MEM, \"no-growth path\");\n             return v;\n         }\n \n         // Second-fastest path: can at least realloc.\n-        task->log(rust_log::UPCALL | rust_log::MEM, \"realloc path\");\n+        LOG(task, rust_log::UPCALL | rust_log::MEM, \"realloc path\");\n         v = (rust_vec*) task->realloc(v, alloc, td->is_stateful);\n         if (!v) {\n             task->fail(4);\n@@ -436,7 +432,7 @@ upcall_vec_grow(rust_task *task,\n          * need_copy outparam flag to indicate to our caller (vec-copy glue)\n          * that we need the copies performed for us.\n          */\n-        task->log(rust_log::UPCALL | rust_log::MEM, \"new vec path\");\n+        LOG(task, rust_log::UPCALL | rust_log::MEM, \"new vec path\");\n         void *mem = task->malloc(alloc, td);\n         if (!mem) {\n             task->fail(4);\n@@ -476,23 +472,23 @@ upcall_require_rust_sym(rust_task *task,\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n \n-    task->log(rust_log::UPCALL | rust_log::CACHE,\n+    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n               \"upcall require rust sym: lib #%\" PRIdPTR\n               \" = %s, c_sym #%\" PRIdPTR\n               \", rust_sym #%\" PRIdPTR\n               \", curr_crate = 0x%\" PRIxPTR, lib_num, library, c_sym_num,\n               rust_sym_num, curr_crate);\n     for (char const **c = crate_rel(curr_crate, path); *c; ++c) {\n-        task->log(rust_log::UPCALL, \" + %s\", crate_rel(curr_crate, *c));\n+        LOG(task, rust_log::UPCALL, \" + %s\", crate_rel(curr_crate, *c));\n     }\n \n-    task->log(rust_log::UPCALL | rust_log::CACHE,\n+    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n               \"require C symbol 'rust_crate' from lib #%\" PRIdPTR, lib_num);\n     rust_crate_cache::c_sym *c =\n             fetch_c_sym(task, curr_crate, lib_num, c_sym_num, library,\n                         \"rust_crate\");\n \n-    task->log(rust_log::UPCALL | rust_log::CACHE,\n+    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n               \"require rust symbol inside crate\");\n     rust_crate_cache::rust_sym *s = task->cache->get_rust_sym(rust_sym_num,\n                                                               dom,\n@@ -501,10 +497,10 @@ upcall_require_rust_sym(rust_task *task,\n \n     uintptr_t addr = s->get_val();\n     if (addr) {\n-        task->log(rust_log::UPCALL | rust_log::CACHE,\n+        LOG(task, rust_log::UPCALL | rust_log::CACHE,\n                   \"found-or-cached addr: 0x%\" PRIxPTR, addr);\n     } else {\n-        task->log(rust_log::UPCALL | rust_log::CACHE | rust_log::ERR,\n+        LOG(task, rust_log::UPCALL | rust_log::CACHE | rust_log::ERR,\n                   \"failed to resolve symbol\");\n         task->fail(7);\n     }\n@@ -520,7 +516,7 @@ upcall_require_c_sym(rust_task *task,\n                      char const *symbol) {\n     LOG_UPCALL_ENTRY(task);\n \n-    task->log(rust_log::UPCALL | rust_log::CACHE,\n+    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n               \"upcall require c sym: lib #%\" PRIdPTR\n               \" = %s, c_sym #%\" PRIdPTR\n               \" = %s\"\n@@ -532,10 +528,10 @@ upcall_require_c_sym(rust_task *task,\n \n     uintptr_t addr = c->get_val();\n     if (addr) {\n-        task->log(rust_log::UPCALL | rust_log::CACHE,\n+        LOG(task, rust_log::UPCALL | rust_log::CACHE,\n                   \"found-or-cached addr: 0x%\" PRIxPTR, addr);\n     } else {\n-        task->log(rust_log::UPCALL | rust_log::CACHE | rust_log::ERR,\n+        LOG(task, rust_log::UPCALL | rust_log::CACHE | rust_log::ERR,\n                   \"failed to resolve symbol %s in %s\", symbol, library);\n         task->fail(6);\n     }\n@@ -550,13 +546,13 @@ upcall_get_type_desc(rust_task *task,\n                      size_t n_descs,\n                      type_desc const **descs) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::CACHE,\n+    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n               \"upcall get_type_desc with size=%\" PRIdPTR\n               \", align=%\" PRIdPTR \", %\" PRIdPTR \" descs\", size, align,\n               n_descs);\n     rust_crate_cache *cache = task->get_crate_cache(curr_crate);\n     type_desc *td = cache->get_type_desc(size, align, n_descs, descs);\n-    task->log(rust_log::UPCALL | rust_log::CACHE,\n+    LOG(task, rust_log::UPCALL | rust_log::CACHE,\n               \"returning tydesc 0x%\" PRIxPTR, td);\n     return td;\n }\n@@ -579,7 +575,7 @@ upcall_start_task(rust_task *spawner,\n     LOG_UPCALL_ENTRY(spawner);\n \n     rust_dom *dom = spawner->dom;\n-    dom->log(rust_log::UPCALL | rust_log::MEM | rust_log::TASK,\n+    DLOG(dom, rust_log::UPCALL | rust_log::MEM | rust_log::TASK,\n              \"upcall start_task(task %s @0x%\" PRIxPTR\n              \" exit_task_glue 0x%\" PRIxPTR\n              \", spawnee 0x%\" PRIxPTR\n@@ -602,7 +598,7 @@ upcall_new_thread(rust_task *task, const char *name) {\n         kernel->create_domain(parent_dom->root_crate, name);\n     rust_handle<rust_task> *child_task_handle =\n         kernel->get_task_handle(child_dom_handle->referent()->root_task);\n-    task->log(rust_log::UPCALL | rust_log::MEM,\n+    LOG(task, rust_log::UPCALL | rust_log::MEM,\n               \"child name: %s, child_dom_handle: \" PTR\n               \", child_task_handle: \" PTR,\n               name, child_dom_handle, child_task_handle);\n@@ -645,7 +641,7 @@ upcall_start_thread(rust_task *task,\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *parenet_dom = task->dom;\n     rust_handle<rust_task> *child_task_handle = child_task_proxy->handle();\n-    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::TASK,\n+    LOG(task, rust_log::UPCALL | rust_log::MEM | rust_log::TASK,\n               \"exit_task_glue: \" PTR \", spawnee_fn \" PTR\n               \", callsz %\" PRIdPTR \")\",\n               exit_task_glue, spawnee_fn, callsz);"}, {"sha": "b36b776372a5728814c9a28a07f4bd1f9f3d3daf", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/9a7576fe2cdd169313b5e25be6bf485407adb496/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=9a7576fe2cdd169313b5e25be6bf485407adb496", "patch": "@@ -24,7 +24,7 @@ ptr_vec<T>::ptr_vec(rust_dom *dom) :\n     data(new (dom) T*[alloc])\n {\n     I(dom, data);\n-    dom->log(rust_log::MEM,\n+    DLOG(dom, rust_log::MEM,\n              \"new ptr_vec(data=0x%\" PRIxPTR \") -> 0x%\" PRIxPTR,\n              (uintptr_t)data, (uintptr_t)this);\n }\n@@ -33,7 +33,7 @@ template <typename T>\n ptr_vec<T>::~ptr_vec()\n {\n     I(dom, data);\n-    dom->log(rust_log::MEM,\n+    DLOG(dom, rust_log::MEM,\n              \"~ptr_vec 0x%\" PRIxPTR \", data=0x%\" PRIxPTR,\n              (uintptr_t)this, (uintptr_t)data);\n     I(dom, fill == 0);"}]}