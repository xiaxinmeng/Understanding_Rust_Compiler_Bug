{"sha": "9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "node_id": "C_kwDOAAsO6NoAKDlhYTVjMjRiN2Q3NjNmYjk4ZDk5ODgxOTU3MTEyOGZmMmViOGEzY2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-17T17:42:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-17T17:42:51Z"}, "message": "Auto merge of #108075 - WaffleLapkin:de-arena-allocates-you-OwO, r=Nilstrieb\n\nRemove `arena_cache` modifier from `associated_item` query & copy `ty::AssocItem` instead of passing by ref\n\nr? `@ghost`", "tree": {"sha": "8cfe1d86dcc61127aa656f5202c6db2296d07804", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cfe1d86dcc61127aa656f5202c6db2296d07804"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "html_url": "https://github.com/rust-lang/rust/commit/9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f722b24eb9ea35a7cc187a1cb5c50d4d324f5855", "url": "https://api.github.com/repos/rust-lang/rust/commits/f722b24eb9ea35a7cc187a1cb5c50d4d324f5855", "html_url": "https://github.com/rust-lang/rust/commit/f722b24eb9ea35a7cc187a1cb5c50d4d324f5855"}, {"sha": "dce666b797eeba0294ffd253ff5e473bf9f0c3eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/dce666b797eeba0294ffd253ff5e473bf9f0c3eb", "html_url": "https://github.com/rust-lang/rust/commit/dce666b797eeba0294ffd253ff5e473bf9f0c3eb"}], "stats": {"total": 194, "additions": 93, "deletions": 101}, "files": [{"sha": "04396c883d3abe3b0d976a69b04898781f026196", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -537,7 +537,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n             let assoc_items = tcx.associated_items(id.owner_id);\n             check_on_unimplemented(tcx, id);\n \n-            for assoc_item in assoc_items.in_definition_order() {\n+            for &assoc_item in assoc_items.in_definition_order() {\n                 match assoc_item.kind {\n                     ty::AssocKind::Fn => {\n                         let abi = tcx.fn_sig(assoc_item.def_id).skip_binder().abi();\n@@ -670,7 +670,7 @@ pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: hir::ItemId) {\n pub(super) fn check_specialization_validity<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_def: &ty::TraitDef,\n-    trait_item: &ty::AssocItem,\n+    trait_item: ty::AssocItem,\n     impl_id: DefId,\n     impl_item: DefId,\n ) {\n@@ -767,17 +767,17 @@ fn check_impl_items_against_trait<'tcx>(\n                 ));\n             }\n             ty::AssocKind::Fn => {\n-                compare_impl_method(tcx, &ty_impl_item, &ty_trait_item, impl_trait_ref);\n+                compare_impl_method(tcx, ty_impl_item, ty_trait_item, impl_trait_ref);\n             }\n             ty::AssocKind::Type => {\n-                compare_impl_ty(tcx, &ty_impl_item, &ty_trait_item, impl_trait_ref);\n+                compare_impl_ty(tcx, ty_impl_item, ty_trait_item, impl_trait_ref);\n             }\n         }\n \n         check_specialization_validity(\n             tcx,\n             trait_def,\n-            &ty_trait_item,\n+            ty_trait_item,\n             impl_id.to_def_id(),\n             impl_item,\n         );"}, {"sha": "a07a46da21fb72384051c9f28323f815e58b36cb", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -37,8 +37,8 @@ use std::iter;\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n pub(super) fn compare_impl_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\", impl_trait_ref);\n@@ -129,8 +129,8 @@ pub(super) fn compare_impl_method<'tcx>(\n #[instrument(level = \"debug\", skip(tcx, impl_trait_ref))]\n fn compare_method_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     check_implied_wf: CheckImpliedWfMode,\n ) -> Result<(), ErrorGuaranteed> {\n@@ -381,8 +381,8 @@ fn compare_method_predicate_entailment<'tcx>(\n fn extract_bad_args_for_implies_lint<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     errors: &[infer::RegionResolutionError<'tcx>],\n-    (trait_m, trait_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n-    (impl_m, impl_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    (trait_m, trait_sig): (ty::AssocItem, ty::FnSig<'tcx>),\n+    (impl_m, impl_sig): (ty::AssocItem, ty::FnSig<'tcx>),\n     hir_id: hir::HirId,\n ) -> Vec<(Span, Option<String>)> {\n     let mut blame_generics = vec![];\n@@ -476,7 +476,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for RemapLateBound<'_, 'tcx> {\n \n fn emit_implied_wf_lint<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n     hir_id: hir::HirId,\n     bad_args: Vec<(Span, Option<String>)>,\n ) {\n@@ -523,8 +523,8 @@ enum CheckImpliedWfMode {\n \n fn compare_asyncness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n ) -> Result<(), ErrorGuaranteed> {\n     if tcx.asyncness(trait_m.def_id) == hir::IsAsync::Async {\n         match tcx.fn_sig(impl_m.def_id).skip_binder().skip_binder().output().kind() {\n@@ -869,8 +869,8 @@ fn report_trait_method_mismatch<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     mut cause: ObligationCause<'tcx>,\n     terr: TypeError<'tcx>,\n-    (trait_m, trait_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n-    (impl_m, impl_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    (trait_m, trait_sig): (ty::AssocItem, ty::FnSig<'tcx>),\n+    (impl_m, impl_sig): (ty::AssocItem, ty::FnSig<'tcx>),\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> ErrorGuaranteed {\n     let tcx = infcx.tcx;\n@@ -963,8 +963,8 @@ fn report_trait_method_mismatch<'tcx>(\n \n fn check_region_bounds_on_impl_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n     delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_generics = tcx.generics_of(impl_m.def_id);\n@@ -1038,7 +1038,7 @@ fn check_region_bounds_on_impl_item<'tcx>(\n             .sess\n             .create_err(LifetimesOrBoundsMismatchOnTrait {\n                 span,\n-                item_kind: assoc_item_kind_str(impl_m),\n+                item_kind: assoc_item_kind_str(&impl_m),\n                 ident: impl_m.ident(tcx),\n                 generics_span,\n                 bounds_span,\n@@ -1056,8 +1056,8 @@ fn extract_spans_for_error_reporting<'tcx>(\n     infcx: &infer::InferCtxt<'tcx>,\n     terr: TypeError<'_>,\n     cause: &ObligationCause<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n     let mut impl_args = {\n@@ -1080,8 +1080,8 @@ fn extract_spans_for_error_reporting<'tcx>(\n \n fn compare_self_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     // Try to give more informative error messages about self typing\n@@ -1092,7 +1092,7 @@ fn compare_self_type<'tcx>(\n     // inscrutable, particularly for cases where one method has no\n     // self.\n \n-    let self_string = |method: &ty::AssocItem| {\n+    let self_string = |method: ty::AssocItem| {\n         let untransformed_self_ty = match method.container {\n             ty::ImplContainer => impl_trait_ref.self_ty(),\n             ty::TraitContainer => tcx.types.self_param,\n@@ -1182,8 +1182,8 @@ fn compare_self_type<'tcx>(\n /// [`compare_generic_param_kinds`]. This function also does not handle lifetime parameters\n fn compare_number_of_generics<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_: &ty::AssocItem,\n-    trait_: &ty::AssocItem,\n+    impl_: ty::AssocItem,\n+    trait_: ty::AssocItem,\n     delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_own_counts = tcx.generics_of(trait_.def_id).own_counts();\n@@ -1203,7 +1203,7 @@ fn compare_number_of_generics<'tcx>(\n         (\"const\", trait_own_counts.consts, impl_own_counts.consts),\n     ];\n \n-    let item_kind = assoc_item_kind_str(impl_);\n+    let item_kind = assoc_item_kind_str(&impl_);\n \n     let mut err_occurred = None;\n     for (kind, trait_count, impl_count) in matchings {\n@@ -1325,8 +1325,8 @@ fn compare_number_of_generics<'tcx>(\n \n fn compare_number_of_method_arguments<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n@@ -1405,8 +1405,8 @@ fn compare_number_of_method_arguments<'tcx>(\n \n fn compare_synthetic_generics<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n ) -> Result<(), ErrorGuaranteed> {\n     // FIXME(chrisvittal) Clean up this function, list of FIXME items:\n     //     1. Better messages for the span labels\n@@ -1559,8 +1559,8 @@ fn compare_synthetic_generics<'tcx>(\n /// This function does not handle lifetime parameters\n fn compare_generic_param_kinds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_item: &ty::AssocItem,\n-    trait_item: &ty::AssocItem,\n+    impl_item: ty::AssocItem,\n+    trait_item: ty::AssocItem,\n     delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     assert_eq!(impl_item.kind, trait_item.kind);\n@@ -1736,8 +1736,8 @@ pub(super) fn compare_impl_const_raw(\n \n pub(super) fn compare_impl_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_ty: &ty::AssocItem,\n-    trait_ty: &ty::AssocItem,\n+    impl_ty: ty::AssocItem,\n+    trait_ty: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) {\n     debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n@@ -1754,8 +1754,8 @@ pub(super) fn compare_impl_ty<'tcx>(\n /// instead of associated functions.\n fn compare_type_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_ty: &ty::AssocItem,\n-    trait_ty: &ty::AssocItem,\n+    impl_ty: ty::AssocItem,\n+    trait_ty: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_substs = InternalSubsts::identity_for_item(tcx, impl_ty.def_id);\n@@ -1855,8 +1855,8 @@ fn compare_type_predicate_entailment<'tcx>(\n #[instrument(level = \"debug\", skip(tcx))]\n pub(super) fn check_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    trait_ty: &ty::AssocItem,\n-    impl_ty: &ty::AssocItem,\n+    trait_ty: ty::AssocItem,\n+    impl_ty: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     // Given"}, {"sha": "9acfc1b3d2924a0ec73177566de58d0f8355bb78", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -199,7 +199,7 @@ fn report_forbidden_specialization(tcx: TyCtxt<'_>, impl_item: DefId, parent_imp\n fn missing_items_err(\n     tcx: TyCtxt<'_>,\n     impl_span: Span,\n-    missing_items: &[&ty::AssocItem],\n+    missing_items: &[ty::AssocItem],\n     full_impl_span: Span,\n ) {\n     let missing_items_msg = missing_items\n@@ -225,7 +225,7 @@ fn missing_items_err(\n     let padding =\n         tcx.sess.source_map().indentation_before(sugg_sp).unwrap_or_else(|| String::new());\n \n-    for trait_item in missing_items {\n+    for &trait_item in missing_items {\n         let snippet = suggestion_signature(trait_item, tcx);\n         let code = format!(\"{}{}\\n{}\", padding, snippet, padding);\n         let msg = format!(\"implement the missing item: `{snippet}`\");\n@@ -272,7 +272,7 @@ fn default_body_is_unstable(\n     reason: Option<Symbol>,\n     issue: Option<NonZeroU32>,\n ) {\n-    let missing_item_name = &tcx.associated_item(item_did).name;\n+    let missing_item_name = tcx.associated_item(item_did).name;\n     let use_of_unstable_library_feature_note = match reason {\n         Some(r) => format!(\"use of unstable library feature '{feature}': {r}\"),\n         None => format!(\"use of unstable library feature '{feature}'\"),\n@@ -365,7 +365,7 @@ fn fn_sig_suggestion<'tcx>(\n     sig: ty::FnSig<'tcx>,\n     ident: Ident,\n     predicates: ty::GenericPredicates<'tcx>,\n-    assoc: &ty::AssocItem,\n+    assoc: ty::AssocItem,\n ) -> String {\n     let args = sig\n         .inputs()\n@@ -433,7 +433,7 @@ pub fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n /// Return placeholder code for the given associated item.\n /// Similar to `ty::AssocItem::suggestion`, but appropriate for use as the code snippet of a\n /// structured suggestion.\n-fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n+fn suggestion_signature(assoc: ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n     match assoc.kind {\n         ty::AssocKind::Fn => {\n             // We skip the binder here because the binder would deanonymize all"}, {"sha": "66c3904af963b2a5085bcc1c3b014896d9822257", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -1180,7 +1180,7 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n ///\n /// Assuming the defaults are used, check that all predicates (bounds on the\n /// assoc type and where clauses on the trait) hold.\n-fn check_associated_type_bounds(wfcx: &WfCheckingCtxt<'_, '_>, item: &ty::AssocItem, span: Span) {\n+fn check_associated_type_bounds(wfcx: &WfCheckingCtxt<'_, '_>, item: ty::AssocItem, span: Span) {\n     let bounds = wfcx.tcx().explicit_item_bounds(item.def_id);\n \n     debug!(\"check_associated_type_bounds: bounds={:?}\", bounds);\n@@ -1630,7 +1630,7 @@ const HELP_FOR_SELF_TYPE: &str = \"consider changing to `self`, `&self`, `&mut se\n fn check_method_receiver<'tcx>(\n     wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     fn_sig: &hir::FnSig<'_>,\n-    method: &ty::AssocItem,\n+    method: ty::AssocItem,\n     self_ty: Ty<'tcx>,\n ) {\n     let tcx = wfcx.tcx();"}, {"sha": "7bca4edcc8c966de563be77d65cdff5a4d690056", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -27,8 +27,8 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n     /// namespace.\n     fn impls_have_common_items(\n         &self,\n-        impl_items1: &ty::AssocItems<'_>,\n-        impl_items2: &ty::AssocItems<'_>,\n+        impl_items1: &ty::AssocItems,\n+        impl_items2: &ty::AssocItems,\n     ) -> bool {\n         let mut impl_items1 = &impl_items1;\n         let mut impl_items2 = &impl_items2;\n@@ -38,10 +38,10 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n             std::mem::swap(&mut impl_items1, &mut impl_items2);\n         }\n \n-        for item1 in impl_items1.in_definition_order() {\n+        for &item1 in impl_items1.in_definition_order() {\n             let collision = impl_items2\n                 .filter_by_name_unhygienic(item1.name)\n-                .any(|item2| self.compare_hygienically(item1, item2));\n+                .any(|&item2| self.compare_hygienically(item1, item2));\n \n             if collision {\n                 return true;\n@@ -51,7 +51,7 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n         false\n     }\n \n-    fn compare_hygienically(&self, item1: &ty::AssocItem, item2: &ty::AssocItem) -> bool {\n+    fn compare_hygienically(&self, item1: ty::AssocItem, item2: ty::AssocItem) -> bool {\n         // Symbols and namespace match, compare hygienically.\n         item1.kind.namespace() == item2.kind.namespace()\n             && item1.ident(self.tcx).normalize_to_macros_2_0()\n@@ -98,10 +98,10 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n         let impl_items1 = self.tcx.associated_items(impl1);\n         let impl_items2 = self.tcx.associated_items(impl2);\n \n-        for item1 in impl_items1.in_definition_order() {\n+        for &item1 in impl_items1.in_definition_order() {\n             let collision = impl_items2\n                 .filter_by_name_unhygienic(item1.name)\n-                .find(|item2| self.compare_hygienically(item1, item2));\n+                .find(|&&item2| self.compare_hygienically(item1, item2));\n \n             if let Some(item2) = collision {\n                 let name = item1.ident(self.tcx).normalize_to_macros_2_0();"}, {"sha": "560ffc620e0ded46e4a26e49806cae39bd27efc0", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n \n     fn get_unbound_associated_types(&self) -> Vec<String> {\n         if self.tcx.is_trait(self.def_id) {\n-            let items: &AssocItems<'_> = self.tcx.associated_items(self.def_id);\n+            let items: &AssocItems = self.tcx.associated_items(self.def_id);\n             items\n                 .in_definition_order()\n                 .filter(|item| item.kind == AssocKind::Type)"}, {"sha": "0b9226802cf5ea97df342e09fbd00bb8ceca7e10", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -735,7 +735,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             debug!(\"impl_ty: {:?}\", impl_ty);\n \n             // Determine the receiver type that the method itself expects.\n-            let (xform_self_ty, xform_ret_ty) = self.xform_self_ty(&item, impl_ty, impl_substs);\n+            let (xform_self_ty, xform_ret_ty) = self.xform_self_ty(item, impl_ty, impl_substs);\n             debug!(\"xform_self_ty: {:?}, xform_ret_ty: {:?}\", xform_self_ty, xform_ret_ty);\n \n             // We can't use normalize_associated_types_in as it will pollute the\n@@ -796,7 +796,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             let new_trait_ref = this.erase_late_bound_regions(new_trait_ref);\n \n             let (xform_self_ty, xform_ret_ty) =\n-                this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n+                this.xform_self_ty(item, new_trait_ref.self_ty(), new_trait_ref.substs);\n             this.push_candidate(\n                 Candidate {\n                     xform_self_ty,\n@@ -846,7 +846,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             let trait_ref = this.erase_late_bound_regions(poly_trait_ref);\n \n             let (xform_self_ty, xform_ret_ty) =\n-                this.xform_self_ty(&item, trait_ref.self_ty(), trait_ref.substs);\n+                this.xform_self_ty(item, trait_ref.self_ty(), trait_ref.substs);\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n@@ -917,7 +917,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     fn matches_return_type(\n         &self,\n-        method: &ty::AssocItem,\n+        method: ty::AssocItem,\n         self_ty: Option<Ty<'tcx>>,\n         expected: Ty<'tcx>,\n     ) -> bool {\n@@ -966,11 +966,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     } else {\n                         let new_trait_ref = self.erase_late_bound_regions(bound_trait_ref);\n \n-                        let (xform_self_ty, xform_ret_ty) = self.xform_self_ty(\n-                            &item,\n-                            new_trait_ref.self_ty(),\n-                            new_trait_ref.substs,\n-                        );\n+                        let (xform_self_ty, xform_ret_ty) =\n+                            self.xform_self_ty(item, new_trait_ref.self_ty(), new_trait_ref.substs);\n                         self.push_candidate(\n                             Candidate {\n                                 xform_self_ty,\n@@ -998,7 +995,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 }\n \n                 let (xform_self_ty, xform_ret_ty) =\n-                    self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n+                    self.xform_self_ty(item, trait_ref.self_ty(), trait_substs);\n                 self.push_candidate(\n                     Candidate {\n                         xform_self_ty,\n@@ -1025,7 +1022,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             .filter(|candidate| candidate_filter(&candidate.item))\n             .filter(|candidate| {\n                 if let Some(return_ty) = self.return_type {\n-                    self.matches_return_type(&candidate.item, None, return_ty)\n+                    self.matches_return_type(candidate.item, None, return_ty)\n                 } else {\n                     true\n                 }\n@@ -1884,7 +1881,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn xform_self_ty(\n         &self,\n-        item: &ty::AssocItem,\n+        item: ty::AssocItem,\n         impl_ty: Ty<'tcx>,\n         substs: SubstsRef<'tcx>,\n     ) -> (Ty<'tcx>, Option<Ty<'tcx>>) {"}, {"sha": "b33729d0be5c9a509020f7f4affe067675bb59ea", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -326,7 +326,7 @@ impl<T> Trait<T> for X {\n                         diag,\n                         &trait_ref,\n                         pred.bounds,\n-                        &assoc,\n+                        assoc,\n                         assoc_substs,\n                         ty,\n                         msg,\n@@ -624,7 +624,7 @@ fn foo(&self) -> Self::T { String::new() }\n         diag: &mut Diagnostic,\n         trait_ref: &ty::TraitRef<'tcx>,\n         bounds: hir::GenericBounds<'_>,\n-        assoc: &ty::AssocItem,\n+        assoc: ty::AssocItem,\n         assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,\n@@ -667,7 +667,7 @@ fn foo(&self) -> Self::T { String::new() }\n         &self,\n         diag: &mut Diagnostic,\n         span: Span,\n-        assoc: &ty::AssocItem,\n+        assoc: ty::AssocItem,\n         assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,"}, {"sha": "cf4d9b4b005790191a57c8c98ae2a9acff9fdbbc", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -729,15 +729,14 @@ rustc_queries! {\n     }\n \n     /// Maps from a trait item to the trait item \"descriptor\".\n-    query associated_item(key: DefId) -> &'tcx ty::AssocItem {\n+    query associated_item(key: DefId) -> ty::AssocItem {\n         desc { |tcx| \"computing associated item data for `{}`\", tcx.def_path_str(key) }\n-        arena_cache\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n \n     /// Collects the associated items defined on a trait or impl.\n-    query associated_items(key: DefId) -> &'tcx ty::AssocItems<'tcx> {\n+    query associated_items(key: DefId) -> &'tcx ty::AssocItems {\n         arena_cache\n         desc { |tcx| \"collecting associated items of `{}`\", tcx.def_path_str(key) }\n     }"}, {"sha": "4019cf8ceee646f79e7d0f528946c7aa900e0b8b", "filename": "compiler/rustc_middle/src/traits/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -133,11 +133,7 @@ impl Node {\n     ///\n     /// If this returns `None`, the item can potentially still be found in\n     /// parents of this node.\n-    pub fn item<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_item_def_id: DefId,\n-    ) -> Option<&'tcx ty::AssocItem> {\n+    pub fn item<'tcx>(&self, tcx: TyCtxt<'tcx>, trait_item_def_id: DefId) -> Option<ty::AssocItem> {\n         match *self {\n             Node::Trait(_) => Some(tcx.associated_item(trait_item_def_id)),\n             Node::Impl(impl_def_id) => {\n@@ -239,7 +235,7 @@ impl<'tcx> Ancestors<'tcx> {\n                     }\n                 }\n \n-                Some(LeafDef { item: *item, defining_node: node, finalizing_node })\n+                Some(LeafDef { item, defining_node: node, finalizing_node })\n             } else {\n                 // Item not mentioned. This \"finalizes\" any defaulted item provided by an ancestor.\n                 finalizing_node = Some(node);"}, {"sha": "f1a9e50a4f05fc98e11171ed82dc2e52c3c798d3", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -129,13 +129,13 @@ impl std::fmt::Display for AssocKind {\n /// it is relatively expensive. Instead, items are indexed by `Symbol` and hygienic comparison is\n /// done only on items with the same name.\n #[derive(Debug, Clone, PartialEq, HashStable)]\n-pub struct AssocItems<'tcx> {\n-    items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n+pub struct AssocItems {\n+    items: SortedIndexMultiMap<u32, Symbol, ty::AssocItem>,\n }\n \n-impl<'tcx> AssocItems<'tcx> {\n+impl AssocItems {\n     /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n-    pub fn new(items_in_def_order: impl IntoIterator<Item = &'tcx ty::AssocItem>) -> Self {\n+    pub fn new(items_in_def_order: impl IntoIterator<Item = ty::AssocItem>) -> Self {\n         let items = items_in_def_order.into_iter().map(|item| (item.name, item)).collect();\n         AssocItems { items }\n     }\n@@ -145,7 +145,7 @@ impl<'tcx> AssocItems<'tcx> {\n     /// New code should avoid relying on definition order. If you need a particular associated item\n     /// for a known trait, make that trait a lang item instead of indexing this array.\n     pub fn in_definition_order(&self) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n-        self.items.iter().map(|(_, v)| *v)\n+        self.items.iter().map(|(_, v)| v)\n     }\n \n     pub fn len(&self) -> usize {\n@@ -157,7 +157,7 @@ impl<'tcx> AssocItems<'tcx> {\n         &self,\n         name: Symbol,\n     ) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n-        self.items.get_by_key(name).copied()\n+        self.items.get_by_key(name)\n     }\n \n     /// Returns the associated item with the given name and `AssocKind`, if one exists."}, {"sha": "d183a1a3fb018c8984e187049c66e394c69ee00d", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -2206,7 +2206,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         Some(Ident::new(def, span))\n     }\n \n-    pub fn opt_associated_item(self, def_id: DefId) -> Option<&'tcx AssocItem> {\n+    pub fn opt_associated_item(self, def_id: DefId) -> Option<AssocItem> {\n         if let DefKind::AssocConst | DefKind::AssocFn | DefKind::AssocTy = self.def_kind(def_id) {\n             Some(self.associated_item(def_id))\n         } else {"}, {"sha": "df1aeed941d7c76f480a488ceaf8e369a54efb2d", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -97,7 +97,7 @@ fn check_is_object_safe(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {\n /// object. Note that object-safe traits can have some\n /// non-vtable-safe methods, so long as they require `Self: Sized` or\n /// otherwise ensure that they cannot be used when `Self = Trait`.\n-pub fn is_vtable_safe_method(tcx: TyCtxt<'_>, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n+pub fn is_vtable_safe_method(tcx: TyCtxt<'_>, trait_def_id: DefId, method: ty::AssocItem) -> bool {\n     debug_assert!(tcx.generics_of(trait_def_id).has_self);\n     debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n     // Any method that has a `Self: Sized` bound cannot be called.\n@@ -120,8 +120,8 @@ fn object_safety_violations_for_trait(\n         .associated_items(trait_def_id)\n         .in_definition_order()\n         .filter(|item| item.kind == ty::AssocKind::Fn)\n-        .filter_map(|item| {\n-            object_safety_violation_for_method(tcx, trait_def_id, &item)\n+        .filter_map(|&item| {\n+            object_safety_violation_for_method(tcx, trait_def_id, item)\n                 .map(|(code, span)| ObjectSafetyViolation::Method(item.name, code, span))\n         })\n         .collect();\n@@ -387,7 +387,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n fn object_safety_violation_for_method(\n     tcx: TyCtxt<'_>,\n     trait_def_id: DefId,\n-    method: &ty::AssocItem,\n+    method: ty::AssocItem,\n ) -> Option<(MethodViolationCode, Span)> {\n     debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n     // Any method that has a `Self : Sized` requisite is otherwise\n@@ -420,7 +420,7 @@ fn object_safety_violation_for_method(\n fn virtual_call_violation_for_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,\n-    method: &ty::AssocItem,\n+    method: ty::AssocItem,\n ) -> Option<MethodViolationCode> {\n     let sig = tcx.fn_sig(method.def_id).subst_identity();\n \n@@ -722,7 +722,7 @@ fn object_ty_for_trait<'tcx>(\n #[allow(dead_code)]\n fn receiver_is_dispatchable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    method: &ty::AssocItem,\n+    method: ty::AssocItem,\n     receiver_ty: Ty<'tcx>,\n ) -> bool {\n     debug!(\"receiver_is_dispatchable: method = {:?}, receiver_ty = {:?}\", method, receiver_ty);"}, {"sha": "c2388f9fa1bb711557123056ce490c44e844a5a2", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -2149,7 +2149,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     } else {\n         ty.map_bound(|ty| ty.into())\n     };\n-    if !check_substs_compatible(tcx, &assoc_ty.item, substs) {\n+    if !check_substs_compatible(tcx, assoc_ty.item, substs) {\n         let err = tcx.ty_error_with_message(\n             obligation.cause.span,\n             \"impl item and trait item have different parameters\",\n@@ -2164,7 +2164,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n // Verify that the trait item and its implementation have compatible substs lists\n fn check_substs_compatible<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    assoc_item: &ty::AssocItem,\n+    assoc_item: ty::AssocItem,\n     substs: ty::SubstsRef<'tcx>,\n ) -> bool {\n     fn check_substs_compatible_inner<'tcx>(\n@@ -2238,7 +2238,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         leaf_def.defining_node,\n     );\n \n-    if !check_substs_compatible(tcx, &leaf_def.item, impl_fn_substs) {\n+    if !check_substs_compatible(tcx, leaf_def.item, impl_fn_substs) {\n         let err = tcx.ty_error_with_message(\n             obligation.cause.span,\n             \"impl method and trait method have different parameters\","}, {"sha": "2e4a5cfe4bcf94c691aa029f87ddacdf051fd006", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -399,7 +399,7 @@ pub(crate) fn assoc_def(\n     // If there is no such item in that impl, this function will fail with a\n     // cycle error if the specialization graph is currently being built.\n     if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_def_id) {\n-        let &item = tcx.associated_item(impl_item_id);\n+        let item = tcx.associated_item(impl_item_id);\n         let impl_node = Node::Impl(impl_def_id);\n         return Ok(LeafDef {\n             item,"}, {"sha": "9f5c5bbeac8de2c3c89e29f75805e1ded65e8c87", "filename": "compiler/rustc_trait_selection/src/traits/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -197,12 +197,12 @@ fn own_existential_vtable_entries(tcx: TyCtxt<'_>, trait_def_id: DefId) -> &[Def\n         .in_definition_order()\n         .filter(|item| item.kind == ty::AssocKind::Fn);\n     // Now list each method's DefId (for within its trait).\n-    let own_entries = trait_methods.filter_map(move |trait_method| {\n+    let own_entries = trait_methods.filter_map(move |&trait_method| {\n         debug!(\"own_existential_vtable_entry: trait_method={:?}\", trait_method);\n         let def_id = trait_method.def_id;\n \n         // Some methods cannot be called on an object; skip those.\n-        if !is_vtable_safe_method(tcx, trait_def_id, &trait_method) {\n+        if !is_vtable_safe_method(tcx, trait_def_id, trait_method) {\n             debug!(\"own_existential_vtable_entry: not vtable safe\");\n             return None;\n         }"}, {"sha": "164cac6a010facdb2933bd0468d1332be017606f", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -26,7 +26,7 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     }\n }\n \n-fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems<'_> {\n+fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems {\n     if tcx.is_trait_alias(def_id) {\n         ty::AssocItems::new(Vec::new())\n     } else {"}, {"sha": "d2c6e7ab024998169528a3cf19dbc624bb1cbaa7", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aa5c24b7d763fb98d998819571128ff2eb8a3ca/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9aa5c24b7d763fb98d998819571128ff2eb8a3ca", "patch": "@@ -689,12 +689,12 @@ fn resolve_associated_trait_item<'a>(\n             .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n             .map(|trait_assoc| {\n                 trait_assoc_to_impl_assoc_item(cx.tcx, impl_, trait_assoc.def_id)\n-                    .unwrap_or(trait_assoc)\n+                    .unwrap_or(*trait_assoc)\n             })\n     });\n     // FIXME(#74563): warn about ambiguity\n     debug!(\"the candidates were {:?}\", candidates.clone().collect::<Vec<_>>());\n-    candidates.next().copied()\n+    candidates.next()\n }\n \n /// Find the associated item in the impl `impl_id` that corresponds to the\n@@ -711,7 +711,7 @@ fn trait_assoc_to_impl_assoc_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_id: DefId,\n     trait_assoc_id: DefId,\n-) -> Option<&'tcx ty::AssocItem> {\n+) -> Option<ty::AssocItem> {\n     let trait_to_impl_assoc_map = tcx.impl_item_implementor_ids(impl_id);\n     debug!(?trait_to_impl_assoc_map);\n     let impl_assoc_id = *trait_to_impl_assoc_map.get(&trait_assoc_id)?;"}]}