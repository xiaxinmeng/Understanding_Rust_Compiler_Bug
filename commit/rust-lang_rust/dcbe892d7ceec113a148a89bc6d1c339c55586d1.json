{"sha": "dcbe892d7ceec113a148a89bc6d1c339c55586d1", "node_id": "C_kwDOAAsO6NoAKGRjYmU4OTJkN2NlZWMxMTNhMTQ4YTg5YmM2ZDFjMzM5YzU1NTg2ZDE", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-08-15T11:51:45Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-08-15T11:51:45Z"}, "message": "Add an HIR pretty-printer", "tree": {"sha": "169bf7338d8f654a4fdf029ca44877979f202984", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/169bf7338d8f654a4fdf029ca44877979f202984"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcbe892d7ceec113a148a89bc6d1c339c55586d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcbe892d7ceec113a148a89bc6d1c339c55586d1", "html_url": "https://github.com/rust-lang/rust/commit/dcbe892d7ceec113a148a89bc6d1c339c55586d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcbe892d7ceec113a148a89bc6d1c339c55586d1/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6d59f2bb4fae0ba4f74e2c967b5e2f777f8c860", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6d59f2bb4fae0ba4f74e2c967b5e2f777f8c860", "html_url": "https://github.com/rust-lang/rust/commit/b6d59f2bb4fae0ba4f74e2c967b5e2f777f8c860"}], "stats": {"total": 1117, "additions": 914, "deletions": 203}, "files": [{"sha": "1d818d96267c177223985d6588e138556227e9c2", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -4,6 +4,7 @@ mod lower;\n #[cfg(test)]\n mod tests;\n pub mod scope;\n+mod pretty;\n \n use std::{ops::Index, sync::Arc};\n \n@@ -352,6 +353,10 @@ impl Body {\n         }\n     }\n \n+    pub fn pretty_print(&self, db: &dyn DefDatabase, owner: DefWithBodyId) -> String {\n+        pretty::print_body_hir(db, self, owner)\n+    }\n+\n     fn new(\n         db: &dyn DefDatabase,\n         expander: Expander,"}, {"sha": "ddd476efe5c4d764dabd4ff597e732d902fb3dec", "filename": "crates/hir-def/src/body/pretty.rs", "status": "added", "additions": 621, "deletions": 0, "changes": 621, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -0,0 +1,621 @@\n+//! A pretty-printer for HIR.\n+\n+use std::fmt::{self, Write};\n+\n+use crate::{\n+    expr::{Array, BindingAnnotation, Literal, Statement},\n+    pretty::{print_generic_args, print_path, print_type_ref},\n+    type_ref::TypeRef,\n+};\n+\n+use super::*;\n+\n+pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBodyId) -> String {\n+    let needs_semi;\n+    let header = match owner {\n+        DefWithBodyId::FunctionId(it) => {\n+            needs_semi = false;\n+            let item_tree_id = it.lookup(db).id;\n+            format!(\"fn {}(\u2026) \", item_tree_id.item_tree(db)[item_tree_id.value].name)\n+        }\n+        DefWithBodyId::StaticId(it) => {\n+            needs_semi = true;\n+            let item_tree_id = it.lookup(db).id;\n+            format!(\"static {} = \", item_tree_id.item_tree(db)[item_tree_id.value].name)\n+        }\n+        DefWithBodyId::ConstId(it) => {\n+            needs_semi = true;\n+            let item_tree_id = it.lookup(db).id;\n+            let name = match &item_tree_id.item_tree(db)[item_tree_id.value].name {\n+                Some(name) => name.to_string(),\n+                None => \"_\".to_string(),\n+            };\n+            format!(\"const {} = \", name)\n+        }\n+    };\n+\n+    let mut p = Printer { body, buf: header, indent_level: 0, needs_indent: false };\n+    p.print_expr(body.body_expr);\n+    if needs_semi {\n+        p.buf.push(';');\n+    }\n+    p.buf\n+}\n+\n+macro_rules! w {\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = write!($dst, $($arg)*); }\n+    };\n+}\n+\n+macro_rules! wln {\n+    ($dst:expr) => {\n+        { let _ = writeln!($dst); }\n+    };\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = writeln!($dst, $($arg)*); }\n+    };\n+}\n+\n+struct Printer<'a> {\n+    body: &'a Body,\n+    buf: String,\n+    indent_level: usize,\n+    needs_indent: bool,\n+}\n+\n+impl<'a> Write for Printer<'a> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        for line in s.split_inclusive('\\n') {\n+            if self.needs_indent {\n+                match self.buf.chars().rev().skip_while(|ch| *ch == ' ').next() {\n+                    Some('\\n') | None => {}\n+                    _ => self.buf.push('\\n'),\n+                }\n+                self.buf.push_str(&\"    \".repeat(self.indent_level));\n+                self.needs_indent = false;\n+            }\n+\n+            self.buf.push_str(line);\n+            self.needs_indent = line.ends_with('\\n');\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<'a> Printer<'a> {\n+    fn indented(&mut self, f: impl FnOnce(&mut Self)) {\n+        self.indent_level += 1;\n+        wln!(self);\n+        f(self);\n+        self.indent_level -= 1;\n+        self.buf = self.buf.trim_end_matches('\\n').to_string();\n+    }\n+\n+    fn whitespace(&mut self) {\n+        match self.buf.chars().next_back() {\n+            None | Some('\\n' | ' ') => {}\n+            _ => self.buf.push(' '),\n+        }\n+    }\n+\n+    fn newline(&mut self) {\n+        match self.buf.chars().rev().skip_while(|ch| *ch == ' ').next() {\n+            Some('\\n') | None => {}\n+            _ => writeln!(self).unwrap(),\n+        }\n+    }\n+\n+    fn print_expr(&mut self, expr: ExprId) {\n+        let expr = &self.body[expr];\n+\n+        match expr {\n+            Expr::Missing => w!(self, \"\ufffd\"),\n+            Expr::Underscore => w!(self, \"_\"),\n+            Expr::Path(path) => self.print_path(path),\n+            Expr::If { condition, then_branch, else_branch } => {\n+                w!(self, \"if \");\n+                self.print_expr(*condition);\n+                w!(self, \" \");\n+                self.print_expr(*then_branch);\n+                if let Some(els) = *else_branch {\n+                    w!(self, \" else \");\n+                    self.print_expr(els);\n+                }\n+            }\n+            Expr::Let { pat, expr } => {\n+                w!(self, \"let \");\n+                self.print_pat(*pat);\n+                w!(self, \" = \");\n+                self.print_expr(*expr);\n+            }\n+            Expr::Loop { body, label } => {\n+                if let Some(lbl) = label {\n+                    w!(self, \"{}: \", self.body[*lbl].name);\n+                }\n+                w!(self, \"loop \");\n+                self.print_expr(*body);\n+            }\n+            Expr::While { condition, body, label } => {\n+                if let Some(lbl) = label {\n+                    w!(self, \"{}: \", self.body[*lbl].name);\n+                }\n+                w!(self, \"while \");\n+                self.print_expr(*condition);\n+                self.print_expr(*body);\n+            }\n+            Expr::For { iterable, pat, body, label } => {\n+                if let Some(lbl) = label {\n+                    w!(self, \"{}: \", self.body[*lbl].name);\n+                }\n+                w!(self, \"for \");\n+                self.print_pat(*pat);\n+                w!(self, \" in \");\n+                self.print_expr(*iterable);\n+                self.print_expr(*body);\n+            }\n+            Expr::Call { callee, args, is_assignee_expr: _ } => {\n+                self.print_expr(*callee);\n+                w!(self, \"(\");\n+                if !args.is_empty() {\n+                    self.indented(|p| {\n+                        for arg in &**args {\n+                            p.print_expr(*arg);\n+                            wln!(p, \",\");\n+                        }\n+                    });\n+                }\n+                w!(self, \")\");\n+            }\n+            Expr::MethodCall { receiver, method_name, args, generic_args } => {\n+                self.print_expr(*receiver);\n+                w!(self, \".{}\", method_name);\n+                if let Some(args) = generic_args {\n+                    w!(self, \"::<\");\n+                    print_generic_args(args, self).unwrap();\n+                    w!(self, \">\");\n+                }\n+                w!(self, \"(\");\n+                if !args.is_empty() {\n+                    self.indented(|p| {\n+                        for arg in &**args {\n+                            p.print_expr(*arg);\n+                            wln!(p, \",\");\n+                        }\n+                    });\n+                }\n+                w!(self, \")\");\n+            }\n+            Expr::Match { expr, arms } => {\n+                w!(self, \"match \");\n+                self.print_expr(*expr);\n+                w!(self, \" {{\");\n+                self.indented(|p| {\n+                    for arm in &**arms {\n+                        p.print_pat(arm.pat);\n+                        if let Some(guard) = arm.guard {\n+                            w!(p, \" if \");\n+                            p.print_expr(guard);\n+                        }\n+                        w!(p, \" => \");\n+                        p.print_expr(arm.expr);\n+                        wln!(p, \",\");\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            Expr::Continue { label } => {\n+                w!(self, \"continue\");\n+                if let Some(label) = label {\n+                    w!(self, \" {}\", label);\n+                }\n+            }\n+            Expr::Break { expr, label } => {\n+                w!(self, \"break\");\n+                if let Some(label) = label {\n+                    w!(self, \" {}\", label);\n+                }\n+                if let Some(expr) = expr {\n+                    self.whitespace();\n+                    self.print_expr(*expr);\n+                }\n+            }\n+            Expr::Return { expr } => {\n+                w!(self, \"return\");\n+                if let Some(expr) = expr {\n+                    self.whitespace();\n+                    self.print_expr(*expr);\n+                }\n+            }\n+            Expr::Yield { expr } => {\n+                w!(self, \"yield\");\n+                if let Some(expr) = expr {\n+                    self.whitespace();\n+                    self.print_expr(*expr);\n+                }\n+            }\n+            Expr::RecordLit { path, fields, spread, ellipsis, is_assignee_expr: _ } => {\n+                match path {\n+                    Some(path) => self.print_path(path),\n+                    None => w!(self, \"\ufffd\"),\n+                }\n+\n+                w!(self, \"{{\");\n+                self.indented(|p| {\n+                    for field in &**fields {\n+                        w!(p, \"{}: \", field.name);\n+                        p.print_expr(field.expr);\n+                        wln!(p, \",\");\n+                    }\n+                    if let Some(spread) = spread {\n+                        w!(p, \"..\");\n+                        p.print_expr(*spread);\n+                        wln!(p);\n+                    }\n+                    if *ellipsis {\n+                        wln!(p, \"..\");\n+                    }\n+                });\n+                w!(self, \"}}\");\n+            }\n+            Expr::Field { expr, name } => {\n+                self.print_expr(*expr);\n+                w!(self, \".{}\", name);\n+            }\n+            Expr::Await { expr } => {\n+                self.print_expr(*expr);\n+                w!(self, \".await\");\n+            }\n+            Expr::Try { expr } => {\n+                self.print_expr(*expr);\n+                w!(self, \"?\");\n+            }\n+            Expr::TryBlock { body } => {\n+                w!(self, \"try \");\n+                self.print_expr(*body);\n+            }\n+            Expr::Async { body } => {\n+                w!(self, \"async \");\n+                self.print_expr(*body);\n+            }\n+            Expr::Const { body } => {\n+                w!(self, \"const \");\n+                self.print_expr(*body);\n+            }\n+            Expr::Cast { expr, type_ref } => {\n+                self.print_expr(*expr);\n+                w!(self, \" as \");\n+                self.print_type_ref(type_ref);\n+            }\n+            Expr::Ref { expr, rawness, mutability } => {\n+                w!(self, \"&\");\n+                if rawness.is_raw() {\n+                    w!(self, \"raw \");\n+                }\n+                if mutability.is_mut() {\n+                    w!(self, \"mut \");\n+                }\n+                self.print_expr(*expr);\n+            }\n+            Expr::Box { expr } => {\n+                w!(self, \"box \");\n+                self.print_expr(*expr);\n+            }\n+            Expr::UnaryOp { expr, op } => {\n+                let op = match op {\n+                    ast::UnaryOp::Deref => \"*\",\n+                    ast::UnaryOp::Not => \"!\",\n+                    ast::UnaryOp::Neg => \"-\",\n+                };\n+                w!(self, \"{}\", op);\n+                self.print_expr(*expr);\n+            }\n+            Expr::BinaryOp { lhs, rhs, op } => {\n+                let (bra, ket) = match op {\n+                    None | Some(ast::BinaryOp::Assignment { .. }) => (\"\", \"\"),\n+                    _ => (\"(\", \")\"),\n+                };\n+                w!(self, \"{}\", bra);\n+                self.print_expr(*lhs);\n+                w!(self, \"{} \", ket);\n+                match op {\n+                    Some(op) => w!(self, \"{}\", op),\n+                    None => w!(self, \"\ufffd\"), // :)\n+                }\n+                w!(self, \" {}\", bra);\n+                self.print_expr(*rhs);\n+                w!(self, \"{}\", ket);\n+            }\n+            Expr::Range { lhs, rhs, range_type } => {\n+                if let Some(lhs) = lhs {\n+                    w!(self, \"(\");\n+                    self.print_expr(*lhs);\n+                    w!(self, \") \");\n+                }\n+                let range = match range_type {\n+                    ast::RangeOp::Exclusive => \"..\",\n+                    ast::RangeOp::Inclusive => \"..=\",\n+                };\n+                w!(self, \"{}\", range);\n+                if let Some(rhs) = rhs {\n+                    w!(self, \"(\");\n+                    self.print_expr(*rhs);\n+                    w!(self, \") \");\n+                }\n+            }\n+            Expr::Index { base, index } => {\n+                self.print_expr(*base);\n+                w!(self, \"[\");\n+                self.print_expr(*index);\n+                w!(self, \"]\");\n+            }\n+            Expr::Closure { args, arg_types, ret_type, body } => {\n+                w!(self, \"|\");\n+                for (i, (pat, ty)) in args.iter().zip(arg_types.iter()).enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    self.print_pat(*pat);\n+                    if let Some(ty) = ty {\n+                        w!(self, \": \");\n+                        self.print_type_ref(ty);\n+                    }\n+                }\n+                w!(self, \"|\");\n+                if let Some(ret_ty) = ret_type {\n+                    w!(self, \" -> \");\n+                    self.print_type_ref(ret_ty);\n+                }\n+                self.whitespace();\n+                self.print_expr(*body);\n+            }\n+            Expr::Tuple { exprs, is_assignee_expr: _ } => {\n+                w!(self, \"(\");\n+                for expr in exprs.iter() {\n+                    self.print_expr(*expr);\n+                    w!(self, \", \");\n+                }\n+                w!(self, \")\");\n+            }\n+            Expr::Unsafe { body } => {\n+                w!(self, \"unsafe \");\n+                self.print_expr(*body);\n+            }\n+            Expr::Array(arr) => {\n+                w!(self, \"[\");\n+                if !matches!(arr, Array::ElementList { elements, .. } if elements.is_empty()) {\n+                    self.indented(|p| match arr {\n+                        Array::ElementList { elements, is_assignee_expr: _ } => {\n+                            for elem in elements.iter() {\n+                                p.print_expr(*elem);\n+                                w!(p, \", \");\n+                            }\n+                        }\n+                        Array::Repeat { initializer, repeat } => {\n+                            p.print_expr(*initializer);\n+                            w!(p, \"; \");\n+                            p.print_expr(*repeat);\n+                        }\n+                    });\n+                    self.newline();\n+                }\n+                w!(self, \"]\");\n+            }\n+            Expr::Literal(lit) => self.print_literal(lit),\n+            Expr::Block { id: _, statements, tail, label } => {\n+                self.whitespace();\n+                if let Some(lbl) = label {\n+                    w!(self, \"{}: \", self.body[*lbl].name);\n+                }\n+                w!(self, \"{{\");\n+                if !statements.is_empty() || tail.is_some() {\n+                    self.indented(|p| {\n+                        for stmt in &**statements {\n+                            p.print_stmt(stmt);\n+                        }\n+                        if let Some(tail) = tail {\n+                            p.print_expr(*tail);\n+                        }\n+                        p.newline();\n+                    });\n+                }\n+                w!(self, \"}}\");\n+            }\n+            Expr::MacroStmts { statements, tail } => {\n+                w!(self, \"{{ // macro statements\");\n+                self.indented(|p| {\n+                    for stmt in statements.iter() {\n+                        p.print_stmt(stmt);\n+                    }\n+                    if let Some(tail) = tail {\n+                        p.print_expr(*tail);\n+                    }\n+                });\n+                self.newline();\n+                w!(self, \"}}\");\n+            }\n+        }\n+    }\n+\n+    fn print_pat(&mut self, pat: PatId) {\n+        let pat = &self.body[pat];\n+\n+        match pat {\n+            Pat::Missing => w!(self, \"\ufffd\"),\n+            Pat::Wild => w!(self, \"_\"),\n+            Pat::Tuple { args, ellipsis } => {\n+                w!(self, \"(\");\n+                for (i, pat) in args.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    if *ellipsis == Some(i) {\n+                        w!(self, \".., \");\n+                    }\n+                    self.print_pat(*pat);\n+                }\n+                w!(self, \")\");\n+            }\n+            Pat::Or(pats) => {\n+                for (i, pat) in pats.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \" | \");\n+                    }\n+                    self.print_pat(*pat);\n+                }\n+            }\n+            Pat::Record { path, args, ellipsis } => {\n+                match path {\n+                    Some(path) => self.print_path(path),\n+                    None => w!(self, \"\ufffd\"),\n+                }\n+\n+                w!(self, \" {{\");\n+                self.indented(|p| {\n+                    for arg in args.iter() {\n+                        w!(p, \"{}: \", arg.name);\n+                        p.print_pat(arg.pat);\n+                        wln!(p, \",\");\n+                    }\n+                    if *ellipsis {\n+                        wln!(p, \"..\");\n+                    }\n+                });\n+                w!(self, \"}}\");\n+            }\n+            Pat::Range { start, end } => {\n+                self.print_expr(*start);\n+                w!(self, \"...\");\n+                self.print_expr(*end);\n+            }\n+            Pat::Slice { prefix, slice, suffix } => {\n+                w!(self, \"[\");\n+                for pat in prefix.iter() {\n+                    self.print_pat(*pat);\n+                    w!(self, \", \");\n+                }\n+                if let Some(pat) = slice {\n+                    self.print_pat(*pat);\n+                    w!(self, \", \");\n+                }\n+                for pat in suffix.iter() {\n+                    self.print_pat(*pat);\n+                    w!(self, \", \");\n+                }\n+                w!(self, \"]\");\n+            }\n+            Pat::Path(path) => self.print_path(path),\n+            Pat::Lit(expr) => self.print_expr(*expr),\n+            Pat::Bind { mode, name, subpat } => {\n+                let mode = match mode {\n+                    BindingAnnotation::Unannotated => \"\",\n+                    BindingAnnotation::Mutable => \"mut \",\n+                    BindingAnnotation::Ref => \"ref \",\n+                    BindingAnnotation::RefMut => \"ref mut \",\n+                };\n+                w!(self, \"{}{}\", mode, name);\n+                if let Some(pat) = subpat {\n+                    self.whitespace();\n+                    self.print_pat(*pat);\n+                }\n+            }\n+            Pat::TupleStruct { path, args, ellipsis } => {\n+                match path {\n+                    Some(path) => self.print_path(path),\n+                    None => w!(self, \"\ufffd\"),\n+                }\n+                w!(self, \"(\");\n+                for (i, arg) in args.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    if *ellipsis == Some(i) {\n+                        w!(self, \", ..\");\n+                    }\n+                    self.print_pat(*arg);\n+                }\n+                w!(self, \")\");\n+            }\n+            Pat::Ref { pat, mutability } => {\n+                w!(self, \"&\");\n+                if mutability.is_mut() {\n+                    w!(self, \"mut \");\n+                }\n+                self.print_pat(*pat);\n+            }\n+            Pat::Box { inner } => {\n+                w!(self, \"box \");\n+                self.print_pat(*inner);\n+            }\n+            Pat::ConstBlock(c) => {\n+                w!(self, \"const \");\n+                self.print_expr(*c);\n+            }\n+        }\n+    }\n+\n+    fn print_stmt(&mut self, stmt: &Statement) {\n+        match stmt {\n+            Statement::Let { pat, type_ref, initializer, else_branch } => {\n+                w!(self, \"let \");\n+                self.print_pat(*pat);\n+                if let Some(ty) = type_ref {\n+                    w!(self, \": \");\n+                    self.print_type_ref(ty);\n+                }\n+                if let Some(init) = initializer {\n+                    w!(self, \" = \");\n+                    self.print_expr(*init);\n+                }\n+                if let Some(els) = else_branch {\n+                    w!(self, \" else \");\n+                    self.print_expr(*els);\n+                }\n+                wln!(self, \";\");\n+            }\n+            Statement::Expr { expr, has_semi } => {\n+                self.print_expr(*expr);\n+                if *has_semi {\n+                    w!(self, \";\");\n+                }\n+                wln!(self);\n+            }\n+        }\n+    }\n+\n+    fn print_literal(&mut self, literal: &Literal) {\n+        match literal {\n+            Literal::String(it) => w!(self, \"{:?}\", it),\n+            Literal::ByteString(it) => w!(self, \"\\\"{}\\\"\", it.escape_ascii()),\n+            Literal::Char(it) => w!(self, \"'{}'\", it.escape_debug()),\n+            Literal::Bool(it) => w!(self, \"{}\", it),\n+            Literal::Int(i, suffix) => {\n+                w!(self, \"{}\", i);\n+                if let Some(suffix) = suffix {\n+                    w!(self, \"{}\", suffix);\n+                }\n+            }\n+            Literal::Uint(i, suffix) => {\n+                w!(self, \"{}\", i);\n+                if let Some(suffix) = suffix {\n+                    w!(self, \"{}\", suffix);\n+                }\n+            }\n+            Literal::Float(f, suffix) => {\n+                w!(self, \"{}\", f);\n+                if let Some(suffix) = suffix {\n+                    w!(self, \"{}\", suffix);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn print_type_ref(&mut self, ty: &TypeRef) {\n+        print_type_ref(ty, self).unwrap();\n+    }\n+\n+    fn print_path(&mut self, path: &Path) {\n+        print_path(path, self).unwrap();\n+    }\n+}"}, {"sha": "dd69c3ab4731519ff08c60b2696f0773906edcd7", "filename": "crates/hir-def/src/builtin_type.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -156,3 +156,38 @@ impl BuiltinFloat {\n         Some(res)\n     }\n }\n+\n+impl fmt::Display for BuiltinInt {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            BuiltinInt::Isize => \"isize\",\n+            BuiltinInt::I8 => \"i8\",\n+            BuiltinInt::I16 => \"i16\",\n+            BuiltinInt::I32 => \"i32\",\n+            BuiltinInt::I64 => \"i64\",\n+            BuiltinInt::I128 => \"i128\",\n+        })\n+    }\n+}\n+\n+impl fmt::Display for BuiltinUint {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            BuiltinUint::Usize => \"usize\",\n+            BuiltinUint::U8 => \"u8\",\n+            BuiltinUint::U16 => \"u16\",\n+            BuiltinUint::U32 => \"u32\",\n+            BuiltinUint::U64 => \"u64\",\n+            BuiltinUint::U128 => \"u128\",\n+        })\n+    }\n+}\n+\n+impl fmt::Display for BuiltinFloat {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            BuiltinFloat::F32 => \"f32\",\n+            BuiltinFloat::F64 => \"f64\",\n+        })\n+    }\n+}"}, {"sha": "4381b43c258bfe90a9387e10f7608981090105f8", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -12,6 +12,8 @@\n //!\n //! See also a neighboring `body` module.\n \n+use std::fmt;\n+\n use hir_expand::name::Name;\n use la_arena::{Idx, RawIdx};\n \n@@ -52,8 +54,8 @@ impl FloatTypeWrapper {\n     }\n }\n \n-impl std::fmt::Display for FloatTypeWrapper {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+impl fmt::Display for FloatTypeWrapper {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{:?}\", f64::from_bits(self.0))\n     }\n }"}, {"sha": "34dd817fd130ce555c85bff6de7544949664ceb6", "filename": "crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 4, "deletions": 175, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -2,13 +2,10 @@\n \n use std::fmt::{self, Write};\n \n-use itertools::Itertools;\n-\n use crate::{\n     attr::RawAttrs,\n     generics::{TypeOrConstParamData, WherePredicate, WherePredicateTypeTarget},\n-    path::GenericArg,\n-    type_ref::TraitBoundModifier,\n+    pretty::{print_path, print_type_bounds, print_type_ref},\n     visibility::RawVisibility,\n };\n \n@@ -464,183 +461,15 @@ impl<'a> Printer<'a> {\n     }\n \n     fn print_type_ref(&mut self, type_ref: &TypeRef) {\n-        // FIXME: deduplicate with `HirDisplay` impl\n-        match type_ref {\n-            TypeRef::Never => w!(self, \"!\"),\n-            TypeRef::Placeholder => w!(self, \"_\"),\n-            TypeRef::Tuple(fields) => {\n-                w!(self, \"(\");\n-                for (i, field) in fields.iter().enumerate() {\n-                    if i != 0 {\n-                        w!(self, \", \");\n-                    }\n-                    self.print_type_ref(field);\n-                }\n-                w!(self, \")\");\n-            }\n-            TypeRef::Path(path) => self.print_path(path),\n-            TypeRef::RawPtr(pointee, mtbl) => {\n-                let mtbl = match mtbl {\n-                    Mutability::Shared => \"*const\",\n-                    Mutability::Mut => \"*mut\",\n-                };\n-                w!(self, \"{} \", mtbl);\n-                self.print_type_ref(pointee);\n-            }\n-            TypeRef::Reference(pointee, lt, mtbl) => {\n-                let mtbl = match mtbl {\n-                    Mutability::Shared => \"\",\n-                    Mutability::Mut => \"mut \",\n-                };\n-                w!(self, \"&\");\n-                if let Some(lt) = lt {\n-                    w!(self, \"{} \", lt.name);\n-                }\n-                w!(self, \"{}\", mtbl);\n-                self.print_type_ref(pointee);\n-            }\n-            TypeRef::Array(elem, len) => {\n-                w!(self, \"[\");\n-                self.print_type_ref(elem);\n-                w!(self, \"; {}]\", len);\n-            }\n-            TypeRef::Slice(elem) => {\n-                w!(self, \"[\");\n-                self.print_type_ref(elem);\n-                w!(self, \"]\");\n-            }\n-            TypeRef::Fn(args_and_ret, varargs) => {\n-                let ((_, return_type), args) =\n-                    args_and_ret.split_last().expect(\"TypeRef::Fn is missing return type\");\n-                w!(self, \"fn(\");\n-                for (i, (_, typeref)) in args.iter().enumerate() {\n-                    if i != 0 {\n-                        w!(self, \", \");\n-                    }\n-                    self.print_type_ref(typeref);\n-                }\n-                if *varargs {\n-                    if !args.is_empty() {\n-                        w!(self, \", \");\n-                    }\n-                    w!(self, \"...\");\n-                }\n-                w!(self, \") -> \");\n-                self.print_type_ref(return_type);\n-            }\n-            TypeRef::Macro(_ast_id) => {\n-                w!(self, \"<macro>\");\n-            }\n-            TypeRef::Error => w!(self, \"{{unknown}}\"),\n-            TypeRef::ImplTrait(bounds) => {\n-                w!(self, \"impl \");\n-                self.print_type_bounds(bounds);\n-            }\n-            TypeRef::DynTrait(bounds) => {\n-                w!(self, \"dyn \");\n-                self.print_type_bounds(bounds);\n-            }\n-        }\n+        print_type_ref(type_ref, self).unwrap();\n     }\n \n     fn print_type_bounds(&mut self, bounds: &[Interned<TypeBound>]) {\n-        for (i, bound) in bounds.iter().enumerate() {\n-            if i != 0 {\n-                w!(self, \" + \");\n-            }\n-\n-            match bound.as_ref() {\n-                TypeBound::Path(path, modifier) => {\n-                    match modifier {\n-                        TraitBoundModifier::None => (),\n-                        TraitBoundModifier::Maybe => w!(self, \"?\"),\n-                    }\n-                    self.print_path(path)\n-                }\n-                TypeBound::ForLifetime(lifetimes, path) => {\n-                    w!(self, \"for<{}> \", lifetimes.iter().format(\", \"));\n-                    self.print_path(path);\n-                }\n-                TypeBound::Lifetime(lt) => w!(self, \"{}\", lt.name),\n-                TypeBound::Error => w!(self, \"{{unknown}}\"),\n-            }\n-        }\n+        print_type_bounds(bounds, self).unwrap();\n     }\n \n     fn print_path(&mut self, path: &Path) {\n-        match path.type_anchor() {\n-            Some(anchor) => {\n-                w!(self, \"<\");\n-                self.print_type_ref(anchor);\n-                w!(self, \">::\");\n-            }\n-            None => match path.kind() {\n-                PathKind::Plain => {}\n-                PathKind::Super(0) => w!(self, \"self::\"),\n-                PathKind::Super(n) => {\n-                    for _ in 0..*n {\n-                        w!(self, \"super::\");\n-                    }\n-                }\n-                PathKind::Crate => w!(self, \"crate::\"),\n-                PathKind::Abs => w!(self, \"::\"),\n-                PathKind::DollarCrate(_) => w!(self, \"$crate::\"),\n-            },\n-        }\n-\n-        for (i, segment) in path.segments().iter().enumerate() {\n-            if i != 0 {\n-                w!(self, \"::\");\n-            }\n-\n-            w!(self, \"{}\", segment.name);\n-            if let Some(generics) = segment.args_and_bindings {\n-                // NB: these are all in type position, so `::<` turbofish syntax is not necessary\n-                w!(self, \"<\");\n-                let mut first = true;\n-                let args = if generics.has_self_type {\n-                    let (self_ty, args) = generics.args.split_first().unwrap();\n-                    w!(self, \"Self=\");\n-                    self.print_generic_arg(self_ty);\n-                    first = false;\n-                    args\n-                } else {\n-                    &generics.args\n-                };\n-                for arg in args {\n-                    if !first {\n-                        w!(self, \", \");\n-                    }\n-                    first = false;\n-                    self.print_generic_arg(arg);\n-                }\n-                for binding in &generics.bindings {\n-                    if !first {\n-                        w!(self, \", \");\n-                    }\n-                    first = false;\n-                    w!(self, \"{}\", binding.name);\n-                    if !binding.bounds.is_empty() {\n-                        w!(self, \": \");\n-                        self.print_type_bounds(&binding.bounds);\n-                    }\n-                    if let Some(ty) = &binding.type_ref {\n-                        w!(self, \" = \");\n-                        self.print_type_ref(ty);\n-                    }\n-                }\n-\n-                w!(self, \">\");\n-            }\n-        }\n-    }\n-\n-    fn print_generic_arg(&mut self, arg: &GenericArg) {\n-        match arg {\n-            GenericArg::Type(ty) => self.print_type_ref(ty),\n-            GenericArg::Const(c) => w!(self, \"{}\", c),\n-            GenericArg::Lifetime(lt) => w!(self, \"{}\", lt.name),\n-        }\n+        print_path(path, self).unwrap();\n     }\n \n     fn print_generic_params(&mut self, params: &GenericParams) {"}, {"sha": "e30d9652bb5dde974f65e5955ba36f68d0c75305", "filename": "crates/hir-def/src/item_tree/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -283,10 +283,10 @@ struct S {\n         \"#,\n         expect![[r#\"\n             pub(self) struct S {\n-                pub(self) a: Mixed<'a, T, Item = (), OtherItem = u8>,\n-                pub(self) b: Qualified<Self=Fully>::Syntax,\n-                pub(self) c: <TypeAnchored>::Path<'a>,\n-                pub(self) d: dyn for<'a> Trait<'a>,\n+                pub(self) a: Mixed::<'a, T, Item = (), OtherItem = u8>,\n+                pub(self) b: Qualified::<Self=Fully>::Syntax,\n+                pub(self) c: <TypeAnchored>::Path::<'a>,\n+                pub(self) d: dyn for<'a> Trait::<'a>,\n             }\n         \"#]],\n     )\n@@ -329,7 +329,7 @@ trait Tr<'a, T: 'a>: Super where Self: for<'a> Tr<'a, T> {}\n                 T: Copy,\n                 U: ?Sized;\n \n-            impl<'a, 'b, T, const K: u8> S<'a, 'b, T, K>\n+            impl<'a, 'b, T, const K: u8> S::<'a, 'b, T, K>\n             where\n                 T: Copy,\n                 T: 'a,\n@@ -352,7 +352,7 @@ trait Tr<'a, T: 'a>: Super where Self: for<'a> Tr<'a, T> {}\n             where\n                 Self: Super,\n                 T: 'a,\n-                Self: for<'a> Tr<'a, T>\n+                Self: for<'a> Tr::<'a, T>\n             {\n             }\n         \"#]],"}, {"sha": "32ebfda4fd926d475ec1b595bd0c7b01c698372f", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -53,6 +53,7 @@ pub mod import_map;\n mod test_db;\n #[cfg(test)]\n mod macro_expansion_tests;\n+mod pretty;\n \n use std::{\n     hash::{Hash, Hasher},"}, {"sha": "6636c8a23ca5fea4e31eef52f1d9d86ab0292359", "filename": "crates/hir-def/src/pretty.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -0,0 +1,209 @@\n+//! Display and pretty printing routines.\n+\n+use std::fmt::{self, Write};\n+\n+use hir_expand::mod_path::PathKind;\n+use itertools::Itertools;\n+\n+use crate::{\n+    intern::Interned,\n+    path::{GenericArg, GenericArgs, Path},\n+    type_ref::{Mutability, TraitBoundModifier, TypeBound, TypeRef},\n+};\n+\n+pub(crate) fn print_path(path: &Path, buf: &mut dyn Write) -> fmt::Result {\n+    match path.type_anchor() {\n+        Some(anchor) => {\n+            write!(buf, \"<\")?;\n+            print_type_ref(anchor, buf)?;\n+            write!(buf, \">::\")?;\n+        }\n+        None => match path.kind() {\n+            PathKind::Plain => {}\n+            PathKind::Super(0) => write!(buf, \"self\")?,\n+            PathKind::Super(n) => {\n+                for i in 0..*n {\n+                    if i == 0 {\n+                        buf.write_str(\"super\")?;\n+                    } else {\n+                        buf.write_str(\"::super\")?;\n+                    }\n+                }\n+            }\n+            PathKind::Crate => write!(buf, \"crate\")?,\n+            PathKind::Abs => {}\n+            PathKind::DollarCrate(_) => write!(buf, \"$crate\")?,\n+        },\n+    }\n+\n+    for (i, segment) in path.segments().iter().enumerate() {\n+        if i != 0 || !matches!(path.kind(), PathKind::Plain) {\n+            write!(buf, \"::\")?;\n+        }\n+\n+        write!(buf, \"{}\", segment.name)?;\n+        if let Some(generics) = segment.args_and_bindings {\n+            write!(buf, \"::<\")?;\n+            print_generic_args(generics, buf)?;\n+\n+            write!(buf, \">\")?;\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+pub(crate) fn print_generic_args(generics: &GenericArgs, buf: &mut dyn Write) -> fmt::Result {\n+    let mut first = true;\n+    let args = if generics.has_self_type {\n+        let (self_ty, args) = generics.args.split_first().unwrap();\n+        write!(buf, \"Self=\")?;\n+        print_generic_arg(self_ty, buf)?;\n+        first = false;\n+        args\n+    } else {\n+        &generics.args\n+    };\n+    for arg in args {\n+        if !first {\n+            write!(buf, \", \")?;\n+        }\n+        first = false;\n+        print_generic_arg(arg, buf)?;\n+    }\n+    for binding in &generics.bindings {\n+        if !first {\n+            write!(buf, \", \")?;\n+        }\n+        first = false;\n+        write!(buf, \"{}\", binding.name)?;\n+        if !binding.bounds.is_empty() {\n+            write!(buf, \": \")?;\n+            print_type_bounds(&binding.bounds, buf)?;\n+        }\n+        if let Some(ty) = &binding.type_ref {\n+            write!(buf, \" = \")?;\n+            print_type_ref(ty, buf)?;\n+        }\n+    }\n+    Ok(())\n+}\n+\n+pub(crate) fn print_generic_arg(arg: &GenericArg, buf: &mut dyn Write) -> fmt::Result {\n+    match arg {\n+        GenericArg::Type(ty) => print_type_ref(ty, buf),\n+        GenericArg::Const(c) => write!(buf, \"{}\", c),\n+        GenericArg::Lifetime(lt) => write!(buf, \"{}\", lt.name),\n+    }\n+}\n+\n+pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Result {\n+    // FIXME: deduplicate with `HirDisplay` impl\n+    match type_ref {\n+        TypeRef::Never => write!(buf, \"!\")?,\n+        TypeRef::Placeholder => write!(buf, \"_\")?,\n+        TypeRef::Tuple(fields) => {\n+            write!(buf, \"(\")?;\n+            for (i, field) in fields.iter().enumerate() {\n+                if i != 0 {\n+                    write!(buf, \", \")?;\n+                }\n+                print_type_ref(field, buf)?;\n+            }\n+            write!(buf, \")\")?;\n+        }\n+        TypeRef::Path(path) => print_path(path, buf)?,\n+        TypeRef::RawPtr(pointee, mtbl) => {\n+            let mtbl = match mtbl {\n+                Mutability::Shared => \"*const\",\n+                Mutability::Mut => \"*mut\",\n+            };\n+            write!(buf, \"{} \", mtbl)?;\n+            print_type_ref(pointee, buf)?;\n+        }\n+        TypeRef::Reference(pointee, lt, mtbl) => {\n+            let mtbl = match mtbl {\n+                Mutability::Shared => \"\",\n+                Mutability::Mut => \"mut \",\n+            };\n+            write!(buf, \"&\")?;\n+            if let Some(lt) = lt {\n+                write!(buf, \"{} \", lt.name)?;\n+            }\n+            write!(buf, \"{}\", mtbl)?;\n+            print_type_ref(pointee, buf)?;\n+        }\n+        TypeRef::Array(elem, len) => {\n+            write!(buf, \"[\")?;\n+            print_type_ref(elem, buf)?;\n+            write!(buf, \"; {}]\", len)?;\n+        }\n+        TypeRef::Slice(elem) => {\n+            write!(buf, \"[\")?;\n+            print_type_ref(elem, buf)?;\n+            write!(buf, \"]\")?;\n+        }\n+        TypeRef::Fn(args_and_ret, varargs) => {\n+            let ((_, return_type), args) =\n+                args_and_ret.split_last().expect(\"TypeRef::Fn is missing return type\");\n+            write!(buf, \"fn(\")?;\n+            for (i, (_, typeref)) in args.iter().enumerate() {\n+                if i != 0 {\n+                    write!(buf, \", \")?;\n+                }\n+                print_type_ref(typeref, buf)?;\n+            }\n+            if *varargs {\n+                if !args.is_empty() {\n+                    write!(buf, \", \")?;\n+                }\n+                write!(buf, \"...\")?;\n+            }\n+            write!(buf, \") -> \")?;\n+            print_type_ref(return_type, buf)?;\n+        }\n+        TypeRef::Macro(_ast_id) => {\n+            write!(buf, \"<macro>\")?;\n+        }\n+        TypeRef::Error => write!(buf, \"{{unknown}}\")?,\n+        TypeRef::ImplTrait(bounds) => {\n+            write!(buf, \"impl \")?;\n+            print_type_bounds(bounds, buf)?;\n+        }\n+        TypeRef::DynTrait(bounds) => {\n+            write!(buf, \"dyn \")?;\n+            print_type_bounds(bounds, buf)?;\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+pub(crate) fn print_type_bounds(\n+    bounds: &[Interned<TypeBound>],\n+    buf: &mut dyn Write,\n+) -> fmt::Result {\n+    for (i, bound) in bounds.iter().enumerate() {\n+        if i != 0 {\n+            write!(buf, \" + \")?;\n+        }\n+\n+        match bound.as_ref() {\n+            TypeBound::Path(path, modifier) => {\n+                match modifier {\n+                    TraitBoundModifier::None => (),\n+                    TraitBoundModifier::Maybe => write!(buf, \"?\")?,\n+                }\n+                print_path(path, buf)?;\n+            }\n+            TypeBound::ForLifetime(lifetimes, path) => {\n+                write!(buf, \"for<{}> \", lifetimes.iter().format(\", \"))?;\n+                print_path(path, buf)?;\n+            }\n+            TypeBound::Lifetime(lt) => write!(buf, \"{}\", lt.name)?,\n+            TypeBound::Error => write!(buf, \"{{unknown}}\")?,\n+        }\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "5b4c71be7fb837eb688529d7d6ab976445655979", "filename": "crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -77,6 +77,10 @@ impl Rawness {\n             Rawness::Ref\n         }\n     }\n+\n+    pub fn is_raw(&self) -> bool {\n+        matches!(self, Self::RawPtr)\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]"}, {"sha": "3561bdeba7f52f4acfd8a2d0f7761b98bc4ab028", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -72,7 +72,7 @@ use itertools::Itertools;\n use nameres::diagnostics::DefDiagnosticKind;\n use once_cell::unsync::Lazy;\n use rustc_hash::FxHashSet;\n-use stdx::{format_to, impl_from, never};\n+use stdx::{impl_from, never};\n use syntax::{\n     ast::{self, HasAttrs as _, HasDocComments, HasName},\n     AstNode, AstPtr, SmolStr, SyntaxNodePtr, TextRange, T,\n@@ -1136,6 +1136,20 @@ impl DefWithBody {\n         }\n     }\n \n+    fn id(&self) -> DefWithBodyId {\n+        match self {\n+            DefWithBody::Function(it) => it.id.into(),\n+            DefWithBody::Static(it) => it.id.into(),\n+            DefWithBody::Const(it) => it.id.into(),\n+        }\n+    }\n+\n+    /// A textual representation of the HIR of this def's body for debugging purposes.\n+    pub fn debug_hir(self, db: &dyn HirDatabase) -> String {\n+        let body = db.body(self.id());\n+        body.pretty_print(db.upcast(), self.id())\n+    }\n+\n     pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let krate = self.module(db).id.krate();\n \n@@ -1470,19 +1484,6 @@ impl Function {\n         let def_map = db.crate_def_map(loc.krate(db).into());\n         def_map.fn_as_proc_macro(self.id).map(|id| Macro { id: id.into() })\n     }\n-\n-    /// A textual representation of the HIR of this function for debugging purposes.\n-    pub fn debug_hir(self, db: &dyn HirDatabase) -> String {\n-        let body = db.body(self.id.into());\n-\n-        let mut result = String::new();\n-        format_to!(result, \"HIR expressions in the body of `{}`:\\n\", self.name(db));\n-        for (id, expr) in body.exprs.iter() {\n-            format_to!(result, \"{:?}: {:?}\\n\", id, expr);\n-        }\n-\n-        result\n-    }\n }\n \n // Note: logically, this belongs to `hir_ty`, but we are not using it there yet."}, {"sha": "d2bbbf6d26ab4cc9e23893fdad52de346ba88dac", "filename": "crates/ide/src/view_hir.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fide%2Fsrc%2Fview_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/crates%2Fide%2Fsrc%2Fview_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fview_hir.rs?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -1,4 +1,4 @@\n-use hir::{Function, Semantics};\n+use hir::{DefWithBody, Semantics};\n use ide_db::base_db::FilePosition;\n use ide_db::RootDatabase;\n use syntax::{algo::find_node_at_offset, ast, AstNode};\n@@ -19,8 +19,12 @@ fn body_hir(db: &RootDatabase, position: FilePosition) -> Option<String> {\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(position.file_id);\n \n-    let function = find_node_at_offset::<ast::Fn>(source_file.syntax(), position.offset)?;\n-\n-    let function: Function = sema.to_def(&function)?;\n-    Some(function.debug_hir(db))\n+    let item = find_node_at_offset::<ast::Item>(source_file.syntax(), position.offset)?;\n+    let def: DefWithBody = match item {\n+        ast::Item::Fn(it) => sema.to_def(&it)?.into(),\n+        ast::Item::Const(it) => sema.to_def(&it)?.into(),\n+        ast::Item::Static(it) => sema.to_def(&it)?.into(),\n+        _ => return None,\n+    };\n+    Some(def.debug_hir(db))\n }"}, {"sha": "f58de9da1bfe00751033ecc731ea10b7881014f6", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcbe892d7ceec113a148a89bc6d1c339c55586d1/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/dcbe892d7ceec113a148a89bc6d1c339c55586d1/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=dcbe892d7ceec113a148a89bc6d1c339c55586d1", "patch": "@@ -433,7 +433,7 @@ export function syntaxTree(ctx: Ctx): Cmd {\n // The contents of the file come from the `TextDocumentContentProvider`\n export function viewHir(ctx: Ctx): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n-        readonly uri = vscode.Uri.parse(\"rust-analyzer-hir://viewHir/hir.txt\");\n+        readonly uri = vscode.Uri.parse(\"rust-analyzer-hir://viewHir/hir.rs\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n         constructor() {\n             vscode.workspace.onDidChangeTextDocument("}]}