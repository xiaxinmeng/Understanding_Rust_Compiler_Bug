{"sha": "26438b473883ea607b30288e461187f0fb2fe589", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NDM4YjQ3Mzg4M2VhNjA3YjMwMjg4ZTQ2MTE4N2YwZmIyZmU1ODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-08T18:16:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-08T18:16:00Z"}, "message": "Auto merge of #78452 - cjgillot:ddk-struct, r=Mark-Simulacrum\n\nAccess query (DepKind) metadata through fields\n\nThis refactors the access to query definition metadata (attributes such as eval always, anon, has_params) and loading/forcing functions to generate a number of structs, instead of matching on the DepKind enum. This makes access to the fields cheaper to compile. Using a struct means that finding the metadata for a given query is just an offset away; previously the match may have been compiled to a jump table but likely not completely inlined as we expect here.\n\nA previous attempt explored a similar strategy, but using trait objects in #78314 that proved less effective, likely due to higher overheads due to forcing dynamic calls and poorer cache utilization (all metadata is fairly densely packed with this PR).", "tree": {"sha": "367872d4228bcc704926734c49695738999bdd34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/367872d4228bcc704926734c49695738999bdd34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26438b473883ea607b30288e461187f0fb2fe589", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26438b473883ea607b30288e461187f0fb2fe589", "html_url": "https://github.com/rust-lang/rust/commit/26438b473883ea607b30288e461187f0fb2fe589", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26438b473883ea607b30288e461187f0fb2fe589/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddf2cc7f8eb34f1a63b491d6a52e3e8208393c09", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddf2cc7f8eb34f1a63b491d6a52e3e8208393c09", "html_url": "https://github.com/rust-lang/rust/commit/ddf2cc7f8eb34f1a63b491d6a52e3e8208393c09"}, {"sha": "0f334c3642257f711e0c397fec11707d86e14e70", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f334c3642257f711e0c397fec11707d86e14e70", "html_url": "https://github.com/rust-lang/rust/commit/0f334c3642257f711e0c397fec11707d86e14e70"}], "stats": {"total": 693, "additions": 376, "deletions": 317}, "files": [{"sha": "b775846bba4528e272dcb1fee2279c4132f3f4cc", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 340, "deletions": 163, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=26438b473883ea607b30288e461187f0fb2fe589", "patch": "@@ -29,8 +29,8 @@\n //!   contained no `DefId` for thing that had been removed.\n //!\n //! `DepNode` definition happens in the `define_dep_nodes!()` macro. This macro\n-//! defines the `DepKind` enum and a corresponding `DepConstructor` enum. The\n-//! `DepConstructor` enum links a `DepKind` to the parameters that are needed at\n+//! defines the `DepKind` enum and a corresponding `dep_constructor` module. The\n+//! `dep_constructor` module links a `DepKind` to the parameters that are needed at\n //! runtime in order to construct a valid `DepNode` fingerprint.\n //!\n //! Because the macro sees what parameters a given `DepKind` requires, it can\n@@ -44,7 +44,7 @@\n //!   `DefId` it was computed from. In other cases, too much information gets\n //!   lost during fingerprint computation.\n //!\n-//! The `DepConstructor` enum, together with `DepNode::new()`, ensures that only\n+//! The `dep_constructor` module, together with `DepNode::new()`, ensures that only\n //! valid `DepNode` instances can be constructed. For example, the API does not\n //! allow for constructing parameterless `DepNode`s with anything other\n //! than a zeroed out fingerprint. More generally speaking, it relieves the\n@@ -66,10 +66,104 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::definitions::DefPathHash;\n use rustc_hir::HirId;\n use rustc_span::symbol::Symbol;\n+use rustc_span::DUMMY_SP;\n use std::hash::Hash;\n \n pub use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n \n+/// This struct stores metadata about each DepKind.\n+///\n+/// Information is retrieved by indexing the `DEP_KINDS` array using the integer value\n+/// of the `DepKind`. Overall, this allows to implement `DepContext` using this manual\n+/// jump table instead of large matches.\n+pub struct DepKindStruct {\n+    /// Whether the DepNode has parameters (query keys).\n+    pub(super) has_params: bool,\n+\n+    /// Anonymous queries cannot be replayed from one compiler invocation to the next.\n+    /// When their result is needed, it is recomputed. They are useful for fine-grained\n+    /// dependency tracking, and caching within one compiler invocation.\n+    pub(super) is_anon: bool,\n+\n+    /// Eval-always queries do not track their dependencies, and are always recomputed, even if\n+    /// their inputs have not changed since the last compiler invocation. The result is still\n+    /// cached within one compiler invocation.\n+    pub(super) is_eval_always: bool,\n+\n+    /// Whether the query key can be recovered from the hashed fingerprint.\n+    /// See [DepNodeParams] trait for the behaviour of each key type.\n+    // FIXME: Make this a simple boolean once DepNodeParams::can_reconstruct_query_key\n+    // can be made a specialized associated const.\n+    can_reconstruct_query_key: fn() -> bool,\n+\n+    /// The red/green evaluation system will try to mark a specific DepNode in the\n+    /// dependency graph as green by recursively trying to mark the dependencies of\n+    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+    /// where we don't know if it is red or green and we therefore actually have\n+    /// to recompute its value in order to find out. Since the only piece of\n+    /// information that we have at that point is the `DepNode` we are trying to\n+    /// re-evaluate, we need some way to re-run a query from just that. This is what\n+    /// `force_from_dep_node()` implements.\n+    ///\n+    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+    /// is usually constructed by computing a stable hash of the query-key that the\n+    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+    /// back from hash to query-key (since hash functions are not reversible). For\n+    /// this reason `force_from_dep_node()` is expected to fail from time to time\n+    /// because we just cannot find out, from the `DepNode` alone, what the\n+    /// corresponding query-key is and therefore cannot re-run the query.\n+    ///\n+    /// The system deals with this case letting `try_mark_green` fail which forces\n+    /// the root query to be re-evaluated.\n+    ///\n+    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+    /// Fortunately, we can use some contextual information that will allow us to\n+    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n+    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+    /// everything we need to re-run the query.\n+    ///\n+    /// Take the `mir_promoted` query as an example. Like many other queries, it\n+    /// just has a single parameter: the `DefId` of the item it will compute the\n+    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n+    ///\n+    /// When you implement a new query, it will likely have a corresponding new\n+    /// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n+    /// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n+    /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n+    /// add it to the \"We don't have enough information to reconstruct...\" group in\n+    /// the match below.\n+    pub(super) force_from_dep_node: fn(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool,\n+\n+    /// Invoke a query to put the on-disk cached value in memory.\n+    pub(super) try_load_from_on_disk_cache: fn(TyCtxt<'_>, &DepNode),\n+}\n+\n+impl std::ops::Deref for DepKind {\n+    type Target = DepKindStruct;\n+    fn deref(&self) -> &DepKindStruct {\n+        &DEP_KINDS[*self as usize]\n+    }\n+}\n+\n+impl DepKind {\n+    #[inline(always)]\n+    pub fn can_reconstruct_query_key(&self) -> bool {\n+        // Only fetch the DepKindStruct once.\n+        let data: &DepKindStruct = &**self;\n+        if data.is_anon {\n+            return false;\n+        }\n+\n+        (data.can_reconstruct_query_key)()\n+    }\n+}\n+\n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e., which sub-expression of the macro we are in) but don't need\n // to actually use any of the arguments.\n@@ -103,79 +197,151 @@ macro_rules! contains_eval_always_attr {\n     ($($attr:ident $(($($attr_args:tt)*))* ),*) => ({$(is_eval_always_attr!($attr) | )* false});\n }\n \n+#[allow(non_upper_case_globals)]\n+pub mod dep_kind {\n+    use super::*;\n+    use crate::ty::query::{queries, query_keys};\n+    use rustc_query_system::query::{force_query, QueryDescription};\n+\n+    // We use this for most things when incr. comp. is turned off.\n+    pub const Null: DepKindStruct = DepKindStruct {\n+        has_params: false,\n+        is_anon: false,\n+        is_eval_always: false,\n+\n+        can_reconstruct_query_key: || true,\n+        force_from_dep_node: |_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node),\n+        try_load_from_on_disk_cache: |_, _| {},\n+    };\n+\n+    // Represents metadata from an extern crate.\n+    pub const CrateMetadata: DepKindStruct = DepKindStruct {\n+        has_params: true,\n+        is_anon: false,\n+        is_eval_always: true,\n+\n+        can_reconstruct_query_key: || true,\n+        force_from_dep_node: |_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node),\n+        try_load_from_on_disk_cache: |_, _| {},\n+    };\n+\n+    pub const TraitSelect: DepKindStruct = DepKindStruct {\n+        has_params: false,\n+        is_anon: true,\n+        is_eval_always: false,\n+\n+        can_reconstruct_query_key: || true,\n+        force_from_dep_node: |_, _| false,\n+        try_load_from_on_disk_cache: |_, _| {},\n+    };\n+\n+    pub const CompileCodegenUnit: DepKindStruct = DepKindStruct {\n+        has_params: true,\n+        is_anon: false,\n+        is_eval_always: false,\n+\n+        can_reconstruct_query_key: || false,\n+        force_from_dep_node: |_, _| false,\n+        try_load_from_on_disk_cache: |_, _| {},\n+    };\n+\n+    macro_rules! define_query_dep_kinds {\n+        ($(\n+            [$($attrs:tt)*]\n+            $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n+        ,)*) => (\n+            $(pub const $variant: DepKindStruct = {\n+                const has_params: bool = $({ erase!($tuple_arg_ty); true } |)* false;\n+                const is_anon: bool = contains_anon_attr!($($attrs)*);\n+                const is_eval_always: bool = contains_eval_always_attr!($($attrs)*);\n+\n+                #[inline(always)]\n+                fn can_reconstruct_query_key() -> bool {\n+                    <query_keys::$variant<'_> as DepNodeParams<TyCtxt<'_>>>\n+                        ::can_reconstruct_query_key()\n+                }\n+\n+                fn recover<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<query_keys::$variant<'tcx>> {\n+                    <query_keys::$variant<'_> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node)\n+                }\n+\n+                fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n+                    if is_anon {\n+                        return false;\n+                    }\n+\n+                    if !can_reconstruct_query_key() {\n+                        return false;\n+                    }\n+\n+                    if let Some(key) = recover(tcx, dep_node) {\n+                        force_query::<queries::$variant<'_>, _>(\n+                            tcx,\n+                            key,\n+                            DUMMY_SP,\n+                            *dep_node\n+                        );\n+                        return true;\n+                    }\n+\n+                    false\n+                }\n+\n+                fn try_load_from_on_disk_cache(tcx: TyCtxt<'_>, dep_node: &DepNode) {\n+                    if is_anon {\n+                        return\n+                    }\n+\n+                    if !can_reconstruct_query_key() {\n+                        return\n+                    }\n+\n+                    debug_assert!(tcx.dep_graph\n+                                     .node_color(dep_node)\n+                                     .map(|c| c.is_green())\n+                                     .unwrap_or(false));\n+\n+                    let key = recover(tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n+                    if queries::$variant::cache_on_disk(tcx, &key, None) {\n+                        let _ = tcx.$variant(key);\n+                    }\n+                }\n+\n+                DepKindStruct {\n+                    has_params,\n+                    is_anon,\n+                    is_eval_always,\n+                    can_reconstruct_query_key,\n+                    force_from_dep_node,\n+                    try_load_from_on_disk_cache,\n+                }\n+            };)*\n+        );\n+    }\n+\n+    rustc_dep_node_append!([define_query_dep_kinds!][]);\n+}\n+\n macro_rules! define_dep_nodes {\n     (<$tcx:tt>\n     $(\n         [$($attrs:tt)*]\n         $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n       ,)*\n     ) => (\n-        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n+        static DEP_KINDS: &[DepKindStruct] = &[ $(dep_kind::$variant),* ];\n+\n+        /// This enum serves as an index into the `DEP_KINDS` array.\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n         #[allow(non_camel_case_types)]\n         pub enum DepKind {\n             $($variant),*\n         }\n \n-        impl DepKind {\n-            #[allow(unreachable_code)]\n-            pub fn can_reconstruct_query_key<$tcx>(&self) -> bool {\n-                match *self {\n-                    $(\n-                        DepKind :: $variant => {\n-                            if contains_anon_attr!($($attrs)*) {\n-                                return false;\n-                            }\n-\n-                            // tuple args\n-                            $({\n-                                return <$tuple_arg_ty as DepNodeParams<TyCtxt<'_>>>\n-                                    ::can_reconstruct_query_key();\n-                            })*\n-\n-                            true\n-                        }\n-                    )*\n-                }\n-            }\n-\n-            pub fn is_anon(&self) -> bool {\n-                match *self {\n-                    $(\n-                        DepKind :: $variant => { contains_anon_attr!($($attrs)*) }\n-                    )*\n-                }\n-            }\n-\n-            pub fn is_eval_always(&self) -> bool {\n-                match *self {\n-                    $(\n-                        DepKind :: $variant => { contains_eval_always_attr!($($attrs)*) }\n-                    )*\n-                }\n-            }\n-\n-            #[allow(unreachable_code)]\n-            pub fn has_params(&self) -> bool {\n-                match *self {\n-                    $(\n-                        DepKind :: $variant => {\n-                            // tuple args\n-                            $({\n-                                erase!($tuple_arg_ty);\n-                                return true;\n-                            })*\n-\n-                            false\n-                        }\n-                    )*\n-                }\n-            }\n-        }\n-\n-        pub struct DepConstructor;\n-\n         #[allow(non_camel_case_types)]\n-        impl DepConstructor {\n+        pub mod dep_constructor {\n+            use super::*;\n+\n             $(\n                 #[inline(always)]\n                 #[allow(unreachable_code, non_snake_case)]\n@@ -191,101 +357,10 @@ macro_rules! define_dep_nodes {\n             )*\n         }\n \n-        pub type DepNode = rustc_query_system::dep_graph::DepNode<DepKind>;\n-\n-        // We keep a lot of `DepNode`s in memory during compilation. It's not\n-        // required that their size stay the same, but we don't want to change\n-        // it inadvertently. This assert just ensures we're aware of any change.\n-        #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-        static_assert_size!(DepNode, 17);\n-\n-        #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-        static_assert_size!(DepNode, 24);\n-\n-        pub trait DepNodeExt: Sized {\n-            /// Construct a DepNode from the given DepKind and DefPathHash. This\n-            /// method will assert that the given DepKind actually requires a\n-            /// single DefId/DefPathHash parameter.\n-            fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> Self;\n-\n-            /// Extracts the DefId corresponding to this DepNode. This will work\n-            /// if two conditions are met:\n-            ///\n-            /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n-            /// 2. the item that the DefPath refers to exists in the current tcx.\n-            ///\n-            /// Condition (1) is determined by the DepKind variant of the\n-            /// DepNode. Condition (2) might not be fulfilled if a DepNode\n-            /// refers to something from the previous compilation session that\n-            /// has been removed.\n-            fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId>;\n-\n-            /// Used in testing\n-            fn from_label_string(label: &str, def_path_hash: DefPathHash)\n-                -> Result<Self, ()>;\n-\n-            /// Used in testing\n-            fn has_label_string(label: &str) -> bool;\n-        }\n-\n-        impl DepNodeExt for DepNode {\n-            /// Construct a DepNode from the given DepKind and DefPathHash. This\n-            /// method will assert that the given DepKind actually requires a\n-            /// single DefId/DefPathHash parameter.\n-            fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n-                debug_assert!(kind.can_reconstruct_query_key() && kind.has_params());\n-                DepNode {\n-                    kind,\n-                    hash: def_path_hash.0.into(),\n-                }\n-            }\n-\n-            /// Extracts the DefId corresponding to this DepNode. This will work\n-            /// if two conditions are met:\n-            ///\n-            /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n-            /// 2. the item that the DefPath refers to exists in the current tcx.\n-            ///\n-            /// Condition (1) is determined by the DepKind variant of the\n-            /// DepNode. Condition (2) might not be fulfilled if a DepNode\n-            /// refers to something from the previous compilation session that\n-            /// has been removed.\n-            fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n-                if self.kind.can_reconstruct_query_key() {\n-                    tcx.queries.on_disk_cache.as_ref()?.def_path_hash_to_def_id(tcx, DefPathHash(self.hash.into()))\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            /// Used in testing\n-            fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<DepNode, ()> {\n-                let kind = match label {\n-                    $(\n-                        stringify!($variant) => DepKind::$variant,\n-                    )*\n-                    _ => return Err(()),\n-                };\n-\n-                if !kind.can_reconstruct_query_key() {\n-                    return Err(());\n-                }\n-\n-                if kind.has_params() {\n-                    Ok(DepNode::from_def_path_hash(def_path_hash, kind))\n-                } else {\n-                    Ok(DepNode::new_no_params(kind))\n-                }\n-            }\n-\n-            /// Used in testing\n-            fn has_label_string(label: &str) -> bool {\n-                match label {\n-                    $(\n-                        stringify!($variant) => true,\n-                    )*\n-                    _ => false,\n-                }\n+        fn dep_kind_from_label_string(label: &str) -> Result<DepKind, ()> {\n+            match label {\n+                $(stringify!($variant) => Ok(DepKind::$variant),)*\n+                _ => Err(()),\n             }\n         }\n \n@@ -312,8 +387,110 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [] CompileCodegenUnit(Symbol),\n ]);\n \n+pub type DepNode = rustc_query_system::dep_graph::DepNode<DepKind>;\n+\n+// We keep a lot of `DepNode`s in memory during compilation. It's not\n+// required that their size stay the same, but we don't want to change\n+// it inadvertently. This assert just ensures we're aware of any change.\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+static_assert_size!(DepNode, 17);\n+\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+static_assert_size!(DepNode, 24);\n+\n+pub trait DepNodeExt: Sized {\n+    /// Construct a DepNode from the given DepKind and DefPathHash. This\n+    /// method will assert that the given DepKind actually requires a\n+    /// single DefId/DefPathHash parameter.\n+    fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> Self;\n+\n+    /// Extracts the DefId corresponding to this DepNode. This will work\n+    /// if two conditions are met:\n+    ///\n+    /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+    /// 2. the item that the DefPath refers to exists in the current tcx.\n+    ///\n+    /// Condition (1) is determined by the DepKind variant of the\n+    /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+    /// refers to something from the previous compilation session that\n+    /// has been removed.\n+    fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId>;\n+\n+    /// Used in testing\n+    fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<Self, ()>;\n+\n+    /// Used in testing\n+    fn has_label_string(label: &str) -> bool;\n+}\n+\n+impl DepNodeExt for DepNode {\n+    /// Construct a DepNode from the given DepKind and DefPathHash. This\n+    /// method will assert that the given DepKind actually requires a\n+    /// single DefId/DefPathHash parameter.\n+    fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n+        debug_assert!(kind.can_reconstruct_query_key() && kind.has_params);\n+        DepNode { kind, hash: def_path_hash.0.into() }\n+    }\n+\n+    /// Extracts the DefId corresponding to this DepNode. This will work\n+    /// if two conditions are met:\n+    ///\n+    /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+    /// 2. the item that the DefPath refers to exists in the current tcx.\n+    ///\n+    /// Condition (1) is determined by the DepKind variant of the\n+    /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+    /// refers to something from the previous compilation session that\n+    /// has been removed.\n+    fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n+        if self.kind.can_reconstruct_query_key() {\n+            tcx.queries\n+                .on_disk_cache\n+                .as_ref()?\n+                .def_path_hash_to_def_id(tcx, DefPathHash(self.hash.into()))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Used in testing\n+    fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<DepNode, ()> {\n+        let kind = dep_kind_from_label_string(label)?;\n+\n+        if !kind.can_reconstruct_query_key() {\n+            return Err(());\n+        }\n+\n+        if kind.has_params {\n+            Ok(DepNode::from_def_path_hash(def_path_hash, kind))\n+        } else {\n+            Ok(DepNode::new_no_params(kind))\n+        }\n+    }\n+\n+    /// Used in testing\n+    fn has_label_string(label: &str) -> bool {\n+        dep_kind_from_label_string(label).is_ok()\n+    }\n+}\n+\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for () {\n+    #[inline(always)]\n+    fn can_reconstruct_query_key() -> bool {\n+        true\n+    }\n+\n+    fn to_fingerprint(&self, _: TyCtxt<'tcx>) -> Fingerprint {\n+        Fingerprint::ZERO\n+    }\n+\n+    fn recover(_: TyCtxt<'tcx>, _: &DepNode) -> Option<Self> {\n+        Some(())\n+    }\n+}\n+\n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n-    #[inline]\n+    #[inline(always)]\n     fn can_reconstruct_query_key() -> bool {\n         true\n     }\n@@ -342,7 +519,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n-    #[inline]\n+    #[inline(always)]\n     fn can_reconstruct_query_key() -> bool {\n         true\n     }\n@@ -361,7 +538,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n-    #[inline]\n+    #[inline(always)]\n     fn can_reconstruct_query_key() -> bool {\n         true\n     }\n@@ -381,7 +558,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n-    #[inline]\n+    #[inline(always)]\n     fn can_reconstruct_query_key() -> bool {\n         false\n     }\n@@ -406,7 +583,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for HirId {\n-    #[inline]\n+    #[inline(always)]\n     fn can_reconstruct_query_key() -> bool {\n         false\n     }"}, {"sha": "22e9cc1cd3ee42e702d12baa622e59bfe06238c7", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=26438b473883ea607b30288e461187f0fb2fe589", "patch": "@@ -1,5 +1,4 @@\n use crate::ich::StableHashingContext;\n-use crate::ty::query::try_load_from_on_disk_cache;\n use crate::ty::{self, TyCtxt};\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n@@ -9,13 +8,12 @@ use rustc_hir::def_id::LocalDefId;\n \n mod dep_node;\n \n-pub(crate) use rustc_query_system::dep_graph::DepNodeParams;\n pub use rustc_query_system::dep_graph::{\n     debug, hash_result, DepContext, DepNodeColor, DepNodeIndex, SerializedDepNodeIndex,\n     WorkProduct, WorkProductId,\n };\n \n-pub use dep_node::{label_strs, DepConstructor, DepKind, DepNode, DepNodeExt};\n+pub use dep_node::{dep_constructor, label_strs, DepKind, DepNode, DepNodeExt};\n \n pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;\n@@ -26,18 +24,25 @@ pub type SerializedDepGraph = rustc_query_system::dep_graph::SerializedDepGraph<\n impl rustc_query_system::dep_graph::DepKind for DepKind {\n     const NULL: Self = DepKind::Null;\n \n+    #[inline(always)]\n+    fn can_reconstruct_query_key(&self) -> bool {\n+        DepKind::can_reconstruct_query_key(self)\n+    }\n+\n+    #[inline(always)]\n     fn is_eval_always(&self) -> bool {\n-        DepKind::is_eval_always(self)\n+        self.is_eval_always\n     }\n \n+    #[inline(always)]\n     fn has_params(&self) -> bool {\n-        DepKind::has_params(self)\n+        self.has_params\n     }\n \n     fn debug_node(node: &DepNode, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         write!(f, \"{:?}\", node.kind)?;\n \n-        if !node.kind.has_params() && !node.kind.is_anon() {\n+        if !node.kind.has_params && !node.kind.is_anon {\n             return Ok(());\n         }\n \n@@ -81,10 +86,6 @@ impl rustc_query_system::dep_graph::DepKind for DepKind {\n             op(icx.task_deps)\n         })\n     }\n-\n-    fn can_reconstruct_query_key(&self) -> bool {\n-        DepKind::can_reconstruct_query_key(self)\n-    }\n }\n \n impl<'tcx> DepContext for TyCtxt<'tcx> {\n@@ -153,7 +154,26 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n         }\n \n         debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n-        ty::query::force_from_dep_node(*self, dep_node)\n+\n+        // We must avoid ever having to call `force_from_dep_node()` for a\n+        // `DepNode::codegen_unit`:\n+        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+        // would always end up having to evaluate the first caller of the\n+        // `codegen_unit` query that *is* reconstructible. This might very well be\n+        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+        // to re-trigger calling the `codegen_unit` query with the right key. At\n+        // that point we would already have re-done all the work we are trying to\n+        // avoid doing in the first place.\n+        // The solution is simple: Just explicitly call the `codegen_unit` query for\n+        // each CGU, right after partitioning. This way `try_mark_green` will always\n+        // hit the cache instead of having to go through `force_from_dep_node`.\n+        // This assertion makes sure, we actually keep applying the solution above.\n+        debug_assert!(\n+            dep_node.kind != DepKind::codegen_unit,\n+            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+        );\n+\n+        (dep_node.kind.force_from_dep_node)(*self, dep_node)\n     }\n \n     fn has_errors_or_delayed_span_bugs(&self) -> bool {\n@@ -166,7 +186,7 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n \n     // Interactions with on_disk_cache\n     fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n-        try_load_from_on_disk_cache(*self, dep_node)\n+        (dep_node.kind.try_load_from_on_disk_cache)(*self, dep_node)\n     }\n \n     fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic> {"}, {"sha": "698c25215968b855faa3d810145dd9c97e355f5a", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=26438b473883ea607b30288e461187f0fb2fe589", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{DepConstructor, DepNode, WorkProduct, WorkProductId};\n+use crate::dep_graph::{dep_constructor, DepNode, WorkProduct, WorkProductId};\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::ty::{subst::InternalSubsts, Instance, InstanceDef, SymbolName, TyCtxt};\n use rustc_data_structures::base_n;\n@@ -358,7 +358,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn codegen_dep_node(&self, tcx: TyCtxt<'tcx>) -> DepNode {\n-        DepConstructor::CompileCodegenUnit(tcx, self.name())\n+        dep_constructor::CompileCodegenUnit(tcx, self.name())\n     }\n }\n "}, {"sha": "acfa58e511ed1f030890901da29a888bf10578ca", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 133, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=26438b473883ea607b30288e461187f0fb2fe589", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{self, DepKind, DepNode, DepNodeParams};\n+use crate::dep_graph;\n use crate::hir::exports::Export;\n use crate::hir::map;\n use crate::infer::canonical::{self, Canonical};\n@@ -103,138 +103,6 @@ pub use self::profiling_support::{IntoSelfProfilingString, QueryKeyStringBuilder\n \n rustc_query_append! { [define_queries!][<'tcx>] }\n \n-/// The red/green evaluation system will try to mark a specific DepNode in the\n-/// dependency graph as green by recursively trying to mark the dependencies of\n-/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-/// where we don't know if it is red or green and we therefore actually have\n-/// to recompute its value in order to find out. Since the only piece of\n-/// information that we have at that point is the `DepNode` we are trying to\n-/// re-evaluate, we need some way to re-run a query from just that. This is what\n-/// `force_from_dep_node()` implements.\n-///\n-/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-/// is usually constructed by computing a stable hash of the query-key that the\n-/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-/// back from hash to query-key (since hash functions are not reversible). For\n-/// this reason `force_from_dep_node()` is expected to fail from time to time\n-/// because we just cannot find out, from the `DepNode` alone, what the\n-/// corresponding query-key is and therefore cannot re-run the query.\n-///\n-/// The system deals with this case letting `try_mark_green` fail which forces\n-/// the root query to be re-evaluated.\n-///\n-/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-/// Fortunately, we can use some contextual information that will allow us to\n-/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-/// valid `DefPathHash`. Since we also always build a huge table that maps every\n-/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-/// everything we need to re-run the query.\n-///\n-/// Take the `mir_promoted` query as an example. Like many other queries, it\n-/// just has a single parameter: the `DefId` of the item it will compute the\n-/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-/// `DefId` in `tcx.def_path_hash_to_def_id`.\n-///\n-/// When you implement a new query, it will likely have a corresponding new\n-/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n-/// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n-/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n-/// add it to the \"We don't have enough information to reconstruct...\" group in\n-/// the match below.\n-pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool {\n-    // We must avoid ever having to call `force_from_dep_node()` for a\n-    // `DepNode::codegen_unit`:\n-    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-    // would always end up having to evaluate the first caller of the\n-    // `codegen_unit` query that *is* reconstructible. This might very well be\n-    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-    // to re-trigger calling the `codegen_unit` query with the right key. At\n-    // that point we would already have re-done all the work we are trying to\n-    // avoid doing in the first place.\n-    // The solution is simple: Just explicitly call the `codegen_unit` query for\n-    // each CGU, right after partitioning. This way `try_mark_green` will always\n-    // hit the cache instead of having to go through `force_from_dep_node`.\n-    // This assertion makes sure, we actually keep applying the solution above.\n-    debug_assert!(\n-        dep_node.kind != DepKind::codegen_unit,\n-        \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-    );\n-\n-    if !dep_node.kind.can_reconstruct_query_key() {\n-        return false;\n-    }\n-\n-    macro_rules! force_from_dep_node {\n-        ($($(#[$attr:meta])* [$($modifiers:tt)*] $name:ident($K:ty),)*) => {\n-            match dep_node.kind {\n-                // These are inputs that are expected to be pre-allocated and that\n-                // should therefore always be red or green already.\n-                DepKind::CrateMetadata |\n-\n-                // These are anonymous nodes.\n-                DepKind::TraitSelect |\n-\n-                // We don't have enough information to reconstruct the query key of\n-                // these.\n-                DepKind::CompileCodegenUnit |\n-\n-                // Forcing this makes no sense.\n-                DepKind::Null => {\n-                    bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n-                }\n-\n-                $(DepKind::$name => {\n-                    debug_assert!(<$K as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key());\n-\n-                    if let Some(key) = <$K as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node) {\n-                        force_query::<queries::$name<'_>, _>(\n-                            tcx,\n-                            key,\n-                            DUMMY_SP,\n-                            *dep_node\n-                        );\n-                        return true;\n-                    }\n-                })*\n-            }\n-        }\n-    }\n-\n-    rustc_dep_node_append! { [force_from_dep_node!][] }\n-\n-    false\n-}\n-\n-pub(crate) fn try_load_from_on_disk_cache<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) {\n-    macro_rules! try_load_from_on_disk_cache {\n-        ($($name:ident,)*) => {\n-            match dep_node.kind {\n-                $(DepKind::$name => {\n-                    if <query_keys::$name<'tcx> as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key() {\n-                        debug_assert!(tcx.dep_graph\n-                                         .node_color(dep_node)\n-                                         .map(|c| c.is_green())\n-                                         .unwrap_or(false));\n-\n-                        let key = <query_keys::$name<'tcx> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n-                        if queries::$name::cache_on_disk(tcx, &key, None) {\n-                            let _ = tcx.$name(key);\n-                        }\n-                    }\n-                })*\n-\n-                _ => (),\n-            }\n-        }\n-    }\n-\n-    rustc_cached_queries!(try_load_from_on_disk_cache!);\n-}\n-\n mod sealed {\n     use super::{DefId, LocalDefId};\n "}, {"sha": "64aba870502c77453f7d24881b1edf8099533a65", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=26438b473883ea607b30288e461187f0fb2fe589", "patch": "@@ -153,12 +153,6 @@ where\n     }\n }\n \n-impl<Ctxt: DepContext> DepNodeParams<Ctxt> for () {\n-    fn to_fingerprint(&self, _: Ctxt) -> Fingerprint {\n-        Fingerprint::ZERO\n-    }\n-}\n-\n /// A \"work product\" corresponds to a `.o` (or other) file that we\n /// save in between runs. These IDs do not have a `DefId` but rather\n /// some independent path or string that persists between runs without"}, {"sha": "b1c901633a71b24eb4ce891c5ebbacb8bbd43b82", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26438b473883ea607b30288e461187f0fb2fe589/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=26438b473883ea607b30288e461187f0fb2fe589", "patch": "@@ -61,7 +61,7 @@ pub trait DepContext: Copy {\n }\n \n /// Describe the different families of dependency nodes.\n-pub trait DepKind: Copy + fmt::Debug + Eq + Ord + Hash {\n+pub trait DepKind: Copy + fmt::Debug + Eq + Hash {\n     const NULL: Self;\n \n     /// Return whether this kind always require evaluation."}]}