{"sha": "2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkOTBiOTFiNWQyZDE4Y2Q0MzNhOWU2ZjE5NDRiNjg1ZjhiNGJiMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-13T03:07:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-13T03:07:17Z"}, "message": "auto merge of #19683 : nikomatsakis/rust/generalized-where-clauses, r=nrc\n\nThis patch does not itself enable generalized where clauses, but it lays the groundwork. Rather than storing a list of bounds per type parameter, the trait selection and other logic is now driven by a unified list of predicates. All predicate handling is now driven through a common interface. This also fixes a number of bugs where region predicates were being dropped on the floor. As a drive-by, this patch also fixes some bugs in the opt-out-copy feature flag.\r\n\r\nThat said, this patch does not change the parser or AST in any way, so we still *generate* the list of predicates by walking a list of bounds (and we still *store* the bounds on the `TypeParameterDef` and so on). Those will get patched in a follow-up.\r\n\r\nThe commits in this case are standalone; the first few are simple refactorings.\r\n\r\nr? @nick29581 \r\ncc @aturon", "tree": {"sha": "4505a743df61f423226618ea002c87faccb9891b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4505a743df61f423226618ea002c87faccb9891b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "html_url": "https://github.com/rust-lang/rust/commit/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c6692724242c93416e574a48c5ea51b2e95d461", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c6692724242c93416e574a48c5ea51b2e95d461", "html_url": "https://github.com/rust-lang/rust/commit/8c6692724242c93416e574a48c5ea51b2e95d461"}, {"sha": "124e1e18cc4f327730a978a7a8c1e7876bb63c6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/124e1e18cc4f327730a978a7a8c1e7876bb63c6e", "html_url": "https://github.com/rust-lang/rust/commit/124e1e18cc4f327730a978a7a8c1e7876bb63c6e"}], "stats": {"total": 2520, "additions": 1440, "deletions": 1080}, "files": [{"sha": "2b92ae8af0ab2d3d29ed2b73dbf47812038b495e", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -19,7 +19,7 @@\n \n /// Types able to be transferred across task boundaries.\n #[lang=\"send\"]\n-pub trait Send for Sized? {\n+pub trait Send for Sized? : 'static {\n     // empty.\n }\n "}, {"sha": "fcac718b3708cbf1576ff7ddf4979975563104d3", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -40,89 +40,8 @@ register_diagnostics!(\n     E0019,\n     E0020,\n     E0022,\n-    E0023,\n-    E0024,\n-    E0025,\n-    E0026,\n-    E0027,\n-    E0029,\n-    E0030,\n-    E0031,\n-    E0033,\n-    E0034,\n-    E0035,\n-    E0036,\n-    E0038,\n-    E0040,\n-    E0044,\n-    E0045,\n-    E0046,\n-    E0049,\n-    E0050,\n-    E0051,\n-    E0052,\n-    E0053,\n-    E0054,\n-    E0055,\n-    E0056,\n-    E0057,\n-    E0059,\n-    E0060,\n-    E0061,\n-    E0062,\n-    E0063,\n-    E0066,\n-    E0067,\n-    E0068,\n-    E0069,\n-    E0070,\n-    E0071,\n-    E0072,\n-    E0073,\n-    E0074,\n-    E0075,\n-    E0076,\n-    E0077,\n-    E0079,\n-    E0080,\n-    E0081,\n-    E0082,\n-    E0083,\n-    E0084,\n-    E0085,\n-    E0086,\n-    E0087,\n-    E0088,\n-    E0089,\n-    E0090,\n-    E0091,\n-    E0092,\n-    E0093,\n-    E0094,\n-    E0100,\n-    E0101,\n-    E0102,\n-    E0103,\n-    E0104,\n-    E0106,\n-    E0107,\n-    E0108,\n     E0109,\n     E0110,\n-    E0116,\n-    E0117,\n-    E0118,\n-    E0119,\n-    E0120,\n-    E0121,\n-    E0122,\n-    E0124,\n-    E0127,\n-    E0128,\n-    E0129,\n-    E0130,\n-    E0131,\n-    E0132,\n     E0133,\n     E0134,\n     E0135,\n@@ -131,16 +50,12 @@ register_diagnostics!(\n     E0138,\n     E0139,\n     E0140,\n-    E0141,\n     E0152,\n     E0153,\n     E0157,\n     E0158,\n-    E0159,\n     E0161,\n     E0162,\n-    E0163,\n-    E0164,\n     E0165,\n     E0166,\n     E0167,"}, {"sha": "99e7966b66f684556a2119b8cbe3010cbe4ce38b", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -251,3 +251,7 @@ pub const tag_type_param_def: uint = 0xa5;\n \n pub const tag_item_generics: uint = 0xa6;\n pub const tag_method_ty_generics: uint = 0xa7;\n+\n+pub const tag_predicate: uint = 0xa8;\n+pub const tag_predicate_space: uint = 0xa9;\n+pub const tag_predicate_data: uint = 0xb0;"}, {"sha": "7ce9893afc8b1cf5b3b1145f2ea44bd1c5a7dbf1", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -21,7 +21,6 @@ use middle::def;\n use middle::lang_items;\n use middle::resolve;\n use middle::ty;\n-use middle::subst::VecPerParamSpace;\n \n use rbml;\n use rbml::reader;\n@@ -250,9 +249,8 @@ pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n         });\n     let ty = decoder::item_type(def, the_field, tcx, &*cdata);\n     ty::Polytype {\n-        generics: ty::Generics {types: VecPerParamSpace::empty(),\n-                                regions: VecPerParamSpace::empty()},\n-        ty: ty\n+        generics: ty::Generics::empty(),\n+        ty: ty,\n     }\n }\n "}, {"sha": "898f5d2ef93ca2b4c8540d173ec69b271eab271a", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -23,7 +23,8 @@ use metadata::csearch;\n use metadata::cstore;\n use metadata::tydecode::{parse_ty_data, parse_region_data, parse_def_id,\n                          parse_type_param_def_data, parse_bounds_data,\n-                         parse_bare_fn_ty_data, parse_trait_ref_data};\n+                         parse_bare_fn_ty_data, parse_trait_ref_data,\n+                         parse_predicate_data};\n use middle::def;\n use middle::lang_items;\n use middle::resolve::{TraitItemKind, TypeTraitItemKind};\n@@ -1437,7 +1438,20 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         true\n     });\n \n-    ty::Generics { types: types, regions: regions }\n+    let mut predicates = subst::VecPerParamSpace::empty();\n+    reader::tagged_docs(doc, tag_predicate, |predicate_doc| {\n+        let space_doc = reader::get_doc(predicate_doc, tag_predicate_space);\n+        let space = subst::ParamSpace::from_uint(reader::doc_as_u8(space_doc) as uint);\n+\n+        let data_doc = reader::get_doc(predicate_doc, tag_predicate_data);\n+        let data = parse_predicate_data(data_doc.data, data_doc.start, cdata.cnum, tcx,\n+                                        |_, did| translate_def_id(cdata, did));\n+\n+        predicates.push(space, data);\n+        true\n+    });\n+\n+    ty::Generics { types: types, regions: regions, predicates: predicates }\n }\n \n pub fn is_associated_type(cdata: Cmd, id: ast::NodeId) -> bool {"}, {"sha": "48d1284f507873d8f911945caa8a4e3328893abf", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -803,6 +803,18 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n     }\n \n+    for (space, _, predicate) in generics.predicates.iter_enumerated() {\n+        rbml_w.start_tag(tag_predicate);\n+\n+        rbml_w.wr_tagged_u8(tag_predicate_space, space as u8);\n+\n+        rbml_w.start_tag(tag_predicate_data);\n+        tyencode::enc_predicate(rbml_w.writer, ty_str_ctxt, predicate);\n+        rbml_w.end_tag();\n+\n+        rbml_w.end_tag();\n+    }\n+\n     rbml_w.end_tag();\n }\n "}, {"sha": "37d790df37f46aaeb75cd9d5848e38bd677eb5c7", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -470,7 +470,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n         st.tcx.rcache.borrow_mut().insert(key, tt);\n         return tt;\n       }\n-      '\"' => {\n+      '\\\"' => {\n         let _ = parse_def(st, TypeWithId, |x,y| conv(x,y));\n         let inner = parse_ty(st, |x,y| conv(x,y));\n         inner\n@@ -646,6 +646,33 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     ast::DefId { krate: crate_num, node: def_num }\n }\n \n+pub fn parse_predicate_data<'tcx>(data: &[u8],\n+                                  start: uint,\n+                                  crate_num: ast::CrateNum,\n+                                  tcx: &ty::ctxt<'tcx>,\n+                                  conv: conv_did)\n+                                  -> ty::Predicate<'tcx>\n+{\n+    let mut st = parse_state_from_data(data, crate_num, start, tcx);\n+    parse_predicate(&mut st, conv)\n+}\n+\n+pub fn parse_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>,\n+                                conv: conv_did)\n+                                -> ty::Predicate<'tcx>\n+{\n+    match next(st) {\n+        't' => ty::Predicate::Trait(Rc::new(parse_trait_ref(st, conv))),\n+        'e' => ty::Predicate::Equate(parse_ty(st, |x,y| conv(x,y)),\n+                                     parse_ty(st, |x,y| conv(x,y))),\n+        'r' => ty::Predicate::RegionOutlives(parse_region(st, |x,y| conv(x,y)),\n+                                             parse_region(st, |x,y| conv(x,y))),\n+        'o' => ty::Predicate::TypeOutlives(parse_ty(st, |x,y| conv(x,y)),\n+                                           parse_region(st, |x,y| conv(x,y))),\n+        c => panic!(\"Encountered invalid character in metadata: {}\", c)\n+    }\n+}\n+\n pub fn parse_type_param_def_data<'tcx>(data: &[u8], start: uint,\n                                        crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n                                        conv: conv_did) -> ty::TypeParameterDef<'tcx>"}, {"sha": "5c7d15e16018b8ffd3bbb92e42909a74e8111c69", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -413,3 +413,30 @@ pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tc\n     enc_bounds(w, cx, &v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n }\n+\n+pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n+                               cx: &ctxt<'a, 'tcx>,\n+                               p: &ty::Predicate<'tcx>)\n+{\n+    match *p {\n+        ty::Predicate::Trait(ref trait_ref) => {\n+            mywrite!(w, \"t\");\n+            enc_trait_ref(w, cx, &**trait_ref);\n+        }\n+        ty::Predicate::Equate(a, b) => {\n+            mywrite!(w, \"e\");\n+            enc_ty(w, cx, a);\n+            enc_ty(w, cx, b);\n+        }\n+        ty::Predicate::RegionOutlives(a, b) => {\n+            mywrite!(w, \"r\");\n+            enc_region(w, cx, a);\n+            enc_region(w, cx, b);\n+        }\n+        ty::Predicate::TypeOutlives(a, b) => {\n+            mywrite!(w, \"o\");\n+            enc_ty(w, cx, a);\n+            enc_region(w, cx, b);\n+        }\n+    }\n+}"}, {"sha": "50337ec25bd19dfd7bf96036af5dc52d8efb2b7a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -830,6 +830,8 @@ trait rbml_writer_helpers<'tcx> {\n     fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n     fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                type_param_def: &ty::TypeParameterDef<'tcx>);\n+    fn emit_predicate<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                          predicate: &ty::Predicate<'tcx>);\n     fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                           ty: &ty::TraitRef<'tcx>);\n     fn emit_polytype<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n@@ -936,6 +938,15 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n+    fn emit_predicate<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                          predicate: &ty::Predicate<'tcx>) {\n+        self.emit_opaque(|this| {\n+            Ok(tyencode::enc_predicate(this.writer,\n+                                       &ecx.ty_str_ctxt(),\n+                                       predicate))\n+        });\n+    }\n+\n     fn emit_polytype<'a>(&mut self,\n                          ecx: &e::EncodeContext<'a, 'tcx>,\n                          pty: ty::Polytype<'tcx>) {\n@@ -953,6 +964,11 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                         Ok(encode_vec_per_param_space(\n                             this, &pty.generics.regions,\n                             |this, def| def.encode(this).unwrap()))\n+                    });\n+                    this.emit_struct_field(\"predicates\", 2, |this| {\n+                        Ok(encode_vec_per_param_space(\n+                            this, &pty.generics.predicates,\n+                            |this, def| this.emit_predicate(ecx, def)))\n                     })\n                 })\n             });\n@@ -1336,6 +1352,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                               -> Rc<ty::TraitRef<'tcx>>;\n     fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx>;\n+    fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                              -> ty::Predicate<'tcx>;\n     fn read_polytype<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                              -> ty::Polytype<'tcx>;\n     fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1536,6 +1554,15 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n+    fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                              -> ty::Predicate<'tcx>\n+    {\n+        self.read_opaque(|this, doc| {\n+            Ok(tydecode::parse_predicate_data(doc.data, doc.start, dcx.cdata.cnum, dcx.tcx,\n+                                              |s, a| this.convert_def_id(dcx, s, a)))\n+        }).unwrap()\n+    }\n+\n     fn read_polytype<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                              -> ty::Polytype<'tcx> {\n         self.read_struct(\"Polytype\", 2, |this| {\n@@ -1553,7 +1580,13 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                             this.read_struct_field(\"regions\", 1, |this| {\n                                 Ok(this.read_vec_per_param_space(\n                                     |this| Decodable::decode(this).unwrap()))\n-                            }).unwrap()\n+                            }).unwrap(),\n+\n+                            predicates:\n+                            this.read_struct_field(\"predicates\", 2, |this| {\n+                                Ok(this.read_vec_per_param_space(\n+                                    |this| this.read_predicate(dcx)))\n+                            }).unwrap(),\n                         })\n                     })\n                 }).unwrap(),"}, {"sha": "5a53979d719324edccf24940d1c0241717d9ce4f", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -31,12 +31,13 @@ use middle::infer;\n use middle::traits;\n use middle::mem_categorization as mc;\n use middle::expr_use_visitor as euv;\n+use util::common::ErrorReported;\n use util::nodemap::NodeSet;\n \n use syntax::ast;\n use syntax::print::pprust;\n use syntax::visit::Visitor;\n-use syntax::codemap::{DUMMY_SP, Span};\n+use syntax::codemap::Span;\n use syntax::visit;\n \n #[deriving(Eq, PartialEq)]\n@@ -119,15 +120,17 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         let ty = ty::node_id_to_type(self.tcx, e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n-        let cause = traits::ObligationCause::misc(DUMMY_SP);\n-        let obligation = traits::obligation_for_builtin_bound(self.tcx, cause, ty,\n-                                                              ty::BoundSync);\n-        fulfill_cx.register_obligation(self.tcx, obligation.unwrap());\n-        let env = ty::empty_parameter_environment();\n-        let result = fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok();\n-        if !result {\n-            self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n-                                            type which implements Sync\");\n+        match traits::trait_ref_for_builtin_bound(self.tcx, ty::BoundSync, ty) {\n+            Ok(trait_ref) => {\n+                fulfill_cx.register_trait_ref(self.tcx, trait_ref,\n+                                              traits::ObligationCause::dummy());\n+                let env = ty::empty_parameter_environment();\n+                if !fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok() {\n+                    self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n+                                                    type which implements Sync\");\n+                }\n+            }\n+            Err(ErrorReported) => { }\n         }\n     }\n }"}, {"sha": "e2a57629d7eb9c39befcc1ef2f1cadf776958066", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -366,6 +366,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::MatchExpressionArm(_, _) => \"match arms have incompatible types\",\n             infer::IfExpression(_) => \"if and else have incompatible types\",\n             infer::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n+            infer::EquatePredicate(_) => \"equality predicate not satisfied\",\n         };\n \n         self.tcx.sess.span_err(\n@@ -1523,6 +1524,9 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     infer::IfExpressionWithNoElse(_) => {\n                         format!(\"if may be missing an else clause\")\n                     }\n+                    infer::EquatePredicate(_) => {\n+                        format!(\"equality where clause is satisfied\")\n+                    }\n                 };\n \n                 match self.values_str(&trace.values) {"}, {"sha": "3b62b96a3e9b1f34187ea56bb7fca0270c8981da", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -129,7 +129,10 @@ pub enum TypeOrigin {\n     IfExpression(Span),\n \n     // Computing common supertype of an if expression with no else counter-part\n-    IfExpressionWithNoElse(Span)\n+    IfExpressionWithNoElse(Span),\n+\n+    // `where a == b`\n+    EquatePredicate(Span),\n }\n \n impl Copy for TypeOrigin {}\n@@ -1017,7 +1020,8 @@ impl TypeOrigin {\n             RelateOutputImplTypes(span) => span,\n             MatchExpressionArm(match_span, _) => match_span,\n             IfExpression(span) => span,\n-            IfExpressionWithNoElse(span) => span\n+            IfExpressionWithNoElse(span) => span,\n+            EquatePredicate(span) => span,\n         }\n     }\n }\n@@ -1050,6 +1054,9 @@ impl<'tcx> Repr<'tcx> for TypeOrigin {\n             IfExpressionWithNoElse(a) => {\n                 format!(\"IfExpressionWithNoElse({})\", a.repr(tcx))\n             }\n+            EquatePredicate(a) => {\n+                format!(\"EquatePredicate({})\", a.repr(tcx))\n+            }\n         }\n     }\n }"}, {"sha": "822979c86017b22aa2fc81af6c0ffcda5d59d032", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -11,7 +11,7 @@\n //! See `doc.rs` for high-level documentation\n \n use super::SelectionContext;\n-use super::Obligation;\n+use super::{Obligation, ObligationCause};\n use super::util;\n \n use middle::subst;\n@@ -48,7 +48,7 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n     // same types.\n     let param_env = ty::empty_parameter_environment();\n     let mut selcx = SelectionContext::intercrate(infcx, &param_env, infcx.tcx);\n-    let obligation = Obligation::misc(DUMMY_SP, impl1_trait_ref);\n+    let obligation = Obligation::new(ObligationCause::dummy(), impl1_trait_ref);\n     debug!(\"impl_can_satisfy(obligation={})\", obligation.repr(infcx.tcx));\n     selcx.evaluate_impl(impl2_def_id, &obligation)\n }"}, {"sha": "412c188f5f4ae04d8862bdc69b009c4880440aca", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 229, "deletions": 52, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -9,17 +9,27 @@\n // except according to those terms.\n \n use middle::mem_categorization::Typer;\n-use middle::ty;\n-use middle::infer::InferCtxt;\n+use middle::ty::{mod, Ty};\n+use middle::infer::{mod, InferCtxt};\n use std::collections::HashSet;\n+use std::collections::hash_map::{Occupied, Vacant};\n+use std::default::Default;\n use std::rc::Rc;\n+use syntax::ast;\n+use util::common::ErrorReported;\n use util::ppaux::Repr;\n+use util::nodemap::NodeMap;\n \n use super::CodeAmbiguity;\n-use super::Obligation;\n-use super::FulfillmentError;\n use super::CodeSelectionError;\n+use super::FulfillmentError;\n+use super::Obligation;\n+use super::ObligationCause;\n+use super::PredicateObligation;\n+use super::Selection;\n use super::select::SelectionContext;\n+use super::trait_ref_for_builtin_bound;\n+use super::Unimplemented;\n \n /// The fulfillment context is used to drive trait resolution.  It\n /// consists of a list of obligations that must be (eventually)\n@@ -37,37 +47,118 @@ pub struct FulfillmentContext<'tcx> {\n     // than the `SelectionCache`: it avoids duplicate errors and\n     // permits recursive obligations, which are often generated from\n     // traits like `Send` et al.\n-    duplicate_set: HashSet<Rc<ty::TraitRef<'tcx>>>,\n+    duplicate_set: HashSet<ty::Predicate<'tcx>>,\n \n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    trait_obligations: Vec<Obligation<'tcx>>,\n+    predicates: Vec<PredicateObligation<'tcx>>,\n \n     // Remembers the count of trait obligations that we have already\n     // attempted to select. This is used to avoid repeating work\n     // when `select_new_obligations` is called.\n     attempted_mark: uint,\n+\n+    // A set of constraints that regionck must validate. Each\n+    // constraint has the form `T:'a`, meaning \"some type `T` must\n+    // outlive the lifetime 'a\". These constraints derive from\n+    // instantiated type parameters. So if you had a struct defined\n+    // like\n+    //\n+    //     struct Foo<T:'static> { ... }\n+    //\n+    // then in some expression `let x = Foo { ... }` it will\n+    // instantiate the type parameter `T` with a fresh type `$0`. At\n+    // the same time, it will record a region obligation of\n+    // `$0:'static`. This will get checked later by regionck. (We\n+    // can't generally check these things right away because we have\n+    // to wait until types are resolved.)\n+    //\n+    // These are stored in a map keyed to the id of the innermost\n+    // enclosing fn body / static initializer expression. This is\n+    // because the location where the obligation was incurred can be\n+    // relevant with respect to which sublifetime assumptions are in\n+    // place. The reason that we store under the fn-id, and not\n+    // something more fine-grained, is so that it is easier for\n+    // regionck to be sure that it has found *all* the region\n+    // obligations (otherwise, it's easy to fail to walk to a\n+    // particular node-id).\n+    region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n+}\n+\n+pub struct RegionObligation<'tcx> {\n+    pub sub_region: ty::Region,\n+    pub sup_type: Ty<'tcx>,\n+    pub cause: ObligationCause<'tcx>,\n }\n \n impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             duplicate_set: HashSet::new(),\n-            trait_obligations: Vec::new(),\n+            predicates: Vec::new(),\n             attempted_mark: 0,\n+            region_obligations: NodeMap::new(),\n         }\n     }\n \n-    pub fn register_obligation(&mut self,\n-                               tcx: &ty::ctxt<'tcx>,\n-                               obligation: Obligation<'tcx>)\n+    pub fn register_builtin_bound(&mut self,\n+                                  tcx: &ty::ctxt<'tcx>,\n+                                  ty: Ty<'tcx>,\n+                                  builtin_bound: ty::BuiltinBound,\n+                                  cause: ObligationCause<'tcx>)\n     {\n-        if self.duplicate_set.insert(obligation.trait_ref.clone()) {\n-            debug!(\"register_obligation({})\", obligation.repr(tcx));\n-            assert!(!obligation.trait_ref.has_escaping_regions());\n-            self.trait_obligations.push(obligation);\n-        } else {\n-            debug!(\"register_obligation({}) -- already seen, skip\", obligation.repr(tcx));\n+        match trait_ref_for_builtin_bound(tcx, builtin_bound, ty) {\n+            Ok(trait_ref) => {\n+                self.register_trait_ref(tcx, trait_ref, cause);\n+            }\n+            Err(ErrorReported) => { }\n+        }\n+    }\n+\n+    pub fn register_trait_ref<'a>(&mut self,\n+                                  tcx: &ty::ctxt<'tcx>,\n+                                  trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                                  cause: ObligationCause<'tcx>)\n+    {\n+        /*!\n+         * A convenience function for registering trait obligations.\n+         */\n+\n+        let trait_obligation = Obligation { cause: cause,\n+                                            recursion_depth: 0,\n+                                            trait_ref: ty::Predicate::Trait(trait_ref) };\n+        self.register_predicate(tcx, trait_obligation)\n+    }\n+\n+    pub fn register_region_obligation(&mut self,\n+                                      tcx: &ty::ctxt<'tcx>,\n+                                      t_a: Ty<'tcx>,\n+                                      r_b: ty::Region,\n+                                      cause: ObligationCause<'tcx>)\n+    {\n+        register_region_obligation(tcx, t_a, r_b, cause, &mut self.region_obligations);\n+    }\n+\n+    pub fn register_predicate<'a>(&mut self,\n+                                  tcx: &ty::ctxt<'tcx>,\n+                                  predicate: PredicateObligation<'tcx>)\n+    {\n+        if !self.duplicate_set.insert(predicate.trait_ref.clone()) {\n+            debug!(\"register_predicate({}) -- already seen, skip\", predicate.repr(tcx));\n+            return;\n+        }\n+\n+        debug!(\"register_predicate({})\", predicate.repr(tcx));\n+        self.predicates.push(predicate);\n+    }\n+\n+    pub fn region_obligations(&self,\n+                              body_id: ast::NodeId)\n+                              -> &[RegionObligation<'tcx>]\n+    {\n+        match self.region_obligations.get(&body_id) {\n+            None => Default::default(),\n+            Some(vec) => vec.as_slice(),\n         }\n     }\n \n@@ -81,7 +172,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         // Anything left is ambiguous.\n         let errors: Vec<FulfillmentError> =\n-            self.trait_obligations\n+            self.predicates\n             .iter()\n             .map(|o| FulfillmentError::new((*o).clone(), CodeAmbiguity))\n             .collect();\n@@ -117,8 +208,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         self.select(&mut selcx, false)\n     }\n \n-    pub fn pending_trait_obligations(&self) -> &[Obligation<'tcx>] {\n-        self.trait_obligations[]\n+    pub fn pending_obligations(&self) -> &[PredicateObligation<'tcx>] {\n+        self.predicates[]\n     }\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n@@ -129,14 +220,14 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                   -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         debug!(\"select({} obligations, only_new_obligations={}) start\",\n-               self.trait_obligations.len(),\n+               self.predicates.len(),\n                only_new_obligations);\n \n         let tcx = selcx.tcx();\n         let mut errors = Vec::new();\n \n         loop {\n-            let count = self.trait_obligations.len();\n+            let count = self.predicates.len();\n \n             debug!(\"select_where_possible({} obligations) iteration\",\n                    count);\n@@ -154,51 +245,39 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n             // First pass: walk each obligation, retaining\n             // only those that we cannot yet process.\n-            self.trait_obligations.retain(|obligation| {\n-                // Hack: Retain does not pass in the index, but we want\n-                // to avoid processing the first `start_count` entries.\n-                if skip > 0 {\n-                    skip -= 1;\n-                    true\n-                } else {\n-                    match selcx.select(obligation) {\n-                        Ok(None) => {\n-                            true\n-                        }\n-                        Ok(Some(s)) => {\n-                            selections.push(s);\n-                            false\n-                        }\n-                        Err(selection_err) => {\n-                            debug!(\"obligation: {} error: {}\",\n-                                   obligation.repr(tcx),\n-                                   selection_err.repr(tcx));\n-                            errors.push(FulfillmentError::new(\n-                                (*obligation).clone(),\n-                                CodeSelectionError(selection_err)));\n+            {\n+                let region_obligations = &mut self.region_obligations;\n+                self.predicates.retain(|predicate| {\n+                    // Hack: Retain does not pass in the index, but we want\n+                    // to avoid processing the first `start_count` entries.\n+                    let processed =\n+                        if skip == 0 {\n+                            process_predicate(selcx, predicate,\n+                                              &mut selections, &mut errors, region_obligations)\n+                        } else {\n+                            skip -= 1;\n                             false\n-                        }\n-                    }\n-                }\n-            });\n+                        };\n+                    !processed\n+                });\n+            }\n \n-            self.attempted_mark = self.trait_obligations.len();\n+            self.attempted_mark = self.predicates.len();\n \n-            if self.trait_obligations.len() == count {\n+            if self.predicates.len() == count {\n                 // Nothing changed.\n                 break;\n             }\n \n             // Now go through all the successful ones,\n             // registering any nested obligations for the future.\n             for selection in selections.into_iter() {\n-                selection.map_move_nested(\n-                    |o| self.register_obligation(tcx, o));\n+                selection.map_move_nested(|p| self.register_predicate(tcx, p));\n             }\n         }\n \n         debug!(\"select({} obligations, {} errors) done\",\n-               self.trait_obligations.len(),\n+               self.predicates.len(),\n                errors.len());\n \n         if errors.len() == 0 {\n@@ -208,3 +287,101 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n }\n+\n+fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                              predicate: &PredicateObligation<'tcx>,\n+                              selections: &mut Vec<Selection<'tcx>>,\n+                              errors: &mut Vec<FulfillmentError<'tcx>>,\n+                              region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n+                              -> bool\n+{\n+    /*!\n+     * Processes a predicate obligation and modifies the appropriate\n+     * output array with the successful/error result.  Returns `false`\n+     * if the predicate could not be processed due to insufficient\n+     * type inference.\n+     */\n+\n+    let tcx = selcx.tcx();\n+    match predicate.trait_ref {\n+        ty::Predicate::Trait(ref trait_ref) => {\n+            let trait_obligation = Obligation { cause: predicate.cause,\n+                                                recursion_depth: predicate.recursion_depth,\n+                                                trait_ref: trait_ref.clone() };\n+            match selcx.select(&trait_obligation) {\n+                Ok(None) => {\n+                    false\n+                }\n+                Ok(Some(s)) => {\n+                    selections.push(s);\n+                    true\n+                }\n+                Err(selection_err) => {\n+                    debug!(\"predicate: {} error: {}\",\n+                           predicate.repr(tcx),\n+                           selection_err.repr(tcx));\n+                    errors.push(\n+                        FulfillmentError::new(\n+                            predicate.clone(),\n+                            CodeSelectionError(selection_err)));\n+                    true\n+                }\n+            }\n+        }\n+\n+        ty::Predicate::Equate(a, b) => {\n+            let origin = infer::EquatePredicate(predicate.cause.span);\n+            match infer::mk_eqty(selcx.infcx(), false, origin, a, b) {\n+                Ok(()) => {\n+                    true\n+                }\n+                Err(_) => {\n+                    errors.push(\n+                        FulfillmentError::new(\n+                            predicate.clone(),\n+                            CodeSelectionError(Unimplemented)));\n+                    true\n+                }\n+            }\n+        }\n+\n+        ty::Predicate::RegionOutlives(r_a, r_b) => {\n+            let origin = infer::RelateRegionParamBound(predicate.cause.span);\n+            let () = infer::mk_subr(selcx.infcx(), origin, r_b, r_a); // `b : a` ==> `a <= b`\n+            true\n+        }\n+\n+        ty::Predicate::TypeOutlives(t_a, r_b) => {\n+            register_region_obligation(tcx, t_a, r_b, predicate.cause, region_obligations);\n+            true\n+        }\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for RegionObligation<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"RegionObligation(sub_region={}, sup_type={})\",\n+                self.sub_region.repr(tcx),\n+                self.sup_type.repr(tcx))\n+    }\n+}\n+\n+fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                    t_a: Ty<'tcx>,\n+                                    r_b: ty::Region,\n+                                    cause: ObligationCause<'tcx>,\n+                                    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n+{\n+    let region_obligation = RegionObligation { sup_type: t_a,\n+                                               sub_region: r_b,\n+                                               cause: cause };\n+\n+    debug!(\"register_region_obligation({})\",\n+           region_obligation.repr(tcx));\n+\n+    match region_obligations.entry(region_obligation.cause.body_id) {\n+        Vacant(entry) => { entry.set(vec![region_obligation]); },\n+        Occupied(mut entry) => { entry.get_mut().push(region_obligation); },\n+    }\n+\n+}"}, {"sha": "604a0607c0b4ce4ef36949c7523fc4e0236f721f", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 57, "deletions": 80, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -15,25 +15,25 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n-use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty::{mod, Ty};\n use middle::infer::InferCtxt;\n use std::rc::Rc;\n use std::slice::Items;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util::common::ErrorReported;\n \n-pub use self::fulfill::FulfillmentContext;\n+pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n+pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n-pub use self::util::transitive_bounds;\n pub use self::util::Supertraits;\n pub use self::util::search_trait_and_supertraits_from_bound;\n+pub use self::util::transitive_bounds;\n+pub use self::util::trait_ref_for_builtin_bound;\n \n mod coherence;\n mod fulfill;\n@@ -47,22 +47,32 @@ mod util;\n /// provides the required vtable, or else finding a bound that is in\n /// scope. The eventual result is usually a `Selection` (defined below).\n #[deriving(Clone)]\n-pub struct Obligation<'tcx> {\n+pub struct Obligation<'tcx, T> {\n     pub cause: ObligationCause<'tcx>,\n     pub recursion_depth: uint,\n-    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub trait_ref: T,\n }\n \n+pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n+pub type TraitObligation<'tcx> = Obligation<'tcx, Rc<ty::TraitRef<'tcx>>>;\n+\n /// Why did we incur this obligation? Used for error reporting.\n-#[deriving(Clone)]\n+#[deriving(Copy, Clone)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n+\n+    // The id of the fn body that triggered this obligation. This is\n+    // used for region obligations to determine the precise\n+    // environment in which the region obligation should be evaluated\n+    // (in particular, closures can add new assumptions). See the\n+    // field `region_obligations` of the `FulfillmentContext` for more\n+    // information.\n+    pub body_id: ast::NodeId,\n+\n     pub code: ObligationCauseCode<'tcx>\n }\n \n-impl<'tcx> Copy for ObligationCause<'tcx> {}\n-\n-#[deriving(Clone)]\n+#[deriving(Copy, Clone)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n@@ -86,7 +96,7 @@ pub enum ObligationCauseCode<'tcx> {\n \n     // Captures of variable the given id by a closure (span is the\n     // span of the closure)\n-    ClosureCapture(ast::NodeId, Span),\n+    ClosureCapture(ast::NodeId, Span, ty::BuiltinBound),\n \n     // Types of fields (other than the last) in a struct must be sized.\n     FieldSized,\n@@ -95,21 +105,21 @@ pub enum ObligationCauseCode<'tcx> {\n     ObjectSized,\n }\n \n-pub type Obligations<'tcx> = subst::VecPerParamSpace<Obligation<'tcx>>;\n-\n-impl<'tcx> Copy for ObligationCauseCode<'tcx> {}\n+pub type Obligations<'tcx, O> = subst::VecPerParamSpace<Obligation<'tcx, O>>;\n+pub type PredicateObligations<'tcx> = subst::VecPerParamSpace<PredicateObligation<'tcx>>;\n+pub type TraitObligations<'tcx> = subst::VecPerParamSpace<TraitObligation<'tcx>>;\n \n-pub type Selection<'tcx> = Vtable<'tcx, Obligation<'tcx>>;\n+pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n \n #[deriving(Clone,Show)]\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n     Overflow,\n-    OutputTypeParameterMismatch(Rc<ty::TraitRef<'tcx>>, ty::type_err<'tcx>)\n+    OutputTypeParameterMismatch(Rc<ty::TraitRef<'tcx>>, Rc<ty::TraitRef<'tcx>>, ty::type_err<'tcx>),\n }\n \n pub struct FulfillmentError<'tcx> {\n-    pub obligation: Obligation<'tcx>,\n+    pub obligation: PredicateObligation<'tcx>,\n     pub code: FulfillmentErrorCode<'tcx>\n }\n \n@@ -219,33 +229,6 @@ pub struct VtableParamData<'tcx> {\n     pub bound: Rc<ty::TraitRef<'tcx>>,\n }\n \n-/// Matches the self type of the inherent impl `impl_def_id`\n-/// against `self_ty` and returns the resulting resolution.  This\n-/// routine may modify the surrounding type context (for example,\n-/// it may unify variables).\n-pub fn select_inherent_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                     param_env: &ty::ParameterEnvironment<'tcx>,\n-                                     typer: &Typer<'tcx>,\n-                                     cause: ObligationCause<'tcx>,\n-                                     impl_def_id: ast::DefId,\n-                                     self_ty: Ty<'tcx>)\n-                                     -> SelectionResult<'tcx,\n-                                            VtableImplData<'tcx, Obligation<'tcx>>>\n-{\n-    // This routine is only suitable for inherent impls. This is\n-    // because it does not attempt to unify the output type parameters\n-    // from the trait ref against the values from the obligation.\n-    // (These things do not apply to inherent impls, for which there\n-    // is no trait ref nor obligation.)\n-    //\n-    // Matching against non-inherent impls should be done with\n-    // `try_resolve_obligation()`.\n-    assert!(ty::impl_trait_ref(infcx.tcx, impl_def_id).is_none());\n-\n-    let mut selcx = select::SelectionContext::new(infcx, param_env, typer);\n-    selcx.select_inherent_impl(impl_def_id, cause, self_ty)\n-}\n-\n /// True if neither the trait nor self type is local. Note that `impl_def_id` must refer to an impl\n /// of a trait, not an inherent impl.\n pub fn is_orphan_impl(tcx: &ty::ctxt,\n@@ -265,63 +248,56 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n     coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n }\n \n-/// Given generic bounds from an impl like:\n-///\n-///    impl<A:Foo, B:Bar+Qux> ...\n-///\n-/// along with the bindings for the types `A` and `B` (e.g., `<A=A0, B=B0>`), yields a result like\n-///\n-///    [[Foo for A0, Bar for B0, Qux for B0], [], []]\n-///\n-/// Expects that `generic_bounds` have already been fully substituted, late-bound regions liberated\n-/// and so forth, so that they are in the same namespace as `type_substs`.\n-pub fn obligations_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      cause: ObligationCause<'tcx>,\n-                                      generic_bounds: &ty::GenericBounds<'tcx>,\n-                                      type_substs: &subst::VecPerParamSpace<Ty<'tcx>>)\n-                                      -> subst::VecPerParamSpace<Obligation<'tcx>>\n-{\n-    util::obligations_for_generics(tcx, cause, 0, generic_bounds, type_substs)\n-}\n-\n-pub fn obligation_for_builtin_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                          cause: ObligationCause<'tcx>,\n-                                          source_ty: Ty<'tcx>,\n-                                          builtin_bound: ty::BuiltinBound)\n-                                          -> Result<Obligation<'tcx>, ErrorReported>\n+/// Creates predicate obligations from the generic bounds.\n+pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                     cause: ObligationCause<'tcx>,\n+                                     generic_bounds: &ty::GenericBounds<'tcx>)\n+                                     -> PredicateObligations<'tcx>\n {\n-    util::obligation_for_builtin_bound(tcx, cause, builtin_bound, 0, source_ty)\n+    util::predicates_for_generics(tcx, cause, 0, generic_bounds)\n }\n \n-impl<'tcx> Obligation<'tcx> {\n-    pub fn new(cause: ObligationCause<'tcx>, trait_ref: Rc<ty::TraitRef<'tcx>>)\n-               -> Obligation<'tcx> {\n+impl<'tcx,O> Obligation<'tcx,O> {\n+    pub fn new(cause: ObligationCause<'tcx>,\n+               trait_ref: O)\n+               -> Obligation<'tcx, O>\n+    {\n         Obligation { cause: cause,\n                      recursion_depth: 0,\n                      trait_ref: trait_ref }\n     }\n \n-    pub fn misc(span: Span, trait_ref: Rc<ty::TraitRef<'tcx>>) -> Obligation<'tcx> {\n-        Obligation::new(ObligationCause::misc(span), trait_ref)\n+    pub fn misc(span: Span, body_id: ast::NodeId, trait_ref: O) -> Obligation<'tcx, O> {\n+        Obligation::new(ObligationCause::misc(span, body_id), trait_ref)\n     }\n \n+    pub fn with<P>(&self, value: P) -> Obligation<'tcx,P> {\n+        Obligation { cause: self.cause.clone(),\n+                     recursion_depth: self.recursion_depth,\n+                     trait_ref: value }\n+    }\n+}\n+\n+impl<'tcx> Obligation<'tcx,Rc<ty::TraitRef<'tcx>>> {\n     pub fn self_ty(&self) -> Ty<'tcx> {\n         self.trait_ref.self_ty()\n     }\n }\n \n impl<'tcx> ObligationCause<'tcx> {\n-    pub fn new(span: Span, code: ObligationCauseCode<'tcx>)\n+    pub fn new(span: Span,\n+               body_id: ast::NodeId,\n+               code: ObligationCauseCode<'tcx>)\n                -> ObligationCause<'tcx> {\n-        ObligationCause { span: span, code: code }\n+        ObligationCause { span: span, body_id: body_id, code: code }\n     }\n \n-    pub fn misc(span: Span) -> ObligationCause<'tcx> {\n-        ObligationCause { span: span, code: MiscObligation }\n+    pub fn misc(span: Span, body_id: ast::NodeId) -> ObligationCause<'tcx> {\n+        ObligationCause { span: span, body_id: body_id, code: MiscObligation }\n     }\n \n     pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, code: MiscObligation }\n+        ObligationCause { span: DUMMY_SP, body_id: 0, code: MiscObligation }\n     }\n }\n \n@@ -406,7 +382,8 @@ impl<N> VtableBuiltinData<N> {\n }\n \n impl<'tcx> FulfillmentError<'tcx> {\n-    fn new(obligation: Obligation<'tcx>, code: FulfillmentErrorCode<'tcx>)\n+    fn new(obligation: PredicateObligation<'tcx>,\n+           code: FulfillmentErrorCode<'tcx>)\n            -> FulfillmentError<'tcx>\n     {\n         FulfillmentError { obligation: obligation, code: code }"}, {"sha": "88c70f5557c14af47c3d9cd3c933958e3c512752", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 165, "deletions": 116, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -17,9 +17,8 @@ use self::Candidate::*;\n use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n-use super::{Obligation, ObligationCause};\n-use super::{SelectionError, Unimplemented, Overflow,\n-            OutputTypeParameterMismatch};\n+use super::{PredicateObligation, Obligation, TraitObligation, ObligationCause};\n+use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure, VtableFnPointer};\n@@ -70,14 +69,14 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n }\n \n // A stack that walks back up the stack frame.\n-struct ObligationStack<'prev, 'tcx: 'prev> {\n-    obligation: &'prev Obligation<'tcx>,\n+struct TraitObligationStack<'prev, 'tcx: 'prev> {\n+    obligation: &'prev TraitObligation<'tcx>,\n \n     /// Trait ref from `obligation` but skolemized with the\n     /// selection-context's skolemizer. Used to check for recursion.\n     skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n-    previous: Option<&'prev ObligationStack<'prev, 'tcx>>\n+    previous: Option<&'prev TraitObligationStack<'prev, 'tcx>>\n }\n \n #[deriving(Clone)]\n@@ -191,6 +190,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'tcx> {\n+        self.infcx\n+    }\n+\n     pub fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -213,7 +216,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Evaluates whether the obligation can be satisfied. Returns an indication of whether the\n     /// obligation can be satisfied and, if so, by what means. Never affects surrounding typing\n     /// environment.\n-    pub fn select(&mut self, obligation: &Obligation<'tcx>)\n+    pub fn select(&mut self, obligation: &TraitObligation<'tcx>)\n                   -> SelectionResult<'tcx, Selection<'tcx>> {\n         debug!(\"select({})\", obligation.repr(self.tcx()));\n         assert!(!obligation.trait_ref.has_escaping_regions());\n@@ -225,29 +228,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    pub fn select_inherent_impl(&mut self,\n-                                impl_def_id: ast::DefId,\n-                                obligation_cause: ObligationCause<'tcx>,\n-                                obligation_self_ty: Ty<'tcx>)\n-                                -> SelectionResult<'tcx, VtableImplData<'tcx, Obligation<'tcx>>>\n-    {\n-        debug!(\"select_inherent_impl(impl_def_id={}, obligation_self_ty={})\",\n-               impl_def_id.repr(self.tcx()),\n-               obligation_self_ty.repr(self.tcx()));\n-\n-        match self.match_inherent_impl(impl_def_id,\n-                                       obligation_cause,\n-                                       obligation_self_ty) {\n-            Ok(substs) => {\n-                let vtable_impl = self.vtable_impl(impl_def_id, substs, obligation_cause, 0);\n-                Ok(Some(vtable_impl))\n-            }\n-            Err(()) => {\n-                Err(Unimplemented)\n-            }\n-        }\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // EVALUATION\n     //\n@@ -260,25 +240,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Evaluates whether the obligation `obligation` can be satisfied (by any means).\n     pub fn evaluate_obligation(&mut self,\n-                               obligation: &Obligation<'tcx>)\n+                               obligation: &PredicateObligation<'tcx>)\n                                -> bool\n     {\n         debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n-        assert!(!obligation.trait_ref.has_escaping_regions());\n \n-        let stack = self.push_stack(None, obligation);\n-        self.evaluate_stack(&stack).may_apply()\n+        self.evaluate_predicate_recursively(None, obligation).may_apply()\n     }\n \n     fn evaluate_builtin_bound_recursively<'o>(&mut self,\n                                               bound: ty::BuiltinBound,\n-                                              previous_stack: &ObligationStack<'o, 'tcx>,\n+                                              previous_stack: &TraitObligationStack<'o, 'tcx>,\n                                               ty: Ty<'tcx>)\n                                               -> EvaluationResult<'tcx>\n     {\n         let obligation =\n-            util::obligation_for_builtin_bound(\n+            util::predicate_for_builtin_bound(\n                 self.tcx(),\n                 previous_stack.obligation.cause,\n                 bound,\n@@ -287,17 +265,47 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match obligation {\n             Ok(obligation) => {\n-                self.evaluate_obligation_recursively(Some(previous_stack), &obligation)\n+                self.evaluate_predicate_recursively(Some(previous_stack), &obligation)\n             }\n             Err(ErrorReported) => {\n                 EvaluatedToOk\n             }\n         }\n     }\n \n+    fn evaluate_predicate_recursively<'o>(&mut self,\n+                                          previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                          obligation: &PredicateObligation<'tcx>)\n+                                           -> EvaluationResult<'tcx>\n+    {\n+        debug!(\"evaluate_predicate_recursively({})\",\n+               obligation.repr(self.tcx()));\n+\n+        match obligation.trait_ref {\n+            ty::Predicate::Trait(ref t) => {\n+                assert!(!t.has_escaping_regions());\n+                let obligation = obligation.with(t.clone());\n+                self.evaluate_obligation_recursively(previous_stack, &obligation)\n+            }\n+\n+            ty::Predicate::Equate(a, b) => {\n+                match infer::can_mk_eqty(self.infcx, a, b) {\n+                    Ok(()) => EvaluatedToOk,\n+                    Err(_) => EvaluatedToErr(Unimplemented),\n+                }\n+            }\n+\n+            ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n+                // we do not consider region relationships when\n+                // evaluating trait matches\n+                EvaluatedToOk\n+            }\n+        }\n+    }\n+\n     fn evaluate_obligation_recursively<'o>(&mut self,\n-                                           previous_stack: Option<&ObligationStack<'o, 'tcx>>,\n-                                           obligation: &Obligation<'tcx>)\n+                                           previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                           obligation: &TraitObligation<'tcx>)\n                                            -> EvaluationResult<'tcx>\n     {\n         debug!(\"evaluate_obligation_recursively({})\",\n@@ -312,7 +320,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn evaluate_stack<'o>(&mut self,\n-                          stack: &ObligationStack<'o, 'tcx>)\n+                          stack: &TraitObligationStack<'o, 'tcx>)\n                           -> EvaluationResult<'tcx>\n     {\n         // In intercrate mode, whenever any of the types are unbound,\n@@ -347,7 +355,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n               stack.iter().skip(1).any(\n                   |prev| stack.skol_trait_ref.def_id == prev.skol_trait_ref.def_id))\n         {\n-            debug!(\"evaluate_stack_intracrate({}) --> unbound argument, recursion -->  ambiguous\",\n+            debug!(\"evaluate_stack({}) --> unbound argument, recursion -->  ambiguous\",\n                    stack.skol_trait_ref.repr(self.tcx()));\n             return EvaluatedToAmbig;\n         }\n@@ -376,7 +384,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .skip(1) // skip top-most frame\n             .any(|prev| stack.skol_trait_ref == prev.skol_trait_ref)\n         {\n-            debug!(\"evaluate_stack_intracrate({}) --> recursive\",\n+            debug!(\"evaluate_stack({}) --> recursive\",\n                    stack.skol_trait_ref.repr(self.tcx()));\n             return EvaluatedToOk;\n         }\n@@ -392,7 +400,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// `obligation_self_ty`. This can be used either for trait or inherent impls.\n     pub fn evaluate_impl(&mut self,\n                          impl_def_id: ast::DefId,\n-                         obligation: &Obligation<'tcx>)\n+                         obligation: &TraitObligation<'tcx>)\n                          -> bool\n     {\n         debug!(\"evaluate_impl(impl_def_id={}, obligation={})\",\n@@ -423,7 +431,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // candidates. See `doc.rs` and the `Candidate` type for more details.\n \n     fn candidate_from_obligation<'o>(&mut self,\n-                                     stack: &ObligationStack<'o, 'tcx>)\n+                                     stack: &TraitObligationStack<'o, 'tcx>)\n                                      -> SelectionResult<'tcx, Candidate<'tcx>>\n     {\n         // Watch out for overflow. This intentionally bypasses (and does\n@@ -466,7 +474,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn candidate_from_obligation_no_cache<'o>(&mut self,\n-                                              stack: &ObligationStack<'o, 'tcx>)\n+                                              stack: &TraitObligationStack<'o, 'tcx>)\n                                               -> SelectionResult<'tcx, Candidate<'tcx>>\n     {\n         if ty::type_is_error(stack.obligation.self_ty()) {\n@@ -595,8 +603,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // common case, then we can use the global environment.\n         // See the discussion in doc.rs for more details.\n         if\n-            !self.param_env.caller_obligations.is_empty()\n-            &&\n+            !self.param_env.caller_bounds.is_empty() &&\n             cache_skol_trait_ref.input_types().iter().any(\n                 |&t| ty::type_has_ty_infer(t))\n         {\n@@ -626,12 +633,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn assemble_candidates<'o>(&mut self,\n-                               stack: &ObligationStack<'o, 'tcx>)\n+                               stack: &TraitObligationStack<'o, 'tcx>)\n                                -> Result<CandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n         // Check for overflow.\n \n-        let ObligationStack { obligation, .. } = *stack;\n+        let TraitObligationStack { obligation, .. } = *stack;\n \n         let mut candidates = CandidateSet {\n             vec: Vec::new(),\n@@ -682,16 +689,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///\n     /// Never affects inference environment.\n     fn assemble_candidates_from_caller_bounds(&mut self,\n-                                              obligation: &Obligation<'tcx>,\n+                                              obligation: &TraitObligation<'tcx>,\n                                               candidates: &mut CandidateSet<'tcx>)\n                                               -> Result<(),SelectionError<'tcx>>\n     {\n         debug!(\"assemble_candidates_from_caller_bounds({})\",\n                obligation.repr(self.tcx()));\n \n         let caller_trait_refs: Vec<Rc<ty::TraitRef>> =\n-            self.param_env.caller_obligations.iter()\n-            .map(|o| o.trait_ref.clone())\n+            self.param_env.caller_bounds.predicates.iter()\n+            .filter_map(|o| o.to_trait())\n             .collect();\n \n         let all_bounds =\n@@ -720,7 +727,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// parameters and hence do not affect whether this trait is a match or not. They will be\n     /// unified during the confirmation step.\n     fn assemble_unboxed_closure_candidates(&mut self,\n-                                           obligation: &Obligation<'tcx>,\n+                                           obligation: &TraitObligation<'tcx>,\n                                            candidates: &mut CandidateSet<'tcx>)\n                                            -> Result<(),SelectionError<'tcx>>\n     {\n@@ -762,7 +769,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Implement one of the `Fn()` family for a fn pointer.\n     fn assemble_fn_pointer_candidates(&mut self,\n-                                      obligation: &Obligation<'tcx>,\n+                                      obligation: &TraitObligation<'tcx>,\n                                       candidates: &mut CandidateSet<'tcx>)\n                                       -> Result<(),SelectionError<'tcx>>\n     {\n@@ -800,7 +807,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Search for impls that might apply to `obligation`.\n     fn assemble_candidates_from_impls(&mut self,\n-                                      obligation: &Obligation<'tcx>,\n+                                      obligation: &TraitObligation<'tcx>,\n                                       candidates: &mut CandidateSet<'tcx>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n@@ -831,7 +838,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// obligations are met. Returns true if `candidate` remains viable after this further\n     /// scrutiny.\n     fn winnow_candidate<'o>(&mut self,\n-                            stack: &ObligationStack<'o, 'tcx>,\n+                            stack: &TraitObligationStack<'o, 'tcx>,\n                             candidate: &Candidate<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n@@ -846,13 +853,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn winnow_selection<'o>(&mut self,\n-                            stack: Option<&ObligationStack<'o, 'tcx>>,\n+                            stack: Option<&TraitObligationStack<'o, 'tcx>>,\n                             selection: Selection<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in selection.iter_nested() {\n-            match self.evaluate_obligation_recursively(stack, obligation) {\n+            match self.evaluate_predicate_recursively(stack, obligation) {\n                 EvaluatedToErr(e) => { return EvaluatedToErr(e); }\n                 EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n                 EvaluatedToOk => { }\n@@ -885,7 +892,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// essentially harmless.  See issue #18453 for more details of\n     /// a case where doing the opposite caused us harm.\n     fn candidate_should_be_dropped_in_favor_of<'o>(&mut self,\n-                                                   stack: &ObligationStack<'o, 'tcx>,\n+                                                   stack: &TraitObligationStack<'o, 'tcx>,\n                                                    candidate_i: &Candidate<'tcx>,\n                                                    candidate_j: &Candidate<'tcx>)\n                                                    -> bool\n@@ -928,12 +935,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn assemble_builtin_bound_candidates<'o>(&mut self,\n                                              bound: ty::BuiltinBound,\n-                                             stack: &ObligationStack<'o, 'tcx>,\n+                                             stack: &TraitObligationStack<'o, 'tcx>,\n                                              candidates: &mut CandidateSet<'tcx>)\n                                              -> Result<(),SelectionError<'tcx>>\n     {\n-        match self.builtin_bound(bound, stack.obligation.self_ty()) {\n-            Ok(If(_)) => {\n+        match self.builtin_bound(bound, stack.obligation) {\n+            Ok(If(..)) => {\n                 debug!(\"builtin_bound: bound={}\",\n                        bound.repr(self.tcx()));\n                 candidates.vec.push(BuiltinCandidate(bound));\n@@ -947,10 +954,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn builtin_bound(&mut self,\n                      bound: ty::BuiltinBound,\n-                     self_ty: Ty<'tcx>)\n+                     obligation: &TraitObligation<'tcx>)\n                      -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n     {\n-        let self_ty = self.infcx.shallow_resolve(self_ty);\n+        let self_ty = self.infcx.shallow_resolve(obligation.trait_ref.self_ty());\n         return match self_ty.sty {\n             ty::ty_infer(ty::IntVar(_)) |\n             ty::ty_infer(ty::FloatVar(_)) |\n@@ -1023,8 +1030,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         match bound {\n                             ty::BoundCopy => {\n                                 match mutbl {\n-                                    ast::MutMutable => Err(Unimplemented),  // &mut T is affine\n-                                    ast::MutImmutable => Ok(If(Vec::new())),  // &T is copyable\n+                                    ast::MutMutable => {\n+                                        // &mut T is affine\n+                                        Err(Unimplemented)\n+                                    }\n+                                    ast::MutImmutable => {\n+                                        // &T is copyable, no matter what T is\n+                                        Ok(If(Vec::new()))\n+                                    }\n                                 }\n                             }\n \n@@ -1083,10 +1096,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundCopy => {\n                         match mutbl {\n                             // &mut T is affine and hence never `Copy`\n-                            ast::MutMutable => Err(Unimplemented),\n+                            ast::MutMutable => {\n+                                Err(Unimplemented)\n+                            }\n \n                             // &T is always copyable\n-                            ast::MutImmutable => Ok(If(Vec::new())),\n+                            ast::MutImmutable => {\n+                                Ok(If(Vec::new()))\n+                            }\n                         }\n                     }\n \n@@ -1122,8 +1139,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 match bound {\n                     ty::BoundCopy => {\n                         match *len {\n-                            Some(_) => Ok(If(vec![element_ty])), // [T, ..n] is copy iff T is copy\n-                            None => Err(Unimplemented), // [T] is unsized and hence affine\n+                            Some(_) => {\n+                                // [T, ..n] is copy iff T is copy\n+                                Ok(If(vec![element_ty]))\n+                            }\n+                            None => {\n+                                // [T] is unsized and hence affine\n+                                Err(Unimplemented)\n+                            }\n                         }\n                     }\n \n@@ -1256,7 +1279,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Some(def_id) == tcx.lang_items.no_send_bound() ||\n                         Some(def_id) == tcx.lang_items.managed_bound()\n                     {\n-                        return Err(Unimplemented);\n+                        return Err(Unimplemented)\n                     }\n                 }\n \n@@ -1266,6 +1289,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // don't supply any form of builtin impl.\n                     if !this.tcx().sess.features.borrow().opt_out_copy {\n                         return Ok(ParameterBuiltin)\n+                    } else {\n+                        // Older, backwards compatibility behavior:\n+                        if\n+                            Some(def_id) == tcx.lang_items.no_copy_bound() ||\n+                            Some(def_id) == tcx.lang_items.managed_bound() ||\n+                            ty::has_dtor(tcx, def_id)\n+                        {\n+                            return Err(Unimplemented);\n+                        }\n                     }\n                 }\n \n@@ -1274,7 +1306,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Some(def_id) == tcx.lang_items.no_sync_bound() ||\n                         Some(def_id) == tcx.lang_items.managed_bound()\n                     {\n-                        return Err(Unimplemented);\n+                        return Err(Unimplemented)\n                     } else if\n                         Some(def_id) == tcx.lang_items.unsafe_type()\n                     {\n@@ -1300,7 +1332,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // type error.  See `doc.rs` for more details.\n \n     fn confirm_candidate(&mut self,\n-                         obligation: &Obligation<'tcx>,\n+                         obligation: &TraitObligation<'tcx>,\n                          candidate: Candidate<'tcx>)\n                          -> Result<Selection<'tcx>,SelectionError<'tcx>>\n     {\n@@ -1343,7 +1375,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_param_candidate(&mut self,\n-                               obligation: &Obligation<'tcx>,\n+                               obligation: &TraitObligation<'tcx>,\n                                param: VtableParamData<'tcx>)\n                                -> Result<VtableParamData<'tcx>,\n                                          SelectionError<'tcx>>\n@@ -1359,15 +1391,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_builtin_candidate(&mut self,\n-                                 obligation: &Obligation<'tcx>,\n+                                 obligation: &TraitObligation<'tcx>,\n                                  bound: ty::BuiltinBound)\n-                                 -> Result<VtableBuiltinData<Obligation<'tcx>>,\n+                                 -> Result<VtableBuiltinData<PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n         debug!(\"confirm_builtin_candidate({})\",\n                obligation.repr(self.tcx()));\n \n-        match try!(self.builtin_bound(bound, obligation.self_ty())) {\n+        match try!(self.builtin_bound(bound, obligation)) {\n             If(nested) => Ok(self.vtable_builtin_data(obligation, bound, nested)),\n             AmbiguousBuiltin | ParameterBuiltin => {\n                 self.tcx().sess.span_bug(\n@@ -1379,32 +1411,47 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn vtable_builtin_data(&mut self,\n-                           obligation: &Obligation<'tcx>,\n+                           obligation: &TraitObligation<'tcx>,\n                            bound: ty::BuiltinBound,\n                            nested: Vec<Ty<'tcx>>)\n-                           -> VtableBuiltinData<Obligation<'tcx>>\n+                           -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n         let obligations = nested.iter().map(|&t| {\n-            util::obligation_for_builtin_bound(\n+            util::predicate_for_builtin_bound(\n                 self.tcx(),\n                 obligation.cause,\n                 bound,\n                 obligation.recursion_depth + 1,\n                 t)\n         }).collect::<Result<_, _>>();\n-        let obligations = match obligations {\n+        let mut obligations = match obligations {\n             Ok(o) => o,\n             Err(ErrorReported) => Vec::new()\n         };\n+\n+        // as a special case, `Send` requires `'static`\n+        if bound == ty::BoundSend {\n+            obligations.push(Obligation {\n+                cause: obligation.cause,\n+                recursion_depth: obligation.recursion_depth+1,\n+                trait_ref: ty::Predicate::TypeOutlives(obligation.self_ty(),\n+                                                       ty::ReStatic)\n+            });\n+        }\n+\n         let obligations = VecPerParamSpace::new(obligations, Vec::new(),\n                                                 Vec::new(), Vec::new());\n+\n+        debug!(\"vtable_builtin_data: obligations={}\",\n+               obligations.repr(self.tcx()));\n+\n         VtableBuiltinData { nested: obligations }\n     }\n \n     fn confirm_impl_candidate(&mut self,\n-                              obligation: &Obligation<'tcx>,\n+                              obligation: &TraitObligation<'tcx>,\n                               impl_def_id: ast::DefId)\n-                              -> Result<VtableImplData<'tcx, Obligation<'tcx>>,\n+                              -> Result<VtableImplData<'tcx, PredicateObligation<'tcx>>,\n                                         SelectionError<'tcx>>\n     {\n         debug!(\"confirm_impl_candidate({},{})\",\n@@ -1414,6 +1461,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n         let substs = self.rematch_impl(impl_def_id, obligation);\n+        debug!(\"confirm_impl_candidate substs={}\", substs);\n         Ok(self.vtable_impl(impl_def_id, substs, obligation.cause, obligation.recursion_depth + 1))\n     }\n \n@@ -1422,20 +1470,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                    substs: Substs<'tcx>,\n                    cause: ObligationCause<'tcx>,\n                    recursion_depth: uint)\n-                   -> VtableImplData<'tcx, Obligation<'tcx>>\n+                   -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n-        let impl_obligations =\n-            self.impl_obligations(cause,\n-                                  recursion_depth,\n-                                  impl_def_id,\n-                                  &substs);\n+        let impl_predicates =\n+            self.impl_predicates(cause,\n+                                 recursion_depth,\n+                                 impl_def_id,\n+                                 &substs);\n         VtableImplData { impl_def_id: impl_def_id,\n                          substs: substs,\n-                         nested: impl_obligations }\n+                         nested: impl_predicates }\n     }\n \n     fn confirm_fn_pointer_candidate(&mut self,\n-                                    obligation: &Obligation<'tcx>)\n+                                    obligation: &TraitObligation<'tcx>)\n                                     -> Result<ty::Ty<'tcx>,SelectionError<'tcx>>\n     {\n         debug!(\"confirm_fn_pointer_candidate({})\",\n@@ -1480,7 +1528,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_unboxed_closure_candidate(&mut self,\n-                                         obligation: &Obligation<'tcx>,\n+                                         obligation: &TraitObligation<'tcx>,\n                                          closure_def_id: ast::DefId,\n                                          substs: &Substs<'tcx>)\n                                          -> Result<(),SelectionError<'tcx>>\n@@ -1531,7 +1579,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn rematch_impl(&mut self,\n                     impl_def_id: ast::DefId,\n-                    obligation: &Obligation<'tcx>)\n+                    obligation: &TraitObligation<'tcx>)\n                     -> Substs<'tcx>\n     {\n         match self.match_impl(impl_def_id, obligation) {\n@@ -1550,7 +1598,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_impl(&mut self,\n                   impl_def_id: ast::DefId,\n-                  obligation: &Obligation<'tcx>)\n+                  obligation: &TraitObligation<'tcx>)\n                   -> Result<Substs<'tcx>, ()>\n     {\n         let impl_trait_ref = ty::impl_trait_ref(self.tcx(),\n@@ -1577,7 +1625,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn fast_reject_trait_refs(&mut self,\n-                              obligation: &Obligation,\n+                              obligation: &TraitObligation,\n                               impl_trait_ref: &ty::TraitRef)\n                               -> bool\n     {\n@@ -1600,7 +1648,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn match_trait_refs(&mut self,\n-                        obligation: &Obligation<'tcx>,\n+                        obligation: &TraitObligation<'tcx>,\n                         trait_ref: Rc<ty::TraitRef<'tcx>>)\n                         -> Result<(),()>\n     {\n@@ -1752,23 +1800,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.infcx.sub_trait_refs(false,\n                                         origin,\n                                         expected_trait_ref.clone(),\n-                                        obligation_trait_ref) {\n+                                        obligation_trait_ref.clone()) {\n             Ok(()) => Ok(()),\n-            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, e))\n+            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n         }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n     // Miscellany\n \n     fn push_stack<'o,'s:'o>(&mut self,\n-                            previous_stack: Option<&'s ObligationStack<'s, 'tcx>>,\n-                            obligation: &'o Obligation<'tcx>)\n-                            -> ObligationStack<'o, 'tcx>\n+                            previous_stack: Option<&'s TraitObligationStack<'s, 'tcx>>,\n+                            obligation: &'o TraitObligation<'tcx>)\n+                            -> TraitObligationStack<'o, 'tcx>\n     {\n         let skol_trait_ref = obligation.trait_ref.fold_with(&mut self.skolemizer);\n \n-        ObligationStack {\n+        TraitObligationStack {\n             obligation: obligation,\n             skol_trait_ref: skol_trait_ref,\n             previous: previous_stack.map(|p| p), // FIXME variance\n@@ -1785,17 +1833,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    fn impl_obligations(&self,\n-                        cause: ObligationCause<'tcx>,\n-                        recursion_depth: uint,\n-                        impl_def_id: ast::DefId,\n-                        impl_substs: &Substs<'tcx>)\n-                        -> VecPerParamSpace<Obligation<'tcx>>\n+    fn impl_predicates(&self,\n+                       cause: ObligationCause<'tcx>,\n+                       recursion_depth: uint,\n+                       impl_def_id: ast::DefId,\n+                       impl_substs: &Substs<'tcx>)\n+                       -> VecPerParamSpace<PredicateObligation<'tcx>>\n     {\n         let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n         let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n-        util::obligations_for_generics(self.tcx(), cause, recursion_depth,\n-                                       &bounds, &impl_substs.types)\n+        util::predicates_for_generics(self.tcx(), cause, recursion_depth, &bounds)\n     }\n \n     fn fn_family_trait_kind(&self,\n@@ -1840,14 +1887,16 @@ impl<'tcx> SelectionCache<'tcx> {\n     }\n }\n \n-impl<'o, 'tcx> ObligationStack<'o, 'tcx> {\n-    fn iter(&self) -> Option<&ObligationStack<'o, 'tcx>> {\n+impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n+    fn iter(&self) -> Option<&TraitObligationStack<'o, 'tcx>> {\n         Some(self)\n     }\n }\n \n-impl<'o, 'tcx> Iterator<&'o ObligationStack<'o, 'tcx>> for Option<&'o ObligationStack<'o, 'tcx>> {\n-    fn next(&mut self) -> Option<&'o ObligationStack<'o, 'tcx>> {\n+impl<'o, 'tcx> Iterator<&'o TraitObligationStack<'o,'tcx>>\n+           for Option<&'o TraitObligationStack<'o, 'tcx>>\n+{\n+    fn next(&mut self) -> Option<&'o TraitObligationStack<'o, 'tcx>> {\n         match *self {\n             Some(o) => {\n                 *self = o.previous;\n@@ -1860,9 +1909,9 @@ impl<'o, 'tcx> Iterator<&'o ObligationStack<'o, 'tcx>> for Option<&'o Obligation\n     }\n }\n \n-impl<'o, 'tcx> Repr<'tcx> for ObligationStack<'o, 'tcx> {\n+impl<'o, 'tcx> Repr<'tcx> for TraitObligationStack<'o, 'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"ObligationStack({})\",\n+        format!(\"TraitObligationStack({})\",\n                 self.obligation.repr(tcx))\n     }\n }"}, {"sha": "52154e0be7ad0c3a3382f241bd5c0b620a2d3171", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 175, "deletions": 147, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -9,8 +9,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::subst;\n-use middle::subst::{ParamSpace, Substs, VecPerParamSpace, Subst};\n+use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n use middle::ty::{mod, Ty};\n use std::collections::HashSet;\n@@ -21,112 +20,138 @@ use syntax::codemap::Span;\n use util::common::ErrorReported;\n use util::ppaux::Repr;\n \n-use super::{Obligation, ObligationCause, VtableImpl,\n-            VtableParam, VtableParamData, VtableImplData};\n+use super::{Obligation, ObligationCause, PredicateObligation,\n+            VtableImpl, VtableParam, VtableParamData, VtableImplData};\n \n ///////////////////////////////////////////////////////////////////////////\n-// Supertrait iterator\n+// `Elaboration` iterator\n+///////////////////////////////////////////////////////////////////////////\n \n-pub struct Supertraits<'cx, 'tcx:'cx> {\n+/// \"Elaboration\" is the process of identifying all the predicates that\n+/// are implied by a source predicate. Currently this basically means\n+/// walking the \"supertraits\" and other similar assumptions. For\n+/// example, if we know that `T : Ord`, the elaborator would deduce\n+/// that `T : PartialOrd` holds as well. Similarly, if we have `trait\n+/// Foo : 'static`, and we know that `T : Foo`, then we know that `T :\n+/// 'static`.\n+pub struct Elaborator<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n-    stack: Vec<SupertraitEntry<'tcx>>,\n-    visited: HashSet<Rc<ty::TraitRef<'tcx>>>,\n+    stack: Vec<StackEntry<'tcx>>,\n+    visited: HashSet<ty::Predicate<'tcx>>,\n }\n \n-struct SupertraitEntry<'tcx> {\n+struct StackEntry<'tcx> {\n     position: uint,\n-    supertraits: Vec<Rc<ty::TraitRef<'tcx>>>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n }\n \n-pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                              trait_ref: Rc<ty::TraitRef<'tcx>>)\n-                              -> Supertraits<'cx, 'tcx>\n+pub fn elaborate_trait_ref<'cx, 'tcx>(\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    trait_ref: Rc<ty::TraitRef<'tcx>>)\n+    -> Elaborator<'cx, 'tcx>\n {\n-    //! Returns an iterator over the trait reference `T` and all of its supertrait references. May\n-    //! contain duplicates. In general the ordering is not defined.\n-    //!\n-    //! Example:\n-    //!\n-    //! ```\n-    //! trait Foo { ... }\n-    //! trait Bar : Foo { ... }\n-    //! trait Baz : Bar+Foo { ... }\n-    //! ```\n-    //!\n-    //! `supertraits(Baz)` yields `[Baz, Bar, Foo, Foo]` in some order.\n-\n-    transitive_bounds(tcx, &[trait_ref])\n+    elaborate_predicates(tcx, vec![ty::Predicate::Trait(trait_ref)])\n }\n \n-pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                                    bounds: &[Rc<ty::TraitRef<'tcx>>])\n-                                    -> Supertraits<'cx, 'tcx>\n+pub fn elaborate_trait_refs<'cx, 'tcx>(\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    trait_refs: &[Rc<ty::TraitRef<'tcx>>])\n+    -> Elaborator<'cx, 'tcx>\n {\n-    let bounds = Vec::from_fn(bounds.len(), |i| bounds[i].clone());\n+    let predicates = trait_refs.iter()\n+                               .map(|trait_ref| ty::Predicate::Trait((*trait_ref).clone()))\n+                               .collect();\n+    elaborate_predicates(tcx, predicates)\n+}\n \n-    let visited: HashSet<Rc<ty::TraitRef>> =\n-        bounds.iter()\n-              .map(|b| (*b).clone())\n-              .collect();\n+pub fn elaborate_predicates<'cx, 'tcx>(\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>)\n+    -> Elaborator<'cx, 'tcx>\n+{\n+    let visited: HashSet<ty::Predicate<'tcx>> =\n+        predicates.iter()\n+                  .map(|b| (*b).clone())\n+                  .collect();\n \n-    let entry = SupertraitEntry { position: 0, supertraits: bounds };\n-    Supertraits { tcx: tcx, stack: vec![entry], visited: visited }\n+    let entry = StackEntry { position: 0, predicates: predicates };\n+    Elaborator { tcx: tcx, stack: vec![entry], visited: visited }\n }\n \n-impl<'cx, 'tcx> Supertraits<'cx, 'tcx> {\n-    fn push(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n-        let ty::ParamBounds { builtin_bounds, mut trait_bounds, .. } =\n-            ty::bounds_for_trait_ref(self.tcx, trait_ref);\n-        for builtin_bound in builtin_bounds.iter() {\n-            let bound_trait_ref = trait_ref_for_builtin_bound(self.tcx,\n-                                                              builtin_bound,\n-                                                              trait_ref.self_ty());\n-            bound_trait_ref.map(|trait_ref| trait_bounds.push(trait_ref));\n+impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n+    fn push(&mut self, predicate: &ty::Predicate<'tcx>) {\n+        match *predicate {\n+            ty::Predicate::Trait(ref trait_ref) => {\n+                let mut predicates =\n+                    ty::predicates_for_trait_ref(self.tcx, &**trait_ref);\n+\n+                // Only keep those bounds that we haven't already\n+                // seen.  This is necessary to prevent infinite\n+                // recursion in some cases.  One common case is when\n+                // people define `trait Sized { }` rather than `trait\n+                // Sized for Sized? { }`.\n+                predicates.retain(|r| self.visited.insert((*r).clone()));\n+\n+                self.stack.push(StackEntry { position: 0,\n+                                             predicates: predicates });\n+            }\n+            ty::Predicate::Equate(..) => {\n+            }\n+            ty::Predicate::RegionOutlives(..) |\n+            ty::Predicate::TypeOutlives(..) => {\n+                // Currently, we do not \"elaborate\" predicates like\n+                // `'a : 'b` or `T : 'a`.  We could conceivably do\n+                // more here.  For example,\n+                //\n+                //     &'a int : 'b\n+                //\n+                // implies that\n+                //\n+                //     'a : 'b\n+                //\n+                // and we could get even more if we took WF\n+                // constraints into account. For example,\n+                //\n+                //     &'a &'b int : 'c\n+                //\n+                // implies that\n+                //\n+                //     'b : 'a\n+                //     'a : 'c\n+            }\n         }\n-\n-        // Only keep those bounds that we haven't already seen.  This\n-        // is necessary to prevent infinite recursion in some cases.\n-        // One common case is when people define `trait Sized { }`\n-        // rather than `trait Sized for Sized? { }`.\n-        trait_bounds.retain(|r| self.visited.insert((*r).clone()));\n-\n-        let entry = SupertraitEntry { position: 0, supertraits: trait_bounds };\n-        self.stack.push(entry);\n-    }\n-\n-    /// Returns the path taken through the trait supertraits to reach the current point.\n-    pub fn indices(&self) -> Vec<uint> {\n-        self.stack.iter().map(|e| e.position).collect()\n     }\n }\n \n-impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n-    fn next(&mut self) -> Option<Rc<ty::TraitRef<'tcx>>> {\n+impl<'cx, 'tcx> Iterator<ty::Predicate<'tcx>> for Elaborator<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n         loop {\n             // Extract next item from top-most stack frame, if any.\n-            let next_trait = match self.stack.last_mut() {\n+            let next_predicate = match self.stack.last_mut() {\n                 None => {\n                     // No more stack frames. Done.\n                     return None;\n                 }\n                 Some(entry) => {\n                     let p = entry.position;\n-                    if p < entry.supertraits.len() {\n-                        // Still more supertraits left in the top stack frame.\n+                    if p < entry.predicates.len() {\n+                        // Still more predicates left in the top stack frame.\n                         entry.position += 1;\n \n-                        let next_trait = entry.supertraits[p].clone();\n-                        Some(next_trait)\n+                        let next_predicate =\n+                            entry.predicates[p].clone();\n+\n+                        Some(next_predicate)\n                     } else {\n                         None\n                     }\n                 }\n             };\n \n-            match next_trait {\n-                Some(next_trait) => {\n-                    self.push(&*next_trait);\n-                    return Some(next_trait);\n+            match next_predicate {\n+                Some(next_predicate) => {\n+                    self.push(&next_predicate);\n+                    return Some(next_predicate);\n                 }\n \n                 None => {\n@@ -138,6 +163,55 @@ impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Supertrait iterator\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// A filter around the `Elaborator` that just yields up supertrait references,\n+/// not other kinds of predicates.\n+pub struct Supertraits<'cx, 'tcx:'cx> {\n+    elaborator: Elaborator<'cx, 'tcx>,\n+}\n+\n+pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n+                              trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                              -> Supertraits<'cx, 'tcx>\n+{\n+    let elaborator = elaborate_trait_ref(tcx, trait_ref);\n+    Supertraits { elaborator: elaborator }\n+}\n+\n+pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n+                                    bounds: &[Rc<ty::TraitRef<'tcx>>])\n+                                    -> Supertraits<'cx, 'tcx>\n+{\n+    let elaborator = elaborate_trait_refs(tcx, bounds);\n+    Supertraits { elaborator: elaborator }\n+}\n+\n+impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<Rc<ty::TraitRef<'tcx>>> {\n+        loop {\n+            match self.elaborator.next() {\n+                None => {\n+                    return None;\n+                }\n+                Some(ty::Predicate::Trait(trait_ref)) => {\n+                    return Some(trait_ref);\n+                }\n+                Some(ty::Predicate::Equate(..)) |\n+                Some(ty::Predicate::RegionOutlives(..)) |\n+                Some(ty::Predicate::TypeOutlives(..)) => {\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Other\n+///////////////////////////////////////////////////////////////////////////\n+\n // determine the `self` type, using fresh variables for all variables\n // declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n@@ -176,103 +250,56 @@ impl<'tcx> fmt::Show for VtableParamData<'tcx> {\n }\n \n /// See `super::obligations_for_generics`\n-pub fn obligations_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      cause: ObligationCause<'tcx>,\n-                                      recursion_depth: uint,\n-                                      generic_bounds: &ty::GenericBounds<'tcx>,\n-                                      type_substs: &VecPerParamSpace<Ty<'tcx>>)\n-                                      -> VecPerParamSpace<Obligation<'tcx>>\n+pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                     cause: ObligationCause<'tcx>,\n+                                     recursion_depth: uint,\n+                                     generic_bounds: &ty::GenericBounds<'tcx>)\n+                                     -> VecPerParamSpace<PredicateObligation<'tcx>>\n {\n-\n-    debug!(\"obligations_for_generics(generic_bounds={}, type_substs={})\",\n-           generic_bounds.repr(tcx), type_substs.repr(tcx));\n-\n-    let mut obligations = VecPerParamSpace::empty();\n-\n-    for (space, index, bounds) in generic_bounds.types.iter_enumerated() {\n-        push_obligations_for_param_bounds(tcx,\n-                                          cause,\n-                                          recursion_depth,\n-                                          space,\n-                                          index,\n-                                          bounds,\n-                                          type_substs,\n-                                          &mut obligations);\n-    }\n-\n-    debug!(\"obligations() ==> {}\", obligations.repr(tcx));\n-\n-    return obligations;\n-}\n-\n-fn push_obligations_for_param_bounds<'tcx>(\n-    tcx: &ty::ctxt<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    recursion_depth: uint,\n-    space: subst::ParamSpace,\n-    index: uint,\n-    param_bounds: &ty::ParamBounds<'tcx>,\n-    param_type_substs: &VecPerParamSpace<Ty<'tcx>>,\n-    obligations: &mut VecPerParamSpace<Obligation<'tcx>>)\n-{\n-    let param_ty = *param_type_substs.get(space, index);\n-    for builtin_bound in param_bounds.builtin_bounds.iter() {\n-        let obligation = obligation_for_builtin_bound(tcx,\n-                                                      cause,\n-                                                      builtin_bound,\n-                                                      recursion_depth,\n-                                                      param_ty);\n-        if let Ok(ob) = obligation {\n-            obligations.push(space, ob);\n-        }\n-    }\n-\n-    for bound_trait_ref in param_bounds.trait_bounds.iter() {\n-        obligations.push(\n-            space,\n-            Obligation { cause: cause,\n-                         recursion_depth: recursion_depth,\n-                         trait_ref: (*bound_trait_ref).clone() });\n-    }\n+    debug!(\"predicates_for_generics(generic_bounds={})\",\n+           generic_bounds.repr(tcx));\n+\n+    generic_bounds.predicates.map(|predicate| {\n+        Obligation { cause: cause,\n+                     recursion_depth: recursion_depth,\n+                     trait_ref: predicate.clone() }\n+    })\n }\n \n pub fn trait_ref_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     param_ty: Ty<'tcx>)\n-    -> Option<Rc<ty::TraitRef<'tcx>>>\n+    -> Result<Rc<ty::TraitRef<'tcx>>, ErrorReported>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n-            Some(Rc::new(ty::TraitRef {\n+            Ok(Rc::new(ty::TraitRef {\n                 def_id: def_id,\n                 substs: Substs::empty().with_self_ty(param_ty)\n             }))\n         }\n         Err(e) => {\n             tcx.sess.err(e.as_slice());\n-            None\n+            Err(ErrorReported)\n         }\n     }\n }\n \n-pub fn obligation_for_builtin_bound<'tcx>(\n+pub fn predicate_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     recursion_depth: uint,\n     param_ty: Ty<'tcx>)\n-    -> Result<Obligation<'tcx>, ErrorReported>\n+    -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n-    let trait_ref = trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty);\n-    match trait_ref {\n-        Some(trait_ref) => Ok(Obligation {\n-                cause: cause,\n-                recursion_depth: recursion_depth,\n-                trait_ref: trait_ref\n-            }),\n-        None => Err(ErrorReported)\n-    }\n+    let trait_ref = try!(trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n+    Ok(Obligation {\n+        cause: cause,\n+        recursion_depth: recursion_depth,\n+        trait_ref: ty::Predicate::Trait(trait_ref),\n+    })\n }\n \n /// Starting from a caller obligation `caller_bound` (which has coordinates `space`/`i` in the list\n@@ -294,7 +321,7 @@ pub fn search_trait_and_supertraits_from_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     return None;\n }\n \n-impl<'tcx> Repr<'tcx> for super::Obligation<'tcx> {\n+impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Obligation(trait_ref={},depth={})\",\n                 self.trait_ref.repr(tcx),\n@@ -358,10 +385,11 @@ impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n             super::Unimplemented =>\n                 format!(\"Unimplemented\"),\n \n-            super::OutputTypeParameterMismatch(ref t, ref e) =>\n-                format!(\"OutputTypeParameterMismatch({}, {})\",\n-                        t.repr(tcx),\n-                        e.repr(tcx)),\n+            super::OutputTypeParameterMismatch(ref a, ref b, ref c) =>\n+                format!(\"OutputTypeParameterMismatch({},{},{})\",\n+                        a.repr(tcx),\n+                        b.repr(tcx),\n+                        c.repr(tcx)),\n         }\n     }\n }"}, {"sha": "ddbf69685cd91523bfc651ab51fec79a4a3cc557", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 209, "deletions": 134, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -44,6 +44,7 @@ use back::svh::Svh;\n use session::Session;\n use lint;\n use metadata::csearch;\n+use middle;\n use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n@@ -60,13 +61,14 @@ use middle::traits::ObligationCause;\n use middle::traits;\n use middle::ty;\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder, HigherRankedFoldable};\n-use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n-use util::common::{indenter, memoized};\n+use util::common::{indenter, memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n+\n+use arena::TypedArena;\n use std::borrow::BorrowFrom;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n@@ -75,10 +77,10 @@ use std::hash::{Hash, sip, Writer};\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n+use std::collections::enum_set::{EnumSet, CLike};\n use std::collections::hash_map::{HashMap, Occupied, Vacant};\n-use arena::TypedArena;\n use syntax::abi;\n-use syntax::ast::{CrateNum, DefId, FnStyle, Ident, ItemTrait, LOCAL_CRATE};\n+use syntax::ast::{CrateNum, DefId, DUMMY_NODE_ID, FnStyle, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{Onceness, StmtExpr, StmtSemi, StructField, UnnamedField};\n use syntax::ast::{Visibility};\n@@ -87,7 +89,6 @@ use syntax::attr::{mod, AttrMetaMethods};\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::{mod, InternedString};\n use syntax::{ast, ast_map};\n-use std::collections::enum_set::{EnumSet, CLike};\n \n pub type Disr = u64;\n \n@@ -1613,18 +1614,28 @@ pub struct RegionParameterDef {\n     pub bounds: Vec<ty::Region>,\n }\n \n-/// Information about the formal type/lifetime parameters associated with an\n-/// item or method. Analogous to ast::Generics.\n+impl RegionParameterDef {\n+    pub fn to_early_bound_region(&self) -> ty::Region {\n+        ty::ReEarlyBound(self.def_id.node, self.space, self.index, self.name)\n+    }\n+}\n+\n+/// Information about the formal type/lifetime parameters associated\n+/// with an item or method. Analogous to ast::Generics.\n #[deriving(Clone, Show)]\n pub struct Generics<'tcx> {\n     pub types: VecPerParamSpace<TypeParameterDef<'tcx>>,\n     pub regions: VecPerParamSpace<RegionParameterDef>,\n+    pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n \n impl<'tcx> Generics<'tcx> {\n     pub fn empty() -> Generics<'tcx> {\n-        Generics { types: VecPerParamSpace::empty(),\n-                   regions: VecPerParamSpace::empty() }\n+        Generics {\n+            types: VecPerParamSpace::empty(),\n+            regions: VecPerParamSpace::empty(),\n+            predicates: VecPerParamSpace::empty(),\n+        }\n     }\n \n     pub fn has_type_params(&self, space: subst::ParamSpace) -> bool {\n@@ -1638,8 +1649,49 @@ impl<'tcx> Generics<'tcx> {\n     pub fn to_bounds(&self, tcx: &ty::ctxt<'tcx>, substs: &Substs<'tcx>)\n                      -> GenericBounds<'tcx> {\n         GenericBounds {\n-            types: self.types.map(|d| d.bounds.subst(tcx, substs)),\n-            regions: self.regions.map(|d| d.bounds.subst(tcx, substs)),\n+            predicates: self.predicates.subst(tcx, substs),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub enum Predicate<'tcx> {\n+    /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n+    /// the `Self` type of the trait reference and `A`, `B`, and `C`\n+    /// would be the parameters in the `TypeSpace`.\n+    Trait(Rc<TraitRef<'tcx>>),\n+\n+    /// where `T1 == T2`.\n+    Equate(/* T1 */ Ty<'tcx>, /* T2 */ Ty<'tcx>),\n+\n+    /// where 'a : 'b\n+    RegionOutlives(/* 'a */ Region, /* 'b */ Region),\n+\n+    /// where T : 'a\n+    TypeOutlives(Ty<'tcx>, Region),\n+}\n+\n+impl<'tcx> Predicate<'tcx> {\n+    pub fn has_escaping_regions(&self) -> bool {\n+        match *self {\n+            Predicate::Trait(ref trait_ref) => trait_ref.has_escaping_regions(),\n+            Predicate::Equate(a, b) => (ty::type_has_escaping_regions(a) ||\n+                                        ty::type_has_escaping_regions(b)),\n+            Predicate::RegionOutlives(a, b) => a.escapes_depth(0) || b.escapes_depth(0),\n+            Predicate::TypeOutlives(a, b) => ty::type_has_escaping_regions(a) || b.escapes_depth(0),\n+        }\n+    }\n+\n+    pub fn to_trait(&self) -> Option<Rc<TraitRef<'tcx>>> {\n+        match *self {\n+            Predicate::Trait(ref t) => {\n+                Some(t.clone())\n+            }\n+            Predicate::Equate(..) |\n+            Predicate::RegionOutlives(..) |\n+            Predicate::TypeOutlives(..) => {\n+                None\n+            }\n         }\n     }\n }\n@@ -1665,19 +1717,20 @@ impl<'tcx> Generics<'tcx> {\n /// [uint:Bar<int>]]`.\n #[deriving(Clone, Show)]\n pub struct GenericBounds<'tcx> {\n-    pub types: VecPerParamSpace<ParamBounds<'tcx>>,\n-    pub regions: VecPerParamSpace<Vec<Region>>,\n+    pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n \n impl<'tcx> GenericBounds<'tcx> {\n     pub fn empty() -> GenericBounds<'tcx> {\n-        GenericBounds { types: VecPerParamSpace::empty(),\n-                        regions: VecPerParamSpace::empty() }\n+        GenericBounds { predicates: VecPerParamSpace::empty() }\n     }\n \n     pub fn has_escaping_regions(&self) -> bool {\n-        self.types.any(|pb| pb.trait_bounds.iter().any(|tr| tr.has_escaping_regions())) ||\n-            self.regions.any(|rs| rs.iter().any(|r| r.escapes_depth(0)))\n+        self.predicates.any(|p| p.has_escaping_regions())\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.predicates.is_empty()\n     }\n }\n \n@@ -1728,9 +1781,6 @@ pub struct ParameterEnvironment<'tcx> {\n     /// parameters in the same way, this only has an effect on regions.\n     pub free_substs: Substs<'tcx>,\n \n-    /// Bounds on the various type parameters\n-    pub bounds: VecPerParamSpace<ParamBounds<'tcx>>,\n-\n     /// Each type parameter has an implicit region bound that\n     /// indicates it must outlive at least the function body (the user\n     /// may specify stronger requirements). This field indicates the\n@@ -1740,10 +1790,7 @@ pub struct ParameterEnvironment<'tcx> {\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations.\n-    ///\n-    /// Note: This effectively *duplicates* the `bounds` array for\n-    /// now.\n-    pub caller_obligations: VecPerParamSpace<traits::Obligation<'tcx>>,\n+    pub caller_bounds: ty::GenericBounds<'tcx>,\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n@@ -1762,7 +1809,6 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n-                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -1797,7 +1843,6 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n-                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -1824,7 +1869,6 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                         let fn_pty = ty::lookup_item_type(cx, fn_def_id);\n \n                         construct_parameter_environment(cx,\n-                                                        item.span,\n                                                         &fn_pty.generics,\n                                                         body.id)\n                     }\n@@ -1835,8 +1879,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                     ast::ItemStatic(..) => {\n                         let def_id = ast_util::local_def(id);\n                         let pty = ty::lookup_item_type(cx, def_id);\n-                        construct_parameter_environment(cx, item.span,\n-                                                        &pty.generics, id)\n+                        construct_parameter_environment(cx, &pty.generics, id)\n                     }\n                     _ => {\n                         cx.sess.span_bug(item.span,\n@@ -3141,7 +3184,8 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n pub fn type_moves_by_default<'tcx>(cx: &ctxt<'tcx>,\n                                    ty: Ty<'tcx>,\n                                    param_env: &ParameterEnvironment<'tcx>)\n-                                    -> bool {\n+                                   -> bool\n+{\n     if !type_has_params(ty) && !type_has_self(ty) {\n         match cx.type_moves_by_default_cache.borrow().get(&ty) {\n             None => {}\n@@ -3156,20 +3200,26 @@ pub fn type_moves_by_default<'tcx>(cx: &ctxt<'tcx>,\n \n     let infcx = infer::new_infer_ctxt(cx);\n     let mut fulfill_cx = traits::FulfillmentContext::new();\n-    let obligation = traits::obligation_for_builtin_bound(\n-        cx,\n-        ObligationCause::misc(DUMMY_SP),\n-        ty,\n-        ty::BoundCopy).unwrap();\n-    fulfill_cx.register_obligation(cx, obligation);\n-    let result = !fulfill_cx.select_all_or_error(&infcx,\n-                                                 param_env,\n-                                                 cx).is_ok();\n-    cx.type_moves_by_default_cache.borrow_mut().insert(ty, result);\n+\n+    // we can use dummy values here because we won't report any errors\n+    // that result nor will we pay any mind to region obligations that arise\n+    // (there shouldn't really be any anyhow)\n+    let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n+\n+    fulfill_cx.register_builtin_bound(cx, ty, ty::BoundCopy, cause);\n+\n+    // Note: we only assuming something is `Copy` if we can\n+    // *definitively* show that it implements `Copy`. Otherwise,\n+    // assume it is move; linear is always ok.\n+    let is_copy = fulfill_cx.select_all_or_error(&infcx, param_env, cx).is_ok();\n+    let is_move = !is_copy;\n+\n     debug!(\"determined whether {} moves by default: {}\",\n            ty_to_string(cx, ty),\n-           result);\n-    result\n+           is_move);\n+\n+    cx.type_moves_by_default_cache.borrow_mut().insert(ty, is_move);\n+    is_move\n }\n \n pub fn is_ffi_safe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -4979,11 +5029,11 @@ pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n     })\n }\n \n-/// Given a reference to a trait, returns the bounds declared on the\n-/// trait, with appropriate substitutions applied.\n-pub fn bounds_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n-                                  trait_ref: &TraitRef<'tcx>)\n-                                  -> ty::ParamBounds<'tcx>\n+/// Given a reference to a trait, returns the \"superbounds\" declared\n+/// on the trait, with appropriate substitutions applied.\n+pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n+                                      trait_ref: &TraitRef<'tcx>)\n+                                      -> Vec<ty::Predicate<'tcx>>\n {\n     let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n \n@@ -5074,11 +5124,39 @@ pub fn bounds_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n     let builtin_bounds =\n         trait_def.bounds.builtin_bounds.subst(tcx, &trait_ref.substs);\n \n-    ty::ParamBounds {\n+    let bounds = ty::ParamBounds {\n         trait_bounds: trait_bounds,\n         region_bounds: region_bounds,\n         builtin_bounds: builtin_bounds,\n+    };\n+\n+    predicates(tcx, trait_ref.self_ty(), &bounds)\n+}\n+\n+pub fn predicates<'tcx>(\n+    tcx: &ctxt<'tcx>,\n+    param_ty: Ty<'tcx>,\n+    bounds: &ParamBounds<'tcx>)\n+    -> Vec<Predicate<'tcx>>\n+{\n+    let mut vec = Vec::new();\n+\n+    for builtin_bound in bounds.builtin_bounds.iter() {\n+        match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n+            Ok(trait_ref) => { vec.push(Predicate::Trait(trait_ref)); }\n+            Err(ErrorReported) => { }\n+        }\n+    }\n+\n+    for &region_bound in bounds.region_bounds.iter() {\n+        vec.push(Predicate::TypeOutlives(param_ty, region_bound));\n+    }\n+\n+    for bound_trait_ref in bounds.trait_bounds.iter() {\n+        vec.push(Predicate::Trait((*bound_trait_ref).clone()));\n     }\n+\n+    vec\n }\n \n /// Iterate over attributes of a definition.\n@@ -5436,56 +5514,62 @@ pub fn each_bound_trait_and_supertraits<'tcx>(tcx: &ctxt<'tcx>,\n     return true;\n }\n \n+pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n+                                  opt_principal: Option<&TraitRef<'tcx>>, // None for boxed closures\n+                                  others: BuiltinBounds)\n+                                  -> Vec<ty::Region>\n+{\n+    // Since we don't actually *know* the self type for an object,\n+    // this \"open(err)\" serves as a kind of dummy standin -- basically\n+    // a skolemized type.\n+    let open_ty = ty::mk_infer(tcx, SkolemizedTy(0));\n+\n+    let opt_trait_ref = opt_principal.map_or(Vec::new(), |principal| {\n+        let substs = principal.substs.with_self_ty(open_ty);\n+        vec!(Rc::new(ty::TraitRef::new(principal.def_id, substs)))\n+    });\n+\n+    let param_bounds = ty::ParamBounds {\n+        region_bounds: Vec::new(),\n+        builtin_bounds: others,\n+        trait_bounds: opt_trait_ref,\n+    };\n+\n+    let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n+    ty::required_region_bounds(tcx, open_ty, predicates)\n+}\n+\n /// Given a type which must meet the builtin bounds and trait bounds, returns a set of lifetimes\n /// which the type must outlive.\n ///\n /// Requires that trait definitions have been processed.\n pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n-                                    region_bounds: &[ty::Region],\n-                                    builtin_bounds: BuiltinBounds,\n-                                    trait_bounds: &[Rc<TraitRef<'tcx>>])\n+                                    param_ty: Ty<'tcx>,\n+                                    predicates: Vec<ty::Predicate<'tcx>>)\n                                     -> Vec<ty::Region>\n {\n-    let mut all_bounds = Vec::new();\n-\n-    debug!(\"required_region_bounds(builtin_bounds={}, trait_bounds={})\",\n-           builtin_bounds.repr(tcx),\n-           trait_bounds.repr(tcx));\n-\n-    all_bounds.push_all(region_bounds);\n-\n-    push_region_bounds(&[],\n-                       builtin_bounds,\n-                       &mut all_bounds);\n-\n-    debug!(\"from builtin bounds: all_bounds={}\", all_bounds.repr(tcx));\n-\n-    each_bound_trait_and_supertraits(\n-        tcx,\n-        trait_bounds,\n-        |trait_ref| {\n-            let bounds = ty::bounds_for_trait_ref(tcx, &*trait_ref);\n-            push_region_bounds(bounds.region_bounds.as_slice(),\n-                               bounds.builtin_bounds,\n-                               &mut all_bounds);\n-            debug!(\"from {}: bounds={} all_bounds={}\",\n-                   trait_ref.repr(tcx),\n-                   bounds.repr(tcx),\n-                   all_bounds.repr(tcx));\n-            true\n-        });\n-\n-    return all_bounds;\n-\n-    fn push_region_bounds(region_bounds: &[ty::Region],\n-                          builtin_bounds: ty::BuiltinBounds,\n-                          all_bounds: &mut Vec<ty::Region>) {\n-        all_bounds.push_all(region_bounds.as_slice());\n-\n-        if builtin_bounds.contains(&ty::BoundSend) {\n-            all_bounds.push(ty::ReStatic);\n-        }\n-    }\n+    debug!(\"required_region_bounds(param_ty={}, predicates={})\",\n+           param_ty.repr(tcx),\n+           predicates.repr(tcx));\n+\n+    traits::elaborate_predicates(tcx, predicates)\n+        .filter_map(|predicate| {\n+            match predicate {\n+                ty::Predicate::Trait(..) |\n+                ty::Predicate::Equate(..) |\n+                ty::Predicate::RegionOutlives(..) => {\n+                    None\n+                }\n+                ty::Predicate::TypeOutlives(t, r) => {\n+                    if t == param_ty {\n+                        Some(r)\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        })\n+        .collect()\n }\n \n pub fn get_tydesc_ty<'tcx>(tcx: &ctxt<'tcx>) -> Result<Ty<'tcx>, String> {\n@@ -5835,16 +5919,14 @@ impl Variance {\n /// are no free type/lifetime parameters in scope.\n pub fn empty_parameter_environment<'tcx>() -> ParameterEnvironment<'tcx> {\n     ty::ParameterEnvironment { free_substs: Substs::empty(),\n-                               bounds: VecPerParamSpace::empty(),\n-                               caller_obligations: VecPerParamSpace::empty(),\n+                               caller_bounds: GenericBounds::empty(),\n                                implicit_region_bound: ty::ReEmpty,\n                                selection_cache: traits::SelectionCache::new(), }\n }\n \n /// See `ParameterEnvironment` struct def'n for details\n pub fn construct_parameter_environment<'tcx>(\n     tcx: &ctxt<'tcx>,\n-    span: Span,\n     generics: &ty::Generics<'tcx>,\n     free_id: ast::NodeId)\n     -> ParameterEnvironment<'tcx>\n@@ -5881,35 +5963,24 @@ pub fn construct_parameter_environment<'tcx>(\n \n     let bounds = generics.to_bounds(tcx, &free_substs);\n     let bounds = liberate_late_bound_regions(tcx, free_id_scope, &bind(bounds)).value;\n-    let obligations = traits::obligations_for_generics(tcx,\n-                                                       traits::ObligationCause::misc(span),\n-                                                       &bounds,\n-                                                       &free_substs.types);\n-    let type_bounds = bounds.types.subst(tcx, &free_substs);\n \n     //\n     // Compute region bounds. For now, these relations are stored in a\n     // global table on the tcx, so just enter them there. I'm not\n     // crazy about this scheme, but it's convenient, at least.\n     //\n \n-    for &space in subst::ParamSpace::all().iter() {\n-        record_region_bounds(tcx, space, &free_substs, bounds.regions.get_slice(space));\n-    }\n+    record_region_bounds(tcx, &bounds);\n \n-\n-    debug!(\"construct_parameter_environment: free_id={} free_subst={} \\\n-           obligations={} type_bounds={}\",\n+    debug!(\"construct_parameter_environment: free_id={} free_subst={} bounds={}\",\n            free_id,\n            free_substs.repr(tcx),\n-           obligations.repr(tcx),\n-           type_bounds.repr(tcx));\n+           bounds.repr(tcx));\n \n     return ty::ParameterEnvironment {\n         free_substs: free_substs,\n-        bounds: bounds.types,\n         implicit_region_bound: ty::ReScope(free_id_scope),\n-        caller_obligations: obligations,\n+        caller_bounds: bounds,\n         selection_cache: traits::SelectionCache::new(),\n     };\n \n@@ -5938,31 +6009,24 @@ pub fn construct_parameter_environment<'tcx>(\n         }\n     }\n \n-    fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                  space: subst::ParamSpace,\n-                                  free_substs: &Substs<'tcx>,\n-                                  bound_sets: &[Vec<ty::Region>]) {\n-        for (subst_region, bound_set) in\n-            free_substs.regions().get_slice(space).iter().zip(\n-                bound_sets.iter())\n-        {\n-            // For each region parameter 'subst...\n-            for bound_region in bound_set.iter() {\n-                // Which is declared with a bound like 'subst:'bound...\n-                match (subst_region, bound_region) {\n-                    (&ty::ReFree(subst_fr), &ty::ReFree(bound_fr)) => {\n-                        // Record that 'subst outlives 'bound. Or, put\n-                        // another way, 'bound <= 'subst.\n-                        tcx.region_maps.relate_free_regions(bound_fr, subst_fr);\n-                    },\n-                    _ => {\n-                        // All named regions are instantiated with free regions.\n-                        tcx.sess.bug(\n-                            format!(\"record_region_bounds: \\\n-                                     non free region: {} / {}\",\n-                                    subst_region.repr(tcx),\n-                                    bound_region.repr(tcx)).as_slice());\n-                    }\n+    fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, bounds: &GenericBounds<'tcx>) {\n+        debug!(\"record_region_bounds(bounds={})\", bounds.repr(tcx));\n+\n+        for predicate in bounds.predicates.iter() {\n+            match *predicate {\n+                Predicate::Trait(..) | Predicate::Equate(..) | Predicate::TypeOutlives(..) => {\n+                    // No region bounds here\n+                }\n+                Predicate::RegionOutlives(ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n+                    // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n+                    tcx.region_maps.relate_free_regions(fr_b, fr_a);\n+                }\n+                Predicate::RegionOutlives(r_a, r_b) => {\n+                    // All named regions are instantiated with free regions.\n+                    tcx.sess.bug(\n+                        format!(\"record_region_bounds: non free region: {} / {}\",\n+                                r_a.repr(tcx),\n+                                r_b.repr(tcx)).as_slice());\n                 }\n             }\n         }\n@@ -6281,6 +6345,17 @@ impl<'tcx> Repr<'tcx> for TyTrait<'tcx> {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for ty::Predicate<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        match *self {\n+            Predicate::Trait(ref a) => a.repr(tcx),\n+            Predicate::Equate(a, b) => format!(\"Equate({},{})\", a.repr(tcx), b.repr(tcx)),\n+            Predicate::RegionOutlives(a, b) => format!(\"Outlives({}:{})\", a.repr(tcx), b.repr(tcx)),\n+            Predicate::TypeOutlives(a, b) => format!(\"Outlives({}:{})\", a.repr(tcx), b.repr(tcx)),\n+        }\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for vtable_origin<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {"}, {"sha": "8b54a46bfb934d4d28249ce5f95e4fad476e2020", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -137,11 +137,6 @@ pub trait TypeFolder<'tcx> {\n     fn fold_item_substs(&mut self, i: ty::ItemSubsts<'tcx>) -> ty::ItemSubsts<'tcx> {\n         super_fold_item_substs(self, i)\n     }\n-\n-    fn fold_obligation(&mut self, o: &traits::Obligation<'tcx>)\n-                       -> traits::Obligation<'tcx> {\n-        super_fold_obligation(self, o)\n-    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -404,15 +399,33 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n         ty::Generics {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n+            predicates: self.predicates.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Predicate<'tcx> {\n+        match *self {\n+            ty::Predicate::Trait(ref a) =>\n+                ty::Predicate::Trait(a.fold_with(folder)),\n+            ty::Predicate::Equate(ref a, ref b) =>\n+                ty::Predicate::Equate(a.fold_with(folder),\n+                                        b.fold_with(folder)),\n+            ty::Predicate::RegionOutlives(ref a, ref b) =>\n+                ty::Predicate::RegionOutlives(a.fold_with(folder),\n+                                                b.fold_with(folder)),\n+            ty::Predicate::TypeOutlives(ref a, ref b) =>\n+                ty::Predicate::TypeOutlives(a.fold_with(folder),\n+                                              b.fold_with(folder)),\n         }\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::GenericBounds<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericBounds<'tcx> {\n         ty::GenericBounds {\n-            types: self.types.fold_with(folder),\n-            regions: self.regions.fold_with(folder),\n+            predicates: self.predicates.fold_with(folder),\n         }\n     }\n }\n@@ -434,9 +447,15 @@ impl<'tcx> TypeFoldable<'tcx> for ty::UnsizeKind<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::Obligation<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx> {\n-        folder.fold_obligation(self)\n+impl<'tcx,O> TypeFoldable<'tcx> for traits::Obligation<'tcx,O>\n+    where O : TypeFoldable<'tcx>\n+{\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx, O> {\n+        traits::Obligation {\n+            cause: self.cause,\n+            recursion_depth: self.recursion_depth,\n+            trait_ref: self.trait_ref.fold_with(folder),\n+        }\n     }\n }\n \n@@ -687,17 +706,6 @@ pub fn super_fold_item_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_obligation<'tcx, T:TypeFolder<'tcx>>(this: &mut T,\n-                                                       obligation: &traits::Obligation<'tcx>)\n-                                                       -> traits::Obligation<'tcx>\n-{\n-    traits::Obligation {\n-        cause: obligation.cause,\n-        recursion_depth: obligation.recursion_depth,\n-        trait_ref: obligation.trait_ref.fold_with(this),\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Higher-ranked things\n "}, {"sha": "7a14ed9cca8c932c52b82f499eedce5f30895647", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -914,17 +914,17 @@ impl<'tcx> Repr<'tcx> for ty::Polytype<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ty::Generics<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Generics(types: {}, regions: {})\",\n+        format!(\"Generics(types: {}, regions: {}, predicates: {})\",\n                 self.types.repr(tcx),\n-                self.regions.repr(tcx))\n+                self.regions.repr(tcx),\n+                self.predicates.repr(tcx))\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ty::GenericBounds<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"GenericBounds(types: {}, regions: {})\",\n-                self.types.repr(tcx),\n-                self.regions.repr(tcx))\n+        format!(\"GenericBounds({})\",\n+                self.predicates.repr(tcx))\n     }\n }\n "}, {"sha": "83938fa335708fe8d174ce4a3942c2e24e53cbb8", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -793,7 +793,8 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n     let mut selcx = traits::SelectionContext::new(&infcx, &param_env, tcx);\n-    let obligation = traits::Obligation::misc(span, trait_ref.clone());\n+    let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                             trait_ref.clone());\n     let selection = match selcx.select(&obligation) {\n         Ok(Some(selection)) => selection,\n         Ok(None) => {\n@@ -826,8 +827,8 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // fully bound. It could be a slight optimization to stop\n     // iterating early.\n     let mut fulfill_cx = traits::FulfillmentContext::new();\n-    let vtable = selection.map_move_nested(|obligation| {\n-        fulfill_cx.register_obligation(tcx, obligation);\n+    let vtable = selection.map_move_nested(|predicate| {\n+        fulfill_cx.register_predicate(infcx.tcx, predicate);\n     });\n     match fulfill_cx.select_all_or_error(&infcx, &param_env, tcx) {\n         Ok(()) => { }"}, {"sha": "4ad0d2b8293e1664980deff4de312a7f549e8d1e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 37, "deletions": 49, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -800,7 +800,7 @@ fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n     let existential_bounds = conv_existential_bounds(this,\n                                                      rscope,\n                                                      span,\n-                                                     &[Rc::new(trait_ref.clone())],\n+                                                     Some(&trait_ref),\n                                                      bounds);\n \n     let result = ty::mk_trait(this.tcx(), trait_ref, existential_bounds);\n@@ -918,7 +918,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 let bounds = conv_existential_bounds(this,\n                                                      rscope,\n                                                      ast_ty.span,\n-                                                     [].as_slice(),\n+                                                     None,\n                                                      f.bounds.as_slice());\n                 let fn_decl = ty_of_closure(this,\n                                             f.fn_style,\n@@ -935,9 +935,10 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyProc(ref f) => {\n                 // Use corresponding trait store to figure out default bounds\n                 // if none were specified.\n-                let bounds = conv_existential_bounds(this, rscope,\n+                let bounds = conv_existential_bounds(this,\n+                                                     rscope,\n                                                      ast_ty.span,\n-                                                     [].as_slice(),\n+                                                     None,\n                                                      f.bounds.as_slice());\n \n                 let fn_decl = ty_of_closure(this,\n@@ -1370,7 +1371,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    main_trait_refs: &[Rc<ty::TraitRef<'tcx>>],\n+    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for boxed closures\n     ast_bounds: &[ast::TyParamBound])\n     -> ty::ExistentialBounds\n {\n@@ -1381,7 +1382,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n         partition_bounds(this.tcx(), span, ast_bound_refs.as_slice());\n \n     conv_existential_bounds_from_partitioned_bounds(\n-        this, rscope, span, main_trait_refs, partitioned_bounds)\n+        this, rscope, span, principal_trait_ref, partitioned_bounds)\n }\n \n fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n@@ -1411,11 +1412,12 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n         }\n     };\n \n-    let bounds = conv_existential_bounds_from_partitioned_bounds(this,\n-                                                                 rscope,\n-                                                                 span,\n-                                                                 main_trait_bound.as_slice(),\n-                                                                 partitioned_bounds);\n+    let bounds =\n+        conv_existential_bounds_from_partitioned_bounds(this,\n+                                                        rscope,\n+                                                        span,\n+                                                        main_trait_bound.as_ref().map(|tr| &**tr),\n+                                                        partitioned_bounds);\n \n     match main_trait_bound {\n         None => ty::mk_err(),\n@@ -1427,7 +1429,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    main_trait_refs: &[Rc<ty::TraitRef<'tcx>>],\n+    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for boxed closures\n     partitioned_bounds: PartitionedBounds)\n     -> ty::ExistentialBounds\n     where AC: AstConv<'tcx>, RS:RegionScope\n@@ -1445,28 +1447,12 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n                      as closure or object bounds\").as_slice());\n     }\n \n-    // The \"main trait refs\", rather annoyingly, have no type\n-    // specified for the `Self` parameter of the trait. The reason for\n-    // this is that they are, after all, *existential* types, and\n-    // hence that type is unknown. However, leaving this type missing\n-    // causes the substitution code to go all awry when walking the\n-    // bounds, so here we clone those trait refs and insert ty::err as\n-    // the self type. Perhaps we should do this more generally, it'd\n-    // be convenient (or perhaps something else, i.e., ty::erased).\n-    let main_trait_refs: Vec<Rc<ty::TraitRef>> =\n-        main_trait_refs.iter()\n-        .map(|t|\n-             Rc::new(ty::TraitRef {\n-                 def_id: t.def_id,\n-                 substs: t.substs.with_self_ty(ty::mk_err()) }))\n-        .collect();\n-\n     let region_bound = compute_region_bound(this,\n                                             rscope,\n                                             span,\n-                                            builtin_bounds,\n                                             region_bounds.as_slice(),\n-                                            main_trait_refs.as_slice());\n+                                            principal_trait_ref,\n+                                            builtin_bounds);\n \n     ty::ExistentialBounds {\n         region_bound: region_bound,\n@@ -1478,33 +1464,35 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n /// (if any) we can use to summarize this type. The basic idea is that we will use the bound the\n /// user provided, if they provided one, and otherwise search the supertypes of trait bounds for\n /// region bounds. It may be that we can derive no bound at all, in which case we return `None`.\n-pub fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      span: Span,\n-                                      builtin_bounds: ty::BuiltinBounds,\n-                                      region_bounds: &[&ast::Lifetime],\n-                                      trait_bounds: &[Rc<ty::TraitRef<'tcx>>])\n-                                      -> Option<ty::Region>\n+fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  span: Span,\n+                                  explicit_region_bounds: &[&ast::Lifetime],\n+                                  principal_trait_ref: Option<&ty::TraitRef<'tcx>>,\n+                                  builtin_bounds: ty::BuiltinBounds)\n+                                  -> Option<ty::Region>\n {\n-    if region_bounds.len() > 1 {\n+    debug!(\"compute_opt_region_bound(explicit_region_bounds={}, \\\n+           principal_trait_ref={}, builtin_bounds={})\",\n+           explicit_region_bounds,\n+           principal_trait_ref.repr(tcx),\n+           builtin_bounds.repr(tcx));\n+\n+    if explicit_region_bounds.len() > 1 {\n         tcx.sess.span_err(\n-            region_bounds[1].span,\n+            explicit_region_bounds[1].span,\n             format!(\"only a single explicit lifetime bound is permitted\").as_slice());\n     }\n \n-    if region_bounds.len() != 0 {\n+    if explicit_region_bounds.len() != 0 {\n         // Explicitly specified region bound. Use that.\n-        let r = region_bounds[0];\n+        let r = explicit_region_bounds[0];\n         return Some(ast_region_to_region(tcx, r));\n     }\n \n     // No explicit region bound specified. Therefore, examine trait\n     // bounds and see if we can derive region bounds from those.\n     let derived_region_bounds =\n-        ty::required_region_bounds(\n-            tcx,\n-            &[],\n-            builtin_bounds,\n-            trait_bounds);\n+        ty::object_region_bounds(tcx, principal_trait_ref, builtin_bounds);\n \n     // If there are no derived region bounds, then report back that we\n     // can find no region bound.\n@@ -1538,13 +1526,13 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    builtin_bounds: ty::BuiltinBounds,\n     region_bounds: &[&ast::Lifetime],\n-    trait_bounds: &[Rc<ty::TraitRef<'tcx>>])\n+    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for closures\n+    builtin_bounds: ty::BuiltinBounds)\n     -> ty::Region\n {\n-    match compute_opt_region_bound(this.tcx(), span, builtin_bounds,\n-                                   region_bounds, trait_bounds) {\n+    match compute_opt_region_bound(this.tcx(), span, region_bounds,\n+                                   principal_trait_ref, builtin_bounds) {\n         Some(r) => r,\n         None => {\n             match rscope.default_region_bound(span) {"}, {"sha": "2b34b4a55b7c11460c753f8fcd1373ac0dba9a88", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -232,16 +232,24 @@ fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n     -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n {\n     // Here `expected_ty` is known to be a type inference variable.\n-    for obligation in fcx.inh.fulfillment_cx.borrow().pending_trait_obligations().iter() {\n-        let obligation_self_ty = fcx.infcx().shallow_resolve(obligation.self_ty());\n-        match obligation_self_ty.sty {\n-            ty::ty_infer(ty::TyVar(v)) if expected_vid == v => { }\n-            _ => { continue; }\n-        }\n+    for obligation in fcx.inh.fulfillment_cx.borrow().pending_obligations().iter() {\n+        match obligation.trait_ref {\n+            ty::Predicate::Trait(ref trait_ref) => {\n+                let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n+                match self_ty.sty {\n+                    ty::ty_infer(ty::TyVar(v)) if expected_vid == v => { }\n+                    _ => { continue; }\n+                }\n \n-        match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &*obligation.trait_ref) {\n-            Some(e) => { return Some(e); }\n-            None => { }\n+                match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &**trait_ref) {\n+                    Some(e) => { return Some(e); }\n+                    None => { }\n+                }\n+            }\n+            ty::Predicate::Equate(..) |\n+            ty::Predicate::RegionOutlives(..) |\n+            ty::Predicate::TypeOutlives(..) => {\n+            }\n         }\n     }\n "}, {"sha": "bf1f2c0ce809a165f41a8e9c10b4c649c40967ca", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -462,8 +462,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                method_bounds.repr(self.tcx()));\n \n         self.fcx.add_obligations_for_parameters(\n-            traits::ObligationCause::misc(self.span),\n-            method_bounds_substs,\n+            traits::ObligationCause::misc(self.span, self.fcx.body_id),\n             method_bounds);\n \n         self.fcx.add_default_region_param_bounds("}, {"sha": "d081b97b71ad8448ecc3b8750bbd430952dc5307", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -169,7 +169,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n \n     // Construct an obligation\n-    let obligation = traits::Obligation::misc(span, trait_ref.clone());\n+    let obligation = traits::Obligation::misc(span,\n+                                              fcx.body_id,\n+                                              ty::Predicate::Trait(trait_ref.clone()));\n \n     // Now we want to know if this can be matched\n     let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n@@ -187,6 +189,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n     assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n \n+    debug!(\"lookup_in_trait_adjusted: method_num={} method_ty={}\",\n+           method_num, method_ty.repr(fcx.tcx()));\n+\n     // Substitute the trait parameters into the method type and\n     // instantiate late-bound regions to get the actual method type.\n     //\n@@ -204,7 +209,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n         abi: bare_fn_ty.abi.clone(),\n     });\n \n-    debug!(\"matched method fty={} obligation={}\",\n+    debug!(\"lookup_in_trait_adjusted: matched method fty={} obligation={}\",\n            fty.repr(fcx.tcx()),\n            obligation.repr(fcx.tcx()));\n \n@@ -219,8 +224,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     let method_bounds = method_ty.generics.to_bounds(fcx.tcx(), &trait_ref.substs);\n     assert!(!method_bounds.has_escaping_regions());\n     fcx.add_obligations_for_parameters(\n-        traits::ObligationCause::misc(span),\n-        &trait_ref.substs,\n+        traits::ObligationCause::misc(span, fcx.body_id),\n         &method_bounds);\n \n     // FIXME(#18653) -- Try to resolve obligations, giving us more\n@@ -233,8 +237,8 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n         None => { }\n \n         Some(self_expr) => {\n-            debug!(\"inserting adjustment if needed (self-id = {}, \\\n-                   base adjustment = {}, explicit self = {})\",\n+            debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n+                   (self-id={}, base adjustment={}, explicit_self={})\",\n                    self_expr.id, autoderefref, method_ty.explicit_self);\n \n             match method_ty.explicit_self {"}, {"sha": "f0f527f667354c356e6ed6c2ea7f2af8672e2335", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -353,11 +353,27 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                param_ty: ty::ParamTy) {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n-        let ty::ParamTy { space, idx: index, .. } = param_ty;\n-        let bounds =\n-            self.fcx.inh.param_env.bounds.get(space, index).trait_bounds\n-            .as_slice();\n-        self.elaborate_bounds(bounds, true, |this, trait_ref, m, method_num| {\n+        let bounds: Vec<_> =\n+            self.fcx.inh.param_env.caller_bounds.predicates\n+            .iter()\n+            .filter_map(|predicate| {\n+                match *predicate {\n+                    ty::Predicate::Trait(ref trait_ref) => {\n+                        match trait_ref.self_ty().sty {\n+                            ty::ty_param(ref p) if *p == param_ty => Some(trait_ref.clone()),\n+                            _ => None\n+                        }\n+                    }\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::TypeOutlives(..) => {\n+                        None\n+                    }\n+                }\n+            })\n+            .collect();\n+\n+        self.elaborate_bounds(bounds.as_slice(), true, |this, trait_ref, m, method_num| {\n             let xform_self_ty =\n                 this.xform_self_ty(&m, &trait_ref.substs);\n \n@@ -400,6 +416,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                           m: Rc<ty::Method<'tcx>>,\n                           method_num: uint|)\n     {\n+        debug!(\"elaborate_bounds(bounds={})\", bounds.repr(self.tcx()));\n+\n         let tcx = self.tcx();\n         let mut cache = HashSet::new();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n@@ -802,11 +820,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n                     // Convert the bounds into obligations.\n                     let obligations =\n-                        traits::obligations_for_generics(\n+                        traits::predicates_for_generics(\n                             self.tcx(),\n-                            traits::ObligationCause::misc(self.span),\n-                            &impl_bounds,\n-                            &substs.types);\n+                            traits::ObligationCause::misc(self.span, self.fcx.body_id),\n+                            &impl_bounds);\n                     debug!(\"impl_obligations={}\", obligations.repr(self.tcx()));\n \n                     // Evaluate those obligations to see if they might possibly hold."}, {"sha": "573c63eb6af05563265e39f13bc354237716b78e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 39, "deletions": 149, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -84,13 +84,14 @@ use self::TupleArgumentsFlag::*;\n \n use astconv::{mod, ast_region_to_region, ast_ty_to_ty, AstConv};\n use check::_match::pat_ctxt;\n-use middle::{const_eval, def, traits};\n+use middle::{const_eval, def};\n use middle::infer;\n use middle::lang_items::IteratorItem;\n use middle::mem_categorization::{mod, McResult};\n use middle::pat_util::{mod, pat_id_map};\n use middle::region::CodeExtent;\n use middle::subst::{mod, Subst, Substs, VecPerParamSpace, ParamSpace};\n+use middle::traits;\n use middle::ty::{FnSig, VariantInfo, Polytype};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{mod, Ty};\n@@ -108,7 +109,6 @@ use util::ppaux::{mod, UserString, Repr};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n-use std::collections::hash_map::{Occupied, Vacant};\n use std::mem::replace;\n use std::rc::Rc;\n use syntax::{mod, abi, attr};\n@@ -161,42 +161,10 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // one is never copied into the tcx: it is only used by regionck.\n     fn_sig_map: RefCell<NodeMap<Vec<Ty<'tcx>>>>,\n \n-    // A set of constraints that regionck must validate. Each\n-    // constraint has the form `T:'a`, meaning \"some type `T` must\n-    // outlive the lifetime 'a\". These constraints derive from\n-    // instantiated type parameters. So if you had a struct defined\n-    // like\n-    //\n-    //     struct Foo<T:'static> { ... }\n-    //\n-    // then in some expression `let x = Foo { ... }` it will\n-    // instantiate the type parameter `T` with a fresh type `$0`. At\n-    // the same time, it will record a region obligation of\n-    // `$0:'static`. This will get checked later by regionck. (We\n-    // can't generally check these things right away because we have\n-    // to wait until types are resolved.)\n-    //\n-    // These are stored in a map keyed to the id of the innermost\n-    // enclosing fn body / static initializer expression. This is\n-    // because the location where the obligation was incurred can be\n-    // relevant with respect to which sublifetime assumptions are in\n-    // place. The reason that we store under the fn-id, and not\n-    // something more fine-grained, is so that it is easier for\n-    // regionck to be sure that it has found *all* the region\n-    // obligations (otherwise, it's easy to fail to walk to a\n-    // particular node-id).\n-    region_obligations: RefCell<NodeMap<Vec<RegionObligation<'tcx>>>>,\n-\n     // Tracks trait obligations incurred during this function body.\n     fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n }\n \n-struct RegionObligation<'tcx> {\n-    sub_region: ty::Region,\n-    sup_type: Ty<'tcx>,\n-    origin: infer::SubregionOrigin<'tcx>,\n-}\n-\n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n enum Expectation<'tcx> {\n@@ -328,7 +296,6 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             upvar_borrow_map: RefCell::new(FnvHashMap::new()),\n             unboxed_closures: RefCell::new(DefIdMap::new()),\n             fn_sig_map: RefCell::new(NodeMap::new()),\n-            region_obligations: RefCell::new(NodeMap::new()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n         }\n     }\n@@ -1762,8 +1729,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` outlives `'a`:\n-                let origin = infer::RelateObjectBound(span);\n-                self.register_region_obligation(origin, self_ty, ty_trait.bounds.region_bound);\n+                let cause = traits::ObligationCause { span: span,\n+                                                      body_id: self.body_id,\n+                                                      code: traits::ObjectCastObligation(self_ty) };\n+                self.register_region_obligation(self_ty, ty_trait.bounds.region_bound, cause);\n             }\n         }\n     }\n@@ -1790,8 +1759,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 span,\n+                self.body_id,\n                 traits::ItemObligation(def_id)),\n-            &substs,\n             &bounds);\n         let monotype =\n             polytype.ty.subst(self.tcx(), &substs);\n@@ -1815,14 +1784,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                               code: traits::ObligationCauseCode<'tcx>,\n                               bound: ty::BuiltinBound)\n     {\n-        let obligation = traits::obligation_for_builtin_bound(\n-            self.tcx(),\n-            traits::ObligationCause::new(span, code),\n+        self.register_builtin_bound(\n             ty,\n-            bound);\n-        if let Ok(ob) = obligation {\n-            self.register_obligation(ob);\n-        }\n+            bound,\n+            traits::ObligationCause::new(span, self.body_id, code));\n     }\n \n     pub fn require_type_is_sized(&self,\n@@ -1840,15 +1805,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n     }\n \n-    pub fn register_obligation(&self,\n-                               obligation: traits::Obligation<'tcx>)\n+    pub fn register_builtin_bound(&self,\n+                                  ty: Ty<'tcx>,\n+                                  builtin_bound: ty::BuiltinBound,\n+                                  cause: traits::ObligationCause<'tcx>)\n+    {\n+        self.inh.fulfillment_cx.borrow_mut()\n+            .register_builtin_bound(self.tcx(), ty, builtin_bound, cause);\n+    }\n+\n+    pub fn register_predicate(&self,\n+                              obligation: traits::PredicateObligation<'tcx>)\n     {\n-        debug!(\"register_obligation({})\",\n+        debug!(\"register_predicate({})\",\n                obligation.repr(self.tcx()));\n \n         self.inh.fulfillment_cx\n             .borrow_mut()\n-            .register_obligation(self.tcx(), obligation);\n+            .register_predicate(self.tcx(), obligation);\n     }\n \n     pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty<'tcx> {\n@@ -1983,19 +1957,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Registers an obligation for checking later, during regionck, that the type `ty` must\n     /// outlive the region `r`.\n     pub fn register_region_obligation(&self,\n-                                      origin: infer::SubregionOrigin<'tcx>,\n                                       ty: Ty<'tcx>,\n-                                      r: ty::Region)\n+                                      region: ty::Region,\n+                                      cause: traits::ObligationCause<'tcx>)\n     {\n-        let mut region_obligations = self.inh.region_obligations.borrow_mut();\n-        let region_obligation = RegionObligation { sub_region: r,\n-                                                   sup_type: ty,\n-                                                   origin: origin };\n-\n-        match region_obligations.entry(self.body_id) {\n-            Vacant(entry) => { entry.set(vec![region_obligation]); },\n-            Occupied(mut entry) => { entry.get_mut().push(region_obligation); },\n-        }\n+        let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n+        fulfillment_cx.register_region_obligation(self.tcx(), ty, region, cause);\n     }\n \n     pub fn add_default_region_param_bounds(&self,\n@@ -2004,8 +1971,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         for &ty in substs.types.iter() {\n             let default_bound = ty::ReScope(CodeExtent::from_node_id(expr.id));\n-            let origin = infer::RelateDefaultParamBound(expr.span, ty);\n-            self.register_region_obligation(origin, ty, default_bound);\n+            let cause = traits::ObligationCause::new(expr.span, self.body_id,\n+                                                     traits::MiscObligation);\n+            self.register_region_obligation(ty, default_bound, cause);\n         }\n     }\n \n@@ -2029,90 +1997,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// and `T`. This routine will add a region obligation `$1:'$0` and register it locally.\n     pub fn add_obligations_for_parameters(&self,\n                                           cause: traits::ObligationCause<'tcx>,\n-                                          substs: &Substs<'tcx>,\n                                           generic_bounds: &ty::GenericBounds<'tcx>)\n     {\n         assert!(!generic_bounds.has_escaping_regions());\n \n-        debug!(\"add_obligations_for_parameters(substs={}, generic_bounds={})\",\n-               substs.repr(self.tcx()),\n+        debug!(\"add_obligations_for_parameters(generic_bounds={})\",\n                generic_bounds.repr(self.tcx()));\n \n-        self.add_trait_obligations_for_generics(cause, substs, generic_bounds);\n-        self.add_region_obligations_for_generics(cause, substs, generic_bounds);\n-    }\n-\n-    fn add_trait_obligations_for_generics(&self,\n-                                          cause: traits::ObligationCause<'tcx>,\n-                                          substs: &Substs<'tcx>,\n-                                          generic_bounds: &ty::GenericBounds<'tcx>) {\n-        assert!(!generic_bounds.has_escaping_regions());\n-        assert!(!substs.has_regions_escaping_depth(0));\n-\n-        let obligations =\n-            traits::obligations_for_generics(self.tcx(),\n-                                             cause,\n-                                             generic_bounds,\n-                                             &substs.types);\n-        obligations.map_move(|o| self.register_obligation(o));\n-    }\n-\n-    fn add_region_obligations_for_generics(&self,\n-                                           cause: traits::ObligationCause<'tcx>,\n-                                           substs: &Substs<'tcx>,\n-                                           generic_bounds: &ty::GenericBounds<'tcx>)\n-    {\n-        assert!(!generic_bounds.has_escaping_regions());\n-        assert_eq!(generic_bounds.types.iter().len(), substs.types.iter().len());\n-\n-        for (type_bounds, &type_param) in\n-            generic_bounds.types.iter().zip(\n-                substs.types.iter())\n-        {\n-            self.add_region_obligations_for_type_parameter(\n-                cause.span, type_bounds, type_param);\n-        }\n-\n-        assert_eq!(generic_bounds.regions.iter().len(),\n-                   substs.regions().iter().len());\n-        for (region_bounds, &region_param) in\n-            generic_bounds.regions.iter().zip(\n-                substs.regions().iter())\n-        {\n-            self.add_region_obligations_for_region_parameter(\n-                cause.span, region_bounds.as_slice(), region_param);\n-        }\n-    }\n+        let obligations = traits::predicates_for_generics(self.tcx(),\n+                                                          cause,\n+                                                          generic_bounds);\n \n-    fn add_region_obligations_for_type_parameter(&self,\n-                                                 span: Span,\n-                                                 param_bound: &ty::ParamBounds<'tcx>,\n-                                                 ty: Ty<'tcx>)\n-    {\n-        // For each declared region bound `T:r`, `T` must outlive `r`.\n-        let region_bounds =\n-            ty::required_region_bounds(\n-                self.tcx(),\n-                param_bound.region_bounds.as_slice(),\n-                param_bound.builtin_bounds,\n-                param_bound.trait_bounds.as_slice());\n-        for &r in region_bounds.iter() {\n-            let origin = infer::RelateParamBound(span, ty);\n-            self.register_region_obligation(origin, ty, r);\n-        }\n-    }\n-\n-    fn add_region_obligations_for_region_parameter(&self,\n-                                                   span: Span,\n-                                                   region_bounds: &[ty::Region],\n-                                                   region_param: ty::Region)\n-    {\n-        for &b in region_bounds.iter() {\n-            // For each bound `region:b`, `b <= region` must hold\n-            // (i.e., `region` must outlive `b`).\n-            let origin = infer::RelateRegionParamBound(span);\n-            self.mk_subr(origin, b, region_param);\n-        }\n+        obligations.map_move(|o| self.register_predicate(o));\n     }\n }\n \n@@ -4065,6 +3961,9 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);\n         vtable::select_new_fcx_obligations(fcx);\n \n+        debug!(\"ExprForLoop each item has type {}\",\n+               fcx.infcx().resolve_type_vars_if_possible(typ).repr(fcx.tcx()));\n+\n         let pcx = pat_ctxt {\n             fcx: fcx,\n             map: pat_id_map(&tcx.def_map, &**pat),\n@@ -5197,8 +5096,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     debug!(\"after late-bounds have been replaced: bounds={}\", bounds.repr(fcx.tcx()));\n \n     fcx.add_obligations_for_parameters(\n-        traits::ObligationCause::new(span, traits::ItemObligation(def.def_id())),\n-        &substs,\n+        traits::ObligationCause::new(span, fcx.body_id, traits::ItemObligation(def.def_id())),\n         &bounds);\n \n     // Substitute the values for the type parameters into the type of\n@@ -5832,11 +5730,3 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for RegionObligation<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"RegionObligation(sub_region={}, sup_type={}, origin={})\",\n-                self.sub_region.repr(tcx),\n-                self.sup_type.repr(tcx),\n-                self.origin.repr(tcx))\n-    }\n-}"}, {"sha": "cadcee43b4402b845f9d85ba3c7700b379534167", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -353,18 +353,13 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n     {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n-        let region_obligations = self.fcx.inh.region_obligations.borrow();\n-        match region_obligations.get(&node_id) {\n-            None => { }\n-            Some(vec) => {\n-                for r_o in vec.iter() {\n-                    debug!(\"visit_region_obligations: r_o={}\",\n-                           r_o.repr(self.tcx()));\n-                    let sup_type = self.resolve_type(r_o.sup_type);\n-                    type_must_outlive(self, r_o.origin.clone(),\n-                                      sup_type, r_o.sub_region);\n-                }\n-            }\n+        let fulfillment_cx = self.fcx.inh.fulfillment_cx.borrow();\n+        for r_o in fulfillment_cx.region_obligations(node_id).iter() {\n+            debug!(\"visit_region_obligations: r_o={}\",\n+                   r_o.repr(self.tcx()));\n+            let sup_type = self.resolve_type(r_o.sup_type);\n+            let origin = infer::RelateRegionParamBound(r_o.cause.span);\n+            type_must_outlive(self, origin, sup_type, r_o.sub_region);\n         }\n     }\n \n@@ -937,14 +932,9 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n             // Check that the type meets the criteria of the existential bounds:\n             for builtin_bound in bounds.builtin_bounds.iter() {\n-                let code = traits::ClosureCapture(var_node_id, expr.span);\n-                let cause = traits::ObligationCause::new(freevar.span, code);\n-                let obligation = traits::obligation_for_builtin_bound(rcx.tcx(), cause,\n-                                                                      var_ty, builtin_bound);\n-                if let Ok(obligation) = obligation {\n-                    rcx.fcx.inh.fulfillment_cx.borrow_mut().register_obligation(rcx.tcx(),\n-                                                                                obligation)\n-                }\n+                let code = traits::ClosureCapture(var_node_id, expr.span, builtin_bound);\n+                let cause = traits::ObligationCause::new(freevar.span, rcx.fcx.body_id, code);\n+                rcx.fcx.register_builtin_bound(var_ty, builtin_bound, cause);\n             }\n             type_must_outlive(\n                 rcx, infer::RelateProcBound(expr.span, var_node_id, var_ty),\n@@ -1864,20 +1854,14 @@ fn param_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n            region.repr(rcx.tcx()),\n            param_ty.repr(rcx.tcx()));\n \n-    // Collect all regions that `param_ty` is known to outlive into\n-    // this vector:\n-    let mut param_bounds;\n-\n     // To start, collect bounds from user:\n-    let param_bound = param_env.bounds.get(param_ty.space, param_ty.idx);\n-    param_bounds =\n+    let mut param_bounds =\n         ty::required_region_bounds(rcx.tcx(),\n-                                   param_bound.region_bounds.as_slice(),\n-                                   param_bound.builtin_bounds,\n-                                   param_bound.trait_bounds.as_slice());\n+                                   param_ty.to_ty(rcx.tcx()),\n+                                   param_env.caller_bounds.predicates.as_slice().to_vec());\n \n-    // Collect default bound of fn body that applies to all in scope\n-    // type parameters:\n+    // Add in the default bound of fn body that applies to all in\n+    // scope type parameters:\n     param_bounds.push(param_env.implicit_region_bound);\n \n     // Finally, collect regions we scraped from the well-formedness"}, {"sha": "112ad1fb5b9b8c81e5cbdafe70b2731851d8df3c", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -97,7 +97,9 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             }\n \n             ty::ty_trait(ref t) => {\n-                self.accumulate_from_object_ty(ty, &t.bounds)\n+                let required_region_bounds =\n+                    ty::object_region_bounds(self.tcx, Some(&t.principal), t.bounds.builtin_bounds);\n+                self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n             }\n \n             ty::ty_enum(def_id, ref substs) |\n@@ -321,12 +323,15 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             ty::UniqTraitStore => { }\n         }\n \n-        self.accumulate_from_object_ty(ty, &c.bounds)\n+        let required_region_bounds =\n+            ty::object_region_bounds(self.tcx, None, c.bounds.builtin_bounds);\n+        self.accumulate_from_object_ty(ty, c.bounds.region_bound, required_region_bounds);\n     }\n \n     fn accumulate_from_object_ty(&mut self,\n                                  ty: Ty<'tcx>,\n-                                 bounds: &ty::ExistentialBounds)\n+                                 region_bound: ty::Region,\n+                                 required_region_bounds: Vec<ty::Region>)\n     {\n         // Imagine a type like this:\n         //\n@@ -362,17 +367,12 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n         // The content of this object type must outlive\n         // `bounds.region_bound`:\n-        let r_c = bounds.region_bound;\n+        let r_c = region_bound;\n         self.push_region_constraint_from_top(r_c);\n \n         // And then, in turn, to be well-formed, the\n         // `region_bound` that user specified must imply the\n         // region bounds required from all of the trait types:\n-        let required_region_bounds =\n-            ty::required_region_bounds(self.tcx,\n-                                       &[],\n-                                       bounds.builtin_bounds,\n-                                       &[]);\n         for &r_d in required_region_bounds.iter() {\n             // Each of these is an instance of the `'c <= 'b`\n             // constraint above"}, {"sha": "7c5ceb6f5107c8a5007dabfcde15672d926e040f", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 114, "deletions": 71, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -12,15 +12,14 @@ use check::{FnCtxt, structurally_resolved_type};\n use middle::subst::{SelfSpace, FnSpace};\n use middle::traits;\n use middle::traits::{SelectionError, OutputTypeParameterMismatch, Overflow, Unimplemented};\n-use middle::traits::{Obligation, obligation_for_builtin_bound};\n+use middle::traits::{Obligation, ObligationCause};\n use middle::traits::{FulfillmentError, CodeSelectionError, CodeAmbiguity};\n-use middle::traits::{ObligationCause};\n+use middle::traits::{PredicateObligation};\n use middle::ty::{mod, Ty};\n use middle::infer;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::common::ErrorReported;\n use util::ppaux::{UserString, Repr, ty_to_string};\n \n pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -249,18 +248,10 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   -> Rc<ty::TraitRef<'tcx>>\n {\n     // We can only make objects from sized types.\n-    let sized_obligation =\n-        traits::obligation_for_builtin_bound(\n-            fcx.tcx(),\n-            traits::ObligationCause::new(span, traits::ObjectSized),\n-            referent_ty,\n-            ty::BoundSized);\n-    match sized_obligation {\n-        Ok(sized_obligation) => {\n-            fcx.register_obligation(sized_obligation);\n-        }\n-        Err(ErrorReported) => { }\n-    }\n+    fcx.register_builtin_bound(\n+        referent_ty,\n+        ty::BoundSized,\n+        traits::ObligationCause::new(span, fcx.body_id, traits::ObjectSized));\n \n     // This is just for better error reporting. Kinda goofy. The object type stuff\n     // needs some refactoring so there is a more convenient type to pass around.\n@@ -287,24 +278,20 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let object_obligation =\n         Obligation::new(\n             ObligationCause::new(span,\n+                                 fcx.body_id,\n                                  traits::ObjectCastObligation(object_trait_ty)),\n-            object_trait_ref.clone());\n-    fcx.register_obligation(object_obligation);\n+            ty::Predicate::Trait(object_trait_ref.clone()));\n+    fcx.register_predicate(object_obligation);\n \n     // Create additional obligations for all the various builtin\n     // bounds attached to the object cast. (In other words, if the\n     // object type is Foo+Send, this would create an obligation\n     // for the Send check.)\n     for builtin_bound in object_trait.bounds.builtin_bounds.iter() {\n-            let obligation = obligation_for_builtin_bound(\n-                fcx.tcx(),\n-                ObligationCause::new(span,\n-                                     traits::ObjectCastObligation(object_trait_ty)),\n-                referent_ty,\n-                builtin_bound);\n-        if let Ok(obligation) = obligation {\n-            fcx.register_obligation(obligation);\n-        }\n+        fcx.register_builtin_bound(\n+            referent_ty,\n+            builtin_bound,\n+            ObligationCause::new(span, fcx.body_id, traits::ObjectCastObligation(object_trait_ty)));\n     }\n \n     object_trait_ref\n@@ -323,17 +310,6 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     }\n }\n \n-fn resolve_trait_ref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, obligation: &Obligation<'tcx>)\n-                               -> (Rc<ty::TraitRef<'tcx>>, Ty<'tcx>)\n-{\n-    let trait_ref =\n-        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n-            &*obligation.trait_ref);\n-    let self_ty =\n-        trait_ref.substs.self_ty().unwrap();\n-    (Rc::new(trait_ref), self_ty)\n-}\n-\n pub fn report_fulfillment_errors<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                            errors: &Vec<FulfillmentError<'tcx>>) {\n     for error in errors.iter() {\n@@ -354,18 +330,42 @@ pub fn report_fulfillment_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        obligation: &Obligation<'tcx>,\n+                                        obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)\n {\n     match *error {\n         Overflow => {\n-            let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n-            fcx.tcx().sess.span_err(\n-                obligation.cause.span,\n-                format!(\n-                    \"overflow evaluating the trait `{}` for the type `{}`\",\n-                    trait_ref.user_string(fcx.tcx()),\n-                    self_ty.user_string(fcx.tcx())).as_slice());\n+            // We could track the stack here more precisely if we wanted, I imagine.\n+            match obligation.trait_ref {\n+                ty::Predicate::Trait(ref trait_ref) => {\n+                    let trait_ref =\n+                        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(&**trait_ref);\n+                    fcx.tcx().sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"overflow evaluating the trait `{}` for the type `{}`\",\n+                            trait_ref.user_string(fcx.tcx()),\n+                            trait_ref.self_ty().user_string(fcx.tcx())).as_slice());\n+                }\n+\n+                ty::Predicate::Equate(a, b) => {\n+                    let a = fcx.infcx().resolve_type_vars_if_possible(a);\n+                    let b = fcx.infcx().resolve_type_vars_if_possible(b);\n+                    fcx.tcx().sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"overflow checking whether the types `{}` and `{}` are equal\",\n+                            a.user_string(fcx.tcx()),\n+                            b.user_string(fcx.tcx())).as_slice());\n+                }\n+\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::RegionOutlives(..) => {\n+                    fcx.tcx().sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\"overflow evaluating lifetime predicate\").as_slice());\n+                }\n+            }\n \n             let current_limit = fcx.tcx().sess.recursion_limit.get();\n             let suggested_limit = current_limit * 2;\n@@ -378,31 +378,63 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             note_obligation_cause(fcx, obligation);\n         }\n         Unimplemented => {\n-            let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n-            if !ty::type_is_error(self_ty) {\n-                fcx.tcx().sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n-                        \"the trait `{}` is not implemented for the type `{}`\",\n-                        trait_ref.user_string(fcx.tcx()),\n-                        self_ty.user_string(fcx.tcx())).as_slice());\n-                note_obligation_cause(fcx, obligation);\n+            match obligation.trait_ref {\n+                ty::Predicate::Trait(ref trait_ref) => {\n+                    let trait_ref =\n+                        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+                            &**trait_ref);\n+                    if !ty::type_is_error(trait_ref.self_ty()) {\n+                        fcx.tcx().sess.span_err(\n+                            obligation.cause.span,\n+                            format!(\n+                                \"the trait `{}` is not implemented for the type `{}`\",\n+                                trait_ref.user_string(fcx.tcx()),\n+                                trait_ref.self_ty().user_string(fcx.tcx())).as_slice());\n+                        note_obligation_cause(fcx, obligation);\n+                    }\n+                }\n+\n+                ty::Predicate::Equate(a, b) => {\n+                    let a = fcx.infcx().resolve_type_vars_if_possible(a);\n+                    let b = fcx.infcx().resolve_type_vars_if_possible(b);\n+                    let err = infer::can_mk_eqty(fcx.infcx(), a, b).unwrap_err();\n+                    fcx.tcx().sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"mismatched types: the types `{}` and `{}` are not equal ({})\",\n+                            a.user_string(fcx.tcx()),\n+                            b.user_string(fcx.tcx()),\n+                            ty::type_err_to_str(fcx.tcx(), &err)).as_slice());\n+                }\n+\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::RegionOutlives(..) => {\n+                    // these kinds of predicates turn into\n+                    // constraints, and hence errors show up in region\n+                    // inference.\n+                    fcx.tcx().sess.span_bug(\n+                        obligation.cause.span,\n+                        format!(\"region predicate error {}\",\n+                                obligation.repr(fcx.tcx())).as_slice());\n+                }\n             }\n         }\n-        OutputTypeParameterMismatch(ref expected_trait_ref, ref e) => {\n+        OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n             let expected_trait_ref =\n                 fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n                     &**expected_trait_ref);\n-            let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n-            if !ty::type_is_error(self_ty) {\n+            let actual_trait_ref =\n+                fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+                    &**actual_trait_ref);\n+            if !ty::type_is_error(actual_trait_ref.self_ty()) {\n                 fcx.tcx().sess.span_err(\n                     obligation.cause.span,\n                     format!(\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n                          but the trait `{}` is required ({})\",\n-                        self_ty.user_string(fcx.tcx()),\n+                        expected_trait_ref.self_ty().user_string(fcx.tcx()),\n                         expected_trait_ref.user_string(fcx.tcx()),\n-                        trait_ref.user_string(fcx.tcx()),\n+                        actual_trait_ref.user_string(fcx.tcx()),\n                         ty::type_err_to_str(fcx.tcx(), e)).as_slice());\n                 note_obligation_cause(fcx, obligation);\n             }\n@@ -411,12 +443,25 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        obligation: &Obligation<'tcx>) {\n+                                        obligation: &PredicateObligation<'tcx>) {\n     // Unable to successfully determine, probably means\n     // insufficient type information, but could mean\n     // ambiguous impls. The latter *ought* to be a\n     // coherence violation, so we don't report it here.\n-    let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n+\n+    let trait_ref = match obligation.trait_ref {\n+        ty::Predicate::Trait(ref trait_ref) => {\n+            fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(&**trait_ref)\n+        }\n+        _ => {\n+            fcx.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"ambiguity from something other than a trait: {}\",\n+                        obligation.trait_ref.repr(fcx.tcx())).as_slice());\n+        }\n+    };\n+    let self_ty = trait_ref.self_ty();\n+\n     debug!(\"maybe_report_ambiguity(trait_ref={}, self_ty={}, obligation={})\",\n            trait_ref.repr(fcx.tcx()),\n            self_ty.repr(fcx.tcx()),\n@@ -473,8 +518,8 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n /// Select as many obligations as we can at present.\n-pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt) {\n-\n+pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt)\n+{\n     match\n         fcx.inh.fulfillment_cx\n         .borrow_mut()\n@@ -500,27 +545,23 @@ pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n }\n \n fn note_obligation_cause<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                   obligation: &Obligation<'tcx>) {\n+                                   obligation: &PredicateObligation<'tcx>) {\n     let tcx = fcx.tcx();\n-    let trait_name = ty::item_path_str(tcx, obligation.trait_ref.def_id);\n     match obligation.cause.code {\n         traits::MiscObligation => { }\n         traits::ItemObligation(item_def_id) => {\n             let item_name = ty::item_path_str(tcx, item_def_id);\n             tcx.sess.span_note(\n                 obligation.cause.span,\n                 format!(\n-                    \"the trait `{}` must be implemented because it is required by `{}`\",\n-                    trait_name,\n+                    \"required by `{}`\",\n                     item_name).as_slice());\n         }\n         traits::ObjectCastObligation(object_ty) => {\n             tcx.sess.span_note(\n                 obligation.cause.span,\n                 format!(\n-                    \"the trait `{}` must be implemented for the cast \\\n-                     to the object type `{}`\",\n-                    trait_name,\n+                    \"required for the cast to the object type `{}`\",\n                     fcx.infcx().ty_to_string(object_ty)).as_slice());\n         }\n         traits::RepeatVec => {\n@@ -558,7 +599,9 @@ fn note_obligation_cause<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                        \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n                        to force the compiler to allow this\");\n         }\n-        traits::ClosureCapture(var_id, closure_span) => {\n+        traits::ClosureCapture(var_id, closure_span, builtin_bound) => {\n+            let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n+            let trait_name = ty::item_path_str(tcx, def_id);\n             let name = ty::local_var_name_str(tcx, var_id);\n             span_note!(tcx.sess, closure_span,\n                        \"the closure that captures `{}` requires that all captured variables \\\""}, {"sha": "8c82429e1c226cc4282e06bbb1a5ca001f21a7d2", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -91,7 +91,6 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let polytype = ty::lookup_item_type(ccx.tcx, item_def_id);\n         let param_env =\n             ty::construct_parameter_environment(ccx.tcx,\n-                                                item.span,\n                                                 &polytype.generics,\n                                                 item.id);\n         let inh = Inherited::new(ccx.tcx, param_env);\n@@ -122,14 +121,12 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 // For DST, all intermediate types must be sized.\n                 if variant.fields.len() > 0 {\n                     for field in variant.fields.init().iter() {\n-                        let cause = traits::ObligationCause::new(field.span, traits::FieldSized);\n-                        let obligation = traits::obligation_for_builtin_bound(fcx.tcx(),\n-                                                                              cause,\n-                                                                              field.ty,\n-                                                                              ty::BoundSized);\n-                        if let Ok(obligation) = obligation {\n-                            fcx.register_obligation(obligation);\n-                        }\n+                        fcx.register_builtin_bound(\n+                            field.ty,\n+                            ty::BoundSized,\n+                            traits::ObligationCause::new(field.span,\n+                                                         fcx.body_id,\n+                                                         traits::FieldSized));\n                     }\n                 }\n             }\n@@ -218,33 +215,16 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // the same way as we treat the self-type.\n             bounds_checker.check_trait_ref(&trait_ref);\n \n-            let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_ref.def_id);\n-\n             let cause =\n                 traits::ObligationCause::new(\n                     item.span,\n+                    fcx.body_id,\n                     traits::ItemObligation(trait_ref.def_id));\n \n             // Find the supertrait bounds. This will add `int:Bar`.\n-            //\n-            // FIXME -- This is a bit ill-factored. There is very similar\n-            // code in traits::util::obligations_for_generics.\n-            fcx.add_region_obligations_for_type_parameter(item.span,\n-                                                          &trait_def.bounds,\n-                                                          trait_ref.self_ty());\n-            for builtin_bound in trait_def.bounds.builtin_bounds.iter() {\n-                let obligation = traits::obligation_for_builtin_bound(fcx.tcx(),\n-                                                                      cause,\n-                                                                      trait_ref.self_ty(),\n-                                                                      builtin_bound);\n-                if let Ok(obligation) = obligation {\n-                    fcx.register_obligation(obligation);\n-                }\n-            }\n-            for trait_bound in trait_def.bounds.trait_bounds.iter() {\n-                let trait_bound = trait_bound.subst(fcx.tcx(), &trait_ref.substs);\n-                fcx.register_obligation(\n-                    traits::Obligation::new(cause, trait_bound));\n+            let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &trait_ref);\n+            for predicate in predicates.into_iter() {\n+                fcx.register_predicate(traits::Obligation::new(cause, predicate));\n             }\n         });\n     }\n@@ -291,8 +271,8 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 self.span,\n+                self.fcx.body_id,\n                 traits::ItemObligation(trait_ref.def_id)),\n-            &trait_ref.substs,\n             &bounds);\n \n         for &ty in trait_ref.substs.types.iter() {\n@@ -341,8 +321,8 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                 if self.binding_count == 0 {\n                     self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,\n+                                                     self.fcx.body_id,\n                                                      traits::ItemObligation(type_id)),\n-                        substs,\n                         &polytype.generics.to_bounds(self.tcx(), substs));\n                 } else {\n                     // There are two circumstances in which we ignore\n@@ -367,11 +347,13 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                     //\n                     // (I believe we should do the same for traits, but\n                     // that will require an RFC. -nmatsakis)\n-                    self.fcx.add_trait_obligations_for_generics(\n+                    let bounds = polytype.generics.to_bounds(self.tcx(), substs);\n+                    let bounds = filter_to_trait_obligations(bounds);\n+                    self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,\n+                                                     self.fcx.body_id,\n                                                      traits::ItemObligation(type_id)),\n-                        substs,\n-                        &polytype.generics.to_bounds(self.tcx(), substs));\n+                        &bounds);\n                 }\n \n                 self.fold_substs(substs);\n@@ -458,6 +440,24 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         .collect()\n }\n \n+fn filter_to_trait_obligations<'tcx>(bounds: ty::GenericBounds<'tcx>)\n+                                     -> ty::GenericBounds<'tcx>\n+{\n+    let mut result = ty::GenericBounds::empty();\n+    for (space, _, predicate) in bounds.predicates.iter_enumerated() {\n+        match *predicate {\n+            ty::Predicate::Trait(..) => {\n+                result.predicates.push(space, predicate.clone())\n+            }\n+            ty::Predicate::Equate(..) |\n+            ty::Predicate::TypeOutlives(..) |\n+            ty::Predicate::RegionOutlives(..) => {\n+            }\n+        }\n+    }\n+    result\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Special drop trait checking\n \n@@ -469,14 +469,8 @@ fn check_struct_safe_for_destructor<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     if !struct_tpt.generics.has_type_params(subst::TypeSpace)\n         && !struct_tpt.generics.has_region_params(subst::TypeSpace)\n     {\n-        let cause = traits::ObligationCause::new(span, traits::DropTrait);\n-        let obligation = traits::obligation_for_builtin_bound(fcx.tcx(),\n-                                                              cause,\n-                                                              self_ty,\n-                                                              ty::BoundSend);\n-        if let Ok(obligation) = obligation {\n-            fcx.register_obligation(obligation);\n-        }\n+        let cause = traits::ObligationCause::new(span, fcx.body_id, traits::DropTrait);\n+        fcx.register_builtin_bound(self_ty, ty::BoundSend, cause);\n     } else {\n         span_err!(fcx.tcx().sess, span, E0141,\n                   \"cannot implement a destructor on a structure \\"}, {"sha": "09cf708047601a81d00171378d0087f098a677eb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -1407,14 +1407,15 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .collect();\n \n         // ...and also create generics synthesized from the associated types.\n+        let mut index = 0;\n         let assoc_types: Vec<_> =\n             items.iter()\n             .flat_map(|item| match *item {\n                 ast::TypeTraitItem(ref trait_item) => {\n-                    let index = types.len();\n+                    index += 1;\n                     Some(ty::mk_param(ccx.tcx,\n                                       subst::AssocSpace,\n-                                      index,\n+                                      index - 1,\n                                       local_def(trait_item.ty_param.id))).into_iter()\n                 }\n                 ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {\n@@ -1596,7 +1597,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    substs: &subst::Substs<'tcx>,\n                                    ast_generics: &ast::Generics,\n                                    items: &[ast::TraitItem])\n-                                   -> ty::Generics<'tcx> {\n+                                   -> ty::Generics<'tcx>\n+{\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n@@ -1644,7 +1646,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         bounds: ty::ParamBounds {\n             region_bounds: vec!(),\n             builtin_bounds: ty::empty_builtin_bounds(),\n-            trait_bounds: vec!(self_trait_ref),\n+            trait_bounds: vec!(self_trait_ref.clone()),\n         },\n         associated_with: None,\n         default: None\n@@ -1654,6 +1656,9 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     generics.types.push(subst::SelfSpace, def);\n \n+    generics.predicates.push(subst::SelfSpace,\n+                             ty::Predicate::Trait(self_trait_ref));\n+\n     generics\n }\n \n@@ -1806,6 +1811,10 @@ fn ty_generics<'tcx,AC>(this: &AC,\n         result.types.push(space, (*associated_type_param).clone());\n     }\n \n+    // Just for fun, also push the bounds from the type parameters\n+    // into the predicates list. This is currently kind of non-DRY.\n+    create_predicates(this.tcx(), &mut result, space);\n+\n     return result;\n \n     fn create_type_parameters_for_associated_types<'tcx, AC>(\n@@ -1892,6 +1901,27 @@ fn ty_generics<'tcx,AC>(this: &AC,\n             }\n         }\n     }\n+\n+    fn create_predicates<'tcx>(\n+        tcx: &ty::ctxt<'tcx>,\n+        result: &mut ty::Generics<'tcx>,\n+        space: subst::ParamSpace)\n+    {\n+        for type_param_def in result.types.get_slice(space).iter() {\n+            let param_ty = ty::mk_param_from_def(tcx, type_param_def);\n+            for predicate in ty::predicates(tcx, param_ty, &type_param_def.bounds).into_iter() {\n+                result.predicates.push(space, predicate);\n+            }\n+        }\n+\n+        for region_param_def in result.regions.get_slice(space).iter() {\n+            let region = region_param_def.to_early_bound_region();\n+            for &bound_region in region_param_def.bounds.iter() {\n+                result.predicates.push(space, ty::Predicate::RegionOutlives(region,\n+                                                                            bound_region));\n+            }\n+        }\n+    }\n }\n \n fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n@@ -2145,8 +2175,7 @@ pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let regions =\n         ty_generics.regions.map(\n-            |def| ty::ReEarlyBound(def.def_id.node, def.space,\n-                                   def.index, def.name));\n+            |def| def.to_early_bound_region());\n \n     subst::Substs::new(types, regions)\n }"}, {"sha": "41ed5b8ec365628189cbf43054088a6d16c00274", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -160,8 +160,11 @@ fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n \n fn no_params<'tcx>(t: Ty<'tcx>) -> ty::Polytype<'tcx> {\n     ty::Polytype {\n-        generics: ty::Generics {types: VecPerParamSpace::empty(),\n-                                regions: VecPerParamSpace::empty()},\n+        generics: ty::Generics {\n+            types: VecPerParamSpace::empty(),\n+            regions: VecPerParamSpace::empty(),\n+            predicates: VecPerParamSpace::empty(),\n+        },\n         ty: t\n     }\n }"}, {"sha": "4c7ff60fbdd0f6440def7a3e0a5a39cad659b0af", "filename": "src/test/compile-fail/builtin-superkinds-self-type.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -17,7 +17,6 @@ trait Foo : Sync+'static {\n \n impl <T: Sync> Foo for T { }\n //~^ ERROR the parameter type `T` may not live long enough\n-//~^^ ERROR the parameter type `T` may not live long enough\n \n fn main() {\n     let (tx, rx) = channel();"}, {"sha": "2c689f6909b3913463397e9b276e517ad061fa5d", "filename": "src/test/compile-fail/builtin-superkinds-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -14,6 +14,6 @@\n trait Foo : Send { }\n \n impl <'a> Foo for &'a mut () { }\n-//~^ ERROR does not fulfill the required lifetime\n+//~^ ERROR declared lifetime bound not satisfied\n \n fn main() { }"}, {"sha": "57ee4cf7cc3b03b7695db104745be532c6103293", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -34,6 +34,7 @@ fn g<T>(val: T) {\n fn foo<'a>() {\n     let t: S<&'a int> = S;\n     let a = &t as &Gettable<&'a int>;\n+    //~^ ERROR declared lifetime bound not satisfied\n }\n \n fn foo2<'a>() {"}, {"sha": "35e928d417c3b164ac6feefa3fb9cd5661d6abfa", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -22,7 +22,7 @@ fn test51<'a>() {\n }\n fn test52<'a>() {\n     assert_send::<&'a (Dummy+Send)>();\n-    //~^ ERROR does not fulfill the required lifetime\n+    //~^ ERROR declared lifetime bound not satisfied\n }\n \n // ...unless they are properly bounded"}, {"sha": "11148d2846c16aebe9759b4e9a083cf6c1901a78", "filename": "src/test/compile-fail/kindck-send-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -19,7 +19,7 @@ fn test32() { assert_send::<Vec<int> >(); }\n \n // but not if they own a bad thing\n fn test40<'a>(_: &'a int) {\n-    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<Box<&'a int>>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn main() { }"}, {"sha": "04172932cfe6fcf88a04008c1a137cbbd153478e", "filename": "src/test/compile-fail/kindck-send-region-pointers.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -22,13 +22,13 @@ fn test10() { assert_send::<&'static mut int>(); }\n \n // otherwise lifetime pointers are not ok\n fn test20<'a>(_: &'a int) {\n-    assert_send::<&'a int>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<&'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n fn test21<'a>(_: &'a int) {\n-    assert_send::<&'a str>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<&'a str>(); //~ ERROR declared lifetime bound not satisfied\n }\n fn test22<'a>(_: &'a int) {\n-    assert_send::<&'a [int]>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<&'a [int]>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn main() { }"}, {"sha": "33314149d1fade8cd73284edf230617afb87a32a", "filename": "src/test/compile-fail/kindck-send-unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -15,7 +15,7 @@ fn test70() {\n     assert_send::<*mut int>();\n }\n fn test71<'a>() {\n-    assert_send::<*mut &'a int>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<*mut &'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn main() {"}, {"sha": "80f8a154d58e47170027199a74428947128984bc", "filename": "src/test/compile-fail/opt-out-copy-bad.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fopt-out-copy-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fopt-out-copy-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fopt-out-copy-bad.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(opt_out_copy)]\n+\n+// Test that when using the `opt-out-copy` feature we still consider\n+// destructors to be non-movable\n+\n+struct CantCopyThis;\n+\n+impl Drop for CantCopyThis {\n+    fn drop(&mut self) { }\n+}\n+\n+struct IWantToCopyThis {\n+    but_i_cant: CantCopyThis,\n+}\n+\n+impl Copy for IWantToCopyThis {}\n+//~^ ERROR the trait `Copy` may not be implemented for this type\n+\n+enum CantCopyThisEither {\n+    A,\n+    B(::std::kinds::marker::NoCopy),\n+}\n+\n+enum IWantToCopyThisToo {\n+    ButICant(CantCopyThisEither),\n+}\n+\n+impl Copy for IWantToCopyThisToo {}\n+//~^ ERROR the trait `Copy` may not be implemented for this type\n+\n+fn main() {}\n+"}, {"sha": "1da7f47677a2c89633d07af93d4660089694d0e1", "filename": "src/test/compile-fail/recursion_limit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -44,8 +44,8 @@ fn main() {\n     is_send::<A>();\n     //~^ ERROR overflow evaluating\n     //~^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n-    //~^^^ NOTE must be implemented\n+    //~^^^ NOTE required by `is_send`\n     //~^^^^ ERROR overflow evaluating\n     //~^^^^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n-    //~^^^^^^ NOTE must be implemented\n+    //~^^^^^^ NOTE required by `is_send`\n }"}, {"sha": "b2b2d3337c419c7ec53d184e4d1d6dcf980505f3", "filename": "src/test/compile-fail/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -15,20 +15,20 @@ trait Foo {}\n impl<'a> Foo for &'a [u8] {}\n \n fn a(v: &[u8]) -> Box<Foo + 'static> {\n-    let x: Box<Foo + 'static> = box v; //~ ERROR does not outlive\n+    let x: Box<Foo + 'static> = box v; //~ ERROR declared lifetime bound not satisfied\n     x\n }\n \n fn b(v: &[u8]) -> Box<Foo + 'static> {\n-    box v //~ ERROR does not outlive\n+    box v //~ ERROR declared lifetime bound not satisfied\n }\n \n fn c(v: &[u8]) -> Box<Foo> {\n     box v // OK thanks to lifetime elision\n }\n \n fn d<'a,'b>(v: &'a [u8]) -> Box<Foo+'b> {\n-    box v //~ ERROR does not outlive\n+    box v //~ ERROR declared lifetime bound not satisfied\n }\n \n fn e<'a:'b,'b>(v: &'a [u8]) -> Box<Foo+'b> {"}, {"sha": "ec679a7dda170991168c02b259ce2d419e20bc44", "filename": "src/test/compile-fail/regions-bounded-by-send.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -29,15 +29,15 @@ fn static_lifime_ok<'a,T,U:Send>(_: &'a int) {\n // otherwise lifetime pointers are not ok\n \n fn param_not_ok<'a>(x: &'a int) {\n-    assert_send::<&'a int>(); //~ ERROR does not fulfill\n+    assert_send::<&'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn param_not_ok1<'a>(_: &'a int) {\n-    assert_send::<&'a str>(); //~ ERROR does not fulfill\n+    assert_send::<&'a str>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn param_not_ok2<'a>(_: &'a int) {\n-    assert_send::<&'a [int]>(); //~ ERROR does not fulfill\n+    assert_send::<&'a [int]>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n // boxes are ok\n@@ -51,7 +51,7 @@ fn box_ok() {\n // but not if they own a bad thing\n \n fn box_with_region_not_ok<'a>() {\n-    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill\n+    assert_send::<Box<&'a int>>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n // objects with insufficient bounds no ok\n@@ -63,7 +63,7 @@ fn object_with_random_bound_not_ok<'a>() {\n \n fn object_with_send_bound_not_ok<'a>() {\n     assert_send::<&'a (Dummy+Send)>();\n-    //~^ ERROR does not fulfill\n+    //~^ ERROR declared lifetime bound not satisfied\n }\n \n fn proc_with_lifetime_not_ok<'a>() {\n@@ -84,11 +84,11 @@ fn unsafe_ok1<'a>(_: &'a int) {\n }\n \n fn unsafe_ok2<'a>(_: &'a int) {\n-    assert_send::<*const &'a int>(); //~ ERROR does not fulfill\n+    assert_send::<*const &'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn unsafe_ok3<'a>(_: &'a int) {\n-    assert_send::<*mut &'a int>(); //~ ERROR does not fulfill\n+    assert_send::<*mut &'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn main() {"}, {"sha": "e3939a4e39046bfca361f38fec42154409ffb7a6", "filename": "src/test/compile-fail/regions-bounded-by-trait-requiring-static.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -29,15 +29,15 @@ fn static_lifime_ok<'a,T,U:Send>(_: &'a int) {\n // otherwise lifetime pointers are not ok\n \n fn param_not_ok<'a>(x: &'a int) {\n-    assert_send::<&'a int>(); //~ ERROR does not fulfill\n+    assert_send::<&'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn param_not_ok1<'a>(_: &'a int) {\n-    assert_send::<&'a str>(); //~ ERROR does not fulfill\n+    assert_send::<&'a str>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn param_not_ok2<'a>(_: &'a int) {\n-    assert_send::<&'a [int]>(); //~ ERROR does not fulfill\n+    assert_send::<&'a [int]>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n // boxes are ok\n@@ -51,7 +51,7 @@ fn box_ok() {\n // but not if they own a bad thing\n \n fn box_with_region_not_ok<'a>() {\n-    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill\n+    assert_send::<Box<&'a int>>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n // unsafe pointers are ok unless they point at unsendable things\n@@ -62,11 +62,11 @@ fn unsafe_ok1<'a>(_: &'a int) {\n }\n \n fn unsafe_ok2<'a>(_: &'a int) {\n-    assert_send::<*const &'a int>(); //~ ERROR does not fulfill\n+    assert_send::<*const &'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn unsafe_ok3<'a>(_: &'a int) {\n-    assert_send::<*mut &'a int>(); //~ ERROR does not fulfill\n+    assert_send::<*mut &'a int>(); //~ ERROR declared lifetime bound not satisfied\n }\n \n fn main() {"}, {"sha": "10484925980a79da53098566d5cd46c3de95026e", "filename": "src/test/compile-fail/regions-bounded-method-type-parameters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -20,7 +20,7 @@ impl Foo {\n \n fn caller<'a>(x: &int) {\n     Foo.some_method::<&'a int>();\n-    //~^ ERROR does not fulfill the required lifetime\n+    //~^ ERROR declared lifetime bound not satisfied\n }\n \n fn main() { }"}, {"sha": "4c95e1eac6d58ddeec9fc0b9a60a5aa608601dad", "filename": "src/test/compile-fail/regions-proc-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fregions-proc-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04/src%2Ftest%2Fcompile-fail%2Fregions-proc-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bounds.rs?ref=2d90b91b5d2d18cd433a9e6f1944b685f8b4bb04", "patch": "@@ -12,7 +12,7 @@ fn is_static<T: 'static>() {}\n \n fn foo<'a>() {\n     is_static::<proc():'a>();\n-    //~^ ERROR does not fulfill the required lifetime\n+    //~^ ERROR declared lifetime bound not satisfied\n \n     is_static::<proc():'static>();\n }"}]}