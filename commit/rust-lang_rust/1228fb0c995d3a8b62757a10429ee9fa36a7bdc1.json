{"sha": "1228fb0c995d3a8b62757a10429ee9fa36a7bdc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMjhmYjBjOTk1ZDNhOGI2Mjc1N2ExMDQyOWVlOWZhMzZhN2JkYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-19T19:36:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-19T19:36:48Z"}, "message": "auto merge of #11904 : nick29581/rust/0filemap, r=alexcrichton", "tree": {"sha": "4eedc4e600d4b115eb92d519af48ec4d14666bc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eedc4e600d4b115eb92d519af48ec4d14666bc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1228fb0c995d3a8b62757a10429ee9fa36a7bdc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1228fb0c995d3a8b62757a10429ee9fa36a7bdc1", "html_url": "https://github.com/rust-lang/rust/commit/1228fb0c995d3a8b62757a10429ee9fa36a7bdc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1228fb0c995d3a8b62757a10429ee9fa36a7bdc1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "209b47f248ba98fce70210dede3f99cf0313d357", "url": "https://api.github.com/repos/rust-lang/rust/commits/209b47f248ba98fce70210dede3f99cf0313d357", "html_url": "https://github.com/rust-lang/rust/commit/209b47f248ba98fce70210dede3f99cf0313d357"}, {"sha": "418eea115454f1a617440e9e35f9c63520962bc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/418eea115454f1a617440e9e35f9c63520962bc3", "html_url": "https://github.com/rust-lang/rust/commit/418eea115454f1a617440e9e35f9c63520962bc3"}], "stats": {"total": 86, "additions": 78, "deletions": 8}, "files": [{"sha": "486a25fa775c9ee40ff5971c17ee11c3fa29562e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 78, "deletions": 8, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1228fb0c995d3a8b62757a10429ee9fa36a7bdc1/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1228fb0c995d3a8b62757a10429ee9fa36a7bdc1/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=1228fb0c995d3a8b62757a10429ee9fa36a7bdc1", "patch": "@@ -380,6 +380,20 @@ impl CodeMap {\n                 a = m;\n             }\n         }\n+        // There can be filemaps with length 0. These have the same start_pos as the previous\n+        // filemap, but are not the filemaps we want (because they are length 0, they cannot\n+        // contain what we are looking for). So, rewind until we find a useful filemap.\n+        loop {\n+            let lines = files[a].lines.borrow();\n+            let lines = lines.get();\n+            if lines.len() > 0 {\n+                break;\n+            }\n+            if a == 0 {\n+                fail!(\"position {} does not resolve to a source location\", pos.to_uint());\n+            }\n+            a -= 1;\n+        }\n         if a >= len {\n             fail!(\"position {} does not resolve to a source location\", pos.to_uint())\n         }\n@@ -406,10 +420,10 @@ impl CodeMap {\n     fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n-        let chpos = self.bytepos_to_local_charpos(pos);\n-        let mut lines = f.lines.borrow_mut();\n+        let chpos = self.bytepos_to_charpos(pos);\n+        let lines = f.lines.borrow();\n         let linebpos = lines.get()[a];\n-        let linechpos = self.bytepos_to_local_charpos(linebpos);\n+        let linechpos = self.bytepos_to_charpos(linebpos);\n         debug!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n         debug!(\"codemap: char pos {:?} is on the line at char pos {:?}\",\n@@ -432,9 +446,8 @@ impl CodeMap {\n         return FileMapAndBytePos {fm: fm, pos: offset};\n     }\n \n-    // Converts an absolute BytePos to a CharPos relative to the file it is\n-    // located in\n-    fn bytepos_to_local_charpos(&self, bpos: BytePos) -> CharPos {\n+    // Converts an absolute BytePos to a CharPos relative to the codemap.\n+    fn bytepos_to_charpos(&self, bpos: BytePos) -> CharPos {\n         debug!(\"codemap: converting {:?} to char pos\", bpos);\n         let idx = self.lookup_filemap_idx(bpos);\n         let files = self.files.borrow();\n@@ -450,8 +463,8 @@ impl CodeMap {\n                 total_extra_bytes += mbc.bytes;\n                 // We should never see a byte position in the middle of a\n                 // character\n-                assert!(bpos == mbc.pos\n-                    || bpos.to_uint() >= mbc.pos.to_uint() + mbc.bytes);\n+                assert!(bpos == mbc.pos ||\n+                        bpos.to_uint() >= mbc.pos.to_uint() + mbc.bytes);\n             } else {\n                 break;\n             }\n@@ -486,4 +499,61 @@ mod test {\n         fm.next_line(BytePos(10));\n         fm.next_line(BytePos(2));\n     }\n+\n+    fn init_code_map() ->CodeMap {\n+        let cm = CodeMap::new();\n+        let fm1 = cm.new_filemap(~\"blork.rs\",~\"first line.\\nsecond line\");\n+        let fm2 = cm.new_filemap(~\"empty.rs\",~\"\");\n+        let fm3 = cm.new_filemap(~\"blork2.rs\",~\"first line.\\nsecond line\");\n+\n+        fm1.next_line(BytePos(0));\n+        fm1.next_line(BytePos(12));\n+        fm2.next_line(BytePos(23));\n+        fm3.next_line(BytePos(23));\n+        fm3.next_line(BytePos(33));\n+\n+        cm\n+    }\n+\n+    #[test]\n+    fn t3() {\n+        // Test lookup_byte_offset\n+        let cm = init_code_map();\n+\n+        let fmabp1 = cm.lookup_byte_offset(BytePos(22));\n+        assert_eq!(fmabp1.fm.name, ~\"blork.rs\");\n+        assert_eq!(fmabp1.pos, BytePos(22));\n+\n+        let fmabp2 = cm.lookup_byte_offset(BytePos(23));\n+        assert_eq!(fmabp2.fm.name, ~\"blork2.rs\");\n+        assert_eq!(fmabp2.pos, BytePos(0));\n+    }\n+\n+    #[test]\n+    fn t4() {\n+        // Test bytepos_to_charpos\n+        let cm = init_code_map();\n+\n+        let cp1 = cm.bytepos_to_charpos(BytePos(22));\n+        assert_eq!(cp1, CharPos(22));\n+\n+        let cp2 = cm.bytepos_to_charpos(BytePos(23));\n+        assert_eq!(cp2, CharPos(23));\n+    }\n+\n+    #[test]\n+    fn t5() {\n+        // Test zero-length filemaps.\n+        let cm = init_code_map();\n+\n+        let loc1 = cm.lookup_char_pos(BytePos(22));\n+        assert_eq!(loc1.file.name, ~\"blork.rs\");\n+        assert_eq!(loc1.line, 2);\n+        assert_eq!(loc1.col, CharPos(10));\n+\n+        let loc2 = cm.lookup_char_pos(BytePos(23));\n+        assert_eq!(loc2.file.name, ~\"blork2.rs\");\n+        assert_eq!(loc2.line, 1);\n+        assert_eq!(loc2.col, CharPos(0));\n+    }\n }"}]}