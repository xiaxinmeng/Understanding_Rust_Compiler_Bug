{"sha": "22eec92882e4b62a82f96be03d0c42a50d848bc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZWVjOTI4ODJlNGI2MmE4MmY5NmJlMDNkMGM0MmE1MGQ4NDhiYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-19T22:01:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-19T22:01:30Z"}, "message": "Auto merge of #65094 - oxalica:linux-statx, r=alexcrichton\n\nPrefer statx on linux if available\n\nThis PR make `metadata`-related functions try to invoke `statx` first on Linux if available,\nmaking `std::fs::Metadata::created` work on Linux with `statx` supported.\n\nIt follows the discussion in #61386 , and will fix #59743\n\nThe implementation of this PR is simply converting `struct statx` into `struct stat64` with\nextra fields for `btime` if `statx` succeeds, since other fields are not currently used.\n\n---\n\nI also did a separated benchmark for `fs::metadata`, `stat64`, `statx`, and `statx` with conversion to `stat64`.\nIt shows that `statx` with conversion is even more faster than pure `statx`.\nI think it's due to `sizeof stat64 == 114` but `sizeof statx == 256`.\n\nAnyway, the bare implementation of `statx` with conversion is only about 0.2% slower than the original impl (`stat64`-family).\nWith heap-allocation counted (~8.5% of total cost), the difference between `stat` and `statx` (with or without conversion) is just nothing.\n\nTherefore, I think it is not urgent to use bare `struct statx` as underlying representation now.\nThere is no need to break `std::os::linux::fs::MetadataExt::as_raw_stat` (https://github.com/rust-lang/rust/pull/61386#issuecomment-538074018)\n\n[Separated bare benchmarks](https://gist.github.com/oxalica/c4073ecb202c599fe41b7f15f86dc79c):\n```\nmetadata_ok             time:   [529.41 ns 529.77 ns 530.19 ns]\nmetadata_err            time:   [538.71 ns 539.39 ns 540.35 ns]\nstat64_ok               time:   [484.32 ns 484.53 ns 484.75 ns]\nstat64_err              time:   [481.77 ns 482.00 ns 482.24 ns]\nstatx_ok                time:   [488.07 ns 488.35 ns 488.62 ns]\nstatx_err               time:   [487.74 ns 488.00 ns 488.27 ns]\nstatx_cvt_ok            time:   [485.05 ns 485.28 ns 485.53 ns]\nstatx_cvt_err           time:   [485.23 ns 485.45 ns 485.67 ns]\n```\n\nr? @alexcrichton", "tree": {"sha": "9588c3567336560d4978d2d28aaa0be7ad418f9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9588c3567336560d4978d2d28aaa0be7ad418f9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22eec92882e4b62a82f96be03d0c42a50d848bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22eec92882e4b62a82f96be03d0c42a50d848bc9", "html_url": "https://github.com/rust-lang/rust/commit/22eec92882e4b62a82f96be03d0c42a50d848bc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22eec92882e4b62a82f96be03d0c42a50d848bc9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c23a7aa778b0dfeffbf83b099bdf971242c1e1ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/c23a7aa778b0dfeffbf83b099bdf971242c1e1ac", "html_url": "https://github.com/rust-lang/rust/commit/c23a7aa778b0dfeffbf83b099bdf971242c1e1ac"}, {"sha": "2ee45c9da28c4de155f29d402eff1d22977cbdc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ee45c9da28c4de155f29d402eff1d22977cbdc7", "html_url": "https://github.com/rust-lang/rust/commit/2ee45c9da28c4de155f29d402eff1d22977cbdc7"}], "stats": {"total": 249, "additions": 235, "deletions": 14}, "files": [{"sha": "6595f54162f0a8a1ceeca203cf93ba5205937622", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/22eec92882e4b62a82f96be03d0c42a50d848bc9/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eec92882e4b62a82f96be03d0c42a50d848bc9/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=22eec92882e4b62a82f96be03d0c42a50d848bc9", "patch": "@@ -1090,13 +1090,14 @@ impl Metadata {\n \n     /// Returns the creation time listed in this metadata.\n     ///\n-    /// The returned value corresponds to the `birthtime` field of `stat` on\n-    /// Unix platforms and the `ftCreationTime` field on Windows platforms.\n+    /// The returned value corresponds to the `btime` field of `statx` on\n+    /// Linux kernel starting from to 4.11, the `birthtime` field of `stat` on other\n+    /// Unix platforms, and the `ftCreationTime` field on Windows platforms.\n     ///\n     /// # Errors\n     ///\n     /// This field may not be available on all platforms, and will return an\n-    /// `Err` on platforms where it is not available.\n+    /// `Err` on platforms or filesystems where it is not available.\n     ///\n     /// # Examples\n     ///\n@@ -1109,7 +1110,7 @@ impl Metadata {\n     ///     if let Ok(time) = metadata.created() {\n     ///         println!(\"{:?}\", time);\n     ///     } else {\n-    ///         println!(\"Not supported on this platform\");\n+    ///         println!(\"Not supported on this platform or filesystem\");\n     ///     }\n     ///     Ok(())\n     /// }\n@@ -3443,5 +3444,18 @@ mod tests {\n             check!(a.created());\n             check!(b.created());\n         }\n+\n+        if cfg!(target_os = \"linux\") {\n+            // Not always available\n+            match (a.created(), b.created()) {\n+                (Ok(t1), Ok(t2)) => assert!(t1 <= t2),\n+                (Err(e1), Err(e2)) if e1.kind() == ErrorKind::Other &&\n+                                      e2.kind() == ErrorKind::Other => {}\n+                (a, b) => panic!(\n+                    \"creation time must be always supported or not supported: {:?} {:?}\",\n+                    a, b,\n+                ),\n+            }\n+        }\n     }\n }"}, {"sha": "13dd9f5f34f13c936d4b832c591d5dfab115d179", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 217, "deletions": 10, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/22eec92882e4b62a82f96be03d0c42a50d848bc9/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eec92882e4b62a82f96be03d0c42a50d848bc9/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=22eec92882e4b62a82f96be03d0c42a50d848bc9", "patch": "@@ -41,11 +41,138 @@ pub use crate::sys_common::fs::remove_dir_all;\n \n pub struct File(FileDesc);\n \n-#[derive(Clone)]\n-pub struct FileAttr {\n-    stat: stat64,\n+// FIXME: This should be available on Linux with all `target_arch` and `target_env`.\n+// https://github.com/rust-lang/libc/issues/1545\n+macro_rules! cfg_has_statx {\n+    ({ $($then_tt:tt)* } else { $($else_tt:tt)* }) => {\n+        cfg_if::cfg_if! {\n+            if #[cfg(all(target_os = \"linux\", target_env = \"gnu\", any(\n+                target_arch = \"x86\",\n+                target_arch = \"arm\",\n+                // target_arch = \"mips\",\n+                target_arch = \"powerpc\",\n+                target_arch = \"x86_64\",\n+                // target_arch = \"aarch64\",\n+                target_arch = \"powerpc64\",\n+                // target_arch = \"mips64\",\n+                // target_arch = \"s390x\",\n+                target_arch = \"sparc64\",\n+            )))] {\n+                $($then_tt)*\n+            } else {\n+                $($else_tt)*\n+            }\n+        }\n+    };\n+    ($($block_inner:tt)*) => {\n+        #[cfg(all(target_os = \"linux\", target_env = \"gnu\", any(\n+            target_arch = \"x86\",\n+            target_arch = \"arm\",\n+            // target_arch = \"mips\",\n+            target_arch = \"powerpc\",\n+            target_arch = \"x86_64\",\n+            // target_arch = \"aarch64\",\n+            target_arch = \"powerpc64\",\n+            // target_arch = \"mips64\",\n+            // target_arch = \"s390x\",\n+            target_arch = \"sparc64\",\n+        )))]\n+        {\n+            $($block_inner)*\n+        }\n+    };\n }\n \n+cfg_has_statx! {{\n+    #[derive(Clone)]\n+    pub struct FileAttr {\n+        stat: stat64,\n+        statx_extra_fields: Option<StatxExtraFields>,\n+    }\n+\n+    #[derive(Clone)]\n+    struct StatxExtraFields {\n+        // This is needed to check if btime is supported by the filesystem.\n+        stx_mask: u32,\n+        stx_btime: libc::statx_timestamp,\n+    }\n+\n+    // We prefer `statx` on Linux if available, which contains file creation time.\n+    // Default `stat64` contains no creation time.\n+    unsafe fn try_statx(\n+        fd: c_int,\n+        path: *const libc::c_char,\n+        flags: i32,\n+        mask: u32,\n+    ) -> Option<io::Result<FileAttr>> {\n+        use crate::sync::atomic::{AtomicBool, Ordering};\n+\n+        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n+        // We store the availability in a global to avoid unnecessary syscalls\n+        static HAS_STATX: AtomicBool = AtomicBool::new(true);\n+        syscall! {\n+            fn statx(\n+                fd: c_int,\n+                pathname: *const libc::c_char,\n+                flags: c_int,\n+                mask: libc::c_uint,\n+                statxbuf: *mut libc::statx\n+            ) -> c_int\n+        }\n+\n+        if !HAS_STATX.load(Ordering::Relaxed) {\n+            return None;\n+        }\n+\n+        let mut buf: libc::statx = mem::zeroed();\n+        let ret = cvt(statx(fd, path, flags, mask, &mut buf));\n+        match ret {\n+            Err(err) => match err.raw_os_error() {\n+                Some(libc::ENOSYS) => {\n+                    HAS_STATX.store(false, Ordering::Relaxed);\n+                    return None;\n+                }\n+                _ => return Some(Err(err)),\n+            }\n+            Ok(_) => {\n+                // We cannot fill `stat64` exhaustively because of private padding fields.\n+                let mut stat: stat64 = mem::zeroed();\n+                // `c_ulong` on gnu-mips, `dev_t` otherwise\n+                stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor) as _;\n+                stat.st_ino = buf.stx_ino as libc::ino64_t;\n+                stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n+                stat.st_mode = buf.stx_mode as libc::mode_t;\n+                stat.st_uid = buf.stx_uid as libc::uid_t;\n+                stat.st_gid = buf.stx_gid as libc::gid_t;\n+                stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor) as _;\n+                stat.st_size = buf.stx_size as off64_t;\n+                stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n+                stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n+                stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n+                // `i64` on gnu-x86_64-x32, `c_ulong` otherwise.\n+                stat.st_atime_nsec = buf.stx_atime.tv_nsec as _;\n+                stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n+                stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as _;\n+                stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n+                stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as _;\n+\n+                let extra = StatxExtraFields {\n+                    stx_mask: buf.stx_mask,\n+                    stx_btime: buf.stx_btime,\n+                };\n+\n+                Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n+            }\n+        }\n+    }\n+\n+} else {\n+    #[derive(Clone)]\n+    pub struct FileAttr {\n+        stat: stat64,\n+    }\n+}}\n+\n // all DirEntry's will have a reference to this struct\n struct InnerReadDir {\n     dirp: Dir,\n@@ -97,6 +224,20 @@ pub struct FileType { mode: mode_t }\n #[derive(Debug)]\n pub struct DirBuilder { mode: mode_t }\n \n+cfg_has_statx! {{\n+    impl FileAttr {\n+        fn from_stat64(stat: stat64) -> Self {\n+            Self { stat, statx_extra_fields: None }\n+        }\n+    }\n+} else {\n+    impl FileAttr {\n+        fn from_stat64(stat: stat64) -> Self {\n+            Self { stat }\n+        }\n+    }\n+}}\n+\n impl FileAttr {\n     pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n     pub fn perm(&self) -> FilePermissions {\n@@ -164,6 +305,22 @@ impl FileAttr {\n                   target_os = \"macos\",\n                   target_os = \"ios\")))]\n     pub fn created(&self) -> io::Result<SystemTime> {\n+        cfg_has_statx! {\n+            if let Some(ext) = &self.statx_extra_fields {\n+                return if (ext.stx_mask & libc::STATX_BTIME) != 0 {\n+                    Ok(SystemTime::from(libc::timespec {\n+                        tv_sec: ext.stx_btime.tv_sec as libc::time_t,\n+                        tv_nsec: ext.stx_btime.tv_nsec as _,\n+                    }))\n+                } else {\n+                    Err(io::Error::new(\n+                        io::ErrorKind::Other,\n+                        \"creation time is not available for the filesystem\",\n+                    ))\n+                };\n+            }\n+        }\n+\n         Err(io::Error::new(io::ErrorKind::Other,\n                            \"creation time is not available on this platform \\\n                             currently\"))\n@@ -306,12 +463,25 @@ impl DirEntry {\n \n     #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\n     pub fn metadata(&self) -> io::Result<FileAttr> {\n-        let fd = cvt(unsafe {dirfd(self.dir.inner.dirp.0)})?;\n+        let fd = cvt(unsafe { dirfd(self.dir.inner.dirp.0) })?;\n+        let name = self.entry.d_name.as_ptr();\n+\n+        cfg_has_statx! {\n+            if let Some(ret) = unsafe { try_statx(\n+                fd,\n+                name,\n+                libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,\n+                libc::STATX_ALL,\n+            ) } {\n+                return ret;\n+            }\n+        }\n+\n         let mut stat: stat64 = unsafe { mem::zeroed() };\n         cvt(unsafe {\n-            fstatat64(fd, self.entry.d_name.as_ptr(), &mut stat, libc::AT_SYMLINK_NOFOLLOW)\n+            fstatat64(fd, name, &mut stat, libc::AT_SYMLINK_NOFOLLOW)\n         })?;\n-        Ok(FileAttr { stat })\n+        Ok(FileAttr::from_stat64(stat))\n     }\n \n     #[cfg(not(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\")))]\n@@ -517,11 +687,24 @@ impl File {\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        let fd = self.0.raw();\n+\n+        cfg_has_statx! {\n+            if let Some(ret) = unsafe { try_statx(\n+                fd,\n+                b\"\\0\" as *const _ as *const libc::c_char,\n+                libc::AT_EMPTY_PATH | libc::AT_STATX_SYNC_AS_STAT,\n+                libc::STATX_ALL,\n+            ) } {\n+                return ret;\n+            }\n+        }\n+\n         let mut stat: stat64 = unsafe { mem::zeroed() };\n         cvt(unsafe {\n-            fstat64(self.0.raw(), &mut stat)\n+            fstat64(fd, &mut stat)\n         })?;\n-        Ok(FileAttr { stat })\n+        Ok(FileAttr::from_stat64(stat))\n     }\n \n     pub fn fsync(&self) -> io::Result<()> {\n@@ -798,20 +981,44 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n     let p = cstr(p)?;\n+\n+    cfg_has_statx! {\n+        if let Some(ret) = unsafe { try_statx(\n+            libc::AT_FDCWD,\n+            p.as_ptr(),\n+            libc::AT_STATX_SYNC_AS_STAT,\n+            libc::STATX_ALL,\n+        ) } {\n+            return ret;\n+        }\n+    }\n+\n     let mut stat: stat64 = unsafe { mem::zeroed() };\n     cvt(unsafe {\n         stat64(p.as_ptr(), &mut stat)\n     })?;\n-    Ok(FileAttr { stat })\n+    Ok(FileAttr::from_stat64(stat))\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n     let p = cstr(p)?;\n+\n+    cfg_has_statx! {\n+        if let Some(ret) = unsafe { try_statx(\n+            libc::AT_FDCWD,\n+            p.as_ptr(),\n+            libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,\n+            libc::STATX_ALL,\n+        ) } {\n+            return ret;\n+        }\n+    }\n+\n     let mut stat: stat64 = unsafe { mem::zeroed() };\n     cvt(unsafe {\n         lstat64(p.as_ptr(), &mut stat)\n     })?;\n-    Ok(FileAttr { stat })\n+    Ok(FileAttr::from_stat64(stat))\n }\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {"}]}