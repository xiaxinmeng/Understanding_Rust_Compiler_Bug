{"sha": "d5616e1f18abb46071581d096994a0ff6581e3f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NjE2ZTFmMThhYmI0NjA3MTU4MWQwOTY5OTRhMGZmNjU4MWUzZjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-22T00:01:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-22T00:01:29Z"}, "message": "Auto merge of #49896 - SimonSapin:inherent, r=alexcrichton\n\nAdd inherent methods in libcore for [T], [u8], str, f32, and f64\n\n# Background\n\nPrimitive types are defined by the language, they don\u2019t have a type definition like `pub struct Foo { \u2026 }` in any crate. So they don\u2019t \u201cbelong\u201d to any crate as far as `impl` coherence is concerned, and on principle no crate would be able to define inherent methods for them, without a trait. Since we want these types to have inherent methods anyway, the standard library (with cooperation from the compiler) bends this rule with code like [`#[lang = \"u8\"] impl u8 { /*\u2026*/ }`](https://github.com/rust-lang/rust/blob/1.25.0/src/libcore/num/mod.rs#L2244-L2245). The `#[lang]` attribute is permanently-unstable and never intended to be used outside of the standard library.\n\nEach lang item can only be defined once. Before this PR there is one impl-coherence-rule-bending lang item per primitive type (plus one for `[u8]`, which overlaps with `[T]`). And so one `impl` block each. These blocks for `str`, `[T]` and `[u8]` are in liballoc rather than libcore because *some* of the methods (like `<[T]>::to_vec(&self) -> Vec<T> where T:\u00a0Clone`) need a global memory allocator which we don\u2019t want to make a requirement in libcore. Similarly, `impl f32` and `impl f64` are in libstd because some of the methods are based on FFI calls to C\u2019s `libm` and we want, as much as possible, libcore not to require \u201cruntime support\u201d.\n\nIn libcore, the methods of `str` and `[T]` that don\u2019t allocate are made available through two **unstable traits** `StrExt` and `SliceExt` (so the traits can\u2019t be *named* by programs on the Stable release channel) that have **stable methods** and are re-exported in the libcore prelude (so that programs on Stable can *call* these methods anyway). Non-allocating `[u8]` methods are not available in libcore: https://github.com/rust-lang/rust/issues/45803. Some `f32` and `f64` methods are in an unstable `core::num::Float` trait with stable methods, but that one is **not in the libcore prelude**. (So as far as Stable programs are concerns it doesn\u2019t exist, and I don\u2019t know what the point was to mark these methods `#[stable]`.)\n\nhttps://github.com/rust-lang/rust/issues/32110 is the tracking issue for these unstable traits.\n\n# High-level proposal\n\nSince the standard library is already bending the rules, why not bend them *a little more*? By defining a few additional lang items, the compiler can allow the standard library to have *two* `impl` blocks (in different crates) for some primitive types.\n\nThe `StrExt` and `SliceExt` traits still exist for now so that we can bootstrap from a previous-version compiler that doesn\u2019t have these lang items yet, but they can be removed in next release cycle. (`Float` is used internally and needs to be public for libcore unit tests, but was already `#[doc(hidden)]`.) I don\u2019t know if https://github.com/rust-lang/rust/issues/32110 should be closed by this PR, or only when the traits are entirely removed after we make a new bootstrap compiler.\n\n# Float methods\n\nAmong the methods of the `core::num::Float` trait, three are based on LLVM intrinsics: `abs`, `signum`, and `powi`. PR https://github.com/rust-lang/rust/pull/27823 \u201cRemove dependencies on libm functions from libcore\u201d moved a bunch of `core::num::Float` methods back to libstd, but left these three behind. However they aren\u2019t specifically discussed in the PR thread. The `compiler_builtins` crate defines `__powisf2` and `__powidf2` functions that look like implementations of `powi`, but I couldn\u2019t find a connection with the `llvm.powi.f32` and `llvm.powi.f32` intrinsics by grepping through LLVM\u2019s code.\n\nIn discussion starting at https://github.com/rust-lang/rust/issues/32110#issuecomment-370647922 Alex says that we do not want methods in libcore that require \u201cruntime support\u201d, but it\u2019s not clear whether that applies to these `abs`, `signum`, or `powi`. In doubt, I\u2019ve **removed** them for the trait and moved them to inherent methods in libstd for now. We can move them back later (or in this PR) if we decide that\u2019s appropriate.\n\n# Change details\n\nFor users on the Stable release channel:\n\n* I believe this PR does not make any breaking change\n* Some methods for `[u8]`, `f32`, and `f64` are newly available to `#![no_std]` users (fixes https://github.com/rust-lang/rust/issues/45803)\n* There should be no visible change for `std` users in terms of what programs compile or what their behavior is. (Only in compiler error messages, possibly.)\n\nFor Nightly users, additionally:\n\n* The unstable `StrExt` and `SliceExt` traits are gone\n* Their methods are now inherent methods of `str` and `[T]` (so only code that explicitly named the traits should be affected, not \"normal\" method calls)\n* The `abs`, `signum` and `powi` methods of the `Float` trait are gone\n* The `Float` trait\u2019s unstable feature name changed to `float_internals` with no associated tracking issue, to reflect it being a permanently unstable implementation detail rather than a public API on a path to stabilization.\n* Its remaining methods are now inherent methods of `f32` and `f64`.\n\n-----\n\nCC @rust-lang/libs for the API changes, @rust-lang/compiler for the new lang items", "tree": {"sha": "addedaf5480f673bd54b0b0ff553b89ca5f1a572", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/addedaf5480f673bd54b0b0ff553b89ca5f1a572"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5616e1f18abb46071581d096994a0ff6581e3f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5616e1f18abb46071581d096994a0ff6581e3f9", "html_url": "https://github.com/rust-lang/rust/commit/d5616e1f18abb46071581d096994a0ff6581e3f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5616e1f18abb46071581d096994a0ff6581e3f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa7ce896f2c41550f7f6cf3dadb21bacc69cc912", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa7ce896f2c41550f7f6cf3dadb21bacc69cc912", "html_url": "https://github.com/rust-lang/rust/commit/aa7ce896f2c41550f7f6cf3dadb21bacc69cc912"}, {"sha": "70fdd1b5c0f6a0673fcf924b3d8880af034bdee0", "url": "https://api.github.com/repos/rust-lang/rust/commits/70fdd1b5c0f6a0673fcf924b3d8880af034bdee0", "html_url": "https://github.com/rust-lang/rust/commit/70fdd1b5c0f6a0673fcf924b3d8880af034bdee0"}], "stats": {"total": 8088, "additions": 4091, "deletions": 3997}, "files": [{"sha": "6399be98cd5197f9d3d2eae08d30ae746c35c9ce", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -75,7 +75,7 @@\n #![deny(missing_debug_implementations)]\n \n #![cfg_attr(test, allow(deprecated))] // rand\n-#![cfg_attr(not(test), feature(core_float))]\n+#![cfg_attr(all(not(test), stage0), feature(float_internals))]\n #![cfg_attr(not(test), feature(exact_size_is_empty))]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(rand, test))]\n@@ -90,6 +90,8 @@\n #![feature(collections_range)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n+#![cfg_attr(stage0, feature(core_slice_ext))]\n+#![cfg_attr(stage0, feature(core_str_ext))]\n #![feature(custom_attribute)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]"}, {"sha": "4594263c01f23ec38ea72983213392662e303deb", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 9, "deletions": 1445, "changes": 1454, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -101,7 +101,7 @@ use core::cmp::Ordering::{self, Less};\n use core::mem::size_of;\n use core::mem;\n use core::ptr;\n-use core::slice as core_slice;\n+#[cfg(stage0)] use core::slice::SliceExt;\n use core::{u8, u16, u32};\n \n use borrow::{Borrow, BorrowMut, ToOwned};\n@@ -171,1059 +171,12 @@ mod hack {\n     }\n }\n \n-#[lang = \"slice\"]\n+#[cfg_attr(stage0, lang = \"slice\")]\n+#[cfg_attr(not(stage0), lang = \"slice_alloc\")]\n #[cfg(not(test))]\n impl<T> [T] {\n-    /// Returns the number of elements in the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    /// assert_eq!(a.len(), 3);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn len(&self) -> usize {\n-        core_slice::SliceExt::len(self)\n-    }\n-\n-    /// Returns `true` if the slice has a length of 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_empty(&self) -> bool {\n-        core_slice::SliceExt::is_empty(self)\n-    }\n-\n-    /// Returns the first element of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(Some(&10), v.first());\n-    ///\n-    /// let w: &[i32] = &[];\n-    /// assert_eq!(None, w.first());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn first(&self) -> Option<&T> {\n-        core_slice::SliceExt::first(self)\n-    }\n-\n-    /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [0, 1, 2];\n-    ///\n-    /// if let Some(first) = x.first_mut() {\n-    ///     *first = 5;\n-    /// }\n-    /// assert_eq!(x, &[5, 1, 2]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn first_mut(&mut self) -> Option<&mut T> {\n-        core_slice::SliceExt::first_mut(self)\n-    }\n-\n-    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &[0, 1, 2];\n-    ///\n-    /// if let Some((first, elements)) = x.split_first() {\n-    ///     assert_eq!(first, &0);\n-    ///     assert_eq!(elements, &[1, 2]);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn split_first(&self) -> Option<(&T, &[T])> {\n-        core_slice::SliceExt::split_first(self)\n-    }\n-\n-    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [0, 1, 2];\n-    ///\n-    /// if let Some((first, elements)) = x.split_first_mut() {\n-    ///     *first = 3;\n-    ///     elements[0] = 4;\n-    ///     elements[1] = 5;\n-    /// }\n-    /// assert_eq!(x, &[3, 4, 5]);\n-    /// ```\n-    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        core_slice::SliceExt::split_first_mut(self)\n-    }\n-\n-    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &[0, 1, 2];\n-    ///\n-    /// if let Some((last, elements)) = x.split_last() {\n-    ///     assert_eq!(last, &2);\n-    ///     assert_eq!(elements, &[0, 1]);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn split_last(&self) -> Option<(&T, &[T])> {\n-        core_slice::SliceExt::split_last(self)\n-\n-    }\n-\n-    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [0, 1, 2];\n-    ///\n-    /// if let Some((last, elements)) = x.split_last_mut() {\n-    ///     *last = 3;\n-    ///     elements[0] = 4;\n-    ///     elements[1] = 5;\n-    /// }\n-    /// assert_eq!(x, &[4, 5, 3]);\n-    /// ```\n-    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        core_slice::SliceExt::split_last_mut(self)\n-    }\n-\n-    /// Returns the last element of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(Some(&30), v.last());\n-    ///\n-    /// let w: &[i32] = &[];\n-    /// assert_eq!(None, w.last());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn last(&self) -> Option<&T> {\n-        core_slice::SliceExt::last(self)\n-    }\n-\n-    /// Returns a mutable pointer to the last item in the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [0, 1, 2];\n-    ///\n-    /// if let Some(last) = x.last_mut() {\n-    ///     *last = 10;\n-    /// }\n-    /// assert_eq!(x, &[0, 1, 10]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn last_mut(&mut self) -> Option<&mut T> {\n-        core_slice::SliceExt::last_mut(self)\n-    }\n-\n-    /// Returns a reference to an element or subslice depending on the type of\n-    /// index.\n-    ///\n-    /// - If given a position, returns a reference to the element at that\n-    ///   position or `None` if out of bounds.\n-    /// - If given a range, returns the subslice corresponding to that range,\n-    ///   or `None` if out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(Some(&40), v.get(1));\n-    /// assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n-    /// assert_eq!(None, v.get(3));\n-    /// assert_eq!(None, v.get(0..4));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n-        where I: SliceIndex<Self>\n-    {\n-        core_slice::SliceExt::get(self, index)\n-    }\n-\n-    /// Returns a mutable reference to an element or subslice depending on the\n-    /// type of index (see [`get`]) or `None` if the index is out of bounds.\n-    ///\n-    /// [`get`]: #method.get\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [0, 1, 2];\n-    ///\n-    /// if let Some(elem) = x.get_mut(1) {\n-    ///     *elem = 42;\n-    /// }\n-    /// assert_eq!(x, &[0, 42, 2]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n-        where I: SliceIndex<Self>\n-    {\n-        core_slice::SliceExt::get_mut(self, index)\n-    }\n-\n-    /// Returns a reference to an element or subslice, without doing bounds\n-    /// checking.\n-    ///\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`get`].\n-    ///\n-    /// [`get`]: #method.get\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &[1, 2, 4];\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(x.get_unchecked(1), &2);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n-        where I: SliceIndex<Self>\n-    {\n-        core_slice::SliceExt::get_unchecked(self, index)\n-    }\n-\n-    /// Returns a mutable reference to an element or subslice, without doing\n-    /// bounds checking.\n-    ///\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`get_mut`].\n-    ///\n-    /// [`get_mut`]: #method.get_mut\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [1, 2, 4];\n-    ///\n-    /// unsafe {\n-    ///     let elem = x.get_unchecked_mut(1);\n-    ///     *elem = 13;\n-    /// }\n-    /// assert_eq!(x, &[1, 13, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n-        where I: SliceIndex<Self>\n-    {\n-        core_slice::SliceExt::get_unchecked_mut(self, index)\n-    }\n-\n-    /// Returns a raw pointer to the slice's buffer.\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the container referenced by this slice may cause its buffer\n-    /// to be reallocated, which would also make any pointers to it invalid.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &[1, 2, 4];\n-    /// let x_ptr = x.as_ptr();\n-    ///\n-    /// unsafe {\n-    ///     for i in 0..x.len() {\n-    ///         assert_eq!(x.get_unchecked(i), &*x_ptr.offset(i as isize));\n-    ///     }\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn as_ptr(&self) -> *const T {\n-        core_slice::SliceExt::as_ptr(self)\n-    }\n-\n-    /// Returns an unsafe mutable pointer to the slice's buffer.\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the container referenced by this slice may cause its buffer\n-    /// to be reallocated, which would also make any pointers to it invalid.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [1, 2, 4];\n-    /// let x_ptr = x.as_mut_ptr();\n-    ///\n-    /// unsafe {\n-    ///     for i in 0..x.len() {\n-    ///         *x_ptr.offset(i as isize) += 2;\n-    ///     }\n-    /// }\n-    /// assert_eq!(x, &[3, 4, 6]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        core_slice::SliceExt::as_mut_ptr(self)\n-    }\n-\n-    /// Swaps two elements in the slice.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `a` or `b` are out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn swap(&mut self, a: usize, b: usize) {\n-        core_slice::SliceExt::swap(self, a, b)\n-    }\n-\n-    /// Reverses the order of elements in the slice, in place.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [1, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3, 2, 1]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn reverse(&mut self) {\n-        core_slice::SliceExt::reverse(self)\n-    }\n-\n-    /// Returns an iterator over the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &[1, 2, 4];\n-    /// let mut iterator = x.iter();\n-    ///\n-    /// assert_eq!(iterator.next(), Some(&1));\n-    /// assert_eq!(iterator.next(), Some(&2));\n-    /// assert_eq!(iterator.next(), Some(&4));\n-    /// assert_eq!(iterator.next(), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn iter(&self) -> Iter<T> {\n-        core_slice::SliceExt::iter(self)\n-    }\n-\n-    /// Returns an iterator that allows modifying each value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [1, 2, 4];\n-    /// for elem in x.iter_mut() {\n-    ///     *elem += 2;\n-    /// }\n-    /// assert_eq!(x, &[3, 4, 6]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn iter_mut(&mut self) -> IterMut<T> {\n-        core_slice::SliceExt::iter_mut(self)\n-    }\n-\n-    /// Returns an iterator over all contiguous windows of length\n-    /// `size`. The windows overlap. If the slice is shorter than\n-    /// `size`, the iterator returns no values.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let slice = ['r', 'u', 's', 't'];\n-    /// let mut iter = slice.windows(2);\n-    /// assert_eq!(iter.next().unwrap(), &['r', 'u']);\n-    /// assert_eq!(iter.next().unwrap(), &['u', 's']);\n-    /// assert_eq!(iter.next().unwrap(), &['s', 't']);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    ///\n-    /// If the slice is shorter than `size`:\n-    ///\n-    /// ```\n-    /// let slice = ['f', 'o', 'o'];\n-    /// let mut iter = slice.windows(4);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn windows(&self, size: usize) -> Windows<T> {\n-        core_slice::SliceExt::windows(self, size)\n-    }\n-\n-    /// Returns an iterator over `chunk_size` elements of the slice at a\n-    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will\n-    /// not have length `chunk_size`.\n-    ///\n-    /// See [`exact_chunks`] for a variant of this iterator that returns chunks\n-    /// of always exactly `chunk_size` elements.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n-    /// let mut iter = slice.chunks(2);\n-    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n-    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n-    /// assert_eq!(iter.next().unwrap(), &['m']);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    ///\n-    /// [`exact_chunks`]: #method.exact_chunks\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n-        core_slice::SliceExt::chunks(self, chunk_size)\n-    }\n-\n-    /// Returns an iterator over `chunk_size` elements of the slice at a\n-    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last up to `chunk_size-1`\n-    /// elements will be omitted.\n-    ///\n-    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n-    /// can often optimize the resulting code better than in the case of\n-    /// [`chunks`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(exact_chunks)]\n-    ///\n-    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n-    /// let mut iter = slice.exact_chunks(2);\n-    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n-    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    ///\n-    /// [`chunks`]: #method.chunks\n-    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-    #[inline]\n-    pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n-        core_slice::SliceExt::exact_chunks(self, chunk_size)\n-    }\n-\n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will not\n-    /// have length `chunk_size`.\n-    ///\n-    /// See [`exact_chunks_mut`] for a variant of this iterator that returns chunks\n-    /// of always exactly `chunk_size` elements.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = &mut [0, 0, 0, 0, 0];\n-    /// let mut count = 1;\n-    ///\n-    /// for chunk in v.chunks_mut(2) {\n-    ///     for elem in chunk.iter_mut() {\n-    ///         *elem += count;\n-    ///     }\n-    ///     count += 1;\n-    /// }\n-    /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n-    /// ```\n-    ///\n-    /// [`exact_chunks_mut`]: #method.exact_chunks_mut\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n-        core_slice::SliceExt::chunks_mut(self, chunk_size)\n-    }\n-\n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last up to `chunk_size-1`\n-    /// elements will be omitted.\n-    ///\n-    ///\n-    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n-    /// can often optimize the resulting code better than in the case of\n-    /// [`chunks_mut`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(exact_chunks)]\n-    ///\n-    /// let v = &mut [0, 0, 0, 0, 0];\n-    /// let mut count = 1;\n-    ///\n-    /// for chunk in v.exact_chunks_mut(2) {\n-    ///     for elem in chunk.iter_mut() {\n-    ///         *elem += count;\n-    ///     }\n-    ///     count += 1;\n-    /// }\n-    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n-    /// ```\n-    ///\n-    /// [`chunks_mut`]: #method.chunks_mut\n-    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-    #[inline]\n-    pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n-        core_slice::SliceExt::exact_chunks_mut(self, chunk_size)\n-    }\n-\n-    /// Divides one slice into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid > len`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [1, 2, 3, 4, 5, 6];\n-    ///\n-    /// {\n-    ///    let (left, right) = v.split_at(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.split_at(2);\n-    ///     assert!(left == [1, 2]);\n-    ///     assert!(right == [3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.split_at(6);\n-    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n-        core_slice::SliceExt::split_at(self, mid)\n-    }\n-\n-    /// Divides one mutable slice into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid > len`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [1, 0, 3, 0, 5, 6];\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1, 0]);\n-    ///     assert!(right == [3, 0, 5, 6]);\n-    ///     left[1] = 2;\n-    ///     right[1] = 4;\n-    /// }\n-    /// assert!(v == [1, 2, 3, 4, 5, 6]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-        core_slice::SliceExt::split_at_mut(self, mid)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`. The matched element is not contained in the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let slice = [10, 40, 33, 20];\n-    /// let mut iter = slice.split(|num| num % 3 == 0);\n-    ///\n-    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n-    /// assert_eq!(iter.next().unwrap(), &[20]);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    ///\n-    /// If the first element is matched, an empty slice will be the first item\n-    /// returned by the iterator. Similarly, if the last element in the slice\n-    /// is matched, an empty slice will be the last item returned by the\n-    /// iterator:\n-    ///\n-    /// ```\n-    /// let slice = [10, 40, 33];\n-    /// let mut iter = slice.split(|num| num % 3 == 0);\n-    ///\n-    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n-    /// assert_eq!(iter.next().unwrap(), &[]);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    ///\n-    /// If two matched elements are directly adjacent, an empty slice will be\n-    /// present between them:\n-    ///\n-    /// ```\n-    /// let slice = [10, 6, 33, 20];\n-    /// let mut iter = slice.split(|num| num % 3 == 0);\n-    ///\n-    /// assert_eq!(iter.next().unwrap(), &[10]);\n-    /// assert_eq!(iter.next().unwrap(), &[]);\n-    /// assert_eq!(iter.next().unwrap(), &[20]);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split<F>(&self, pred: F) -> Split<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::split(self, pred)\n-    }\n-\n-    /// Returns an iterator over mutable subslices separated by elements that\n-    /// match `pred`. The matched element is not contained in the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [10, 40, 30, 20, 60, 50];\n-    ///\n-    /// for group in v.split_mut(|num| *num % 3 == 0) {\n-    ///     group[0] = 1;\n-    /// }\n-    /// assert_eq!(v, [1, 40, 30, 1, 60, 1]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::split_mut(self, pred)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, starting at the end of the slice and working backwards.\n-    /// The matched element is not contained in the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    ///\n-    /// let slice = [11, 22, 33, 0, 44, 55];\n-    /// let mut iter = slice.rsplit(|num| *num == 0);\n-    ///\n-    /// assert_eq!(iter.next().unwrap(), &[44, 55]);\n-    /// assert_eq!(iter.next().unwrap(), &[11, 22, 33]);\n-    /// assert_eq!(iter.next(), None);\n-    /// ```\n-    ///\n-    /// As with `split()`, if the first or last element is matched, an empty\n-    /// slice will be the first (or last) item returned by the iterator.\n-    ///\n-    /// ```\n-    /// let v = &[0, 1, 1, 2, 3, 5, 8];\n-    /// let mut it = v.rsplit(|n| *n % 2 == 0);\n-    /// assert_eq!(it.next().unwrap(), &[]);\n-    /// assert_eq!(it.next().unwrap(), &[3, 5]);\n-    /// assert_eq!(it.next().unwrap(), &[1, 1]);\n-    /// assert_eq!(it.next().unwrap(), &[]);\n-    /// assert_eq!(it.next(), None);\n-    /// ```\n-    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n-    #[inline]\n-    pub fn rsplit<F>(&self, pred: F) -> RSplit<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::rsplit(self, pred)\n-    }\n-\n-    /// Returns an iterator over mutable subslices separated by elements that\n-    /// match `pred`, starting at the end of the slice and working\n-    /// backwards. The matched element is not contained in the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [100, 400, 300, 200, 600, 500];\n-    ///\n-    /// let mut count = 0;\n-    /// for group in v.rsplit_mut(|num| *num % 3 == 0) {\n-    ///     count += 1;\n-    ///     group[0] = count;\n-    /// }\n-    /// assert_eq!(v, [3, 400, 300, 2, 600, 1]);\n-    /// ```\n-    ///\n-    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n-    #[inline]\n-    pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::rsplit_mut(self, pred)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to returning at most `n` items. The matched element is\n-    /// not contained in the subslices.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n-    /// `[20, 60, 50]`):\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n-    ///\n-    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::splitn(self, n, pred)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to returning at most `n` items. The matched element is\n-    /// not contained in the subslices.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [10, 40, 30, 20, 60, 50];\n-    ///\n-    /// for group in v.splitn_mut(2, |num| *num % 3 == 0) {\n-    ///     group[0] = 1;\n-    /// }\n-    /// assert_eq!(v, [1, 40, 30, 1, 60, 50]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::splitn_mut(self, n, pred)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to returning at most `n` items. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the slice split once, starting from the end, by numbers divisible\n-    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n-    ///\n-    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::rsplitn(self, n, pred)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to returning at most `n` items. This starts at the end of\n-    /// the slice and works backwards. The matched element is not contained in\n-    /// the subslices.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut s = [10, 40, 30, 20, 60, 50];\n-    ///\n-    /// for group in s.rsplitn_mut(2, |num| *num % 3 == 0) {\n-    ///     group[0] = 1;\n-    /// }\n-    /// assert_eq!(s, [1, 40, 30, 20, 60, 1]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n-    }\n-\n-    /// Returns `true` if the slice contains an element with the given value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.contains(&30));\n-    /// assert!(!v.contains(&50));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains(&self, x: &T) -> bool\n-        where T: PartialEq\n-    {\n-        core_slice::SliceExt::contains(self, x)\n-    }\n-\n-    /// Returns `true` if `needle` is a prefix of the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.starts_with(&[10]));\n-    /// assert!(v.starts_with(&[10, 40]));\n-    /// assert!(!v.starts_with(&[50]));\n-    /// assert!(!v.starts_with(&[10, 50]));\n-    /// ```\n-    ///\n-    /// Always returns `true` if `needle` is an empty slice:\n-    ///\n-    /// ```\n-    /// let v = &[10, 40, 30];\n-    /// assert!(v.starts_with(&[]));\n-    /// let v: &[u8] = &[];\n-    /// assert!(v.starts_with(&[]));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with(&self, needle: &[T]) -> bool\n-        where T: PartialEq\n-    {\n-        core_slice::SliceExt::starts_with(self, needle)\n-    }\n-\n-    /// Returns `true` if `needle` is a suffix of the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.ends_with(&[30]));\n-    /// assert!(v.ends_with(&[40, 30]));\n-    /// assert!(!v.ends_with(&[50]));\n-    /// assert!(!v.ends_with(&[50, 30]));\n-    /// ```\n-    ///\n-    /// Always returns `true` if `needle` is an empty slice:\n-    ///\n-    /// ```\n-    /// let v = &[10, 40, 30];\n-    /// assert!(v.ends_with(&[]));\n-    /// let v: &[u8] = &[];\n-    /// assert!(v.ends_with(&[]));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with(&self, needle: &[T]) -> bool\n-        where T: PartialEq\n-    {\n-        core_slice::SliceExt::ends_with(self, needle)\n-    }\n-\n-    /// Binary searches this sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Ok` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1, 4]`.\n-    ///\n-    /// ```\n-    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    ///\n-    /// assert_eq!(s.binary_search(&13),  Ok(9));\n-    /// assert_eq!(s.binary_search(&4),   Err(7));\n-    /// assert_eq!(s.binary_search(&100), Err(13));\n-    /// let r = s.binary_search(&1);\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n-        where T: Ord\n-    {\n-        core_slice::SliceExt::binary_search(self, x)\n-    }\n-\n-    /// Binary searches this sorted slice with a comparator function.\n-    ///\n-    /// The comparator function should implement an order consistent\n-    /// with the sort order of the underlying slice, returning an\n-    /// order code that indicates whether its argument is `Less`,\n-    /// `Equal` or `Greater` the desired target.\n-    ///\n-    /// If a matching value is found then returns `Ok`, containing\n-    /// the index for the matched element; if no match is found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1, 4]`.\n-    ///\n-    /// ```\n-    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    ///\n-    /// let seek = 13;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n-    /// let seek = 4;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n-    /// let seek = 100;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n-    /// let seek = 1;\n-    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n-        where F: FnMut(&'a T) -> Ordering\n-    {\n-        core_slice::SliceExt::binary_search_by(self, f)\n-    }\n-\n-    /// Binary searches this sorted slice with a key extraction function.\n-    ///\n-    /// Assumes that the slice is sorted by the key, for instance with\n-    /// [`sort_by_key`] using the same key extraction function.\n-    ///\n-    /// If a matching value is found then returns `Ok`, containing the\n-    /// index for the matched element; if no match is found then `Err`\n-    /// is returned, containing the index where a matching element could\n-    /// be inserted while maintaining sorted order.\n-    ///\n-    /// [`sort_by_key`]: #method.sort_by_key\n-    ///\n-    /// # Examples\n-    ///\n-    /// Looks up a series of four elements in a slice of pairs sorted by\n-    /// their second elements. The first is found, with a uniquely\n-    /// determined position; the second and third are not found; the\n-    /// fourth could match any position in `[1, 4]`.\n-    ///\n-    /// ```\n-    /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n-    ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n-    ///          (1, 21), (2, 34), (4, 55)];\n-    ///\n-    /// assert_eq!(s.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\n-    /// assert_eq!(s.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\n-    /// assert_eq!(s.binary_search_by_key(&100, |&(a,b)| b), Err(13));\n-    /// let r = s.binary_search_by_key(&1, |&(a,b)| b);\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n-    #[inline]\n-    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n-        where F: FnMut(&'a T) -> B,\n-              B: Ord\n-    {\n-        core_slice::SliceExt::binary_search_by_key(self, b, f)\n-    }\n+    #[cfg(stage0)]\n+    slice_core_methods!();\n \n     /// Sorts the slice.\n     ///\n@@ -1402,345 +355,6 @@ impl<T> [T] {\n         sort_by_key!(usize, self, f)\n     }\n \n-    /// Sorts the slice, but may not preserve the order of equal elements.\n-    ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(n log n)` worst-case.\n-    ///\n-    /// # Current implementation\n-    ///\n-    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n-    /// which combines the fast average case of randomized quicksort with the fast worst case of\n-    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n-    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n-    /// deterministic behavior.\n-    ///\n-    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n-    /// slice consists of several concatenated sorted sequences.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [-5, 4, 1, -3, 2];\n-    ///\n-    /// v.sort_unstable();\n-    /// assert!(v == [-5, -3, 1, 2, 4]);\n-    /// ```\n-    ///\n-    /// [pdqsort]: https://github.com/orlp/pdqsort\n-    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn sort_unstable(&mut self)\n-        where T: Ord\n-    {\n-        core_slice::SliceExt::sort_unstable(self);\n-    }\n-\n-    /// Sorts the slice with a comparator function, but may not preserve the order of equal\n-    /// elements.\n-    ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(n log n)` worst-case.\n-    ///\n-    /// # Current implementation\n-    ///\n-    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n-    /// which combines the fast average case of randomized quicksort with the fast worst case of\n-    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n-    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n-    /// deterministic behavior.\n-    ///\n-    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n-    /// slice consists of several concatenated sorted sequences.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [5, 4, 1, 3, 2];\n-    /// v.sort_unstable_by(|a, b| a.cmp(b));\n-    /// assert!(v == [1, 2, 3, 4, 5]);\n-    ///\n-    /// // reverse sorting\n-    /// v.sort_unstable_by(|a, b| b.cmp(a));\n-    /// assert!(v == [5, 4, 3, 2, 1]);\n-    /// ```\n-    ///\n-    /// [pdqsort]: https://github.com/orlp/pdqsort\n-    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn sort_unstable_by<F>(&mut self, compare: F)\n-        where F: FnMut(&T, &T) -> Ordering\n-    {\n-        core_slice::SliceExt::sort_unstable_by(self, compare);\n-    }\n-\n-    /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n-    /// elements.\n-    ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(m n log(m n))` worst-case, where the key function is `O(m)`.\n-    ///\n-    /// # Current implementation\n-    ///\n-    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n-    /// which combines the fast average case of randomized quicksort with the fast worst case of\n-    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n-    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n-    /// deterministic behavior.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [-5i32, 4, 1, -3, 2];\n-    ///\n-    /// v.sort_unstable_by_key(|k| k.abs());\n-    /// assert!(v == [1, 2, -3, 4, -5]);\n-    /// ```\n-    ///\n-    /// [pdqsort]: https://github.com/orlp/pdqsort\n-    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn sort_unstable_by_key<K, F>(&mut self, f: F)\n-        where F: FnMut(&T) -> K, K: Ord\n-    {\n-        core_slice::SliceExt::sort_unstable_by_key(self, f);\n-    }\n-\n-    /// Rotates the slice in-place such that the first `mid` elements of the\n-    /// slice move to the end while the last `self.len() - mid` elements move to\n-    /// the front. After calling `rotate_left`, the element previously at index\n-    /// `mid` will become the first element in the slice.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if `mid` is greater than the length of the\n-    /// slice. Note that `mid == self.len()` does _not_ panic and is a no-op\n-    /// rotation.\n-    ///\n-    /// # Complexity\n-    ///\n-    /// Takes linear (in `self.len()`) time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n-    /// a.rotate_left(2);\n-    /// assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n-    /// ```\n-    ///\n-    /// Rotating a subslice:\n-    ///\n-    /// ```\n-    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n-    /// a[1..5].rotate_left(1);\n-    /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n-   /// ```\n-    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n-    pub fn rotate_left(&mut self, mid: usize) {\n-        core_slice::SliceExt::rotate_left(self, mid);\n-    }\n-\n-    /// Rotates the slice in-place such that the first `self.len() - k`\n-    /// elements of the slice move to the end while the last `k` elements move\n-    /// to the front. After calling `rotate_right`, the element previously at\n-    /// index `self.len() - k` will become the first element in the slice.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if `k` is greater than the length of the\n-    /// slice. Note that `k == self.len()` does _not_ panic and is a no-op\n-    /// rotation.\n-    ///\n-    /// # Complexity\n-    ///\n-    /// Takes linear (in `self.len()`) time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n-    /// a.rotate_right(2);\n-    /// assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n-    /// ```\n-    ///\n-    /// Rotate a subslice:\n-    ///\n-    /// ```\n-    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n-    /// a[1..5].rotate_right(1);\n-    /// assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);\n-    /// ```\n-    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n-    pub fn rotate_right(&mut self, k: usize) {\n-        core_slice::SliceExt::rotate_right(self, k);\n-    }\n-\n-    /// Copies the elements from `src` into `self`.\n-    ///\n-    /// The length of `src` must be the same as `self`.\n-    ///\n-    /// If `src` implements `Copy`, it can be more performant to use\n-    /// [`copy_from_slice`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the two slices have different lengths.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Cloning two elements from a slice into another:\n-    ///\n-    /// ```\n-    /// let src = [1, 2, 3, 4];\n-    /// let mut dst = [0, 0];\n-    ///\n-    /// dst.clone_from_slice(&src[2..]);\n-    ///\n-    /// assert_eq!(src, [1, 2, 3, 4]);\n-    /// assert_eq!(dst, [3, 4]);\n-    /// ```\n-    ///\n-    /// Rust enforces that there can only be one mutable reference with no\n-    /// immutable references to a particular piece of data in a particular\n-    /// scope. Because of this, attempting to use `clone_from_slice` on a\n-    /// single slice will result in a compile failure:\n-    ///\n-    /// ```compile_fail\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    ///\n-    /// slice[..2].clone_from_slice(&slice[3..]); // compile fail!\n-    /// ```\n-    ///\n-    /// To work around this, we can use [`split_at_mut`] to create two distinct\n-    /// sub-slices from a slice:\n-    ///\n-    /// ```\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    ///\n-    /// {\n-    ///     let (left, right) = slice.split_at_mut(2);\n-    ///     left.clone_from_slice(&right[1..]);\n-    /// }\n-    ///\n-    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n-    /// ```\n-    ///\n-    /// [`copy_from_slice`]: #method.copy_from_slice\n-    /// [`split_at_mut`]: #method.split_at_mut\n-    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n-    pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n-        core_slice::SliceExt::clone_from_slice(self, src)\n-    }\n-\n-    /// Copies all elements from `src` into `self`, using a memcpy.\n-    ///\n-    /// The length of `src` must be the same as `self`.\n-    ///\n-    /// If `src` does not implement `Copy`, use [`clone_from_slice`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the two slices have different lengths.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Copying two elements from a slice into another:\n-    ///\n-    /// ```\n-    /// let src = [1, 2, 3, 4];\n-    /// let mut dst = [0, 0];\n-    ///\n-    /// dst.copy_from_slice(&src[2..]);\n-    ///\n-    /// assert_eq!(src, [1, 2, 3, 4]);\n-    /// assert_eq!(dst, [3, 4]);\n-    /// ```\n-    ///\n-    /// Rust enforces that there can only be one mutable reference with no\n-    /// immutable references to a particular piece of data in a particular\n-    /// scope. Because of this, attempting to use `copy_from_slice` on a\n-    /// single slice will result in a compile failure:\n-    ///\n-    /// ```compile_fail\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    ///\n-    /// slice[..2].copy_from_slice(&slice[3..]); // compile fail!\n-    /// ```\n-    ///\n-    /// To work around this, we can use [`split_at_mut`] to create two distinct\n-    /// sub-slices from a slice:\n-    ///\n-    /// ```\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    ///\n-    /// {\n-    ///     let (left, right) = slice.split_at_mut(2);\n-    ///     left.copy_from_slice(&right[1..]);\n-    /// }\n-    ///\n-    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n-    /// ```\n-    ///\n-    /// [`clone_from_slice`]: #method.clone_from_slice\n-    /// [`split_at_mut`]: #method.split_at_mut\n-    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n-    pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n-        core_slice::SliceExt::copy_from_slice(self, src)\n-    }\n-\n-    /// Swaps all elements in `self` with those in `other`.\n-    ///\n-    /// The length of `other` must be the same as `self`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the two slices have different lengths.\n-    ///\n-    /// # Example\n-    ///\n-    /// Swapping two elements across slices:\n-    ///\n-    /// ```\n-    /// let mut slice1 = [0, 0];\n-    /// let mut slice2 = [1, 2, 3, 4];\n-    ///\n-    /// slice1.swap_with_slice(&mut slice2[2..]);\n-    ///\n-    /// assert_eq!(slice1, [3, 4]);\n-    /// assert_eq!(slice2, [1, 2, 0, 0]);\n-    /// ```\n-    ///\n-    /// Rust enforces that there can only be one mutable reference to a\n-    /// particular piece of data in a particular scope. Because of this,\n-    /// attempting to use `swap_with_slice` on a single slice will result in\n-    /// a compile failure:\n-    ///\n-    /// ```compile_fail\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    /// slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!\n-    /// ```\n-    ///\n-    /// To work around this, we can use [`split_at_mut`] to create two distinct\n-    /// mutable sub-slices from a slice:\n-    ///\n-    /// ```\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    ///\n-    /// {\n-    ///     let (left, right) = slice.split_at_mut(2);\n-    ///     left.swap_with_slice(&mut right[1..]);\n-    /// }\n-    ///\n-    /// assert_eq!(slice, [4, 5, 3, 1, 2]);\n-    /// ```\n-    ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n-    #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n-    pub fn swap_with_slice(&mut self, other: &mut [T]) {\n-        core_slice::SliceExt::swap_with_slice(self, other)\n-    }\n-\n     /// Copies `self` into a new `Vec`.\n     ///\n     /// # Examples\n@@ -1782,16 +396,10 @@ impl<T> [T] {\n     }\n }\n \n-#[lang = \"slice_u8\"]\n+#[cfg_attr(stage0, lang = \"slice_u8\")]\n+#[cfg_attr(not(stage0), lang = \"slice_u8_alloc\")]\n #[cfg(not(test))]\n impl [u8] {\n-    /// Checks if all bytes in this slice are within the ASCII range.\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn is_ascii(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii())\n-    }\n-\n     /// Returns a vector containing a copy of this slice where each byte\n     /// is mapped to its ASCII upper case equivalent.\n     ///\n@@ -1826,52 +434,8 @@ impl [u8] {\n         me\n     }\n \n-    /// Checks that two slices are an ASCII case-insensitive match.\n-    ///\n-    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n-    /// but without allocating and copying temporaries.\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().zip(other).all(|(a, b)| {\n-                a.eq_ignore_ascii_case(b)\n-            })\n-    }\n-\n-    /// Converts this slice to its ASCII upper case equivalent in-place.\n-    ///\n-    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n-    /// but non-ASCII letters are unchanged.\n-    ///\n-    /// To return a new uppercased value without modifying the existing one, use\n-    /// [`to_ascii_uppercase`].\n-    ///\n-    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn make_ascii_uppercase(&mut self) {\n-        for byte in self {\n-            byte.make_ascii_uppercase();\n-        }\n-    }\n-\n-    /// Converts this slice to its ASCII lower case equivalent in-place.\n-    ///\n-    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n-    /// but non-ASCII letters are unchanged.\n-    ///\n-    /// To return a new lowercased value without modifying the existing one, use\n-    /// [`to_ascii_lowercase`].\n-    ///\n-    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn make_ascii_lowercase(&mut self) {\n-        for byte in self {\n-            byte.make_ascii_lowercase();\n-        }\n-    }\n+    #[cfg(stage0)]\n+    slice_u8_core_methods!();\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "82ba2f4571193e09f9a871bc0fd569e72f7e3715", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 59, "deletions": 1776, "changes": 1835, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -40,6 +40,7 @@\n \n use core::fmt;\n use core::str as core_str;\n+#[cfg(stage0)] use core::str::StrExt;\n use core::str::pattern::Pattern;\n use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n@@ -76,7 +77,8 @@ pub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError\n pub use core::str::SplitWhitespace;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::pattern;\n-\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+pub use core::str::EncodeUtf16;\n \n #[unstable(feature = \"slice_concat_ext\",\n            reason = \"trait should not have to exist\",\n@@ -90,1729 +92,78 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n         }\n \n         // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.borrow().len()).sum();\n-        let mut result = String::with_capacity(len);\n-\n-        for s in self {\n-            result.push_str(s.borrow())\n-        }\n-\n-        result\n-    }\n-\n-    fn join(&self, sep: &str) -> String {\n-        if self.is_empty() {\n-            return String::new();\n-        }\n-\n-        // concat is faster\n-        if sep.is_empty() {\n-            return self.concat();\n-        }\n-\n-        // this is wrong without the guarantee that `self` is non-empty\n-        // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1) +\n-                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n-        let mut result = String::with_capacity(len);\n-        let mut first = true;\n-\n-        for s in self {\n-            if first {\n-                first = false;\n-            } else {\n-                result.push_str(sep);\n-            }\n-            result.push_str(s.borrow());\n-        }\n-        result\n-    }\n-\n-    fn connect(&self, sep: &str) -> String {\n-        self.join(sep)\n-    }\n-}\n-\n-/// An iterator of [`u16`] over the string encoded as UTF-16.\n-///\n-/// [`u16`]: ../../std/primitive.u16.html\n-///\n-/// This struct is created by the [`encode_utf16`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`encode_utf16`]: ../../std/primitive.str.html#method.encode_utf16\n-/// [`str`]: ../../std/primitive.str.html\n-#[derive(Clone)]\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-pub struct EncodeUtf16<'a> {\n-    chars: Chars<'a>,\n-    extra: u16,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a> fmt::Debug for EncodeUtf16<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"EncodeUtf16 { .. }\")\n-    }\n-}\n-\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-impl<'a> Iterator for EncodeUtf16<'a> {\n-    type Item = u16;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> {\n-        if self.extra != 0 {\n-            let tmp = self.extra;\n-            self.extra = 0;\n-            return Some(tmp);\n-        }\n-\n-        let mut buf = [0; 2];\n-        self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(&mut buf).len();\n-            if n == 2 {\n-                self.extra = buf[1];\n-            }\n-            buf[0]\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (low, high) = self.chars.size_hint();\n-        // every char gets either one u16 or two u16,\n-        // so this iterator is between 1 or 2 times as\n-        // long as the underlying iterator.\n-        (low, high.and_then(|n| n.checked_mul(2)))\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a> FusedIterator for EncodeUtf16<'a> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Borrow<str> for String {\n-    #[inline]\n-    fn borrow(&self) -> &str {\n-        &self[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ToOwned for str {\n-    type Owned = String;\n-    fn to_owned(&self) -> String {\n-        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n-    }\n-\n-    fn clone_into(&self, target: &mut String) {\n-        let mut b = mem::replace(target, String::new()).into_bytes();\n-        self.as_bytes().clone_into(&mut b);\n-        *target = unsafe { String::from_utf8_unchecked(b) }\n-    }\n-}\n-\n-/// Methods for string slices.\n-#[lang = \"str\"]\n-#[cfg(not(test))]\n-impl str {\n-    /// Returns the length of `self`.\n-    ///\n-    /// This length is in bytes, not [`char`]s or graphemes. In other words,\n-    /// it may not be what a human considers the length of the string.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let len = \"foo\".len();\n-    /// assert_eq!(3, len);\n-    ///\n-    /// let len = \"\u0192oo\".len(); // fancy f!\n-    /// assert_eq!(4, len);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn len(&self) -> usize {\n-        core_str::StrExt::len(self)\n-    }\n-\n-    /// Returns `true` if `self` has a length of zero bytes.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"\";\n-    /// assert!(s.is_empty());\n-    ///\n-    /// let s = \"not empty\";\n-    /// assert!(!s.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(self)\n-    }\n-\n-    /// Checks that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n-    ///\n-    /// The start and end of the string (when `index == self.len()`) are\n-    /// considered to be\n-    /// boundaries.\n-    ///\n-    /// Returns `false` if `index` is greater than `self.len()`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert!(s.is_char_boundary(0));\n-    /// // start of `\u8001`\n-    /// assert!(s.is_char_boundary(6));\n-    /// assert!(s.is_char_boundary(s.len()));\n-    ///\n-    /// // second byte of `\u00f6`\n-    /// assert!(!s.is_char_boundary(2));\n-    ///\n-    /// // third byte of `\u8001`\n-    /// assert!(!s.is_char_boundary(8));\n-    /// ```\n-    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n-    #[inline]\n-    pub fn is_char_boundary(&self, index: usize) -> bool {\n-        core_str::StrExt::is_char_boundary(self, index)\n-    }\n-\n-    /// Converts a string slice to a byte slice. To convert the byte slice back\n-    /// into a string slice, use the [`str::from_utf8`] function.\n-    ///\n-    /// [`str::from_utf8`]: ./str/fn.from_utf8.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bytes = \"bors\".as_bytes();\n-    /// assert_eq!(b\"bors\", bytes);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline(always)]\n-    pub fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(self)\n-    }\n-\n-    /// Converts a mutable string slice to a mutable byte slice. To convert the\n-    /// mutable byte slice back into a mutable string slice, use the\n-    /// [`str::from_utf8_mut`] function.\n-    ///\n-    /// [`str::from_utf8_mut`]: ./str/fn.from_utf8_mut.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut s = String::from(\"Hello\");\n-    /// let bytes = unsafe { s.as_bytes_mut() };\n-    ///\n-    /// assert_eq!(b\"Hello\", bytes);\n-    /// ```\n-    ///\n-    /// Mutability:\n-    ///\n-    /// ```\n-    /// let mut s = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n-    ///\n-    /// unsafe {\n-    ///     let bytes = s.as_bytes_mut();\n-    ///\n-    ///     bytes[0] = 0xF0;\n-    ///     bytes[1] = 0x9F;\n-    ///     bytes[2] = 0x8D;\n-    ///     bytes[3] = 0x94;\n-    /// }\n-    ///\n-    /// assert_eq!(\"\ud83c\udf54\u2208\ud83c\udf0f\", s);\n-    /// ```\n-    #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n-    #[inline(always)]\n-    pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n-        core_str::StrExt::as_bytes_mut(self)\n-    }\n-\n-    /// Converts a string slice to a raw pointer.\n-    ///\n-    /// As string slices are a slice of bytes, the raw pointer points to a\n-    /// [`u8`]. This pointer will be pointing to the first byte of the string\n-    /// slice.\n-    ///\n-    /// [`u8`]: primitive.u8.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"Hello\";\n-    /// let ptr = s.as_ptr();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(self)\n-    }\n-\n-    /// Returns a subslice of `str`.\n-    ///\n-    /// This is the non-panicking alternative to indexing the `str`. Returns\n-    /// [`None`] whenever equivalent indexing operation would panic.\n-    ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n-    ///\n-    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n-    ///\n-    /// // indices not on UTF-8 sequence boundaries\n-    /// assert!(v.get(1..).is_none());\n-    /// assert!(v.get(..8).is_none());\n-    ///\n-    /// // out of bounds\n-    /// assert!(v.get(..42).is_none());\n-    /// ```\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n-        core_str::StrExt::get(self, i)\n-    }\n-\n-    /// Returns a mutable subslice of `str`.\n-    ///\n-    /// This is the non-panicking alternative to indexing the `str`. Returns\n-    /// [`None`] whenever equivalent indexing operation would panic.\n-    ///\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = String::from(\"hello\");\n-    /// // correct length\n-    /// assert!(v.get_mut(0..5).is_some());\n-    /// // out of bounds\n-    /// assert!(v.get_mut(..42).is_none());\n-    /// assert_eq!(Some(\"he\"), v.get_mut(0..2).map(|v| &*v));\n-    ///\n-    /// assert_eq!(\"hello\", v);\n-    /// {\n-    ///     let s = v.get_mut(0..2);\n-    ///     let s = s.map(|s| {\n-    ///         s.make_ascii_uppercase();\n-    ///         &*s\n-    ///     });\n-    ///     assert_eq!(Some(\"HE\"), s);\n-    /// }\n-    /// assert_eq!(\"HEllo\", v);\n-    /// ```\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n-        core_str::StrExt::get_mut(self, i)\n-    }\n-\n-    /// Returns a unchecked subslice of `str`.\n-    ///\n-    /// This is the unchecked alternative to indexing the `str`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that these preconditions are\n-    /// satisfied:\n-    ///\n-    /// * The starting index must come before the ending index;\n-    /// * Indexes must be within bounds of the original slice;\n-    /// * Indexes must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// Failing that, the returned string slice may reference invalid memory or\n-    /// violate the invariants communicated by the `str` type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n-    /// unsafe {\n-    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked(0..4));\n-    ///     assert_eq!(\"\u2208\", v.get_unchecked(4..7));\n-    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked(7..11));\n-    /// }\n-    /// ```\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        core_str::StrExt::get_unchecked(self, i)\n-    }\n-\n-    /// Returns a mutable, unchecked subslice of `str`.\n-    ///\n-    /// This is the unchecked alternative to indexing the `str`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that these preconditions are\n-    /// satisfied:\n-    ///\n-    /// * The starting index must come before the ending index;\n-    /// * Indexes must be within bounds of the original slice;\n-    /// * Indexes must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// Failing that, the returned string slice may reference invalid memory or\n-    /// violate the invariants communicated by the `str` type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n-    /// unsafe {\n-    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked_mut(0..4));\n-    ///     assert_eq!(\"\u2208\", v.get_unchecked_mut(4..7));\n-    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked_mut(7..11));\n-    /// }\n-    /// ```\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        core_str::StrExt::get_unchecked_mut(self, i)\n-    }\n-\n-    /// Creates a string slice from another string slice, bypassing safety\n-    /// checks.\n-    ///\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`str`] and [`Index`].\n-    ///\n-    /// [`str`]: primitive.str.html\n-    /// [`Index`]: ops/trait.Index.html\n-    ///\n-    /// This new slice goes from `begin` to `end`, including `begin` but\n-    /// excluding `end`.\n-    ///\n-    /// To get a mutable string slice instead, see the\n-    /// [`slice_mut_unchecked`] method.\n-    ///\n-    /// [`slice_mut_unchecked`]: #method.slice_mut_unchecked\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that three preconditions are\n-    /// satisfied:\n-    ///\n-    /// * `begin` must come before `end`.\n-    /// * `begin` and `end` must be byte positions within the string slice.\n-    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(\"L\u00f6we \u8001\u864e L\u00e9opard\", s.slice_unchecked(0, 21));\n-    /// }\n-    ///\n-    /// let s = \"Hello, world!\";\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(\"world\", s.slice_unchecked(7, 12));\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_unchecked(self, begin, end)\n-    }\n-\n-    /// Creates a string slice from another string slice, bypassing safety\n-    /// checks.\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`str`] and [`IndexMut`].\n-    ///\n-    /// [`str`]: primitive.str.html\n-    /// [`IndexMut`]: ops/trait.IndexMut.html\n-    ///\n-    /// This new slice goes from `begin` to `end`, including `begin` but\n-    /// excluding `end`.\n-    ///\n-    /// To get an immutable string slice instead, see the\n-    /// [`slice_unchecked`] method.\n-    ///\n-    /// [`slice_unchecked`]: #method.slice_unchecked\n-    ///\n-    /// # Safety\n-    ///\n-    /// Callers of this function are responsible that three preconditions are\n-    /// satisfied:\n-    ///\n-    /// * `begin` must come before `end`.\n-    /// * `begin` and `end` must be byte positions within the string slice.\n-    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n-    #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n-    #[inline]\n-    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        core_str::StrExt::slice_mut_unchecked(self, begin, end)\n-    }\n-\n-    /// Divide one string slice into two at an index.\n-    ///\n-    /// The argument, `mid`, should be a byte offset from the start of the\n-    /// string. It must also be on the boundary of a UTF-8 code point.\n-    ///\n-    /// The two slices returned go from the start of the string slice to `mid`,\n-    /// and from `mid` to the end of the string slice.\n-    ///\n-    /// To get mutable string slices instead, see the [`split_at_mut`]\n-    /// method.\n-    ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \"Per Martin-L\u00f6f\";\n-    ///\n-    /// let (first, last) = s.split_at(3);\n-    ///\n-    /// assert_eq!(\"Per\", first);\n-    /// assert_eq!(\" Martin-L\u00f6f\", last);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n-    pub fn split_at(&self, mid: usize) -> (&str, &str) {\n-        core_str::StrExt::split_at(self, mid)\n-    }\n-\n-    /// Divide one mutable string slice into two at an index.\n-    ///\n-    /// The argument, `mid`, should be a byte offset from the start of the\n-    /// string. It must also be on the boundary of a UTF-8 code point.\n-    ///\n-    /// The two slices returned go from the start of the string slice to `mid`,\n-    /// and from `mid` to the end of the string slice.\n-    ///\n-    /// To get immutable string slices instead, see the [`split_at`] method.\n-    ///\n-    /// [`split_at`]: #method.split_at\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n-    /// beyond the last code point of the string slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n-    /// {\n-    ///     let (first, last) = s.split_at_mut(3);\n-    ///     first.make_ascii_uppercase();\n-    ///     assert_eq!(\"PER\", first);\n-    ///     assert_eq!(\" Martin-L\u00f6f\", last);\n-    /// }\n-    /// assert_eq!(\"PER Martin-L\u00f6f\", s);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n-    pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n-        core_str::StrExt::split_at_mut(self, mid)\n-    }\n-\n-    /// Returns an iterator over the [`char`]s of a string slice.\n-    ///\n-    /// As a string slice consists of valid UTF-8, we can iterate through a\n-    /// string slice by [`char`]. This method returns such an iterator.\n-    ///\n-    /// It's important to remember that [`char`] represents a Unicode Scalar\n-    /// Value, and may not match your idea of what a 'character' is. Iteration\n-    /// over grapheme clusters may be what you actually want.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let word = \"goodbye\";\n-    ///\n-    /// let count = word.chars().count();\n-    /// assert_eq!(7, count);\n-    ///\n-    /// let mut chars = word.chars();\n-    ///\n-    /// assert_eq!(Some('g'), chars.next());\n-    /// assert_eq!(Some('o'), chars.next());\n-    /// assert_eq!(Some('o'), chars.next());\n-    /// assert_eq!(Some('d'), chars.next());\n-    /// assert_eq!(Some('b'), chars.next());\n-    /// assert_eq!(Some('y'), chars.next());\n-    /// assert_eq!(Some('e'), chars.next());\n-    ///\n-    /// assert_eq!(None, chars.next());\n-    /// ```\n-    ///\n-    /// Remember, [`char`]s may not match your human intuition about characters:\n-    ///\n-    /// ```\n-    /// let y = \"y\u0306\";\n-    ///\n-    /// let mut chars = y.chars();\n-    ///\n-    /// assert_eq!(Some('y'), chars.next()); // not 'y\u0306'\n-    /// assert_eq!(Some('\\u{0306}'), chars.next());\n-    ///\n-    /// assert_eq!(None, chars.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(self)\n-    }\n-    /// Returns an iterator over the [`char`]s of a string slice, and their\n-    /// positions.\n-    ///\n-    /// As a string slice consists of valid UTF-8, we can iterate through a\n-    /// string slice by [`char`]. This method returns an iterator of both\n-    /// these [`char`]s, as well as their byte positions.\n-    ///\n-    /// The iterator yields tuples. The position is first, the [`char`] is\n-    /// second.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let word = \"goodbye\";\n-    ///\n-    /// let count = word.char_indices().count();\n-    /// assert_eq!(7, count);\n-    ///\n-    /// let mut char_indices = word.char_indices();\n-    ///\n-    /// assert_eq!(Some((0, 'g')), char_indices.next());\n-    /// assert_eq!(Some((1, 'o')), char_indices.next());\n-    /// assert_eq!(Some((2, 'o')), char_indices.next());\n-    /// assert_eq!(Some((3, 'd')), char_indices.next());\n-    /// assert_eq!(Some((4, 'b')), char_indices.next());\n-    /// assert_eq!(Some((5, 'y')), char_indices.next());\n-    /// assert_eq!(Some((6, 'e')), char_indices.next());\n-    ///\n-    /// assert_eq!(None, char_indices.next());\n-    /// ```\n-    ///\n-    /// Remember, [`char`]s may not match your human intuition about characters:\n-    ///\n-    /// ```\n-    /// let yes = \"y\u0306es\";\n-    ///\n-    /// let mut char_indices = yes.char_indices();\n-    ///\n-    /// assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y\u0306')\n-    /// assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n-    ///\n-    /// // note the 3 here - the last character took up two bytes\n-    /// assert_eq!(Some((3, 'e')), char_indices.next());\n-    /// assert_eq!(Some((4, 's')), char_indices.next());\n-    ///\n-    /// assert_eq!(None, char_indices.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(self)\n-    }\n-\n-    /// An iterator over the bytes of a string slice.\n-    ///\n-    /// As a string slice consists of a sequence of bytes, we can iterate\n-    /// through a string slice by byte. This method returns such an iterator.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut bytes = \"bors\".bytes();\n-    ///\n-    /// assert_eq!(Some(b'b'), bytes.next());\n-    /// assert_eq!(Some(b'o'), bytes.next());\n-    /// assert_eq!(Some(b'r'), bytes.next());\n-    /// assert_eq!(Some(b's'), bytes.next());\n-    ///\n-    /// assert_eq!(None, bytes.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(self)\n-    }\n-\n-    /// Split a string slice by whitespace.\n-    ///\n-    /// The iterator returned will return string slices that are sub-slices of\n-    /// the original string slice, separated by any amount of whitespace.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut iter = \"A few words\".split_whitespace();\n-    ///\n-    /// assert_eq!(Some(\"A\"), iter.next());\n-    /// assert_eq!(Some(\"few\"), iter.next());\n-    /// assert_eq!(Some(\"words\"), iter.next());\n-    ///\n-    /// assert_eq!(None, iter.next());\n-    /// ```\n-    ///\n-    /// All kinds of whitespace are considered:\n-    ///\n-    /// ```\n-    /// let mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\n-    /// assert_eq!(Some(\"Mary\"), iter.next());\n-    /// assert_eq!(Some(\"had\"), iter.next());\n-    /// assert_eq!(Some(\"a\"), iter.next());\n-    /// assert_eq!(Some(\"little\"), iter.next());\n-    /// assert_eq!(Some(\"lamb\"), iter.next());\n-    ///\n-    /// assert_eq!(None, iter.next());\n-    /// ```\n-    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-    #[inline]\n-    pub fn split_whitespace(&self) -> SplitWhitespace {\n-        StrExt::split_whitespace(self)\n-    }\n-\n-    /// An iterator over the lines of a string, as string slices.\n-    ///\n-    /// Lines are ended with either a newline (`\\n`) or a carriage return with\n-    /// a line feed (`\\r\\n`).\n-    ///\n-    /// The final line ending is optional.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let text = \"foo\\r\\nbar\\n\\nbaz\\n\";\n-    /// let mut lines = text.lines();\n-    ///\n-    /// assert_eq!(Some(\"foo\"), lines.next());\n-    /// assert_eq!(Some(\"bar\"), lines.next());\n-    /// assert_eq!(Some(\"\"), lines.next());\n-    /// assert_eq!(Some(\"baz\"), lines.next());\n-    ///\n-    /// assert_eq!(None, lines.next());\n-    /// ```\n-    ///\n-    /// The final line ending isn't required:\n-    ///\n-    /// ```\n-    /// let text = \"foo\\nbar\\n\\r\\nbaz\";\n-    /// let mut lines = text.lines();\n-    ///\n-    /// assert_eq!(Some(\"foo\"), lines.next());\n-    /// assert_eq!(Some(\"bar\"), lines.next());\n-    /// assert_eq!(Some(\"\"), lines.next());\n-    /// assert_eq!(Some(\"baz\"), lines.next());\n-    ///\n-    /// assert_eq!(None, lines.next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(self)\n-    }\n-\n-    /// An iterator over the lines of a string.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(self)\n-    }\n-\n-    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let text = \"Za\u017c\u00f3\u0142\u0107 g\u0119\u015bl\u0105 ja\u017a\u0144\";\n-    ///\n-    /// let utf8_len = text.len();\n-    /// let utf16_len = text.encode_utf16().count();\n-    ///\n-    /// assert!(utf16_len <= utf8_len);\n-    /// ```\n-    #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-    pub fn encode_utf16(&self) -> EncodeUtf16 {\n-        EncodeUtf16 { chars: self[..].chars(), extra: 0 }\n-    }\n-\n-    /// Returns `true` if the given pattern matches a sub-slice of\n-    /// this string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.contains(\"nana\"));\n-    /// assert!(!bananas.contains(\"apples\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::contains(self, pat)\n-    }\n-\n-    /// Returns `true` if the given pattern matches a prefix of this\n-    /// string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.starts_with(\"bana\"));\n-    /// assert!(!bananas.starts_with(\"nana\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::starts_with(self, pat)\n-    }\n-\n-    /// Returns `true` if the given pattern matches a suffix of this\n-    /// string slice.\n-    ///\n-    /// Returns `false` if it does not.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let bananas = \"bananas\";\n-    ///\n-    /// assert!(bananas.ends_with(\"anas\"));\n-    /// assert!(!bananas.ends_with(\"nana\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::ends_with(self, pat)\n-    }\n-\n-    /// Returns the byte index of the first character of this string slice that\n-    /// matches the pattern.\n-    ///\n-    /// Returns [`None`] if the pattern doesn't match.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find('L'), Some(0));\n-    /// assert_eq!(s.find('\u00e9'), Some(14));\n-    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n-    /// ```\n-    ///\n-    /// More complex patterns using point-free style and closures:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find(char::is_whitespace), Some(5));\n-    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n-    /// assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\n-    /// assert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));\n-    /// ```\n-    ///\n-    /// Not finding the pattern:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n-    ///\n-    /// assert_eq!(s.find(x), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n-        core_str::StrExt::find(self, pat)\n-    }\n-\n-    /// Returns the byte index of the last character of this string slice that\n-    /// matches the pattern.\n-    ///\n-    /// Returns [`None`] if the pattern doesn't match.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`None`]: option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind('L'), Some(13));\n-    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n-    /// ```\n-    ///\n-    /// More complex patterns with closures:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind(char::is_whitespace), Some(12));\n-    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n-    /// ```\n-    ///\n-    /// Not finding the pattern:\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n-    ///\n-    /// assert_eq!(s.rfind(x), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rfind(self, pat)\n-    }\n-\n-    /// An iterator over substrings of this string slice, separated by\n-    /// characters matched by a pattern.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rsplit`] method can be used.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    /// [`rsplit`]: #method.rsplit\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n-    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n-    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n-    /// ```\n-    ///\n-    /// If a string contains multiple contiguous separators, you will end up\n-    /// with empty strings in the output:\n-    ///\n-    /// ```\n-    /// let x = \"||||a||b|c\".to_string();\n-    /// let d: Vec<_> = x.split('|').collect();\n-    ///\n-    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// Contiguous separators are separated by the empty string.\n-    ///\n-    /// ```\n-    /// let x = \"(///)\".to_string();\n-    /// let d: Vec<_> = x.split('/').collect();\n-    ///\n-    /// assert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n-    /// ```\n-    ///\n-    /// Separators at the start or end of a string are neighbored\n-    /// by empty strings.\n-    ///\n-    /// ```\n-    /// let d: Vec<_> = \"010\".split(\"0\").collect();\n-    /// assert_eq!(d, &[\"\", \"1\", \"\"]);\n-    /// ```\n-    ///\n-    /// When the empty string is used as a separator, it separates\n-    /// every character in the string, along with the beginning\n-    /// and end of the string.\n-    ///\n-    /// ```\n-    /// let f: Vec<_> = \"rust\".split(\"\").collect();\n-    /// assert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n-    /// ```\n-    ///\n-    /// Contiguous separators can lead to possibly surprising behavior\n-    /// when whitespace is used as the separator. This code is correct:\n-    ///\n-    /// ```\n-    /// let x = \"    a  b c\".to_string();\n-    /// let d: Vec<_> = x.split(' ').collect();\n-    ///\n-    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// It does _not_ give you:\n-    ///\n-    /// ```,ignore\n-    /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n-    /// ```\n-    ///\n-    /// Use [`split_whitespace`] for this behavior.\n-    ///\n-    /// [`split_whitespace`]: #method.split_whitespace\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n-        core_str::StrExt::split(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by\n-    /// characters matched by a pattern and yielded in reverse order.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`split`] method can be used.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplit(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by\n-    /// characters matched by a pattern.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// Equivalent to [`split`], except that the trailing substring\n-    /// is skipped if empty.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// This method can be used for string data that is _terminated_,\n-    /// rather than _separated_ by a pattern.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rsplit_terminator`] method can be used.\n-    ///\n-    /// [`rsplit_terminator`]: #method.rsplit_terminator\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, [\"A\", \"B\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n-    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n-        core_str::StrExt::split_terminator(self, pat)\n-    }\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern and yielded in reverse order.\n-    ///\n-    /// The pattern can be a simple `&str`, [`char`], or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// Equivalent to [`split`], except that the trailing substring is\n-    /// skipped if empty.\n-    ///\n-    /// [`split`]: #method.split\n-    ///\n-    /// This method can be used for string data that is _terminated_,\n-    /// rather than _separated_ by a pattern.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a\n-    /// reverse search, and it will be double ended if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// For iterating from the front, the [`split_terminator`] method can be\n-    /// used.\n-    ///\n-    /// [`split_terminator`]: #method.split_terminator\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n-    /// assert_eq!(v, [\"B\", \"A\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n-    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplit_terminator(self, pat)\n-    }\n-\n-    /// An iterator over substrings of the given string slice, separated by a\n-    /// pattern, restricted to returning at most `n` items.\n-    ///\n-    /// If `n` substrings are returned, the last substring (the `n`th substring)\n-    /// will contain the remainder of the string.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will not be double ended, because it is\n-    /// not efficient to support.\n-    ///\n-    /// If the pattern allows a reverse search, the [`rsplitn`] method can be\n-    /// used.\n-    ///\n-    /// [`rsplitn`]: #method.rsplitn\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"abcXdef\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n-        core_str::StrExt::splitn(self, n, pat)\n-    }\n-\n-    /// An iterator over substrings of this string slice, separated by a\n-    /// pattern, starting from the end of the string, restricted to returning\n-    /// at most `n` items.\n-    ///\n-    /// If `n` substrings are returned, the last substring (the `n`th substring)\n-    /// will contain the remainder of the string.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines the split.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will not be double ended, because it is not\n-    /// efficient to support.\n-    ///\n-    /// For splitting from the front, the [`splitn`] method can be used.\n-    ///\n-    /// [`splitn`]: #method.splitn\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplitn(self, n, pat)\n-    }\n-\n-    /// An iterator over the disjoint matches of a pattern within the given string\n-    /// slice.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rmatches`] method can be used.\n-    ///\n-    /// [`rmatches`]: #method.rmatches\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n-    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n-    /// ```\n-    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n-    #[inline]\n-    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n-        core_str::StrExt::matches(self, pat)\n-    }\n+        let len = self.iter().map(|s| s.borrow().len()).sum();\n+        let mut result = String::with_capacity(len);\n \n-    /// An iterator over the disjoint matches of a pattern within this string slice,\n-    /// yielded in reverse order.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`matches`] method can be used.\n-    ///\n-    /// [`matches`]: #method.matches\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n-    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n-    /// ```\n-    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n-    #[inline]\n-    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rmatches(self, pat)\n-    }\n+        for s in self {\n+            result.push_str(s.borrow())\n+        }\n \n-    /// An iterator over the disjoint matches of a pattern within this string\n-    /// slice as well as the index that the match starts at.\n-    ///\n-    /// For matches of `pat` within `self` that overlap, only the indices\n-    /// corresponding to the first match are returned.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines\n-    /// if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n-    /// allows a reverse search and forward/reverse search yields the same\n-    /// elements. This is true for, eg, [`char`] but not for `&str`.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, the [`rmatch_indices`] method can be used.\n-    ///\n-    /// [`rmatch_indices`]: #method.rmatch_indices\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n-    /// ```\n-    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n-        core_str::StrExt::match_indices(self, pat)\n+        result\n     }\n \n-    /// An iterator over the disjoint matches of a pattern within `self`,\n-    /// yielded in reverse order along with the index of the match.\n-    ///\n-    /// For matches of `pat` within `self` that overlap, only the indices\n-    /// corresponding to the last match are returned.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if a\n-    /// character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n-    /// search yields the same elements.\n-    ///\n-    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-    ///\n-    /// For iterating from the front, the [`match_indices`] method can be used.\n-    ///\n-    /// [`match_indices`]: #method.match_indices\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n-    ///\n-    /// let v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\n-    /// assert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n-    /// ```\n-    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rmatch_indices(self, pat)\n-    }\n+    fn join(&self, sep: &str) -> String {\n+        if self.is_empty() {\n+            return String::new();\n+        }\n \n-    /// Returns a string slice with leading and trailing whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\"Hello\\tworld\", s.trim());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim(&self) -> &str {\n-        StrExt::trim(self)\n-    }\n+        // concat is faster\n+        if sep.is_empty() {\n+            return self.concat();\n+        }\n \n-    /// Returns a string slice with leading whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Left' in this context means the first\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _right_ side, not the left.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n-    /// ```\n-    ///\n-    /// Directionality:\n-    ///\n-    /// ```\n-    /// let s = \"  English\";\n-    /// assert!(Some('E') == s.trim_left().chars().next());\n-    ///\n-    /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea\";\n-    /// assert!(Some('\u05e2') == s.trim_left().chars().next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_left(&self) -> &str {\n-        StrExt::trim_left(self)\n-    }\n+        // this is wrong without the guarantee that `self` is non-empty\n+        // `len` calculation may overflow but push_str but will check boundaries\n+        let len = sep.len() * (self.len() - 1) +\n+                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n+        let mut result = String::with_capacity(len);\n+        let mut first = true;\n \n-    /// Returns a string slice with trailing whitespace removed.\n-    ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Right' in this context means the last\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _left_ side, not the right.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    ///\n-    /// assert_eq!(\" Hello\\tworld\", s.trim_right());\n-    /// ```\n-    ///\n-    /// Directionality:\n-    ///\n-    /// ```\n-    /// let s = \"English  \";\n-    /// assert!(Some('h') == s.trim_right().chars().rev().next());\n-    ///\n-    /// let s = \"\u05e2\u05d1\u05e8\u05d9\u05ea  \";\n-    /// assert!(Some('\u05ea') == s.trim_right().chars().rev().next());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_right(&self) -> &str {\n-        StrExt::trim_right(self)\n+        for s in self {\n+            if first {\n+                first = false;\n+            } else {\n+                result.push_str(sep);\n+            }\n+            result.push_str(s.borrow());\n+        }\n+        result\n     }\n \n-    /// Returns a string slice with all prefixes and suffixes that match a\n-    /// pattern repeatedly removed.\n-    ///\n-    /// The pattern can be a [`char`] or a closure that determines if a\n-    /// character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: DoubleEndedSearcher<'a>\n-    {\n-        core_str::StrExt::trim_matches(self, pat)\n+    fn connect(&self, sep: &str) -> String {\n+        self.join(sep)\n     }\n+}\n \n-    /// Returns a string slice with all prefixes that match a pattern\n-    /// repeatedly removed.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Left' in this context means the first\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _right_ side, not the left.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n-    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n-        core_str::StrExt::trim_left_matches(self, pat)\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Borrow<str> for String {\n+    #[inline]\n+    fn borrow(&self) -> &str {\n+        &self[..]\n     }\n+}\n \n-    /// Returns a string slice with all suffixes that match a pattern\n-    /// repeatedly removed.\n-    ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n-    ///\n-    /// [`char`]: primitive.char.html\n-    ///\n-    /// # Text directionality\n-    ///\n-    /// A string is a sequence of bytes. 'Right' in this context means the last\n-    /// position of that byte string; for a language like Arabic or Hebrew\n-    /// which are 'right to left' rather than 'left to right', this will be\n-    /// the _left_ side, not the right.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Simple patterns:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n-    ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// assert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::trim_right_matches(self, pat)\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ToOwned for str {\n+    type Owned = String;\n+    fn to_owned(&self) -> String {\n+        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n     }\n \n-    /// Parses this string slice into another type.\n-    ///\n-    /// Because `parse` is so general, it can cause problems with type\n-    /// inference. As such, `parse` is one of the few times you'll see\n-    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n-    /// helps the inference algorithm understand specifically which type\n-    /// you're trying to parse into.\n-    ///\n-    /// `parse` can parse any type that implements the [`FromStr`] trait.\n-    ///\n-    /// [`FromStr`]: str/trait.FromStr.html\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will return [`Err`] if it's not possible to parse this string slice into\n-    /// the desired type.\n-    ///\n-    /// [`Err`]: str/trait.FromStr.html#associatedtype.Err\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage\n-    ///\n-    /// ```\n-    /// let four: u32 = \"4\".parse().unwrap();\n-    ///\n-    /// assert_eq!(4, four);\n-    /// ```\n-    ///\n-    /// Using the 'turbofish' instead of annotating `four`:\n-    ///\n-    /// ```\n-    /// let four = \"4\".parse::<u32>();\n-    ///\n-    /// assert_eq!(Ok(4), four);\n-    /// ```\n-    ///\n-    /// Failing to parse:\n-    ///\n-    /// ```\n-    /// let nope = \"j\".parse::<u32>();\n-    ///\n-    /// assert!(nope.is_err());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n-        core_str::StrExt::parse(self)\n+    fn clone_into(&self, target: &mut String) {\n+        let mut b = mem::replace(target, String::new()).into_bytes();\n+        self.as_bytes().clone_into(&mut b);\n+        *target = unsafe { String::from_utf8_unchecked(b) }\n     }\n+}\n+\n+/// Methods for string slices.\n+#[cfg_attr(stage0, lang = \"str\")]\n+#[cfg_attr(not(stage0), lang = \"str_alloc\")]\n+#[cfg(not(test))]\n+impl str {\n+    #[cfg(stage0)]\n+    str_core_methods!();\n \n     /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n     ///\n@@ -2140,26 +491,6 @@ impl str {\n         unsafe { String::from_utf8_unchecked(buf) }\n     }\n \n-    /// Checks if all characters in this string are within the ASCII range.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let ascii = \"hello!\\n\";\n-    /// let non_ascii = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n-    ///\n-    /// assert!(ascii.is_ascii());\n-    /// assert!(!non_ascii.is_ascii());\n-    /// ```\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn is_ascii(&self) -> bool {\n-        // We can treat each byte as character here: all multibyte characters\n-        // start with a byte that is not in the ascii range, so we will stop\n-        // there already.\n-        self.bytes().all(|b| b.is_ascii())\n-    }\n-\n     /// Returns a copy of this string where each character is mapped to its\n     /// ASCII upper case equivalent.\n     ///\n@@ -2219,54 +550,6 @@ impl str {\n         // make_ascii_lowercase() preserves the UTF-8 invariant.\n         unsafe { String::from_utf8_unchecked(bytes) }\n     }\n-\n-    /// Checks that two strings are an ASCII case-insensitive match.\n-    ///\n-    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n-    /// but without allocating and copying temporaries.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\n-    /// assert!(\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00f6S\"));\n-    /// assert!(!\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00d6S\"));\n-    /// ```\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    #[inline]\n-    pub fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n-        self.as_bytes().eq_ignore_ascii_case(other.as_bytes())\n-    }\n-\n-    /// Converts this string to its ASCII upper case equivalent in-place.\n-    ///\n-    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n-    /// but non-ASCII letters are unchanged.\n-    ///\n-    /// To return a new uppercased value without modifying the existing one, use\n-    /// [`to_ascii_uppercase`].\n-    ///\n-    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    pub fn make_ascii_uppercase(&mut self) {\n-        let me = unsafe { self.as_bytes_mut() };\n-        me.make_ascii_uppercase()\n-    }\n-\n-    /// Converts this string to its ASCII lower case equivalent in-place.\n-    ///\n-    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n-    /// but non-ASCII letters are unchanged.\n-    ///\n-    /// To return a new lowercased value without modifying the existing one, use\n-    /// [`to_ascii_lowercase`].\n-    ///\n-    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n-    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n-    pub fn make_ascii_lowercase(&mut self) {\n-        let me = unsafe { self.as_bytes_mut() };\n-        me.make_ascii_lowercase()\n-    }\n }\n \n /// Converts a boxed slice of bytes to a boxed string slice without checking"}, {"sha": "b184404c15bfd6c050b99252db3c15e41b2d00a2", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -74,6 +74,7 @@ use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::marker::PhantomData;\n use core::mem;\n #[cfg(not(test))]\n+#[cfg(stage0)]\n use core::num::Float;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds};"}, {"sha": "58eef6492877a4b0d6430d614eb119498289a6ce", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -87,3 +87,16 @@ macro_rules! forward_ref_op_assign {\n     }\n }\n \n+#[cfg(stage0)]\n+macro_rules! public_in_stage0 {\n+    ( { $(#[$attr:meta])* } $($Item: tt)*) => {\n+        $(#[$attr])* pub $($Item)*\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! public_in_stage0 {\n+    ( { $(#[$attr:meta])* } $($Item: tt)*) => {\n+        $(#[$attr])* pub(crate) $($Item)*\n+    }\n+}"}, {"sha": "0e605f8dbe7d3e551e1ad954dc1dd4d7c397556d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -71,6 +71,7 @@\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n #![feature(const_fn)]\n+#![feature(core_float)]\n #![feature(custom_attribute)]\n #![feature(doc_cfg)]\n #![feature(doc_spotlight)]\n@@ -93,6 +94,8 @@\n #![feature(rustc_attrs)]\n #![feature(rustc_const_unstable)]\n #![feature(simd_ffi)]\n+#![feature(core_slice_ext)]\n+#![feature(core_str_ext)]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(stmt_expr_attributes)]\n@@ -229,7 +232,7 @@ macro_rules! test_v512 { ($item:item) => {}; }\n #[allow(unused_macros)]\n macro_rules! vector_impl { ($([$f:ident, $($args:tt)*]),*) => { $($f!($($args)*);)* } }\n #[path = \"../stdsimd/coresimd/mod.rs\"]\n-#[allow(missing_docs, missing_debug_implementations, dead_code)]\n+#[allow(missing_docs, missing_debug_implementations, dead_code, unused_imports)]\n #[unstable(feature = \"stdsimd\", issue = \"48556\")]\n #[cfg(not(stage0))] // allow changes to how stdsimd works in stage0\n mod coresimd;"}, {"sha": "8d5f6f601daf8a3c0eebc46cadc9124c7219700c", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 284, "deletions": 27, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -17,9 +17,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use intrinsics;\n use mem;\n use num::Float;\n+#[cfg(not(stage0))] use num::FpCategory;\n use num::FpCategory as Fp;\n \n /// The radix or base of the internal representation of `f32`.\n@@ -188,27 +188,6 @@ impl Float for f32 {\n         }\n     }\n \n-    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n-    /// number is `Float::nan()`.\n-    #[inline]\n-    fn abs(self) -> f32 {\n-        unsafe { intrinsics::fabsf32(self) }\n-    }\n-\n-    /// Returns a number that represents the sign of `self`.\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n-    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n-    /// - `Float::nan()` if the number is `Float::nan()`\n-    #[inline]\n-    fn signum(self) -> f32 {\n-        if self.is_nan() {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::copysignf32(1.0, self) }\n-        }\n-    }\n-\n     /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     #[inline]\n@@ -231,11 +210,6 @@ impl Float for f32 {\n         1.0 / self\n     }\n \n-    #[inline]\n-    fn powi(self, n: i32) -> f32 {\n-        unsafe { intrinsics::powif32(self, n) }\n-    }\n-\n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n     fn to_degrees(self) -> f32 {\n@@ -292,3 +266,286 @@ impl Float for f32 {\n         unsafe { mem::transmute(v) }\n     }\n }\n+\n+// FIXME: remove (inline) this macro and the Float trait\n+// when updating to a bootstrap compiler that has the new lang items.\n+#[cfg_attr(stage0, macro_export)]\n+#[unstable(feature = \"core_float\", issue = \"32110\")]\n+macro_rules! f32_core_methods { () => {\n+    /// Returns `true` if this value is `NaN` and false otherwise.\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    ///\n+    /// let nan = f32::NAN;\n+    /// let f = 7.0_f32;\n+    ///\n+    /// assert!(nan.is_nan());\n+    /// assert!(!f.is_nan());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_nan(self) -> bool { Float::is_nan(self) }\n+\n+    /// Returns `true` if this value is positive infinity or negative infinity and\n+    /// false otherwise.\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    ///\n+    /// let f = 7.0f32;\n+    /// let inf = f32::INFINITY;\n+    /// let neg_inf = f32::NEG_INFINITY;\n+    /// let nan = f32::NAN;\n+    ///\n+    /// assert!(!f.is_infinite());\n+    /// assert!(!nan.is_infinite());\n+    ///\n+    /// assert!(inf.is_infinite());\n+    /// assert!(neg_inf.is_infinite());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_infinite(self) -> bool { Float::is_infinite(self) }\n+\n+    /// Returns `true` if this number is neither infinite nor `NaN`.\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    ///\n+    /// let f = 7.0f32;\n+    /// let inf = f32::INFINITY;\n+    /// let neg_inf = f32::NEG_INFINITY;\n+    /// let nan = f32::NAN;\n+    ///\n+    /// assert!(f.is_finite());\n+    ///\n+    /// assert!(!nan.is_finite());\n+    /// assert!(!inf.is_finite());\n+    /// assert!(!neg_inf.is_finite());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_finite(self) -> bool { Float::is_finite(self) }\n+\n+    /// Returns `true` if the number is neither zero, infinite,\n+    /// [subnormal][subnormal], or `NaN`.\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    ///\n+    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n+    /// let max = f32::MAX;\n+    /// let lower_than_min = 1.0e-40_f32;\n+    /// let zero = 0.0_f32;\n+    ///\n+    /// assert!(min.is_normal());\n+    /// assert!(max.is_normal());\n+    ///\n+    /// assert!(!zero.is_normal());\n+    /// assert!(!f32::NAN.is_normal());\n+    /// assert!(!f32::INFINITY.is_normal());\n+    /// // Values between `0` and `min` are Subnormal.\n+    /// assert!(!lower_than_min.is_normal());\n+    /// ```\n+    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_normal(self) -> bool { Float::is_normal(self) }\n+\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n+    ///\n+    /// ```\n+    /// use std::num::FpCategory;\n+    /// use std::f32;\n+    ///\n+    /// let num = 12.4_f32;\n+    /// let inf = f32::INFINITY;\n+    ///\n+    /// assert_eq!(num.classify(), FpCategory::Normal);\n+    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn classify(self) -> FpCategory { Float::classify(self) }\n+\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n+    ///\n+    /// ```\n+    /// let f = 7.0_f32;\n+    /// let g = -7.0_f32;\n+    ///\n+    /// assert!(f.is_sign_positive());\n+    /// assert!(!g.is_sign_positive());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_sign_positive(self) -> bool { Float::is_sign_positive(self) }\n+\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n+    ///\n+    /// ```\n+    /// let f = 7.0f32;\n+    /// let g = -7.0f32;\n+    ///\n+    /// assert!(!f.is_sign_negative());\n+    /// assert!(g.is_sign_negative());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_sign_negative(self) -> bool { Float::is_sign_negative(self) }\n+\n+    /// Takes the reciprocal (inverse) of a number, `1/x`.\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    ///\n+    /// let x = 2.0_f32;\n+    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    ///\n+    /// assert!(abs_difference <= f32::EPSILON);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn recip(self) -> f32 { Float::recip(self) }\n+\n+    /// Converts radians to degrees.\n+    ///\n+    /// ```\n+    /// use std::f32::{self, consts};\n+    ///\n+    /// let angle = consts::PI;\n+    ///\n+    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n+    ///\n+    /// assert!(abs_difference <= f32::EPSILON);\n+    /// ```\n+    #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n+    #[inline]\n+    pub fn to_degrees(self) -> f32 { Float::to_degrees(self) }\n+\n+    /// Converts degrees to radians.\n+    ///\n+    /// ```\n+    /// use std::f32::{self, consts};\n+    ///\n+    /// let angle = 180.0f32;\n+    ///\n+    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n+    ///\n+    /// assert!(abs_difference <= f32::EPSILON);\n+    /// ```\n+    #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n+    #[inline]\n+    pub fn to_radians(self) -> f32 { Float::to_radians(self) }\n+\n+    /// Returns the maximum of the two numbers.\n+    ///\n+    /// ```\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n+    ///\n+    /// assert_eq!(x.max(y), y);\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn max(self, other: f32) -> f32 {\n+        Float::max(self, other)\n+    }\n+\n+    /// Returns the minimum of the two numbers.\n+    ///\n+    /// ```\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n+    ///\n+    /// assert_eq!(x.min(y), x);\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn min(self, other: f32) -> f32 {\n+        Float::min(self, other)\n+    }\n+\n+    /// Raw transmutation to `u32`.\n+    ///\n+    /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms.\n+    ///\n+    /// See `from_bits` for some discussion of the portability of this operation\n+    /// (there are almost no issues).\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_ne!((1f32).to_bits(), 1f32 as u32); // to_bits() is not casting!\n+    /// assert_eq!((12.5f32).to_bits(), 0x41480000);\n+    ///\n+    /// ```\n+    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn to_bits(self) -> u32 {\n+        Float::to_bits(self)\n+    }\n+\n+    /// Raw transmutation from `u32`.\n+    ///\n+    /// This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n+    /// It turns out this is incredibly portable, for two reasons:\n+    ///\n+    /// * Floats and Ints have the same endianness on all supported platforms.\n+    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    ///\n+    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n+    /// (notably x86 and ARM) picked the interpretation that was ultimately\n+    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n+    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n+    ///\n+    /// Rather than trying to preserve signaling-ness cross-platform, this\n+    /// implementation favours preserving the exact bits. This means that\n+    /// any payloads encoded in NaNs will be preserved even if the result of\n+    /// this method is sent over the network from an x86 machine to a MIPS one.\n+    ///\n+    /// If the results of this method are only manipulated by the same\n+    /// architecture that produced them, then there is no portability concern.\n+    ///\n+    /// If the input isn't NaN, then there is no portability concern.\n+    ///\n+    /// If you don't care about signalingness (very likely), then there is no\n+    /// portability concern.\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::f32;\n+    /// let v = f32::from_bits(0x41480000);\n+    /// let difference = (v - 12.5).abs();\n+    /// assert!(difference <= 1e-5);\n+    /// ```\n+    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn from_bits(v: u32) -> Self {\n+        Float::from_bits(v)\n+    }\n+}}\n+\n+#[lang = \"f32\"]\n+#[cfg(not(test))]\n+#[cfg(not(stage0))]\n+impl f32 {\n+    f32_core_methods!();\n+}"}, {"sha": "08b869734d49627099a649553567dd660159b4ca", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 295, "deletions": 28, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -17,10 +17,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use intrinsics;\n use mem;\n-use num::FpCategory as Fp;\n use num::Float;\n+#[cfg(not(stage0))] use num::FpCategory;\n+use num::FpCategory as Fp;\n \n /// The radix or base of the internal representation of `f64`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -188,27 +188,6 @@ impl Float for f64 {\n         }\n     }\n \n-    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n-    /// number is `Float::nan()`.\n-    #[inline]\n-    fn abs(self) -> f64 {\n-        unsafe { intrinsics::fabsf64(self) }\n-    }\n-\n-    /// Returns a number that represents the sign of `self`.\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n-    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n-    /// - `Float::nan()` if the number is `Float::nan()`\n-    #[inline]\n-    fn signum(self) -> f64 {\n-        if self.is_nan() {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::copysignf64(1.0, self) }\n-        }\n-    }\n-\n     /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     #[inline]\n@@ -229,11 +208,6 @@ impl Float for f64 {\n         1.0 / self\n     }\n \n-    #[inline]\n-    fn powi(self, n: i32) -> f64 {\n-        unsafe { intrinsics::powif64(self, n) }\n-    }\n-\n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n     fn to_degrees(self) -> f64 {\n@@ -291,3 +265,296 @@ impl Float for f64 {\n         unsafe { mem::transmute(v) }\n     }\n }\n+\n+// FIXME: remove (inline) this macro and the Float trait\n+// when updating to a bootstrap compiler that has the new lang items.\n+#[cfg_attr(stage0, macro_export)]\n+#[unstable(feature = \"core_float\", issue = \"32110\")]\n+macro_rules! f64_core_methods { () => {\n+    /// Returns `true` if this value is `NaN` and false otherwise.\n+    ///\n+    /// ```\n+    /// use std::f64;\n+    ///\n+    /// let nan = f64::NAN;\n+    /// let f = 7.0_f64;\n+    ///\n+    /// assert!(nan.is_nan());\n+    /// assert!(!f.is_nan());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_nan(self) -> bool { Float::is_nan(self) }\n+\n+    /// Returns `true` if this value is positive infinity or negative infinity and\n+    /// false otherwise.\n+    ///\n+    /// ```\n+    /// use std::f64;\n+    ///\n+    /// let f = 7.0f64;\n+    /// let inf = f64::INFINITY;\n+    /// let neg_inf = f64::NEG_INFINITY;\n+    /// let nan = f64::NAN;\n+    ///\n+    /// assert!(!f.is_infinite());\n+    /// assert!(!nan.is_infinite());\n+    ///\n+    /// assert!(inf.is_infinite());\n+    /// assert!(neg_inf.is_infinite());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_infinite(self) -> bool { Float::is_infinite(self) }\n+\n+    /// Returns `true` if this number is neither infinite nor `NaN`.\n+    ///\n+    /// ```\n+    /// use std::f64;\n+    ///\n+    /// let f = 7.0f64;\n+    /// let inf: f64 = f64::INFINITY;\n+    /// let neg_inf: f64 = f64::NEG_INFINITY;\n+    /// let nan: f64 = f64::NAN;\n+    ///\n+    /// assert!(f.is_finite());\n+    ///\n+    /// assert!(!nan.is_finite());\n+    /// assert!(!inf.is_finite());\n+    /// assert!(!neg_inf.is_finite());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_finite(self) -> bool { Float::is_finite(self) }\n+\n+    /// Returns `true` if the number is neither zero, infinite,\n+    /// [subnormal][subnormal], or `NaN`.\n+    ///\n+    /// ```\n+    /// use std::f64;\n+    ///\n+    /// let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308f64\n+    /// let max = f64::MAX;\n+    /// let lower_than_min = 1.0e-308_f64;\n+    /// let zero = 0.0f64;\n+    ///\n+    /// assert!(min.is_normal());\n+    /// assert!(max.is_normal());\n+    ///\n+    /// assert!(!zero.is_normal());\n+    /// assert!(!f64::NAN.is_normal());\n+    /// assert!(!f64::INFINITY.is_normal());\n+    /// // Values between `0` and `min` are Subnormal.\n+    /// assert!(!lower_than_min.is_normal());\n+    /// ```\n+    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_normal(self) -> bool { Float::is_normal(self) }\n+\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n+    ///\n+    /// ```\n+    /// use std::num::FpCategory;\n+    /// use std::f64;\n+    ///\n+    /// let num = 12.4_f64;\n+    /// let inf = f64::INFINITY;\n+    ///\n+    /// assert_eq!(num.classify(), FpCategory::Normal);\n+    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn classify(self) -> FpCategory { Float::classify(self) }\n+\n+    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// positive sign bit and positive infinity.\n+    ///\n+    /// ```\n+    /// let f = 7.0_f64;\n+    /// let g = -7.0_f64;\n+    ///\n+    /// assert!(f.is_sign_positive());\n+    /// assert!(!g.is_sign_positive());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_sign_positive(self) -> bool { Float::is_sign_positive(self) }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n+    #[inline]\n+    #[doc(hidden)]\n+    pub fn is_positive(self) -> bool { Float::is_sign_positive(self) }\n+\n+    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// negative sign bit and negative infinity.\n+    ///\n+    /// ```\n+    /// let f = 7.0_f64;\n+    /// let g = -7.0_f64;\n+    ///\n+    /// assert!(!f.is_sign_negative());\n+    /// assert!(g.is_sign_negative());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_sign_negative(self) -> bool { Float::is_sign_negative(self) }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n+    #[inline]\n+    #[doc(hidden)]\n+    pub fn is_negative(self) -> bool { Float::is_sign_negative(self) }\n+\n+    /// Takes the reciprocal (inverse) of a number, `1/x`.\n+    ///\n+    /// ```\n+    /// let x = 2.0_f64;\n+    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn recip(self) -> f64 { Float::recip(self) }\n+\n+    /// Converts radians to degrees.\n+    ///\n+    /// ```\n+    /// use std::f64::consts;\n+    ///\n+    /// let angle = consts::PI;\n+    ///\n+    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn to_degrees(self) -> f64 { Float::to_degrees(self) }\n+\n+    /// Converts degrees to radians.\n+    ///\n+    /// ```\n+    /// use std::f64::consts;\n+    ///\n+    /// let angle = 180.0_f64;\n+    ///\n+    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn to_radians(self) -> f64 { Float::to_radians(self) }\n+\n+    /// Returns the maximum of the two numbers.\n+    ///\n+    /// ```\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n+    ///\n+    /// assert_eq!(x.max(y), y);\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn max(self, other: f64) -> f64 {\n+        Float::max(self, other)\n+    }\n+\n+    /// Returns the minimum of the two numbers.\n+    ///\n+    /// ```\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n+    ///\n+    /// assert_eq!(x.min(y), x);\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn min(self, other: f64) -> f64 {\n+        Float::min(self, other)\n+    }\n+\n+    /// Raw transmutation to `u64`.\n+    ///\n+    /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms.\n+    ///\n+    /// See `from_bits` for some discussion of the portability of this operation\n+    /// (there are almost no issues).\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!((1f64).to_bits() != 1f64 as u64); // to_bits() is not casting!\n+    /// assert_eq!((12.5f64).to_bits(), 0x4029000000000000);\n+    ///\n+    /// ```\n+    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn to_bits(self) -> u64 {\n+        Float::to_bits(self)\n+    }\n+\n+    /// Raw transmutation from `u64`.\n+    ///\n+    /// This is currently identical to `transmute::<u64, f64>(v)` on all platforms.\n+    /// It turns out this is incredibly portable, for two reasons:\n+    ///\n+    /// * Floats and Ints have the same endianness on all supported platforms.\n+    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    ///\n+    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n+    /// (notably x86 and ARM) picked the interpretation that was ultimately\n+    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n+    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n+    ///\n+    /// Rather than trying to preserve signaling-ness cross-platform, this\n+    /// implementation favours preserving the exact bits. This means that\n+    /// any payloads encoded in NaNs will be preserved even if the result of\n+    /// this method is sent over the network from an x86 machine to a MIPS one.\n+    ///\n+    /// If the results of this method are only manipulated by the same\n+    /// architecture that produced them, then there is no portability concern.\n+    ///\n+    /// If the input isn't NaN, then there is no portability concern.\n+    ///\n+    /// If you don't care about signalingness (very likely), then there is no\n+    /// portability concern.\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::f64;\n+    /// let v = f64::from_bits(0x4029000000000000);\n+    /// let difference = (v - 12.5).abs();\n+    /// assert!(difference <= 1e-5);\n+    /// ```\n+    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn from_bits(v: u64) -> Self {\n+        Float::from_bits(v)\n+    }\n+}}\n+\n+#[lang = \"f64\"]\n+#[cfg(not(test))]\n+#[cfg(not(stage0))]\n+impl f64 {\n+    f64_core_methods!();\n+}"}, {"sha": "aa4d4bc638b1d236d9f3752a2020e999aaa41684", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 12, "deletions": 37, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -4098,83 +4098,58 @@ pub enum FpCategory {\n     Normal,\n }\n \n-/// A built-in floating point number.\n+// Technically private and only exposed for coretests:\n #[doc(hidden)]\n-#[unstable(feature = \"core_float\",\n-           reason = \"stable interface is via `impl f{32,64}` in later crates\",\n-           issue = \"32110\")]\n+#[unstable(feature = \"float_internals\",\n+           reason = \"internal routines only exposed for testing\",\n+           issue = \"0\")]\n pub trait Float: Sized {\n     /// Type used by `to_bits` and `from_bits`.\n-    #[stable(feature = \"core_float_bits\", since = \"1.25.0\")]\n     type Bits;\n \n     /// Returns `true` if this value is NaN and false otherwise.\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_nan(self) -> bool;\n+\n     /// Returns `true` if this value is positive infinity or negative infinity and\n     /// false otherwise.\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_infinite(self) -> bool;\n+\n     /// Returns `true` if this number is neither infinite nor NaN.\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_finite(self) -> bool;\n+\n     /// Returns `true` if this number is neither zero, infinite, denormal, or NaN.\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_normal(self) -> bool;\n+\n     /// Returns the category that this number falls into.\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn classify(self) -> FpCategory;\n \n-    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n-    /// number is `Float::nan()`.\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn abs(self) -> Self;\n-    /// Returns a number that represents the sign of `self`.\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n-    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n-    /// - `Float::nan()` if the number is `Float::nan()`\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn signum(self) -> Self;\n-\n     /// Returns `true` if `self` is positive, including `+0.0` and\n     /// `Float::infinity()`.\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_sign_positive(self) -> bool;\n+\n     /// Returns `true` if `self` is negative, including `-0.0` and\n     /// `Float::neg_infinity()`.\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_sign_negative(self) -> bool;\n \n     /// Take the reciprocal (inverse) of a number, `1/x`.\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn recip(self) -> Self;\n \n-    /// Raise a number to an integer power.\n-    ///\n-    /// Using this function is generally faster than using `powf`\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn powi(self, n: i32) -> Self;\n-\n     /// Convert radians to degrees.\n-    #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n     fn to_degrees(self) -> Self;\n+\n     /// Convert degrees to radians.\n-    #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n     fn to_radians(self) -> Self;\n \n     /// Returns the maximum of the two numbers.\n-    #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n     fn max(self, other: Self) -> Self;\n+\n     /// Returns the minimum of the two numbers.\n-    #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n     fn min(self, other: Self) -> Self;\n \n     /// Raw transmutation to integer.\n-    #[stable(feature = \"core_float_bits\", since=\"1.25.0\")]\n     fn to_bits(self) -> Self::Bits;\n+\n     /// Raw transmutation from integer.\n-    #[stable(feature = \"core_float_bits\", since=\"1.25.0\")]\n     fn from_bits(v: Self::Bits) -> Self;\n }\n "}, {"sha": "8212648f2d8fb308f054ea49e2f94b9c70eb9250", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -58,7 +58,9 @@ pub use result::Result::{self, Ok, Err};\n // Re-exported extension traits for primitive types\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n+#[cfg(stage0)]\n pub use slice::SliceExt;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n+#[cfg(stage0)]\n pub use str::StrExt;"}, {"sha": "cc42acd77aed1c29b6ed847b4cbc53e344d15fcb", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1474, "deletions": 2, "changes": 1476, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -68,12 +68,15 @@ struct Repr<T> {\n // Extension traits\n //\n \n+public_in_stage0! {\n+{\n /// Extension methods for slices.\n #[unstable(feature = \"core_slice_ext\",\n            reason = \"stable interface provided by `impl [T]` in later crates\",\n            issue = \"32110\")]\n #[allow(missing_docs)] // documented elsewhere\n-pub trait SliceExt {\n+}\n+trait SliceExt {\n     type Item;\n \n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -238,7 +241,7 @@ pub trait SliceExt {\n     fn sort_unstable_by_key<B, F>(&mut self, f: F)\n         where F: FnMut(&Self::Item) -> B,\n               B: Ord;\n-}\n+}}\n \n // Use macros to be generic over const/mut\n macro_rules! slice_offset {\n@@ -755,6 +758,1475 @@ impl<T> SliceExt for [T] {\n     }\n }\n \n+// FIXME: remove (inline) this macro and the SliceExt trait\n+// when updating to a bootstrap compiler that has the new lang items.\n+#[cfg_attr(stage0, macro_export)]\n+#[unstable(feature = \"core_slice_ext\", issue = \"32110\")]\n+macro_rules! slice_core_methods { () => {\n+    /// Returns the number of elements in the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        SliceExt::len(self)\n+    }\n+\n+    /// Returns `true` if the slice has a length of 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        SliceExt::is_empty(self)\n+    }\n+\n+    /// Returns the first element of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&10), v.first());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(None, w.first());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn first(&self) -> Option<&T> {\n+        SliceExt::first(self)\n+    }\n+\n+    /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(first) = x.first_mut() {\n+    ///     *first = 5;\n+    /// }\n+    /// assert_eq!(x, &[5, 1, 2]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn first_mut(&mut self) -> Option<&mut T> {\n+        SliceExt::first_mut(self)\n+    }\n+\n+    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[0, 1, 2];\n+    ///\n+    /// if let Some((first, elements)) = x.split_first() {\n+    ///     assert_eq!(first, &0);\n+    ///     assert_eq!(elements, &[1, 2]);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn split_first(&self) -> Option<(&T, &[T])> {\n+        SliceExt::split_first(self)\n+    }\n+\n+    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some((first, elements)) = x.split_first_mut() {\n+    ///     *first = 3;\n+    ///     elements[0] = 4;\n+    ///     elements[1] = 5;\n+    /// }\n+    /// assert_eq!(x, &[3, 4, 5]);\n+    /// ```\n+    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n+        SliceExt::split_first_mut(self)\n+    }\n+\n+    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[0, 1, 2];\n+    ///\n+    /// if let Some((last, elements)) = x.split_last() {\n+    ///     assert_eq!(last, &2);\n+    ///     assert_eq!(elements, &[0, 1]);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn split_last(&self) -> Option<(&T, &[T])> {\n+        SliceExt::split_last(self)\n+\n+    }\n+\n+    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some((last, elements)) = x.split_last_mut() {\n+    ///     *last = 3;\n+    ///     elements[0] = 4;\n+    ///     elements[1] = 5;\n+    /// }\n+    /// assert_eq!(x, &[4, 5, 3]);\n+    /// ```\n+    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n+        SliceExt::split_last_mut(self)\n+    }\n+\n+    /// Returns the last element of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&30), v.last());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(None, w.last());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn last(&self) -> Option<&T> {\n+        SliceExt::last(self)\n+    }\n+\n+    /// Returns a mutable pointer to the last item in the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(last) = x.last_mut() {\n+    ///     *last = 10;\n+    /// }\n+    /// assert_eq!(x, &[0, 1, 10]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn last_mut(&mut self) -> Option<&mut T> {\n+        SliceExt::last_mut(self)\n+    }\n+\n+    /// Returns a reference to an element or subslice depending on the type of\n+    /// index.\n+    ///\n+    /// - If given a position, returns a reference to the element at that\n+    ///   position or `None` if out of bounds.\n+    /// - If given a range, returns the subslice corresponding to that range,\n+    ///   or `None` if out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&40), v.get(1));\n+    /// assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n+    /// assert_eq!(None, v.get(3));\n+    /// assert_eq!(None, v.get(0..4));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n+        where I: SliceIndex<Self>\n+    {\n+        SliceExt::get(self, index)\n+    }\n+\n+    /// Returns a mutable reference to an element or subslice depending on the\n+    /// type of index (see [`get`]) or `None` if the index is out of bounds.\n+    ///\n+    /// [`get`]: #method.get\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(elem) = x.get_mut(1) {\n+    ///     *elem = 42;\n+    /// }\n+    /// assert_eq!(x, &[0, 42, 2]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n+        where I: SliceIndex<Self>\n+    {\n+        SliceExt::get_mut(self, index)\n+    }\n+\n+    /// Returns a reference to an element or subslice, without doing bounds\n+    /// checking.\n+    ///\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`get`].\n+    ///\n+    /// [`get`]: #method.get\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[1, 2, 4];\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(x.get_unchecked(1), &2);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<Self>\n+    {\n+        SliceExt::get_unchecked(self, index)\n+    }\n+\n+    /// Returns a mutable reference to an element or subslice, without doing\n+    /// bounds checking.\n+    ///\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`get_mut`].\n+    ///\n+    /// [`get_mut`]: #method.get_mut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [1, 2, 4];\n+    ///\n+    /// unsafe {\n+    ///     let elem = x.get_unchecked_mut(1);\n+    ///     *elem = 13;\n+    /// }\n+    /// assert_eq!(x, &[1, 13, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n+        where I: SliceIndex<Self>\n+    {\n+        SliceExt::get_unchecked_mut(self, index)\n+    }\n+\n+    /// Returns a raw pointer to the slice's buffer.\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the container referenced by this slice may cause its buffer\n+    /// to be reallocated, which would also make any pointers to it invalid.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[1, 2, 4];\n+    /// let x_ptr = x.as_ptr();\n+    ///\n+    /// unsafe {\n+    ///     for i in 0..x.len() {\n+    ///         assert_eq!(x.get_unchecked(i), &*x_ptr.offset(i as isize));\n+    ///     }\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const T {\n+        SliceExt::as_ptr(self)\n+    }\n+\n+    /// Returns an unsafe mutable pointer to the slice's buffer.\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the container referenced by this slice may cause its buffer\n+    /// to be reallocated, which would also make any pointers to it invalid.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [1, 2, 4];\n+    /// let x_ptr = x.as_mut_ptr();\n+    ///\n+    /// unsafe {\n+    ///     for i in 0..x.len() {\n+    ///         *x_ptr.offset(i as isize) += 2;\n+    ///     }\n+    /// }\n+    /// assert_eq!(x, &[3, 4, 6]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        SliceExt::as_mut_ptr(self)\n+    }\n+\n+    /// Swaps two elements in the slice.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `a` or `b` are out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn swap(&mut self, a: usize, b: usize) {\n+        SliceExt::swap(self, a, b)\n+    }\n+\n+    /// Reverses the order of elements in the slice, in place.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [1, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3, 2, 1]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn reverse(&mut self) {\n+        SliceExt::reverse(self)\n+    }\n+\n+    /// Returns an iterator over the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[1, 2, 4];\n+    /// let mut iterator = x.iter();\n+    ///\n+    /// assert_eq!(iterator.next(), Some(&1));\n+    /// assert_eq!(iterator.next(), Some(&2));\n+    /// assert_eq!(iterator.next(), Some(&4));\n+    /// assert_eq!(iterator.next(), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn iter(&self) -> Iter<T> {\n+        SliceExt::iter(self)\n+    }\n+\n+    /// Returns an iterator that allows modifying each value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [1, 2, 4];\n+    /// for elem in x.iter_mut() {\n+    ///     *elem += 2;\n+    /// }\n+    /// assert_eq!(x, &[3, 4, 6]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn iter_mut(&mut self) -> IterMut<T> {\n+        SliceExt::iter_mut(self)\n+    }\n+\n+    /// Returns an iterator over all contiguous windows of length\n+    /// `size`. The windows overlap. If the slice is shorter than\n+    /// `size`, the iterator returns no values.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let slice = ['r', 'u', 's', 't'];\n+    /// let mut iter = slice.windows(2);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'u']);\n+    /// assert_eq!(iter.next().unwrap(), &['u', 's']);\n+    /// assert_eq!(iter.next().unwrap(), &['s', 't']);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If the slice is shorter than `size`:\n+    ///\n+    /// ```\n+    /// let slice = ['f', 'o', 'o'];\n+    /// let mut iter = slice.windows(4);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn windows(&self, size: usize) -> Windows<T> {\n+        SliceExt::windows(self, size)\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a\n+    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will\n+    /// not have length `chunk_size`.\n+    ///\n+    /// See [`exact_chunks`] for a variant of this iterator that returns chunks\n+    /// of always exactly `chunk_size` elements.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.chunks(2);\n+    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n+    /// assert_eq!(iter.next().unwrap(), &['m']);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// [`exact_chunks`]: #method.exact_chunks\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n+        SliceExt::chunks(self, chunk_size)\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a\n+    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last up to `chunk_size-1`\n+    /// elements will be omitted.\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n+    /// can often optimize the resulting code better than in the case of\n+    /// [`chunks`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exact_chunks)]\n+    ///\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.exact_chunks(2);\n+    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// [`chunks`]: #method.chunks\n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[inline]\n+    pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n+        SliceExt::exact_chunks(self, chunk_size)\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will not\n+    /// have length `chunk_size`.\n+    ///\n+    /// See [`exact_chunks_mut`] for a variant of this iterator that returns chunks\n+    /// of always exactly `chunk_size` elements.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.chunks_mut(2) {\n+    ///     for elem in chunk.iter_mut() {\n+    ///         *elem += count;\n+    ///     }\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n+    /// ```\n+    ///\n+    /// [`exact_chunks_mut`]: #method.exact_chunks_mut\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n+        SliceExt::chunks_mut(self, chunk_size)\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last up to `chunk_size-1`\n+    /// elements will be omitted.\n+    ///\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n+    /// can often optimize the resulting code better than in the case of\n+    /// [`chunks_mut`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exact_chunks)]\n+    ///\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.exact_chunks_mut(2) {\n+    ///     for elem in chunk.iter_mut() {\n+    ///         *elem += count;\n+    ///     }\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n+    /// ```\n+    ///\n+    /// [`chunks_mut`]: #method.chunks_mut\n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[inline]\n+    pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n+        SliceExt::exact_chunks_mut(self, chunk_size)\n+    }\n+\n+    /// Divides one slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [1, 2, 3, 4, 5, 6];\n+    ///\n+    /// {\n+    ///    let (left, right) = v.split_at(0);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at(2);\n+    ///     assert!(left == [1, 2]);\n+    ///     assert!(right == [3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at(6);\n+    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n+        SliceExt::split_at(self, mid)\n+    }\n+\n+    /// Divides one mutable slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [1, 0, 3, 0, 5, 6];\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(2);\n+    ///     assert!(left == [1, 0]);\n+    ///     assert!(right == [3, 0, 5, 6]);\n+    ///     left[1] = 2;\n+    ///     right[1] = 4;\n+    /// }\n+    /// assert!(v == [1, 2, 3, 4, 5, 6]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+        SliceExt::split_at_mut(self, mid)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`. The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let slice = [10, 40, 33, 20];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If the first element is matched, an empty slice will be the first item\n+    /// returned by the iterator. Similarly, if the last element in the slice\n+    /// is matched, an empty slice will be the last item returned by the\n+    /// iterator:\n+    ///\n+    /// ```\n+    /// let slice = [10, 40, 33];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n+    /// assert_eq!(iter.next().unwrap(), &[]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If two matched elements are directly adjacent, an empty slice will be\n+    /// present between them:\n+    ///\n+    /// ```\n+    /// let slice = [10, 6, 33, 20];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10]);\n+    /// assert_eq!(iter.next().unwrap(), &[]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split<F>(&self, pred: F) -> Split<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::split(self, pred)\n+    }\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`. The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.split_mut(|num| *num % 3 == 0) {\n+    ///     group[0] = 1;\n+    /// }\n+    /// assert_eq!(v, [1, 40, 30, 1, 60, 1]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::split_mut(self, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, starting at the end of the slice and working backwards.\n+    /// The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let slice = [11, 22, 33, 0, 44, 55];\n+    /// let mut iter = slice.rsplit(|num| *num == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[44, 55]);\n+    /// assert_eq!(iter.next().unwrap(), &[11, 22, 33]);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// As with `split()`, if the first or last element is matched, an empty\n+    /// slice will be the first (or last) item returned by the iterator.\n+    ///\n+    /// ```\n+    /// let v = &[0, 1, 1, 2, 3, 5, 8];\n+    /// let mut it = v.rsplit(|n| *n % 2 == 0);\n+    /// assert_eq!(it.next().unwrap(), &[]);\n+    /// assert_eq!(it.next().unwrap(), &[3, 5]);\n+    /// assert_eq!(it.next().unwrap(), &[1, 1]);\n+    /// assert_eq!(it.next().unwrap(), &[]);\n+    /// assert_eq!(it.next(), None);\n+    /// ```\n+    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+    #[inline]\n+    pub fn rsplit<F>(&self, pred: F) -> RSplit<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::rsplit(self, pred)\n+    }\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`, starting at the end of the slice and working\n+    /// backwards. The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [100, 400, 300, 200, 600, 500];\n+    ///\n+    /// let mut count = 0;\n+    /// for group in v.rsplit_mut(|num| *num % 3 == 0) {\n+    ///     count += 1;\n+    ///     group[0] = count;\n+    /// }\n+    /// assert_eq!(v, [3, 400, 300, 2, 600, 1]);\n+    /// ```\n+    ///\n+    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+    #[inline]\n+    pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::rsplit_mut(self, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to returning at most `n` items. The matched element is\n+    /// not contained in the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n+    /// `[20, 60, 50]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::splitn(self, n, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to returning at most `n` items. The matched element is\n+    /// not contained in the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.splitn_mut(2, |num| *num % 3 == 0) {\n+    ///     group[0] = 1;\n+    /// }\n+    /// assert_eq!(v, [1, 40, 30, 1, 60, 50]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::splitn_mut(self, n, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to returning at most `n` items. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split once, starting from the end, by numbers divisible\n+    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::rsplitn(self, n, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to returning at most `n` items. This starts at the end of\n+    /// the slice and works backwards. The matched element is not contained in\n+    /// the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut s = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in s.rsplitn_mut(2, |num| *num % 3 == 0) {\n+    ///     group[0] = 1;\n+    /// }\n+    /// assert_eq!(s, [1, 40, 30, 20, 60, 1]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::rsplitn_mut(self, n, pred)\n+    }\n+\n+    /// Returns `true` if the slice contains an element with the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.contains(&30));\n+    /// assert!(!v.contains(&50));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn contains(&self, x: &T) -> bool\n+        where T: PartialEq\n+    {\n+        SliceExt::contains(self, x)\n+    }\n+\n+    /// Returns `true` if `needle` is a prefix of the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.starts_with(&[10]));\n+    /// assert!(v.starts_with(&[10, 40]));\n+    /// assert!(!v.starts_with(&[50]));\n+    /// assert!(!v.starts_with(&[10, 50]));\n+    /// ```\n+    ///\n+    /// Always returns `true` if `needle` is an empty slice:\n+    ///\n+    /// ```\n+    /// let v = &[10, 40, 30];\n+    /// assert!(v.starts_with(&[]));\n+    /// let v: &[u8] = &[];\n+    /// assert!(v.starts_with(&[]));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn starts_with(&self, needle: &[T]) -> bool\n+        where T: PartialEq\n+    {\n+        SliceExt::starts_with(self, needle)\n+    }\n+\n+    /// Returns `true` if `needle` is a suffix of the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.ends_with(&[30]));\n+    /// assert!(v.ends_with(&[40, 30]));\n+    /// assert!(!v.ends_with(&[50]));\n+    /// assert!(!v.ends_with(&[50, 30]));\n+    /// ```\n+    ///\n+    /// Always returns `true` if `needle` is an empty slice:\n+    ///\n+    /// ```\n+    /// let v = &[10, 40, 30];\n+    /// assert!(v.ends_with(&[]));\n+    /// let v: &[u8] = &[];\n+    /// assert!(v.ends_with(&[]));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn ends_with(&self, needle: &[T]) -> bool\n+        where T: PartialEq\n+    {\n+        SliceExt::ends_with(self, needle)\n+    }\n+\n+    /// Binary searches this sorted slice for a given element.\n+    ///\n+    /// If the value is found then `Ok` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    ///\n+    /// assert_eq!(s.binary_search(&13),  Ok(9));\n+    /// assert_eq!(s.binary_search(&4),   Err(7));\n+    /// assert_eq!(s.binary_search(&100), Err(13));\n+    /// let r = s.binary_search(&1);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n+        where T: Ord\n+    {\n+        SliceExt::binary_search(self, x)\n+    }\n+\n+    /// Binary searches this sorted slice with a comparator function.\n+    ///\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying slice, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` the desired target.\n+    ///\n+    /// If a matching value is found then returns `Ok`, containing\n+    /// the index for the matched element; if no match is found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    ///\n+    /// let seek = 13;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n+    /// let seek = 4;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n+    /// let seek = 100;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n+    /// let seek = 1;\n+    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n+        where F: FnMut(&'a T) -> Ordering\n+    {\n+        SliceExt::binary_search_by(self, f)\n+    }\n+\n+    /// Binary searches this sorted slice with a key extraction function.\n+    ///\n+    /// Assumes that the slice is sorted by the key, for instance with\n+    /// [`sort_by_key`] using the same key extraction function.\n+    ///\n+    /// If a matching value is found then returns `Ok`, containing the\n+    /// index for the matched element; if no match is found then `Err`\n+    /// is returned, containing the index where a matching element could\n+    /// be inserted while maintaining sorted order.\n+    ///\n+    /// [`sort_by_key`]: #method.sort_by_key\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements in a slice of pairs sorted by\n+    /// their second elements. The first is found, with a uniquely\n+    /// determined position; the second and third are not found; the\n+    /// fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n+    ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n+    ///          (1, 21), (2, 34), (4, 55)];\n+    ///\n+    /// assert_eq!(s.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\n+    /// assert_eq!(s.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\n+    /// assert_eq!(s.binary_search_by_key(&100, |&(a,b)| b), Err(13));\n+    /// let r = s.binary_search_by_key(&1, |&(a,b)| b);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n+    #[inline]\n+    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n+        where F: FnMut(&'a T) -> B,\n+              B: Ord\n+    {\n+        SliceExt::binary_search_by_key(self, b, f)\n+    }\n+\n+    /// Sorts the slice, but may not preserve the order of equal elements.\n+    ///\n+    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n+    /// and `O(n log n)` worst-case.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n+    ///\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n+    /// slice consists of several concatenated sorted sequences.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [-5, 4, 1, -3, 2];\n+    ///\n+    /// v.sort_unstable();\n+    /// assert!(v == [-5, -3, 1, 2, 4]);\n+    /// ```\n+    ///\n+    /// [pdqsort]: https://github.com/orlp/pdqsort\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn sort_unstable(&mut self)\n+        where T: Ord\n+    {\n+        SliceExt::sort_unstable(self);\n+    }\n+\n+    /// Sorts the slice with a comparator function, but may not preserve the order of equal\n+    /// elements.\n+    ///\n+    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n+    /// and `O(n log n)` worst-case.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n+    ///\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n+    /// slice consists of several concatenated sorted sequences.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [5, 4, 1, 3, 2];\n+    /// v.sort_unstable_by(|a, b| a.cmp(b));\n+    /// assert!(v == [1, 2, 3, 4, 5]);\n+    ///\n+    /// // reverse sorting\n+    /// v.sort_unstable_by(|a, b| b.cmp(a));\n+    /// assert!(v == [5, 4, 3, 2, 1]);\n+    /// ```\n+    ///\n+    /// [pdqsort]: https://github.com/orlp/pdqsort\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn sort_unstable_by<F>(&mut self, compare: F)\n+        where F: FnMut(&T, &T) -> Ordering\n+    {\n+        SliceExt::sort_unstable_by(self, compare);\n+    }\n+\n+    /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n+    /// elements.\n+    ///\n+    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n+    /// and `O(m n log(m n))` worst-case, where the key function is `O(m)`.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// v.sort_unstable_by_key(|k| k.abs());\n+    /// assert!(v == [1, 2, -3, 4, -5]);\n+    /// ```\n+    ///\n+    /// [pdqsort]: https://github.com/orlp/pdqsort\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn sort_unstable_by_key<K, F>(&mut self, f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n+    {\n+        SliceExt::sort_unstable_by_key(self, f);\n+    }\n+\n+    /// Rotates the slice in-place such that the first `mid` elements of the\n+    /// slice move to the end while the last `self.len() - mid` elements move to\n+    /// the front. After calling `rotate_left`, the element previously at index\n+    /// `mid` will become the first element in the slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if `mid` is greater than the length of the\n+    /// slice. Note that `mid == self.len()` does _not_ panic and is a no-op\n+    /// rotation.\n+    ///\n+    /// # Complexity\n+    ///\n+    /// Takes linear (in `self.len()`) time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a.rotate_left(2);\n+    /// assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n+    /// ```\n+    ///\n+    /// Rotating a subslice:\n+    ///\n+    /// ```\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a[1..5].rotate_left(1);\n+    /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n+   /// ```\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n+    pub fn rotate_left(&mut self, mid: usize) {\n+        SliceExt::rotate_left(self, mid);\n+    }\n+\n+    /// Rotates the slice in-place such that the first `self.len() - k`\n+    /// elements of the slice move to the end while the last `k` elements move\n+    /// to the front. After calling `rotate_right`, the element previously at\n+    /// index `self.len() - k` will become the first element in the slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if `k` is greater than the length of the\n+    /// slice. Note that `k == self.len()` does _not_ panic and is a no-op\n+    /// rotation.\n+    ///\n+    /// # Complexity\n+    ///\n+    /// Takes linear (in `self.len()`) time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a.rotate_right(2);\n+    /// assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n+    /// ```\n+    ///\n+    /// Rotate a subslice:\n+    ///\n+    /// ```\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a[1..5].rotate_right(1);\n+    /// assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);\n+    /// ```\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n+    pub fn rotate_right(&mut self, k: usize) {\n+        SliceExt::rotate_right(self, k);\n+    }\n+\n+    /// Copies the elements from `src` into `self`.\n+    ///\n+    /// The length of `src` must be the same as `self`.\n+    ///\n+    /// If `src` implements `Copy`, it can be more performant to use\n+    /// [`copy_from_slice`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the two slices have different lengths.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Cloning two elements from a slice into another:\n+    ///\n+    /// ```\n+    /// let src = [1, 2, 3, 4];\n+    /// let mut dst = [0, 0];\n+    ///\n+    /// dst.clone_from_slice(&src[2..]);\n+    ///\n+    /// assert_eq!(src, [1, 2, 3, 4]);\n+    /// assert_eq!(dst, [3, 4]);\n+    /// ```\n+    ///\n+    /// Rust enforces that there can only be one mutable reference with no\n+    /// immutable references to a particular piece of data in a particular\n+    /// scope. Because of this, attempting to use `clone_from_slice` on a\n+    /// single slice will result in a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// slice[..2].clone_from_slice(&slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// sub-slices from a slice:\n+    ///\n+    /// ```\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.clone_from_slice(&right[1..]);\n+    /// }\n+    ///\n+    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n+    /// ```\n+    ///\n+    /// [`copy_from_slice`]: #method.copy_from_slice\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n+    pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n+        SliceExt::clone_from_slice(self, src)\n+    }\n+\n+    /// Copies all elements from `src` into `self`, using a memcpy.\n+    ///\n+    /// The length of `src` must be the same as `self`.\n+    ///\n+    /// If `src` does not implement `Copy`, use [`clone_from_slice`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the two slices have different lengths.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Copying two elements from a slice into another:\n+    ///\n+    /// ```\n+    /// let src = [1, 2, 3, 4];\n+    /// let mut dst = [0, 0];\n+    ///\n+    /// dst.copy_from_slice(&src[2..]);\n+    ///\n+    /// assert_eq!(src, [1, 2, 3, 4]);\n+    /// assert_eq!(dst, [3, 4]);\n+    /// ```\n+    ///\n+    /// Rust enforces that there can only be one mutable reference with no\n+    /// immutable references to a particular piece of data in a particular\n+    /// scope. Because of this, attempting to use `copy_from_slice` on a\n+    /// single slice will result in a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// slice[..2].copy_from_slice(&slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// sub-slices from a slice:\n+    ///\n+    /// ```\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.copy_from_slice(&right[1..]);\n+    /// }\n+    ///\n+    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n+    /// ```\n+    ///\n+    /// [`clone_from_slice`]: #method.clone_from_slice\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n+    pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n+        SliceExt::copy_from_slice(self, src)\n+    }\n+\n+    /// Swaps all elements in `self` with those in `other`.\n+    ///\n+    /// The length of `other` must be the same as `self`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the two slices have different lengths.\n+    ///\n+    /// # Example\n+    ///\n+    /// Swapping two elements across slices:\n+    ///\n+    /// ```\n+    /// let mut slice1 = [0, 0];\n+    /// let mut slice2 = [1, 2, 3, 4];\n+    ///\n+    /// slice1.swap_with_slice(&mut slice2[2..]);\n+    ///\n+    /// assert_eq!(slice1, [3, 4]);\n+    /// assert_eq!(slice2, [1, 2, 0, 0]);\n+    /// ```\n+    ///\n+    /// Rust enforces that there can only be one mutable reference to a\n+    /// particular piece of data in a particular scope. Because of this,\n+    /// attempting to use `swap_with_slice` on a single slice will result in\n+    /// a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    /// slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// mutable sub-slices from a slice:\n+    ///\n+    /// ```\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.swap_with_slice(&mut right[1..]);\n+    /// }\n+    ///\n+    /// assert_eq!(slice, [4, 5, 3, 1, 2]);\n+    /// ```\n+    ///\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n+    pub fn swap_with_slice(&mut self, other: &mut [T]) {\n+        SliceExt::swap_with_slice(self, other)\n+    }\n+}}\n+\n+#[lang = \"slice\"]\n+#[cfg(not(test))]\n+#[cfg(not(stage0))]\n+impl<T> [T] {\n+    slice_core_methods!();\n+}\n+\n+// FIXME: remove (inline) this macro\n+// when updating to a bootstrap compiler that has the new lang items.\n+#[cfg_attr(stage0, macro_export)]\n+#[unstable(feature = \"core_slice_ext\", issue = \"32110\")]\n+macro_rules! slice_u8_core_methods { () => {\n+    /// Checks if all bytes in this slice are within the ASCII range.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii())\n+    }\n+\n+    /// Checks that two slices are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n+        self.len() == other.len() &&\n+            self.iter().zip(other).all(|(a, b)| {\n+                a.eq_ignore_ascii_case(b)\n+            })\n+    }\n+\n+    /// Converts this slice to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_uppercase();\n+        }\n+    }\n+\n+    /// Converts this slice to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_lowercase();\n+        }\n+    }\n+}}\n+\n+#[lang = \"slice_u8\"]\n+#[cfg(not(test))]\n+#[cfg(not(stage0))]\n+impl [u8] {\n+    slice_u8_core_methods!();\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n impl<T, I> ops::Index<I> for [T]"}, {"sha": "b39d9feb35b7e3294be2b3c50a14afe7ddf72c39", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1812, "deletions": 76, "changes": 1888, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -2112,14 +2112,16 @@ mod traits {\n \n }\n \n-\n+public_in_stage0! {\n+{\n /// Methods for string slices\n #[allow(missing_docs)]\n #[doc(hidden)]\n #[unstable(feature = \"core_str_ext\",\n            reason = \"stable interface provided by `impl str` in later crates\",\n            issue = \"32110\")]\n-pub trait StrExt {\n+}\n+trait StrExt {\n     // NB there are no docs here are they're all located on the StrExt trait in\n     // liballoc, not here.\n \n@@ -2213,17 +2215,13 @@ pub trait StrExt {\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n     #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n     fn split_whitespace<'a>(&'a self) -> SplitWhitespace<'a>;\n-    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n-    fn is_whitespace(&self) -> bool;\n-    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n-    fn is_alphanumeric(&self) -> bool;\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim(&self) -> &str;\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left(&self) -> &str;\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right(&self) -> &str;\n-}\n+}}\n \n // truncate `&str` to length at most equal to `max`\n // return `true` if it were truncated, and the new str.\n@@ -2549,16 +2547,6 @@ impl StrExt for str {\n         SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n     }\n \n-    #[inline]\n-    fn is_whitespace(&self) -> bool {\n-        self.chars().all(|c| c.is_whitespace())\n-    }\n-\n-    #[inline]\n-    fn is_alphanumeric(&self) -> bool {\n-        self.chars().all(|c| c.is_alphanumeric())\n-    }\n-\n     #[inline]\n     fn trim(&self) -> &str {\n         self.trim_matches(|c: char| c.is_whitespace())\n@@ -2575,88 +2563,1836 @@ impl StrExt for str {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRef<[u8]> for str {\n+// FIXME: remove (inline) this macro and the SliceExt trait\n+// when updating to a bootstrap compiler that has the new lang items.\n+#[cfg_attr(stage0, macro_export)]\n+#[unstable(feature = \"core_str_ext\", issue = \"32110\")]\n+macro_rules! str_core_methods { () => {\n+    /// Returns the length of `self`.\n+    ///\n+    /// This length is in bytes, not [`char`]s or graphemes. In other words,\n+    /// it may not be what a human considers the length of the string.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let len = \"foo\".len();\n+    /// assert_eq!(3, len);\n+    ///\n+    /// let len = \"\u0192oo\".len(); // fancy f!\n+    /// assert_eq!(4, len);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    fn as_ref(&self) -> &[u8] {\n-        self.as_bytes()\n+    pub fn len(&self) -> usize {\n+        StrExt::len(self)\n     }\n-}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Default for &'a str {\n-    /// Creates an empty str\n-    fn default() -> &'a str { \"\" }\n-}\n+    /// Returns `true` if `self` has a length of zero bytes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"\";\n+    /// assert!(s.is_empty());\n+    ///\n+    /// let s = \"not empty\";\n+    /// assert!(!s.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool {\n+        StrExt::is_empty(self)\n+    }\n \n-/// An iterator over the non-whitespace substrings of a string,\n-/// separated by any amount of whitespace.\n-///\n-/// This struct is created by the [`split_whitespace`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`split_whitespace`]: ../../std/primitive.str.html#method.split_whitespace\n-/// [`str`]: ../../std/primitive.str.html\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-#[derive(Clone, Debug)]\n-pub struct SplitWhitespace<'a> {\n-    inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n-}\n+    /// Checks that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n+    ///\n+    /// The start and end of the string (when `index == self.len()`) are\n+    /// considered to be\n+    /// boundaries.\n+    ///\n+    /// Returns `false` if `index` is greater than `self.len()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(s.is_char_boundary(0));\n+    /// // start of `\u8001`\n+    /// assert!(s.is_char_boundary(6));\n+    /// assert!(s.is_char_boundary(s.len()));\n+    ///\n+    /// // second byte of `\u00f6`\n+    /// assert!(!s.is_char_boundary(2));\n+    ///\n+    /// // third byte of `\u8001`\n+    /// assert!(!s.is_char_boundary(8));\n+    /// ```\n+    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n+    #[inline]\n+    pub fn is_char_boundary(&self, index: usize) -> bool {\n+        StrExt::is_char_boundary(self, index)\n+    }\n \n-#[derive(Clone)]\n-struct IsWhitespace;\n+    /// Converts a string slice to a byte slice. To convert the byte slice back\n+    /// into a string slice, use the [`str::from_utf8`] function.\n+    ///\n+    /// [`str::from_utf8`]: ./str/fn.from_utf8.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bytes = \"bors\".as_bytes();\n+    /// assert_eq!(b\"bors\", bytes);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline(always)]\n+    pub fn as_bytes(&self) -> &[u8] {\n+        StrExt::as_bytes(self)\n+    }\n \n-impl FnOnce<(char, )> for IsWhitespace {\n-    type Output = bool;\n+    /// Converts a mutable string slice to a mutable byte slice. To convert the\n+    /// mutable byte slice back into a mutable string slice, use the\n+    /// [`str::from_utf8_mut`] function.\n+    ///\n+    /// [`str::from_utf8_mut`]: ./str/fn.from_utf8_mut.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut s = String::from(\"Hello\");\n+    /// let bytes = unsafe { s.as_bytes_mut() };\n+    ///\n+    /// assert_eq!(b\"Hello\", bytes);\n+    /// ```\n+    ///\n+    /// Mutability:\n+    ///\n+    /// ```\n+    /// let mut s = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    ///\n+    /// unsafe {\n+    ///     let bytes = s.as_bytes_mut();\n+    ///\n+    ///     bytes[0] = 0xF0;\n+    ///     bytes[1] = 0x9F;\n+    ///     bytes[2] = 0x8D;\n+    ///     bytes[3] = 0x94;\n+    /// }\n+    ///\n+    /// assert_eq!(\"\ud83c\udf54\u2208\ud83c\udf0f\", s);\n+    /// ```\n+    #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n+    #[inline(always)]\n+    pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n+        StrExt::as_bytes_mut(self)\n+    }\n \n+    /// Converts a string slice to a raw pointer.\n+    ///\n+    /// As string slices are a slice of bytes, the raw pointer points to a\n+    /// [`u8`]. This pointer will be pointing to the first byte of the string\n+    /// slice.\n+    ///\n+    /// [`u8`]: primitive.u8.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"Hello\";\n+    /// let ptr = s.as_ptr();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (char, )) -> bool {\n-        self.call_mut(arg)\n+    pub fn as_ptr(&self) -> *const u8 {\n+        StrExt::as_ptr(self)\n     }\n-}\n \n-impl FnMut<(char, )> for IsWhitespace {\n+    /// Returns a subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns\n+    /// [`None`] whenever equivalent indexing operation would panic.\n+    ///\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    ///\n+    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n+    ///\n+    /// // indices not on UTF-8 sequence boundaries\n+    /// assert!(v.get(1..).is_none());\n+    /// assert!(v.get(..8).is_none());\n+    ///\n+    /// // out of bounds\n+    /// assert!(v.get(..42).is_none());\n+    /// ```\n+    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (char, )) -> bool {\n-        arg.0.is_whitespace()\n+    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n+        StrExt::get(self, i)\n     }\n-}\n \n-#[derive(Clone)]\n-struct IsNotEmpty;\n-\n-impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n-    type Output = bool;\n+    /// Returns a mutable subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns\n+    /// [`None`] whenever equivalent indexing operation would panic.\n+    ///\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = String::from(\"hello\");\n+    /// // correct length\n+    /// assert!(v.get_mut(0..5).is_some());\n+    /// // out of bounds\n+    /// assert!(v.get_mut(..42).is_none());\n+    /// assert_eq!(Some(\"he\"), v.get_mut(0..2).map(|v| &*v));\n+    ///\n+    /// assert_eq!(\"hello\", v);\n+    /// {\n+    ///     let s = v.get_mut(0..2);\n+    ///     let s = s.map(|s| {\n+    ///         s.make_ascii_uppercase();\n+    ///         &*s\n+    ///     });\n+    ///     assert_eq!(Some(\"HE\"), s);\n+    /// }\n+    /// assert_eq!(\"HEllo\", v);\n+    /// ```\n+    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n+        StrExt::get_mut(self, i)\n+    }\n \n+    /// Returns a unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked(7..11));\n+    /// }\n+    /// ```\n+    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&&str, )) -> bool {\n-        self.call_mut(arg)\n+    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n+        StrExt::get_unchecked(self, i)\n     }\n-}\n \n-impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n+    /// Returns a mutable, unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked_mut(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked_mut(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked_mut(7..11));\n+    /// }\n+    /// ```\n+    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&&str, )) -> bool {\n-        !arg.0.is_empty()\n+    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n+        StrExt::get_unchecked_mut(self, i)\n     }\n-}\n \n+    /// Creates a string slice from another string slice, bypassing safety\n+    /// checks.\n+    ///\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`str`] and [`Index`].\n+    ///\n+    /// [`str`]: primitive.str.html\n+    /// [`Index`]: ops/trait.Index.html\n+    ///\n+    /// This new slice goes from `begin` to `end`, including `begin` but\n+    /// excluding `end`.\n+    ///\n+    /// To get a mutable string slice instead, see the\n+    /// [`slice_mut_unchecked`] method.\n+    ///\n+    /// [`slice_mut_unchecked`]: #method.slice_mut_unchecked\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that three preconditions are\n+    /// satisfied:\n+    ///\n+    /// * `begin` must come before `end`.\n+    /// * `begin` and `end` must be byte positions within the string slice.\n+    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(\"L\u00f6we \u8001\u864e L\u00e9opard\", s.slice_unchecked(0, 21));\n+    /// }\n+    ///\n+    /// let s = \"Hello, world!\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(\"world\", s.slice_unchecked(7, 12));\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n+        StrExt::slice_unchecked(self, begin, end)\n+    }\n \n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-impl<'a> Iterator for SplitWhitespace<'a> {\n-    type Item = &'a str;\n+    /// Creates a string slice from another string slice, bypassing safety\n+    /// checks.\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`str`] and [`IndexMut`].\n+    ///\n+    /// [`str`]: primitive.str.html\n+    /// [`IndexMut`]: ops/trait.IndexMut.html\n+    ///\n+    /// This new slice goes from `begin` to `end`, including `begin` but\n+    /// excluding `end`.\n+    ///\n+    /// To get an immutable string slice instead, see the\n+    /// [`slice_unchecked`] method.\n+    ///\n+    /// [`slice_unchecked`]: #method.slice_unchecked\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that three preconditions are\n+    /// satisfied:\n+    ///\n+    /// * `begin` must come before `end`.\n+    /// * `begin` and `end` must be byte positions within the string slice.\n+    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n+    #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n+    #[inline]\n+    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n+        StrExt::slice_mut_unchecked(self, begin, end)\n+    }\n \n-    fn next(&mut self) -> Option<&'a str> {\n-        self.inner.next()\n+    /// Divide one string slice into two at an index.\n+    ///\n+    /// The argument, `mid`, should be a byte offset from the start of the\n+    /// string. It must also be on the boundary of a UTF-8 code point.\n+    ///\n+    /// The two slices returned go from the start of the string slice to `mid`,\n+    /// and from `mid` to the end of the string slice.\n+    ///\n+    /// To get mutable string slices instead, see the [`split_at_mut`]\n+    /// method.\n+    ///\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n+    /// beyond the last code point of the string slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"Per Martin-L\u00f6f\";\n+    ///\n+    /// let (first, last) = s.split_at(3);\n+    ///\n+    /// assert_eq!(\"Per\", first);\n+    /// assert_eq!(\" Martin-L\u00f6f\", last);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n+    pub fn split_at(&self, mid: usize) -> (&str, &str) {\n+        StrExt::split_at(self, mid)\n     }\n-}\n \n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.inner.next_back()\n+    /// Divide one mutable string slice into two at an index.\n+    ///\n+    /// The argument, `mid`, should be a byte offset from the start of the\n+    /// string. It must also be on the boundary of a UTF-8 code point.\n+    ///\n+    /// The two slices returned go from the start of the string slice to `mid`,\n+    /// and from `mid` to the end of the string slice.\n+    ///\n+    /// To get immutable string slices instead, see the [`split_at`] method.\n+    ///\n+    /// [`split_at`]: #method.split_at\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n+    /// beyond the last code point of the string slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n+    /// {\n+    ///     let (first, last) = s.split_at_mut(3);\n+    ///     first.make_ascii_uppercase();\n+    ///     assert_eq!(\"PER\", first);\n+    ///     assert_eq!(\" Martin-L\u00f6f\", last);\n+    /// }\n+    /// assert_eq!(\"PER Martin-L\u00f6f\", s);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n+    pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n+        StrExt::split_at_mut(self, mid)\n     }\n-}\n \n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a> FusedIterator for SplitWhitespace<'a> {}\n+    /// Returns an iterator over the [`char`]s of a string slice.\n+    ///\n+    /// As a string slice consists of valid UTF-8, we can iterate through a\n+    /// string slice by [`char`]. This method returns such an iterator.\n+    ///\n+    /// It's important to remember that [`char`] represents a Unicode Scalar\n+    /// Value, and may not match your idea of what a 'character' is. Iteration\n+    /// over grapheme clusters may be what you actually want.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let word = \"goodbye\";\n+    ///\n+    /// let count = word.chars().count();\n+    /// assert_eq!(7, count);\n+    ///\n+    /// let mut chars = word.chars();\n+    ///\n+    /// assert_eq!(Some('g'), chars.next());\n+    /// assert_eq!(Some('o'), chars.next());\n+    /// assert_eq!(Some('o'), chars.next());\n+    /// assert_eq!(Some('d'), chars.next());\n+    /// assert_eq!(Some('b'), chars.next());\n+    /// assert_eq!(Some('y'), chars.next());\n+    /// assert_eq!(Some('e'), chars.next());\n+    ///\n+    /// assert_eq!(None, chars.next());\n+    /// ```\n+    ///\n+    /// Remember, [`char`]s may not match your human intuition about characters:\n+    ///\n+    /// ```\n+    /// let y = \"y\u0306\";\n+    ///\n+    /// let mut chars = y.chars();\n+    ///\n+    /// assert_eq!(Some('y'), chars.next()); // not 'y\u0306'\n+    /// assert_eq!(Some('\\u{0306}'), chars.next());\n+    ///\n+    /// assert_eq!(None, chars.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn chars(&self) -> Chars {\n+        StrExt::chars(self)\n+    }\n+    /// Returns an iterator over the [`char`]s of a string slice, and their\n+    /// positions.\n+    ///\n+    /// As a string slice consists of valid UTF-8, we can iterate through a\n+    /// string slice by [`char`]. This method returns an iterator of both\n+    /// these [`char`]s, as well as their byte positions.\n+    ///\n+    /// The iterator yields tuples. The position is first, the [`char`] is\n+    /// second.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let word = \"goodbye\";\n+    ///\n+    /// let count = word.char_indices().count();\n+    /// assert_eq!(7, count);\n+    ///\n+    /// let mut char_indices = word.char_indices();\n+    ///\n+    /// assert_eq!(Some((0, 'g')), char_indices.next());\n+    /// assert_eq!(Some((1, 'o')), char_indices.next());\n+    /// assert_eq!(Some((2, 'o')), char_indices.next());\n+    /// assert_eq!(Some((3, 'd')), char_indices.next());\n+    /// assert_eq!(Some((4, 'b')), char_indices.next());\n+    /// assert_eq!(Some((5, 'y')), char_indices.next());\n+    /// assert_eq!(Some((6, 'e')), char_indices.next());\n+    ///\n+    /// assert_eq!(None, char_indices.next());\n+    /// ```\n+    ///\n+    /// Remember, [`char`]s may not match your human intuition about characters:\n+    ///\n+    /// ```\n+    /// let yes = \"y\u0306es\";\n+    ///\n+    /// let mut char_indices = yes.char_indices();\n+    ///\n+    /// assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y\u0306')\n+    /// assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n+    ///\n+    /// // note the 3 here - the last character took up two bytes\n+    /// assert_eq!(Some((3, 'e')), char_indices.next());\n+    /// assert_eq!(Some((4, 's')), char_indices.next());\n+    ///\n+    /// assert_eq!(None, char_indices.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn char_indices(&self) -> CharIndices {\n+        StrExt::char_indices(self)\n+    }\n+\n+    /// An iterator over the bytes of a string slice.\n+    ///\n+    /// As a string slice consists of a sequence of bytes, we can iterate\n+    /// through a string slice by byte. This method returns such an iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut bytes = \"bors\".bytes();\n+    ///\n+    /// assert_eq!(Some(b'b'), bytes.next());\n+    /// assert_eq!(Some(b'o'), bytes.next());\n+    /// assert_eq!(Some(b'r'), bytes.next());\n+    /// assert_eq!(Some(b's'), bytes.next());\n+    ///\n+    /// assert_eq!(None, bytes.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn bytes(&self) -> Bytes {\n+        StrExt::bytes(self)\n+    }\n+\n+    /// Split a string slice by whitespace.\n+    ///\n+    /// The iterator returned will return string slices that are sub-slices of\n+    /// the original string slice, separated by any amount of whitespace.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut iter = \"A few words\".split_whitespace();\n+    ///\n+    /// assert_eq!(Some(\"A\"), iter.next());\n+    /// assert_eq!(Some(\"few\"), iter.next());\n+    /// assert_eq!(Some(\"words\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    ///\n+    /// All kinds of whitespace are considered:\n+    ///\n+    /// ```\n+    /// let mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\n+    /// assert_eq!(Some(\"Mary\"), iter.next());\n+    /// assert_eq!(Some(\"had\"), iter.next());\n+    /// assert_eq!(Some(\"a\"), iter.next());\n+    /// assert_eq!(Some(\"little\"), iter.next());\n+    /// assert_eq!(Some(\"lamb\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+    #[inline]\n+    pub fn split_whitespace(&self) -> SplitWhitespace {\n+        StrExt::split_whitespace(self)\n+    }\n+\n+    /// An iterator over the lines of a string, as string slices.\n+    ///\n+    /// Lines are ended with either a newline (`\\n`) or a carriage return with\n+    /// a line feed (`\\r\\n`).\n+    ///\n+    /// The final line ending is optional.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let text = \"foo\\r\\nbar\\n\\nbaz\\n\";\n+    /// let mut lines = text.lines();\n+    ///\n+    /// assert_eq!(Some(\"foo\"), lines.next());\n+    /// assert_eq!(Some(\"bar\"), lines.next());\n+    /// assert_eq!(Some(\"\"), lines.next());\n+    /// assert_eq!(Some(\"baz\"), lines.next());\n+    ///\n+    /// assert_eq!(None, lines.next());\n+    /// ```\n+    ///\n+    /// The final line ending isn't required:\n+    ///\n+    /// ```\n+    /// let text = \"foo\\nbar\\n\\r\\nbaz\";\n+    /// let mut lines = text.lines();\n+    ///\n+    /// assert_eq!(Some(\"foo\"), lines.next());\n+    /// assert_eq!(Some(\"bar\"), lines.next());\n+    /// assert_eq!(Some(\"\"), lines.next());\n+    /// assert_eq!(Some(\"baz\"), lines.next());\n+    ///\n+    /// assert_eq!(None, lines.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn lines(&self) -> Lines {\n+        StrExt::lines(self)\n+    }\n+\n+    /// An iterator over the lines of a string.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")]\n+    #[inline]\n+    #[allow(deprecated)]\n+    pub fn lines_any(&self) -> LinesAny {\n+        StrExt::lines_any(self)\n+    }\n+\n+    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let text = \"Za\u017c\u00f3\u0142\u0107 g\u0119\u015bl\u0105 ja\u017a\u0144\";\n+    ///\n+    /// let utf8_len = text.len();\n+    /// let utf16_len = text.encode_utf16().count();\n+    ///\n+    /// assert!(utf16_len <= utf8_len);\n+    /// ```\n+    #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+    pub fn encode_utf16(&self) -> EncodeUtf16 {\n+        EncodeUtf16::new(self)\n+    }\n+\n+    /// Returns `true` if the given pattern matches a sub-slice of\n+    /// this string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.contains(\"nana\"));\n+    /// assert!(!bananas.contains(\"apples\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        StrExt::contains(self, pat)\n+    }\n+\n+    /// Returns `true` if the given pattern matches a prefix of this\n+    /// string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.starts_with(\"bana\"));\n+    /// assert!(!bananas.starts_with(\"nana\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        StrExt::starts_with(self, pat)\n+    }\n+\n+    /// Returns `true` if the given pattern matches a suffix of this\n+    /// string slice.\n+    ///\n+    /// Returns `false` if it does not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.ends_with(\"anas\"));\n+    /// assert!(!bananas.ends_with(\"nana\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::ends_with(self, pat)\n+    }\n+\n+    /// Returns the byte index of the first character of this string slice that\n+    /// matches the pattern.\n+    ///\n+    /// Returns [`None`] if the pattern doesn't match.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find('L'), Some(0));\n+    /// assert_eq!(s.find('\u00e9'), Some(14));\n+    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n+    /// ```\n+    ///\n+    /// More complex patterns using point-free style and closures:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find(char::is_whitespace), Some(5));\n+    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n+    /// assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\n+    /// assert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let x: &[_] = &['1', '2'];\n+    ///\n+    /// assert_eq!(s.find(x), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n+        StrExt::find(self, pat)\n+    }\n+\n+    /// Returns the byte index of the last character of this string slice that\n+    /// matches the pattern.\n+    ///\n+    /// Returns [`None`] if the pattern doesn't match.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`None`]: option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind('L'), Some(13));\n+    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    /// ```\n+    ///\n+    /// More complex patterns with closures:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind(char::is_whitespace), Some(12));\n+    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let x: &[_] = &['1', '2'];\n+    ///\n+    /// assert_eq!(s.rfind(x), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rfind(self, pat)\n+    }\n+\n+    /// An iterator over substrings of this string slice, separated by\n+    /// characters matched by a pattern.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rsplit`] method can be used.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`rsplit`]: #method.rsplit\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".split('X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    /// ```\n+    ///\n+    /// If a string contains multiple contiguous separators, you will end up\n+    /// with empty strings in the output:\n+    ///\n+    /// ```\n+    /// let x = \"||||a||b|c\".to_string();\n+    /// let d: Vec<_> = x.split('|').collect();\n+    ///\n+    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// Contiguous separators are separated by the empty string.\n+    ///\n+    /// ```\n+    /// let x = \"(///)\".to_string();\n+    /// let d: Vec<_> = x.split('/').collect();\n+    ///\n+    /// assert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n+    /// ```\n+    ///\n+    /// Separators at the start or end of a string are neighbored\n+    /// by empty strings.\n+    ///\n+    /// ```\n+    /// let d: Vec<_> = \"010\".split(\"0\").collect();\n+    /// assert_eq!(d, &[\"\", \"1\", \"\"]);\n+    /// ```\n+    ///\n+    /// When the empty string is used as a separator, it separates\n+    /// every character in the string, along with the beginning\n+    /// and end of the string.\n+    ///\n+    /// ```\n+    /// let f: Vec<_> = \"rust\".split(\"\").collect();\n+    /// assert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n+    /// ```\n+    ///\n+    /// Contiguous separators can lead to possibly surprising behavior\n+    /// when whitespace is used as the separator. This code is correct:\n+    ///\n+    /// ```\n+    /// let x = \"    a  b c\".to_string();\n+    /// let d: Vec<_> = x.split(' ').collect();\n+    ///\n+    /// assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// It does _not_ give you:\n+    ///\n+    /// ```,ignore\n+    /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n+    /// ```\n+    ///\n+    /// Use [`split_whitespace`] for this behavior.\n+    ///\n+    /// [`split_whitespace`]: #method.split_whitespace\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n+        StrExt::split(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by\n+    /// characters matched by a pattern and yielded in reverse order.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`split`] method can be used.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rsplit(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by\n+    /// characters matched by a pattern.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// Equivalent to [`split`], except that the trailing substring\n+    /// is skipped if empty.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _separated_ by a pattern.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rsplit_terminator`] method can be used.\n+    ///\n+    /// [`rsplit_terminator`]: #method.rsplit_terminator\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, [\"A\", \"B\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n+        StrExt::split_terminator(self, pat)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern and yielded in reverse order.\n+    ///\n+    /// The pattern can be a simple `&str`, [`char`], or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// Equivalent to [`split`], except that the trailing substring is\n+    /// skipped if empty.\n+    ///\n+    /// [`split`]: #method.split\n+    ///\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _separated_ by a pattern.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search, and it will be double ended if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// For iterating from the front, the [`split_terminator`] method can be\n+    /// used.\n+    ///\n+    /// [`split_terminator`]: #method.split_terminator\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n+    /// assert_eq!(v, [\"B\", \"A\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rsplit_terminator(self, pat)\n+    }\n+\n+    /// An iterator over substrings of the given string slice, separated by a\n+    /// pattern, restricted to returning at most `n` items.\n+    ///\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is\n+    /// not efficient to support.\n+    ///\n+    /// If the pattern allows a reverse search, the [`rsplitn`] method can be\n+    /// used.\n+    ///\n+    /// [`rsplitn`]: #method.rsplitn\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"abcXdef\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n+        StrExt::splitn(self, n, pat)\n+    }\n+\n+    /// An iterator over substrings of this string slice, separated by a\n+    /// pattern, starting from the end of the string, restricted to returning\n+    /// at most `n` items.\n+    ///\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines the split.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is not\n+    /// efficient to support.\n+    ///\n+    /// For splitting from the front, the [`splitn`] method can be used.\n+    ///\n+    /// [`splitn`]: #method.splitn\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rsplitn(self, n, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within the given string\n+    /// slice.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rmatches`] method can be used.\n+    ///\n+    /// [`rmatches`]: #method.rmatches\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n+    /// ```\n+    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+    #[inline]\n+    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n+        StrExt::matches(self, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within this string slice,\n+    /// yielded in reverse order.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`matches`] method can be used.\n+    ///\n+    /// [`matches`]: #method.matches\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n+    /// ```\n+    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+    #[inline]\n+    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rmatches(self, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within this string\n+    /// slice as well as the index that the match starts at.\n+    ///\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the first match are returned.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines\n+    /// if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, the [`rmatch_indices`] method can be used.\n+    ///\n+    /// [`rmatch_indices`]: #method.rmatch_indices\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n+    /// ```\n+    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n+        StrExt::match_indices(self, pat)\n+    }\n+\n+    /// An iterator over the disjoint matches of a pattern within `self`,\n+    /// yielded in reverse order along with the index of the match.\n+    ///\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the last match are returned.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if a\n+    /// character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`match_indices`] method can be used.\n+    ///\n+    /// [`match_indices`]: #method.match_indices\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n+    ///\n+    /// let v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n+    /// ```\n+    #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::rmatch_indices(self, pat)\n+    }\n+\n+    /// Returns a string slice with leading and trailing whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\"Hello\\tworld\", s.trim());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim(&self) -> &str {\n+        StrExt::trim(self)\n+    }\n+\n+    /// Returns a string slice with leading whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Left' in this context means the first\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _right_ side, not the left.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n+    /// ```\n+    ///\n+    /// Directionality:\n+    ///\n+    /// ```\n+    /// let s = \"  English\";\n+    /// assert!(Some('E') == s.trim_left().chars().next());\n+    ///\n+    /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea\";\n+    /// assert!(Some('\u05e2') == s.trim_left().chars().next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_left(&self) -> &str {\n+        StrExt::trim_left(self)\n+    }\n+\n+    /// Returns a string slice with trailing whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Right' in this context means the last\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _left_ side, not the right.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    ///\n+    /// assert_eq!(\" Hello\\tworld\", s.trim_right());\n+    /// ```\n+    ///\n+    /// Directionality:\n+    ///\n+    /// ```\n+    /// let s = \"English  \";\n+    /// assert!(Some('h') == s.trim_right().chars().rev().next());\n+    ///\n+    /// let s = \"\u05e2\u05d1\u05e8\u05d9\u05ea  \";\n+    /// assert!(Some('\u05ea') == s.trim_right().chars().rev().next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_right(&self) -> &str {\n+        StrExt::trim_right(self)\n+    }\n+\n+    /// Returns a string slice with all prefixes and suffixes that match a\n+    /// pattern repeatedly removed.\n+    ///\n+    /// The pattern can be a [`char`] or a closure that determines if a\n+    /// character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: DoubleEndedSearcher<'a>\n+    {\n+        StrExt::trim_matches(self, pat)\n+    }\n+\n+    /// Returns a string slice with all prefixes that match a pattern\n+    /// repeatedly removed.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Left' in this context means the first\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _right_ side, not the left.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n+    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n+        StrExt::trim_left_matches(self, pat)\n+    }\n+\n+    /// Returns a string slice with all suffixes that match a pattern\n+    /// repeatedly removed.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Right' in this context means the last\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _left_ side, not the right.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        StrExt::trim_right_matches(self, pat)\n+    }\n+\n+    /// Parses this string slice into another type.\n+    ///\n+    /// Because `parse` is so general, it can cause problems with type\n+    /// inference. As such, `parse` is one of the few times you'll see\n+    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n+    /// helps the inference algorithm understand specifically which type\n+    /// you're trying to parse into.\n+    ///\n+    /// `parse` can parse any type that implements the [`FromStr`] trait.\n+    ///\n+    /// [`FromStr`]: str/trait.FromStr.html\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will return [`Err`] if it's not possible to parse this string slice into\n+    /// the desired type.\n+    ///\n+    /// [`Err`]: str/trait.FromStr.html#associatedtype.Err\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage\n+    ///\n+    /// ```\n+    /// let four: u32 = \"4\".parse().unwrap();\n+    ///\n+    /// assert_eq!(4, four);\n+    /// ```\n+    ///\n+    /// Using the 'turbofish' instead of annotating `four`:\n+    ///\n+    /// ```\n+    /// let four = \"4\".parse::<u32>();\n+    ///\n+    /// assert_eq!(Ok(4), four);\n+    /// ```\n+    ///\n+    /// Failing to parse:\n+    ///\n+    /// ```\n+    /// let nope = \"j\".parse::<u32>();\n+    ///\n+    /// assert!(nope.is_err());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n+        StrExt::parse(self)\n+    }\n+\n+    /// Checks if all characters in this string are within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = \"hello!\\n\";\n+    /// let non_ascii = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n+    ///\n+    /// assert!(ascii.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        // We can treat each byte as character here: all multibyte characters\n+        // start with a byte that is not in the ascii range, so we will stop\n+        // there already.\n+        self.bytes().all(|b| b.is_ascii())\n+    }\n+\n+    /// Checks that two strings are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\n+    /// assert!(\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00f6S\"));\n+    /// assert!(!\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00d6S\"));\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n+        self.as_bytes().eq_ignore_ascii_case(other.as_bytes())\n+    }\n+\n+    /// Converts this string to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        let me = unsafe { self.as_bytes_mut() };\n+        me.make_ascii_uppercase()\n+    }\n+\n+    /// Converts this string to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        let me = unsafe { self.as_bytes_mut() };\n+        me.make_ascii_lowercase()\n+    }\n+}}\n+\n+#[lang = \"str\"]\n+#[cfg(not(test))]\n+#[cfg(not(stage0))]\n+impl str {\n+    str_core_methods!();\n+}\n+\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<[u8]> for str {\n+    #[inline]\n+    fn as_ref(&self) -> &[u8] {\n+        self.as_bytes()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Default for &'a str {\n+    /// Creates an empty str\n+    fn default() -> &'a str { \"\" }\n+}\n+\n+/// An iterator over the non-whitespace substrings of a string,\n+/// separated by any amount of whitespace.\n+///\n+/// This struct is created by the [`split_whitespace`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_whitespace`]: ../../std/primitive.str.html#method.split_whitespace\n+/// [`str`]: ../../std/primitive.str.html\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+#[derive(Clone, Debug)]\n+pub struct SplitWhitespace<'a> {\n+    inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n+}\n+\n+#[derive(Clone)]\n+struct IsWhitespace;\n+\n+impl FnOnce<(char, )> for IsWhitespace {\n+    type Output = bool;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (char, )) -> bool {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl FnMut<(char, )> for IsWhitespace {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (char, )) -> bool {\n+        arg.0.is_whitespace()\n+    }\n+}\n+\n+#[derive(Clone)]\n+struct IsNotEmpty;\n+\n+impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n+    type Output = bool;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&&str, )) -> bool {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&&str, )) -> bool {\n+        !arg.0.is_empty()\n+    }\n+}\n+\n+\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+impl<'a> Iterator for SplitWhitespace<'a> {\n+    type Item = &'a str;\n+\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.inner.next()\n+    }\n+}\n+\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<'a> FusedIterator for SplitWhitespace<'a> {}\n+\n+/// An iterator of [`u16`] over the string encoded as UTF-16.\n+///\n+/// [`u16`]: ../../std/primitive.u16.html\n+///\n+/// This struct is created by the [`encode_utf16`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`encode_utf16`]: ../../std/primitive.str.html#method.encode_utf16\n+/// [`str`]: ../../std/primitive.str.html\n+#[derive(Clone)]\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+pub struct EncodeUtf16<'a> {\n+    chars: Chars<'a>,\n+    extra: u16,\n+}\n+\n+// FIXME: remove (inline) this method\n+// when updating to a bootstrap compiler that has the new lang items.\n+// For grepping purpose: #[cfg(stage0)]\n+impl<'a> EncodeUtf16<'a> {\n+    #[unstable(feature = \"core_str_ext\", issue = \"32110\")]\n+    #[doc(hidden)]\n+    pub fn new(s: &'a str) -> Self {\n+        EncodeUtf16 { chars: s.chars(), extra: 0 }\n+    }\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<'a> fmt::Debug for EncodeUtf16<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"EncodeUtf16 { .. }\")\n+    }\n+}\n+\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+impl<'a> Iterator for EncodeUtf16<'a> {\n+    type Item = u16;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> {\n+        if self.extra != 0 {\n+            let tmp = self.extra;\n+            self.extra = 0;\n+            return Some(tmp);\n+        }\n+\n+        let mut buf = [0; 2];\n+        self.chars.next().map(|ch| {\n+            let n = ch.encode_utf16(&mut buf).len();\n+            if n == 2 {\n+                self.extra = buf[1];\n+            }\n+            buf[0]\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (low, high) = self.chars.size_hint();\n+        // every char gets either one u16 or two u16,\n+        // so this iterator is between 1 or 2 times as\n+        // long as the underlying iterator.\n+        (low, high.and_then(|n| n.checked_mul(2)))\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<'a> FusedIterator for EncodeUtf16<'a> {}"}, {"sha": "7d3852d2f2a983c1d1f434a6896078536d1ce42e", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -17,6 +17,7 @@\n #![feature(decode_utf8)]\n #![feature(exact_size_is_empty)]\n #![feature(fixed_size_array)]\n+#![feature(float_internals)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n #![feature(hashmap_internals)]"}, {"sha": "c7412dbeeb368d75bd3d3a692c2a8ef806109971", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -214,6 +214,9 @@ language_item_table! {\n     StrImplItem,                     \"str\",                     str_impl;\n     SliceImplItem,                   \"slice\",                   slice_impl;\n     SliceU8ImplItem,                 \"slice_u8\",                slice_u8_impl;\n+    StrAllocImplItem,                \"str_alloc\",               str_alloc_impl;\n+    SliceAllocImplItem,              \"slice_alloc\",             slice_alloc_impl;\n+    SliceU8AllocImplItem,            \"slice_u8_alloc\",          slice_u8_alloc_impl;\n     ConstPtrImplItem,                \"const_ptr\",               const_ptr_impl;\n     MutPtrImplItem,                  \"mut_ptr\",                 mut_ptr_impl;\n     I8ImplItem,                      \"i8\",                      i8_impl;\n@@ -230,6 +233,8 @@ language_item_table! {\n     UsizeImplItem,                   \"usize\",                   usize_impl;\n     F32ImplItem,                     \"f32\",                     f32_impl;\n     F64ImplItem,                     \"f64\",                     f64_impl;\n+    F32RuntimeImplItem,              \"f32_runtime\",             f32_runtime_impl;\n+    F64RuntimeImplItem,              \"f64_runtime\",             f64_runtime_impl;\n \n     SizedTraitLangItem,              \"sized\",                   sized_trait;\n     UnsizeTraitLangItem,             \"unsize\",                  unsize_trait;"}, {"sha": "073f36b9f3c505b2000ad42f152211d33d602ce9", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -471,13 +471,22 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             ty::TyStr => {\n                 let lang_def_id = lang_items.str_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n+\n+                let lang_def_id = lang_items.str_alloc_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TySlice(_) => {\n                 let lang_def_id = lang_items.slice_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n \n                 let lang_def_id = lang_items.slice_u8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n+\n+                let lang_def_id = lang_items.slice_alloc_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+\n+                let lang_def_id = lang_items.slice_u8_alloc_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 let lang_def_id = lang_items.const_ptr_impl();\n@@ -538,10 +547,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             ty::TyFloat(ast::FloatTy::F32) => {\n                 let lang_def_id = lang_items.f32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n+\n+                let lang_def_id = lang_items.f32_runtime_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyFloat(ast::FloatTy::F64) => {\n                 let lang_def_id = lang_items.f64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n+\n+                let lang_def_id = lang_items.f64_runtime_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             _ => {}\n         }"}, {"sha": "532f1da4f301b4201ed6aa7b9b010baa59144631", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -114,139 +114,159 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             ty::TyChar => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.char_impl(),\n+                                          None,\n                                           \"char\",\n                                           \"char\",\n                                           item.span);\n             }\n             ty::TyStr => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.str_impl(),\n+                                          lang_items.str_alloc_impl(),\n                                           \"str\",\n                                           \"str\",\n                                           item.span);\n             }\n             ty::TySlice(slice_item) if slice_item == self.tcx.types.u8 => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.slice_u8_impl(),\n+                                          lang_items.slice_u8_alloc_impl(),\n                                           \"slice_u8\",\n                                           \"[u8]\",\n                                           item.span);\n             }\n             ty::TySlice(_) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.slice_impl(),\n+                                          lang_items.slice_alloc_impl(),\n                                           \"slice\",\n                                           \"[T]\",\n                                           item.span);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.const_ptr_impl(),\n+                                          None,\n                                           \"const_ptr\",\n                                           \"*const T\",\n                                           item.span);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.mut_ptr_impl(),\n+                                          None,\n                                           \"mut_ptr\",\n                                           \"*mut T\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I8) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i8_impl(),\n+                                          None,\n                                           \"i8\",\n                                           \"i8\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I16) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i16_impl(),\n+                                          None,\n                                           \"i16\",\n                                           \"i16\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I32) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i32_impl(),\n+                                          None,\n                                           \"i32\",\n                                           \"i32\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I64) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i64_impl(),\n+                                          None,\n                                           \"i64\",\n                                           \"i64\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I128) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i128_impl(),\n+                                          None,\n                                           \"i128\",\n                                           \"i128\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::Isize) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.isize_impl(),\n+                                          None,\n                                           \"isize\",\n                                           \"isize\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U8) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u8_impl(),\n+                                          None,\n                                           \"u8\",\n                                           \"u8\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U16) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u16_impl(),\n+                                          None,\n                                           \"u16\",\n                                           \"u16\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U32) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u32_impl(),\n+                                          None,\n                                           \"u32\",\n                                           \"u32\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U64) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u64_impl(),\n+                                          None,\n                                           \"u64\",\n                                           \"u64\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U128) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u128_impl(),\n+                                          None,\n                                           \"u128\",\n                                           \"u128\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::Usize) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.usize_impl(),\n+                                          None,\n                                           \"usize\",\n                                           \"usize\",\n                                           item.span);\n             }\n             ty::TyFloat(ast::FloatTy::F32) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.f32_impl(),\n+                                          lang_items.f32_runtime_impl(),\n                                           \"f32\",\n                                           \"f32\",\n                                           item.span);\n             }\n             ty::TyFloat(ast::FloatTy::F64) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.f64_impl(),\n+                                          lang_items.f64_runtime_impl(),\n                                           \"f64\",\n                                           \"f64\",\n                                           item.span);\n@@ -305,11 +325,15 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n     fn check_primitive_impl(&self,\n                             impl_def_id: DefId,\n                             lang_def_id: Option<DefId>,\n+                            lang_def_id2: Option<DefId>,\n                             lang: &str,\n                             ty: &str,\n                             span: Span) {\n-        match lang_def_id {\n-            Some(lang_def_id) if lang_def_id == impl_def_id => {\n+        match (lang_def_id, lang_def_id2) {\n+            (Some(lang_def_id), _) if lang_def_id == impl_def_id => {\n+                // OK\n+            }\n+            (_, Some(lang_def_id)) if lang_def_id == impl_def_id => {\n                 // OK\n             }\n             _ => {"}, {"sha": "e3f7ff5cb3f74406c4bf809adf29e31716e63e28", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -4526,23 +4526,23 @@ but the type of the numeric value or binding could not be identified.\n The error happens on numeric literals:\n \n ```compile_fail,E0689\n-2.0.powi(2);\n+2.0.recip();\n ```\n \n and on numeric bindings without an identified concrete type:\n \n ```compile_fail,E0689\n let x = 2.0;\n-x.powi(2);  // same error as above\n+x.recip();  // same error as above\n ```\n \n Because of this, you must give the numeric literal or binding a type:\n \n ```\n-let _ = 2.0_f32.powi(2);\n+let _ = 2.0_f32.recip();\n let x: f32 = 2.0;\n-let _ = x.powi(2);\n-let _ = (2.0 as f32).powi(2);\n+let _ = x.recip();\n+let _ = (2.0 as f32).recip();\n ```\n \"##,\n "}, {"sha": "23e0c2625eeeb6b0607d2d7fa8d63cdc1211e251", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -286,10 +286,15 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n         lang_items.u128_impl(),\n         lang_items.f32_impl(),\n         lang_items.f64_impl(),\n+        lang_items.f32_runtime_impl(),\n+        lang_items.f64_runtime_impl(),\n         lang_items.char_impl(),\n         lang_items.str_impl(),\n         lang_items.slice_impl(),\n         lang_items.slice_u8_impl(),\n+        lang_items.str_alloc_impl(),\n+        lang_items.slice_alloc_impl(),\n+        lang_items.slice_u8_alloc_impl(),\n         lang_items.const_ptr_impl(),\n         lang_items.mut_ptr_impl(),\n     ];"}, {"sha": "26644c769575c9bde37dd88e9af0a9077e2f54a9", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 20, "deletions": 274, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -19,10 +19,12 @@\n #![allow(missing_docs)]\n \n #[cfg(not(test))]\n-use core::num;\n+#[cfg(stage0)]\n+use core::num::Float;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n+#[cfg(stage0)]\n use num::FpCategory;\n #[cfg(not(test))]\n use sys::cmath;\n@@ -39,106 +41,11 @@ pub use core::f32::{MIN, MIN_POSITIVE, MAX};\n pub use core::f32::consts;\n \n #[cfg(not(test))]\n-#[lang = \"f32\"]\n+#[cfg_attr(stage0, lang = \"f32\")]\n+#[cfg_attr(not(stage0), lang = \"f32_runtime\")]\n impl f32 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    ///\n-    /// let nan = f32::NAN;\n-    /// let f = 7.0_f32;\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// assert!(!f.is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_nan(self) -> bool { num::Float::is_nan(self) }\n-\n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    ///\n-    /// let f = 7.0f32;\n-    /// let inf = f32::INFINITY;\n-    /// let neg_inf = f32::NEG_INFINITY;\n-    /// let nan = f32::NAN;\n-    ///\n-    /// assert!(!f.is_infinite());\n-    /// assert!(!nan.is_infinite());\n-    ///\n-    /// assert!(inf.is_infinite());\n-    /// assert!(neg_inf.is_infinite());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n-\n-    /// Returns `true` if this number is neither infinite nor `NaN`.\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    ///\n-    /// let f = 7.0f32;\n-    /// let inf = f32::INFINITY;\n-    /// let neg_inf = f32::NEG_INFINITY;\n-    /// let nan = f32::NAN;\n-    ///\n-    /// assert!(f.is_finite());\n-    ///\n-    /// assert!(!nan.is_finite());\n-    /// assert!(!inf.is_finite());\n-    /// assert!(!neg_inf.is_finite());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_finite(self) -> bool { num::Float::is_finite(self) }\n-\n-    /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal][subnormal], or `NaN`.\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    ///\n-    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n-    /// let max = f32::MAX;\n-    /// let lower_than_min = 1.0e-40_f32;\n-    /// let zero = 0.0_f32;\n-    ///\n-    /// assert!(min.is_normal());\n-    /// assert!(max.is_normal());\n-    ///\n-    /// assert!(!zero.is_normal());\n-    /// assert!(!f32::NAN.is_normal());\n-    /// assert!(!f32::INFINITY.is_normal());\n-    /// // Values between `0` and `min` are Subnormal.\n-    /// assert!(!lower_than_min.is_normal());\n-    /// ```\n-    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_normal(self) -> bool { num::Float::is_normal(self) }\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    ///\n-    /// ```\n-    /// use std::num::FpCategory;\n-    /// use std::f32;\n-    ///\n-    /// let num = 12.4_f32;\n-    /// let inf = f32::INFINITY;\n-    ///\n-    /// assert_eq!(num.classify(), FpCategory::Normal);\n-    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn classify(self) -> FpCategory { num::Float::classify(self) }\n+    #[cfg(stage0)]\n+    f32_core_methods!();\n \n     /// Returns the largest integer less than or equal to a number.\n     ///\n@@ -257,7 +164,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn abs(self) -> f32 { num::Float::abs(self) }\n+    pub fn abs(self) -> f32 {\n+        unsafe { intrinsics::fabsf32(self) }\n+    }\n \n     /// Returns a number that represents the sign of `self`.\n     ///\n@@ -277,35 +186,13 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn signum(self) -> f32 { num::Float::signum(self) }\n-\n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n-    /// positive sign bit and positive infinity.\n-    ///\n-    /// ```\n-    /// let f = 7.0_f32;\n-    /// let g = -7.0_f32;\n-    ///\n-    /// assert!(f.is_sign_positive());\n-    /// assert!(!g.is_sign_positive());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_sign_positive(self) -> bool { num::Float::is_sign_positive(self) }\n-\n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n-    /// negative sign bit and negative infinity.\n-    ///\n-    /// ```\n-    /// let f = 7.0f32;\n-    /// let g = -7.0f32;\n-    ///\n-    /// assert!(!f.is_sign_negative());\n-    /// assert!(g.is_sign_negative());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_sign_negative(self) -> bool { num::Float::is_sign_negative(self) }\n+    pub fn signum(self) -> f32 {\n+        if self.is_nan() {\n+            NAN\n+        } else {\n+            unsafe { intrinsics::copysignf32(1.0, self) }\n+        }\n+    }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n@@ -380,20 +267,6 @@ impl f32 {\n     }\n \n \n-    /// Takes the reciprocal (inverse) of a number, `1/x`.\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    ///\n-    /// let x = 2.0_f32;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn recip(self) -> f32 { num::Float::recip(self) }\n-\n     /// Raises a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n@@ -408,7 +281,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }\n+    pub fn powi(self, n: i32) -> f32 {\n+        unsafe { intrinsics::powif32(self, n) }\n+    }\n \n     /// Raises a number to a floating point power.\n     ///\n@@ -584,68 +459,6 @@ impl f32 {\n         return unsafe { intrinsics::log10f32(self) };\n     }\n \n-    /// Converts radians to degrees.\n-    ///\n-    /// ```\n-    /// use std::f32::{self, consts};\n-    ///\n-    /// let angle = consts::PI;\n-    ///\n-    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n-    #[inline]\n-    pub fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }\n-\n-    /// Converts degrees to radians.\n-    ///\n-    /// ```\n-    /// use std::f32::{self, consts};\n-    ///\n-    /// let angle = 180.0f32;\n-    ///\n-    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n-    #[inline]\n-    pub fn to_radians(self) -> f32 { num::Float::to_radians(self) }\n-\n-    /// Returns the maximum of the two numbers.\n-    ///\n-    /// ```\n-    /// let x = 1.0f32;\n-    /// let y = 2.0f32;\n-    ///\n-    /// assert_eq!(x.max(y), y);\n-    /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn max(self, other: f32) -> f32 {\n-        num::Float::max(self, other)\n-    }\n-\n-    /// Returns the minimum of the two numbers.\n-    ///\n-    /// ```\n-    /// let x = 1.0f32;\n-    /// let y = 2.0f32;\n-    ///\n-    /// assert_eq!(x.min(y), x);\n-    /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn min(self, other: f32) -> f32 {\n-        num::Float::min(self, other)\n-    }\n-\n     /// The positive difference of two numbers.\n     ///\n     /// * If `self <= other`: `0:0`\n@@ -1046,73 +859,6 @@ impl f32 {\n     pub fn atanh(self) -> f32 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n-\n-    /// Raw transmutation to `u32`.\n-    ///\n-    /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms.\n-    ///\n-    /// See `from_bits` for some discussion of the portability of this operation\n-    /// (there are almost no issues).\n-    ///\n-    /// Note that this function is distinct from `as` casting, which attempts to\n-    /// preserve the *numeric* value, and not the bitwise value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_ne!((1f32).to_bits(), 1f32 as u32); // to_bits() is not casting!\n-    /// assert_eq!((12.5f32).to_bits(), 0x41480000);\n-    ///\n-    /// ```\n-    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn to_bits(self) -> u32 {\n-        num::Float::to_bits(self)\n-    }\n-\n-    /// Raw transmutation from `u32`.\n-    ///\n-    /// This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n-    /// It turns out this is incredibly portable, for two reasons:\n-    ///\n-    /// * Floats and Ints have the same endianness on all supported platforms.\n-    /// * IEEE-754 very precisely specifies the bit layout of floats.\n-    ///\n-    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n-    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n-    /// (notably x86 and ARM) picked the interpretation that was ultimately\n-    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n-    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n-    ///\n-    /// Rather than trying to preserve signaling-ness cross-platform, this\n-    /// implementation favours preserving the exact bits. This means that\n-    /// any payloads encoded in NaNs will be preserved even if the result of\n-    /// this method is sent over the network from an x86 machine to a MIPS one.\n-    ///\n-    /// If the results of this method are only manipulated by the same\n-    /// architecture that produced them, then there is no portability concern.\n-    ///\n-    /// If the input isn't NaN, then there is no portability concern.\n-    ///\n-    /// If you don't care about signalingness (very likely), then there is no\n-    /// portability concern.\n-    ///\n-    /// Note that this function is distinct from `as` casting, which attempts to\n-    /// preserve the *numeric* value, and not the bitwise value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::f32;\n-    /// let v = f32::from_bits(0x41480000);\n-    /// let difference = (v - 12.5).abs();\n-    /// assert!(difference <= 1e-5);\n-    /// ```\n-    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn from_bits(v: u32) -> Self {\n-        num::Float::from_bits(v)\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "a7e63f59b1c67369e8bb1b1009bc950c813b95d7", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 20, "deletions": 282, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -19,10 +19,12 @@\n #![allow(missing_docs)]\n \n #[cfg(not(test))]\n-use core::num;\n+#[cfg(stage0)]\n+use core::num::Float;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n+#[cfg(stage0)]\n use num::FpCategory;\n #[cfg(not(test))]\n use sys::cmath;\n@@ -39,106 +41,11 @@ pub use core::f64::{MIN, MIN_POSITIVE, MAX};\n pub use core::f64::consts;\n \n #[cfg(not(test))]\n-#[lang = \"f64\"]\n+#[cfg_attr(stage0, lang = \"f64\")]\n+#[cfg_attr(not(stage0), lang = \"f64_runtime\")]\n impl f64 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n-    ///\n-    /// ```\n-    /// use std::f64;\n-    ///\n-    /// let nan = f64::NAN;\n-    /// let f = 7.0_f64;\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// assert!(!f.is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_nan(self) -> bool { num::Float::is_nan(self) }\n-\n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n-    ///\n-    /// ```\n-    /// use std::f64;\n-    ///\n-    /// let f = 7.0f64;\n-    /// let inf = f64::INFINITY;\n-    /// let neg_inf = f64::NEG_INFINITY;\n-    /// let nan = f64::NAN;\n-    ///\n-    /// assert!(!f.is_infinite());\n-    /// assert!(!nan.is_infinite());\n-    ///\n-    /// assert!(inf.is_infinite());\n-    /// assert!(neg_inf.is_infinite());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n-\n-    /// Returns `true` if this number is neither infinite nor `NaN`.\n-    ///\n-    /// ```\n-    /// use std::f64;\n-    ///\n-    /// let f = 7.0f64;\n-    /// let inf: f64 = f64::INFINITY;\n-    /// let neg_inf: f64 = f64::NEG_INFINITY;\n-    /// let nan: f64 = f64::NAN;\n-    ///\n-    /// assert!(f.is_finite());\n-    ///\n-    /// assert!(!nan.is_finite());\n-    /// assert!(!inf.is_finite());\n-    /// assert!(!neg_inf.is_finite());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_finite(self) -> bool { num::Float::is_finite(self) }\n-\n-    /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal][subnormal], or `NaN`.\n-    ///\n-    /// ```\n-    /// use std::f64;\n-    ///\n-    /// let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308f64\n-    /// let max = f64::MAX;\n-    /// let lower_than_min = 1.0e-308_f64;\n-    /// let zero = 0.0f64;\n-    ///\n-    /// assert!(min.is_normal());\n-    /// assert!(max.is_normal());\n-    ///\n-    /// assert!(!zero.is_normal());\n-    /// assert!(!f64::NAN.is_normal());\n-    /// assert!(!f64::INFINITY.is_normal());\n-    /// // Values between `0` and `min` are Subnormal.\n-    /// assert!(!lower_than_min.is_normal());\n-    /// ```\n-    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_normal(self) -> bool { num::Float::is_normal(self) }\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    ///\n-    /// ```\n-    /// use std::num::FpCategory;\n-    /// use std::f64;\n-    ///\n-    /// let num = 12.4_f64;\n-    /// let inf = f64::INFINITY;\n-    ///\n-    /// assert_eq!(num.classify(), FpCategory::Normal);\n-    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn classify(self) -> FpCategory { num::Float::classify(self) }\n+    #[cfg(stage0)]\n+    f64_core_methods!();\n \n     /// Returns the largest integer less than or equal to a number.\n     ///\n@@ -235,7 +142,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn abs(self) -> f64 { num::Float::abs(self) }\n+    pub fn abs(self) -> f64 {\n+        unsafe { intrinsics::fabsf64(self) }\n+    }\n \n     /// Returns a number that represents the sign of `self`.\n     ///\n@@ -255,45 +164,13 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn signum(self) -> f64 { num::Float::signum(self) }\n-\n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n-    /// positive sign bit and positive infinity.\n-    ///\n-    /// ```\n-    /// let f = 7.0_f64;\n-    /// let g = -7.0_f64;\n-    ///\n-    /// assert!(f.is_sign_positive());\n-    /// assert!(!g.is_sign_positive());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_sign_positive(self) -> bool { num::Float::is_sign_positive(self) }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n-    #[inline]\n-    pub fn is_positive(self) -> bool { num::Float::is_sign_positive(self) }\n-\n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n-    /// negative sign bit and negative infinity.\n-    ///\n-    /// ```\n-    /// let f = 7.0_f64;\n-    /// let g = -7.0_f64;\n-    ///\n-    /// assert!(!f.is_sign_negative());\n-    /// assert!(g.is_sign_negative());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_sign_negative(self) -> bool { num::Float::is_sign_negative(self) }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n-    #[inline]\n-    pub fn is_negative(self) -> bool { num::Float::is_sign_negative(self) }\n+    pub fn signum(self) -> f64 {\n+        if self.is_nan() {\n+            NAN\n+        } else {\n+            unsafe { intrinsics::copysignf64(1.0, self) }\n+        }\n+    }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n@@ -365,18 +242,6 @@ impl f64 {\n         }\n     }\n \n-    /// Takes the reciprocal (inverse) of a number, `1/x`.\n-    ///\n-    /// ```\n-    /// let x = 2.0_f64;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn recip(self) -> f64 { num::Float::recip(self) }\n-\n     /// Raises a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n@@ -389,7 +254,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }\n+    pub fn powi(self, n: i32) -> f64 {\n+        unsafe { intrinsics::powif64(self, n) }\n+    }\n \n     /// Raises a number to a floating point power.\n     ///\n@@ -535,68 +402,6 @@ impl f64 {\n         self.log_wrapper(|n| { unsafe { intrinsics::log10f64(n) } })\n     }\n \n-    /// Converts radians to degrees.\n-    ///\n-    /// ```\n-    /// use std::f64::consts;\n-    ///\n-    /// let angle = consts::PI;\n-    ///\n-    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }\n-\n-    /// Converts degrees to radians.\n-    ///\n-    /// ```\n-    /// use std::f64::consts;\n-    ///\n-    /// let angle = 180.0_f64;\n-    ///\n-    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn to_radians(self) -> f64 { num::Float::to_radians(self) }\n-\n-    /// Returns the maximum of the two numbers.\n-    ///\n-    /// ```\n-    /// let x = 1.0_f64;\n-    /// let y = 2.0_f64;\n-    ///\n-    /// assert_eq!(x.max(y), y);\n-    /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn max(self, other: f64) -> f64 {\n-        num::Float::max(self, other)\n-    }\n-\n-    /// Returns the minimum of the two numbers.\n-    ///\n-    /// ```\n-    /// let x = 1.0_f64;\n-    /// let y = 2.0_f64;\n-    ///\n-    /// assert_eq!(x.min(y), x);\n-    /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn min(self, other: f64) -> f64 {\n-        num::Float::min(self, other)\n-    }\n-\n     /// The positive difference of two numbers.\n     ///\n     /// * If `self <= other`: `0:0`\n@@ -1000,73 +805,6 @@ impl f64 {\n             }\n         }\n     }\n-\n-    /// Raw transmutation to `u64`.\n-    ///\n-    /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms.\n-    ///\n-    /// See `from_bits` for some discussion of the portability of this operation\n-    /// (there are almost no issues).\n-    ///\n-    /// Note that this function is distinct from `as` casting, which attempts to\n-    /// preserve the *numeric* value, and not the bitwise value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert!((1f64).to_bits() != 1f64 as u64); // to_bits() is not casting!\n-    /// assert_eq!((12.5f64).to_bits(), 0x4029000000000000);\n-    ///\n-    /// ```\n-    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn to_bits(self) -> u64 {\n-        num::Float::to_bits(self)\n-    }\n-\n-    /// Raw transmutation from `u64`.\n-    ///\n-    /// This is currently identical to `transmute::<u64, f64>(v)` on all platforms.\n-    /// It turns out this is incredibly portable, for two reasons:\n-    ///\n-    /// * Floats and Ints have the same endianness on all supported platforms.\n-    /// * IEEE-754 very precisely specifies the bit layout of floats.\n-    ///\n-    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n-    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n-    /// (notably x86 and ARM) picked the interpretation that was ultimately\n-    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n-    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n-    ///\n-    /// Rather than trying to preserve signaling-ness cross-platform, this\n-    /// implementation favours preserving the exact bits. This means that\n-    /// any payloads encoded in NaNs will be preserved even if the result of\n-    /// this method is sent over the network from an x86 machine to a MIPS one.\n-    ///\n-    /// If the results of this method are only manipulated by the same\n-    /// architecture that produced them, then there is no portability concern.\n-    ///\n-    /// If the input isn't NaN, then there is no portability concern.\n-    ///\n-    /// If you don't care about signalingness (very likely), then there is no\n-    /// portability concern.\n-    ///\n-    /// Note that this function is distinct from `as` casting, which attempts to\n-    /// preserve the *numeric* value, and not the bitwise value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::f64;\n-    /// let v = f64::from_bits(0x4029000000000000);\n-    /// let difference = (v - 12.5).abs();\n-    /// assert!(difference <= 1e-5);\n-    /// ```\n-    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn from_bits(v: u64) -> Self {\n-        num::Float::from_bits(v)\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "2c8203a3dc4bb2b99ea7ec2d547636cab866183f", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -252,14 +252,15 @@\n #![feature(collections_range)]\n #![feature(compiler_builtins_lib)]\n #![feature(const_fn)]\n-#![feature(core_float)]\n+#![cfg_attr(stage0, feature(core_float))]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(external_doc)]\n #![feature(fs_read_write)]\n #![feature(fixed_size_array)]\n #![feature(float_from_str_radix)]\n+#![cfg_attr(stage0, feature(float_internals))]\n #![feature(fn_traits)]\n #![feature(fnbox)]\n #![cfg_attr(stage0, feature(generic_param_attrs))]"}, {"sha": "fe7e058091ed5fe1c6cf871817f879892f5ead2d", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -876,21 +876,7 @@ impl Hash for Wtf8 {\n }\n \n impl Wtf8 {\n-    pub fn is_ascii(&self) -> bool {\n-        self.bytes.is_ascii()\n-    }\n-    pub fn to_ascii_uppercase(&self) -> Wtf8Buf {\n-        Wtf8Buf { bytes: self.bytes.to_ascii_uppercase() }\n-    }\n-    pub fn to_ascii_lowercase(&self) -> Wtf8Buf {\n-        Wtf8Buf { bytes: self.bytes.to_ascii_lowercase() }\n-    }\n-    pub fn eq_ignore_ascii_case(&self, other: &Wtf8) -> bool {\n-        self.bytes.eq_ignore_ascii_case(&other.bytes)\n-    }\n-\n     pub fn make_ascii_uppercase(&mut self) { self.bytes.make_ascii_uppercase() }\n-    pub fn make_ascii_lowercase(&mut self) { self.bytes.make_ascii_lowercase() }\n }\n \n #[cfg(test)]"}, {"sha": "0a0f9ce4bd10eb878a4b4a82dafdd4eea0085735", "filename": "src/test/compile-fail/single-primitive-inherent-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -15,7 +15,7 @@\n #![no_std]\n \n // OK\n-#[lang = \"str\"]\n+#[lang = \"str_alloc\"]\n impl str {}\n \n impl str {"}, {"sha": "ee0a5c1aa1b5eb88e1ee810e56ffbf9f1f9d24cb", "filename": "src/test/rustdoc/issue-23511.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Frustdoc%2Fissue-23511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Frustdoc%2Fissue-23511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-23511.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -14,7 +14,7 @@\n pub mod str {\n     #![doc(primitive = \"str\")]\n \n-    #[lang = \"str\"]\n+    #[lang = \"str_alloc\"]\n     impl str {\n         // @has search-index.js foo\n         pub fn foo(&self) {}"}, {"sha": "f7aaab4242c0fab7bb6faf104d08cdd58f387df1", "filename": "src/test/ui/impl-trait/method-suggestion-no-duplication.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fui%2Fimpl-trait%2Fmethod-suggestion-no-duplication.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fui%2Fimpl-trait%2Fmethod-suggestion-no-duplication.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmethod-suggestion-no-duplication.stderr?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -8,10 +8,8 @@ LL |     foo(|s| s.is_empty());\n    |               ^^^^^^^^\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n-   = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n+   = note: the following trait defines an item `is_empty`, perhaps you need to implement it:\n            candidate #1: `std::iter::ExactSizeIterator`\n-           candidate #2: `core::slice::SliceExt`\n-           candidate #3: `core::str::StrExt`\n \n error: aborting due to previous error\n "}, {"sha": "090ff817eb0f2cf89321767645756f61836cd6ab", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -48,13 +48,13 @@ macro_rules! fake_anon_field_expr {\n \n macro_rules! real_method_stmt {\n      () => {\n-          2.0.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+          2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n      }\n }\n \n macro_rules! real_method_expr {\n      () => {\n-          2.0.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+          2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n      }\n }\n "}, {"sha": "284960d2f6e154135b7fa33dcd5cce1b5a221b5c", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -25,17 +25,17 @@ LL |           (1).0 //~ ERROR doesn't have fields\n LL |     fake_anon_field_stmt!();\n    |     ------------------------ in this macro invocation\n \n-error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n   --> $DIR/macro-backtrace-invalid-internals.rs:51:15\n    |\n-LL |           2.0.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n-   |               ^^^^\n+LL |           2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n+   |               ^^^^^\n ...\n LL |     real_method_stmt!();\n    |     -------------------- in this macro invocation\n help: you must specify a concrete type for this numeric value, like `f32`\n    |\n-LL |           2.0_f32.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+LL |           2.0_f32.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n    |           ^^^^^^^\n \n error[E0599]: no method named `fake` found for type `{integer}` in the current scope\n@@ -65,17 +65,17 @@ LL |           (1).0 //~ ERROR doesn't have fields\n LL |     let _ = fake_anon_field_expr!();\n    |             ----------------------- in this macro invocation\n \n-error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n   --> $DIR/macro-backtrace-invalid-internals.rs:57:15\n    |\n-LL |           2.0.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n-   |               ^^^^\n+LL |           2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n+   |               ^^^^^\n ...\n LL |     let _ = real_method_expr!();\n    |             ------------------- in this macro invocation\n help: you must specify a concrete type for this numeric value, like `f32`\n    |\n-LL |           2.0_f32.powi(2) //~ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+LL |           2.0_f32.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n    |           ^^^^^^^\n \n error: aborting due to 8 previous errors"}, {"sha": "2e452f9671f380fd21b3b9e073359a80579c1ba4", "filename": "src/test/ui/suggestions/method-on-ambiguous-numeric-type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.rs?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n fn main() {\n-    let x = 2.0.powi(2);\n-    //~^ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+    let x = 2.0.recip();\n+    //~^ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n     let y = 2.0;\n-    let x = y.powi(2);\n-    //~^ ERROR can't call method `powi` on ambiguous numeric type `{float}`\n+    let x = y.recip();\n+    //~^ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n     println!(\"{:?}\", x);\n }"}, {"sha": "477b4c3821d51bc2f9aa5cc982a677a3919d59ee", "filename": "src/test/ui/suggestions/method-on-ambiguous-numeric-type.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5616e1f18abb46071581d096994a0ff6581e3f9/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.stderr?ref=d5616e1f18abb46071581d096994a0ff6581e3f9", "patch": "@@ -1,18 +1,18 @@\n-error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n   --> $DIR/method-on-ambiguous-numeric-type.rs:12:17\n    |\n-LL |     let x = 2.0.powi(2);\n-   |                 ^^^^\n+LL |     let x = 2.0.recip();\n+   |                 ^^^^^\n help: you must specify a concrete type for this numeric value, like `f32`\n    |\n-LL |     let x = 2.0_f32.powi(2);\n+LL |     let x = 2.0_f32.recip();\n    |             ^^^^^^^\n \n-error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n   --> $DIR/method-on-ambiguous-numeric-type.rs:15:15\n    |\n-LL |     let x = y.powi(2);\n-   |               ^^^^\n+LL |     let x = y.recip();\n+   |               ^^^^^\n help: you must specify a type for this binding, like `f32`\n    |\n LL |     let y: f32 = 2.0;"}]}