{"sha": "fe792d9f7dceac7ddb38524a15031c0ea68730fa", "node_id": "C_kwDOAAsO6NoAKGZlNzkyZDlmN2RjZWFjN2RkYjM4NTI0YTE1MDMxYzBlYTY4NzMwZmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-23T04:45:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-23T04:45:14Z"}, "message": "Auto merge of #10809 - nyurik:match-unsafe, r=Jarcho\n\nFix missing block for unsafe code\n\nIf a block is declared as unsafe, it needs an extra layer of curly braces around it.\n\nFixes #10808\n\nThis code adds handling for `UnsafeSource::UserProvided` block, i.e. `unsafe { ... }`. Note that we do not handle the `UnsafeSource::CompilerGenerated` as it seems to not be possible to generate that with the user code (?), or at least doesn't seem to be needed to be handled explicitly.\n\nThere is an issue with this code: it does not add an extra indentation for the unsafe blocks. I think this is a relatively minor concern for such an edge case, and should probably be done by a separate PR (fixing compile bug is more important than getting styling perfect especially when `rustfmt` will fix it anyway)\n\n```rust\n// original code\nunsafe {\n  ...\n}\n\n// code that is now generated by this PR\n{ unsafe {\n  ...\n} }\n\n// what we would ideally like to get\n{\n  unsafe {\n    ...\n  }\n}\n```\n\nchangelog: [`single_match`](https://rust-lang.github.io/rust-clippy/master/#single_match): Fix suggestion for `unsafe` blocks", "tree": {"sha": "34527cd378320963dcd2e6eb8800a91f61208d6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34527cd378320963dcd2e6eb8800a91f61208d6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe792d9f7dceac7ddb38524a15031c0ea68730fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe792d9f7dceac7ddb38524a15031c0ea68730fa", "html_url": "https://github.com/rust-lang/rust/commit/fe792d9f7dceac7ddb38524a15031c0ea68730fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe792d9f7dceac7ddb38524a15031c0ea68730fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec2f2d5e47c5bc8527037c190c06227cc01c9ca2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec2f2d5e47c5bc8527037c190c06227cc01c9ca2", "html_url": "https://github.com/rust-lang/rust/commit/ec2f2d5e47c5bc8527037c190c06227cc01c9ca2"}, {"sha": "ed935de08761ef3d463b7770f9c5d8b7422bed82", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed935de08761ef3d463b7770f9c5d8b7422bed82", "html_url": "https://github.com/rust-lang/rust/commit/ed935de08761ef3d463b7770f9c5d8b7422bed82"}], "stats": {"total": 650, "additions": 640, "deletions": 10}, "files": [{"sha": "582337b47e813ed6e5cedab6f54df7ee1b2a2ef7", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe792d9f7dceac7ddb38524a15031c0ea68730fa/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe792d9f7dceac7ddb38524a15031c0ea68730fa/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=fe792d9f7dceac7ddb38524a15031c0ea68730fa", "patch": "@@ -4,7 +4,7 @@\n \n use rustc_data_structures::sync::Lrc;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::{BlockCheckMode, Expr, ExprKind, UnsafeSource};\n use rustc_lint::{LateContext, LintContext};\n use rustc_session::Session;\n use rustc_span::source_map::{original_sp, SourceMap};\n@@ -71,11 +71,16 @@ pub fn expr_block<T: LintContext>(\n     app: &mut Applicability,\n ) -> String {\n     let (code, from_macro) = snippet_block_with_context(cx, expr.span, outer, default, indent_relative_to, app);\n-    if from_macro {\n-        format!(\"{{ {code} }}\")\n-    } else if let ExprKind::Block(_, _) = expr.kind {\n+    if !from_macro &&\n+        let ExprKind::Block(block, _) = expr.kind &&\n+        block.rules != BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided)\n+    {\n         format!(\"{code}\")\n     } else {\n+        // FIXME: add extra indent for the unsafe blocks:\n+        //     original code:   unsafe { ... }\n+        //     result code:     { unsafe { ... } }\n+        //     desired code:    {\\n  unsafe { ... }\\n}\n         format!(\"{{ {code} }}\")\n     }\n }"}, {"sha": "77a2cf3b991f6064fd506b67ce10979144455dbd", "filename": "tests/ui/single_match.fixed", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.fixed?ref=fe792d9f7dceac7ddb38524a15031c0ea68730fa", "patch": "@@ -0,0 +1,209 @@\n+//@run-rustfix\n+#![warn(clippy::single_match)]\n+#![allow(unused, clippy::uninlined_format_args, clippy::redundant_pattern_matching)]\n+fn dummy() {}\n+\n+fn single_match() {\n+    let x = Some(1u8);\n+\n+    if let Some(y) = x {\n+        println!(\"{:?}\", y);\n+    };\n+\n+    let x = Some(1u8);\n+    if let Some(y) = x { println!(\"{:?}\", y) }\n+\n+    let z = (1u8, 1u8);\n+    if let (2..=3, 7..=9) = z { dummy() };\n+\n+    // Not linted (pattern guards used)\n+    match x {\n+        Some(y) if y == 0 => println!(\"{:?}\", y),\n+        _ => (),\n+    }\n+\n+    // Not linted (no block with statements in the single arm)\n+    match z {\n+        (2..=3, 7..=9) => println!(\"{:?}\", z),\n+        _ => println!(\"nope\"),\n+    }\n+}\n+\n+enum Foo {\n+    Bar,\n+    Baz(u8),\n+}\n+use std::borrow::Cow;\n+use Foo::*;\n+\n+fn single_match_know_enum() {\n+    let x = Some(1u8);\n+    let y: Result<_, i8> = Ok(1i8);\n+\n+    if let Some(y) = x { dummy() };\n+\n+    if let Ok(y) = y { dummy() };\n+\n+    let c = Cow::Borrowed(\"\");\n+\n+    if let Cow::Borrowed(..) = c { dummy() };\n+\n+    let z = Foo::Bar;\n+    // no warning\n+    match z {\n+        Bar => println!(\"42\"),\n+        Baz(_) => (),\n+    }\n+\n+    match z {\n+        Baz(_) => println!(\"42\"),\n+        Bar => (),\n+    }\n+}\n+\n+// issue #173\n+fn if_suggestion() {\n+    let x = \"test\";\n+    if x == \"test\" { println!() }\n+\n+    #[derive(PartialEq, Eq)]\n+    enum Foo {\n+        A,\n+        B,\n+        C(u32),\n+    }\n+\n+    let x = Foo::A;\n+    if x == Foo::A { println!() }\n+\n+    const FOO_C: Foo = Foo::C(0);\n+    if x == FOO_C { println!() }\n+\n+    if x == Foo::A { println!() }\n+\n+    let x = &x;\n+    if x == &Foo::A { println!() }\n+\n+    enum Bar {\n+        A,\n+        B,\n+    }\n+    impl PartialEq for Bar {\n+        fn eq(&self, rhs: &Self) -> bool {\n+            matches!((self, rhs), (Self::A, Self::A) | (Self::B, Self::B))\n+        }\n+    }\n+    impl Eq for Bar {}\n+\n+    let x = Bar::A;\n+    if let Bar::A = x { println!() }\n+\n+    // issue #7038\n+    struct X;\n+    let x = Some(X);\n+    if let None = x { println!() };\n+}\n+\n+// See: issue #8282\n+fn ranges() {\n+    enum E {\n+        V,\n+    }\n+    let x = (Some(E::V), Some(42));\n+\n+    // Don't lint, because the `E` enum can be extended with additional fields later. Thus, the\n+    // proposed replacement to `if let Some(E::V)` may hide non-exhaustive warnings that appeared\n+    // because of `match` construction.\n+    match x {\n+        (Some(E::V), _) => {},\n+        (None, _) => {},\n+    }\n+\n+    // lint\n+    if let (Some(_), _) = x {}\n+\n+    // lint\n+    if let (Some(E::V), _) = x { todo!() }\n+\n+    // lint\n+    if let (.., Some(E::V), _) = (Some(42), Some(E::V), Some(42)) {}\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (.., Some(E::V), _) => {},\n+        (.., None, _) => {},\n+    }\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (Some(E::V), ..) => {},\n+        (None, ..) => {},\n+    }\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (_, Some(E::V), ..) => {},\n+        (_, None, ..) => {},\n+    }\n+}\n+\n+fn skip_type_aliases() {\n+    enum OptionEx {\n+        Some(i32),\n+        None,\n+    }\n+    enum ResultEx {\n+        Err(i32),\n+        Ok(i32),\n+    }\n+\n+    use OptionEx::{None, Some};\n+    use ResultEx::{Err, Ok};\n+\n+    // don't lint\n+    match Err(42) {\n+        Ok(_) => dummy(),\n+        Err(_) => (),\n+    };\n+\n+    // don't lint\n+    match Some(1i32) {\n+        Some(_) => dummy(),\n+        None => (),\n+    };\n+}\n+\n+macro_rules! single_match {\n+    ($num:literal) => {\n+        match $num {\n+            15 => println!(\"15\"),\n+            _ => (),\n+        }\n+    };\n+}\n+\n+fn main() {\n+    single_match!(5);\n+\n+    // Don't lint\n+    let _ = match Some(0) {\n+        #[cfg(feature = \"foo\")]\n+        Some(10) => 11,\n+        Some(x) => x,\n+        _ => 0,\n+    };\n+}\n+\n+fn issue_10808(bar: Option<i32>) {\n+    if let Some(v) = bar { unsafe {\n+        let r = &v as *const i32;\n+        println!(\"{}\", *r);\n+    } }\n+\n+    if let Some(v) = bar {\n+        unsafe {\n+            let r = &v as *const i32;\n+            println!(\"{}\", *r);\n+        }\n+    }\n+}"}, {"sha": "8d0ab5b99ad51e84e8b9066d277acf3cc12b3c9e", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=fe792d9f7dceac7ddb38524a15031c0ea68730fa", "patch": "@@ -1,6 +1,6 @@\n+//@run-rustfix\n #![warn(clippy::single_match)]\n-#![allow(clippy::uninlined_format_args)]\n-\n+#![allow(unused, clippy::uninlined_format_args, clippy::redundant_pattern_matching)]\n fn dummy() {}\n \n fn single_match() {\n@@ -244,3 +244,24 @@ fn main() {\n         _ => 0,\n     };\n }\n+\n+fn issue_10808(bar: Option<i32>) {\n+    match bar {\n+        Some(v) => unsafe {\n+            let r = &v as *const i32;\n+            println!(\"{}\", *r);\n+        },\n+        _ => {},\n+    }\n+\n+    match bar {\n+        #[rustfmt::skip]\n+        Some(v) => {\n+            unsafe {\n+                let r = &v as *const i32;\n+                println!(\"{}\", *r);\n+            }\n+        },\n+        _ => {},\n+    }\n+}"}, {"sha": "dad66e2ab2ec3aa7c352945efc993691362fdf86", "filename": "tests/ui/single_match.stderr", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.stderr?ref=fe792d9f7dceac7ddb38524a15031c0ea68730fa", "patch": "@@ -155,5 +155,47 @@ LL | |         (..) => {},\n LL | |     }\n    | |_____^ help: try this: `if let (.., Some(E::V), _) = (Some(42), Some(E::V), Some(42)) {}`\n \n-error: aborting due to 16 previous errors\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:249:5\n+   |\n+LL | /     match bar {\n+LL | |         Some(v) => unsafe {\n+LL | |             let r = &v as *const i32;\n+LL | |             println!(\"{}\", *r);\n+LL | |         },\n+LL | |         _ => {},\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(v) = bar { unsafe {\n+LL +         let r = &v as *const i32;\n+LL +         println!(\"{}\", *r);\n+LL +     } }\n+   |\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:257:5\n+   |\n+LL | /     match bar {\n+LL | |         #[rustfmt::skip]\n+LL | |         Some(v) => {\n+LL | |             unsafe {\n+...  |\n+LL | |         _ => {},\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(v) = bar {\n+LL +         unsafe {\n+LL +             let r = &v as *const i32;\n+LL +             println!(\"{}\", *r);\n+LL +         }\n+LL +     }\n+   |\n+\n+error: aborting due to 18 previous errors\n "}, {"sha": "f88498655a41850601deca91cf2fd026c7f2f278", "filename": "tests/ui/single_match_else.fixed", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.fixed?ref=fe792d9f7dceac7ddb38524a15031c0ea68730fa", "patch": "@@ -0,0 +1,173 @@\n+//@run-rustfix\n+//@aux-build: proc_macros.rs\n+#![warn(clippy::single_match_else)]\n+#![allow(unused, clippy::needless_return, clippy::no_effect, clippy::uninlined_format_args)]\n+extern crate proc_macros;\n+use proc_macros::with_span;\n+\n+enum ExprNode {\n+    ExprAddrOf,\n+    Butterflies,\n+    Unicorns,\n+}\n+\n+static NODE: ExprNode = ExprNode::Unicorns;\n+\n+fn unwrap_addr() -> Option<&'static ExprNode> {\n+    let _ = if let ExprNode::ExprAddrOf = ExprNode::Butterflies { Some(&NODE) } else {\n+        let x = 5;\n+        None\n+    };\n+\n+    // Don't lint\n+    with_span!(span match ExprNode::Butterflies {\n+        ExprNode::ExprAddrOf => Some(&NODE),\n+        _ => {\n+            let x = 5;\n+            None\n+        },\n+    })\n+}\n+\n+macro_rules! unwrap_addr {\n+    ($expression:expr) => {\n+        match $expression {\n+            ExprNode::ExprAddrOf => Some(&NODE),\n+            _ => {\n+                let x = 5;\n+                None\n+            },\n+        }\n+    };\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    unwrap_addr!(ExprNode::Unicorns);\n+\n+    //\n+    // don't lint single exprs/statements\n+    //\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => return,\n+    }\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            return\n+        },\n+    }\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            return;\n+        },\n+    }\n+\n+    //\n+    // lint multiple exprs/statements \"else\" blocks\n+    //\n+\n+    // lint here\n+    if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+        println!(\"else block\");\n+        return\n+    }\n+\n+    // lint here\n+    if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+        println!(\"else block\");\n+        return;\n+    }\n+\n+    // lint here\n+    use std::convert::Infallible;\n+    if let Ok(a) = Result::<i32, Infallible>::Ok(1) { println!(\"${:?}\", a) } else {\n+        println!(\"else block\");\n+        return;\n+    }\n+\n+    use std::borrow::Cow;\n+    if let Cow::Owned(a) = Cow::from(\"moo\") { println!(\"${:?}\", a) } else {\n+        println!(\"else block\");\n+        return;\n+    }\n+}\n+\n+fn issue_10808(bar: Option<i32>) {\n+    if let Some(v) = bar { unsafe {\n+        let r = &v as *const i32;\n+        println!(\"{}\", *r);\n+    } } else {\n+        println!(\"None1\");\n+        println!(\"None2\");\n+    }\n+\n+    if let Some(v) = bar {\n+        println!(\"Some\");\n+        println!(\"{v}\");\n+    } else { unsafe {\n+        let v = 0;\n+        let r = &v as *const i32;\n+        println!(\"{}\", *r);\n+    } }\n+\n+    if let Some(v) = bar { unsafe {\n+        let r = &v as *const i32;\n+        println!(\"{}\", *r);\n+    } } else { unsafe {\n+        let v = 0;\n+        let r = &v as *const i32;\n+        println!(\"{}\", *r);\n+    } }\n+\n+    if let Some(v) = bar {\n+        unsafe {\n+            let r = &v as *const i32;\n+            println!(\"{}\", *r);\n+        }\n+    } else {\n+        println!(\"None\");\n+        println!(\"None\");\n+    }\n+\n+    match bar {\n+        Some(v) => {\n+            println!(\"Some\");\n+            println!(\"{v}\");\n+        },\n+        #[rustfmt::skip]\n+        None => {\n+            unsafe {\n+                let v = 0;\n+                let r = &v as *const i32;\n+                println!(\"{}\", *r);\n+            }\n+        },\n+    }\n+\n+    match bar {\n+        #[rustfmt::skip]\n+        Some(v) => {\n+            unsafe {\n+                let r = &v as *const i32;\n+                println!(\"{}\", *r);\n+            }\n+        },\n+        #[rustfmt::skip]\n+        None => {\n+            unsafe {\n+                let v = 0;\n+                let r = &v as *const i32;\n+                println!(\"{}\", *r);\n+            }\n+        },\n+    }\n+}"}, {"sha": "b34b95539190cdbd4389364a6485e00afa3edc05", "filename": "tests/ui/single_match_else.rs", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.rs?ref=fe792d9f7dceac7ddb38524a15031c0ea68730fa", "patch": "@@ -1,7 +1,7 @@\n+//@run-rustfix\n //@aux-build: proc_macros.rs\n #![warn(clippy::single_match_else)]\n-#![allow(clippy::needless_return, clippy::no_effect, clippy::uninlined_format_args)]\n-\n+#![allow(unused, clippy::needless_return, clippy::no_effect, clippy::uninlined_format_args)]\n extern crate proc_macros;\n use proc_macros::with_span;\n \n@@ -115,3 +115,87 @@ fn main() {\n         }\n     }\n }\n+\n+fn issue_10808(bar: Option<i32>) {\n+    match bar {\n+        Some(v) => unsafe {\n+            let r = &v as *const i32;\n+            println!(\"{}\", *r);\n+        },\n+        None => {\n+            println!(\"None1\");\n+            println!(\"None2\");\n+        },\n+    }\n+\n+    match bar {\n+        Some(v) => {\n+            println!(\"Some\");\n+            println!(\"{v}\");\n+        },\n+        None => unsafe {\n+            let v = 0;\n+            let r = &v as *const i32;\n+            println!(\"{}\", *r);\n+        },\n+    }\n+\n+    match bar {\n+        Some(v) => unsafe {\n+            let r = &v as *const i32;\n+            println!(\"{}\", *r);\n+        },\n+        None => unsafe {\n+            let v = 0;\n+            let r = &v as *const i32;\n+            println!(\"{}\", *r);\n+        },\n+    }\n+\n+    match bar {\n+        #[rustfmt::skip]\n+        Some(v) => {\n+            unsafe {\n+                let r = &v as *const i32;\n+                println!(\"{}\", *r);\n+            }\n+        },\n+        None => {\n+            println!(\"None\");\n+            println!(\"None\");\n+        },\n+    }\n+\n+    match bar {\n+        Some(v) => {\n+            println!(\"Some\");\n+            println!(\"{v}\");\n+        },\n+        #[rustfmt::skip]\n+        None => {\n+            unsafe {\n+                let v = 0;\n+                let r = &v as *const i32;\n+                println!(\"{}\", *r);\n+            }\n+        },\n+    }\n+\n+    match bar {\n+        #[rustfmt::skip]\n+        Some(v) => {\n+            unsafe {\n+                let r = &v as *const i32;\n+                println!(\"{}\", *r);\n+            }\n+        },\n+        #[rustfmt::skip]\n+        None => {\n+            unsafe {\n+                let v = 0;\n+                let r = &v as *const i32;\n+                println!(\"{}\", *r);\n+            }\n+        },\n+    }\n+}"}, {"sha": "228236f3bb8e84723d79d270f15eefe2599a1491", "filename": "tests/ui/single_match_else.stderr", "status": "modified", "additions": 97, "deletions": 1, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe792d9f7dceac7ddb38524a15031c0ea68730fa/tests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.stderr?ref=fe792d9f7dceac7ddb38524a15031c0ea68730fa", "patch": "@@ -100,5 +100,101 @@ LL +         return;\n LL +     }\n    |\n \n-error: aborting due to 5 previous errors\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:120:5\n+   |\n+LL | /     match bar {\n+LL | |         Some(v) => unsafe {\n+LL | |             let r = &v as *const i32;\n+LL | |             println!(\"{}\", *r);\n+...  |\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(v) = bar { unsafe {\n+LL +         let r = &v as *const i32;\n+LL +         println!(\"{}\", *r);\n+LL +     } } else {\n+LL +         println!(\"None1\");\n+LL +         println!(\"None2\");\n+LL +     }\n+   |\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:131:5\n+   |\n+LL | /     match bar {\n+LL | |         Some(v) => {\n+LL | |             println!(\"Some\");\n+LL | |             println!(\"{v}\");\n+...  |\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(v) = bar {\n+LL +         println!(\"Some\");\n+LL +         println!(\"{v}\");\n+LL +     } else { unsafe {\n+LL +         let v = 0;\n+LL +         let r = &v as *const i32;\n+LL +         println!(\"{}\", *r);\n+LL +     } }\n+   |\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:143:5\n+   |\n+LL | /     match bar {\n+LL | |         Some(v) => unsafe {\n+LL | |             let r = &v as *const i32;\n+LL | |             println!(\"{}\", *r);\n+...  |\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(v) = bar { unsafe {\n+LL +         let r = &v as *const i32;\n+LL +         println!(\"{}\", *r);\n+LL +     } } else { unsafe {\n+LL +         let v = 0;\n+LL +         let r = &v as *const i32;\n+LL +         println!(\"{}\", *r);\n+LL +     } }\n+   |\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:155:5\n+   |\n+LL | /     match bar {\n+LL | |         #[rustfmt::skip]\n+LL | |         Some(v) => {\n+LL | |             unsafe {\n+...  |\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(v) = bar {\n+LL +         unsafe {\n+LL +             let r = &v as *const i32;\n+LL +             println!(\"{}\", *r);\n+LL +         }\n+LL +     } else {\n+LL +         println!(\"None\");\n+LL +         println!(\"None\");\n+LL +     }\n+   |\n+\n+error: aborting due to 9 previous errors\n "}]}