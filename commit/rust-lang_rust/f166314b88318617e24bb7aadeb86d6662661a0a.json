{"sha": "f166314b88318617e24bb7aadeb86d6662661a0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNjYzMTRiODgzMTg2MTdlMjRiYjdhYWRlYjg2ZDY2NjI2NjFhMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-22T08:06:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-22T08:06:48Z"}, "message": "Auto merge of #58995 - Centril:refactor-build-manifest, r=alexcrichton\n\nRefactor tools/build-mainfest\n\nI saw some duplication in https://github.com/rust-lang/rust/pull/58990 and got an itch... Will likely need to be rebased when that lands. Hopefully the PR should have zero semantic changes...\n\nr? @alexcrichton", "tree": {"sha": "402428f8d02b4fd10a9bda10d313c69adaad4630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/402428f8d02b4fd10a9bda10d313c69adaad4630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f166314b88318617e24bb7aadeb86d6662661a0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f166314b88318617e24bb7aadeb86d6662661a0a", "html_url": "https://github.com/rust-lang/rust/commit/f166314b88318617e24bb7aadeb86d6662661a0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f166314b88318617e24bb7aadeb86d6662661a0a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a85ec7c2c005c1c2f85050151706c6301720760a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a85ec7c2c005c1c2f85050151706c6301720760a", "html_url": "https://github.com/rust-lang/rust/commit/a85ec7c2c005c1c2f85050151706c6301720760a"}, {"sha": "83534874444f8981c540685eba1ddb8fb42999bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/83534874444f8981c540685eba1ddb8fb42999bc", "html_url": "https://github.com/rust-lang/rust/commit/83534874444f8981c540685eba1ddb8fb42999bc"}], "stats": {"total": 401, "additions": 197, "deletions": 204}, "files": [{"sha": "706fce262f0e42a2006bcbfe14afa5e1a2d76630", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 197, "deletions": 204, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/f166314b88318617e24bb7aadeb86d6662661a0a/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f166314b88318617e24bb7aadeb86d6662661a0a/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=f166314b88318617e24bb7aadeb86d6662661a0a", "patch": "@@ -10,7 +10,7 @@ use std::io::{self, Read, Write};\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n \n-static HOSTS: &'static [&'static str] = &[\n+static HOSTS: &[&str] = &[\n     \"aarch64-unknown-linux-gnu\",\n     \"arm-unknown-linux-gnueabi\",\n     \"arm-unknown-linux-gnueabihf\",\n@@ -40,7 +40,7 @@ static HOSTS: &'static [&'static str] = &[\n     \"x86_64-unknown-netbsd\",\n ];\n \n-static TARGETS: &'static [&'static str] = &[\n+static TARGETS: &[&str] = &[\n     \"aarch64-apple-ios\",\n     \"aarch64-fuchsia\",\n     \"aarch64-linux-android\",\n@@ -124,7 +124,7 @@ static TARGETS: &'static [&'static str] = &[\n     \"x86_64-unknown-redox\",\n ];\n \n-static DOCS_TARGETS: &'static [&'static str] = &[\n+static DOCS_TARGETS: &[&str] = &[\n     \"i686-apple-darwin\",\n     \"i686-pc-windows-gnu\",\n     \"i686-pc-windows-msvc\",\n@@ -135,7 +135,7 @@ static DOCS_TARGETS: &'static [&'static str] = &[\n     \"x86_64-unknown-linux-gnu\",\n ];\n \n-static MINGW: &'static [&'static str] = &[\n+static MINGW: &[&str] = &[\n     \"i686-pc-windows-gnu\",\n     \"x86_64-pc-windows-gnu\",\n ];\n@@ -162,7 +162,7 @@ struct Rename {\n     to: String,\n }\n \n-#[derive(Serialize)]\n+#[derive(Serialize, Default)]\n struct Target {\n     available: bool,\n     url: Option<String>,\n@@ -174,17 +174,7 @@ struct Target {\n }\n \n impl Target {\n-    fn unavailable() -> Target {\n-        Target {\n-            available: false,\n-            url: None,\n-            hash: None,\n-            xz_url: None,\n-            xz_hash: None,\n-            components: None,\n-            extensions: None,\n-        }\n-    }\n+    fn unavailable() -> Self { Self::default() }\n }\n \n #[derive(Serialize)]\n@@ -193,6 +183,12 @@ struct Component {\n     target: String,\n }\n \n+impl Component {\n+    fn from_str(pkg: &str, target: &str) -> Self {\n+        Self { pkg: pkg.to_string(), target: target.to_string() }\n+    }\n+}\n+\n macro_rules! t {\n     ($e:expr) => (match $e {\n         Ok(e) => e,\n@@ -310,6 +306,25 @@ fn main() {\n     }.build();\n }\n \n+enum PkgType { RustSrc, Cargo, Rls, Clippy, Rustfmt, LlvmTools, Lldb, Miri, Other }\n+\n+impl PkgType {\n+    fn from_component(component: &str) -> Self {\n+        use PkgType::*;\n+        match component {\n+            \"rust-src\" => RustSrc,\n+            \"cargo\" => Cargo,\n+            \"rls\" | \"rls-preview\" => Rls,\n+            \"clippy\" | \"clippy-preview\" => Clippy,\n+            \"rustfmt\" | \"rustfmt-preview\" => Rustfmt,\n+            \"llvm-tools\" | \"llvm-tools-preview\" => LlvmTools,\n+            \"lldb\" | \"lldb-preview\" => Lldb,\n+            \"miri\" | \"miri-preview\" => Miri,\n+            _ => Other,\n+        }\n+    }\n+}\n+\n impl Builder {\n     fn build(&mut self) {\n         self.rust_version = self.version(\"rust\", \"x86_64-unknown-linux-gnu\");\n@@ -358,39 +373,56 @@ impl Builder {\n             renames: BTreeMap::new(),\n             profiles: BTreeMap::new(),\n         };\n+        self.add_packages_to(&mut manifest);\n+        self.add_profiles_to(&mut manifest);\n+        self.add_renames_to(&mut manifest);\n+        manifest.pkg.insert(\"rust\".to_string(), self.rust_package(&manifest));\n+        manifest\n+    }\n \n-        self.package(\"rustc\", &mut manifest.pkg, HOSTS);\n-        self.package(\"cargo\", &mut manifest.pkg, HOSTS);\n-        self.package(\"rust-mingw\", &mut manifest.pkg, MINGW);\n-        self.package(\"rust-std\", &mut manifest.pkg, TARGETS);\n-        self.package(\"rust-docs\", &mut manifest.pkg, DOCS_TARGETS);\n-        self.package(\"rust-src\", &mut manifest.pkg, &[\"*\"]);\n-        self.package(\"rls-preview\", &mut manifest.pkg, HOSTS);\n-        self.package(\"clippy-preview\", &mut manifest.pkg, HOSTS);\n-        self.package(\"miri\", &mut manifest.pkg, HOSTS);\n-        self.package(\"rustfmt-preview\", &mut manifest.pkg, HOSTS);\n-        self.package(\"rust-analysis\", &mut manifest.pkg, TARGETS);\n-        self.package(\"llvm-tools-preview\", &mut manifest.pkg, TARGETS);\n-        self.package(\"lldb-preview\", &mut manifest.pkg, TARGETS);\n-\n-        self.profile(\"minimal\",\n-                     &mut manifest.profiles,\n-                     &[\"rustc\", \"cargo\", \"rust-std\", \"rust-mingw\"]);\n-        self.profile(\"default\",\n-                     &mut manifest.profiles,\n-                     &[\"rustc\", \"cargo\", \"rust-std\", \"rust-mingw\",\n-                       \"rust-docs\", \"rustfmt-preview\", \"clippy-preview\"]);\n-        self.profile(\"complete\",\n-                     &mut manifest.profiles,\n-                     &[\"rustc\", \"cargo\", \"rust-std\", \"rust-mingw\",\n-                       \"rust-docs\", \"rustfmt-preview\", \"clippy-preview\",\n-                       \"rls-preview\", \"rust-src\", \"llvm-tools-preview\",\n-                       \"lldb-preview\", \"rust-analysis\", \"miri\"]);\n-\n-        manifest.renames.insert(\"rls\".to_owned(), Rename { to: \"rls-preview\".to_owned() });\n-        manifest.renames.insert(\"rustfmt\".to_owned(), Rename { to: \"rustfmt-preview\".to_owned() });\n-        manifest.renames.insert(\"clippy\".to_owned(), Rename { to: \"clippy-preview\".to_owned() });\n+    fn add_packages_to(&mut self, manifest: &mut Manifest) {\n+        let mut package = |name, targets| self.package(name, &mut manifest.pkg, targets);\n+        package(\"rustc\", HOSTS);\n+        package(\"cargo\", HOSTS);\n+        package(\"rust-mingw\", MINGW);\n+        package(\"rust-std\", TARGETS);\n+        package(\"rust-docs\", DOCS_TARGETS);\n+        package(\"rust-src\", &[\"*\"]);\n+        package(\"rls-preview\", HOSTS);\n+        package(\"clippy-preview\", HOSTS);\n+        package(\"miri\", HOSTS);\n+        package(\"rustfmt-preview\", HOSTS);\n+        package(\"rust-analysis\", TARGETS);\n+        package(\"llvm-tools-preview\", TARGETS);\n+        package(\"lldb-preview\", TARGETS);\n+    }\n \n+    fn add_profiles_to(&mut self, manifest: &mut Manifest) {\n+        let mut profile = |name, pkgs| self.profile(name, &mut manifest.profiles, pkgs);\n+        profile(\"minimal\", &[\"rustc\", \"cargo\", \"rust-std\", \"rust-mingw\"]);\n+        profile(\"default\", &[\n+            \"rustc\", \"cargo\", \"rust-std\", \"rust-mingw\",\n+            \"rust-docs\", \"rustfmt-preview\", \"clippy-preview\"\n+        ]);\n+        profile(\"complete\", &[\n+            \"rustc\", \"cargo\", \"rust-std\", \"rust-mingw\",\n+            \"rust-docs\", \"rustfmt-preview\", \"clippy-preview\",\n+            \"rls-preview\", \"rust-src\", \"llvm-tools-preview\",\n+            \"lldb-preview\", \"rust-analysis\", \"miri\"\n+        ]);\n+    }\n+\n+    fn add_renames_to(&self, manifest: &mut Manifest) {\n+        let mut rename = |from: &str, to: &str| manifest.renames.insert(\n+            from.to_owned(),\n+            Rename { to: to.to_owned() }\n+        );\n+        rename(\"rls\", \"rls-preview\");\n+        rename(\"rustfmt\", \"rustfmt-preview\");\n+        rename(\"clippy\", \"clippy-preview\");\n+    }\n+\n+    fn rust_package(&mut self, manifest: &Manifest) -> Package {\n         let mut pkg = Package {\n             version: self.cached_version(\"rust\")\n                          .as_ref()\n@@ -400,90 +432,82 @@ impl Builder {\n             target: BTreeMap::new(),\n         };\n         for host in HOSTS {\n-            let filename = self.filename(\"rust\", host);\n-            let digest = match self.digests.remove(&filename) {\n-                Some(digest) => digest,\n-                None => {\n-                    pkg.target.insert(host.to_string(), Target::unavailable());\n-                    continue\n-                }\n-            };\n-            let xz_filename = filename.replace(\".tar.gz\", \".tar.xz\");\n-            let xz_digest = self.digests.remove(&xz_filename);\n-            let mut components = Vec::new();\n-            let mut extensions = Vec::new();\n-\n-            // rustc/rust-std/cargo/docs are all required, and so is rust-mingw\n-            // if it's available for the target.\n-            components.extend(vec![\n-                Component { pkg: \"rustc\".to_string(), target: host.to_string() },\n-                Component { pkg: \"rust-std\".to_string(), target: host.to_string() },\n-                Component { pkg: \"cargo\".to_string(), target: host.to_string() },\n-                Component { pkg: \"rust-docs\".to_string(), target: host.to_string() },\n-            ]);\n-            if host.contains(\"pc-windows-gnu\") {\n-                components.push(Component {\n-                    pkg: \"rust-mingw\".to_string(),\n-                    target: host.to_string(),\n-                });\n-            }\n-\n-            // Tools are always present in the manifest, but might be marked as unavailable if they\n-            // weren't built\n-            extensions.extend(vec![\n-                Component { pkg: \"clippy-preview\".to_string(), target: host.to_string() },\n-                Component { pkg: \"miri\".to_string(), target: host.to_string() },\n-                Component { pkg: \"rls-preview\".to_string(), target: host.to_string() },\n-                Component { pkg: \"rustfmt-preview\".to_string(), target: host.to_string() },\n-                Component { pkg: \"llvm-tools-preview\".to_string(), target: host.to_string() },\n-                Component { pkg: \"lldb-preview\".to_string(), target: host.to_string() },\n-                Component { pkg: \"rust-analysis\".to_string(), target: host.to_string() },\n-            ]);\n-\n-            for target in TARGETS {\n-                if target != host {\n-                    extensions.push(Component {\n-                        pkg: \"rust-std\".to_string(),\n-                        target: target.to_string(),\n-                    });\n-                }\n-            }\n-            extensions.push(Component {\n-                pkg: \"rust-src\".to_string(),\n-                target: \"*\".to_string(),\n-            });\n-\n-            // If the components/extensions don't actually exist for this\n-            // particular host/target combination then nix it entirely from our\n-            // lists.\n-            {\n-                let has_component = |c: &Component| {\n-                    if c.target == \"*\" {\n-                        return true\n-                    }\n-                    let pkg = match manifest.pkg.get(&c.pkg) {\n-                        Some(p) => p,\n-                        None => return false,\n-                    };\n-                    pkg.target.get(&c.target).is_some()\n-                };\n-                extensions.retain(&has_component);\n-                components.retain(&has_component);\n+            if let Some(target) = self.target_host_combination(host, &manifest) {\n+                pkg.target.insert(host.to_string(), target);\n+            } else {\n+                pkg.target.insert(host.to_string(), Target::unavailable());\n+                continue\n             }\n+        }\n+        pkg\n+    }\n \n-            pkg.target.insert(host.to_string(), Target {\n-                available: true,\n-                url: Some(self.url(&filename)),\n-                hash: Some(digest),\n-                xz_url: xz_digest.as_ref().map(|_| self.url(&xz_filename)),\n-                xz_hash: xz_digest,\n-                components: Some(components),\n-                extensions: Some(extensions),\n-            });\n+    fn target_host_combination(&mut self, host: &str, manifest: &Manifest) -> Option<Target> {\n+        let filename = self.filename(\"rust\", host);\n+        let digest = self.digests.remove(&filename)?;\n+        let xz_filename = filename.replace(\".tar.gz\", \".tar.xz\");\n+        let xz_digest = self.digests.remove(&xz_filename);\n+        let mut components = Vec::new();\n+        let mut extensions = Vec::new();\n+\n+        let host_component = |pkg| Component::from_str(pkg, host);\n+\n+        // rustc/rust-std/cargo/docs are all required,\n+        // and so is rust-mingw if it's available for the target.\n+        components.extend(vec![\n+            host_component(\"rustc\"),\n+            host_component(\"rust-std\"),\n+            host_component(\"cargo\"),\n+            host_component(\"rust-docs\"),\n+        ]);\n+        if host.contains(\"pc-windows-gnu\") {\n+            components.push(host_component(\"rust-mingw\"));\n         }\n-        manifest.pkg.insert(\"rust\".to_string(), pkg);\n \n-        manifest\n+        // Tools are always present in the manifest,\n+        // but might be marked as unavailable if they weren't built.\n+        extensions.extend(vec![\n+            host_component(\"clippy-preview\"),\n+            host_component(\"miri\"),\n+            host_component(\"rls-preview\"),\n+            host_component(\"rustfmt-preview\"),\n+            host_component(\"llvm-tools-preview\"),\n+            host_component(\"lldb-preview\"),\n+            host_component(\"rust-analysis\"),\n+        ]);\n+\n+        extensions.extend(\n+            TARGETS.iter()\n+                .filter(|&&target| target != host)\n+                .map(|target| Component::from_str(\"rust-std\", target))\n+        );\n+        extensions.push(Component::from_str(\"rust-src\", \"*\"));\n+\n+        // If the components/extensions don't actually exist for this\n+        // particular host/target combination then nix it entirely from our\n+        // lists.\n+        let has_component = |c: &Component| {\n+            if c.target == \"*\" {\n+                return true\n+            }\n+            let pkg = match manifest.pkg.get(&c.pkg) {\n+                Some(p) => p,\n+                None => return false,\n+            };\n+            pkg.target.get(&c.target).is_some()\n+        };\n+        extensions.retain(&has_component);\n+        components.retain(&has_component);\n+\n+        Some(Target {\n+            available: true,\n+            url: Some(self.url(&filename)),\n+            hash: Some(digest),\n+            xz_url: xz_digest.as_ref().map(|_| self.url(&xz_filename)),\n+            xz_hash: xz_digest,\n+            components: Some(components),\n+            extensions: Some(extensions),\n+        })\n     }\n \n     fn profile(&mut self,\n@@ -497,10 +521,11 @@ impl Builder {\n                pkgname: &str,\n                dst: &mut BTreeMap<String, Package>,\n                targets: &[&str]) {\n-        let (version, is_present) = match *self.cached_version(pkgname) {\n-            Some(ref version) => (version.clone(), true),\n-            None => (String::new(), false),\n-        };\n+        let (version, is_present) = self.cached_version(pkgname)\n+            .as_ref()\n+            .cloned()\n+            .map(|version| (version, true))\n+            .unwrap_or_default();\n \n         let targets = targets.iter().map(|name| {\n             if is_present {\n@@ -524,15 +549,7 @@ impl Builder {\n             } else {\n                 // If the component is not present for this build add it anyway but mark it as\n                 // unavailable -- this way rustup won't allow upgrades without --force\n-                (name.to_string(), Target {\n-                    available: false,\n-                    url: None,\n-                    hash: None,\n-                    xz_url: None,\n-                    xz_hash: None,\n-                    components: None,\n-                    extensions: None,\n-                })\n+                (name.to_string(), Target::unavailable())\n             }\n         }).collect();\n \n@@ -551,89 +568,65 @@ impl Builder {\n     }\n \n     fn filename(&self, component: &str, target: &str) -> String {\n-        if component == \"rust-src\" {\n-            format!(\"rust-src-{}.tar.gz\", self.rust_release)\n-        } else if component == \"cargo\" {\n-            format!(\"cargo-{}-{}.tar.gz\", self.cargo_release, target)\n-        } else if component == \"rls\" || component == \"rls-preview\" {\n-            format!(\"rls-{}-{}.tar.gz\", self.rls_release, target)\n-        } else if component == \"clippy\" || component == \"clippy-preview\" {\n-            format!(\"clippy-{}-{}.tar.gz\", self.clippy_release, target)\n-        } else if component == \"rustfmt\" || component == \"rustfmt-preview\" {\n-            format!(\"rustfmt-{}-{}.tar.gz\", self.rustfmt_release, target)\n-        } else if component == \"llvm-tools\" || component == \"llvm-tools-preview\" {\n-            format!(\"llvm-tools-{}-{}.tar.gz\", self.llvm_tools_release, target)\n-        } else if component == \"lldb\" || component == \"lldb-preview\" {\n-            format!(\"lldb-{}-{}.tar.gz\", self.lldb_release, target)\n-        } else if component == \"miri\" || component == \"miri-preview\" {\n-            format!(\"miri-{}-{}.tar.gz\", self.miri_release, target)\n-        } else {\n-            format!(\"{}-{}-{}.tar.gz\", component, self.rust_release, target)\n+        use PkgType::*;\n+        match PkgType::from_component(component) {\n+            RustSrc => format!(\"rust-src-{}.tar.gz\", self.rust_release),\n+            Cargo => format!(\"cargo-{}-{}.tar.gz\", self.cargo_release, target),\n+            Rls => format!(\"rls-{}-{}.tar.gz\", self.rls_release, target),\n+            Clippy => format!(\"clippy-{}-{}.tar.gz\", self.clippy_release, target),\n+            Rustfmt => format!(\"rustfmt-{}-{}.tar.gz\", self.rustfmt_release, target),\n+            LlvmTools => format!(\"llvm-tools-{}-{}.tar.gz\", self.llvm_tools_release, target),\n+            Lldb => format!(\"lldb-{}-{}.tar.gz\", self.lldb_release, target),\n+            Miri => format!(\"miri-{}-{}.tar.gz\", self.miri_release, target),\n+            Other => format!(\"{}-{}-{}.tar.gz\", component, self.rust_release, target),\n         }\n     }\n \n     fn cached_version(&self, component: &str) -> &Option<String> {\n-        if component == \"cargo\" {\n-            &self.cargo_version\n-        } else if component == \"rls\" || component == \"rls-preview\" {\n-            &self.rls_version\n-        } else if component == \"clippy\" || component == \"clippy-preview\" {\n-            &self.clippy_version\n-        } else if component == \"rustfmt\" || component == \"rustfmt-preview\" {\n-            &self.rustfmt_version\n-        } else if component == \"llvm-tools\" || component == \"llvm-tools-preview\" {\n-            &self.llvm_tools_version\n-        } else if component == \"lldb\" || component == \"lldb-preview\" {\n-            &self.lldb_version\n-        } else if component == \"miri\" || component == \"miri-preview\" {\n-            &self.miri_version\n-        } else {\n-            &self.rust_version\n+        use PkgType::*;\n+        match PkgType::from_component(component) {\n+            Cargo => &self.cargo_version,\n+            Rls => &self.rls_version,\n+            Clippy => &self.clippy_version,\n+            Rustfmt => &self.rustfmt_version,\n+            LlvmTools => &self.llvm_tools_version,\n+            Lldb => &self.lldb_version,\n+            Miri => &self.miri_version,\n+            _ => &self.rust_version,\n         }\n     }\n \n     fn cached_git_commit_hash(&self, component: &str) -> &Option<String> {\n-        if component == \"cargo\" {\n-            &self.cargo_git_commit_hash\n-        } else if component == \"rls\" || component == \"rls-preview\" {\n-            &self.rls_git_commit_hash\n-        } else if component == \"clippy\" || component == \"clippy-preview\" {\n-            &self.clippy_git_commit_hash\n-        } else if component == \"rustfmt\" || component == \"rustfmt-preview\" {\n-            &self.rustfmt_git_commit_hash\n-        } else if component == \"llvm-tools\" || component == \"llvm-tools-preview\" {\n-            &self.llvm_tools_git_commit_hash\n-        } else if component == \"lldb\" || component == \"lldb-preview\" {\n-            &self.lldb_git_commit_hash\n-        } else if component == \"miri\" || component == \"miri-preview\" {\n-            &self.miri_git_commit_hash\n-        } else {\n-            &self.rust_git_commit_hash\n+        use PkgType::*;\n+        match PkgType::from_component(component) {\n+            Cargo => &self.cargo_git_commit_hash,\n+            Rls => &self.rls_git_commit_hash,\n+            Clippy => &self.clippy_git_commit_hash,\n+            Rustfmt => &self.rustfmt_git_commit_hash,\n+            LlvmTools => &self.llvm_tools_git_commit_hash,\n+            Lldb => &self.lldb_git_commit_hash,\n+            Miri => &self.miri_git_commit_hash,\n+            _ => &self.rust_git_commit_hash,\n         }\n     }\n \n     fn version(&self, component: &str, target: &str) -> Option<String> {\n-        let mut cmd = Command::new(\"tar\");\n-        let filename = self.filename(component, target);\n-        cmd.arg(\"xf\")\n-           .arg(self.input.join(&filename))\n-           .arg(format!(\"{}/version\", filename.replace(\".tar.gz\", \"\")))\n-           .arg(\"-O\");\n-        let output = t!(cmd.output());\n-        if output.status.success() {\n-            Some(String::from_utf8_lossy(&output.stdout).trim().to_string())\n-        } else {\n-            // Perhaps we didn't build this package.\n-            None\n-        }\n+        self.untar(component, target, |filename| format!(\"{}/version\", filename))\n     }\n \n     fn git_commit_hash(&self, component: &str, target: &str) -> Option<String> {\n+        self.untar(component, target, |filename| format!(\"{}/git-commit-hash\", filename))\n+    }\n+\n+    fn untar<F>(&self, component: &str, target: &str, dir: F) -> Option<String>\n+    where\n+        F: FnOnce(String) -> String\n+    {\n         let mut cmd = Command::new(\"tar\");\n         let filename = self.filename(component, target);\n         cmd.arg(\"xf\")\n            .arg(self.input.join(&filename))\n-           .arg(format!(\"{}/git-commit-hash\", filename.replace(\".tar.gz\", \"\")))\n+           .arg(dir(filename.replace(\".tar.gz\", \"\")))\n            .arg(\"-O\");\n         let output = t!(cmd.output());\n         if output.status.success() {"}]}