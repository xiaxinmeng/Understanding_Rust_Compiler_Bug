{"sha": "f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MDVlNDFkN2E0M2ViZDdmZGQwZmNkOTBmNmUwNTQyYTVhNmNjZjY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-12T05:01:42Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-17T19:50:20Z"}, "message": "librustc: Implement write guards for borrowing `@mut` to `&` or `&mut`. r=nmatsakis", "tree": {"sha": "62e7e079cb5998e833ec950e9525330a1dc1e9e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62e7e079cb5998e833ec950e9525330a1dc1e9e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "html_url": "https://github.com/rust-lang/rust/commit/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bde2c1d6533bf693dbb6ae8105bb082ad0ff0fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bde2c1d6533bf693dbb6ae8105bb082ad0ff0fe", "html_url": "https://github.com/rust-lang/rust/commit/8bde2c1d6533bf693dbb6ae8105bb082ad0ff0fe"}], "stats": {"total": 891, "additions": 524, "deletions": 367}, "files": [{"sha": "1d964edd5370f30d4866f9f4a36fe444dbb27666", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -216,7 +216,7 @@ pub mod raw {\n     }\n \n     pub unsafe fn push_slow<T>(v: &mut @[const T], initval: T) {\n-        reserve_at_least(v, v.len() + 1u);\n+        reserve_at_least(&mut *v, v.len() + 1u);\n         push_fast(v, move initval);\n     }\n \n@@ -234,7 +234,7 @@ pub mod raw {\n     pub unsafe fn reserve<T>(v: &mut @[const T], n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if capacity(*v) < n {\n-            let ptr: **VecRepr = transmute(copy v);\n+            let ptr: **VecRepr = transmute(v);\n             rustrt::vec_reserve_shared_actual(sys::get_type_desc::<T>(),\n                                               ptr, n as libc::size_t);\n         }"}, {"sha": "b800564b8e10c14f3fa2a51567bb2224577d5e7d", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -95,8 +95,8 @@ pub mod at_vec;\n pub mod str;\n \n pub mod ptr;\n-pub mod managed;\n pub mod owned;\n+pub mod managed;\n \n \n /* Core language traits */"}, {"sha": "32fc5f527b7cf69e7e0cff2f93555c12c33b1bc6", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -14,7 +14,9 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n+use cast::transmute;\n use cmp::{Eq, Ord};\n+use managed::raw::BoxRepr;\n use prelude::*;\n use ptr;\n "}, {"sha": "c5268e2d4ed56abd7c8215efefbd7fa7900f8b0b", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -15,7 +15,9 @@\n #[forbid(deprecated_pattern)];\n //! Runtime calls emitted by the compiler.\n \n+use cast::transmute;\n use libc::{c_char, c_void, size_t, uintptr_t};\n+use managed::raw::BoxRepr;\n use str;\n use sys;\n \n@@ -24,6 +26,11 @@ use gc::{cleanup_stack_for_failure, gc, Word};\n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n \n+#[cfg(target_word_size = \"32\")]\n+const FROZEN_BIT: uint = 0x80000000;\n+#[cfg(target_word_size = \"64\")]\n+const FROZEN_BIT: uint = 0x8000000000000000;\n+\n extern mod rustrt {\n     #[rust_stack]\n     unsafe fn rust_upcall_exchange_malloc(td: *c_char, size: uintptr_t)\n@@ -56,6 +63,15 @@ pub unsafe fn rt_fail_bounds_check(file: *c_char, line: size_t,\n     }\n }\n \n+pub unsafe fn rt_fail_borrowed() {\n+    let msg = \"borrowed\";\n+    do str::as_buf(msg) |msg_p, _| {\n+        do str::as_buf(\"???\") |file_p, _| {\n+            rt_fail_(msg_p as *c_char, file_p as *c_char, 0);\n+        }\n+    }\n+}\n+\n #[rt(exchange_malloc)]\n #[lang=\"exchange_malloc\"]\n pub unsafe fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n@@ -86,6 +102,29 @@ pub unsafe fn rt_free(ptr: *c_char) {\n     rustrt::rust_upcall_free(ptr);\n }\n \n+#[lang=\"borrow_as_imm\"]\n+#[inline(always)]\n+pub unsafe fn borrow_as_imm(a: *u8) {\n+    let a: *mut BoxRepr = transmute(a);\n+    (*a).header.ref_count |= FROZEN_BIT;\n+}\n+\n+#[lang=\"return_to_mut\"]\n+#[inline(always)]\n+pub unsafe fn return_to_mut(a: *u8) {\n+    let a: *mut BoxRepr = transmute(a);\n+    (*a).header.ref_count &= !FROZEN_BIT;\n+}\n+\n+#[lang=\"check_not_borrowed\"]\n+#[inline(always)]\n+pub unsafe fn check_not_borrowed(a: *u8) {\n+    let a: *mut BoxRepr = transmute(a);\n+    if ((*a).header.ref_count & FROZEN_BIT) != 0 {\n+        rt_fail_borrowed();\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "d1c85d6482d0bc7bcba427cb83a4953ef17b6a6c", "filename": "src/libcore/str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -80,7 +80,7 @@ pub fn push_char(s: &mut ~str, ch: char) {\n         else { 6u };\n         let len = len(*s);\n         let new_len = len + nb;\n-        reserve_at_least(s, new_len);\n+        reserve_at_least(&mut *s, new_len);\n         let off = len;\n         do as_buf(*s) |buf, _len| {\n             let buf: *mut u8 = ::cast::reinterpret_cast(&buf);\n@@ -164,7 +164,7 @@ pub fn push_str_no_overallocate(lhs: &mut ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n-        reserve(lhs, llen + rlen);\n+        reserve(&mut *lhs, llen + rlen);\n         do as_buf(*lhs) |lbuf, _llen| {\n             do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n@@ -181,7 +181,7 @@ pub fn push_str(lhs: &mut ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n-        reserve_at_least(lhs, llen + rlen);\n+        reserve_at_least(&mut *lhs, llen + rlen);\n         do as_buf(*lhs) |lbuf, _llen| {\n             do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n@@ -2056,18 +2056,18 @@ pub mod raw {\n \n     /// Appends a byte to a string. (Not UTF-8 safe).\n     pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n-        reserve_at_least(s, s.len() + 1);\n+        reserve_at_least(&mut *s, s.len() + 1);\n         do as_buf(*s) |buf, len| {\n             let buf: *mut u8 = ::cast::reinterpret_cast(&buf);\n             *ptr::mut_offset(buf, len) = b;\n         }\n-        set_len(s, s.len() + 1);\n+        set_len(&mut *s, s.len() + 1);\n     }\n \n     /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n     unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n-        reserve_at_least(s, s.len() + bytes.len());\n-        for vec::each(bytes) |byte| { push_byte(s, *byte); }\n+        reserve_at_least(&mut *s, s.len() + bytes.len());\n+        for vec::each(bytes) |byte| { push_byte(&mut *s, *byte); }\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n@@ -2090,7 +2090,7 @@ pub mod raw {\n \n     /// Sets the length of the string and adds the null terminator\n     pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n-        let v: **vec::raw::VecRepr = cast::transmute(copy v);\n+        let v: **vec::raw::VecRepr = cast::transmute(v);\n         let repr: *vec::raw::VecRepr = *v;\n         (*repr).unboxed.fill = new_len + 1u;\n         let null = ptr::mut_offset(ptr::mut_addr_of(&((*repr).unboxed.data)),"}, {"sha": "28bbeaad35b380f3f9baa27e16e431b63dfe427f", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -187,7 +187,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                 forward_blk:     fn(TaskGroupInner) -> bool,\n                 last_generation: uint) -> bool {\n         // Need to swap the list out to use it, to appease borrowck.\n-        let tmp_list = util::replace(list, AncestorList(None));\n+        let tmp_list = util::replace(&mut *list, AncestorList(None));\n         let (coalesce_this, early_break) =\n             iterate(&tmp_list, bail_opt, forward_blk, last_generation);\n         // What should our next ancestor end up being?\n@@ -289,7 +289,7 @@ fn each_ancestor(list:        &mut AncestorList,\n         fn with_parent_tg<U>(parent_group: &mut Option<TaskGroupArc>,\n                              blk: fn(TaskGroupInner) -> U) -> U {\n             // If this trips, more likely the problem is 'blk' failed inside.\n-            let tmp_arc = option::swap_unwrap(parent_group);\n+            let tmp_arc = option::swap_unwrap(&mut *parent_group);\n             let result = do access_group(&tmp_arc) |tg_opt| { blk(tg_opt) };\n             *parent_group = move Some(move tmp_arc);\n             move result\n@@ -363,7 +363,7 @@ fn AutoNotify(chan: Chan<TaskResult>) -> AutoNotify {\n \n fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n                            is_member: bool) -> bool {\n-    let newstate = util::replace(state, None);\n+    let newstate = util::replace(&mut *state, None);\n     // If 'None', the group was failing. Can't enlist.\n     if newstate.is_some() {\n         let group = option::unwrap(move newstate);\n@@ -379,7 +379,7 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n                        is_member: bool) {\n-    let newstate = util::replace(state, None);\n+    let newstate = util::replace(&mut *state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n         let group = option::unwrap(move newstate);"}, {"sha": "1caf569e77d500828a847b1ce8b617a49f1b834d", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -472,7 +472,7 @@ pub fn shift<T>(v: &mut ~[T]) -> T unsafe {\n     assert capacity(v) >= ln;\n     // Pretend like we have the original length so we can use\n     // the vector copy_memory to overwrite the hole we just made\n-    raw::set_len(v, ln);\n+    raw::set_len(&mut *v, ln);\n \n     // Memcopy the head element (the one we want) to the location we just\n     // popped. For the moment it unsafely exists at both the head and last\n@@ -487,7 +487,7 @@ pub fn shift<T>(v: &mut ~[T]) -> T unsafe {\n     raw::copy_memory(init_slice, tail_slice, next_ln);\n \n     // Set the new length. Now the vector is back to normal\n-    raw::set_len(v, next_ln);\n+    raw::set_len(&mut *v, next_ln);\n \n     // Swap out the element we want from the end\n     let vp = raw::to_mut_ptr(*v);\n@@ -592,7 +592,7 @@ pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n #[inline(always)]\n pub fn push<T>(v: &mut ~[T], initval: T) {\n     unsafe {\n-        let repr: **raw::VecRepr = ::cast::transmute(copy v);\n+        let repr: **raw::VecRepr = ::cast::transmute(&mut *v);\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n             push_fast(v, initval);\n@@ -616,30 +616,30 @@ unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n \n #[inline(never)]\n fn push_slow<T>(v: &mut ~[T], initval: T) {\n-    reserve_at_least(v, v.len() + 1u);\n+    reserve_at_least(&mut *v, v.len() + 1u);\n     unsafe { push_fast(v, initval) }\n }\n \n #[inline(always)]\n pub fn push_all<T: Copy>(v: &mut ~[T], rhs: &[const T]) {\n-    reserve(v, v.len() + rhs.len());\n+    reserve(&mut *v, v.len() + rhs.len());\n \n     for uint::range(0u, rhs.len()) |i| {\n-        push(v, unsafe { raw::get(rhs, i) })\n+        push(&mut *v, unsafe { raw::get(rhs, i) })\n     }\n }\n \n #[inline(always)]\n pub fn push_all_move<T>(v: &mut ~[T], rhs: ~[T]) {\n     let mut rhs = rhs; // FIXME(#3488)\n-    reserve(v, v.len() + rhs.len());\n+    reserve(&mut *v, v.len() + rhs.len());\n     unsafe {\n         do as_mut_buf(rhs) |p, len| {\n             for uint::range(0, len) |i| {\n                 // FIXME #4204 Should be rusti::uninit() - don't need to zero\n                 let mut x = rusti::init();\n                 x <-> *ptr::mut_offset(p, i);\n-                push(v, x);\n+                push(&mut *v, x);\n             }\n         }\n         raw::set_len(&mut rhs, 0);\n@@ -657,7 +657,7 @@ pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n                 let mut dropped = rusti::init();\n                 dropped <-> *ptr::mut_offset(p, i);\n             }\n-            raw::set_len(v, newlen);\n+            raw::set_len(&mut *v, newlen);\n         }\n     }\n }\n@@ -731,7 +731,7 @@ pub pure fn append_mut<T: Copy>(lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n  * * initval - The value for the new elements\n  */\n pub fn grow<T: Copy>(v: &mut ~[T], n: uint, initval: &T) {\n-    reserve_at_least(v, v.len() + n);\n+    reserve_at_least(&mut *v, v.len() + n);\n     let mut i: uint = 0u;\n \n     while i < n {\n@@ -754,7 +754,7 @@ pub fn grow<T: Copy>(v: &mut ~[T], n: uint, initval: &T) {\n  *             value\n  */\n pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n-    reserve_at_least(v, v.len() + n);\n+    reserve_at_least(&mut *v, v.len() + n);\n     let mut i: uint = 0u;\n     while i < n {\n         v.push(op(i));\n@@ -772,7 +772,7 @@ pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n  */\n pub fn grow_set<T: Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n     let l = v.len();\n-    if index >= l { grow(v, index - l + 1u, initval); }\n+    if index >= l { grow(&mut *v, index - l + 1u, initval); }\n     v[index] = val;\n }\n "}, {"sha": "3f37b6d17944e7c18b147ede469c4249dfa87ca5", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -69,7 +69,7 @@ fn find_rust_files(files: &mut ~[Path], path: &Path) {\n         && !contains(path.to_str(), ~\"compile-fail\")\n         && !contains(path.to_str(), ~\"build\") {\n         for os::list_dir_path(path).each |p| {\n-            find_rust_files(files, *p);\n+            find_rust_files(&mut *files, *p);\n         }\n     }\n }"}, {"sha": "740cc526310985b083e3c385757502097c1bcbeb", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -291,7 +291,7 @@ fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n             time(time_passes, ~\"liveness checking\", ||\n                  middle::liveness::check_crate(ty_cx, method_map, crate));\n \n-        let (root_map, mutbl_map) =\n+        let (root_map, mutbl_map, write_guard_map) =\n             time(time_passes, ~\"borrow checking\", ||\n                  middle::borrowck::check_crate(ty_cx, method_map,\n                                                last_use_map, crate));\n@@ -308,7 +308,8 @@ fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n                     root_map: root_map,\n                     last_use_map: last_use_map,\n                     method_map: method_map,\n-                    vtable_map: vtable_map};\n+                    vtable_map: vtable_map,\n+                    write_guard_map: write_guard_map};\n \n         time(time_passes, ~\"translation\", ||\n              trans::base::trans_crate(sess, crate, ty_cx,"}, {"sha": "09b6904faa3ce2222f929f3c6155840611698f02", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -60,6 +60,7 @@ type maps = {\n     last_use_map: middle::liveness::last_use_map,\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n+    write_guard_map: middle::borrowck::write_guard_map,\n };\n \n type decode_ctxt = @{"}, {"sha": "5635d5d18e59b5a3eb04d9517dabd0e0b17d2636", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -21,8 +21,8 @@ use core::prelude::*;\n \n use middle::borrowck::{Loan, bckerr, borrowck_ctxt, cmt, inherent_mutability};\n use middle::borrowck::{req_maps, save_and_restore};\n-use middle::mem_categorization::{cat_arg, cat_binding, cat_deref, cat_local};\n-use middle::mem_categorization::{cat_rvalue, cat_special};\n+use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n+use middle::mem_categorization::{cat_local, cat_rvalue, cat_special, gc_ptr};\n use middle::mem_categorization::{loan_path, lp_arg, lp_comp, lp_deref};\n use middle::mem_categorization::{lp_local};\n use middle::ty::{CopyValue, MoveValue, ReadValue};\n@@ -54,6 +54,7 @@ enum check_loan_ctxt = @{\n };\n \n // if we are enforcing purity, why are we doing so?\n+#[deriving_eq]\n enum purity_cause {\n     // enforcing purity because fn was declared pure:\n     pc_pure_fn,\n@@ -64,26 +65,6 @@ enum purity_cause {\n     pc_cmt(bckerr)\n }\n \n-impl purity_cause : cmp::Eq {\n-    pure fn eq(&self, other: &purity_cause) -> bool {\n-        match (*self) {\n-            pc_pure_fn => {\n-                match (*other) {\n-                    pc_pure_fn => true,\n-                    _ => false\n-                }\n-            }\n-            pc_cmt(ref e0a) => {\n-                match (*other) {\n-                    pc_cmt(ref e0b) => (*e0a) == (*e0b),\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &purity_cause) -> bool { !(*self).eq(other) }\n-}\n-\n fn check_loans(bccx: borrowck_ctxt,\n                req_maps: req_maps,\n                crate: @ast::crate) {\n@@ -100,18 +81,12 @@ fn check_loans(bccx: borrowck_ctxt,\n     visit::visit_crate(*crate, clcx, vt);\n }\n \n+#[deriving_eq]\n enum assignment_type {\n     at_straight_up,\n     at_swap\n }\n \n-impl assignment_type : cmp::Eq {\n-    pure fn eq(&self, other: &assignment_type) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &assignment_type) -> bool { !(*self).eq(other) }\n-}\n-\n impl assignment_type {\n     fn checked_by_liveness() -> bool {\n         // the liveness pass guarantees that immutable local variables\n@@ -410,6 +385,29 @@ impl check_loan_ctxt {\n         }\n \n         self.bccx.add_to_mutbl_map(cmt);\n+\n+        // Check for and insert write guards as necessary.\n+        self.add_write_guards_if_necessary(cmt);\n+    }\n+\n+    fn add_write_guards_if_necessary(cmt: cmt) {\n+        match cmt.cat {\n+            cat_deref(base, deref_count, ptr_kind) => {\n+                self.add_write_guards_if_necessary(base);\n+\n+                match ptr_kind {\n+                    gc_ptr(ast::m_mutbl) => {\n+                        let key = { id: base.id, derefs: deref_count };\n+                        self.bccx.write_guard_map.insert(key, ());\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            cat_comp(base, _) => {\n+                self.add_write_guards_if_necessary(base);\n+            }\n+            _ => {}\n+        }\n     }\n \n     fn check_for_loan_conflicting_with_assignment("}, {"sha": "30ed831c53fe0e6a413ef6d8837688b1ab0f05dd", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -454,10 +454,16 @@ impl gather_loan_ctxt {\n             let e = {cmt: cmt,\n                      code: err_mutbl(req_mutbl)};\n             if req_mutbl == m_imm {\n-                // you can treat mutable things as imm if you are pure\n-                debug!(\"imm required, must be pure\");\n-\n-                Ok(pc_if_pure(e))\n+                // if this is an @mut box, then it's generally OK to borrow as\n+                // &imm; this will result in a write guard\n+                if cmt.cat.is_mutable_box() {\n+                    Ok(pc_ok)\n+                } else {\n+                    // you can treat mutable things as imm if you are pure\n+                    debug!(\"imm required, must be pure\");\n+\n+                    Ok(pc_if_pure(e))\n+                }\n             } else {\n                 Err(e)\n             }"}, {"sha": "80e5dacae41e9d3c62eee37da8e57a783b1dc0e1", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -19,7 +19,8 @@ use middle::borrowck::{err_out_of_scope};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_discr, cat_comp};\n use middle::mem_categorization::{cat_deref, cat_discr, cat_local};\n use middle::mem_categorization::{cat_special, cat_stack_upvar, comp_field};\n-use middle::mem_categorization::{comp_index, comp_variant, region_ptr};\n+use middle::mem_categorization::{comp_index, comp_variant, gc_ptr};\n+use middle::mem_categorization::{region_ptr};\n use middle::ty;\n use util::common::indenter;\n \n@@ -162,7 +163,7 @@ impl LoanContext {\n             self.loan_unstable_deref(cmt, cmt_base, req_mutbl)\n           }\n           cat_deref(_, _, unsafe_ptr) |\n-          cat_deref(_, _, gc_ptr) |\n+          cat_deref(_, _, gc_ptr(_)) |\n           cat_deref(_, _, region_ptr(_)) => {\n             // Aliased data is simply not lendable.\n             self.bccx.tcx.sess.span_bug("}, {"sha": "91ea70f507ea756b809c3f754ed70bec55c85c12", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -263,13 +263,15 @@ pub mod preserve;\n fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n                last_use_map: liveness::last_use_map,\n-               crate: @ast::crate) -> (root_map, mutbl_map) {\n+               crate: @ast::crate)\n+            -> (root_map, mutbl_map, write_guard_map) {\n \n     let bccx = borrowck_ctxt_(@{tcx: tcx,\n                                 method_map: method_map,\n                                 last_use_map: last_use_map,\n                                 root_map: root_map(),\n                                 mutbl_map: HashMap(),\n+                                write_guard_map: HashMap(),\n                                 mut loaned_paths_same: 0,\n                                 mut loaned_paths_imm: 0,\n                                 mut stable_paths: 0,\n@@ -293,7 +295,7 @@ fn check_crate(tcx: ty::ctxt,\n                          make_stat(bccx, bccx.req_pure_paths)));\n     }\n \n-    return (bccx.root_map, bccx.mutbl_map);\n+    return (bccx.root_map, bccx.mutbl_map, bccx.write_guard_map);\n \n     fn make_stat(bccx: borrowck_ctxt, stat: uint) -> ~str {\n         let stat_f = stat as float;\n@@ -310,6 +312,7 @@ type borrowck_ctxt_ = {tcx: ty::ctxt,\n                        last_use_map: liveness::last_use_map,\n                        root_map: root_map,\n                        mutbl_map: mutbl_map,\n+                       write_guard_map: write_guard_map,\n \n                        // Statistics:\n                        mut loaned_paths_same: uint,\n@@ -322,10 +325,17 @@ enum borrowck_ctxt {\n     borrowck_ctxt_(@borrowck_ctxt_)\n }\n \n+struct RootInfo {\n+    scope: ast::node_id,\n+    // This will be true if we need to freeze this box at runtime. This will\n+    // result in a call to `borrow_as_imm()` and `return_to_mut()`.\n+    freezes: bool   // True if we need to freeze this box at runtime.\n+}\n+\n // a map mapping id's of expressions of gc'd type (@T, @[], etc) where\n // the box needs to be kept live to the id of the scope for which they\n // must stay live.\n-type root_map = HashMap<root_map_key, ast::node_id>;\n+type root_map = HashMap<root_map_key, RootInfo>;\n \n // the keys to the root map combine the `id` of the expression with\n // the number of types that it is autodereferenced.  So, for example,\n@@ -338,6 +348,10 @@ type root_map_key = {id: ast::node_id, derefs: uint};\n // this is used in trans for optimization purposes.\n type mutbl_map = HashMap<ast::node_id, ()>;\n \n+// A set containing IDs of expressions of gc'd type that need to have a write\n+// guard.\n+type write_guard_map = HashMap<root_map_key, ()>;\n+\n // Errors that can occur\"]\n enum bckerr_code {\n     err_mut_uniq,\n@@ -447,14 +461,6 @@ impl root_map_key : to_bytes::IterBytes {\n \n fn root_map() -> root_map {\n     return HashMap();\n-\n-    pure fn root_map_key_eq(k1: &root_map_key, k2: &root_map_key) -> bool {\n-        k1.id == k2.id && k1.derefs == k2.derefs\n-    }\n-\n-    pure fn root_map_key_hash(k: &root_map_key) -> uint {\n-        (k.id << 4) as uint | k.derefs\n-    }\n }\n \n // ___________________________________________________________________________"}, {"sha": "429df1a6aa52d017a18797d4f9a33a25c9be54ae", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -15,13 +15,14 @@\n \n use core::prelude::*;\n \n-use middle::borrowck::{bckerr, bckerr_code, bckres, borrowck_ctxt, cmt};\n-use middle::borrowck::{err_mut_uniq, err_mut_variant, err_out_of_root_scope};\n-use middle::borrowck::{err_out_of_scope, err_root_not_permitted};\n+use middle::borrowck::{RootInfo, bckerr, bckerr_code, bckres, borrowck_ctxt};\n+use middle::borrowck::{cmt, err_mut_uniq, err_mut_variant};\n+use middle::borrowck::{err_out_of_root_scope, err_out_of_scope};\n+use middle::borrowck::{err_root_not_permitted};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n use middle::mem_categorization::{cat_discr, cat_local, cat_special};\n use middle::mem_categorization::{cat_stack_upvar, comp_field, comp_index};\n-use middle::mem_categorization::{comp_variant, region_ptr};\n+use middle::mem_categorization::{comp_variant, gc_ptr, region_ptr};\n use middle::ty;\n use util::common::indenter;\n \n@@ -180,14 +181,16 @@ priv impl &preserve_ctxt {\n             // Unsafe pointers are the user's problem\n             Ok(pc_ok)\n           }\n-          cat_deref(base, derefs, gc_ptr) => {\n+          cat_deref(base, derefs, gc_ptr(*)) => {\n             // GC'd pointers of type @MT: if this pointer lives in\n             // immutable, stable memory, then everything is fine.  But\n             // otherwise we have no guarantee the pointer will stay\n             // live, so we must root the pointer (i.e., inc the ref\n             // count) for the duration of the loan.\n             debug!(\"base.mutbl = %?\", self.bccx.mut_to_str(base.mutbl));\n-            if base.mutbl == m_imm {\n+            if cmt.cat.derefs_through_mutable_box() {\n+                self.attempt_root(cmt, base, derefs)\n+            } else if base.mutbl == m_imm {\n                 let non_rooting_ctxt =\n                     preserve_ctxt({root_managed_data: false,.. **self});\n                 match (&non_rooting_ctxt).preserve(base) {\n@@ -326,8 +329,10 @@ priv impl &preserve_ctxt {\n     /// value live for longer than the current fn or else potentially\n     /// require that an statically unbounded number of values be\n     /// rooted (if a loop exists).\n-    fn attempt_root(cmt: cmt, base: cmt,\n-                    derefs: uint) -> bckres<preserve_condition> {\n+    fn attempt_root(cmt: cmt,\n+                    base: cmt,\n+                    derefs: uint)\n+                 -> bckres<preserve_condition> {\n         if !self.root_managed_data {\n             // normally, there is a root_ub; the only time that this\n             // is none is when a boxed value is stored in an immutable\n@@ -352,21 +357,26 @@ priv impl &preserve_ctxt {\n             if self.bccx.is_subregion_of(self.scope_region, root_region) {\n                 debug!(\"Elected to root\");\n                 let rk = {id: base.id, derefs: derefs};\n-                self.bccx.root_map.insert(rk, scope_id);\n+                // We freeze if and only if this is a *mutable* @ box that\n+                // we're borrowing into a pointer.\n+                self.bccx.root_map.insert(rk, RootInfo {\n+                    scope: scope_id,\n+                    freezes: cmt.cat.derefs_through_mutable_box()\n+                });\n                 return Ok(pc_ok);\n             } else {\n                 debug!(\"Unable to root\");\n                 return Err({cmt:cmt,\n-                         code:err_out_of_root_scope(root_region,\n-                                                    self.scope_region)});\n+                            code:err_out_of_root_scope(root_region,\n+                                                       self.scope_region)});\n             }\n           }\n \n           // we won't be able to root long enough\n           _ => {\n               return Err({cmt:cmt,\n-                       code:err_out_of_root_scope(root_region,\n-                                                  self.scope_region)});\n+                          code:err_out_of_root_scope(root_region,\n+                                                     self.scope_region)});\n           }\n \n         }"}, {"sha": "d70fcd1ae8a8eea18283101f90e1f26dde1d4916", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -71,16 +71,19 @@ pub enum LangItem {\n     ExchangeFreeFnLangItem,     // 27\n     MallocFnLangItem,           // 28\n     FreeFnLangItem,             // 29\n+    BorrowAsImmFnLangItem,      // 30\n+    ReturnToMutFnLangItem,      // 31\n+    CheckNotBorrowedFnLangItem, // 32\n }\n \n struct LanguageItems {\n-    items: [ Option<def_id> * 30 ]\n+    items: [ Option<def_id> * 33 ]\n }\n \n impl LanguageItems {\n     static pub fn new() -> LanguageItems {\n         LanguageItems {\n-            items: [ None, ..30 ]\n+            items: [ None, ..33 ]\n         }\n     }\n \n@@ -127,6 +130,9 @@ impl LanguageItems {\n             27 => \"exchange_free\",\n             28 => \"malloc\",\n             29 => \"free\",\n+            30 => \"borrow_as_imm\",\n+            31 => \"return_to_mut\",\n+            32 => \"check_not_borrowed\",\n \n             _ => \"???\"\n         }\n@@ -228,6 +234,15 @@ impl LanguageItems {\n     pub fn free_fn(&const self) -> def_id {\n         self.items[FreeFnLangItem as uint].get()\n     }\n+    pub fn borrow_as_imm_fn(&const self) -> def_id {\n+        self.items[BorrowAsImmFnLangItem as uint].get()\n+    }\n+    pub fn return_to_mut_fn(&const self) -> def_id {\n+        self.items[ReturnToMutFnLangItem as uint].get()\n+    }\n+    pub fn check_not_borrowed_fn(&const self) -> def_id {\n+        self.items[CheckNotBorrowedFnLangItem as uint].get()\n+    }\n }\n \n fn LanguageItemCollector(crate: @crate,\n@@ -270,6 +285,10 @@ fn LanguageItemCollector(crate: @crate,\n     item_refs.insert(~\"exchange_free\", ExchangeFreeFnLangItem as uint);\n     item_refs.insert(~\"malloc\", MallocFnLangItem as uint);\n     item_refs.insert(~\"free\", FreeFnLangItem as uint);\n+    item_refs.insert(~\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n+    item_refs.insert(~\"return_to_mut\", ReturnToMutFnLangItem as uint);\n+    item_refs.insert(~\"check_not_borrowed\",\n+                     CheckNotBorrowedFnLangItem as uint);\n \n     LanguageItemCollector {\n         crate: crate,"}, {"sha": "3919c6bc8f108583a574ec3c9933b6db4131b38f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 47, "deletions": 149, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -62,6 +62,7 @@ use syntax::ast;\n use syntax::codemap::span;\n use syntax::print::pprust;\n \n+#[deriving_eq]\n enum categorization {\n     cat_rvalue,                     // result of eval'ing some misc expr\n     cat_special(special_kind),      //\n@@ -74,111 +75,18 @@ enum categorization {\n     cat_discr(cmt, ast::node_id),   // match discriminant (see preserve())\n }\n \n-impl categorization : cmp::Eq {\n-    pure fn eq(&self, other: &categorization) -> bool {\n-        match (*self) {\n-            cat_rvalue => {\n-                match (*other) {\n-                    cat_rvalue => true,\n-                    _ => false\n-                }\n-            }\n-            cat_special(e0a) => {\n-                match (*other) {\n-                    cat_special(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_local(e0a) => {\n-                match (*other) {\n-                    cat_local(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_binding(e0a) => {\n-                match (*other) {\n-                    cat_binding(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_arg(e0a) => {\n-                match (*other) {\n-                    cat_arg(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_stack_upvar(e0a) => {\n-                match (*other) {\n-                    cat_stack_upvar(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_deref(e0a, e1a, e2a) => {\n-                match (*other) {\n-                    cat_deref(e0b, e1b, e2b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            cat_comp(e0a, e1a) => {\n-                match (*other) {\n-                    cat_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            cat_discr(e0a, e1a) => {\n-                match (*other) {\n-                    cat_discr(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &categorization) -> bool { !(*self).eq(other) }\n-}\n-\n // different kinds of pointers:\n+#[deriving_eq]\n pub enum ptr_kind {\n     uniq_ptr,\n-    gc_ptr,\n+    gc_ptr(ast::mutability),\n     region_ptr(ty::Region),\n     unsafe_ptr\n }\n \n-impl ptr_kind : cmp::Eq {\n-    pure fn eq(&self, other: &ptr_kind) -> bool {\n-        match (*self) {\n-            uniq_ptr => {\n-                match (*other) {\n-                    uniq_ptr => true,\n-                    _ => false\n-                }\n-            }\n-            gc_ptr => {\n-                match (*other) {\n-                    gc_ptr => true,\n-                    _ => false\n-                }\n-            }\n-            region_ptr(e0a) => {\n-                match (*other) {\n-                    region_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            unsafe_ptr => {\n-                match (*other) {\n-                    unsafe_ptr => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &ptr_kind) -> bool { !(*self).eq(other) }\n-}\n-\n // I am coining the term \"components\" to mean \"pieces of a data\n // structure accessible without a dereference\":\n+#[deriving_eq]\n pub enum comp_kind {\n     comp_tuple,                  // elt in a tuple\n     comp_anon_field,             // anonymous field (in e.g.\n@@ -190,45 +98,8 @@ pub enum comp_kind {\n                ast::mutability)  // mutability of vec content\n }\n \n-impl comp_kind : cmp::Eq {\n-    pure fn eq(&self, other: &comp_kind) -> bool {\n-        match (*self) {\n-            comp_tuple => {\n-                match (*other) {\n-                    comp_tuple => true,\n-                    _ => false\n-                }\n-            }\n-            comp_anon_field => {\n-                match (*other) {\n-                    comp_anon_field => true,\n-                    _ => false\n-                }\n-            }\n-            comp_variant(e0a) => {\n-                match (*other) {\n-                    comp_variant(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            comp_field(e0a, e1a) => {\n-                match (*other) {\n-                    comp_field(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            comp_index(e0a, e1a) => {\n-                match (*other) {\n-                    comp_index(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &comp_kind) -> bool { !(*self).eq(other) }\n-}\n-\n // different kinds of expressions we might evaluate\n+#[deriving_eq]\n enum special_kind {\n     sk_method,\n     sk_static_item,\n@@ -237,13 +108,6 @@ enum special_kind {\n     sk_heap_upvar\n }\n \n-impl special_kind : cmp::Eq {\n-    pure fn eq(&self, other: &special_kind) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &special_kind) -> bool { !(*self).eq(other) }\n-}\n-\n // a complete categorization of a value indicating where it originated\n // and how it is located, as well as the mutability of the memory in\n // which the value is stored.\n@@ -339,14 +203,17 @@ fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         Some(deref_ptr(region_ptr((*f).meta.region)))\n       }\n \n-      ty::ty_box(*) |\n-      ty::ty_evec(_, ty::vstore_box) |\n+      ty::ty_box(mt) |\n+      ty::ty_evec(mt, ty::vstore_box) => {\n+        Some(deref_ptr(gc_ptr(mt.mutbl)))\n+      }\n+\n       ty::ty_estr(ty::vstore_box) => {\n-        Some(deref_ptr(gc_ptr))\n+        Some(deref_ptr(gc_ptr(ast::m_imm)))\n       }\n \n       ty::ty_fn(ref f) if (*f).meta.proto == ast::ProtoBox => {\n-        Some(deref_ptr(gc_ptr))\n+        Some(deref_ptr(gc_ptr(ast::m_imm)))\n       }\n \n       ty::ty_ptr(*) => {\n@@ -764,7 +631,7 @@ impl &mem_categorization_ctxt {\n                     // not loanable.\n                     match ptr {\n                         uniq_ptr => {Some(@lp_deref(*l, ptr))}\n-                        gc_ptr | region_ptr(_) | unsafe_ptr => {None}\n+                        gc_ptr(*) | region_ptr(_) | unsafe_ptr => {None}\n                     }\n                 };\n \n@@ -774,7 +641,7 @@ impl &mem_categorization_ctxt {\n                     uniq_ptr => {\n                         self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n                     }\n-                    gc_ptr | region_ptr(_) | unsafe_ptr => {\n+                    gc_ptr(*) | region_ptr(_) | unsafe_ptr => {\n                         mt.mutbl\n                     }\n                 };\n@@ -820,7 +687,7 @@ impl &mem_categorization_ctxt {\n               uniq_ptr => {\n                 self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n               }\n-              gc_ptr | region_ptr(_) | unsafe_ptr => {\n+              gc_ptr(_) | region_ptr(_) | unsafe_ptr => {\n                 mt.mutbl\n               }\n             };\n@@ -1027,7 +894,7 @@ impl &mem_categorization_ctxt {\n     fn ptr_sigil(ptr: ptr_kind) -> ~str {\n         match ptr {\n           uniq_ptr => ~\"~\",\n-          gc_ptr => ~\"@\",\n+          gc_ptr(_) => ~\"@\",\n           region_ptr(_) => ~\"&\",\n           unsafe_ptr => ~\"*\"\n         }\n@@ -1160,3 +1027,34 @@ fn field_mutbl(tcx: ty::ctxt,\n \n     return None;\n }\n+\n+impl categorization {\n+    fn derefs_through_mutable_box(&const self) -> bool {\n+        match *self {\n+            cat_deref(_, _, gc_ptr(ast::m_mutbl)) => {\n+                true\n+            }\n+            cat_deref(subcmt, _, _) |\n+            cat_comp(subcmt, _) |\n+            cat_discr(subcmt, _) |\n+            cat_stack_upvar(subcmt) => {\n+                subcmt.cat.derefs_through_mutable_box()\n+            }\n+            cat_rvalue |\n+            cat_special(*) |\n+            cat_local(*) |\n+            cat_binding(*) |\n+            cat_arg(*) => {\n+                false\n+            }\n+        }\n+    }\n+\n+    fn is_mutable_box(&const self) -> bool {\n+        match *self {\n+            cat_deref(_, _, gc_ptr(ast::m_mutbl)) => true,\n+            _ => false\n+        }\n+    }\n+}\n+"}, {"sha": "4418ecfef2cc5e926a35bfa252016d48ea589d31", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -3466,12 +3466,12 @@ impl Resolver {\n         for module_.children.each_ref |ident, namebindings| {\n             debug!(\"(computing exports) maybe export '%s'\",\n                    self.session.str_of(*ident));\n-            self.add_exports_of_namebindings(exports2,\n+            self.add_exports_of_namebindings(&mut *exports2,\n                                              *ident,\n                                              *namebindings,\n                                              TypeNS,\n                                              false);\n-            self.add_exports_of_namebindings(exports2,\n+            self.add_exports_of_namebindings(&mut *exports2,\n                                              *ident,\n                                              *namebindings,\n                                              ValueNS,\n@@ -3489,7 +3489,7 @@ impl Resolver {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe reexport '%s'\",\n                                self.session.str_of(*ident));\n-                        self.add_exports_of_namebindings(exports2,\n+                        self.add_exports_of_namebindings(&mut *exports2,\n                                                          *ident,\n                                                          target.bindings,\n                                                          *ns,"}, {"sha": "63ccefbce0ede17034633c681298871cc2e8dd32", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -901,26 +901,32 @@ fn collect_record_or_struct_fields(bcx: block, m: &[@Match], col: uint) ->\n     }\n }\n \n-fn root_pats_as_necessary(bcx: block, m: &[@Match],\n-                          col: uint, val: ValueRef)\n-{\n+fn root_pats_as_necessary(bcx: block,\n+                          m: &[@Match],\n+                          col: uint,\n+                          val: ValueRef)\n+                       -> block {\n+    let mut bcx = bcx;\n     for vec::each(m) |br| {\n         let pat_id = br.pats[col].id;\n \n         match bcx.ccx().maps.root_map.find({id:pat_id, derefs:0u}) {\n             None => (),\n-            Some(scope_id) => {\n+            Some(root_info) => {\n                 // Note: the scope_id will always be the id of the match.  See\n                 // the extended comment in rustc::middle::borrowck::preserve()\n                 // for details (look for the case covering cat_discr).\n \n                 let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n                                    mode: ByRef, source: FromLvalue};\n-                datum.root(bcx, scope_id);\n-                return; // if we kept going, we'd only re-root the same value\n+                bcx = datum.root(bcx, root_info);\n+                // If we kept going, we'd only re-root the same value, so\n+                // return now.\n+                return bcx;\n             }\n         }\n     }\n+    return bcx;\n }\n \n // Macro for deciding whether any of the remaining matches fit a given kind of\n@@ -1243,7 +1249,7 @@ fn compile_submatch(bcx: block,\n         if pat_id == 0 { pat_id = br.pats[col].id; }\n     }\n \n-    root_pats_as_necessary(bcx, m, col, val);\n+    bcx = root_pats_as_necessary(bcx, m, col, val);\n \n     let rec_fields = collect_record_or_struct_fields(bcx, m, col);\n     if rec_fields.len() > 0 {"}, {"sha": "7838a963aaf6f5cad6eae9154557c4551618196e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -40,6 +40,7 @@ use lib;\n use metadata::common::link_meta;\n use metadata::{csearch, cstore, decoder, encoder};\n use middle::astencode;\n+use middle::borrowck::RootInfo;\n use middle::pat_util::*;\n use middle::resolve;\n use middle::trans::_match;\n@@ -963,15 +964,28 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n // block, so an SSA value that is valid in the inner block may not be valid in\n // the outer block.  In fact, the inner block may not even execute.  Rather\n // than generate the full SSA form, we just use an alloca'd value.\n-fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n-                    root_loc: ValueRef, ty: ty::t) {\n-\n-    debug!(\"add_root_cleanup(bcx=%s, scope_id=%d, root_loc=%s, ty=%s)\",\n-           bcx.to_str(), scope_id, val_str(bcx.ccx().tn, root_loc),\n+fn add_root_cleanup(bcx: block,\n+                    root_info: RootInfo,\n+                    root_loc: ValueRef,\n+                    ty: ty::t) {\n+\n+    debug!(\"add_root_cleanup(bcx=%s, \\\n+                             scope=%d, \\\n+                             freezes=%?, \\\n+                             root_loc=%s, \\\n+                             ty=%s)\",\n+           bcx.to_str(),\n+           root_info.scope,\n+           root_info.freezes,\n+           val_str(bcx.ccx().tn, root_loc),\n            ppaux::ty_to_str(bcx.ccx().tcx, ty));\n \n-    let bcx_scope = find_bcx_for_scope(bcx, scope_id);\n-    add_clean_temp_mem(bcx_scope, root_loc, ty);\n+    let bcx_scope = find_bcx_for_scope(bcx, root_info.scope);\n+    if root_info.freezes {\n+        add_clean_frozen_root(bcx_scope, root_loc, ty);\n+    } else {\n+        add_clean_temp_mem(bcx_scope, root_loc, ty);\n+    }\n \n     fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n         let mut bcx_sid = bcx;\n@@ -1262,7 +1276,8 @@ fn trans_block_cleanups_(bcx: block,\n // In the last argument, Some(block) mean jump to this block, and none means\n // this is a landing pad and leaving should be accomplished with a resume\n // instruction.\n-fn cleanup_and_leave(bcx: block, upto: Option<BasicBlockRef>,\n+fn cleanup_and_leave(bcx: block,\n+                     upto: Option<BasicBlockRef>,\n                      leave: Option<BasicBlockRef>) {\n     let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n     let mut cur = bcx, bcx = bcx;\n@@ -1992,7 +2007,7 @@ fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n                                degen,\n                                path,\n                                vi,\n-                               i);\n+                               &mut *i);\n             }\n         }\n     }"}, {"sha": "beaf3b68617c1d26ca3c4983be8cddb96f6f7ed9", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -17,13 +17,26 @@ use lib::llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, ModuleRef};\n use libc::{c_uint, c_int};\n use middle::trans::common::*;\n \n+use core::cast::transmute;\n use core::cast;\n use core::libc;\n use core::str;\n use core::vec;\n use std::map::HashMap;\n use syntax::codemap;\n \n+fn terminate(cx: block, _: &str) {\n+    unsafe {\n+        cx.terminated = true;\n+    }\n+}\n+\n+fn check_not_terminated(cx: block) {\n+    if cx.terminated {\n+        fail ~\"already terminated!\";\n+    }\n+}\n+\n fn B(cx: block) -> BuilderRef {\n     unsafe {\n         let b = cx.fcx.ccx.builder.B;\n@@ -86,8 +99,8 @@ fn count_insn(cx: block, category: &str) {\n fn RetVoid(cx: block) {\n     unsafe {\n         if cx.unreachable { return; }\n-        assert (!cx.terminated);\n-        cx.terminated = true;\n+        check_not_terminated(cx);\n+        terminate(cx, \"RetVoid\");\n         count_insn(cx, \"retvoid\");\n         llvm::LLVMBuildRetVoid(B(cx));\n     }\n@@ -96,17 +109,17 @@ fn RetVoid(cx: block) {\n fn Ret(cx: block, V: ValueRef) {\n     unsafe {\n         if cx.unreachable { return; }\n-        assert (!cx.terminated);\n-        cx.terminated = true;\n+        check_not_terminated(cx);\n+        terminate(cx, \"Ret\");\n         count_insn(cx, \"ret\");\n         llvm::LLVMBuildRet(B(cx), V);\n     }\n }\n \n fn AggregateRet(cx: block, RetVals: ~[ValueRef]) {\n     if cx.unreachable { return; }\n-    assert (!cx.terminated);\n-    cx.terminated = true;\n+    check_not_terminated(cx);\n+    terminate(cx, \"AggregateRet\");\n     unsafe {\n         llvm::LLVMBuildAggregateRet(B(cx), vec::raw::to_ptr(RetVals),\n                                     RetVals.len() as c_uint);\n@@ -116,8 +129,8 @@ fn AggregateRet(cx: block, RetVals: ~[ValueRef]) {\n fn Br(cx: block, Dest: BasicBlockRef) {\n     unsafe {\n         if cx.unreachable { return; }\n-        assert (!cx.terminated);\n-        cx.terminated = true;\n+        check_not_terminated(cx);\n+        terminate(cx, \"Br\");\n         count_insn(cx, \"br\");\n         llvm::LLVMBuildBr(B(cx), Dest);\n     }\n@@ -127,8 +140,8 @@ fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n           Else: BasicBlockRef) {\n     unsafe {\n         if cx.unreachable { return; }\n-        assert (!cx.terminated);\n-        cx.terminated = true;\n+        check_not_terminated(cx);\n+        terminate(cx, \"CondBr\");\n         count_insn(cx, \"condbr\");\n         llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n     }\n@@ -138,8 +151,8 @@ fn Switch(cx: block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(V); }\n-        assert !cx.terminated;\n-        cx.terminated = true;\n+        check_not_terminated(cx);\n+        terminate(cx, \"Switch\");\n         return llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases as c_uint);\n     }\n }\n@@ -154,8 +167,8 @@ fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n     unsafe {\n         if cx.unreachable { return; }\n-        assert (!cx.terminated);\n-        cx.terminated = true;\n+        check_not_terminated(cx);\n+        terminate(cx, \"IndirectBr\");\n         count_insn(cx, \"indirectbr\");\n         llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests as c_uint);\n     }\n@@ -171,8 +184,8 @@ fn noname() -> *libc::c_char unsafe {\n fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n           Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { return; }\n-    assert (!cx.terminated);\n-    cx.terminated = true;\n+    check_not_terminated(cx);\n+    terminate(cx, \"Invoke\");\n     debug!(\"Invoke(%s with arguments (%s))\",\n            val_str(cx.ccx().tn, Fn),\n            str::connect(vec::map(Args, |a| val_str(cx.ccx().tn, *a)),\n@@ -188,8 +201,8 @@ fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n fn FastInvoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n               Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { return; }\n-    assert (!cx.terminated);\n-    cx.terminated = true;\n+    check_not_terminated(cx);\n+    terminate(cx, \"FastInvoke\");\n     unsafe {\n         count_insn(cx, \"fastinvoke\");\n         let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::raw::to_ptr(Args),\n@@ -985,7 +998,8 @@ fn Trap(cx: block) {\n fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n     unsafe {\n-        assert !cx.terminated && !cx.unreachable;\n+        check_not_terminated(cx);\n+        assert !cx.unreachable;\n         count_insn(cx, \"landingpad\");\n         return llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n                                       NumClauses as c_uint, noname());\n@@ -1001,8 +1015,8 @@ fn SetCleanup(cx: block, LandingPad: ValueRef) {\n \n fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n     unsafe {\n-        assert (!cx.terminated);\n-        cx.terminated = true;\n+        check_not_terminated(cx);\n+        terminate(cx, \"Resume\");\n         count_insn(cx, \"resume\");\n         return llvm::LLVMBuildResume(B(cx), Exn);\n     }"}, {"sha": "f943ee0773d47615102791c9730755387696a1b5", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -32,6 +32,7 @@ use middle::trans::build;\n use middle::trans::callee;\n use middle::trans::datum;\n use middle::trans::debuginfo;\n+use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::meth;\n use middle::trans::reachable;\n@@ -442,6 +443,31 @@ fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n         scope_clean_changed(scope_info);\n     }\n }\n+fn add_clean_frozen_root(bcx: block, val: ValueRef, t: ty::t) {\n+    debug!(\"add_clean_frozen_root(%s, %s, %s)\",\n+           bcx.to_str(), val_str(bcx.ccx().tn, val),\n+           ty_to_str(bcx.ccx().tcx, t));\n+    let {root, rooted} = root_for_cleanup(bcx, val, t);\n+    let cleanup_type = cleanup_type(bcx.tcx(), t);\n+    do in_scope_cx(bcx) |scope_info| {\n+        scope_info.cleanups.push(\n+            clean_temp(val, |bcx| {\n+                let bcx = callee::trans_rtcall_or_lang_call(\n+                    bcx,\n+                    bcx.tcx().lang_items.return_to_mut_fn(),\n+                    ~[\n+                        build::Load(bcx,\n+                                    build::PointerCast(bcx,\n+                                                       root,\n+                                                       T_ptr(T_ptr(T_i8()))))\n+                    ],\n+                    expr::Ignore\n+                );\n+                glue::drop_ty_root(bcx, root, rooted, t)\n+            }, cleanup_type));\n+        scope_clean_changed(scope_info);\n+    }\n+}\n fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n       heap_shared => {"}, {"sha": "8c024b364c3288039d7cab4bc7ff92a52743f647", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 88, "deletions": 40, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -98,6 +98,7 @@\n use core::prelude::*;\n \n use lib::llvm::ValueRef;\n+use middle::borrowck::RootInfo;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -534,26 +535,56 @@ impl Datum {\n         }\n     }\n \n-    fn root(bcx: block, scope_id: ast::node_id) {\n+    fn root(bcx: block, root_info: RootInfo) -> block {\n         /*!\n          *\n          * In some cases, borrowck will decide that an @T/@[]/@str\n          * value must be rooted for the program to be safe.  In that\n          * case, we will call this function, which will stash a copy\n          * away until we exit the scope `scope_id`. */\n \n-        debug!(\"root(scope_id=%?, self=%?)\",\n-               scope_id, self.to_str(bcx.ccx()));\n+        debug!(\"root(scope_id=%?, freezes=%?, self=%?)\",\n+               root_info.scope, root_info.freezes, self.to_str(bcx.ccx()));\n \n         if bcx.sess().trace() {\n             trans_trace(\n                 bcx, None,\n-                fmt!(\"preserving until end of scope %d\", scope_id));\n+                fmt!(\"preserving until end of scope %d\", root_info.scope));\n         }\n \n         let scratch = scratch_datum(bcx, self.ty, true);\n         self.copy_to_datum(bcx, INIT, scratch);\n-        base::add_root_cleanup(bcx, scope_id, scratch.val, scratch.ty);\n+        base::add_root_cleanup(bcx, root_info, scratch.val, scratch.ty);\n+\n+        // If we need to freeze the box, do that now.\n+        if root_info.freezes {\n+            callee::trans_rtcall_or_lang_call(\n+                bcx,\n+                bcx.tcx().lang_items.borrow_as_imm_fn(),\n+                ~[\n+                    Load(bcx,\n+                         PointerCast(bcx,\n+                                     scratch.val,\n+                                     T_ptr(T_ptr(T_i8()))))\n+                ],\n+                expr::Ignore)\n+        } else {\n+            bcx\n+        }\n+    }\n+\n+    fn perform_write_guard(bcx: block) -> block {\n+        // Create scratch space, but do not root it.\n+        let llval = match self.mode {\n+            ByValue => self.val,\n+            ByRef => Load(bcx, self.val),\n+        };\n+\n+        callee::trans_rtcall_or_lang_call(\n+            bcx,\n+            bcx.tcx().lang_items.check_not_borrowed_fn(),\n+            ~[ PointerCast(bcx, llval, T_ptr(T_i8())) ],\n+            expr::Ignore)\n     }\n \n     fn drop_val(bcx: block) -> block {\n@@ -610,7 +641,7 @@ impl Datum {\n         expr_id: ast::node_id, // id of expr being deref'd\n         derefs: uint,          // number of times deref'd already\n         is_auto: bool)         // if true, only deref if auto-derefable\n-        -> Option<Datum>\n+        -> (Option<Datum>, block)\n     {\n         let ccx = bcx.ccx();\n \n@@ -621,32 +652,39 @@ impl Datum {\n         // root the autoderef'd value, if necessary:\n         //\n         // (Note: root'd values are always boxes)\n-        match ccx.maps.root_map.find({id:expr_id, derefs:derefs}) {\n-            None => (),\n-            Some(scope_id) => {\n-                self.root(bcx, scope_id);\n-            }\n-        }\n+        let key = {id:expr_id, derefs:derefs};\n+        let bcx = match ccx.maps.root_map.find(key) {\n+            None => bcx,\n+            Some(root_info) => self.root(bcx, root_info)\n+        };\n+\n+        // Perform the write guard, if necessary.\n+        //\n+        // (Note: write-guarded values are always boxes)\n+        let bcx = match ccx.maps.write_guard_map.find(key) {\n+            None => bcx,\n+            Some(_) => self.perform_write_guard(bcx)\n+        };\n \n         match ty::get(self.ty).sty {\n             ty::ty_box(_) | ty::ty_uniq(_) => {\n-                return Some(self.box_body(bcx));\n+                return (Some(self.box_body(bcx)), bcx);\n             }\n             ty::ty_ptr(mt) => {\n                 if is_auto { // unsafe ptrs are not AUTO-derefable\n-                    return None;\n+                    return (None, bcx);\n                 } else {\n-                    return Some(deref_ptr(bcx, &self, mt.ty));\n+                    return (Some(deref_ptr(bcx, &self, mt.ty)), bcx);\n                 }\n             }\n             ty::ty_rptr(_, mt) => {\n-                return Some(deref_ptr(bcx, &self, mt.ty));\n+                return (Some(deref_ptr(bcx, &self, mt.ty)), bcx);\n             }\n             ty::ty_enum(did, ref substs) => {\n                 // Check whether this enum is a newtype enum:\n                 let variants = ty::enum_variants(ccx.tcx, did);\n                 if (*variants).len() != 1 || variants[0].args.len() != 1 {\n-                    return None;\n+                    return (None, bcx);\n                 }\n \n                 let ty = ty::subst(ccx.tcx, substs, variants[0].args[0]);\n@@ -655,12 +693,15 @@ impl Datum {\n                         // Recast lv.val as a pointer to the newtype\n                         // rather than a ptr to the enum type.\n                         let llty = T_ptr(type_of::type_of(ccx, ty));\n-                        Some(Datum {\n-                            val: PointerCast(bcx, self.val, llty),\n-                            ty: ty,\n-                            mode: ByRef,\n-                            source: FromLvalue\n-                        })\n+                        (\n+                            Some(Datum {\n+                                val: PointerCast(bcx, self.val, llty),\n+                                ty: ty,\n+                                mode: ByRef,\n+                                source: FromLvalue\n+                            }),\n+                            bcx\n+                        )\n                     }\n                     ByValue => {\n                         // Actually, this case cannot happen right\n@@ -672,7 +713,7 @@ impl Datum {\n                         // code in place here to do the right\n                         // thing if this change ever goes through.\n                         assert ty::type_is_immediate(ty);\n-                        Some(Datum {ty: ty, ..self})\n+                        (Some(Datum {ty: ty, ..self}), bcx)\n                     }\n                 };\n             }\n@@ -681,7 +722,7 @@ impl Datum {\n                 let fields = ty::struct_fields(ccx.tcx, did, substs);\n                 if fields.len() != 1 || fields[0].ident !=\n                     special_idents::unnamed_field {\n-                    return None;\n+                    return (None, bcx);\n                 }\n \n                 let ty = fields[0].mt.ty;\n@@ -691,12 +732,15 @@ impl Datum {\n                         // than a pointer to the struct type.\n                         // XXX: This isn't correct for structs with\n                         // destructors.\n-                        Some(Datum {\n-                            val: GEPi(bcx, self.val, [0, 0, 0]),\n-                            ty: ty,\n-                            mode: ByRef,\n-                            source: FromLvalue\n-                        })\n+                        (\n+                            Some(Datum {\n+                                val: GEPi(bcx, self.val, [0, 0, 0]),\n+                                ty: ty,\n+                                mode: ByRef,\n+                                source: FromLvalue\n+                            }),\n+                            bcx\n+                        )\n                     }\n                     ByValue => {\n                         // Actually, this case cannot happen right now,\n@@ -707,12 +751,12 @@ impl Datum {\n                         // code in place here to do the right thing if this\n                         // change ever goes through.\n                         assert ty::type_is_immediate(ty);\n-                        Some(Datum {ty: ty, ..self})\n+                        (Some(Datum {ty: ty, ..self}), bcx)\n                     }\n                 }\n             }\n             _ => { // not derefable.\n-                return None;\n+                return (None, bcx);\n             }\n         }\n \n@@ -728,10 +772,11 @@ impl Datum {\n \n     fn deref(bcx: block,\n              expr: @ast::expr,  // the expression whose value is being deref'd\n-             derefs: uint) -> Datum {\n+             derefs: uint)\n+          -> DatumBlock {\n         match self.try_deref(bcx, expr.id, derefs, false) {\n-            Some(lvres) => lvres,\n-            None => {\n+            (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },\n+            (None, _) => {\n                 bcx.ccx().sess.span_bug(\n                     expr.span, ~\"Cannot deref this expression\");\n             }\n@@ -740,7 +785,8 @@ impl Datum {\n \n     fn autoderef(bcx: block,\n                  expr_id: ast::node_id,\n-                 max: uint) -> Datum {\n+                 max: uint)\n+              -> DatumBlock {\n         let _icx = bcx.insn_ctxt(\"autoderef\");\n \n         debug!(\"autoderef(expr_id=%d, max=%?, self=%?)\",\n@@ -749,12 +795,14 @@ impl Datum {\n \n         let mut datum = self;\n         let mut derefs = 0u;\n+        let mut bcx = bcx;\n         while derefs < max {\n             derefs += 1u;\n             match datum.try_deref(bcx, expr_id, derefs, true) {\n-                None => break,\n-                Some(datum_deref) => {\n+                (None, new_bcx) => { bcx = new_bcx; break }\n+                (Some(datum_deref), new_bcx) => {\n                     datum = datum_deref;\n+                    bcx = new_bcx;\n                 }\n             }\n         }\n@@ -763,7 +811,7 @@ impl Datum {\n         // in which case we should have, or we asked to deref as many\n         // times as we can\n         assert derefs == max || max == uint::max_value;\n-        datum\n+        DatumBlock { bcx: bcx, datum: datum }\n     }\n \n     fn get_base_and_len(bcx: block) -> (ValueRef, ValueRef) {"}, {"sha": "a6f4b960aa709bfc5c1a009cef2d22d488c5daf7", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -202,7 +202,10 @@ fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n             });\n \n             if adj.autoderefs > 0 {\n-                datum = datum.autoderef(bcx, expr.id, adj.autoderefs);\n+                let DatumBlock { bcx: new_bcx, datum: new_datum } =\n+                    datum.autoderef(bcx, expr.id, adj.autoderefs);\n+                datum = new_datum;\n+                bcx = new_bcx;\n             }\n \n             datum = match adj.autoref {\n@@ -755,8 +758,8 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     // the lvalue in there, and then arrange for it to be cleaned up\n     // at the end of the scope with id `scope_id`:\n     let root_key = {id:expr.id, derefs:0u};\n-    for bcx.ccx().maps.root_map.find(root_key).each |scope_id| {\n-        unrooted_datum.root(bcx, *scope_id);\n+    for bcx.ccx().maps.root_map.find(root_key).each |&root_info| {\n+        bcx = unrooted_datum.root(bcx, root_info);\n     }\n \n     return DatumBlock {bcx: bcx, datum: unrooted_datum};\n@@ -779,8 +782,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n             }\n             ast::expr_unary(ast::deref, base) => {\n                 let basedatum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-                let derefdatum = basedatum.deref(bcx, base, 0);\n-                return DatumBlock {bcx: bcx, datum: derefdatum};\n+                return basedatum.deref(bcx, base, 0);\n             }\n             _ => {\n                 bcx.tcx().sess.span_bug("}, {"sha": "3403df6c1cc6243e12647bd9c41df0f179b1f583", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -74,7 +74,7 @@ fn add_u16(dest: &mut ~[u8], val: u16) {\n }\n \n fn add_substr(dest: &mut ~[u8], src: ~[u8]) {\n-    add_u16(dest, vec::len(src) as u16);\n+    add_u16(&mut *dest, vec::len(src) as u16);\n     *dest += src;\n }\n "}, {"sha": "fee2224d3f9814b3477436522eee60d4a1e2982b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -2206,8 +2206,15 @@ fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n       ty_rptr(re_static, mt) =>\n       kind_safe_for_default_mode() | mutable_type_kind(cx, mt),\n \n-      // General region pointers are copyable but NOT owned nor sendable\n-      ty_rptr(_, _) => kind_safe_for_default_mode(),\n+      ty_rptr(_, mt) => {\n+        if mt.mutbl == ast::m_mutbl {\n+            // Mutable region pointers are noncopyable\n+            kind_noncopyable()\n+        } else {\n+            // General region pointers are copyable but NOT owned nor sendable\n+            kind_safe_for_default_mode()\n+        }\n+      }\n \n       // Unique boxes and vecs have the kind of their contained type,\n       // but unique boxes can't be implicitly copyable."}, {"sha": "899c30bddcd40c8308f4eac12e34d68b9b3da22e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -2720,9 +2720,9 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                              sp,\n                              /*bad*/copy vs,\n                              id,\n-                             disr_vals,\n-                             disr_val,\n-                             variants);\n+                             &mut *disr_vals,\n+                             &mut *disr_val,\n+                             &mut *variants);\n                 }\n             }\n "}, {"sha": "83a6fac04d8dbf28efe1ff42799a9d8901e8bbb8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -721,7 +721,7 @@ impl CoherenceChecker {\n                 debug!(\n                     \"(creating impl) adding provided method `%s` to impl\",\n                     sess.str_of(provided_method.method_info.ident));\n-                vec::push(all_methods, provided_method.method_info);\n+                vec::push(&mut *all_methods, provided_method.method_info);\n             }\n         }\n "}, {"sha": "1113029a13706e71a7ff66d298b9a9f5e9a519d3", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -1278,7 +1278,7 @@ impl RegionVarBindings {\n \n         return (move graph);\n \n-        fn insert_edge(graph: &mut Graph,\n+        fn insert_edge(+graph: &mut Graph,\n                        node_id: RegionVid,\n                        edge_dir: Direction,\n                        edge_idx: uint) {"}, {"sha": "4d1a8af0b1dd7982b0ea1dd8d26ca90032da1c4f", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -430,22 +430,24 @@ impl<T: Const Owned> &RWWriteMode<T> {\n     /// Access the pre-downgrade RWARC in write mode.\n     fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n         match *self {\n-            RWWriteMode((data, ref token, _)) => {\n+            RWWriteMode((ref data, ref token, _)) => {\n                 do token.write {\n-                    blk(data)\n+                    blk(&mut **data)\n                 }\n             }\n         }\n     }\n     /// Access the pre-downgrade RWARC in write mode with a condvar.\n     fn write_cond<U>(blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n         match *self {\n-            RWWriteMode((data, ref token, ref poison)) => {\n+            RWWriteMode((ref data, ref token, ref poison)) => {\n                 do token.write_cond |cond| {\n                     let cvar = Condvar {\n-                        is_mutex: false, failed: poison.failed,\n-                        cond: cond };\n-                    blk(data, &cvar)\n+                        is_mutex: false,\n+                        failed: &mut *poison.failed,\n+                        cond: cond\n+                    };\n+                    blk(&mut **data, &cvar)\n                 }\n             }\n         }"}, {"sha": "d478970ca9f5e627fb4b4fc1d6949fea0fb47035", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -1322,7 +1322,12 @@ mod tests {\n     fn of_string2() {\n         let buf = @ mut ~\"1234567890\";\n         let mut i = 0;\n-        while i < 10 { *buf = *buf + *buf; i+=1;}\n+        while i < 10 {\n+            let a = *buf;\n+            let b = *buf;\n+            *buf = a + b;\n+            i+=1;\n+        }\n         let sample = @*buf;\n         let r      = of_str(sample);\n         assert char_len(r) == str::char_len(*sample);\n@@ -1353,7 +1358,12 @@ mod tests {\n     fn iter1() {\n         let buf = @ mut ~\"1234567890\";\n         let mut i = 0;\n-        while i < 10 { *buf = *buf + *buf; i+=1;}\n+        while i < 10 {\n+            let a = *buf;\n+            let b = *buf;\n+            *buf = a + b;\n+            i+=1;\n+        }\n         let sample = @*buf;\n         let r      = of_str(sample);\n \n@@ -1374,7 +1384,12 @@ mod tests {\n         let init = @~\"1234567890\";\n         let buf  = @mut * init;\n         let mut i = 0;\n-        while i < 8 { *buf = *buf + *buf; i+=1;}\n+        while i < 8 {\n+            let a = *buf;\n+            let b = *buf;\n+            *buf = a + b;\n+            i+=1;\n+        }\n         let sample = @*buf;\n         let r1     = of_str(sample);\n         let mut r2 = of_str(init);"}, {"sha": "d77e02f37b938a4d8e8918e85e832a98ff965a8d", "filename": "src/libstd/time.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -402,22 +402,22 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             None => Err(~\"Invalid year\")\n           },\n           'c' => {\n-            parse_type(s, pos, 'a', tm)\n+            parse_type(s, pos, 'a', &mut *tm)\n                 .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'b', tm))\n+                .chain(|pos| parse_type(s, pos, 'b', &mut *tm))\n                 .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'e', tm))\n+                .chain(|pos| parse_type(s, pos, 'e', &mut *tm))\n                 .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'T', tm))\n+                .chain(|pos| parse_type(s, pos, 'T', &mut *tm))\n                 .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'Y', tm))\n+                .chain(|pos| parse_type(s, pos, 'Y', &mut *tm))\n           }\n           'D' | 'x' => {\n-            parse_type(s, pos, 'm', tm)\n+            parse_type(s, pos, 'm', &mut *tm)\n                 .chain(|pos| parse_char(s, pos, '/'))\n-                .chain(|pos| parse_type(s, pos, 'd', tm))\n+                .chain(|pos| parse_type(s, pos, 'd', &mut *tm))\n                 .chain(|pos| parse_char(s, pos, '/'))\n-                .chain(|pos| parse_type(s, pos, 'y', tm))\n+                .chain(|pos| parse_type(s, pos, 'y', &mut *tm))\n           }\n           'd' => match match_digits(s, pos, 2u, false) {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n@@ -428,11 +428,11 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             None => Err(~\"Invalid day of the month\")\n           },\n           'F' => {\n-            parse_type(s, pos, 'Y', tm)\n+            parse_type(s, pos, 'Y', &mut *tm)\n                 .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'm', tm))\n+                .chain(|pos| parse_type(s, pos, 'm', &mut *tm))\n                 .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'd', tm))\n+                .chain(|pos| parse_type(s, pos, 'd', &mut *tm))\n           }\n           'H' => {\n             // FIXME (#2350): range check.\n@@ -513,18 +513,18 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             None => Err(~\"Invalid hour\")\n           },\n           'R' => {\n-            parse_type(s, pos, 'H', tm)\n+            parse_type(s, pos, 'H', &mut *tm)\n                 .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', tm))\n+                .chain(|pos| parse_type(s, pos, 'M', &mut *tm))\n           }\n           'r' => {\n-            parse_type(s, pos, 'I', tm)\n+            parse_type(s, pos, 'I', &mut *tm)\n                 .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', tm))\n+                .chain(|pos| parse_type(s, pos, 'M', &mut *tm))\n                 .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'S', tm))\n+                .chain(|pos| parse_type(s, pos, 'S', &mut *tm))\n                 .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'p', tm))\n+                .chain(|pos| parse_type(s, pos, 'p', &mut *tm))\n           }\n           'S' => {\n             // FIXME (#2350): range check.\n@@ -539,11 +539,11 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           }\n           //'s' {}\n           'T' | 'X' => {\n-            parse_type(s, pos, 'H', tm)\n+            parse_type(s, pos, 'H', &mut *tm)\n                 .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', tm))\n+                .chain(|pos| parse_type(s, pos, 'M', &mut *tm))\n                 .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'S', tm))\n+                .chain(|pos| parse_type(s, pos, 'S', &mut *tm))\n           }\n           't' => parse_char(s, pos, '\\t'),\n           'u' => {\n@@ -558,11 +558,11 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             }\n           }\n           'v' => {\n-            parse_type(s, pos, 'e', tm)\n+            parse_type(s, pos, 'e', &mut *tm)\n                 .chain(|pos|  parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'b', tm))\n+                .chain(|pos| parse_type(s, pos, 'b', &mut *tm))\n                 .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'Y', tm))\n+                .chain(|pos| parse_type(s, pos, 'Y', &mut *tm))\n           }\n           //'W' {}\n           'w' => {"}, {"sha": "66c3111b309600a0505620c8a9b6ca6e8fce0028", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -160,7 +160,7 @@ fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n                                            comments: &mut ~[cmnt]) {\n     while is_whitespace(rdr.curr) && !is_eof(rdr) {\n         if rdr.col == CharPos(0u) && rdr.curr == '\\n' {\n-            push_blank_line_comment(rdr, comments);\n+            push_blank_line_comment(rdr, &mut *comments);\n         }\n         bump(rdr);\n     }"}, {"sha": "1170ffba3ac5191930b40c897d4569a9d8a296a3", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -1 +1 @@\n-Subproject commit 4d392c86feb6389f550d8110d36fa90d66c09251\n+Subproject commit 1170ffba3ac5191930b40c897d4569a9d8a296a3"}, {"sha": "126135772ade08da981e21da8b3a5126fdc4d69e", "filename": "src/test/run-fail/write-guard-fail-2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Ftest%2Frun-fail%2Fwrite-guard-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Ftest%2Frun-fail%2Fwrite-guard-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fwrite-guard-fail-2.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -0,0 +1,11 @@\n+// error-pattern:borrowed\n+\n+struct S {\n+    x: int\n+}\n+\n+fn main() {\n+    let x = @mut S { x: 3 };\n+    let y: &S = x;\n+    x.x = 5;\n+}"}, {"sha": "ad4c794212121f07306806ace70b941421300043", "filename": "src/test/run-fail/write-guard-fail-3.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Ftest%2Frun-fail%2Fwrite-guard-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Ftest%2Frun-fail%2Fwrite-guard-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fwrite-guard-fail-3.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -0,0 +1,8 @@\n+// error-pattern:borrowed\n+\n+fn main() {\n+    let x = @mut 3;\n+    let y: &mut int = x;\n+    *x = 5;\n+}\n+"}, {"sha": "d393832c6e862496bbaa97877f9cbb49c4830392", "filename": "src/test/run-fail/write-guard-fail.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Ftest%2Frun-fail%2Fwrite-guard-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Ftest%2Frun-fail%2Fwrite-guard-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fwrite-guard-fail.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -0,0 +1,13 @@\n+// error-pattern:borrowed\n+\n+fn f(x: &int, y: @mut int) {\n+    unsafe {\n+        *y = 2;\n+    }\n+}\n+\n+fn main() {\n+    let x = @mut 3;\n+    f(x, x);\n+}\n+"}, {"sha": "bc370b20d155be51aea08931259747595d09b855", "filename": "src/test/run-pass/write-guard.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Ftest%2Frun-pass%2Fwrite-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6/src%2Ftest%2Frun-pass%2Fwrite-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwrite-guard.rs?ref=f405e41d7a43ebd7fdd0fcd90f6e0542a5a6ccf6", "patch": "@@ -0,0 +1,9 @@\n+fn f(x: &int) {\n+    io::println(x.to_str());\n+}\n+\n+fn main() {\n+    let x = @mut 3;\n+    f(x);\n+}\n+"}]}