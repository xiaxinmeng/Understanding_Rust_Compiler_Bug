{"sha": "4019118ec2f5fb1e6749e80b15fc70a9d0accd6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMTkxMThlYzJmNWZiMWU2NzQ5ZTgwYjE1ZmM3MGE5ZDBhY2NkNmY=", "commit": {"author": {"name": "Colin Sherratt", "email": "colin.sherratt@gmail.com", "date": "2014-11-12T01:22:07Z"}, "committer": {"name": "Colin Sherratt", "email": "colin.sherratt@gmail.com", "date": "2014-11-14T08:41:08Z"}, "message": "Added population count assertion in reserve. Cleaned up wrap_index.", "tree": {"sha": "4171913b93bb171ba436f69e276baae941b7ed7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4171913b93bb171ba436f69e276baae941b7ed7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4019118ec2f5fb1e6749e80b15fc70a9d0accd6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4019118ec2f5fb1e6749e80b15fc70a9d0accd6f", "html_url": "https://github.com/rust-lang/rust/commit/4019118ec2f5fb1e6749e80b15fc70a9d0accd6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4019118ec2f5fb1e6749e80b15fc70a9d0accd6f/comments", "author": {"login": "csherratt", "id": 26073376, "node_id": "MDQ6VXNlcjI2MDczMzc2", "avatar_url": "https://avatars.githubusercontent.com/u/26073376?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csherratt", "html_url": "https://github.com/csherratt", "followers_url": "https://api.github.com/users/csherratt/followers", "following_url": "https://api.github.com/users/csherratt/following{/other_user}", "gists_url": "https://api.github.com/users/csherratt/gists{/gist_id}", "starred_url": "https://api.github.com/users/csherratt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csherratt/subscriptions", "organizations_url": "https://api.github.com/users/csherratt/orgs", "repos_url": "https://api.github.com/users/csherratt/repos", "events_url": "https://api.github.com/users/csherratt/events{/privacy}", "received_events_url": "https://api.github.com/users/csherratt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csherratt", "id": 26073376, "node_id": "MDQ6VXNlcjI2MDczMzc2", "avatar_url": "https://avatars.githubusercontent.com/u/26073376?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csherratt", "html_url": "https://github.com/csherratt", "followers_url": "https://api.github.com/users/csherratt/followers", "following_url": "https://api.github.com/users/csherratt/following{/other_user}", "gists_url": "https://api.github.com/users/csherratt/gists{/gist_id}", "starred_url": "https://api.github.com/users/csherratt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csherratt/subscriptions", "organizations_url": "https://api.github.com/users/csherratt/orgs", "repos_url": "https://api.github.com/users/csherratt/repos", "events_url": "https://api.github.com/users/csherratt/events{/privacy}", "received_events_url": "https://api.github.com/users/csherratt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e549d8c3c6b69fea8cbbadf8028dc4fa62bdbfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e549d8c3c6b69fea8cbbadf8028dc4fa62bdbfb", "html_url": "https://github.com/rust-lang/rust/commit/5e549d8c3c6b69fea8cbbadf8028dc4fa62bdbfb"}], "stats": {"total": 25, "additions": 14, "deletions": 11}, "files": [{"sha": "359dffa08532138adebe75e185b207f40495b49c", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4019118ec2f5fb1e6749e80b15fc70a9d0accd6f/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4019118ec2f5fb1e6749e80b15fc70a9d0accd6f/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=4019118ec2f5fb1e6749e80b15fc70a9d0accd6f", "patch": "@@ -98,6 +98,10 @@ impl<T> RingBuf<T> {\n     /// Returns true iff the buffer is at capacity\n     #[inline]\n     fn is_full(&self) -> bool { self.cap - self.len() == 1 }\n+\n+    /// Returns the index in the underlying buffer for a given logical element index.\n+    #[inline]\n+    fn wrap_index(&self, idx: uint) -> uint { wrap_index(idx, self.cap) }\n }\n \n impl<T> RingBuf<T> {\n@@ -149,7 +153,7 @@ impl<T> RingBuf<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn get(&self, i: uint) -> Option<&T> {\n         if i < self.len() {\n-            let idx = wrap_index(self.tail + i, self.cap);\n+            let idx = self.wrap_index(self.tail + i);\n             unsafe { Some(&*self.ptr.offset(idx as int)) }\n         } else {\n             None\n@@ -179,7 +183,7 @@ impl<T> RingBuf<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n         if i < self.len() {\n-            let idx = wrap_index(self.tail + i, self.cap);\n+            let idx = self.wrap_index(self.tail + i);\n             unsafe { Some(&mut *self.ptr.offset(idx as int)) }\n         } else {\n             None\n@@ -208,8 +212,8 @@ impl<T> RingBuf<T> {\n     pub fn swap(&mut self, i: uint, j: uint) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n-        let ri = wrap_index(self.tail + i, self.cap);\n-        let rj = wrap_index(self.tail + j, self.cap);\n+        let ri = self.wrap_index(self.tail + i);\n+        let rj = self.wrap_index(self.tail + j);\n         unsafe {\n             ptr::swap(self.ptr.offset(ri as int), self.ptr.offset(rj as int))\n         }\n@@ -334,6 +338,7 @@ impl<T> RingBuf<T> {\n             }\n             debug_assert!(self.head < self.cap);\n             debug_assert!(self.tail < self.cap);\n+            debug_assert!(self.cap.count_ones() == 1);\n         }\n     }\n \n@@ -549,7 +554,7 @@ impl<T> RingBuf<T> {\n             None\n         } else {\n             let tail = self.tail;\n-            self.tail = wrap_index(self.tail + 1, self.cap);\n+            self.tail = self.wrap_index(self.tail + 1);\n             unsafe { Some(self.buffer_read(tail)) }\n         }\n     }\n@@ -573,7 +578,7 @@ impl<T> RingBuf<T> {\n             debug_assert!(!self.is_full());\n         }\n \n-        self.tail = wrap_index(self.tail - 1, self.cap);\n+        self.tail = self.wrap_index(self.tail - 1);\n         let tail = self.tail;\n         unsafe { self.buffer_write(tail, t); }\n     }\n@@ -604,7 +609,7 @@ impl<T> RingBuf<T> {\n         }\n \n         let head = self.head;\n-        self.head = wrap_index(self.head + 1, self.cap);\n+        self.head = self.wrap_index(self.head + 1);\n         unsafe { self.buffer_write(head, t) }\n     }\n \n@@ -633,7 +638,7 @@ impl<T> RingBuf<T> {\n         if self.is_empty() {\n             None\n         } else {\n-            self.head = wrap_index(self.head - 1, self.cap);\n+            self.head = self.wrap_index(self.head - 1);\n             let head = self.head;\n             unsafe { Some(self.buffer_read(head)) }\n         }\n@@ -644,9 +649,7 @@ impl<T> RingBuf<T> {\n #[inline]\n fn wrap_index(index: uint, size: uint) -> uint {\n     // size is always a power of 2\n-    let idx = index & (size - 1);\n-    debug_assert!(idx < size);\n-    idx\n+    index & (size - 1)\n }\n \n /// Calculate the number of elements left to be read in the buffer"}]}