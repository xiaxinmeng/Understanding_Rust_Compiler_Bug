{"sha": "692a22e69d916f8d0153ee9dfa906272561e364a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MmEyMmU2OWQ5MTZmOGQwMTUzZWU5ZGZhOTA2MjcyNTYxZTM2NGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-09T16:40:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-10T00:31:01Z"}, "message": "Change the elements in the task-local map to be actual key-value pairs", "tree": {"sha": "604f5474517cf0a49a7acfa6fd3765c2bae64474", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/604f5474517cf0a49a7acfa6fd3765c2bae64474"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/692a22e69d916f8d0153ee9dfa906272561e364a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/692a22e69d916f8d0153ee9dfa906272561e364a", "html_url": "https://github.com/rust-lang/rust/commit/692a22e69d916f8d0153ee9dfa906272561e364a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/692a22e69d916f8d0153ee9dfa906272561e364a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a89af1fa4cc8548a1c5e0a655a196d94b047ccd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7", "html_url": "https://github.com/rust-lang/rust/commit/a89af1fa4cc8548a1c5e0a655a196d94b047ccd7"}], "stats": {"total": 238, "additions": 111, "deletions": 127}, "files": [{"sha": "fbb11dfaa34c4279c6ca89113385a1acaa850e5c", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/692a22e69d916f8d0153ee9dfa906272561e364a/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/692a22e69d916f8d0153ee9dfa906272561e364a/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=692a22e69d916f8d0153ee9dfa906272561e364a", "patch": "@@ -28,7 +28,7 @@ magic.\n \n use prelude::*;\n \n-use task::local_data_priv::{local_get, local_pop, local_modify, local_set, Handle};\n+use task::local_data_priv::{local_get, local_pop, local_set, Handle};\n \n #[cfg(test)] use task;\n \n@@ -83,7 +83,11 @@ pub unsafe fn local_data_modify<T: 'static>(\n     key: LocalDataKey<T>,\n     modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n-    local_modify(Handle::new(), key, modify_fn)\n+    let cur = local_data_pop(key);\n+    match modify_fn(cur) {\n+        Some(next) => { local_data_set(key, next); }\n+        None => {}\n+    }\n }\n \n #[test]"}, {"sha": "04c1f972a82e1df57de5ebad164b672743512d60", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/692a22e69d916f8d0153ee9dfa906272561e364a/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/692a22e69d916f8d0153ee9dfa906272561e364a/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=692a22e69d916f8d0153ee9dfa906272561e364a", "patch": "@@ -32,7 +32,7 @@ pub struct Task {\n }\n \n pub struct GarbageCollector;\n-pub struct LocalStorage(*c_void, Option<~fn(*c_void)>);\n+pub struct LocalStorage(*c_void, Option<extern \"Rust\" fn(*c_void)>);\n \n pub struct Unwinder {\n     unwinding: bool,"}, {"sha": "16600ffab0635e7b796a87516ebf6237bbd880ff", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 104, "deletions": 124, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/692a22e69d916f8d0153ee9dfa906272561e364a/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/692a22e69d916f8d0153ee9dfa906272561e364a/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=692a22e69d916f8d0153ee9dfa906272561e364a", "patch": "@@ -11,7 +11,6 @@\n #[allow(missing_doc)];\n \n use cast;\n-use cmp::Eq;\n use libc;\n use local_data::LocalDataKey;\n use prelude::*;\n@@ -44,25 +43,19 @@ impl Handle {\n     }\n }\n \n-pub trait LocalData { }\n-impl<T: 'static> LocalData for @T { }\n+trait LocalData {}\n+impl<T: 'static> LocalData for T {}\n \n-impl Eq for @LocalData {\n-    fn eq(&self, other: &@LocalData) -> bool {\n-        unsafe {\n-            let ptr_a: &(uint, uint) = cast::transmute(self);\n-            let ptr_b: &(uint, uint) = cast::transmute(other);\n-            return ptr_a == ptr_b;\n-        }\n-    }\n-    fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n-}\n-\n-// If TLS is used heavily in future, this could be made more efficient with a\n-// proper map.\n-type TaskLocalElement = (*libc::c_void, *libc::c_void, @LocalData);\n-// Has to be a pointer at outermost layer; the foreign call returns void *.\n-type TaskLocalMap = ~[Option<TaskLocalElement>];\n+// The task-local-map actuall stores all TLS information. Right now it's a list\n+// of key-value pairs. Each value is an actual Rust type so that when the map is\n+// destroyed all of the contents are destroyed. Each of the keys are actually\n+// addresses which don't need to be destroyed.\n+//\n+// n.b. Has to be a pointer at outermost layer; the foreign call returns void *.\n+//\n+// n.b. If TLS is used heavily in future, this could be made more efficient with\n+// a proper map.\n+type TaskLocalMap = ~[Option<(*libc::c_void, @LocalData)>];\n \n fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n@@ -76,53 +69,52 @@ fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n-    match handle {\n-        OldHandle(task) => get_task_local_map(task),\n-        NewHandle(local_storage) => get_newsched_local_map(local_storage)\n-    }\n-}\n \n-unsafe fn get_task_local_map(task: *rust_task) -> &mut TaskLocalMap {\n+    unsafe fn oldsched_map(task: *rust_task) -> &mut TaskLocalMap {\n+        extern fn cleanup_extern_cb(map_ptr: *libc::c_void) {\n+            cleanup_task_local_map(map_ptr);\n+        }\n \n-    extern fn cleanup_task_local_map_extern_cb(map_ptr: *libc::c_void) {\n-        cleanup_task_local_map(map_ptr);\n+        // Relies on the runtime initialising the pointer to null.\n+        // Note: the map is an owned pointer and is \"owned\" by TLS. It is moved\n+        // into the tls slot for this task, and then mutable loans are taken\n+        // from this slot to modify the map.\n+        let map_ptr = rt::rust_get_task_local_data(task);\n+        if (*map_ptr).is_null() {\n+            // First time TLS is used, create a new map and set up the necessary\n+            // TLS information for its safe destruction\n+            let map: TaskLocalMap = ~[];\n+            *map_ptr = cast::transmute(map);\n+            rt::rust_task_local_data_atexit(task, cleanup_extern_cb);\n+        }\n+        return cast::transmute(map_ptr);\n     }\n \n-    // Relies on the runtime initialising the pointer to null.\n-    // Note: the map is an owned pointer and is \"owned\" by TLS. It is moved\n-    // into the tls slot for this task, and then mutable loans are taken from\n-    // this slot to modify the map.\n-    let map_ptr = rt::rust_get_task_local_data(task);\n-    if (*map_ptr).is_null() {\n-        // First time TLS is used, create a new map and set up the necessary\n-        // TLS information for its safe destruction\n-        let map: TaskLocalMap = ~[];\n-        *map_ptr = cast::transmute(map);\n-        rt::rust_task_local_data_atexit(task, cleanup_task_local_map_extern_cb);\n+    unsafe fn newsched_map(local: *mut LocalStorage) -> &mut TaskLocalMap {\n+        // This is based on the same idea as the oldsched code above.\n+        match &mut *local {\n+            // If the at_exit function is already set, then we just need to take\n+            // a loan out on the TLS map stored inside\n+            &LocalStorage(ref mut map_ptr, Some(_)) => {\n+                assert!(map_ptr.is_not_null());\n+                return cast::transmute(map_ptr);\n+            }\n+            // If this is the first time we've accessed TLS, perform similar\n+            // actions to the oldsched way of doing things.\n+            &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n+                assert!(map_ptr.is_null());\n+                assert!(at_exit.is_none());\n+                let map: TaskLocalMap = ~[];\n+                *map_ptr = cast::transmute(map);\n+                *at_exit = Some(cleanup_task_local_map);\n+                return cast::transmute(map_ptr);\n+            }\n+        }\n     }\n-    return cast::transmute(map_ptr);\n-}\n \n-unsafe fn get_newsched_local_map(local: *mut LocalStorage) -> &mut TaskLocalMap {\n-    // This is based on the same idea as the oldsched code above.\n-    match &mut *local {\n-        // If the at_exit function is already set, then we just need to take a\n-        // loan out on the TLS map stored inside\n-        &LocalStorage(ref mut map_ptr, Some(_)) => {\n-            assert!(map_ptr.is_not_null());\n-            return cast::transmute(map_ptr);\n-        }\n-        // If this is the first time we've accessed TLS, perform similar\n-        // actions to the oldsched way of doing things.\n-        &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n-            assert!(map_ptr.is_null());\n-            assert!(at_exit.is_none());\n-            let map: TaskLocalMap = ~[];\n-            *map_ptr = cast::transmute(map);\n-            let at_exit_fn: ~fn(*libc::c_void) = |p| cleanup_task_local_map(p);\n-            *at_exit = Some(at_exit_fn);\n-            return cast::transmute(map_ptr);\n-        }\n+    match handle {\n+        OldHandle(task) => oldsched_map(task),\n+        NewHandle(local_storage) => newsched_map(local_storage)\n     }\n }\n \n@@ -132,95 +124,83 @@ unsafe fn key_to_key_value<T: 'static>(key: LocalDataKey<T>) -> *libc::c_void {\n }\n \n // If returning Some(..), returns with @T with the map's reference. Careful!\n-unsafe fn local_data_lookup<T: 'static>(\n-    map: &mut TaskLocalMap, key: LocalDataKey<T>)\n-    -> Option<(uint, *libc::c_void)> {\n+unsafe fn local_data_lookup<T: 'static>(map: &TaskLocalMap,\n+                                        key: LocalDataKey<T>)\n+                                            -> Option<(uint, @T)>\n+{\n+    use managed::raw::BoxRepr;\n \n     let key_value = key_to_key_value(key);\n     for map.iter().enumerate().advance |(i, entry)| {\n         match *entry {\n-            Some((k, data, _)) if k == key_value => { return Some((i, data)); }\n+            Some((k, ref data)) if k == key_value => {\n+                // We now have the correct 'data' as type @LocalData which we\n+                // need to somehow transmute this back to @T. This was\n+                // originally stored into the map as:\n+                //\n+                //    let data = @T;\n+                //    let element = @data as @LocalData;\n+                //    insert(key, element);\n+                //\n+                // This means that the element stored is a 2-word pair (because\n+                // it's a trait). The second element is the vtable (we don't\n+                // need it), and the first element is actually '@@T'. Not only\n+                // is this @@T, but it's a pointer to the base of the @@T (box\n+                // and all), so we have to traverse this to find the actual\n+                // pointer that we want.\n+                let (_vtable, box) =\n+                    *cast::transmute::<&@LocalData, &(uint, *BoxRepr)>(data);\n+                let ptr: &@T = cast::transmute(&(*box).data);\n+                return Some((i, *ptr));\n+            }\n             _ => {}\n         }\n     }\n     return None;\n }\n \n-unsafe fn local_get_helper<T: 'static>(\n-    handle: Handle, key: LocalDataKey<T>,\n-    do_pop: bool) -> Option<@T> {\n-\n+pub unsafe fn local_pop<T: 'static>(handle: Handle,\n+                                    key: LocalDataKey<T>) -> Option<@T> {\n     let map = get_local_map(handle);\n-    // Interpreturn our findings from the map\n-    do local_data_lookup(map, key).map |result| {\n-        // A reference count magically appears on 'data' out of thin air. It\n-        // was referenced in the local_data box, though, not here, so before\n-        // overwriting the local_data_box we need to give an extra reference.\n-        // We must also give an extra reference when not removing.\n-        let (index, data_ptr) = *result;\n-        let data: @T = cast::transmute(data_ptr);\n-        cast::bump_box_refcount(data);\n-        if do_pop {\n+    match local_data_lookup(map, key) {\n+        Some((index, data)) => {\n             map[index] = None;\n+            Some(data)\n         }\n-        data\n+        None => None\n     }\n }\n \n-\n-pub unsafe fn local_pop<T: 'static>(\n-    handle: Handle,\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n-    local_get_helper(handle, key, true)\n-}\n-\n-pub unsafe fn local_get<T: 'static>(\n-    handle: Handle,\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n-    local_get_helper(handle, key, false)\n+pub unsafe fn local_get<T: 'static>(handle: Handle,\n+                                    key: LocalDataKey<T>) -> Option<@T> {\n+    match local_data_lookup(get_local_map(handle), key) {\n+        Some((_, data)) => Some(data),\n+        None => None\n+    }\n }\n \n-pub unsafe fn local_set<T: 'static>(\n-    handle: Handle, key: LocalDataKey<T>, data: @T) {\n-\n+pub unsafe fn local_set<T: 'static>(handle: Handle,\n+                                    key: LocalDataKey<T>,\n+                                    data: @T) {\n     let map = get_local_map(handle);\n-    // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n     let keyval = key_to_key_value(key);\n-    // We keep the data in two forms: one as an unsafe pointer, so we can get\n-    // it back by casting; another in an existential box, so the reference we\n-    // own on it can be dropped when the box is destroyed. The unsafe pointer\n-    // does not have a reference associated with it, so it may become invalid\n-    // when the box is destroyed.\n-    let data_ptr = *cast::transmute::<&@T, &*libc::c_void>(&data);\n-    let data_box = @data as @LocalData;\n-    // Construct new entry to store in the map.\n-    let new_entry = Some((keyval, data_ptr, data_box));\n-    // Find a place to put it.\n+\n+    // When the task-local map is destroyed, all the data needs to be cleaned\n+    // up. For this reason we can't do some clever tricks to store '@T' as a\n+    // '*c_void' or something like that. To solve the problem, we cast\n+    // everything to a trait (LocalData) which is then stored inside the map.\n+    // Upon destruction of the map, all the objects will be destroyed and the\n+    // traits have enough information about them to destroy themselves.\n+    let entry = Some((keyval, @data as @LocalData));\n+\n     match local_data_lookup(map, key) {\n-        Some((index, _old_data_ptr)) => {\n-            // Key already had a value set, _old_data_ptr, whose reference\n-            // will get dropped when the local_data box is overwritten.\n-            map[index] = new_entry;\n-        }\n+        Some((index, _)) => { map[index] = entry; }\n         None => {\n             // Find an empty slot. If not, grow the vector.\n             match map.iter().position(|x| x.is_none()) {\n-                Some(empty_index) => { map[empty_index] = new_entry; }\n-                None => { map.push(new_entry); }\n+                Some(empty_index) => { map[empty_index] = entry; }\n+                None => { map.push(entry); }\n             }\n         }\n     }\n }\n-\n-pub unsafe fn local_modify<T: 'static>(\n-    handle: Handle, key: LocalDataKey<T>,\n-    modify_fn: &fn(Option<@T>) -> Option<@T>) {\n-\n-    // Could be more efficient by doing the lookup work, but this is easy.\n-    let newdata = modify_fn(local_pop(handle, key));\n-    if newdata.is_some() {\n-        local_set(handle, key, newdata.unwrap());\n-    }\n-}"}]}