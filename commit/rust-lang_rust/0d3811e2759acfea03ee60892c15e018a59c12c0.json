{"sha": "0d3811e2759acfea03ee60892c15e018a59c12c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMzgxMWUyNzU5YWNmZWEwM2VlNjA4OTJjMTVlMDE4YTU5YzEyYzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-24T03:53:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-24T16:52:16Z"}, "message": "improve liveness so it reports unused vars / dead assignments\n\ndoesn't warn about pattern bindings yet though", "tree": {"sha": "124b68dd3d07c96adf0e1b5a63bcb7dca3f10de5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/124b68dd3d07c96adf0e1b5a63bcb7dca3f10de5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d3811e2759acfea03ee60892c15e018a59c12c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d3811e2759acfea03ee60892c15e018a59c12c0", "html_url": "https://github.com/rust-lang/rust/commit/0d3811e2759acfea03ee60892c15e018a59c12c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d3811e2759acfea03ee60892c15e018a59c12c0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "html_url": "https://github.com/rust-lang/rust/commit/30b47649ea37d211ee2dec4c541e6ba1e64c31a8"}], "stats": {"total": 446, "additions": 327, "deletions": 119}, "files": [{"sha": "25425e0e11802ff18a35543e7d86030194cdba99", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 207, "deletions": 83, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -252,7 +252,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     for decl.inputs.each { |arg|\n         #debug[\"adding argument %d\", arg.id];\n         (*fn_maps).add_variable(arg.id, arg.ident);\n-    }\n+    };\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n@@ -278,7 +278,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n \n     // compute liveness\n     let lsets = @liveness(fn_maps, specials);\n-    let entry_ln = (*lsets).compute(body);\n+    let entry_ln = (*lsets).compute(decl, body);\n \n     // check for various error conditions\n     let check_vt = visit::mk_vt(@{\n@@ -290,6 +290,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     check_vt.visit_block(body, lsets, check_vt);\n     lsets.check_ret(id, sp, fk, entry_ln);\n     lsets.check_fields(sp, entry_ln);\n+    lsets.warn_about_unused_args(sp, decl, entry_ln);\n }\n \n fn add_class_fields(self: @ir_maps, did: def_id) {\n@@ -384,11 +385,12 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n \n type users = {\n     reader: live_node,\n-    writer: live_node\n+    writer: live_node,\n+    used: bool\n };\n \n fn invalid_users() -> users {\n-    {reader: invalid_node(), writer: invalid_node()}\n+    {reader: invalid_node(), writer: invalid_node(), used: false}\n }\n \n type specials = {\n@@ -400,6 +402,7 @@ type specials = {\n \n const ACC_READ: uint = 1u;\n const ACC_WRITE: uint = 2u;\n+const ACC_USE: uint = 4u;\n \n class liveness {\n     let tcx: ty::ctxt;\n@@ -469,6 +472,15 @@ class liveness {\n         }\n     }\n \n+    fn pat_bindings(pat: @pat, f: fn(live_node, variable, span)) {\n+        let def_map = self.tcx.def_map;\n+        pat_util::pat_bindings(def_map, pat) {|p_id, sp, _n|\n+            let ln = self.live_node(p_id, sp);\n+            let var = self.variable(p_id, sp);\n+            f(ln, var, sp);\n+        }\n+    }\n+\n     fn idx(ln: live_node, var: variable) -> uint {\n         *ln * self.ir.num_vars + *var\n     }\n@@ -487,6 +499,11 @@ class liveness {\n         self.live_on_entry(self.successors[*ln], var)\n     }\n \n+    fn used_on_entry(ln: live_node, var: variable) -> bool {\n+        assert ln.is_valid();\n+        self.users[self.idx(ln, var)].used\n+    }\n+\n     fn assigned_on_entry(ln: live_node, var: variable)\n         -> option<live_node_kind> {\n \n@@ -580,6 +597,10 @@ class liveness {\n                                        self.users[idx].reader);\n             changed |= copy_if_invalid(self.users[succ_idx].writer,\n                                        self.users[idx].writer);\n+            if self.users[succ_idx].used && !self.users[idx].used {\n+                self.users[idx].used = true;\n+                changed = true;\n+            }\n         }\n \n         #debug[\"merge_from_succ(ln=%s, succ=%s, first_merge=%b, changed=%b)\",\n@@ -609,43 +630,39 @@ class liveness {\n                idx, self.ln_str(writer)];\n     }\n \n-    // Indicates that a new value for the local variable was assigned.\n-    fn write(writer: live_node, var: variable) {\n-        let idx = self.idx(writer, var);\n-        self.users[idx].reader = invalid_node();\n-        self.users[idx].writer = writer;\n-\n-        #debug[\"%s writes %s (idx=%u): %s\", writer.to_str(), var.to_str(),\n-               idx, self.ln_str(writer)];\n-    }\n-\n-    // Indicates that the current value of the local variable was used.\n-    fn read(reader: live_node, var: variable) {\n-        let idx = self.idx(reader, var);\n-        self.users[idx].reader = reader;\n-\n-        #debug[\"%s reads %s (idx=%u): %s\", reader.to_str(), var.to_str(),\n-               idx, self.ln_str(reader)];\n-    }\n-\n     // Either read, write, or both depending on the acc bitset\n     fn acc(ln: live_node, var: variable, acc: uint) {\n-        if (acc & ACC_WRITE) != 0u { self.write(ln, var) }\n+        let idx = self.idx(ln, var);\n+        let user = &mut self.users[idx];\n+\n+        if (acc & ACC_WRITE) != 0u {\n+            user.reader = invalid_node();\n+            user.writer = ln;\n+        }\n \n         // Important: if we both read/write, must do read second\n         // or else the write will override.\n-        if (acc & ACC_READ) != 0u { self.read(ln, var) }\n+        if (acc & ACC_READ) != 0u {\n+            user.reader = ln;\n+        }\n+\n+        if (acc & ACC_USE) != 0u {\n+            self.users[idx].used = true;\n+        }\n+\n+        #debug[\"%s accesses[%x] %s: %s\",\n+               ln.to_str(), acc, var.to_str(), self.ln_str(ln)];\n     }\n \n     // _______________________________________________________________________\n \n-    fn compute(body: blk) -> live_node {\n+    fn compute(decl: fn_decl, body: blk) -> live_node {\n         // if there is a `break` or `cont` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n         let entry_ln: live_node =\n             self.with_loop_nodes(self.s.exit_ln, self.s.exit_ln) {||\n-                self.propagate_through_fn_block(body)\n+                self.propagate_through_fn_block(decl, body)\n             };\n \n         // hack to skip the loop unless #debug is enabled:\n@@ -661,14 +678,28 @@ class liveness {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(blk: blk) -> live_node {\n-        if blk.node.expr.is_none() {\n-            self.read(self.s.fallthrough_ln, self.s.no_ret_var)\n+    fn propagate_through_fn_block(decl: fn_decl, blk: blk) -> live_node {\n+        // inputs passed by & mode should be considered live on exit:\n+        for decl.inputs.each { |arg|\n+            alt ty::resolved_mode(self.tcx, arg.mode) {\n+              by_mutbl_ref {\n+                let var = self.variable(arg.id, blk.span);\n+                self.acc(self.s.exit_ln, var, ACC_READ);\n+              }\n+              by_val | by_ref | by_move | by_copy {}\n+            }\n         }\n \n         // in a ctor, there is an implicit use of self.f for all fields f:\n         for self.ir.field_map.each_value { |var|\n-            self.read(self.s.fallthrough_ln, var);\n+            self.acc(self.s.exit_ln, var, ACC_READ|ACC_USE);\n+        }\n+\n+        // the fallthrough exit is only for those cases where we do not\n+        // explicitly return:\n+        self.init_from_succ(self.s.fallthrough_ln, self.s.exit_ln);\n+        if blk.node.expr.is_none() {\n+            self.acc(self.s.fallthrough_ln, self.s.no_ret_var, ACC_READ)\n         }\n \n         self.propagate_through_block(blk, self.s.fallthrough_ln)\n@@ -723,10 +754,7 @@ class liveness {\n \n         let opt_init = local.node.init.map { |i| i.expr };\n         let mut succ = self.propagate_through_opt_expr(opt_init, succ);\n-        let def_map = self.tcx.def_map;\n-        pat_util::pat_bindings(def_map, local.node.pat) { |p_id, sp, _n|\n-            let ln = self.live_node(p_id, sp);\n-            let var = self.variable(p_id, sp);\n+        self.pat_bindings(local.node.pat) { |ln, var, _sp|\n             self.init_from_succ(ln, succ);\n             self.define(ln, var);\n             succ = ln;\n@@ -752,7 +780,7 @@ class liveness {\n           // Interesting cases with control flow or which gen/kill\n \n           expr_path(_) {\n-            self.access_path(expr, succ, ACC_READ)\n+            self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n           expr_field(e, nm, _) {\n@@ -763,7 +791,7 @@ class liveness {\n             alt self.as_self_field(e, nm) {\n               some((ln, var)) {\n                 self.init_from_succ(ln, succ);\n-                self.read(ln, var);\n+                self.acc(ln, var, ACC_READ | ACC_USE);\n                 ln\n               }\n               none {\n@@ -779,7 +807,7 @@ class liveness {\n             (*caps).foldr(succ) { |cap, succ|\n                 self.init_from_succ(cap.ln, succ);\n                 let var = self.variable_from_rdef(cap.rv, expr.span);\n-                self.read(cap.ln, var);\n+                self.acc(cap.ln, var, ACC_READ | ACC_USE);\n                 cap.ln\n             }\n           }\n@@ -877,8 +905,14 @@ class liveness {\n           expr_swap(l, r) {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n-            let succ = self.write_lvalue(r, succ, ACC_WRITE|ACC_READ);\n-            let succ = self.write_lvalue(l, succ, ACC_WRITE|ACC_READ);\n+\n+            // I count swaps as `used` cause it might be something like:\n+            //    foo.bar <-> x\n+            // and I am too lazy to distinguish this case from\n+            //    y <-> x\n+            // (where both x, y are unused) just for a warning.\n+            let succ = self.write_lvalue(r, succ, ACC_WRITE|ACC_READ|ACC_USE);\n+            let succ = self.write_lvalue(l, succ, ACC_WRITE|ACC_READ|ACC_USE);\n             let succ = self.propagate_through_lvalue_components(r, succ);\n             self.propagate_through_lvalue_components(l, succ)\n           }\n@@ -1205,28 +1239,35 @@ class liveness {\n \n fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n     alt local.node.init {\n-      some({op: init_move, expr: expr}) {\n-        // can never be accessed uninitialized, but the move might\n-        // be invalid\n-        #debug[\"check_local() with move initializer\"];\n-        self.check_move_from_expr(expr, vt);\n-      }\n-      some({op: init_op, expr: _}) {\n-        // can never be accessed uninitialized\n-        #debug[\"check_local() with initializer\"];\n+      some({op: op, expr: expr}) {\n+\n+        // Initializer:\n+\n+        alt op {\n+          init_move {self.check_move_from_expr(expr, vt)}\n+          init_assign {}\n+        }\n+        self.warn_about_unused_or_dead_vars_in_pat(local.node.pat);\n+        if !local.node.is_mutbl {\n+            self.check_for_reassignments_in_pat(local.node.pat);\n+        }\n       }\n       none {\n+\n+        // No initializer: the variable might be unused; if not, it\n+        // should not be live at this point.\n+\n         #debug[\"check_local() with no initializer\"];\n-        let def_map = self.tcx.def_map;\n-        pat_util::pat_bindings(def_map, local.node.pat) {|p_id, sp, _n|\n-            let ln = (*self).live_node(p_id, sp);\n-            let var = (*self).variable(p_id, sp);\n-            alt (*self).live_on_exit(ln, var) {\n-              none { /* not live: good */ }\n-              some(lnk) {\n-                self.report_illegal_read(\n-                    local.span, lnk, var, possibly_uninitialized_variable);\n-              }\n+        (*self).pat_bindings(local.node.pat) { |ln, var, sp|\n+            if !self.warn_about_unused(sp, ln, var) {\n+                alt (*self).live_on_exit(ln, var) {\n+                  none { /* not live: good */ }\n+                  some(lnk) {\n+                    self.report_illegal_read(\n+                        local.span, lnk, var,\n+                        possibly_uninitialized_variable);\n+                  }\n+                }\n             }\n         }\n       }\n@@ -1262,11 +1303,21 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n       expr_assign(l, r) {\n         self.check_lvalue(l, vt);\n         vt.visit_expr(r, self, vt);\n+\n+        visit::visit_expr(expr, self, vt);\n       }\n \n       expr_move(l, r) {\n         self.check_lvalue(l, vt);\n         self.check_move_from_expr(r, vt);\n+\n+        visit::visit_expr(expr, self, vt);\n+      }\n+\n+      expr_assign_op(_, l, _) {\n+        self.check_lvalue(l, vt);\n+\n+        visit::visit_expr(expr, self, vt);\n       }\n \n       expr_call(f, args, _) {\n@@ -1293,7 +1344,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n       expr_assert(*) | expr_check(*) | expr_addr_of(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_cast(*) | expr_unary(*) | expr_fail(*) |\n       expr_ret(*) | expr_break | expr_cont | expr_lit(_) |\n-      expr_block(*) | expr_swap(*) | expr_assign_op(*) | expr_mac(*) {\n+      expr_block(*) | expr_swap(*) | expr_mac(*) {\n         visit::visit_expr(expr, self, vt);\n       }\n     }\n@@ -1434,32 +1485,20 @@ impl check_methods for @liveness {\n                 // only legal if there is no later assignment.\n                 let ln = (*self).live_node(expr.id, expr.span);\n                 let var = (*self).variable(nid, expr.span);\n-                alt (*self).assigned_on_exit(ln, var) {\n-                  some(lnk_expr(span)) {\n-                    self.tcx.sess.span_err(\n-                        span,\n-                        \"re-assignment of immutable variable\");\n-\n-                    self.tcx.sess.span_note(\n-                        expr.span,\n-                        \"prior assignment occurs here\");\n+                self.check_for_reassignment(ln, var, expr.span);\n+                self.warn_about_dead_assign(expr.span, ln, var);\n+              }\n+              def {\n+                alt relevant_def(def) {\n+                  some(rdef_var(nid)) {\n+                    let ln = (*self).live_node(expr.id, expr.span);\n+                    let var = (*self).variable(nid, expr.span);\n+                    self.warn_about_dead_assign(expr.span, ln, var);\n                   }\n-                  some(lnk) {\n-                    self.tcx.sess.span_bug(\n-                        expr.span,\n-                        #fmt[\"illegal writer: %?\", lnk]);\n-                   }\n+                  some(rdef_self) {}\n                   none {}\n                 }\n               }\n-              def_arg(*) | def_local(_, true) {\n-                // Assignment to a mutable variable; no conditions\n-                // req'd.  In the case of arguments, the mutability is\n-                // enforced by borrowck.\n-              }\n-              _ {\n-                // Not a variable, don't care\n-              }\n             }\n           }\n \n@@ -1471,6 +1510,33 @@ impl check_methods for @liveness {\n        }\n     }\n \n+    fn check_for_reassignments_in_pat(pat: @pat) {\n+        (*self).pat_bindings(pat) { |ln, var, sp|\n+            self.check_for_reassignment(ln, var, sp);\n+        }\n+    }\n+\n+    fn check_for_reassignment(ln: live_node, var: variable,\n+                              orig_span: span) {\n+        alt (*self).assigned_on_exit(ln, var) {\n+          some(lnk_expr(span)) {\n+            self.tcx.sess.span_err(\n+                span,\n+                \"re-assignment of immutable variable\");\n+\n+            self.tcx.sess.span_note(\n+                orig_span,\n+                \"prior assignment occurs here\");\n+          }\n+          some(lnk) {\n+            self.tcx.sess.span_bug(\n+                orig_span,\n+                #fmt[\"illegal writer: %?\", lnk]);\n+          }\n+          none {}\n+        }\n+    }\n+\n     fn report_illegal_read(chk_span: span,\n                            lnk: live_node_kind,\n                            var: variable,\n@@ -1499,4 +1565,62 @@ impl check_methods for @liveness {\n           }\n         }\n     }\n-}\n\\ No newline at end of file\n+\n+    fn should_warn(var: variable) -> option<str> {\n+        let name = self.ir.var_infos[*var].name;\n+        if name[0] == ('_' as u8) {none} else {some(name)}\n+    }\n+\n+    fn warn_about_unused_args(sp: span, decl: fn_decl, entry_ln: live_node) {\n+        for decl.inputs.each { |arg|\n+            let var = (*self).variable(arg.id, arg.ty.span);\n+            alt ty::resolved_mode(self.tcx, arg.mode) {\n+              by_mutbl_ref {\n+                // for mutable reference arguments, something like\n+                //    x = 1;\n+                // is not worth warning about, as it has visible\n+                // side effects outside the fn.\n+                alt (*self).assigned_on_entry(entry_ln, var) {\n+                  some(_) { /*ok*/ }\n+                  none {\n+                    // but if it is not written, it ought to be used\n+                    self.warn_about_unused(sp, entry_ln, var);\n+                  }\n+                }\n+              }\n+              by_val | by_ref | by_move | by_copy {\n+                self.warn_about_unused(sp, entry_ln, var);\n+              }\n+            }\n+        }\n+    }\n+\n+    fn warn_about_unused_or_dead_vars_in_pat(pat: @pat) {\n+        (*self).pat_bindings(pat) { |ln, var, sp|\n+            if !self.warn_about_unused(sp, ln, var) {\n+                self.warn_about_dead_assign(sp, ln, var);\n+            }\n+        }\n+    }\n+\n+    fn warn_about_unused(sp: span, ln: live_node, var: variable) -> bool {\n+        if !(*self).used_on_entry(ln, var) {\n+            for self.should_warn(var).each { |name|\n+                self.tcx.sess.span_warn(\n+                    sp, #fmt[\"unused variable: `%s`\", name]);\n+            }\n+            ret true;\n+        }\n+        ret false;\n+    }\n+\n+    fn warn_about_dead_assign(sp: span, ln: live_node, var: variable) {\n+        if (*self).live_on_exit(ln, var).is_none() {\n+            for self.should_warn(var).each { |name|\n+                self.tcx.sess.span_warn(\n+                    sp,\n+                    #fmt[\"value assigned to `%s` is never read\", name]);\n+            }\n+        }\n+    }\n+ }\n\\ No newline at end of file"}, {"sha": "7472ebe7effd9beb8755a8366e14f45478412841", "filename": "src/test/compile-fail/assign-imm-local-twice.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -1,9 +1,10 @@\n-fn test(cond: bool) {\n+fn test() {\n     let v: int;\n     v = 1; //! NOTE prior assignment occurs here\n+    #debug[\"v=%d\", v];\n     v = 2; //! ERROR re-assignment of immutable variable\n+    #debug[\"v=%d\", v];\n }\n \n fn main() {\n-    test(true);\n }"}, {"sha": "5018d4835ae4c132a94f777322061953802e9b08", "filename": "src/test/compile-fail/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -11,4 +11,5 @@ fn main() {\n         x = some(i+1); //! ERROR assigning to mutable local variable prohibited due to outstanding loan\n       }\n     }\n+    copy x; // just to prevent liveness warnings\n }"}, {"sha": "bf28af2db4d0bfd99327df253445d6db84e7859f", "filename": "src/test/compile-fail/borrowck-pat-reassign-sometimes-binding.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -14,4 +14,5 @@ fn main() {\n         x = some(1); //! ERROR assigning to mutable local variable prohibited due to outstanding loan\n       }\n     }\n+    copy x; // just to prevent liveness warnings\n }"}, {"sha": "2fc1bca5a6303befb0b4662151bc0d0f79470596", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -1,11 +1,11 @@\n-fn test(cond: bool) {\n+fn test() {\n     let v: int;\n     loop {\n         v = 1; //! ERROR re-assignment of immutable variable\n         //!^ NOTE prior assignment occurs here\n+        copy v; // just to prevent liveness warnings\n     }\n }\n \n fn main() {\n-    test(true);\n }"}, {"sha": "adb42333523a4f4945d51e26025625c1892032a0", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-op-eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -1,9 +1,9 @@\n-fn test(cond: bool) {\n+fn test() {\n     let v: int;\n     v = 2;  //! NOTE prior assignment occurs here\n     v += 1; //! ERROR re-assignment of immutable variable\n+    copy v;\n }\n \n fn main() {\n-    test(true);\n }"}, {"sha": "045ce5baa46a1aaac1adb2791179c532c108a766", "filename": "src/test/compile-fail/liveness-assign-imm-local-with-init.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -0,0 +1,9 @@\n+fn test() {\n+    let v: int = 1; //! NOTE prior assignment occurs here\n+    copy v;\n+    v = 2; //! ERROR re-assignment of immutable variable\n+    copy v;\n+}\n+\n+fn main() {\n+}"}, {"sha": "4b18845f878213a6e0ef2aedf024601d0d8f767e", "filename": "src/test/compile-fail/liveness-break-uninit-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -1,9 +1,7 @@\n fn foo() -> int {\n     let x: int;\n-    let i: int;\n \n     while 1 != 2  {\n-        i = 0;\n         break;\n         x = 0; //! WARNING unreachable statement\n     }"}, {"sha": "5bba9535e5314622f3265b7bddf1a6fa97a0d95c", "filename": "src/test/compile-fail/liveness-break-uninit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -1,9 +1,7 @@\n fn foo() -> int {\n     let x: int;\n-    let i: int;\n \n     loop {\n-        i = 0;\n         break;\n         x = 0;  //! WARNING unreachable statement\n     }"}, {"sha": "bda153b5ad4dc812aca9df857ee22c221f8c9b64", "filename": "src/test/compile-fail/liveness-dead.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -0,0 +1,20 @@\n+fn f1(&x: int) {\n+    x = 1; // no error\n+}\n+\n+fn f2() {\n+    let mut x = 3; //! WARNING value assigned to `x` is never read\n+    x = 4;\n+    copy x;\n+}\n+\n+fn f3() {\n+    let mut x = 3;\n+    copy x;\n+    x = 4; //! WARNING value assigned to `x` is never read\n+}\n+\n+fn main() { // leave this in here just to trigger compile-fail:\n+    let x: int;\n+    copy x; //! ERROR use of possibly uninitialized variable: `x`\n+}"}, {"sha": "a9a80e9ad6ed77e19ca09ca8a9c1a40af1178be1", "filename": "src/test/compile-fail/liveness-init-in-fru.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fru.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -5,4 +5,5 @@ type point = {x: int, y: int};\n fn main() {\n     let mut origin: point;\n     origin = {x: 10 with origin}; //! ERROR use of possibly uninitialized variable: `origin`\n+    copy origin;\n }"}, {"sha": "8d397e73b1fbdf4303a598ebcfeeb73d2f835198", "filename": "src/test/compile-fail/liveness-init-op-equal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-init-op-equal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-init-op-equal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-op-equal.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -1,8 +1,8 @@\n-fn test(cond: bool) {\n+fn test() {\n     let v: int;\n     v += 1; //! ERROR use of possibly uninitialized variable: `v`\n+    copy v;\n }\n \n fn main() {\n-    test(true);\n }"}, {"sha": "dacc1f4f922eabdebc7c68317cc464298716e547", "filename": "src/test/compile-fail/liveness-init-plus-equal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-init-plus-equal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-init-plus-equal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-plus-equal.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -1,8 +1,8 @@\n-fn test(cond: bool) {\n+fn test() {\n     let mut v: int;\n     v = v + 1; //! ERROR use of possibly uninitialized variable: `v`\n+    copy v;\n }\n \n fn main() {\n-    test(true);\n }"}, {"sha": "6045a137a9ecd61eb8317020f1b0399a53464765", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -1,5 +1,5 @@\n-fn main(s: [str]) {\n+fn main(_s: [str]) {\n     let a: [int] = [];\n-    vec::each(a) { |x| //! ERROR not all control paths return a value\n+    vec::each(a) { |_x| //! ERROR not all control paths return a value\n     }\n }"}, {"sha": "f0db4926734c5777b7e97ce0fae8c10cda789544", "filename": "src/test/compile-fail/liveness-move-from-mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-mode.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -1,4 +1,4 @@\n-fn take(-x: int) {}\n+fn take(-_x: int) {}\n \n fn main() {\n "}, {"sha": "1bdfc392bd9068b5e59454c48e852d437f9c8793", "filename": "src/test/compile-fail/liveness-move-in-loop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -9,6 +9,8 @@ fn main() {\n                 loop {\n                     x <- y; //! ERROR use of moved variable\n                     //!^ NOTE move of variable occurred here\n+\n+                    copy x;\n                 }\n             }\n         }"}, {"sha": "d5a95b08bd83e0eb9f326c623d8b1d65e19fd6a4", "filename": "src/test/compile-fail/liveness-move-in-while.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let mut x: int;\n     loop {\n         log(debug, y);\n-        while true { while true { while true { x <- y; } } }\n+        while true { while true { while true { x <- y; copy x; } } }\n         //!^ ERROR use of moved variable: `y`\n         //!^^ NOTE move of variable occurred here\n     }"}, {"sha": "d3a5395bfffce92a9fdc3d2960d4efde1e4137cb", "filename": "src/test/compile-fail/liveness-swap-uninit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-swap-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-swap-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-swap-uninit.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -1,5 +1,6 @@\n fn main() {\n-\tlet x = 3;\n-\tlet y;\n-\tx <-> y; //! ERROR use of possibly uninitialized variable: `y`\n+    let mut x = 3;\n+    let y;\n+    x <-> y; //! ERROR use of possibly uninitialized variable: `y`\n+    copy x;\n }"}, {"sha": "3d8e77040cdf3fa514d6f7a60d1477765476f7cc", "filename": "src/test/compile-fail/liveness-uninit-after-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-uninit-after-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-uninit-after-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-uninit-after-item.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let bar;\n-    fn baz(x: int) { }\n+    fn baz(_x: int) { }\n     bind baz(bar); //! ERROR use of possibly uninitialized variable: `bar`\n }\n "}, {"sha": "2a19c9808c71b16164bf7571ee31d3cb727c0a03", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -0,0 +1,50 @@\n+fn f1(x: int) {\n+    //!^ WARNING unused variable: `x`\n+    //!^^ WARNING unused variable x\n+    // (the 2nd one is from tstate)\n+}\n+\n+fn f1b(&x: int) {\n+    //!^ WARNING unused variable: `x`\n+    //!^^ WARNING unused variable x\n+    // (the 2nd one is from tstate)\n+}\n+\n+fn f2() {\n+    let x = 3;\n+    //!^ WARNING unused variable: `x`\n+    //!^^ WARNING unused variable x\n+    // (the 2nd one is from tstate)\n+}\n+\n+fn f3() {\n+    let mut x = 3;\n+    //!^ WARNING unused variable: `x`\n+    x += 4;\n+    //!^ WARNING value assigned to `x` is never read\n+}\n+\n+fn f3b() {\n+    let mut z = 3;\n+    //!^ WARNING unused variable: `z`\n+    loop {\n+        z += 4;\n+    }\n+}\n+\n+fn f4() {\n+    alt some(3) {\n+      some(i) {\n+      }\n+      none {}\n+    }\n+}\n+\n+// leave this in here just to trigger compile-fail:\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+fn main() {\n+    let i: int = 4;\n+    log(debug, false && { check is_even(i); true });\n+    even(i); //! ERROR unsatisfied precondition\n+}"}, {"sha": "34a932a5a16898dcdeb554ecbc7e0e500d8f5c55", "filename": "src/test/compile-fail/liveness-use-after-move.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -2,4 +2,5 @@ fn main() {\n     let x = @5;\n     let y <- x; //! NOTE move of variable occurred here\n     log(debug, *x); //! ERROR use of moved variable: `x`\n+    copy y;\n }"}, {"sha": "3827598c0a71d172a290020bb895e3aa06937bb3", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -8,7 +8,7 @@ enum _chan<T> = int;\n \n // Tests that \"log(debug, message);\" is flagged as using\n // message after the send deinitializes it\n-fn test00_start(ch: _chan<int>, message: int, count: int) {\n+fn test00_start(ch: _chan<int>, message: int, _count: int) {\n     send(ch, message); //! NOTE move of variable occurred here\n     log(debug, message); //! ERROR use of moved variable: `message`\n }"}, {"sha": "f1c02bd406f7fda6ea4649c8afefaabd8648f94d", "filename": "src/test/compile-fail/no-constraint-prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -2,9 +2,9 @@\n \n fn main() unsafe {\n     fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n-    let a: uint = 1u;\n-    let b: uint = 4u;\n-    let c: uint = 5u;\n+    let mut a: uint = 1u;\n+    let mut b: uint = 4u;\n+    let mut c: uint = 5u;\n     // make sure that the constraint le(b, a) exists...\n     check (uint::le(b, a));\n     // ...invalidate it..."}, {"sha": "19a7105098636e2cb6fcc310c0c8b436b40253d3", "filename": "src/test/compile-fail/pred-assign.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -7,9 +7,9 @@ fn f(a: int, b: int) : lt(a, b) { }\n pure fn lt(a: int, b: int) -> bool { ret a < b; }\n \n fn main() {\n-    let a: int = 10;\n-    let b: int = 23;\n-    let c: int = 77;\n+    let mut a: int = 10;\n+    let mut b: int = 23;\n+    let mut c: int = 77;\n     check (lt(a, b));\n     a = 24;\n     f(a, b);"}, {"sha": "b62f5a942f7ca367dd73f6ecb39f6b6535198253", "filename": "src/test/compile-fail/pred-swap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -7,9 +7,9 @@ fn f(a: int, b: int) : lt(a, b) { }\n pure fn lt(a: int, b: int) -> bool { ret a < b; }\n \n fn main() {\n-    let a: int = 10;\n-    let b: int = 23;\n-    let c: int = 77;\n+    let mut a: int = 10;\n+    let mut b: int = 23;\n+    let mut c: int = 77;\n     check (lt(a, b));\n     b <-> a;\n     f(a, b);"}, {"sha": "70c39d434ff942805f5fb0edda0360dc78a9c4d9", "filename": "src/test/compile-fail/tstate-fru.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Ftstate-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Ftstate-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-fru.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -10,4 +10,5 @@ fn main() {\n     origin = {x: 0, y: 0};\n     let right: point = {x: 10 with tested(origin)};\n         //!^ ERROR precondition\n+    copy right;\n }"}, {"sha": "5fff9aa9cb50c6d7fb36c62c7ef319c1a36aa82c", "filename": "src/test/compile-fail/tstate-while-loop-unsat-constriants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Ftstate-while-loop-unsat-constriants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Ftstate-while-loop-unsat-constriants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-while-loop-unsat-constriants.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -6,8 +6,8 @@ pure fn even(y: int) -> bool { true }\n \n fn main() {\n \n-    let y: int = 42;\n-    let x: int = 1;\n+    let mut y: int = 42;\n+    let mut x: int = 1;\n     check (even(y));\n     loop {\n         print_even(y);"}, {"sha": "498508d89807d1d8b26364813756dc8f54434f8d", "filename": "src/test/compile-fail/unsafe-alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3811e2759acfea03ee60892c15e018a59c12c0/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs?ref=0d3811e2759acfea03ee60892c15e018a59c12c0", "patch": "@@ -3,6 +3,6 @@\n enum foo { left({mut x: int}), right(bool) }\n \n fn main() {\n-    let x = left({mut x: 10});\n-    alt x { left(i) { x = right(false); log(debug, i); } _ { } }\n+    let mut x = left({mut x: 10});\n+    alt x { left(i) { x = right(false); copy x; log(debug, i); } _ { } }\n }"}]}