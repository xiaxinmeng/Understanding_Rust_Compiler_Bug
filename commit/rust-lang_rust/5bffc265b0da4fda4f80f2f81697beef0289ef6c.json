{"sha": "5bffc265b0da4fda4f80f2f81697beef0289ef6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViZmZjMjY1YjBkYTRmZGE0ZjgwZjJmODE2OTdiZWVmMDI4OWVmNmM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-12-31T21:20:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-31T21:20:51Z"}, "message": "Rollup merge of #80514 - pietroalbini:fix-install, r=Mark-Simulacrum\n\nFix broken ./x.py install\n\nDuring my tarball refactorings in https://github.com/rust-lang/rust/pull/79788 I changed the directory layout used by the tarball generation code, and that broke the other parts of rustbuild which hardcoded the paths of those directories. Namely, `./x.py install` relied on the uncompressed copy of the tarball left behind by `fabricate`/`rust-installer`, causing https://github.com/rust-lang/rust/issues/80494.\n\nWhile the easy fix for https://github.com/rust-lang/rust/issues/80494 would've been to just update the hardcoded paths to match the new structure, that fix would leave us in the same situation if we were to change the directory layout again in the future. Instead I refactored the code to return a `GeneratedTarball` struct as the output of all the dist steps, and I put all the paths the rest of rustbuild needs to care about in its fields. That way, future changes to `src/bootstrap/tarball.rs` will not break other stuff.\n\nThis PR is best reviewed commit-by-commit.\nr? `@Mark-Simulacrum`\n`@rustbot` modify labels: beta-nominated beta-accepted T-release", "tree": {"sha": "312328b34e91d11f01df8db7172a02a5058110be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/312328b34e91d11f01df8db7172a02a5058110be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bffc265b0da4fda4f80f2f81697beef0289ef6c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf7kCzCRBK7hj4Ov3rIwAAdHIIABF3sGQ/C6Yhc4zL0oA6Tc1l\nHogFuvwOWx/QuHuZxOKKjISxjm/DwL7OXdm7uBaM/MACeIHq4xLXp41kKaLCXO18\nMyCw7cw93zr0EvdWH0IA8bnwPdCYoUj8Ot9K0P143jFNh49TejIPAJcQ1teeq2Ug\nqhLdRSWa1qI1HUvP38zxtSSgnKTulPGSz3oh8cx9OpZWUjeVIp6jWvZKF3Ke4/5T\ni6vQVYiC+JjI2TV4aXfOG098GTrfZoLo7/IgYS9//wDn8T0/zzXNkdclqKGB1cbb\nudWaq5Gb3ywkwAe+VS1TXjG7mXQ7GIiujQJ4OgMz2JmQYUbRiXUP+/w3Dv1NIFY=\n=xXG0\n-----END PGP SIGNATURE-----\n", "payload": "tree 312328b34e91d11f01df8db7172a02a5058110be\nparent 7d247c924692ad60f22aee90965639fce969f3d8\nparent 8e0ab0fb5e35c96ba92c586eb9e0aa684fcd567d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1609449651 +0100\ncommitter GitHub <noreply@github.com> 1609449651 +0100\n\nRollup merge of #80514 - pietroalbini:fix-install, r=Mark-Simulacrum\n\nFix broken ./x.py install\n\nDuring my tarball refactorings in https://github.com/rust-lang/rust/pull/79788 I changed the directory layout used by the tarball generation code, and that broke the other parts of rustbuild which hardcoded the paths of those directories. Namely, `./x.py install` relied on the uncompressed copy of the tarball left behind by `fabricate`/`rust-installer`, causing https://github.com/rust-lang/rust/issues/80494.\n\nWhile the easy fix for https://github.com/rust-lang/rust/issues/80494 would've been to just update the hardcoded paths to match the new structure, that fix would leave us in the same situation if we were to change the directory layout again in the future. Instead I refactored the code to return a `GeneratedTarball` struct as the output of all the dist steps, and I put all the paths the rest of rustbuild needs to care about in its fields. That way, future changes to `src/bootstrap/tarball.rs` will not break other stuff.\n\nThis PR is best reviewed commit-by-commit.\nr? `@Mark-Simulacrum`\n`@rustbot` modify labels: beta-nominated beta-accepted T-release\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bffc265b0da4fda4f80f2f81697beef0289ef6c", "html_url": "https://github.com/rust-lang/rust/commit/5bffc265b0da4fda4f80f2f81697beef0289ef6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bffc265b0da4fda4f80f2f81697beef0289ef6c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d247c924692ad60f22aee90965639fce969f3d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d247c924692ad60f22aee90965639fce969f3d8", "html_url": "https://github.com/rust-lang/rust/commit/7d247c924692ad60f22aee90965639fce969f3d8"}, {"sha": "8e0ab0fb5e35c96ba92c586eb9e0aa684fcd567d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e0ab0fb5e35c96ba92c586eb9e0aa684fcd567d", "html_url": "https://github.com/rust-lang/rust/commit/8e0ab0fb5e35c96ba92c586eb9e0aa684fcd567d"}], "stats": {"total": 246, "additions": 110, "deletions": 136}, "files": [{"sha": "daec1656b27cdd00bc08360f4acfbee207ba201b", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5bffc265b0da4fda4f80f2f81697beef0289ef6c/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bffc265b0da4fda4f80f2f81697beef0289ef6c/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=5bffc265b0da4fda4f80f2f81697beef0289ef6c", "patch": "@@ -19,7 +19,7 @@ use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n use crate::config::TargetSelection;\n-use crate::tarball::{OverlayKind, Tarball};\n+use crate::tarball::{GeneratedTarball, OverlayKind, Tarball};\n use crate::tool::{self, Tool};\n use crate::util::{exe, is_dylib, timeit};\n use crate::{Compiler, DependencyType, Mode, LLVM_TOOLS};\n@@ -51,7 +51,7 @@ pub struct Docs {\n }\n \n impl Step for Docs {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -63,7 +63,7 @@ impl Step for Docs {\n     }\n \n     /// Builds the `rust-docs` installer component.\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let host = self.host;\n         if !builder.config.docs {\n             return None;\n@@ -86,7 +86,7 @@ pub struct RustcDocs {\n }\n \n impl Step for RustcDocs {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -98,7 +98,7 @@ impl Step for RustcDocs {\n     }\n \n     /// Builds the `rustc-docs` installer component.\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let host = self.host;\n         if !builder.config.compiler_docs {\n             return None;\n@@ -267,7 +267,7 @@ pub struct Mingw {\n }\n \n impl Step for Mingw {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -282,7 +282,7 @@ impl Step for Mingw {\n     ///\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n     /// without any extra installed software (e.g., we bundle gcc, libraries, etc).\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let host = self.host;\n         if !host.contains(\"pc-windows-gnu\") {\n             return None;\n@@ -307,7 +307,7 @@ pub struct Rustc {\n }\n \n impl Step for Rustc {\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -321,7 +321,7 @@ impl Step for Rustc {\n     }\n \n     /// Creates the `rustc` installer component.\n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n@@ -555,7 +555,7 @@ pub struct Std {\n }\n \n impl Step for Std {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -573,7 +573,7 @@ impl Step for Std {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n \n@@ -601,7 +601,7 @@ pub struct RustcDev {\n }\n \n impl Step for RustcDev {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -620,7 +620,7 @@ impl Step for RustcDev {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         if skip_host_target_lib(builder, compiler) {\n@@ -660,7 +660,7 @@ pub struct Analysis {\n }\n \n impl Step for Analysis {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -683,7 +683,7 @@ impl Step for Analysis {\n     }\n \n     /// Creates a tarball of save-analysis metadata, if available.\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -796,7 +796,7 @@ pub struct Src;\n \n impl Step for Src {\n     /// The output path of the src installer tarball\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -809,7 +809,7 @@ impl Step for Src {\n     }\n \n     /// Creates the `rust-src` installer component\n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let tarball = Tarball::new_targetless(builder, \"rust-src\");\n \n         // A lot of tools expect the rust-src component to be entirely in this directory, so if you\n@@ -848,7 +848,7 @@ pub struct PlainSourceTarball;\n \n impl Step for PlainSourceTarball {\n     /// Produces the location of the tarball generated\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -862,7 +862,7 @@ impl Step for PlainSourceTarball {\n     }\n \n     /// Creates the plain source tarball\n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let tarball = Tarball::new(builder, \"rustc\", \"src\");\n         let plain_dst_src = tarball.image_dir();\n \n@@ -941,7 +941,7 @@ pub struct Cargo {\n }\n \n impl Step for Cargo {\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -959,7 +959,7 @@ impl Step for Cargo {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let compiler = self.compiler;\n         let target = self.target;\n \n@@ -995,7 +995,7 @@ pub struct Rls {\n }\n \n impl Step for Rls {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1013,7 +1013,7 @@ impl Step for Rls {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1041,7 +1041,7 @@ pub struct RustAnalyzer {\n }\n \n impl Step for RustAnalyzer {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1059,7 +1059,7 @@ impl Step for RustAnalyzer {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1090,7 +1090,7 @@ pub struct Clippy {\n }\n \n impl Step for Clippy {\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1108,7 +1108,7 @@ impl Step for Clippy {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1140,7 +1140,7 @@ pub struct Miri {\n }\n \n impl Step for Miri {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1158,7 +1158,7 @@ impl Step for Miri {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1193,7 +1193,7 @@ pub struct Rustfmt {\n }\n \n impl Step for Rustfmt {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1211,7 +1211,7 @@ impl Step for Rustfmt {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n \n@@ -1316,11 +1316,11 @@ impl Step for Extended {\n             tarballs.push(mingw_installer.unwrap());\n         }\n \n-        let mut tarball = Tarball::new(builder, \"rust\", &target.triple);\n-        let work = tarball.persist_work_dir();\n-        tarball.combine(&tarballs);\n+        let tarball = Tarball::new(builder, \"rust\", &target.triple);\n+        let generated = tarball.combine(&tarballs);\n \n         let tmp = tmpdir(builder).join(\"combined-tarball\");\n+        let work = generated.work_dir();\n \n         let mut license = String::new();\n         license += &builder.read(&builder.src.join(\"COPYRIGHT\"));\n@@ -1870,7 +1870,7 @@ pub struct LlvmTools {\n }\n \n impl Step for LlvmTools {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1881,7 +1881,7 @@ impl Step for LlvmTools {\n         run.builder.ensure(LlvmTools { target: run.target });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let target = self.target;\n         assert!(builder.config.extended);\n \n@@ -1924,7 +1924,7 @@ pub struct RustDev {\n }\n \n impl Step for RustDev {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -1936,7 +1936,7 @@ impl Step for RustDev {\n         run.builder.ensure(RustDev { target: run.target });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let target = self.target;\n \n         /* run only if llvm-config isn't used */\n@@ -1989,7 +1989,7 @@ pub struct BuildManifest {\n }\n \n impl Step for BuildManifest {\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const DEFAULT: bool = false;\n     const ONLY_HOSTS: bool = true;\n \n@@ -2001,7 +2001,7 @@ impl Step for BuildManifest {\n         run.builder.ensure(BuildManifest { target: run.target });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let build_manifest = builder.tool_exe(Tool::BuildManifest);\n \n         let tarball = Tarball::new(builder, \"build-manifest\", &self.target.triple);\n@@ -2021,7 +2021,7 @@ pub struct ReproducibleArtifacts {\n }\n \n impl Step for ReproducibleArtifacts {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n "}, {"sha": "96164947943ba4760926023f19b2595c083f881c", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 31, "deletions": 75, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5bffc265b0da4fda4f80f2f81697beef0289ef6c/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bffc265b0da4fda4f80f2f81697beef0289ef6c/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=5bffc265b0da4fda4f80f2f81697beef0289ef6c", "patch": "@@ -10,60 +10,19 @@ use std::process::Command;\n \n use build_helper::t;\n \n-use crate::dist::{self, pkgname, sanitize_sh, tmpdir};\n+use crate::dist::{self, sanitize_sh};\n+use crate::tarball::GeneratedTarball;\n use crate::Compiler;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::config::{Config, TargetSelection};\n \n-pub fn install_docs(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"docs\", \"rust-docs\", stage, Some(host));\n-}\n-\n-pub fn install_std(builder: &Builder<'_>, stage: u32, target: TargetSelection) {\n-    install_sh(builder, \"std\", \"rust-std\", stage, Some(target));\n-}\n-\n-pub fn install_cargo(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"cargo\", \"cargo\", stage, Some(host));\n-}\n-\n-pub fn install_rls(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"rls\", \"rls\", stage, Some(host));\n-}\n-\n-pub fn install_rust_analyzer(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"rust-analyzer\", \"rust-analyzer\", stage, Some(host));\n-}\n-\n-pub fn install_clippy(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"clippy\", \"clippy\", stage, Some(host));\n-}\n-pub fn install_miri(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"miri\", \"miri\", stage, Some(host));\n-}\n-\n-pub fn install_rustfmt(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"rustfmt\", \"rustfmt\", stage, Some(host));\n-}\n-\n-pub fn install_analysis(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"analysis\", \"rust-analysis\", stage, Some(host));\n-}\n-\n-pub fn install_src(builder: &Builder<'_>, stage: u32) {\n-    install_sh(builder, \"src\", \"rust-src\", stage, None);\n-}\n-pub fn install_rustc(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"rustc\", \"rustc\", stage, Some(host));\n-}\n-\n fn install_sh(\n     builder: &Builder<'_>,\n     package: &str,\n-    name: &str,\n     stage: u32,\n     host: Option<TargetSelection>,\n+    tarball: &GeneratedTarball,\n ) {\n     builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n@@ -108,15 +67,10 @@ fn install_sh(\n     let empty_dir = builder.out.join(\"tmp/empty_dir\");\n \n     t!(fs::create_dir_all(&empty_dir));\n-    let package_name = if let Some(host) = host {\n-        format!(\"{}-{}\", pkgname(builder, name), host.triple)\n-    } else {\n-        pkgname(builder, name)\n-    };\n \n     let mut cmd = Command::new(\"sh\");\n     cmd.current_dir(&empty_dir)\n-        .arg(sanitize_sh(&tmpdir(builder).join(&package_name).join(\"install.sh\")))\n+        .arg(sanitize_sh(&tarball.decompressed_output().join(\"install.sh\")))\n         .arg(format!(\"--prefix={}\", sanitize_sh(&prefix)))\n         .arg(format!(\"--sysconfdir={}\", sanitize_sh(&sysconfdir)))\n         .arg(format!(\"--datadir={}\", sanitize_sh(&datadir)))\n@@ -191,75 +145,77 @@ macro_rules! install {\n \n install!((self, builder, _config),\n     Docs, \"src/doc\", _config.docs, only_hosts: false, {\n-        builder.ensure(dist::Docs { host: self.target });\n-        install_docs(builder, self.compiler.stage, self.target);\n+        let tarball = builder.ensure(dist::Docs { host: self.target }).expect(\"missing docs\");\n+        install_sh(builder, \"docs\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Std, \"library/std\", true, only_hosts: false, {\n         for target in &builder.targets {\n-            builder.ensure(dist::Std {\n+            let tarball = builder.ensure(dist::Std {\n                 compiler: self.compiler,\n                 target: *target\n-            });\n-            install_std(builder, self.compiler.stage, *target);\n+            }).expect(\"missing std\");\n+            install_sh(builder, \"std\", self.compiler.stage, Some(*target), &tarball);\n         }\n     };\n     Cargo, \"cargo\", Self::should_build(_config), only_hosts: true, {\n-        builder.ensure(dist::Cargo { compiler: self.compiler, target: self.target });\n-        install_cargo(builder, self.compiler.stage, self.target);\n+        let tarball = builder.ensure(dist::Cargo { compiler: self.compiler, target: self.target });\n+        install_sh(builder, \"cargo\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Rls, \"rls\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rls { compiler: self.compiler, target: self.target }).is_some() {\n-            install_rls(builder, self.compiler.stage, self.target);\n+        if let Some(tarball) = builder.ensure(dist::Rls { compiler: self.compiler, target: self.target }) {\n+            install_sh(builder, \"rls\", self.compiler.stage, Some(self.target), &tarball);\n         } else {\n             builder.info(\n                 &format!(\"skipping Install RLS stage{} ({})\", self.compiler.stage, self.target),\n             );\n         }\n     };\n     RustAnalyzer, \"rust-analyzer\", Self::should_build(_config), only_hosts: true, {\n-        builder.ensure(dist::RustAnalyzer { compiler: self.compiler, target: self.target });\n-        install_rust_analyzer(builder, self.compiler.stage, self.target);\n+        let tarball = builder\n+            .ensure(dist::RustAnalyzer { compiler: self.compiler, target: self.target })\n+            .expect(\"missing rust-analyzer\");\n+        install_sh(builder, \"rust-analyzer\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n-        builder.ensure(dist::Clippy { compiler: self.compiler, target: self.target });\n-        install_clippy(builder, self.compiler.stage, self.target);\n+        let tarball = builder.ensure(dist::Clippy { compiler: self.compiler, target: self.target });\n+        install_sh(builder, \"clippy\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Miri, \"miri\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Miri { compiler: self.compiler, target: self.target }).is_some() {\n-            install_miri(builder, self.compiler.stage, self.target);\n+        if let Some(tarball) = builder.ensure(dist::Miri { compiler: self.compiler, target: self.target }) {\n+            install_sh(builder, \"miri\", self.compiler.stage, Some(self.target), &tarball);\n         } else {\n             builder.info(\n                 &format!(\"skipping Install miri stage{} ({})\", self.compiler.stage, self.target),\n             );\n         }\n     };\n     Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rustfmt {\n+        if let Some(tarball) = builder.ensure(dist::Rustfmt {\n             compiler: self.compiler,\n             target: self.target\n-        }).is_some() {\n-            install_rustfmt(builder, self.compiler.stage, self.target);\n+        }) {\n+            install_sh(builder, \"rustfmt\", self.compiler.stage, Some(self.target), &tarball);\n         } else {\n             builder.info(\n                 &format!(\"skipping Install Rustfmt stage{} ({})\", self.compiler.stage, self.target),\n             );\n         }\n     };\n     Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {\n-        builder.ensure(dist::Analysis {\n+        let tarball = builder.ensure(dist::Analysis {\n             // Find the actual compiler (handling the full bootstrap option) which\n             // produced the save-analysis data because that data isn't copied\n             // through the sysroot uplifting.\n             compiler: builder.compiler_for(builder.top_stage, builder.config.build, self.target),\n             target: self.target\n-        });\n-        install_analysis(builder, self.compiler.stage, self.target);\n+        }).expect(\"missing analysis\");\n+        install_sh(builder, \"analysis\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n-        builder.ensure(dist::Rustc {\n+        let tarball = builder.ensure(dist::Rustc {\n             compiler: builder.compiler(builder.top_stage, self.target),\n         });\n-        install_rustc(builder, self.compiler.stage, self.target);\n+        install_sh(builder, \"rustc\", self.compiler.stage, Some(self.target), &tarball);\n     };\n );\n \n@@ -284,7 +240,7 @@ impl Step for Src {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        builder.ensure(dist::Src);\n-        install_src(builder, self.stage);\n+        let tarball = builder.ensure(dist::Src);\n+        install_sh(builder, \"src\", self.stage, None, &tarball);\n     }\n }"}, {"sha": "7fb03056f1bd3ae7a99a1c125c242c51f37b76e4", "filename": "src/bootstrap/tarball.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5bffc265b0da4fda4f80f2f81697beef0289ef6c/src%2Fbootstrap%2Ftarball.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bffc265b0da4fda4f80f2f81697beef0289ef6c/src%2Fbootstrap%2Ftarball.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftarball.rs?ref=5bffc265b0da4fda4f80f2f81697beef0289ef6c", "patch": "@@ -97,7 +97,6 @@ pub(crate) struct Tarball<'a> {\n \n     include_target_in_component_name: bool,\n     is_preview: bool,\n-    delete_temp_dir: bool,\n }\n \n impl<'a> Tarball<'a> {\n@@ -136,7 +135,6 @@ impl<'a> Tarball<'a> {\n \n             include_target_in_component_name: false,\n             is_preview: false,\n-            delete_temp_dir: true,\n         }\n     }\n \n@@ -198,12 +196,7 @@ impl<'a> Tarball<'a> {\n         self.builder.cp_r(src.as_ref(), &dest);\n     }\n \n-    pub(crate) fn persist_work_dir(&mut self) -> PathBuf {\n-        self.delete_temp_dir = false;\n-        self.temp_dir.clone()\n-    }\n-\n-    pub(crate) fn generate(self) -> PathBuf {\n+    pub(crate) fn generate(self) -> GeneratedTarball {\n         let mut component_name = self.component.clone();\n         if self.is_preview {\n             component_name.push_str(\"-preview\");\n@@ -227,20 +220,20 @@ impl<'a> Tarball<'a> {\n         })\n     }\n \n-    pub(crate) fn combine(self, tarballs: &[PathBuf]) {\n-        let mut input_tarballs = tarballs[0].as_os_str().to_os_string();\n+    pub(crate) fn combine(self, tarballs: &[GeneratedTarball]) -> GeneratedTarball {\n+        let mut input_tarballs = tarballs[0].path.as_os_str().to_os_string();\n         for tarball in &tarballs[1..] {\n             input_tarballs.push(\",\");\n-            input_tarballs.push(tarball);\n+            input_tarballs.push(&tarball.path);\n         }\n \n         self.run(|this, cmd| {\n             cmd.arg(\"combine\").arg(\"--input-tarballs\").arg(input_tarballs);\n             this.non_bare_args(cmd);\n-        });\n+        })\n     }\n \n-    pub(crate) fn bare(self) -> PathBuf {\n+    pub(crate) fn bare(self) -> GeneratedTarball {\n         // Bare tarballs should have the top level directory match the package\n         // name, not \"image\". We rename the image directory just before passing\n         // into rust-installer.\n@@ -276,7 +269,7 @@ impl<'a> Tarball<'a> {\n             .arg(crate::dist::distdir(self.builder));\n     }\n \n-    fn run(self, build_cli: impl FnOnce(&Tarball<'a>, &mut Command)) -> PathBuf {\n+    fn run(self, build_cli: impl FnOnce(&Tarball<'a>, &mut Command)) -> GeneratedTarball {\n         t!(std::fs::create_dir_all(&self.overlay_dir));\n         self.builder.create(&self.overlay_dir.join(\"version\"), &self.overlay.version(self.builder));\n         if let Some(sha) = self.builder.rust_sha() {\n@@ -299,9 +292,6 @@ impl<'a> Tarball<'a> {\n             cmd.arg(\"--compression-formats\").arg(formats.join(\",\"));\n         }\n         self.builder.run(&mut cmd);\n-        if self.delete_temp_dir {\n-            t!(std::fs::remove_dir_all(&self.temp_dir));\n-        }\n \n         // Use either the first compression format defined, or \"gz\" as the default.\n         let ext = self\n@@ -313,6 +303,31 @@ impl<'a> Tarball<'a> {\n             .map(|s| s.as_str())\n             .unwrap_or(\"gz\");\n \n-        crate::dist::distdir(self.builder).join(format!(\"{}.tar.{}\", package_name, ext))\n+        GeneratedTarball {\n+            path: crate::dist::distdir(self.builder).join(format!(\"{}.tar.{}\", package_name, ext)),\n+            decompressed_output: self.temp_dir.join(package_name),\n+            work: self.temp_dir,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct GeneratedTarball {\n+    path: PathBuf,\n+    decompressed_output: PathBuf,\n+    work: PathBuf,\n+}\n+\n+impl GeneratedTarball {\n+    pub(crate) fn tarball(&self) -> &Path {\n+        &self.path\n+    }\n+\n+    pub(crate) fn decompressed_output(&self) -> &Path {\n+        &self.decompressed_output\n+    }\n+\n+    pub(crate) fn work_dir(&self) -> &Path {\n+        &self.work\n     }\n }"}, {"sha": "33e252a63c9a59728286bdced37d9d1d0515a62a", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5bffc265b0da4fda4f80f2f81697beef0289ef6c/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bffc265b0da4fda4f80f2f81697beef0289ef6c/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=5bffc265b0da4fda4f80f2f81697beef0289ef6c", "patch": "@@ -1963,7 +1963,7 @@ impl Step for Distcheck {\n \n         let mut cmd = Command::new(\"tar\");\n         cmd.arg(\"-xf\")\n-            .arg(builder.ensure(dist::PlainSourceTarball))\n+            .arg(builder.ensure(dist::PlainSourceTarball).tarball())\n             .arg(\"--strip-components=1\")\n             .current_dir(&dir);\n         builder.run(&mut cmd);\n@@ -1986,7 +1986,10 @@ impl Step for Distcheck {\n         t!(fs::create_dir_all(&dir));\n \n         let mut cmd = Command::new(\"tar\");\n-        cmd.arg(\"-xf\").arg(builder.ensure(dist::Src)).arg(\"--strip-components=1\").current_dir(&dir);\n+        cmd.arg(\"-xf\")\n+            .arg(builder.ensure(dist::Src).tarball())\n+            .arg(\"--strip-components=1\")\n+            .current_dir(&dir);\n         builder.run(&mut cmd);\n \n         let toml = dir.join(\"rust-src/lib/rustlib/src/rust/library/std/Cargo.toml\");"}]}