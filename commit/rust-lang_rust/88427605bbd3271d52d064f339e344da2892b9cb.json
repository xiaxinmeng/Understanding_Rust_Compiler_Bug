{"sha": "88427605bbd3271d52d064f339e344da2892b9cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NDI3NjA1YmJkMzI3MWQ1MmQwNjRmMzM5ZTM0NGRhMjg5MmI5Y2I=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-03-11T23:13:37Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-04-06T13:26:10Z"}, "message": "Make `AdditiveIterator` and `MultiplicativeIterator` extensible\n\nPreviously it could not be implemented for types outside `libcore/iter.rs` due\nto coherence issues.", "tree": {"sha": "892a0ea7f6f161d18e380e19cee7aacb450d415f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/892a0ea7f6f161d18e380e19cee7aacb450d415f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88427605bbd3271d52d064f339e344da2892b9cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88427605bbd3271d52d064f339e344da2892b9cb", "html_url": "https://github.com/rust-lang/rust/commit/88427605bbd3271d52d064f339e344da2892b9cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88427605bbd3271d52d064f339e344da2892b9cb/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf51e55274d6f2eabaf04ff2fc7a6cd61180a0ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf51e55274d6f2eabaf04ff2fc7a6cd61180a0ac", "html_url": "https://github.com/rust-lang/rust/commit/cf51e55274d6f2eabaf04ff2fc7a6cd61180a0ac"}], "stats": {"total": 130, "additions": 93, "deletions": 37}, "files": [{"sha": "52bad579f47d1e7f9e5623e89f65da97006ae717", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 93, "deletions": 37, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/88427605bbd3271d52d064f339e344da2892b9cb/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88427605bbd3271d52d064f339e344da2892b9cb/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=88427605bbd3271d52d064f339e344da2892b9cb", "patch": "@@ -1225,7 +1225,10 @@ impl<I> RandomAccessIterator for Rev<I>\n /// A trait for iterators over elements which can be added together\n #[unstable(feature = \"core\",\n            reason = \"needs to be re-evaluated as part of numerics reform\")]\n-pub trait AdditiveIterator<A> {\n+pub trait AdditiveIterator {\n+    /// The result of summing over the iterator.\n+    type SumResult;\n+\n     /// Iterates over the entire iterator, summing up all the elements\n     ///\n     /// # Examples\n@@ -1238,37 +1241,65 @@ pub trait AdditiveIterator<A> {\n     /// let mut it = a.iter().cloned();\n     /// assert!(it.sum() == 15);\n     /// ```\n-    fn sum(self) -> A;\n+    fn sum(self) -> Self::SumResult;\n+}\n+\n+/// The sum operation of an iterator's item type. Implementing this allows\n+/// calling `.sum()` on the iterator.\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+pub trait AdditiveIteratorItem {\n+    /// The type of the intermediate sums.\n+    type SumResult;\n+    /// The start value of the sum, usually something like `0`.\n+    fn start() -> Self::SumResult;\n+    /// Adds another element of the iterator to the intermediate sum.\n+    fn combine(self, other: Self::SumResult) -> Self::SumResult;\n+}\n+\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+impl<I: Iterator> AdditiveIterator for I where\n+    <I as Iterator>::Item: AdditiveIteratorItem\n+{\n+    type SumResult = <<I as Iterator>::Item as AdditiveIteratorItem>::SumResult;\n+    fn sum(self) -> <I as AdditiveIterator>::SumResult {\n+        let mut sum = <<I as Iterator>::Item as AdditiveIteratorItem>::start();\n+        for x in self {\n+            sum = x.combine(sum);\n+        }\n+        sum\n+    }\n }\n \n macro_rules! impl_additive {\n-    ($A:ty, $init:expr) => {\n+    ($T:ty, $init:expr) => {\n         #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-        impl<T: Iterator<Item=$A>> AdditiveIterator<$A> for T {\n-            #[inline]\n-            fn sum(self) -> $A {\n-                self.fold($init, |acc, x| acc + x)\n-            }\n+        impl AdditiveIteratorItem for $T {\n+            type SumResult = $T;\n+            fn start() -> $T { $init }\n+            fn combine(self, other: $T) -> $T { self + other }\n         }\n     };\n }\n-impl_additive! { i8,   0 }\n-impl_additive! { i16,  0 }\n-impl_additive! { i32,  0 }\n-impl_additive! { i64,  0 }\n-impl_additive! { isize,  0 }\n-impl_additive! { u8,   0 }\n-impl_additive! { u16,  0 }\n-impl_additive! { u32,  0 }\n-impl_additive! { u64,  0 }\n+impl_additive! { i8,    0 }\n+impl_additive! { i16,   0 }\n+impl_additive! { i32,   0 }\n+impl_additive! { i64,   0 }\n+impl_additive! { isize, 0 }\n+impl_additive! { u8,    0 }\n+impl_additive! { u16,   0 }\n+impl_additive! { u32,   0 }\n+impl_additive! { u64,   0 }\n impl_additive! { usize, 0 }\n-impl_additive! { f32,  0.0 }\n-impl_additive! { f64,  0.0 }\n+impl_additive! { f32,   0.0 }\n+impl_additive! { f64,   0.0 }\n \n /// A trait for iterators over elements which can be multiplied together.\n #[unstable(feature = \"core\",\n            reason = \"needs to be re-evaluated as part of numerics reform\")]\n-pub trait MultiplicativeIterator<A> {\n+pub trait MultiplicativeIterator {\n+    /// The result of multiplying the elements of the iterator.\n+    type ProductResult;\n+\n     /// Iterates over the entire iterator, multiplying all the elements\n     ///\n     /// # Examples\n@@ -1284,29 +1315,54 @@ pub trait MultiplicativeIterator<A> {\n     /// assert!(factorial(1) == 1);\n     /// assert!(factorial(5) == 120);\n     /// ```\n-    fn product(self) -> A;\n+    fn product(self) -> Self::ProductResult;\n+}\n+\n+/// The product operation of an iterator's item type. Implementing this allows\n+/// calling `.product()` on the iterator.\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+pub trait MultiplicativeIteratorItem {\n+    /// The type of the intermediate products.\n+    type ProductResult;\n+    /// The start value of the product, usually something like `1`.\n+    fn start() -> Self::ProductResult;\n+    /// Multiplies another element of the iterator to the intermediate product.\n+    fn combine(self, other: Self::ProductResult) -> Self::ProductResult;\n }\n \n-macro_rules! impl_multiplicative {\n-    ($A:ty, $init:expr) => {\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+impl<I: Iterator> MultiplicativeIterator for I where\n+    <I as Iterator>::Item: MultiplicativeIteratorItem\n+{\n+    type ProductResult = <<I as Iterator>::Item as MultiplicativeIteratorItem>::ProductResult;\n+    fn product(self) -> <I as MultiplicativeIterator>::ProductResult {\n+        let mut product = <<I as Iterator>::Item as MultiplicativeIteratorItem>::start();\n+        for x in self {\n+            product = x.combine(product);\n+        }\n+        product\n+    }\n+}\n+\n+macro_rules! impl_multiplicative  {\n+    ($T:ty, $init:expr) => {\n         #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-        impl<T: Iterator<Item=$A>> MultiplicativeIterator<$A> for T {\n-            #[inline]\n-            fn product(self) -> $A {\n-                self.fold($init, |acc, x| acc * x)\n-            }\n+        impl MultiplicativeIteratorItem for $T {\n+            type ProductResult = $T;\n+            fn start() -> $T { $init }\n+            fn combine(self, other: $T) -> $T { self * other }\n         }\n     };\n }\n-impl_multiplicative! { i8,   1 }\n-impl_multiplicative! { i16,  1 }\n-impl_multiplicative! { i32,  1 }\n-impl_multiplicative! { i64,  1 }\n-impl_multiplicative! { isize,  1 }\n-impl_multiplicative! { u8,   1 }\n-impl_multiplicative! { u16,  1 }\n-impl_multiplicative! { u32,  1 }\n-impl_multiplicative! { u64,  1 }\n+impl_multiplicative! { i8,    1 }\n+impl_multiplicative! { i16,   1 }\n+impl_multiplicative! { i32,   1 }\n+impl_multiplicative! { i64,   1 }\n+impl_multiplicative! { isize, 1 }\n+impl_multiplicative! { u8,    1 }\n+impl_multiplicative! { u16,   1 }\n+impl_multiplicative! { u32,   1 }\n+impl_multiplicative! { u64,   1 }\n impl_multiplicative! { usize, 1 }\n impl_multiplicative! { f32,  1.0 }\n impl_multiplicative! { f64,  1.0 }"}]}