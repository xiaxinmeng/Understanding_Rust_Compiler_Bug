{"sha": "196174ddad8cac276db8d44c22c7739f614a0fbc", "node_id": "C_kwDOAAsO6NoAKDE5NjE3NGRkYWQ4Y2FjMjc2ZGI4ZDQ0YzIyYzc3MzlmNjE0YTBmYmM", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-18T02:21:42Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-07-08T00:06:36Z"}, "message": "Changes to `let_unit_value`\n* View through locals in `let_unit_value` when determining if inference is required\n* Don't remove typed let bindings for more functions", "tree": {"sha": "addd1f8c32d4721b86450f9e7f4b675a505cb737", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/addd1f8c32d4721b86450f9e7f4b675a505cb737"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/196174ddad8cac276db8d44c22c7739f614a0fbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/196174ddad8cac276db8d44c22c7739f614a0fbc", "html_url": "https://github.com/rust-lang/rust/commit/196174ddad8cac276db8d44c22c7739f614a0fbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/196174ddad8cac276db8d44c22c7739f614a0fbc/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54feac18d1ad9cc5af1f71dfb34baa32f99630ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/54feac18d1ad9cc5af1f71dfb34baa32f99630ae", "html_url": "https://github.com/rust-lang/rust/commit/54feac18d1ad9cc5af1f71dfb34baa32f99630ae"}], "stats": {"total": 339, "additions": 266, "deletions": 73}, "files": [{"sha": "c98f9e01a8da20cf8e99f5d080fa5b24f13fc2a4", "filename": "clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 90, "deletions": 37, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/196174ddad8cac276db8d44c22c7739f614a0fbc/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196174ddad8cac276db8d44c22c7739f614a0fbc/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=196174ddad8cac276db8d44c22c7739f614a0fbc", "patch": "@@ -1,29 +1,24 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::get_parent_node;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::visitors::for_each_value_source;\n+use clippy_utils::visitors::{for_each_local_assignment, for_each_value_source};\n use core::ops::ControlFlow;\n use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{Expr, ExprKind, Local, PatKind};\n+use rustc_hir::{Expr, ExprKind, HirId, HirIdSet, Local, Node, PatKind, QPath, TyKind};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty, TypeFoldable, TypeSuperFoldable, TypeVisitor};\n+use rustc_middle::ty;\n \n use super::LET_UNIT_VALUE;\n \n-pub(super) fn check(cx: &LateContext<'_>, local: &Local<'_>) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n     if let Some(init) = local.init\n         && !local.pat.span.from_expansion()\n         && !in_external_macro(cx.sess(), local.span)\n         && cx.typeck_results().pat_ty(local.pat).is_unit()\n     {\n-        let needs_inferred = for_each_value_source(init, &mut |e| if needs_inferred_result_ty(cx, e) {\n-            ControlFlow::Continue(())\n-        } else {\n-            ControlFlow::Break(())\n-        }).is_continue();\n-\n-        if needs_inferred {\n+        if local.ty.is_some() && expr_needs_inferred_result(cx, init) {\n             if !matches!(local.pat.kind, PatKind::Wild) {\n                 span_lint_and_then(\n                     cx,\n@@ -62,48 +57,106 @@ pub(super) fn check(cx: &LateContext<'_>, local: &Local<'_>) {\n     }\n }\n \n-fn needs_inferred_result_ty(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    let id = match e.kind {\n+/// Checks sub-expressions which create the value returned by the given expression for whether\n+/// return value inference is needed. This checks through locals to see if they also need inference\n+/// at this point.\n+///\n+/// e.g.\n+/// ```rust,ignore\n+/// let bar = foo();\n+/// let x: u32 = if true { baz() } else { bar };\n+/// ```\n+/// Here the sources of the value assigned to `x` would be `baz()`, and `foo()` via the\n+/// initialization of `bar`. If both `foo` and `baz` have a return type which require type\n+/// inference then this function would return `true`.\n+fn expr_needs_inferred_result<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n+    // The locals used for initialization which have yet to be checked.\n+    let mut locals_to_check = Vec::new();\n+    // All the locals which have been added to `locals_to_check`. Needed to prevent cycles.\n+    let mut seen_locals = HirIdSet::default();\n+    if !each_value_source_needs_inference(cx, e, &mut locals_to_check, &mut seen_locals) {\n+        return false;\n+    }\n+    while let Some(id) = locals_to_check.pop() {\n+        if let Some(Node::Local(l)) = get_parent_node(cx.tcx, id) {\n+            if !l.ty.map_or(true, |ty| matches!(ty.kind, TyKind::Infer)) {\n+                return false;\n+            }\n+            if let Some(e) = l.init {\n+                if !each_value_source_needs_inference(cx, e, &mut locals_to_check, &mut seen_locals) {\n+                    return false;\n+                }\n+            } else if for_each_local_assignment(cx, id, |e| {\n+                if each_value_source_needs_inference(cx, e, &mut locals_to_check, &mut seen_locals) {\n+                    ControlFlow::Continue(())\n+                } else {\n+                    ControlFlow::Break(())\n+                }\n+            })\n+            .is_break()\n+            {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    true\n+}\n+\n+fn each_value_source_needs_inference(\n+    cx: &LateContext<'_>,\n+    e: &Expr<'_>,\n+    locals_to_check: &mut Vec<HirId>,\n+    seen_locals: &mut HirIdSet,\n+) -> bool {\n+    for_each_value_source(e, &mut |e| {\n+        if needs_inferred_result_ty(cx, e, locals_to_check, seen_locals) {\n+            ControlFlow::Continue(())\n+        } else {\n+            ControlFlow::Break(())\n+        }\n+    })\n+    .is_continue()\n+}\n+\n+fn needs_inferred_result_ty(\n+    cx: &LateContext<'_>,\n+    e: &Expr<'_>,\n+    locals_to_check: &mut Vec<HirId>,\n+    seen_locals: &mut HirIdSet,\n+) -> bool {\n+    let (id, args) = match e.kind {\n         ExprKind::Call(\n             Expr {\n                 kind: ExprKind::Path(ref path),\n                 hir_id,\n                 ..\n             },\n-            _,\n+            args,\n         ) => match cx.qpath_res(path, *hir_id) {\n-            Res::Def(DefKind::AssocFn | DefKind::Fn, id) => id,\n+            Res::Def(DefKind::AssocFn | DefKind::Fn, id) => (id, args),\n             _ => return false,\n         },\n-        ExprKind::MethodCall(..) => match cx.typeck_results().type_dependent_def_id(e.hir_id) {\n-            Some(id) => id,\n+        ExprKind::MethodCall(_, args, _) => match cx.typeck_results().type_dependent_def_id(e.hir_id) {\n+            Some(id) => (id, args),\n             None => return false,\n         },\n+        ExprKind::Path(QPath::Resolved(None, path)) => {\n+            if let Res::Local(id) = path.res\n+                && seen_locals.insert(id)\n+            {\n+                locals_to_check.push(id);\n+            }\n+            return true;\n+        },\n         _ => return false,\n     };\n     let sig = cx.tcx.fn_sig(id).skip_binder();\n     if let ty::Param(output_ty) = *sig.output().kind() {\n-        sig.inputs().iter().all(|&ty| !ty_contains_param(ty, output_ty.index))\n+        sig.inputs().iter().zip(args).all(|(&ty, arg)| {\n+            !ty.is_param(output_ty.index) || each_value_source_needs_inference(cx, arg, locals_to_check, seen_locals)\n+        })\n     } else {\n         false\n     }\n }\n-\n-fn ty_contains_param(ty: Ty<'_>, index: u32) -> bool {\n-    struct Visitor(u32);\n-    impl<'tcx> TypeVisitor<'tcx> for Visitor {\n-        type BreakTy = ();\n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if let ty::Param(ty) = *ty.kind() {\n-                if ty.index == self.0 {\n-                    ControlFlow::BREAK\n-                } else {\n-                    ControlFlow::CONTINUE\n-                }\n-            } else {\n-                ty.super_visit_with(self)\n-            }\n-        }\n-    }\n-    ty.visit_with(&mut Visitor(index)).is_break()\n-}"}, {"sha": "6aa86a57c9bdf58b2ccb07cd804c5a1d292da1b6", "filename": "clippy_lints/src/unit_types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/196174ddad8cac276db8d44c22c7739f614a0fbc/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196174ddad8cac276db8d44c22c7739f614a0fbc/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs?ref=196174ddad8cac276db8d44c22c7739f614a0fbc", "patch": "@@ -98,8 +98,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UnitTypes => [LET_UNIT_VALUE, UNIT_CMP, UNIT_ARG]);\n \n-impl LateLintPass<'_> for UnitTypes {\n-    fn check_local(&mut self, cx: &LateContext<'_>, local: &Local<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UnitTypes {\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n         let_unit_value::check(cx, local);\n     }\n "}, {"sha": "e89a46b85381722bcb040ee3d21b7fc3c769e07d", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/196174ddad8cac276db8d44c22c7739f614a0fbc/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196174ddad8cac276db8d44c22c7739f614a0fbc/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=196174ddad8cac276db8d44c22c7739f614a0fbc", "patch": "@@ -617,3 +617,49 @@ pub fn any_temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, e: &'tcx\n     })\n     .is_break()\n }\n+\n+/// Runs the given function for each path expression referencing the given local which occur after\n+/// the given expression.\n+pub fn for_each_local_assignment<'tcx, B>(\n+    cx: &LateContext<'tcx>,\n+    local_id: HirId,\n+    f: impl FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    struct V<'cx, 'tcx, F, B> {\n+        cx: &'cx LateContext<'tcx>,\n+        local_id: HirId,\n+        res: ControlFlow<B>,\n+        f: F,\n+    }\n+    impl<'cx, 'tcx, F: FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>, B> Visitor<'tcx> for V<'cx, 'tcx, F, B> {\n+        type NestedFilter = nested_filter::OnlyBodies;\n+        fn nested_visit_map(&mut self) -> Self::Map {\n+            self.cx.tcx.hir()\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'tcx>) {\n+            if let ExprKind::Assign(lhs, rhs, _) = e.kind\n+                && self.res.is_continue()\n+                && path_to_local_id(lhs, self.local_id)\n+            {\n+                self.res = (self.f)(rhs);\n+                self.visit_expr(rhs);\n+            } else {\n+                walk_expr(self, e);\n+            }\n+        }\n+    }\n+\n+    if let Some(b) = get_enclosing_block(cx, local_id) {\n+        let mut v = V {\n+            cx,\n+            local_id,\n+            res: ControlFlow::Continue(()),\n+            f,\n+        };\n+        v.visit_block(b);\n+        v.res\n+    } else {\n+        ControlFlow::Continue(())\n+    }\n+}"}, {"sha": "3d2a9635d757b9a6b09fdf13b05d90187a625493", "filename": "tests/ui/let_unit.fixed", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/196174ddad8cac276db8d44c22c7739f614a0fbc/tests%2Fui%2Flet_unit.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/196174ddad8cac276db8d44c22c7739f614a0fbc/tests%2Fui%2Flet_unit.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_unit.fixed?ref=196174ddad8cac276db8d44c22c7739f614a0fbc", "patch": "@@ -2,8 +2,7 @@\n \n #![feature(lint_reasons)]\n #![warn(clippy::let_unit_value)]\n-#![allow(clippy::no_effect)]\n-#![allow(unused)]\n+#![allow(unused, clippy::no_effect, clippy::needless_late_init, path_statements)]\n \n macro_rules! let_and_return {\n     ($n:expr) => {{\n@@ -73,8 +72,8 @@ fn _returns_generic() {\n     fn f3<T>(x: T) -> T {\n         x\n     }\n-    fn f4<T>(mut x: Vec<T>) -> T {\n-        x.pop().unwrap()\n+    fn f5<T: Default>(x: bool) -> Option<T> {\n+        x.then(|| T::default())\n     }\n \n     let _: () = f(); // Ok\n@@ -86,8 +85,12 @@ fn _returns_generic() {\n     f3(()); // Lint\n     f3(()); // Lint\n \n-    f4(vec![()]); // Lint\n-    f4(vec![()]); // Lint\n+    // Should lint:\n+    // fn f4<T>(mut x: Vec<T>) -> T {\n+    //    x.pop().unwrap()\n+    // }\n+    // let _: () = f4(vec![()]);\n+    // let x: () = f4(vec![()]);\n \n     // Ok\n     let _: () = {\n@@ -113,6 +116,53 @@ fn _returns_generic() {\n         Some(1) => f2(3),\n         Some(_) => (),\n     };\n+\n+    let _: () = f5(true).unwrap();\n+\n+    #[allow(clippy::let_unit_value)]\n+    {\n+        let x = f();\n+        let y;\n+        let z;\n+        match 0 {\n+            0 => {\n+                y = f();\n+                z = f();\n+            },\n+            1 => {\n+                println!(\"test\");\n+                y = f();\n+                z = f3(());\n+            },\n+            _ => panic!(),\n+        }\n+\n+        let x1;\n+        let x2;\n+        if true {\n+            x1 = f();\n+            x2 = x1;\n+        } else {\n+            x2 = f();\n+            x1 = x2;\n+        }\n+\n+        let opt;\n+        match f5(true) {\n+            Some(x) => opt = x,\n+            None => panic!(),\n+        };\n+\n+        #[warn(clippy::let_unit_value)]\n+        {\n+            let _: () = x;\n+            let _: () = y;\n+            z;\n+            let _: () = x1;\n+            let _: () = x2;\n+            let _: () = opt;\n+        }\n+    }\n }\n \n fn attributes() {"}, {"sha": "625927f76f177a3bc75f20b29b2681972b197b83", "filename": "tests/ui/let_unit.rs", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/196174ddad8cac276db8d44c22c7739f614a0fbc/tests%2Fui%2Flet_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196174ddad8cac276db8d44c22c7739f614a0fbc/tests%2Fui%2Flet_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_unit.rs?ref=196174ddad8cac276db8d44c22c7739f614a0fbc", "patch": "@@ -2,8 +2,7 @@\n \n #![feature(lint_reasons)]\n #![warn(clippy::let_unit_value)]\n-#![allow(clippy::no_effect)]\n-#![allow(unused)]\n+#![allow(unused, clippy::no_effect, clippy::needless_late_init, path_statements)]\n \n macro_rules! let_and_return {\n     ($n:expr) => {{\n@@ -73,8 +72,8 @@ fn _returns_generic() {\n     fn f3<T>(x: T) -> T {\n         x\n     }\n-    fn f4<T>(mut x: Vec<T>) -> T {\n-        x.pop().unwrap()\n+    fn f5<T: Default>(x: bool) -> Option<T> {\n+        x.then(|| T::default())\n     }\n \n     let _: () = f(); // Ok\n@@ -86,8 +85,12 @@ fn _returns_generic() {\n     let _: () = f3(()); // Lint\n     let x: () = f3(()); // Lint\n \n-    let _: () = f4(vec![()]); // Lint\n-    let x: () = f4(vec![()]); // Lint\n+    // Should lint:\n+    // fn f4<T>(mut x: Vec<T>) -> T {\n+    //    x.pop().unwrap()\n+    // }\n+    // let _: () = f4(vec![()]);\n+    // let x: () = f4(vec![()]);\n \n     // Ok\n     let _: () = {\n@@ -113,6 +116,53 @@ fn _returns_generic() {\n         Some(1) => f2(3),\n         Some(_) => (),\n     };\n+\n+    let _: () = f5(true).unwrap();\n+\n+    #[allow(clippy::let_unit_value)]\n+    {\n+        let x = f();\n+        let y;\n+        let z;\n+        match 0 {\n+            0 => {\n+                y = f();\n+                z = f();\n+            },\n+            1 => {\n+                println!(\"test\");\n+                y = f();\n+                z = f3(());\n+            },\n+            _ => panic!(),\n+        }\n+\n+        let x1;\n+        let x2;\n+        if true {\n+            x1 = f();\n+            x2 = x1;\n+        } else {\n+            x2 = f();\n+            x1 = x2;\n+        }\n+\n+        let opt;\n+        match f5(true) {\n+            Some(x) => opt = x,\n+            None => panic!(),\n+        };\n+\n+        #[warn(clippy::let_unit_value)]\n+        {\n+            let _: () = x;\n+            let _: () = y;\n+            let _: () = z;\n+            let _: () = x1;\n+            let _: () = x2;\n+            let _: () = opt;\n+        }\n+    }\n }\n \n fn attributes() {"}, {"sha": "49da74ca7e1c7b4d86e2ee0efce674cddae2025b", "filename": "tests/ui/let_unit.stderr", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/196174ddad8cac276db8d44c22c7739f614a0fbc/tests%2Fui%2Flet_unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/196174ddad8cac276db8d44c22c7739f614a0fbc/tests%2Fui%2Flet_unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_unit.stderr?ref=196174ddad8cac276db8d44c22c7739f614a0fbc", "patch": "@@ -1,19 +1,19 @@\n error: this let-binding has unit value\n-  --> $DIR/let_unit.rs:15:5\n+  --> $DIR/let_unit.rs:14:5\n    |\n LL |     let _x = println!(\"x\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `println!(\"x\");`\n    |\n    = note: `-D clippy::let-unit-value` implied by `-D warnings`\n \n error: this let-binding has unit value\n-  --> $DIR/let_unit.rs:19:9\n+  --> $DIR/let_unit.rs:18:9\n    |\n LL |         let _a = ();\n    |         ^^^^^^^^^^^^ help: omit the `let` binding: `();`\n \n error: this let-binding has unit value\n-  --> $DIR/let_unit.rs:54:5\n+  --> $DIR/let_unit.rs:53:5\n    |\n LL | /     let _ = v\n LL | |         .into_iter()\n@@ -36,55 +36,43 @@ LL +         .unwrap();\n    |\n \n error: this let-binding has unit value\n-  --> $DIR/let_unit.rs:81:5\n+  --> $DIR/let_unit.rs:80:5\n    |\n LL |     let x: () = f(); // Lint.\n    |     ^^^^-^^^^^^^^^^^\n    |         |\n    |         help: use a wild (`_`) binding: `_`\n \n error: this let-binding has unit value\n-  --> $DIR/let_unit.rs:84:5\n+  --> $DIR/let_unit.rs:83:5\n    |\n LL |     let x: () = f2(0i32); // Lint.\n    |     ^^^^-^^^^^^^^^^^^^^^^\n    |         |\n    |         help: use a wild (`_`) binding: `_`\n \n error: this let-binding has unit value\n-  --> $DIR/let_unit.rs:86:5\n+  --> $DIR/let_unit.rs:85:5\n    |\n LL |     let _: () = f3(()); // Lint\n    |     ^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `f3(());`\n \n error: this let-binding has unit value\n-  --> $DIR/let_unit.rs:87:5\n+  --> $DIR/let_unit.rs:86:5\n    |\n LL |     let x: () = f3(()); // Lint\n    |     ^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `f3(());`\n \n error: this let-binding has unit value\n-  --> $DIR/let_unit.rs:89:5\n-   |\n-LL |     let _: () = f4(vec![()]); // Lint\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `f4(vec![()]);`\n-\n-error: this let-binding has unit value\n-  --> $DIR/let_unit.rs:90:5\n-   |\n-LL |     let x: () = f4(vec![()]); // Lint\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `f4(vec![()]);`\n-\n-error: this let-binding has unit value\n-  --> $DIR/let_unit.rs:99:5\n+  --> $DIR/let_unit.rs:102:5\n    |\n LL |     let x: () = if true { f() } else { f2(0) }; // Lint\n    |     ^^^^-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n    |         help: use a wild (`_`) binding: `_`\n \n error: this let-binding has unit value\n-  --> $DIR/let_unit.rs:110:5\n+  --> $DIR/let_unit.rs:113:5\n    |\n LL | /     let _: () = match Some(0) {\n LL | |         None => f2(1),\n@@ -104,5 +92,11 @@ LL +         Some(_) => (),\n LL +     };\n    |\n \n-error: aborting due to 11 previous errors\n+error: this let-binding has unit value\n+  --> $DIR/let_unit.rs:160:13\n+   |\n+LL |             let _: () = z;\n+   |             ^^^^^^^^^^^^^^ help: omit the `let` binding: `z;`\n+\n+error: aborting due to 10 previous errors\n "}]}