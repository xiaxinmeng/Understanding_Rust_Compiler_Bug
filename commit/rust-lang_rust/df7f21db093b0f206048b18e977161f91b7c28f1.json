{"sha": "df7f21db093b0f206048b18e977161f91b7c28f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmN2YyMWRiMDkzYjBmMjA2MDQ4YjE4ZTk3NzE2MWY5MWI3YzI4ZjE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-27T12:19:39Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-27T13:54:33Z"}, "message": "Reformat for new syntax", "tree": {"sha": "36c56d12572266bd0b8d2b3379e52d04bf0e9152", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36c56d12572266bd0b8d2b3379e52d04bf0e9152"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df7f21db093b0f206048b18e977161f91b7c28f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df7f21db093b0f206048b18e977161f91b7c28f1", "html_url": "https://github.com/rust-lang/rust/commit/df7f21db093b0f206048b18e977161f91b7c28f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df7f21db093b0f206048b18e977161f91b7c28f1/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e3ee39c41462652f41993a5610265abea6daa96", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e3ee39c41462652f41993a5610265abea6daa96", "html_url": "https://github.com/rust-lang/rust/commit/0e3ee39c41462652f41993a5610265abea6daa96"}], "stats": {"total": 60651, "additions": 28821, "deletions": 31830}, "files": [{"sha": "fc6385da4a015dd05ca4ded6bc1731c497b3e2d9", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -2,126 +2,126 @@\n \n \n // FIXME: Most of these should be uints.\n-const int rc_base_field_refcnt = 0;\n+const rc_base_field_refcnt: int = 0;\n \n \n // FIXME: import from std::dbg when imported consts work.\n-const uint const_refcount = 0x7bad_face_u;\n+const const_refcount: uint = 0x7bad_face_u;\n \n-const int task_field_refcnt = 0;\n+const task_field_refcnt: int = 0;\n \n-const int task_field_stk = 2;\n+const task_field_stk: int = 2;\n \n-const int task_field_runtime_sp = 3;\n+const task_field_runtime_sp: int = 3;\n \n-const int task_field_rust_sp = 4;\n+const task_field_rust_sp: int = 4;\n \n-const int task_field_gc_alloc_chain = 5;\n+const task_field_gc_alloc_chain: int = 5;\n \n-const int task_field_dom = 6;\n+const task_field_dom: int = 6;\n \n-const int n_visible_task_fields = 7;\n+const n_visible_task_fields: int = 7;\n \n-const int dom_field_interrupt_flag = 1;\n+const dom_field_interrupt_flag: int = 1;\n \n-const int frame_glue_fns_field_mark = 0;\n+const frame_glue_fns_field_mark: int = 0;\n \n-const int frame_glue_fns_field_drop = 1;\n+const frame_glue_fns_field_drop: int = 1;\n \n-const int frame_glue_fns_field_reloc = 2;\n+const frame_glue_fns_field_reloc: int = 2;\n \n-const int box_rc_field_refcnt = 0;\n+const box_rc_field_refcnt: int = 0;\n \n-const int box_rc_field_body = 1;\n+const box_rc_field_body: int = 1;\n \n-const int general_code_alignment = 16;\n+const general_code_alignment: int = 16;\n \n-const int vec_elt_rc = 0;\n+const vec_elt_rc: int = 0;\n \n-const int vec_elt_alloc = 1;\n+const vec_elt_alloc: int = 1;\n \n-const int vec_elt_fill = 2;\n+const vec_elt_fill: int = 2;\n \n-const int vec_elt_pad = 3;\n+const vec_elt_pad: int = 3;\n \n-const int vec_elt_data = 4;\n+const vec_elt_data: int = 4;\n \n-const int tydesc_field_first_param = 0;\n+const tydesc_field_first_param: int = 0;\n \n-const int tydesc_field_size = 1;\n+const tydesc_field_size: int = 1;\n \n-const int tydesc_field_align = 2;\n+const tydesc_field_align: int = 2;\n \n-const int tydesc_field_copy_glue = 3;\n+const tydesc_field_copy_glue: int = 3;\n \n-const int tydesc_field_drop_glue = 4;\n+const tydesc_field_drop_glue: int = 4;\n \n-const int tydesc_field_free_glue = 5;\n+const tydesc_field_free_glue: int = 5;\n \n-const int tydesc_field_sever_glue = 6;\n+const tydesc_field_sever_glue: int = 6;\n \n-const int tydesc_field_mark_glue = 7;\n+const tydesc_field_mark_glue: int = 7;\n \n \n // FIXME no longer used in rustc, drop when rustboot is gone\n-const int tydesc_field_obj_drop_glue = 8;\n+const tydesc_field_obj_drop_glue: int = 8;\n \n-const int tydesc_field_is_stateful = 9;\n+const tydesc_field_is_stateful: int = 9;\n \n-const int tydesc_field_cmp_glue = 10;\n+const tydesc_field_cmp_glue: int = 10;\n \n-const int n_tydesc_fields = 11;\n+const n_tydesc_fields: int = 11;\n \n-const uint cmp_glue_op_eq = 0u;\n+const cmp_glue_op_eq: uint = 0u;\n \n-const uint cmp_glue_op_lt = 1u;\n+const cmp_glue_op_lt: uint = 1u;\n \n-const uint cmp_glue_op_le = 2u;\n+const cmp_glue_op_le: uint = 2u;\n \n-const int obj_field_vtbl = 0;\n+const obj_field_vtbl: int = 0;\n \n-const int obj_field_box = 1;\n+const obj_field_box: int = 1;\n \n-const int obj_body_elt_tydesc = 0;\n+const obj_body_elt_tydesc: int = 0;\n \n-const int obj_body_elt_typarams = 1;\n+const obj_body_elt_typarams: int = 1;\n \n-const int obj_body_elt_fields = 2;\n+const obj_body_elt_fields: int = 2;\n \n // The base object to which an anonymous object is attached.\n-const int obj_body_elt_with_obj = 3;\n+const obj_body_elt_with_obj: int = 3;\n \n // The two halves of a closure: code and environment.\n-const int fn_field_code = 0;\n-const int fn_field_box = 1;\n+const fn_field_code: int = 0;\n+const fn_field_box: int = 1;\n \n-const int closure_elt_tydesc = 0;\n+const closure_elt_tydesc: int = 0;\n \n-const int closure_elt_target = 1;\n+const closure_elt_target: int = 1;\n \n-const int closure_elt_bindings = 2;\n+const closure_elt_bindings: int = 2;\n \n-const int closure_elt_ty_params = 3;\n+const closure_elt_ty_params: int = 3;\n \n-const uint ivec_default_length = 4u;\n+const ivec_default_length: uint = 4u;\n \n-const uint ivec_elt_len = 0u;\n+const ivec_elt_len: uint = 0u;\n \n-const uint ivec_elt_alen = 1u;\n+const ivec_elt_alen: uint = 1u;\n \n-const uint ivec_elt_elems = 2u;\n+const ivec_elt_elems: uint = 2u;\n \n-const uint ivec_heap_stub_elt_zero = 0u;\n+const ivec_heap_stub_elt_zero: uint = 0u;\n \n-const uint ivec_heap_stub_elt_alen = 1u;\n+const ivec_heap_stub_elt_alen: uint = 1u;\n \n-const uint ivec_heap_stub_elt_ptr = 2u;\n+const ivec_heap_stub_elt_ptr: uint = 2u;\n \n-const uint ivec_heap_elt_len = 0u;\n+const ivec_heap_elt_len: uint = 0u;\n \n-const uint ivec_heap_elt_elems = 1u;\n+const ivec_heap_elt_elems: uint = 1u;\n \n-const int worst_case_glue_call_args = 7;\n+const worst_case_glue_call_args: int = 7;\n \n fn memcpy_glue_name() -> str { ret \"rust_memcpy_glue\"; }\n "}, {"sha": "20cf266beca58d4b69bcf2ddb00e8e2f392b1b26", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 171, "deletions": 188, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -31,167 +31,156 @@ tag output_type {\n     output_type_exe;\n }\n \n-fn llvm_err(session::session sess, str msg) {\n-    auto buf = llvm::LLVMRustGetLastError();\n-    if (buf as uint == 0u) {\n+fn llvm_err(sess: session::session, msg: str) {\n+    let buf = llvm::LLVMRustGetLastError();\n+    if buf as uint == 0u {\n         sess.fatal(msg);\n     } else { sess.fatal(msg + \": \" + str::str_from_cstr(buf)); }\n     fail;\n }\n \n-fn link_intrinsics(session::session sess, ModuleRef llmod) {\n-    auto path = fs::connect(sess.get_opts().sysroot, \"lib/intrinsics.bc\");\n-    auto membuf =\n+fn link_intrinsics(sess: session::session, llmod: ModuleRef) {\n+    let path = fs::connect(sess.get_opts().sysroot, \"lib/intrinsics.bc\");\n+    let membuf =\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(str::buf(path));\n-    if (membuf as uint == 0u) {\n+    if membuf as uint == 0u {\n         llvm_err(sess, \"installation problem: couldn't open \" + path);\n         fail;\n     }\n-    auto llintrinsicsmod = llvm::LLVMRustParseBitcode(membuf);\n+    let llintrinsicsmod = llvm::LLVMRustParseBitcode(membuf);\n     llvm::LLVMDisposeMemoryBuffer(membuf);\n-    if (llintrinsicsmod as uint == 0u) {\n+    if llintrinsicsmod as uint == 0u {\n         llvm_err(sess, \"installation problem: couldn't parse intrinsics.bc\");\n         fail;\n     }\n-    auto linkres = llvm::LLVMLinkModules(llmod, llintrinsicsmod);\n+    let linkres = llvm::LLVMLinkModules(llmod, llintrinsicsmod);\n     llvm::LLVMDisposeModule(llintrinsicsmod);\n-    if (linkres == False) {\n+    if linkres == False {\n         llvm_err(sess, \"couldn't link the module with the intrinsics\");\n         fail;\n     }\n }\n \n mod write {\n-    fn is_object_or_assembly_or_exe(output_type ot) -> bool {\n-        if (ot == output_type_assembly || ot == output_type_object ||\n-                ot == output_type_exe) {\n+    fn is_object_or_assembly_or_exe(ot: output_type) -> bool {\n+        if ot == output_type_assembly || ot == output_type_object ||\n+               ot == output_type_exe {\n             ret true;\n         }\n         ret false;\n     }\n \n     // Decides what to call an intermediate file, given the name of the output\n     // and the extension to use.\n-    fn mk_intermediate_name(str output_path, str extension) -> str {\n-        auto dot_pos = str::index(output_path, '.' as u8);\n-        auto stem;\n-        if (dot_pos < 0) {\n+    fn mk_intermediate_name(output_path: str, extension: str) -> str {\n+        let dot_pos = str::index(output_path, '.' as u8);\n+        let stem;\n+        if dot_pos < 0 {\n             stem = output_path;\n         } else { stem = str::substr(output_path, 0u, dot_pos as uint); }\n         ret stem + \".\" + extension;\n     }\n-    fn run_passes(session::session sess, ModuleRef llmod, str output) {\n-        auto opts = sess.get_opts();\n-        if (opts.time_llvm_passes) { llvm::LLVMRustEnableTimePasses(); }\n+    fn run_passes(sess: session::session, llmod: ModuleRef, output: str) {\n+        let opts = sess.get_opts();\n+        if opts.time_llvm_passes { llvm::LLVMRustEnableTimePasses(); }\n         link_intrinsics(sess, llmod);\n-        auto pm = mk_pass_manager();\n-        auto td = mk_target_data(x86::get_data_layout());\n+        let pm = mk_pass_manager();\n+        let td = mk_target_data(x86::get_data_layout());\n         llvm::LLVMAddTargetData(td.lltd, pm.llpm);\n         // TODO: run the linter here also, once there are llvm-c bindings for\n         // it.\n \n         // Generate a pre-optimization intermediate file if -save-temps was\n         // specified.\n \n-        if (opts.save_temps) {\n-            alt (opts.output_type) {\n-                case (output_type_bitcode) {\n-                    if (opts.optimize != 0u) {\n-                        auto filename =\n-                            mk_intermediate_name(output, \"no-opt.bc\");\n-                        llvm::LLVMWriteBitcodeToFile(llmod,\n-                                                     str::buf(filename));\n-                    }\n-                }\n-                case (_) {\n-                    auto filename = mk_intermediate_name(output, \"bc\");\n+        if opts.save_temps {\n+            alt opts.output_type {\n+              output_type_bitcode. {\n+                if opts.optimize != 0u {\n+                    let filename = mk_intermediate_name(output, \"no-opt.bc\");\n                     llvm::LLVMWriteBitcodeToFile(llmod, str::buf(filename));\n                 }\n+              }\n+              _ {\n+                let filename = mk_intermediate_name(output, \"bc\");\n+                llvm::LLVMWriteBitcodeToFile(llmod, str::buf(filename));\n+              }\n             }\n         }\n-        if (opts.verify) { llvm::LLVMAddVerifierPass(pm.llpm); }\n+        if opts.verify { llvm::LLVMAddVerifierPass(pm.llpm); }\n         // FIXME: This is mostly a copy of the bits of opt's -O2 that are\n         // available in the C api.\n         // FIXME2: We might want to add optimization levels like -O1, -O2,\n         // -Os, etc\n         // FIXME3: Should we expose and use the pass lists used by the opt\n         // tool?\n \n-        if (opts.optimize != 0u) {\n-            auto fpm = mk_pass_manager();\n+        if opts.optimize != 0u {\n+            let fpm = mk_pass_manager();\n             llvm::LLVMAddTargetData(td.lltd, fpm.llpm);\n             llvm::LLVMAddStandardFunctionPasses(fpm.llpm, 2u);\n             llvm::LLVMRunPassManager(fpm.llpm, llmod);\n-            let uint threshold = 225u;\n-            if (opts.optimize == 3u) { threshold = 275u; }\n+            let threshold: uint = 225u;\n+            if opts.optimize == 3u { threshold = 275u; }\n             llvm::LLVMAddStandardModulePasses(pm.llpm,\n                                               // optimization level\n                                               opts.optimize,\n                                               False, // optimize for size\n-                                               True, // unit-at-a-time\n-                                               True, // unroll loops\n-                                               True, // simplify lib calls\n-                                               threshold); // inline threshold\n+                                              True, // unit-at-a-time\n+                                              True, // unroll loops\n+                                              True, // simplify lib calls\n+                                              threshold); // inline threshold\n \n         }\n-        if (opts.verify) { llvm::LLVMAddVerifierPass(pm.llpm); }\n-        if (is_object_or_assembly_or_exe(opts.output_type)) {\n-            let int LLVMAssemblyFile = 0;\n-            let int LLVMObjectFile = 1;\n-            let int LLVMOptNone = 0;        // -O0\n-            let int LLVMOptLess = 1;        // -O1\n-            let int LLVMOptDefault = 2;     // -O2, -Os\n-            let int LLVMOptAggressive = 3;  // -O3\n-\n-            auto CodeGenOptLevel;\n-            alt (opts.optimize) {\n-                case (0u) {\n-                     CodeGenOptLevel = LLVMOptNone;\n-                }\n-                case (1u) {\n-                     CodeGenOptLevel = LLVMOptLess;\n-                }\n-                case (2u) {\n-                     CodeGenOptLevel = LLVMOptDefault;\n-                }\n-                case (3u) {\n-                     CodeGenOptLevel = LLVMOptAggressive;\n-                }\n-                case (_) {\n-                     fail;\n-                }\n+        if opts.verify { llvm::LLVMAddVerifierPass(pm.llpm); }\n+        if is_object_or_assembly_or_exe(opts.output_type) {\n+            let LLVMAssemblyFile: int = 0;\n+            let LLVMObjectFile: int = 1;\n+            let LLVMOptNone: int = 0; // -O0\n+            let LLVMOptLess: int = 1; // -O1\n+            let LLVMOptDefault: int = 2; // -O2, -Os\n+            let LLVMOptAggressive: int = 3; // -O3\n+\n+            let CodeGenOptLevel;\n+            alt opts.optimize {\n+              0u { CodeGenOptLevel = LLVMOptNone; }\n+              1u { CodeGenOptLevel = LLVMOptLess; }\n+              2u { CodeGenOptLevel = LLVMOptDefault; }\n+              3u { CodeGenOptLevel = LLVMOptAggressive; }\n+              _ { fail; }\n             }\n \n-            auto FileType;\n-            if (opts.output_type == output_type_object ||\n-                    opts.output_type == output_type_exe) {\n+            let FileType;\n+            if opts.output_type == output_type_object ||\n+                   opts.output_type == output_type_exe {\n                 FileType = LLVMObjectFile;\n             } else { FileType = LLVMAssemblyFile; }\n             // Write optimized bitcode if --save-temps was on.\n \n-            if (opts.save_temps) {\n+            if opts.save_temps {\n                 // Always output the bitcode file with --save-temps\n \n-                auto filename = mk_intermediate_name(output, \"opt.bc\");\n+                let filename = mk_intermediate_name(output, \"opt.bc\");\n                 llvm::LLVMRunPassManager(pm.llpm, llmod);\n                 llvm::LLVMWriteBitcodeToFile(llmod, str::buf(filename));\n                 pm = mk_pass_manager();\n                 // Save the assembly file if -S is used\n \n-                if (opts.output_type == output_type_assembly) {\n-                    auto triple = x86::get_target_triple();\n+                if opts.output_type == output_type_assembly {\n+                    let triple = x86::get_target_triple();\n                     llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n                                                   str::buf(triple),\n                                                   str::buf(output),\n                                                   LLVMAssemblyFile,\n                                                   CodeGenOptLevel);\n                 }\n \n+\n                 // Save the object file for -c or --save-temps alone\n                 // This .o is needed when an exe is built\n-                if (opts.output_type == output_type_object ||\n-                        opts.output_type == output_type_exe) {\n-                    auto triple = x86::get_target_triple();\n+                if opts.output_type == output_type_object ||\n+                       opts.output_type == output_type_exe {\n+                    let triple = x86::get_target_triple();\n                     llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n                                                   str::buf(triple),\n                                                   str::buf(output),\n@@ -202,7 +191,7 @@ mod write {\n                 // If we aren't saving temps then just output the file\n                 // type corresponding to the '-c' or '-S' flag used\n \n-                auto triple = x86::get_target_triple();\n+                let triple = x86::get_target_triple();\n                 llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n                                               str::buf(triple),\n                                               str::buf(output), FileType,\n@@ -211,7 +200,7 @@ mod write {\n             // Clean up and return\n \n             llvm::LLVMDisposeModule(llmod);\n-            if (opts.time_llvm_passes) { llvm::LLVMRustPrintPassTimings(); }\n+            if opts.time_llvm_passes { llvm::LLVMRustPrintPassTimings(); }\n             ret;\n         }\n         // If only a bitcode file is asked for by using the '--emit-llvm'\n@@ -220,7 +209,7 @@ mod write {\n         llvm::LLVMRunPassManager(pm.llpm, llmod);\n         llvm::LLVMWriteBitcodeToFile(llmod, str::buf(output));\n         llvm::LLVMDisposeModule(llmod);\n-        if (opts.time_llvm_passes) { llvm::LLVMRustPrintPassTimings(); }\n+        if opts.time_llvm_passes { llvm::LLVMRustPrintPassTimings(); }\n     }\n }\n \n@@ -276,132 +265,128 @@ mod write {\n  *\n  */\n \n-type link_meta = rec(str name,\n-                     str vers,\n-                     str extras_hash);\n+type link_meta = {name: str, vers: str, extras_hash: str};\n \n-fn build_link_meta(&session::session sess, &ast::crate c,\n-                   &str output, sha1 sha) -> link_meta {\n+fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n+                   sha: sha1) -> link_meta {\n \n-    type provided_metas = rec(option::t[str] name,\n-                              option::t[str] vers,\n-                              (@ast::meta_item)[] cmh_items);\n+    type provided_metas =\n+        {name: option::t[str],\n+         vers: option::t[str],\n+         cmh_items: (@ast::meta_item)[]};\n \n-    fn provided_link_metas(&session::session sess,\n-                           &ast::crate c) -> provided_metas {\n-        let option::t[str] name = none;\n-        let option::t[str] vers = none;\n-        let (@ast::meta_item)[] cmh_items = ~[];\n-        auto linkage_metas = attr::find_linkage_metas(c.node.attrs);\n+    fn provided_link_metas(sess: &session::session, c: &ast::crate) ->\n+       provided_metas {\n+        let name: option::t[str] = none;\n+        let vers: option::t[str] = none;\n+        let cmh_items: (@ast::meta_item)[] = ~[];\n+        let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess, linkage_metas);\n-        for (@ast::meta_item meta in linkage_metas) {\n-            if (attr::get_meta_item_name(meta) == \"name\") {\n-                alt (attr::get_meta_item_value_str(meta)) {\n-                    case (some(?v)) { name = some(v); }\n-                    case (none) { cmh_items += ~[meta]; }\n+        for meta: @ast::meta_item  in linkage_metas {\n+            if attr::get_meta_item_name(meta) == \"name\" {\n+                alt attr::get_meta_item_value_str(meta) {\n+                  some(v) { name = some(v); }\n+                  none. { cmh_items += ~[meta]; }\n                 }\n             } else if (attr::get_meta_item_name(meta) == \"vers\") {\n-                alt (attr::get_meta_item_value_str(meta)) {\n-                    case (some(?v)) { vers = some(v); }\n-                    case (none) { cmh_items += ~[meta]; }\n+                alt attr::get_meta_item_value_str(meta) {\n+                  some(v) { vers = some(v); }\n+                  none. { cmh_items += ~[meta]; }\n                 }\n-            } else {\n-                cmh_items += ~[meta];\n-            }\n+            } else { cmh_items += ~[meta]; }\n         }\n-        ret rec(name = name,\n-                vers = vers,\n-                cmh_items = cmh_items);\n+        ret {name: name, vers: vers, cmh_items: cmh_items};\n     }\n \n     // This calculates CMH as defined above\n-    fn crate_meta_extras_hash(sha1 sha, &ast::crate crate,\n-                              &provided_metas metas) -> str {\n-        fn len_and_str(&str s) -> str {\n+    fn crate_meta_extras_hash(sha: sha1, crate: &ast::crate,\n+                              metas: &provided_metas) -> str {\n+        fn len_and_str(s: &str) -> str {\n             ret #fmt(\"%u_%s\", str::byte_len(s), s);\n         }\n \n-        fn len_and_str_lit(&ast::lit l) -> str {\n+        fn len_and_str_lit(l: &ast::lit) -> str {\n             ret len_and_str(pprust::lit_to_str(@l));\n         }\n \n-        auto cmh_items = attr::sort_meta_items(metas.cmh_items);\n+        let cmh_items = attr::sort_meta_items(metas.cmh_items);\n \n         sha.reset();\n-        for (@ast::meta_item m_ in cmh_items) {\n-            auto m = m_;\n-            alt (m.node) {\n-                case (ast::meta_name_value(?key, ?value)) {\n-                    sha.input_str(len_and_str(key));\n-                    sha.input_str(len_and_str_lit(value));\n-                }\n-                case (ast::meta_word(?name)) {\n-                    sha.input_str(len_and_str(name));\n-                }\n-                case (ast::meta_list(_, _)) {\n-                    // FIXME (#607): Implement this\n-                    fail \"unimplemented meta_item variant\";\n-                }\n+        for m_: @ast::meta_item  in cmh_items {\n+            let m = m_;\n+            alt m.node {\n+              ast::meta_name_value(key, value) {\n+                sha.input_str(len_and_str(key));\n+                sha.input_str(len_and_str_lit(value));\n+              }\n+              ast::meta_word(name) { sha.input_str(len_and_str(name)); }\n+              ast::meta_list(_, _) {\n+                // FIXME (#607): Implement this\n+                fail \"unimplemented meta_item variant\";\n+              }\n             }\n         }\n         ret truncated_sha1_result(sha);\n     }\n \n-    fn warn_missing(&session::session sess, str name, str default) {\n-        if (!sess.get_opts().library) { ret; }\n+    fn warn_missing(sess: &session::session, name: str, default: str) {\n+        if !sess.get_opts().library { ret; }\n         sess.warn(#fmt(\"missing crate link meta '%s', using '%s' as default\",\n                        name, default));\n     }\n \n-    fn crate_meta_name(&session::session sess, &ast::crate crate,\n-                       &str output, &provided_metas metas) -> str {\n-        ret alt (metas.name) {\n-            case (some(?v)) { v }\n-            case (none) {\n-                auto name = {\n-                    auto os_vec = str::split(fs::basename(output), '.' as u8);\n+    fn crate_meta_name(sess: &session::session, crate: &ast::crate,\n+                       output: &str, metas: &provided_metas) -> str {\n+        ret alt metas.name {\n+              some(v) { v }\n+              none. {\n+                let \n                     // FIXME: Remove this vec->ivec conversion.\n-                    auto os = ~[];\n-                    for (str s in os_vec) { os += ~[s]; }\n \n-                    assert (ivec::len(os) >= 2u);\n-                    ivec::pop(os);\n-                    str::connect_ivec(os, \".\")\n-                };\n+                    name =\n+                    {\n+                        let os_vec =\n+                            str::split(fs::basename(output), '.' as u8);\n+                        let os = ~[];\n+                        for s: str  in os_vec { os += ~[s]; }\n+                        assert (ivec::len(os) >= 2u);\n+                        ivec::pop(os);\n+                        str::connect_ivec(os, \".\")\n+                    };\n                 warn_missing(sess, \"name\", name);\n                 name\n-            }\n-        };\n+              }\n+            };\n     }\n \n-    fn crate_meta_vers(&session::session sess, &ast::crate crate,\n-                       &provided_metas metas) -> str {\n-        ret alt (metas.vers) {\n-            case (some(?v)) { v }\n-            case (none) {\n-                auto vers = \"0.0\";\n+    fn crate_meta_vers(sess: &session::session, crate: &ast::crate,\n+                       metas: &provided_metas) -> str {\n+        ret alt metas.vers {\n+              some(v) { v }\n+              none. {\n+                let vers = \"0.0\";\n                 warn_missing(sess, \"vers\", vers);\n                 vers\n-            }\n-        };\n+              }\n+            };\n     }\n \n-    auto provided_metas = provided_link_metas(sess, c);\n-    auto name = crate_meta_name(sess, c, output, provided_metas);\n-    auto vers = crate_meta_vers(sess, c, provided_metas);\n-    auto extras_hash = crate_meta_extras_hash(sha, c, provided_metas);\n+    let provided_metas = provided_link_metas(sess, c);\n+    let name = crate_meta_name(sess, c, output, provided_metas);\n+    let vers = crate_meta_vers(sess, c, provided_metas);\n+    let extras_hash = crate_meta_extras_hash(sha, c, provided_metas);\n \n-    ret rec(name = name, vers = vers, extras_hash = extras_hash);\n+    ret {name: name, vers: vers, extras_hash: extras_hash};\n }\n \n-fn truncated_sha1_result(sha1 sha) -> str {\n+fn truncated_sha1_result(sha: sha1) -> str {\n     ret str::substr(sha.result_str(), 0u, 16u);\n }\n \n \n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t,\n-               &link_meta link_meta) -> str {\n+fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: &ty::t, link_meta: &link_meta) ->\n+   str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -412,66 +397,64 @@ fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t,\n     sha.input_str(link_meta.name);\n     sha.input_str(\"-\");\n     sha.input_str(encoder::encoded_ty(tcx, t));\n-    auto hash = truncated_sha1_result(sha);\n+    let hash = truncated_sha1_result(sha);\n     // Prefix with _ so that it never blends into adjacent digits\n \n     ret \"_\" + hash;\n }\n \n-fn get_symbol_hash(&@crate_ctxt ccx, &ty::t t) -> str {\n-    auto hash = \"\";\n-    alt (ccx.type_sha1s.find(t)) {\n-        case (some(?h)) { hash = h; }\n-        case (none) {\n-            hash =\n-                symbol_hash(ccx.tcx, ccx.sha, t,\n-                            ccx.link_meta);\n-            ccx.type_sha1s.insert(t, hash);\n-        }\n+fn get_symbol_hash(ccx: &@crate_ctxt, t: &ty::t) -> str {\n+    let hash = \"\";\n+    alt ccx.type_sha1s.find(t) {\n+      some(h) { hash = h; }\n+      none. {\n+        hash = symbol_hash(ccx.tcx, ccx.sha, t, ccx.link_meta);\n+        ccx.type_sha1s.insert(t, hash);\n+      }\n     }\n     ret hash;\n }\n \n-fn mangle(&str[] ss) -> str {\n+fn mangle(ss: &str[]) -> str {\n     // Follow C++ namespace-mangling style\n \n-    auto n = \"_ZN\"; // Begin name-sequence.\n+    let n = \"_ZN\"; // Begin name-sequence.\n \n-    for (str s in ss) { n += #fmt(\"%u%s\", str::byte_len(s), s); }\n+    for s: str  in ss { n += #fmt(\"%u%s\", str::byte_len(s), s); }\n     n += \"E\"; // End name-sequence.\n \n     ret n;\n }\n \n-fn exported_name(&str[] path, &str hash, &str vers) -> str {\n+fn exported_name(path: &str[], hash: &str, vers: &str) -> str {\n     // FIXME: versioning isn't working yet\n \n     ret mangle(path + ~[hash]); //  + \"@\" + vers;\n \n }\n \n-fn mangle_exported_name(&@crate_ctxt ccx, &str[] path, &ty::t t) -> str {\n-    auto hash = get_symbol_hash(ccx, t);\n+fn mangle_exported_name(ccx: &@crate_ctxt, path: &str[], t: &ty::t) -> str {\n+    let hash = get_symbol_hash(ccx, t);\n     ret exported_name(path, hash, ccx.link_meta.vers);\n }\n \n-fn mangle_internal_name_by_type_only(&@crate_ctxt ccx, &ty::t t, &str name) ->\n-   str {\n-    auto s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n-    auto hash = get_symbol_hash(ccx, t);\n+fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: &ty::t, name: &str)\n+   -> str {\n+    let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n+    let hash = get_symbol_hash(ccx, t);\n     ret mangle(~[name, s, hash]);\n }\n \n-fn mangle_internal_name_by_path_and_seq(&@crate_ctxt ccx, &str[] path,\n-                                        &str flav) -> str {\n+fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &str[],\n+                                        flav: &str) -> str {\n     ret mangle(path + ~[ccx.names.next(flav)]);\n }\n \n-fn mangle_internal_name_by_path(&@crate_ctxt ccx, &str[] path) -> str {\n+fn mangle_internal_name_by_path(ccx: &@crate_ctxt, path: &str[]) -> str {\n     ret mangle(path);\n }\n \n-fn mangle_internal_name_by_seq(&@crate_ctxt ccx, &str flav) -> str {\n+fn mangle_internal_name_by_seq(ccx: &@crate_ctxt, flav: &str) -> str {\n     ret ccx.names.next(flav);\n }\n //"}, {"sha": "b12ceba8f0dd66e0425e8e07a87dd9ac2b74c367", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 112, "deletions": 109, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -24,121 +24,124 @@ import lib::llvm::llvm::ValueRef;\n import lib::llvm::llvm::TypeRef;\n \n type upcalls =\n-    rec(ValueRef grow_task,\n-        ValueRef log_int,\n-        ValueRef log_float,\n-        ValueRef log_double,\n-        ValueRef log_str,\n-        ValueRef log_istr,\n-        ValueRef trace_word,\n-        ValueRef trace_str,\n-        ValueRef new_port,\n-        ValueRef del_port,\n-        ValueRef new_chan,\n-        ValueRef flush_chan,\n-        ValueRef del_chan,\n-        ValueRef clone_chan,\n-        ValueRef chan_target_task,\n-        ValueRef _yield,\n-        ValueRef sleep,\n-        ValueRef send,\n-        ValueRef recv,\n-        ValueRef _fail,\n-        ValueRef kill,\n-        ValueRef exit,\n-        ValueRef malloc,\n-        ValueRef free,\n-        ValueRef shared_malloc,\n-        ValueRef shared_free,\n-        ValueRef mark,\n-        ValueRef new_str,\n-        ValueRef dup_str,\n-        ValueRef new_vec,\n-        ValueRef vec_append,\n-        ValueRef get_type_desc,\n-        ValueRef new_task,\n-        ValueRef start_task,\n-        ValueRef ivec_resize,\n-        ValueRef ivec_spill,\n-        ValueRef ivec_resize_shared,\n-        ValueRef ivec_spill_shared);\n+    {grow_task: ValueRef,\n+     log_int: ValueRef,\n+     log_float: ValueRef,\n+     log_double: ValueRef,\n+     log_str: ValueRef,\n+     log_istr: ValueRef,\n+     trace_word: ValueRef,\n+     trace_str: ValueRef,\n+     new_port: ValueRef,\n+     del_port: ValueRef,\n+     new_chan: ValueRef,\n+     flush_chan: ValueRef,\n+     del_chan: ValueRef,\n+     clone_chan: ValueRef,\n+     chan_target_task: ValueRef,\n+     _yield: ValueRef,\n+     sleep: ValueRef,\n+     send: ValueRef,\n+     recv: ValueRef,\n+     _fail: ValueRef,\n+     kill: ValueRef,\n+     exit: ValueRef,\n+     malloc: ValueRef,\n+     free: ValueRef,\n+     shared_malloc: ValueRef,\n+     shared_free: ValueRef,\n+     mark: ValueRef,\n+     new_str: ValueRef,\n+     dup_str: ValueRef,\n+     new_vec: ValueRef,\n+     vec_append: ValueRef,\n+     get_type_desc: ValueRef,\n+     new_task: ValueRef,\n+     start_task: ValueRef,\n+     ivec_resize: ValueRef,\n+     ivec_spill: ValueRef,\n+     ivec_resize_shared: ValueRef,\n+     ivec_spill_shared: ValueRef};\n \n-fn declare_upcalls(type_names tn, TypeRef tydesc_type, TypeRef taskptr_type,\n-                   ModuleRef llmod)\n-   -> @upcalls {\n-    fn decl(type_names tn, TypeRef tydesc_type, TypeRef taskptr_type,\n-            ModuleRef llmod, str name, TypeRef[] tys,\n-            TypeRef rv) -> ValueRef {\n-        let TypeRef[] arg_tys = ~[taskptr_type];\n-        for (TypeRef t in tys) { arg_tys += ~[t]; }\n-        auto fn_ty = T_fn(arg_tys, rv);\n+fn declare_upcalls(tn: type_names, tydesc_type: TypeRef,\n+                   taskptr_type: TypeRef, llmod: ModuleRef) -> @upcalls {\n+    fn decl(tn: type_names, tydesc_type: TypeRef, taskptr_type: TypeRef,\n+            llmod: ModuleRef, name: str, tys: TypeRef[], rv: TypeRef) ->\n+       ValueRef {\n+        let arg_tys: TypeRef[] = ~[taskptr_type];\n+        for t: TypeRef  in tys { arg_tys += ~[t]; }\n+        let fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n-    auto dv = bind decl(tn, tydesc_type, taskptr_type, llmod, _, _, T_void());\n-    auto d = bind decl(tn, tydesc_type, taskptr_type, llmod, _, _, _);\n+    let dv = bind decl(tn, tydesc_type, taskptr_type, llmod, _, _, T_void());\n+    let d = bind decl(tn, tydesc_type, taskptr_type, llmod, _, _, _);\n     // FIXME: Sigh:.. remove this when I fix the typechecker pushdown.\n     // --pcwalton\n \n-    let TypeRef[] empty_vec = ~[];\n-    ret @rec(grow_task=dv(\"grow_task\", ~[T_size_t()]),\n-             log_int=dv(\"log_int\", ~[T_i32(), T_i32()]),\n-             log_float=dv(\"log_float\", ~[T_i32(), T_f32()]),\n-             log_double=dv(\"log_double\", ~[T_i32(), T_ptr(T_f64())]),\n-             log_str=dv(\"log_str\", ~[T_i32(), T_ptr(T_str())]),\n-             log_istr=dv(\"log_istr\", ~[T_i32(), T_ptr(T_ivec(T_i8()))]),\n-             trace_word=dv(\"trace_word\", ~[T_int()]),\n-             trace_str=dv(\"trace_str\", ~[T_ptr(T_i8())]),\n-             new_port=d(\"new_port\", ~[T_size_t()], T_opaque_port_ptr()),\n-             del_port=dv(\"del_port\", ~[T_opaque_port_ptr()]),\n-             new_chan=d(\"new_chan\", ~[T_opaque_port_ptr()],\n-                        T_opaque_chan_ptr()),\n-             flush_chan=dv(\"flush_chan\", ~[T_opaque_chan_ptr()]),\n-             del_chan=dv(\"del_chan\", ~[T_opaque_chan_ptr()]),\n-             clone_chan=d(\"clone_chan\", ~[taskptr_type, T_opaque_chan_ptr()],\n-                          T_opaque_chan_ptr()),\n-             chan_target_task=d(\"chan_target_task\",\n-                                ~[T_opaque_chan_ptr()],\n-                                taskptr_type),\n-             _yield=dv(\"yield\", empty_vec),\n-             sleep=dv(\"sleep\", ~[T_size_t()]),\n-             send=dv(\"send\", ~[T_opaque_chan_ptr(), T_ptr(T_i8())]),\n-             recv=dv(\"recv\", ~[T_ptr(T_ptr(T_i8())), T_opaque_port_ptr()]),\n-             _fail=dv(\"fail\", ~[T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n-             kill=dv(\"kill\", ~[taskptr_type]),\n-             exit=dv(\"exit\", empty_vec),\n-             malloc=d(\"malloc\", ~[T_size_t(), T_ptr(tydesc_type)],\n-                      T_ptr(T_i8())),\n-             free=dv(\"free\", ~[T_ptr(T_i8()), T_int()]),\n-             shared_malloc=d(\"shared_malloc\",\n-                      ~[T_size_t(), T_ptr(tydesc_type)], T_ptr(T_i8())),\n-             shared_free=dv(\"shared_free\", ~[T_ptr(T_i8())]),\n-             mark=d(\"mark\", ~[T_ptr(T_i8())], T_int()),\n-             new_str=d(\"new_str\", ~[T_ptr(T_i8()), T_size_t()],\n-                       T_ptr(T_str())),\n-                     dup_str=d(\"dup_str\", ~[taskptr_type, T_ptr(T_str())],\n-                       T_ptr(T_str())),\n-             new_vec=d(\"new_vec\", ~[T_size_t(), T_ptr(tydesc_type)],\n-                       T_opaque_vec_ptr()),\n-             vec_append=d(\"vec_append\",\n-                          ~[T_ptr(tydesc_type), T_ptr(tydesc_type),\n-                            T_ptr(T_opaque_vec_ptr()), T_opaque_vec_ptr(),\n-                            T_bool()], T_void()),\n-             get_type_desc=d(\"get_type_desc\",\n-                             ~[T_ptr(T_nil()), T_size_t(), T_size_t(),\n-                               T_size_t(), T_ptr(T_ptr(tydesc_type))],\n-                             T_ptr(tydesc_type)),\n-             new_task=d(\"new_task\", ~[T_ptr(T_str())], taskptr_type),\n-             start_task=d(\"start_task\",\n-                          ~[taskptr_type, T_int(), T_int(), T_size_t()],\n-                            taskptr_type),\n-             ivec_resize=d(\"ivec_resize\", ~[T_ptr(T_opaque_ivec()), T_int()],\n-                           T_void()),\n-             ivec_spill=d(\"ivec_spill\", ~[T_ptr(T_opaque_ivec()), T_int()],\n-                          T_void()),\n-             ivec_resize_shared=d(\"ivec_resize_shared\",\n-                           ~[T_ptr(T_opaque_ivec()), T_int()], T_void()),\n-             ivec_spill_shared=d(\"ivec_spill_shared\",\n-                          ~[T_ptr(T_opaque_ivec()), T_int()], T_void()));\n+    let empty_vec: TypeRef[] = ~[];\n+    ret @{grow_task: dv(\"grow_task\", ~[T_size_t()]),\n+          log_int: dv(\"log_int\", ~[T_i32(), T_i32()]),\n+          log_float: dv(\"log_float\", ~[T_i32(), T_f32()]),\n+          log_double: dv(\"log_double\", ~[T_i32(), T_ptr(T_f64())]),\n+          log_str: dv(\"log_str\", ~[T_i32(), T_ptr(T_str())]),\n+          log_istr: dv(\"log_istr\", ~[T_i32(), T_ptr(T_ivec(T_i8()))]),\n+          trace_word: dv(\"trace_word\", ~[T_int()]),\n+          trace_str: dv(\"trace_str\", ~[T_ptr(T_i8())]),\n+          new_port: d(\"new_port\", ~[T_size_t()], T_opaque_port_ptr()),\n+          del_port: dv(\"del_port\", ~[T_opaque_port_ptr()]),\n+          new_chan:\n+              d(\"new_chan\", ~[T_opaque_port_ptr()], T_opaque_chan_ptr()),\n+          flush_chan: dv(\"flush_chan\", ~[T_opaque_chan_ptr()]),\n+          del_chan: dv(\"del_chan\", ~[T_opaque_chan_ptr()]),\n+          clone_chan:\n+              d(\"clone_chan\", ~[taskptr_type, T_opaque_chan_ptr()],\n+                T_opaque_chan_ptr()),\n+          chan_target_task:\n+              d(\"chan_target_task\", ~[T_opaque_chan_ptr()], taskptr_type),\n+          _yield: dv(\"yield\", empty_vec),\n+          sleep: dv(\"sleep\", ~[T_size_t()]),\n+          send: dv(\"send\", ~[T_opaque_chan_ptr(), T_ptr(T_i8())]),\n+          recv: dv(\"recv\", ~[T_ptr(T_ptr(T_i8())), T_opaque_port_ptr()]),\n+          _fail: dv(\"fail\", ~[T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n+          kill: dv(\"kill\", ~[taskptr_type]),\n+          exit: dv(\"exit\", empty_vec),\n+          malloc:\n+              d(\"malloc\", ~[T_size_t(), T_ptr(tydesc_type)], T_ptr(T_i8())),\n+          free: dv(\"free\", ~[T_ptr(T_i8()), T_int()]),\n+          shared_malloc:\n+              d(\"shared_malloc\", ~[T_size_t(), T_ptr(tydesc_type)],\n+                T_ptr(T_i8())),\n+          shared_free: dv(\"shared_free\", ~[T_ptr(T_i8())]),\n+          mark: d(\"mark\", ~[T_ptr(T_i8())], T_int()),\n+          new_str: d(\"new_str\", ~[T_ptr(T_i8()), T_size_t()], T_ptr(T_str())),\n+          dup_str:\n+              d(\"dup_str\", ~[taskptr_type, T_ptr(T_str())], T_ptr(T_str())),\n+          new_vec:\n+              d(\"new_vec\", ~[T_size_t(), T_ptr(tydesc_type)],\n+                T_opaque_vec_ptr()),\n+          vec_append:\n+              d(\"vec_append\",\n+                ~[T_ptr(tydesc_type), T_ptr(tydesc_type),\n+                  T_ptr(T_opaque_vec_ptr()), T_opaque_vec_ptr(), T_bool()],\n+                T_void()),\n+          get_type_desc:\n+              d(\"get_type_desc\",\n+                ~[T_ptr(T_nil()), T_size_t(), T_size_t(), T_size_t(),\n+                  T_ptr(T_ptr(tydesc_type))], T_ptr(tydesc_type)),\n+          new_task: d(\"new_task\", ~[T_ptr(T_str())], taskptr_type),\n+          start_task:\n+              d(\"start_task\", ~[taskptr_type, T_int(), T_int(), T_size_t()],\n+                taskptr_type),\n+          ivec_resize:\n+              d(\"ivec_resize\", ~[T_ptr(T_opaque_ivec()), T_int()], T_void()),\n+          ivec_spill:\n+              d(\"ivec_spill\", ~[T_ptr(T_opaque_ivec()), T_int()], T_void()),\n+          ivec_resize_shared:\n+              d(\"ivec_resize_shared\", ~[T_ptr(T_opaque_ivec()), T_int()],\n+                T_void()),\n+          ivec_spill_shared:\n+              d(\"ivec_spill_shared\", ~[T_ptr(T_opaque_ivec()), T_int()],\n+                T_void())};\n }\n //\n // Local Variables:"}, {"sha": "80f0245a3cdda0d3e9e6e04ddf50ee11c1dec9ed", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -7,26 +7,26 @@ import std::os::target_os;\n fn get_module_asm() -> str { ret \"\"; }\n \n fn get_meta_sect_name() -> str {\n-    if (str::eq(target_os(), \"macos\")) { ret \"__DATA,__note.rustc\"; }\n-    if (str::eq(target_os(), \"win32\")) { ret \".note.rustc\"; }\n+    if str::eq(target_os(), \"macos\") { ret \"__DATA,__note.rustc\"; }\n+    if str::eq(target_os(), \"win32\") { ret \".note.rustc\"; }\n     ret \".note.rustc\";\n }\n \n fn get_data_layout() -> str {\n-    if (str::eq(target_os(), \"macos\")) {\n+    if str::eq(target_os(), \"macos\") {\n         ret \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\" + \"-i32:32:32-i64:32:64\" +\n                 \"-f32:32:32-f64:32:64-v64:64:64\" +\n                 \"-v128:128:128-a0:0:64-f80:128:128\" + \"-n8:16:32\";\n     }\n-    if (str::eq(target_os(), \"win32\")) {\n+    if str::eq(target_os(), \"win32\") {\n         ret \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\";\n     }\n     ret \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\";\n }\n \n fn get_target_triple() -> str {\n-    if (str::eq(target_os(), \"macos\")) { ret \"i686-apple-darwin\"; }\n-    if (str::eq(target_os(), \"win32\")) { ret \"i686-pc-mingw32\"; }\n+    if str::eq(target_os(), \"macos\") { ret \"i686-apple-darwin\"; }\n+    if str::eq(target_os(), \"win32\") { ret \"i686-pc-mingw32\"; }\n     ret \"i686-unknown-linux-gnu\";\n }\n //"}, {"sha": "34c8f7f3163f629c44573b306dba630c663fdbce", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 333, "deletions": 348, "changes": 681, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -40,198 +40,191 @@ import back::link::output_type;\n \n tag pp_mode { ppm_normal; ppm_typed; ppm_identified; }\n \n-fn default_configuration(session::session sess, str argv0, str input) ->\n-    ast::crate_cfg {\n-    auto libc =\n-        alt (sess.get_targ_cfg().os) {\n-            case (session::os_win32) { \"msvcrt.dll\" }\n-            case (session::os_macos) { \"libc.dylib\" }\n-            case (session::os_linux) { \"libc.so.6\" }\n-            case (_) { \"libc.so\" }\n+fn default_configuration(sess: session::session, argv0: str, input: str) ->\n+   ast::crate_cfg {\n+    let libc =\n+        alt sess.get_targ_cfg().os {\n+          session::os_win32. { \"msvcrt.dll\" }\n+          session::os_macos. { \"libc.dylib\" }\n+          session::os_linux. { \"libc.so.6\" }\n+          _ { \"libc.so\" }\n         };\n \n-    auto mk = attr::mk_name_value_item_str;\n+    let mk = attr::mk_name_value_item_str;\n \n     ret ~[ // Target bindings.\n-          mk(\"target_os\", std::os::target_os()),\n-          mk(\"target_arch\", \"x86\"),\n+          mk(\"target_os\", std::os::target_os()), mk(\"target_arch\", \"x86\"),\n           mk(\"target_libc\", libc),\n           // Build bindings.\n-          mk(\"build_compiler\", argv0),\n-          mk(\"build_input\", input)];\n+          mk(\"build_compiler\", argv0), mk(\"build_input\", input)];\n }\n \n-fn build_configuration(session::session sess, str argv0,\n-                       str input) -> ast::crate_cfg {\n+fn build_configuration(sess: session::session, argv0: str, input: str) ->\n+   ast::crate_cfg {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n-    auto default_cfg = default_configuration(sess, argv0, input);\n-    auto user_cfg = sess.get_opts().cfg;\n-    auto gen_cfg = {\n+    let default_cfg = default_configuration(sess, argv0, input);\n+    let user_cfg = sess.get_opts().cfg;\n+    let \n         // If the user wants a test runner, then add the test cfg\n-        if (sess.get_opts().test\n-            && !attr::contains_name(user_cfg, \"test\")) {\n-            ~[attr::mk_word_item(\"test\")]\n-        } else {\n-            ~[]\n-        }\n-    };\n+        gen_cfg =\n+        {\n+            if sess.get_opts().test && !attr::contains_name(user_cfg, \"test\")\n+               {\n+                ~[attr::mk_word_item(\"test\")]\n+            } else { ~[] }\n+        };\n     ret user_cfg + gen_cfg + default_cfg;\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(&vec[str] cfgspecs) -> ast::crate_cfg {\n+fn parse_cfgspecs(cfgspecs: &vec[str]) -> ast::crate_cfg {\n     // FIXME: It would be nice to use the parser to parse all varieties of\n     // meta_item here. At the moment we just support the meta_word variant.\n-    auto words = ~[];\n-    for (str s in cfgspecs) { words += ~[attr::mk_word_item(s)]; }\n+    let words = ~[];\n+    for s: str  in cfgspecs { words += ~[attr::mk_word_item(s)]; }\n     ret words;\n }\n \n-fn parse_input(session::session sess, &ast::crate_cfg cfg, str input)\n-    -> @ast::crate {\n-    ret if (str::ends_with(input, \".rc\")) {\n-            parser::parse_crate_from_crate_file\n-                (input, cfg, sess.get_parse_sess())\n+fn parse_input(sess: session::session, cfg: &ast::crate_cfg, input: str) ->\n+   @ast::crate {\n+    ret if str::ends_with(input, \".rc\") {\n+            parser::parse_crate_from_crate_file(input, cfg,\n+                                                sess.get_parse_sess())\n         } else if (str::ends_with(input, \".rs\")) {\n-            parser::parse_crate_from_source_file\n-                (input, cfg, sess.get_parse_sess())\n+            parser::parse_crate_from_source_file(input, cfg,\n+                                                 sess.get_parse_sess())\n         } else { sess.fatal(\"unknown input file type: \" + input); fail };\n }\n \n-fn time[T](bool do_it, str what, fn() -> T  thunk) -> T {\n-    if (!do_it) { ret thunk(); }\n-    auto start = std::time::get_time();\n-    auto rv = thunk();\n-    auto end = std::time::get_time();\n+fn time[T](do_it: bool, what: str, thunk: fn() -> T ) -> T {\n+    if !do_it { ret thunk(); }\n+    let start = std::time::get_time();\n+    let rv = thunk();\n+    let end = std::time::get_time();\n     // FIXME: Actually do timeval math.\n \n     log_err #fmt(\"time: %s took %u s\", what, end.sec - start.sec as uint);\n     ret rv;\n }\n \n-fn compile_input(session::session sess, ast::crate_cfg cfg, str input,\n-                 str output) {\n-    auto time_passes = sess.get_opts().time_passes;\n-    auto crate =\n+fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n+                 output: str) {\n+    let time_passes = sess.get_opts().time_passes;\n+    let crate =\n         time(time_passes, \"parsing\", bind parse_input(sess, cfg, input));\n-    if (sess.get_opts().output_type == link::output_type_none) { ret; }\n-    crate = time(time_passes, \"configuration\",\n-                 bind front::config::strip_unconfigured_items(crate));\n-    if (sess.get_opts().test) {\n-        crate = time(time_passes, \"building test harness\",\n-                     bind front::test::modify_for_testing(crate));\n+    if sess.get_opts().output_type == link::output_type_none { ret; }\n+    crate =\n+        time(time_passes, \"configuration\",\n+             bind front::config::strip_unconfigured_items(crate));\n+    if sess.get_opts().test {\n+        crate =\n+            time(time_passes, \"building test harness\",\n+                 bind front::test::modify_for_testing(crate));\n     }\n-    crate = time(time_passes, \"expansion\",\n-                 bind syntax::ext::expand::expand_crate(sess, crate));\n+    crate =\n+        time(time_passes, \"expansion\",\n+             bind syntax::ext::expand::expand_crate(sess, crate));\n \n-    auto ast_map = time(time_passes, \"ast indexing\",\n-                        bind middle::ast_map::map_crate(*crate));\n+    let ast_map =\n+        time(time_passes, \"ast indexing\",\n+             bind middle::ast_map::map_crate(*crate));\n     time(time_passes, \"external crate/lib resolution\",\n          bind creader::read_crates(sess, *crate));\n-    auto d =\n+    let d =\n         time(time_passes, \"resolution\",\n              bind resolve::resolve_crate(sess, ast_map, crate));\n-    auto freevars =\n+    let freevars =\n         time(time_passes, \"freevar finding\",\n              bind freevars::annotate_freevars(sess, d, crate));\n-    auto ty_cx = ty::mk_ctxt(sess, d, ast_map, freevars);\n+    let ty_cx = ty::mk_ctxt(sess, d, ast_map, freevars);\n     time[()](time_passes, \"typechecking\",\n              bind typeck::check_crate(ty_cx, crate));\n     time[()](time_passes, \"alt checking\",\n              bind middle::check_alt::check_crate(ty_cx, crate));\n-    if (sess.get_opts().run_typestate) {\n+    if sess.get_opts().run_typestate {\n         time(time_passes, \"typestate checking\",\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n     time(time_passes, \"alias checking\",\n          bind middle::alias::check_crate(ty_cx, crate));\n-    auto llmod =\n+    let llmod =\n         time[llvm::llvm::ModuleRef](time_passes, \"translation\",\n-                                    bind trans::trans_crate\n-                                    (sess, crate, ty_cx, output, ast_map));\n+                                    bind trans::trans_crate(sess, crate,\n+                                                            ty_cx, output,\n+                                                            ast_map));\n     time[()](time_passes, \"LLVM passes\",\n              bind link::write::run_passes(sess, llmod, output));\n }\n \n-fn pretty_print_input(session::session sess, ast::crate_cfg cfg,\n-                      str input, pp_mode ppm, bool expand) {\n-    fn ann_paren_for_expr(&pprust::ann_node node) {\n-        alt (node) {\n-            case (pprust::node_expr(?s, ?expr)) {\n-                pprust::popen(s);\n-            }\n-            case (_) {}\n-        }\n+fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n+                      ppm: pp_mode, expand: bool) {\n+    fn ann_paren_for_expr(node: &pprust::ann_node) {\n+        alt node { pprust::node_expr(s, expr) { pprust::popen(s); } _ { } }\n     }\n-    fn ann_typed_post(&ty::ctxt tcx, &pprust::ann_node node) {\n-        alt (node) {\n-            case (pprust::node_expr(?s, ?expr)) {\n-                pp::space(s.s);\n-                pp::word(s.s, \"as\");\n-                pp::space(s.s);\n-                pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n-                pprust::pclose(s);\n-            }\n-            case (_) {}\n+    fn ann_typed_post(tcx: &ty::ctxt, node: &pprust::ann_node) {\n+        alt node {\n+          pprust::node_expr(s, expr) {\n+            pp::space(s.s);\n+            pp::word(s.s, \"as\");\n+            pp::space(s.s);\n+            pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n+            pprust::pclose(s);\n+          }\n+          _ { }\n         }\n     }\n-    fn ann_identified_post(&pprust::ann_node node) {\n-        alt (node) {\n-            case (pprust::node_item(?s, ?item)) {\n-                pp::space(s.s);\n-                pprust::synth_comment(s, int::to_str(item.id, 10u));\n-            }\n-            case (pprust::node_block(?s, ?blk)) {\n-                pp::space(s.s);\n-                pprust::synth_comment(s, \"block \" +\n-                                      int::to_str(blk.node.id, 10u));\n-            }\n-            case (pprust::node_expr(?s, ?expr)) {\n-                pp::space(s.s);\n-                pprust::synth_comment(s, int::to_str(expr.id, 10u));\n-                pprust::pclose(s);\n-            }\n-            case (_) {}\n+    fn ann_identified_post(node: &pprust::ann_node) {\n+        alt node {\n+          pprust::node_item(s, item) {\n+            pp::space(s.s);\n+            pprust::synth_comment(s, int::to_str(item.id, 10u));\n+          }\n+          pprust::node_block(s, blk) {\n+            pp::space(s.s);\n+            pprust::synth_comment(s,\n+                                  \"block \" + int::to_str(blk.node.id, 10u));\n+          }\n+          pprust::node_expr(s, expr) {\n+            pp::space(s.s);\n+            pprust::synth_comment(s, int::to_str(expr.id, 10u));\n+            pprust::pclose(s);\n+          }\n+          _ { }\n         }\n     }\n \n-    auto crate = parse_input(sess, cfg, input);\n-    if(expand) { crate = syntax::ext::expand::expand_crate(sess, crate); }\n-    auto ann;\n-    alt (ppm) {\n-        case (ppm_typed) {\n-            auto amap = middle::ast_map::map_crate(*crate);\n-            auto d = resolve::resolve_crate(sess, amap, crate);\n-            auto freevars = freevars::annotate_freevars(sess, d, crate);\n-            auto ty_cx = ty::mk_ctxt(sess, d, amap, freevars);\n-            typeck::check_crate(ty_cx, crate);\n-            ann = rec(pre=ann_paren_for_expr,\n-                      post=bind ann_typed_post(ty_cx, _));\n-        }\n-        case (ppm_identified) {\n-            ann = rec(pre=ann_paren_for_expr,\n-                      post=ann_identified_post);\n-        }\n-        case (ppm_normal) {\n-            ann = pprust::no_ann();\n-        }\n+    let crate = parse_input(sess, cfg, input);\n+    if expand { crate = syntax::ext::expand::expand_crate(sess, crate); }\n+    let ann;\n+    alt ppm {\n+      ppm_typed. {\n+        let amap = middle::ast_map::map_crate(*crate);\n+        let d = resolve::resolve_crate(sess, amap, crate);\n+        let freevars = freevars::annotate_freevars(sess, d, crate);\n+        let ty_cx = ty::mk_ctxt(sess, d, amap, freevars);\n+        typeck::check_crate(ty_cx, crate);\n+        ann = {pre: ann_paren_for_expr, post: bind ann_typed_post(ty_cx, _)};\n+      }\n+      ppm_identified. {\n+        ann = {pre: ann_paren_for_expr, post: ann_identified_post};\n+      }\n+      ppm_normal. { ann = pprust::no_ann(); }\n     }\n     pprust::print_crate(sess.get_codemap(), crate, input,\n-                        ioivec::file_reader(input),\n-                        ioivec::stdout(), ann);\n+                        ioivec::file_reader(input), ioivec::stdout(), ann);\n }\n \n-fn version(str argv0) {\n-    auto vers = \"unknown version\";\n-    auto env_vers = #env(\"CFG_VERSION\");\n-    if (str::byte_len(env_vers) != 0u) { vers = env_vers; }\n+fn version(argv0: str) {\n+    let vers = \"unknown version\";\n+    let env_vers = #env(\"CFG_VERSION\");\n+    if str::byte_len(env_vers) != 0u { vers = env_vers; }\n     ioivec::stdout().write_str(#fmt(\"%s %s\\n\", argv0, vers));\n }\n \n-fn usage(str argv0) {\n+fn usage(argv0: str) {\n     ioivec::stdout().write_str(#fmt(\"usage: %s [options] <input>\\n\", argv0) +\n-                               \"\n+                                   \"\n options:\n \n     -h --help          display this message\n@@ -267,9 +260,9 @@ options:\n \");\n }\n \n-fn get_os(str triple) -> session::os {\n-    ret if (str::find(triple, \"win32\") >= 0 ||\n-                str::find(triple, \"mingw32\") >= 0) {\n+fn get_os(triple: str) -> session::os {\n+    ret if str::find(triple, \"win32\") >= 0 ||\n+               str::find(triple, \"mingw32\") >= 0 {\n             session::os_win32\n         } else if (str::find(triple, \"darwin\") >= 0) {\n             session::os_macos\n@@ -278,11 +271,11 @@ fn get_os(str triple) -> session::os {\n         } else { log_err \"Unknown operating system!\"; fail };\n }\n \n-fn get_arch(str triple) -> session::arch {\n-    ret if (str::find(triple, \"i386\") >= 0 || str::find(triple, \"i486\") >= 0\n-                || str::find(triple, \"i586\") >= 0 ||\n-                str::find(triple, \"i686\") >= 0 ||\n-                str::find(triple, \"i786\") >= 0) {\n+fn get_arch(triple: str) -> session::arch {\n+    ret if str::find(triple, \"i386\") >= 0 || str::find(triple, \"i486\") >= 0 ||\n+               str::find(triple, \"i586\") >= 0 ||\n+               str::find(triple, \"i686\") >= 0 ||\n+               str::find(triple, \"i786\") >= 0 {\n             session::arch_x86\n         } else if (str::find(triple, \"x86_64\") >= 0) {\n             session::arch_x64\n@@ -292,36 +285,36 @@ fn get_arch(str triple) -> session::arch {\n         } else { log_err \"Unknown architecture! \" + triple; fail };\n }\n \n-fn get_default_sysroot(str binary) -> str {\n-    auto dirname = fs::dirname(binary);\n-    if (str::eq(dirname, binary)) { ret \".\"; }\n+fn get_default_sysroot(binary: str) -> str {\n+    let dirname = fs::dirname(binary);\n+    if str::eq(dirname, binary) { ret \".\"; }\n     ret dirname;\n }\n \n fn build_target_config() -> @session::config {\n-    let str triple =\n+    let triple: str =\n         std::str::rustrt::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple());\n-    let @session::config target_cfg =\n-        @rec(os=get_os(triple),\n-             arch=get_arch(triple),\n-             int_type=ast::ty_i32,\n-             uint_type=ast::ty_u32,\n-             float_type=ast::ty_f64);\n+    let target_cfg: @session::config =\n+        @{os: get_os(triple),\n+          arch: get_arch(triple),\n+          int_type: ast::ty_i32,\n+          uint_type: ast::ty_u32,\n+          float_type: ast::ty_f64};\n     ret target_cfg;\n }\n \n-fn build_session_options(str binary, getopts::match match, str binary_dir) ->\n-   @session::options {\n-    auto library = opt_present(match, \"lib\");\n-    auto static = opt_present(match, \"static\");\n+fn build_session_options(binary: str, match: getopts::match, binary_dir: str)\n+   -> @session::options {\n+    let library = opt_present(match, \"lib\");\n+    let static = opt_present(match, \"static\");\n \n-    auto library_search_paths = ~[binary_dir + \"/lib\"];\n+    let library_search_paths = ~[binary_dir + \"/lib\"];\n     // FIXME: Remove this vec->ivec conversion.\n-    auto lsp_vec = getopts::opt_strs(match, \"L\");\n-    for (str lsp in lsp_vec) { library_search_paths += ~[lsp]; }\n+    let lsp_vec = getopts::opt_strs(match, \"L\");\n+    for lsp: str  in lsp_vec { library_search_paths += ~[lsp]; }\n \n-    auto output_type =\n-        if (opt_present(match, \"parse-only\")) {\n+    let output_type =\n+        if opt_present(match, \"parse-only\") {\n             link::output_type_none\n         } else if (opt_present(match, \"S\")) {\n             link::output_type_assembly\n@@ -330,78 +323,78 @@ fn build_session_options(str binary, getopts::match match, str binary_dir) ->\n         } else if (opt_present(match, \"emit-llvm\")) {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n-    auto verify = !opt_present(match, \"noverify\");\n-    auto save_temps = opt_present(match, \"save-temps\");\n-    auto debuginfo = opt_present(match, \"g\");\n-    auto stats = opt_present(match, \"stats\");\n-    auto time_passes = opt_present(match, \"time-passes\");\n-    auto time_llvm_passes = opt_present(match, \"time-llvm-passes\");\n-    auto run_typestate = !opt_present(match, \"no-typestate\");\n-    auto sysroot_opt = getopts::opt_maybe_str(match, \"sysroot\");\n-    let uint opt_level =\n-        if (opt_present(match, \"O\")) {\n-            if (opt_present(match, \"OptLevel\")) {\n+    let verify = !opt_present(match, \"noverify\");\n+    let save_temps = opt_present(match, \"save-temps\");\n+    let debuginfo = opt_present(match, \"g\");\n+    let stats = opt_present(match, \"stats\");\n+    let time_passes = opt_present(match, \"time-passes\");\n+    let time_llvm_passes = opt_present(match, \"time-llvm-passes\");\n+    let run_typestate = !opt_present(match, \"no-typestate\");\n+    let sysroot_opt = getopts::opt_maybe_str(match, \"sysroot\");\n+    let opt_level: uint =\n+        if opt_present(match, \"O\") {\n+            if opt_present(match, \"OptLevel\") {\n                 log_err \"error: -O and --OptLevel both provided\";\n                 fail;\n             }\n             2u\n         } else if (opt_present(match, \"OptLevel\")) {\n-            alt (getopts::opt_str(match, \"OptLevel\")) {\n-                case (\"0\") { 0u }\n-                case (\"1\") { 1u }\n-                case (\"2\") { 2u }\n-                case (\"3\") { 3u }\n-                case (_) {\n-                    log_err \"error: optimization level needs \" +\n-                                \"to be between 0-3\";\n-                    fail\n-                }\n+            alt getopts::opt_str(match, \"OptLevel\") {\n+              \"0\" { 0u }\n+              \"1\" { 1u }\n+              \"2\" { 2u }\n+              \"3\" { 3u }\n+              _ {\n+                log_err \"error: optimization level needs \" +\n+                            \"to be between 0-3\";\n+                fail\n+              }\n             }\n         } else { 0u };\n-    auto sysroot =\n-        alt (sysroot_opt) {\n-            case (none) { get_default_sysroot(binary) }\n-            case (some(?s)) { s }\n+    let sysroot =\n+        alt sysroot_opt {\n+          none. { get_default_sysroot(binary) }\n+          some(s) { s }\n         };\n-    auto cfg = parse_cfgspecs(getopts::opt_strs(match, \"cfg\"));\n-    auto test = opt_present(match, \"test\");\n-    auto dps = opt_present(match, \"dps\");\n-    let @session::options sopts =\n-        @rec(library=library,\n-             static=static,\n-             optimize=opt_level,\n-             debuginfo=debuginfo,\n-             verify=verify,\n-             run_typestate=run_typestate,\n-             save_temps=save_temps,\n-             stats=stats,\n-             time_passes=time_passes,\n-             time_llvm_passes=time_llvm_passes,\n-             output_type=output_type,\n-             library_search_paths=library_search_paths,\n-             sysroot=sysroot,\n-             cfg=cfg,\n-             test=test,\n-             dps=dps);\n+    let cfg = parse_cfgspecs(getopts::opt_strs(match, \"cfg\"));\n+    let test = opt_present(match, \"test\");\n+    let dps = opt_present(match, \"dps\");\n+    let sopts: @session::options =\n+        @{library: library,\n+          static: static,\n+          optimize: opt_level,\n+          debuginfo: debuginfo,\n+          verify: verify,\n+          run_typestate: run_typestate,\n+          save_temps: save_temps,\n+          stats: stats,\n+          time_passes: time_passes,\n+          time_llvm_passes: time_llvm_passes,\n+          output_type: output_type,\n+          library_search_paths: library_search_paths,\n+          sysroot: sysroot,\n+          cfg: cfg,\n+          test: test,\n+          dps: dps};\n     ret sopts;\n }\n \n-fn build_session(@session::options sopts) -> session::session {\n-    auto target_cfg = build_target_config();\n-    auto cstore = cstore::mk_cstore();\n+fn build_session(sopts: @session::options) -> session::session {\n+    let target_cfg = build_target_config();\n+    let cstore = cstore::mk_cstore();\n     ret session::session(target_cfg, sopts, cstore,\n-                         @rec(cm=codemap::new_codemap(), mutable next_id=0),\n+                         @{cm: codemap::new_codemap(), mutable next_id: 0},\n                          none, 0u);\n }\n \n-fn parse_pretty(session::session sess, &str name) -> pp_mode {\n-    if (str::eq(name, \"normal\")) {\n+fn parse_pretty(sess: session::session, name: &str) -> pp_mode {\n+    if str::eq(name, \"normal\") {\n         ret ppm_normal;\n     } else if (str::eq(name, \"typed\")) {\n         ret ppm_typed;\n     } else if (str::eq(name, \"identified\")) { ret ppm_identified; }\n-    sess.fatal(\"argument to `pretty` or `expand` must be one of `normal`, \"\n-               + \"`typed`, or `identified`\");\n+    sess.fatal(\"argument to `pretty` or `expand` must be one of `normal`, \" +\n+                   \"`typed`, or `identified`\");\n }\n \n fn opts() -> vec[getopts::opt] {\n@@ -416,205 +409,196 @@ fn opts() -> vec[getopts::opt] {\n          optflag(\"lib\"), optflag(\"static\"), optflag(\"dps\")];\n }\n \n-fn main(vec[str] args) {\n-    auto binary = vec::shift(args);\n-    auto binary_dir = fs::dirname(binary);\n-    auto match =\n-        alt (getopts::getopts(args, opts())) {\n-            case (getopts::success(?m)) { m }\n-            case (getopts::failure(?f)) {\n-                log_err #fmt(\"error: %s\", getopts::fail_str(f));\n-                fail\n-            }\n+fn main(args: vec[str]) {\n+    let binary = vec::shift(args);\n+    let binary_dir = fs::dirname(binary);\n+    let match =\n+        alt getopts::getopts(args, opts()) {\n+          getopts::success(m) { m }\n+          getopts::failure(f) {\n+            log_err #fmt(\"error: %s\", getopts::fail_str(f));\n+            fail\n+          }\n         };\n-    if (opt_present(match, \"h\") || opt_present(match, \"help\")) {\n+    if opt_present(match, \"h\") || opt_present(match, \"help\") {\n         usage(binary);\n         ret;\n     }\n-    if (opt_present(match, \"v\") || opt_present(match, \"version\")) {\n+    if opt_present(match, \"v\") || opt_present(match, \"version\") {\n         version(binary);\n         ret;\n     }\n-    auto sopts = build_session_options(binary, match, binary_dir);\n-    auto sess = build_session(sopts);\n-    auto n_inputs = vec::len[str](match.free);\n-    auto output_file = getopts::opt_maybe_str(match, \"o\");\n-    auto glue = opt_present(match, \"glue\");\n-    if (glue) {\n-        if (n_inputs > 0u) {\n+    let sopts = build_session_options(binary, match, binary_dir);\n+    let sess = build_session(sopts);\n+    let n_inputs = vec::len[str](match.free);\n+    let output_file = getopts::opt_maybe_str(match, \"o\");\n+    let glue = opt_present(match, \"glue\");\n+    if glue {\n+        if n_inputs > 0u {\n             sess.fatal(\"No input files allowed with --glue.\");\n         }\n-        auto out = option::from_maybe[str](\"glue.bc\", output_file);\n+        let out = option::from_maybe[str](\"glue.bc\", output_file);\n         middle::trans::make_common_glue(sess, out);\n         ret;\n     }\n-    if (n_inputs == 0u) {\n+    if n_inputs == 0u {\n         sess.fatal(\"No input filename given.\");\n     } else if (n_inputs > 1u) {\n         sess.fatal(\"Multiple input filenames provided.\");\n     }\n-    auto ifile = match.free.(0);\n-    let str saved_out_filename = \"\";\n-    auto cfg = build_configuration(sess, binary, ifile);\n-    auto expand =\n+    let ifile = match.free.(0);\n+    let saved_out_filename: str = \"\";\n+    let cfg = build_configuration(sess, binary, ifile);\n+    let expand =\n         option::map[str,\n                     pp_mode](bind parse_pretty(sess, _),\n                              getopts::opt_default(match, \"expand\", \"normal\"));\n-    alt (expand) {\n-        case (some[pp_mode](?ppm)) {\n-            pretty_print_input(sess, cfg, ifile, ppm, true);\n-            ret;\n-        }\n-        case (none[pp_mode]) {/* continue */ }\n+    alt expand {\n+      some[pp_mode](ppm) {\n+        pretty_print_input(sess, cfg, ifile, ppm, true);\n+        ret;\n+      }\n+      none[pp_mode]. {/* continue */ }\n     }\n-    auto pretty =\n+    let pretty =\n         option::map[str,\n                     pp_mode](bind parse_pretty(sess, _),\n                              getopts::opt_default(match, \"pretty\", \"normal\"));\n-    alt (pretty) {\n-        case (some[pp_mode](?ppm)) {\n-            pretty_print_input(sess, cfg, ifile, ppm, false);\n-            ret;\n-        }\n-        case (none[pp_mode]) {/* continue */ }\n+    alt pretty {\n+      some[pp_mode](ppm) {\n+        pretty_print_input(sess, cfg, ifile, ppm, false);\n+        ret;\n+      }\n+      none[pp_mode]. {/* continue */ }\n     }\n-    auto ls = opt_present(match, \"ls\");\n-    if (ls) {\n+    let ls = opt_present(match, \"ls\");\n+    if ls {\n         metadata::creader::list_file_metadata(ifile, ioivec::stdout());\n         ret;\n     }\n \n-    auto stop_after_codegen = sopts.output_type != link::output_type_exe ||\n-        (sopts.static && sopts.library);\n-\n-    alt (output_file) {\n-        case (none) {\n-            let vec[str] parts = str::split(ifile, '.' as u8);\n-            vec::pop[str](parts);\n-            saved_out_filename = parts.(0);\n-            alt (sopts.output_type) {\n-                case (link::output_type_none) { parts += [\"pp\"]; }\n-                case (link::output_type_bitcode) { parts += [\"bc\"]; }\n-                case (link::output_type_assembly) { parts += [\"s\"]; }\n-                case (\n-                     // Object and exe output both use the '.o' extension here\n-                     link::output_type_object) {\n-                    parts += [\"o\"];\n-                }\n-                case (link::output_type_exe) { parts += [\"o\"]; }\n-            }\n-            auto ofile = str::connect(parts, \".\");\n-            compile_input(sess, cfg, ifile, ofile);\n-        }\n-        case (some(?ofile)) {\n-            // FIXME: what about windows? This will create a foo.exe.o.\n-\n-            saved_out_filename = ofile;\n-            auto temp_filename;\n-            if (!stop_after_codegen) {\n-                temp_filename = ofile + \".o\";\n-            } else {\n-                temp_filename = ofile;\n-            }\n-            compile_input(sess, cfg, ifile, temp_filename);\n+    let stop_after_codegen =\n+        sopts.output_type != link::output_type_exe ||\n+            sopts.static && sopts.library;\n+\n+    alt output_file {\n+      none. {\n+        let parts: vec[str] = str::split(ifile, '.' as u8);\n+        vec::pop[str](parts);\n+        saved_out_filename = parts.(0);\n+        alt sopts.output_type {\n+          link::output_type_none. { parts += [\"pp\"]; }\n+          link::output_type_bitcode. { parts += [\"bc\"]; }\n+          link::output_type_assembly. { parts += [\"s\"]; }\n+\n+          // Object and exe output both use the '.o' extension here\n+          link::output_type_object. {\n+            parts += [\"o\"];\n+          }\n+          link::output_type_exe. { parts += [\"o\"]; }\n         }\n+        let ofile = str::connect(parts, \".\");\n+        compile_input(sess, cfg, ifile, ofile);\n+      }\n+      some(ofile) {\n+        // FIXME: what about windows? This will create a foo.exe.o.\n+\n+        saved_out_filename = ofile;\n+        let temp_filename;\n+        if !stop_after_codegen {\n+            temp_filename = ofile + \".o\";\n+        } else { temp_filename = ofile; }\n+        compile_input(sess, cfg, ifile, temp_filename);\n+      }\n     }\n \n     // If the user wants an exe generated we need to invoke\n     // gcc to link the object file with some libs\n     //\n     // TODO: Factor this out of main.\n-    if (stop_after_codegen) {\n-        ret;\n-    }\n+    if stop_after_codegen { ret; }\n \n-    let str glu = binary_dir + \"/lib/glue.o\";\n-    let str main = binary_dir + \"/lib/main.o\";\n-    let str stage = \"-L\" + binary_dir + \"/lib\";\n-    let str prog = \"gcc\";\n+    let glu: str = binary_dir + \"/lib/glue.o\";\n+    let main: str = binary_dir + \"/lib/main.o\";\n+    let stage: str = \"-L\" + binary_dir + \"/lib\";\n+    let prog: str = \"gcc\";\n     // The invocations of gcc share some flags across platforms\n \n-    let vec[str] gcc_args =\n-        [stage, \"-Lrt\", \"-lrustrt\", glu,  \"-m32\", \"-o\",\n-         saved_out_filename, saved_out_filename + \".o\"];\n-    auto lib_cmd;\n+    let gcc_args: vec[str] =\n+        [stage, \"-Lrt\", \"-lrustrt\", glu, \"-m32\", \"-o\", saved_out_filename,\n+         saved_out_filename + \".o\"];\n+    let lib_cmd;\n \n-    auto os = sess.get_targ_cfg().os;\n-    if (os == session::os_macos) {\n-            lib_cmd = \"-dynamiclib\";\n-    } else {\n-            lib_cmd = \"-shared\";\n-    }\n+    let os = sess.get_targ_cfg().os;\n+    if os == session::os_macos {\n+        lib_cmd = \"-dynamiclib\";\n+    } else { lib_cmd = \"-shared\"; }\n \n     // Converts a library file name into a gcc -l argument\n-    fn unlib(@session::config config, str filename) -> str {\n-        auto rmlib = bind fn(@session::config config,\n-                             str filename) -> str {\n-            if (config.os == session::os_macos\n-                || config.os == session::os_linux\n-                && str::find(filename, \"lib\") == 0) {\n-                ret str::slice(filename, 3u, str::byte_len(filename));\n-            } else {\n-                ret filename;\n-            }\n-        } (config, _);\n-        fn rmext(str filename) -> str {\n-            auto parts = str::split(filename, '.' as u8);\n+    fn unlib(config: @session::config, filename: str) -> str {\n+        let rmlib =\n+            bind fn (config: @session::config, filename: str) -> str {\n+                     if config.os == session::os_macos ||\n+                            config.os == session::os_linux &&\n+                                str::find(filename, \"lib\") == 0 {\n+                         ret str::slice(filename, 3u,\n+                                        str::byte_len(filename));\n+                     } else { ret filename; }\n+                 }(config, _);\n+        fn rmext(filename: str) -> str {\n+            let parts = str::split(filename, '.' as u8);\n             vec::pop(parts);\n             ret str::connect(parts, \".\");\n         }\n-        ret alt (config.os) {\n-            case (session::os_macos) { rmext(rmlib(filename)) }\n-            case (session::os_linux) { rmext(rmlib(filename)) }\n-            case (_) { rmext(filename) }\n-        };\n+        ret alt config.os {\n+              session::os_macos. { rmext(rmlib(filename)) }\n+              session::os_linux. { rmext(rmlib(filename)) }\n+              _ { rmext(filename) }\n+            };\n     }\n \n-    auto cstore = sess.get_cstore();\n-    for (str cratepath in cstore::get_used_crate_files(cstore)) {\n-        if (str::ends_with(cratepath, \".rlib\")) {\n+    let cstore = sess.get_cstore();\n+    for cratepath: str  in cstore::get_used_crate_files(cstore) {\n+        if str::ends_with(cratepath, \".rlib\") {\n             gcc_args += [cratepath];\n             cont;\n         }\n-        auto dir = fs::dirname(cratepath);\n-        if (dir != \"\") {\n-            gcc_args += [\"-L\" + dir];\n-        }\n-        auto libarg = unlib(sess.get_targ_cfg(), fs::basename(cratepath));\n+        let dir = fs::dirname(cratepath);\n+        if dir != \"\" { gcc_args += [\"-L\" + dir]; }\n+        let libarg = unlib(sess.get_targ_cfg(), fs::basename(cratepath));\n         gcc_args += [\"-l\" + libarg];\n     }\n \n     // FIXME: Remove this ivec->vec conversion.\n-    auto ula = cstore::get_used_link_args(cstore);\n-    for (str arg in ula) { gcc_args += [arg]; }\n+    let ula = cstore::get_used_link_args(cstore);\n+    for arg: str  in ula { gcc_args += [arg]; }\n \n-    auto used_libs = cstore::get_used_libraries(cstore);\n-    for (str l in used_libs) {\n-        gcc_args += [\"-l\" + l];\n-    }\n+    let used_libs = cstore::get_used_libraries(cstore);\n+    for l: str  in used_libs { gcc_args += [\"-l\" + l]; }\n \n-    if (sopts.library) {\n+    if sopts.library {\n         gcc_args += [lib_cmd];\n     } else {\n         // FIXME: why do we hardcode -lm?\n         gcc_args += [\"-lm\", main];\n     }\n     // We run 'gcc' here\n \n-    auto err_code = run::run_program(prog, gcc_args);\n-    if (0 != err_code) {\n+    let err_code = run::run_program(prog, gcc_args);\n+    if 0 != err_code {\n         sess.err(#fmt(\"linking with gcc failed with code %d\", err_code));\n         sess.note(#fmt(\"gcc arguments: %s\", str::connect(gcc_args, \" \")));\n         sess.abort_if_errors();\n     }\n     // Clean up on Darwin\n \n-    if (sess.get_targ_cfg().os == session::os_macos) {\n+    if sess.get_targ_cfg().os == session::os_macos {\n         run::run_program(\"dsymutil\", [saved_out_filename]);\n     }\n \n+\n     // Remove the temporary object file if we aren't saving temps\n-    if (!sopts.save_temps) {\n+    if !sopts.save_temps {\n         run::run_program(\"rm\", [saved_out_filename + \".o\"]);\n     }\n }\n@@ -627,28 +611,29 @@ mod test {\n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test() {\n-        auto match = alt (getopts::getopts([\"--test\"], opts())) {\n-            getopts::success(?m) { m }\n-        };\n-        auto sessopts = build_session_options(\"whatever\", match, \"whatever\");\n-        auto sess = build_session(sessopts);\n-        auto cfg = build_configuration(sess, \"whatever\", \"whatever\");\n-        assert attr::contains_name(cfg, \"test\");\n+        let match =\n+            alt getopts::getopts([\"--test\"], opts()) {\n+              getopts::success(m) { m }\n+            };\n+        let sessopts = build_session_options(\"whatever\", match, \"whatever\");\n+        let sess = build_session(sessopts);\n+        let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n+        assert (attr::contains_name(cfg, \"test\"));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n     // another --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n-        auto match = alt (getopts::getopts([\"--test\",\n-                                            \"--cfg=test\"], opts())) {\n-            getopts::success(?m) { m }\n-        };\n-        auto sessopts = build_session_options(\"whatever\", match, \"whatever\");\n-        auto sess = build_session(sessopts);\n-        auto cfg = build_configuration(sess, \"whatever\", \"whatever\");\n-        auto test_items = attr::find_meta_items_by_name(cfg, \"test\");\n-        assert ivec::len(test_items) == 1u;\n+        let match =\n+            alt getopts::getopts([\"--test\", \"--cfg=test\"], opts()) {\n+              getopts::success(m) { m }\n+            };\n+        let sessopts = build_session_options(\"whatever\", match, \"whatever\");\n+        let sess = build_session(sessopts);\n+        let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n+        let test_items = attr::find_meta_items_by_name(cfg, \"test\");\n+        assert (ivec::len(test_items) == 1u);\n     }\n }\n "}, {"sha": "003584e81f5cfb8289797d69bfd11724b9499f27", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 47, "deletions": 54, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -17,104 +17,97 @@ tag os { os_win32; os_macos; os_linux; }\n tag arch { arch_x86; arch_x64; arch_arm; }\n \n type config =\n-    rec(os os,\n-        arch arch,\n-        ty_mach int_type,\n-        ty_mach uint_type,\n-        ty_mach float_type);\n+    {os: os,\n+     arch: arch,\n+     int_type: ty_mach,\n+     uint_type: ty_mach,\n+     float_type: ty_mach};\n \n type options =\n-    rec(bool library,\n-        bool static,\n-        uint optimize,\n-        bool debuginfo,\n-        bool verify,\n-        bool run_typestate,\n-        bool save_temps,\n-        bool stats,\n-        bool time_passes,\n-        bool time_llvm_passes,\n-        back::link::output_type output_type,\n-        str[] library_search_paths,\n-        str sysroot,\n-        // The crate config requested for the session, which may be combined\n-        // with additional crate configurations during the compile process\n-        ast::crate_cfg cfg,\n-        bool test,\n-        bool dps);\n+    // The crate config requested for the session, which may be combined\n+    // with additional crate configurations during the compile process\n+    {library: bool,\n+     static: bool,\n+     optimize: uint,\n+     debuginfo: bool,\n+     verify: bool,\n+     run_typestate: bool,\n+     save_temps: bool,\n+     stats: bool,\n+     time_passes: bool,\n+     time_llvm_passes: bool,\n+     output_type: back::link::output_type,\n+     library_search_paths: str[],\n+     sysroot: str,\n+     cfg: ast::crate_cfg,\n+     test: bool,\n+     dps: bool};\n \n-type crate_metadata = rec(str name, u8[] data);\n+type crate_metadata = {name: str, data: u8[]};\n+\n+obj session(targ_cfg: @config,\n+            opts: @options,\n+            cstore: metadata::cstore::cstore,\n+            parse_sess: parse_sess,\n \n-obj session(@config targ_cfg,\n-            @options opts,\n-            metadata::cstore::cstore cstore,\n-            parse_sess parse_sess,\n             // For a library crate, this is always none\n-            mutable option::t[node_id] main_fn,\n-            mutable uint err_count) {\n+            mutable main_fn: option::t[node_id],\n+            mutable err_count: uint) {\n     fn get_targ_cfg() -> @config { ret targ_cfg; }\n     fn get_opts() -> @options { ret opts; }\n     fn get_cstore() -> metadata::cstore::cstore { cstore }\n-    fn span_fatal(span sp, str msg) -> ! {\n+    fn span_fatal(sp: span, msg: str) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n         codemap::emit_error(some(sp), msg, parse_sess.cm);\n         fail;\n     }\n-    fn fatal(str msg) -> ! {\n+    fn fatal(msg: str) -> ! {\n         codemap::emit_error(none, msg, parse_sess.cm);\n         fail;\n     }\n-    fn span_err(span sp, str msg) {\n+    fn span_err(sp: span, msg: str) {\n         codemap::emit_error(some(sp), msg, parse_sess.cm);\n         err_count += 1u;\n     }\n-    fn err(str msg) {\n+    fn err(msg: str) {\n         codemap::emit_error(none, msg, parse_sess.cm);\n         err_count += 1u;\n     }\n     fn abort_if_errors() {\n-        if (err_count > 0u) {\n-            self.fatal(\"aborting due to previous errors\");\n-        }\n+        if err_count > 0u { self.fatal(\"aborting due to previous errors\"); }\n     }\n-    fn span_warn(span sp, str msg) {\n+    fn span_warn(sp: span, msg: str) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n         codemap::emit_warning(some(sp), msg, parse_sess.cm);\n     }\n-    fn warn(str msg) {\n-        codemap::emit_warning(none, msg, parse_sess.cm);\n-    }\n-    fn span_note(span sp, str msg) {\n+    fn warn(msg: str) { codemap::emit_warning(none, msg, parse_sess.cm); }\n+    fn span_note(sp: span, msg: str) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n         codemap::emit_note(some(sp), msg, parse_sess.cm);\n     }\n-    fn note(str msg) {\n-        codemap::emit_note(none, msg, parse_sess.cm);\n-    }\n-    fn span_bug(span sp, str msg) -> ! {\n+    fn note(msg: str) { codemap::emit_note(none, msg, parse_sess.cm); }\n+    fn span_bug(sp: span, msg: str) -> ! {\n         self.span_fatal(sp, #fmt(\"internal compiler error %s\", msg));\n     }\n-    fn bug(str msg) -> ! {\n+    fn bug(msg: str) -> ! {\n         self.fatal(#fmt(\"internal compiler error %s\", msg));\n     }\n-    fn span_unimpl(span sp, str msg) -> ! {\n+    fn span_unimpl(sp: span, msg: str) -> ! {\n         self.span_bug(sp, \"unimplemented \" + msg);\n     }\n-    fn unimpl(str msg) -> ! { self.bug(\"unimplemented \" + msg); }\n+    fn unimpl(msg: str) -> ! { self.bug(\"unimplemented \" + msg); }\n     fn get_codemap() -> codemap::codemap { ret parse_sess.cm; }\n-    fn lookup_pos(uint pos) -> codemap::loc {\n+    fn lookup_pos(pos: uint) -> codemap::loc {\n         ret codemap::lookup_char_pos(parse_sess.cm, pos);\n     }\n     fn get_parse_sess() -> parse_sess { ret parse_sess; }\n     fn next_node_id() -> ast::node_id {\n         ret syntax::parse::parser::next_node_id(parse_sess);\n     }\n-    fn span_str(span sp) -> str {\n+    fn span_str(sp: span) -> str {\n         ret codemap::span_to_str(sp, self.get_codemap());\n     }\n-    fn set_main_id(node_id d) {\n-        main_fn = some(d);\n-    }\n+    fn set_main_id(d: node_id) { main_fn = some(d); }\n     fn get_main_id() -> option::t[node_id] { main_fn }\n }\n // Local Variables:"}, {"sha": "a8361ba64eedb0f2f520dd7311208e4131f01019", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 96, "deletions": 120, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -29,214 +29,190 @@ export mk_attr;\n \n // From a list of crate attributes get only the meta_items that impact crate\n // linkage\n-fn find_linkage_metas(&ast::attribute[] attrs) -> (@ast::meta_item)[] {\n-    let (@ast::meta_item)[] metas = ~[];\n-    for (ast::attribute attr in find_attrs_by_name(attrs, \"link\")) {\n-        alt (attr.node.value.node) {\n-            case (ast::meta_list(_, ?items)) { metas += items; }\n-            case (_) {\n-                log \"ignoring link attribute that has incorrect type\";\n-            }\n+fn find_linkage_metas(attrs: &ast::attribute[]) -> (@ast::meta_item)[] {\n+    let metas: (@ast::meta_item)[] = ~[];\n+    for attr: ast::attribute  in find_attrs_by_name(attrs, \"link\") {\n+        alt attr.node.value.node {\n+          ast::meta_list(_, items) { metas += items; }\n+          _ { log \"ignoring link attribute that has incorrect type\"; }\n         }\n     }\n     ret metas;\n }\n \n // Search a list of attributes and return only those with a specific name\n-fn find_attrs_by_name(&ast::attribute[] attrs,\n-                      ast::ident name) -> ast::attribute[] {\n-    auto filter = bind fn(&ast::attribute a,\n-                          ast::ident name) -> option::t[ast::attribute] {\n-        if (get_attr_name(a) == name) {\n-            option::some(a)\n-        } else {\n-            option::none\n-        }\n-    } (_, name);\n+fn find_attrs_by_name(attrs: &ast::attribute[], name: ast::ident) ->\n+   ast::attribute[] {\n+    let filter =\n+        bind fn (a: &ast::attribute, name: ast::ident) ->\n+                option::t[ast::attribute] {\n+                 if get_attr_name(a) == name {\n+                     option::some(a)\n+                 } else { option::none }\n+             }(_, name);\n     ret ivec::filter_map(filter, attrs);\n }\n \n-fn get_attr_name(&ast::attribute attr) -> ast::ident {\n+fn get_attr_name(attr: &ast::attribute) -> ast::ident {\n     get_meta_item_name(@attr.node.value)\n }\n \n-fn find_meta_items_by_name(&(@ast::meta_item)[] metas,\n-                           ast::ident name) -> (@ast::meta_item)[] {\n-    auto filter = bind fn(&@ast::meta_item m,\n-                          ast::ident name) -> option::t[@ast::meta_item] {\n-        if (get_meta_item_name(m) == name) {\n-            option::some(m)\n-        } else {\n-            option::none\n-        }\n-    } (_, name);\n+fn find_meta_items_by_name(metas: &(@ast::meta_item)[], name: ast::ident) ->\n+   (@ast::meta_item)[] {\n+    let filter =\n+        bind fn (m: &@ast::meta_item, name: ast::ident) ->\n+                option::t[@ast::meta_item] {\n+                 if get_meta_item_name(m) == name {\n+                     option::some(m)\n+                 } else { option::none }\n+             }(_, name);\n     ret ivec::filter_map(filter, metas);\n }\n \n-fn get_meta_item_name(&@ast::meta_item meta) -> ast::ident {\n-    alt (meta.node) {\n-        case (ast::meta_word(?n)) { n }\n-        case (ast::meta_name_value(?n, _)) { n }\n-        case (ast::meta_list(?n, _)) { n }\n+fn get_meta_item_name(meta: &@ast::meta_item) -> ast::ident {\n+    alt meta.node {\n+      ast::meta_word(n) { n }\n+      ast::meta_name_value(n, _) { n }\n+      ast::meta_list(n, _) { n }\n     }\n }\n \n // Gets the string value if the meta_item is a meta_name_value variant\n // containing a string, otherwise none\n-fn get_meta_item_value_str(&@ast::meta_item meta) -> option::t[str] {\n-    alt (meta.node) {\n-        case (ast::meta_name_value(_, ?v)) {\n-            alt (v.node) {\n-                case (ast::lit_str(?s, _)) {\n-                    option::some(s)\n-                }\n-                case (_) { option::none }\n-            }\n+fn get_meta_item_value_str(meta: &@ast::meta_item) -> option::t[str] {\n+    alt meta.node {\n+      ast::meta_name_value(_, v) {\n+        alt v.node {\n+          ast::lit_str(s, _) { option::some(s) }\n+          _ { option::none }\n         }\n-        case (_) { option::none }\n+      }\n+      _ { option::none }\n     }\n }\n \n-fn attr_meta(&ast::attribute attr) -> @ast::meta_item { @attr.node.value }\n+fn attr_meta(attr: &ast::attribute) -> @ast::meta_item { @attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n-fn attr_metas(&ast::attribute[] attrs) -> (@ast::meta_item)[] {\n-    auto mitems = ~[];\n-    for (ast::attribute a in attrs) { mitems += ~[attr_meta(a)]; }\n+fn attr_metas(attrs: &ast::attribute[]) -> (@ast::meta_item)[] {\n+    let mitems = ~[];\n+    for a: ast::attribute  in attrs { mitems += ~[attr_meta(a)]; }\n     ret mitems;\n }\n \n-fn eq(@ast::meta_item a, @ast::meta_item b) -> bool {\n-    ret alt (a.node) {\n-        case (ast::meta_word(?na)) {\n-            alt (b.node) {\n-                case(ast::meta_word(?nb)) { na == nb }\n-                case(_) { false }\n+fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n+    ret alt a.node {\n+          ast::meta_word(na) {\n+            alt b.node { ast::meta_word(nb) { na == nb } _ { false } }\n+          }\n+          ast::meta_name_value(na, va) {\n+            alt b.node {\n+              ast::meta_name_value(nb, vb) { na == nb && va.node == vb.node }\n+              _ { false }\n             }\n-        }\n-        case (ast::meta_name_value(?na, ?va)) {\n-            alt (b.node) {\n-                case (ast::meta_name_value(?nb, ?vb)) {\n-                    na == nb && va.node == vb.node\n-                }\n-                case (_) { false }\n-            }\n-        }\n-        case (ast::meta_list(?na, ?la)) {\n+          }\n+          ast::meta_list(na, la) {\n+\n             // FIXME (#607): Needs implementing\n             // This involves probably sorting the list by name and\n             // meta_item variant\n             fail \"unimplemented meta_item variant\"\n+          }\n         }\n-    }\n }\n \n-fn contains(&(@ast::meta_item)[] haystack, @ast::meta_item needle) -> bool {\n+fn contains(haystack: &(@ast::meta_item)[], needle: @ast::meta_item) -> bool {\n     log #fmt(\"looking for %s\",\n              syntax::print::pprust::meta_item_to_str(*needle));\n-    for (@ast::meta_item item in haystack) {\n+    for item: @ast::meta_item  in haystack {\n         log #fmt(\"looking in %s\",\n                  syntax::print::pprust::meta_item_to_str(*item));\n-        if (eq(item, needle)) {\n-            log \"found it!\";\n-            ret true;\n-        }\n+        if eq(item, needle) { log \"found it!\"; ret true; }\n     }\n     log \"found it not :(\";\n     ret false;\n }\n \n-fn contains_name(&(@ast::meta_item)[] metas, ast::ident name) -> bool {\n-    auto matches = find_meta_items_by_name(metas, name);\n+fn contains_name(metas: &(@ast::meta_item)[], name: ast::ident) -> bool {\n+    let matches = find_meta_items_by_name(metas, name);\n     ret ivec::len(matches) > 0u;\n }\n \n // FIXME: This needs to sort by meta_item variant in addition to the item name\n-fn sort_meta_items(&(@ast::meta_item)[] items) -> (@ast::meta_item)[] {\n-    fn lteq(&@ast::meta_item ma, &@ast::meta_item mb) -> bool {\n-        fn key(&@ast::meta_item m) -> ast::ident {\n-            alt (m.node) {\n-                case (ast::meta_word(?name)) {\n-                    name\n-                }\n-                case (ast::meta_name_value(?name, _)) {\n-                    name\n-                }\n-                case (ast::meta_list(?name, _)) {\n-                    name\n-                }\n+fn sort_meta_items(items: &(@ast::meta_item)[]) -> (@ast::meta_item)[] {\n+    fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n+        fn key(m: &@ast::meta_item) -> ast::ident {\n+            alt m.node {\n+              ast::meta_word(name) { name }\n+              ast::meta_name_value(name, _) { name }\n+              ast::meta_list(name, _) { name }\n             }\n         }\n         ret key(ma) <= key(mb);\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let (@ast::meta_item)[mutable] v = ~[mutable];\n-    for (@ast::meta_item mi in items) {\n-        v += ~[mutable mi];\n-    }\n+    let v: (@ast::meta_item)[mutable ] = ~[mutable ];\n+    for mi: @ast::meta_item  in items { v += ~[mutable mi]; }\n \n     std::sort::ivector::quick_sort(lteq, v);\n \n-    let (@ast::meta_item)[] v2 = ~[];\n-    for (@ast::meta_item mi in v) {\n-        v2 += ~[mi];\n-    }\n+    let v2: (@ast::meta_item)[] = ~[];\n+    for mi: @ast::meta_item  in v { v2 += ~[mi]; }\n     ret v2;\n }\n \n-fn remove_meta_items_by_name(&(@ast::meta_item)[] items,\n-                             str name) -> (@ast::meta_item)[] {\n+fn remove_meta_items_by_name(items: &(@ast::meta_item)[], name: str) ->\n+   (@ast::meta_item)[] {\n \n-    auto filter = bind fn(&@ast::meta_item item,\n-                          str name) -> option::t[@ast::meta_item] {\n-        if (get_meta_item_name(item) != name) {\n-            option::some(item)\n-        } else {\n-            option::none\n-        }\n-    } (_, name);\n+    let filter =\n+        bind fn (item: &@ast::meta_item, name: str) ->\n+                option::t[@ast::meta_item] {\n+                 if get_meta_item_name(item) != name {\n+                     option::some(item)\n+                 } else { option::none }\n+             }(_, name);\n \n     ret ivec::filter_map(filter, items);\n }\n \n-fn require_unique_names(&session::session sess, &(@ast::meta_item)[] metas) {\n-    auto map = map::mk_hashmap[str, ()](str::hash, str::eq);\n-    for (@ast::meta_item meta in metas) {\n-        auto name = get_meta_item_name(meta);\n-        if (map.contains_key(name)) {\n+fn require_unique_names(sess: &session::session,\n+                        metas: &(@ast::meta_item)[]) {\n+    let map = map::mk_hashmap[str, ()](str::hash, str::eq);\n+    for meta: @ast::meta_item  in metas {\n+        let name = get_meta_item_name(meta);\n+        if map.contains_key(name) {\n             sess.span_fatal(meta.span,\n                             #fmt(\"duplicate meta item `%s`\", name));\n         }\n         map.insert(name, ());\n     }\n }\n \n-fn span[T](&T item) -> ast::spanned[T] {\n-    ret rec(node=item, span=rec(lo=0u, hi=0u));\n+fn span[T](item: &T) -> ast::spanned[T] {\n+    ret {node: item, span: {lo: 0u, hi: 0u}};\n }\n \n-fn mk_name_value_item_str(ast::ident name, str value) -> @ast::meta_item {\n-    auto value_lit = span(ast::lit_str(value, ast::sk_rc));\n+fn mk_name_value_item_str(name: ast::ident, value: str) -> @ast::meta_item {\n+    let value_lit = span(ast::lit_str(value, ast::sk_rc));\n     ret mk_name_value_item(name, value_lit);\n }\n \n-fn mk_name_value_item(ast::ident name, ast::lit value) -> @ast::meta_item {\n+fn mk_name_value_item(name: ast::ident, value: ast::lit) -> @ast::meta_item {\n     ret @span(ast::meta_name_value(name, value));\n }\n \n-fn mk_list_item(ast::ident name, &(@ast::meta_item)[] items)\n-        -> @ast::meta_item {\n+fn mk_list_item(name: ast::ident, items: &(@ast::meta_item)[]) ->\n+   @ast::meta_item {\n     ret @span(ast::meta_list(name, items));\n }\n \n-fn mk_word_item(ast::ident name) -> @ast::meta_item {\n+fn mk_word_item(name: ast::ident) -> @ast::meta_item {\n     ret @span(ast::meta_word(name));\n }\n \n-fn mk_attr(@ast::meta_item item) -> ast::attribute {\n-    ret span(rec(style = ast::attr_inner,\n-                 value = *item));\n+fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n+    ret span({style: ast::attr_inner, value: *item});\n }\n \n //"}, {"sha": "1107e69875f8c8a126b9da0e4e577f1c3dc6fa63", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 74, "deletions": 78, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -8,124 +8,120 @@ export strip_unconfigured_items;\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n-fn strip_unconfigured_items(@ast::crate crate) -> @ast::crate {\n-    auto cfg = crate.node.config;\n+fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n+    let cfg = crate.node.config;\n \n-    auto precursor = rec(fold_mod = bind fold_mod(cfg, _, _),\n-                         fold_block = bind fold_block(cfg, _, _),\n-                         fold_native_mod = bind fold_native_mod(cfg, _, _)\n-                         with *fold::default_ast_fold());\n+    let precursor =\n+        {fold_mod: bind fold_mod(cfg, _, _),\n+         fold_block: bind fold_block(cfg, _, _),\n+         fold_native_mod: bind fold_native_mod(cfg, _, _)\n+            with *fold::default_ast_fold()};\n \n-    auto fold = fold::make_fold(precursor);\n-    auto res = @fold.fold_crate(*crate);\n+    let fold = fold::make_fold(precursor);\n+    let res = @fold.fold_crate(*crate);\n     // FIXME: This is necessary to break a circular reference\n     fold::dummy_out(fold);\n     ret res;\n }\n \n-fn filter_item(&ast::crate_cfg cfg,\n-               &@ast::item item) -> option::t[@ast::item] {\n-    if (item_in_cfg(cfg, item)) {\n-        option::some(item)\n-    } else {\n-        option::none\n-    }\n+fn filter_item(cfg: &ast::crate_cfg, item: &@ast::item) ->\n+   option::t[@ast::item] {\n+    if item_in_cfg(cfg, item) { option::some(item) } else { option::none }\n }\n \n-fn fold_mod(&ast::crate_cfg cfg, &ast::_mod m,\n-              fold::ast_fold fld) -> ast::_mod {\n-    auto filter = bind filter_item(cfg, _);\n-    auto filtered_items = ivec::filter_map(filter, m.items);\n-    ret rec(view_items=ivec::map(fld.fold_view_item, m.view_items),\n-            items=ivec::map(fld.fold_item, filtered_items));\n+fn fold_mod(cfg: &ast::crate_cfg, m: &ast::_mod, fld: fold::ast_fold) ->\n+   ast::_mod {\n+    let filter = bind filter_item(cfg, _);\n+    let filtered_items = ivec::filter_map(filter, m.items);\n+    ret {view_items: ivec::map(fld.fold_view_item, m.view_items),\n+         items: ivec::map(fld.fold_item, filtered_items)};\n }\n \n-fn filter_native_item(&ast::crate_cfg cfg, &@ast::native_item item)\n-    -> option::t[@ast::native_item] {\n-    if (native_item_in_cfg(cfg, item)) {\n+fn filter_native_item(cfg: &ast::crate_cfg, item: &@ast::native_item) ->\n+   option::t[@ast::native_item] {\n+    if native_item_in_cfg(cfg, item) {\n         option::some(item)\n-    } else {\n-        option::none\n-    }\n+    } else { option::none }\n }\n \n-fn fold_native_mod(&ast::crate_cfg cfg, &ast::native_mod nm,\n-                   fold::ast_fold fld) -> ast::native_mod {\n-    auto filter = bind filter_native_item(cfg, _);\n-    auto filtered_items = ivec::filter_map(filter, nm.items);\n-    ret rec(native_name=nm.native_name,\n-            abi=nm.abi,\n-            view_items=ivec::map(fld.fold_view_item, nm.view_items),\n-            items=filtered_items);\n+fn fold_native_mod(cfg: &ast::crate_cfg, nm: &ast::native_mod,\n+                   fld: fold::ast_fold) -> ast::native_mod {\n+    let filter = bind filter_native_item(cfg, _);\n+    let filtered_items = ivec::filter_map(filter, nm.items);\n+    ret {native_name: nm.native_name,\n+         abi: nm.abi,\n+         view_items: ivec::map(fld.fold_view_item, nm.view_items),\n+         items: filtered_items};\n }\n \n-fn filter_stmt(&ast::crate_cfg cfg,\n-               &@ast::stmt stmt) -> option::t[@ast::stmt] {\n-    alt (stmt.node) {\n-        case (ast::stmt_decl(?decl, _)) {\n-            alt (decl.node) {\n-                case (ast::decl_item(?item)) {\n-                    if (item_in_cfg(cfg, item)) {\n-                        option::some(stmt)\n-                    } else {\n-                        option::none\n-                    }\n-                }\n-                case (_) { option::some(stmt) }\n-            }\n+fn filter_stmt(cfg: &ast::crate_cfg, stmt: &@ast::stmt) ->\n+   option::t[@ast::stmt] {\n+    alt stmt.node {\n+      ast::stmt_decl(decl, _) {\n+        alt decl.node {\n+          ast::decl_item(item) {\n+            if item_in_cfg(cfg, item) {\n+                option::some(stmt)\n+            } else { option::none }\n+          }\n+          _ { option::some(stmt) }\n         }\n-        case (_) { option::some(stmt) }\n+      }\n+      _ { option::some(stmt) }\n     }\n }\n \n-fn fold_block(&ast::crate_cfg cfg, &ast::blk_ b,\n-              fold::ast_fold fld) -> ast::blk_  {\n-    auto filter = bind filter_stmt(cfg, _);\n-    auto filtered_stmts = ivec::filter_map(filter, b.stmts);\n-    ret rec(stmts=ivec::map(fld.fold_stmt, filtered_stmts),\n-            expr=option::map(fld.fold_expr, b.expr),\n-            id=b.id);\n+fn fold_block(cfg: &ast::crate_cfg, b: &ast::blk_, fld: fold::ast_fold) ->\n+   ast::blk_ {\n+    let filter = bind filter_stmt(cfg, _);\n+    let filtered_stmts = ivec::filter_map(filter, b.stmts);\n+    ret {stmts: ivec::map(fld.fold_stmt, filtered_stmts),\n+         expr: option::map(fld.fold_expr, b.expr),\n+         id: b.id};\n }\n \n-fn item_in_cfg(&ast::crate_cfg cfg, &@ast::item item) -> bool {\n+fn item_in_cfg(cfg: &ast::crate_cfg, item: &@ast::item) -> bool {\n     ret in_cfg(cfg, item.attrs);\n }\n \n-fn native_item_in_cfg(&ast::crate_cfg cfg, &@ast::native_item item) -> bool {\n+fn native_item_in_cfg(cfg: &ast::crate_cfg, item: &@ast::native_item) ->\n+   bool {\n     ret in_cfg(cfg, item.attrs);\n }\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(&ast::crate_cfg cfg, &ast::attribute[] attrs) -> bool {\n+fn in_cfg(cfg: &ast::crate_cfg, attrs: &ast::attribute[]) -> bool {\n \n     // The \"cfg\" attributes on the item\n-    auto item_cfg_attrs = attr::find_attrs_by_name(attrs, \"cfg\");\n-    auto item_has_cfg_attrs = ivec::len(item_cfg_attrs) > 0u;\n-    if (!item_has_cfg_attrs) { ret true; }\n+    let item_cfg_attrs = attr::find_attrs_by_name(attrs, \"cfg\");\n+    let item_has_cfg_attrs = ivec::len(item_cfg_attrs) > 0u;\n+    if !item_has_cfg_attrs { ret true; }\n \n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n-    auto item_cfg_metas = {\n-        fn extract_metas(&(@ast::meta_item)[] inner_items,\n-                         &@ast::meta_item cfg_item)\n-        -> (@ast::meta_item)[] {\n-\n-            alt (cfg_item.node) {\n-                case (ast::meta_list(?name, ?items)) {\n-                    assert name == \"cfg\";\n+    let \n+\n+        item_cfg_metas =\n+        {\n+            fn extract_metas(inner_items: &(@ast::meta_item)[],\n+                             cfg_item: &@ast::meta_item) ->\n+               (@ast::meta_item)[] {\n+                alt cfg_item.node {\n+                  ast::meta_list(name, items) {\n+                    assert (name == \"cfg\");\n                     inner_items + items\n+                  }\n+                  _ { inner_items }\n                 }\n-                case (_) { inner_items }\n             }\n-        }\n-        auto cfg_metas = attr::attr_metas(item_cfg_attrs);\n-        ivec::foldl(extract_metas, ~[], cfg_metas)\n-    };\n+            let cfg_metas = attr::attr_metas(item_cfg_attrs);\n+            ivec::foldl(extract_metas, ~[], cfg_metas)\n+        };\n \n-    for (@ast::meta_item cfg_mi in item_cfg_metas) {\n-        if (attr::contains(cfg, cfg_mi)) { ret true; }\n+    for cfg_mi: @ast::meta_item  in item_cfg_metas {\n+        if attr::contains(cfg, cfg_mi) { ret true; }\n     }\n \n     ret false;"}, {"sha": "8f4afc86877d4ce24d1f91698f1c852e85a0ae5e", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 224, "deletions": 235, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -9,125 +9,124 @@ import front::attr;\n \n export modify_for_testing;\n \n-type node_id_gen = @fn() -> ast::node_id;\n+type node_id_gen = @fn() -> ast::node_id ;\n \n-type test = rec(ast::ident[] path,\n-                bool ignore);\n+type test = {path: ast::ident[], ignore: bool};\n \n-type test_ctxt = @rec(node_id_gen next_node_id,\n-                      mutable ast::ident[] path,\n-                      mutable test[] testfns);\n+type test_ctxt =\n+    @{next_node_id: node_id_gen,\n+      mutable path: ast::ident[],\n+      mutable testfns: test[]};\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-fn modify_for_testing(@ast::crate crate) -> @ast::crate {\n+fn modify_for_testing(crate: @ast::crate) -> @ast::crate {\n \n     // FIXME: This hackasaurus assumes that 200000 is a safe number to start\n     // generating node_ids at (which is totally not the case). pauls is going\n     // to land a patch that puts parse_sess into session, which will give us\n     // access to the real next node_id.\n-    auto next_node_id = @mutable 200000;\n-    auto next_node_id_fn = @bind fn(@mutable ast::node_id next_node_id)\n-        -> ast::node_id {\n-        auto this_node_id = *next_node_id;\n-        *next_node_id = next_node_id + 1;\n-        ret this_node_id;\n-    } (next_node_id);\n-\n-    let test_ctxt cx = @rec(next_node_id = next_node_id_fn,\n-                            mutable path = ~[],\n-                            mutable testfns = ~[]);\n-\n-    auto precursor = rec(fold_crate = bind fold_crate(cx, _, _),\n-                         fold_item = bind fold_item(cx, _, _),\n-                         fold_mod = bind fold_mod(cx, _, _)\n-                         with *fold::default_ast_fold());\n-\n-    auto fold = fold::make_fold(precursor);\n-    auto res = @fold.fold_crate(*crate);\n+    let next_node_id = @mutable 200000;\n+    let next_node_id_fn =\n+        @bind fn (next_node_id: @mutable ast::node_id) -> ast::node_id {\n+                  let this_node_id = *next_node_id;\n+                  *next_node_id = next_node_id + 1;\n+                  ret this_node_id;\n+              }(next_node_id);\n+\n+    let cx: test_ctxt =\n+        @{next_node_id: next_node_id_fn,\n+          mutable path: ~[],\n+          mutable testfns: ~[]};\n+\n+    let precursor =\n+        {fold_crate: bind fold_crate(cx, _, _),\n+         fold_item: bind fold_item(cx, _, _),\n+         fold_mod: bind fold_mod(cx, _, _) with *fold::default_ast_fold()};\n+\n+    let fold = fold::make_fold(precursor);\n+    let res = @fold.fold_crate(*crate);\n     // FIXME: This is necessary to break a circular reference\n     fold::dummy_out(fold);\n     ret res;\n }\n \n-fn fold_mod(&test_ctxt cx, &ast::_mod m,\n-            fold::ast_fold fld) -> ast::_mod {\n+fn fold_mod(cx: &test_ctxt, m: &ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n \n     // Remove any defined main function from the AST so it doesn't clash with\n     // the one we're going to add.  FIXME: This is sloppy. Instead we should\n     // have some mechanism to indicate to the translation pass which function\n     // we want to be main.\n-    fn nomain(&@ast::item item) -> option::t[@ast::item] {\n-        alt (item.node) {\n-            ast::item_fn(?f, _) {\n-                if (item.ident == \"main\") { option::none }\n-                else { option::some(item) }\n-            }\n-            _ { option::some(item) }\n+    fn nomain(item: &@ast::item) -> option::t[@ast::item] {\n+        alt item.node {\n+          ast::item_fn(f, _) {\n+            if item.ident == \"main\" {\n+                option::none\n+            } else { option::some(item) }\n+          }\n+          _ { option::some(item) }\n         }\n     }\n \n-    auto mod_nomain = rec(view_items=m.view_items,\n-                          items=ivec::filter_map(nomain, m.items));\n+    let mod_nomain =\n+        {view_items: m.view_items, items: ivec::filter_map(nomain, m.items)};\n     ret fold::noop_fold_mod(mod_nomain, fld);\n }\n \n-fn fold_crate(&test_ctxt cx, &ast::crate_ c,\n-              fold::ast_fold fld) -> ast::crate_ {\n-    auto folded = fold::noop_fold_crate(c, fld);\n+fn fold_crate(cx: &test_ctxt, c: &ast::crate_, fld: fold::ast_fold) ->\n+   ast::crate_ {\n+    let folded = fold::noop_fold_crate(c, fld);\n \n     // Add a special __test module to the crate that will contain code\n     // generated for the test harness\n-    ret rec(module = add_test_module(cx, folded.module)\n-            with folded);\n+    ret {module: add_test_module(cx, folded.module) with folded};\n }\n \n \n-fn fold_item(&test_ctxt cx, &@ast::item i,\n-             fold::ast_fold fld) -> @ast::item {\n+fn fold_item(cx: &test_ctxt, i: &@ast::item, fld: fold::ast_fold) ->\n+   @ast::item {\n \n     cx.path += ~[i.ident];\n     log #fmt(\"current path: %s\", ast::path_name_i(cx.path));\n \n-    if (is_test_fn(i)) {\n+    if is_test_fn(i) {\n         log \"this is a test function\";\n-        auto test = rec(path = cx.path,\n-                        ignore = is_ignored(i));\n+        let test = {path: cx.path, ignore: is_ignored(i)};\n         cx.testfns += ~[test];\n         log #fmt(\"have %u test functions\", ivec::len(cx.testfns));\n     }\n \n-    auto res = fold::noop_fold_item(i, fld);\n+    let res = fold::noop_fold_item(i, fld);\n     ivec::pop(cx.path);\n     ret res;\n }\n \n-fn is_test_fn(&@ast::item i) -> bool {\n-    auto has_test_attr =\n+fn is_test_fn(i: &@ast::item) -> bool {\n+    let has_test_attr =\n         ivec::len(attr::find_attrs_by_name(i.attrs, \"test\")) > 0u;\n \n-    fn has_test_signature(&@ast::item i) -> bool {\n-        alt (i.node) {\n-            case (ast::item_fn(?f, ?tps)) {\n-                auto input_cnt = ivec::len(f.decl.inputs);\n-                auto no_output = f.decl.output.node == ast::ty_nil;\n-                auto tparm_cnt = ivec::len(tps);\n-                input_cnt == 0u && no_output && tparm_cnt == 0u\n-            }\n-            case (_) { false }\n+    fn has_test_signature(i: &@ast::item) -> bool {\n+        alt i.node {\n+          ast::item_fn(f, tps) {\n+            let input_cnt = ivec::len(f.decl.inputs);\n+            let no_output = f.decl.output.node == ast::ty_nil;\n+            let tparm_cnt = ivec::len(tps);\n+            input_cnt == 0u && no_output && tparm_cnt == 0u\n+          }\n+          _ { false }\n         }\n     }\n \n     ret has_test_attr && has_test_signature(i);\n }\n \n-fn is_ignored(&@ast::item i) -> bool {\n+fn is_ignored(i: &@ast::item) -> bool {\n     attr::contains_name(attr::attr_metas(i.attrs), \"ignore\")\n }\n \n-fn add_test_module(&test_ctxt cx, &ast::_mod m) -> ast::_mod {\n-    auto testmod = mk_test_module(cx);\n-    ret rec(items=m.items + ~[testmod] with m);\n+fn add_test_module(cx: &test_ctxt, m: &ast::_mod) -> ast::_mod {\n+    let testmod = mk_test_module(cx);\n+    ret {items: m.items + ~[testmod] with m};\n }\n \n /*\n@@ -147,241 +146,231 @@ mod __test {\n \n */\n \n-fn mk_test_module(&test_ctxt cx) -> @ast::item {\n+fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n     // A function that generates a vector of test descriptors to feed to the\n     // test runner\n-    auto testsfn = mk_tests(cx);\n+    let testsfn = mk_tests(cx);\n     // The synthesized main function which will call the console test runner\n     // with our list of tests\n-    auto mainfn = mk_main(cx);\n-    let ast::_mod testmod = rec(view_items=~[],\n-                                items=~[mainfn, testsfn]);\n-    auto item_ = ast::item_mod(testmod);\n-    let ast::item item = rec(ident = \"__test\",\n-                              attrs = ~[],\n-                              id = cx.next_node_id(),\n-                              node = item_,\n-                              span = rec(lo=0u, hi=0u));\n+    let mainfn = mk_main(cx);\n+    let testmod: ast::_mod = {view_items: ~[], items: ~[mainfn, testsfn]};\n+    let item_ = ast::item_mod(testmod);\n+    let item: ast::item =\n+        {ident: \"__test\",\n+         attrs: ~[],\n+         id: cx.next_node_id(),\n+         node: item_,\n+         span: {lo: 0u, hi: 0u}};\n \n     log #fmt(\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item));\n \n     ret @item;\n }\n \n-fn nospan[T](&T t) -> ast::spanned[T] {\n-    ret rec(node=t,\n-            span=rec(lo=0u,hi=0u));\n+fn nospan[T](t: &T) -> ast::spanned[T] {\n+    ret {node: t, span: {lo: 0u, hi: 0u}};\n }\n \n-fn mk_tests(&test_ctxt cx) -> @ast::item {\n-    auto ret_ty = mk_test_desc_ivec_ty(cx);\n+fn mk_tests(cx: &test_ctxt) -> @ast::item {\n+    let ret_ty = mk_test_desc_ivec_ty(cx);\n \n-    let ast::fn_decl decl = rec(inputs = ~[],\n-                                output = ret_ty,\n-                                purity = ast::impure_fn,\n-                                cf = ast::return,\n-                                constraints = ~[]);\n-    auto proto = ast::proto_fn;\n+    let decl: ast::fn_decl =\n+        {inputs: ~[],\n+         output: ret_ty,\n+         purity: ast::impure_fn,\n+         cf: ast::return,\n+         constraints: ~[]};\n+    let proto = ast::proto_fn;\n \n     // The vector of test_descs for this crate\n-    auto test_descs = mk_test_desc_vec(cx);\n-\n-    let ast::blk_ body_= rec(stmts = ~[],\n-                               expr = option::some(test_descs),\n-                               id = cx.next_node_id());\n-    auto body = nospan(body_);\n-\n-    auto fn_ = rec(decl = decl,\n-                   proto = proto,\n-                   body = body);\n-\n-    auto item_ = ast::item_fn(fn_, ~[]);\n-    let ast::item item = rec(ident = \"tests\",\n-                             attrs = ~[],\n-                             id = cx.next_node_id(),\n-                             node = item_,\n-                             span = rec(lo=0u, hi=0u));\n+    let test_descs = mk_test_desc_vec(cx);\n+\n+    let body_: ast::blk_ =\n+        {stmts: ~[], expr: option::some(test_descs), id: cx.next_node_id()};\n+    let body = nospan(body_);\n+\n+    let fn_ = {decl: decl, proto: proto, body: body};\n+\n+    let item_ = ast::item_fn(fn_, ~[]);\n+    let item: ast::item =\n+        {ident: \"tests\",\n+         attrs: ~[],\n+         id: cx.next_node_id(),\n+         node: item_,\n+         span: {lo: 0u, hi: 0u}};\n     ret @item;\n }\n \n fn empty_fn_ty() -> ast::ty {\n-    auto proto = ast::proto_fn;\n-    auto input_ty = ~[];\n-    auto ret_ty = @nospan(ast::ty_nil);\n-    auto cf = ast::return;\n-    auto constrs = ~[];\n+    let proto = ast::proto_fn;\n+    let input_ty = ~[];\n+    let ret_ty = @nospan(ast::ty_nil);\n+    let cf = ast::return;\n+    let constrs = ~[];\n     ret nospan(ast::ty_fn(proto, input_ty, ret_ty, cf, constrs));\n }\n \n // The ast::ty of std::test::test_desc[]\n-fn mk_test_desc_ivec_ty(&test_ctxt cx) -> @ast::ty {\n-    let ast::path test_desc_ty_path = nospan(rec(global = false,\n-                                                 idents = ~[\"std\",\n-                                                            \"test\",\n-                                                            \"test_desc\"],\n-                                                 types = ~[]));\n+fn mk_test_desc_ivec_ty(cx: &test_ctxt) -> @ast::ty {\n+    let test_desc_ty_path: ast::path =\n+        nospan({global: false,\n+                idents: ~[\"std\", \"test\", \"test_desc\"],\n+                types: ~[]});\n \n-    let ast::ty test_desc_ty = nospan(ast::ty_path(test_desc_ty_path,\n-                                                   cx.next_node_id()));\n+    let test_desc_ty: ast::ty =\n+        nospan(ast::ty_path(test_desc_ty_path, cx.next_node_id()));\n \n-    let ast::mt ivec_mt = rec(ty = @test_desc_ty,\n-                              mut = ast::imm);\n+    let ivec_mt: ast::mt = {ty: @test_desc_ty, mut: ast::imm};\n \n     ret @nospan(ast::ty_ivec(ivec_mt));\n }\n \n-fn mk_test_desc_vec(&test_ctxt cx) -> @ast::expr {\n-    log #fmt(\"building test vector from %u tests\",\n-             ivec::len(cx.testfns));\n-    auto descs = ~[];\n-    for (test test in cx.testfns) {\n-        auto test_ = test; // Satisfy alias analysis\n+fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n+    log #fmt(\"building test vector from %u tests\", ivec::len(cx.testfns));\n+    let descs = ~[];\n+    for test: test  in cx.testfns {\n+        let test_ = test; // Satisfy alias analysis\n         descs += ~[mk_test_desc_rec(cx, test_)];\n     }\n \n-    ret @rec(id = cx.next_node_id(),\n-             node = ast::expr_vec(descs, ast::imm, ast::sk_unique),\n-             span = rec(lo=0u,hi=0u));\n+    ret @{id: cx.next_node_id(),\n+          node: ast::expr_vec(descs, ast::imm, ast::sk_unique),\n+          span: {lo: 0u, hi: 0u}};\n }\n \n-fn mk_test_desc_rec(&test_ctxt cx, test test) -> @ast::expr {\n-    auto path = test.path;\n+fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n+    let path = test.path;\n \n     log #fmt(\"encoding %s\", ast::path_name_i(path));\n \n-    let ast::lit name_lit = nospan(ast::lit_str(ast::path_name_i(path),\n-                                                ast::sk_rc));\n-    let ast::expr name_expr = rec(id = cx.next_node_id(),\n-                                  node = ast::expr_lit(@name_lit),\n-                                  span = rec(lo=0u, hi=0u));\n-\n-    let ast::field name_field = nospan(rec(mut = ast::imm,\n-                                           ident = \"name\",\n-                                           expr = @name_expr));\n-\n-    let ast::path fn_path = nospan(rec(global = false,\n-                                       idents = path,\n-                                       types = ~[]));\n-\n-    let ast::expr fn_expr = rec(id = cx.next_node_id(),\n-                                node = ast::expr_path(fn_path),\n-                                span = rec(lo=0u, hi=0u));\n-\n-    let ast::field fn_field = nospan(rec(mut = ast::imm,\n-                                         ident = \"fn\",\n-                                         expr = @fn_expr));\n-\n-    let ast::lit ignore_lit = nospan(ast::lit_bool(test.ignore));\n-\n-    let ast::expr ignore_expr = rec(id = cx.next_node_id(),\n-                                    node = ast::expr_lit(@ignore_lit),\n-                                    span = rec(lo=0u, hi=0u));\n-\n-    let ast::field ignore_field = nospan(rec(mut = ast::imm,\n-                                             ident = \"ignore\",\n-                                             expr = @ignore_expr));\n-\n-    let ast::expr_ desc_rec_ = ast::expr_rec(~[name_field,\n-                                               fn_field,\n-                                               ignore_field],\n-                                             option::none);\n-    let ast::expr desc_rec = rec(id = cx.next_node_id(),\n-                                 node = desc_rec_,\n-                                 span = rec(lo=0u, hi=0u));\n+    let name_lit: ast::lit =\n+        nospan(ast::lit_str(ast::path_name_i(path), ast::sk_rc));\n+    let name_expr: ast::expr =\n+        {id: cx.next_node_id(),\n+         node: ast::expr_lit(@name_lit),\n+         span: {lo: 0u, hi: 0u}};\n+\n+    let name_field: ast::field =\n+        nospan({mut: ast::imm, ident: \"name\", expr: @name_expr});\n+\n+    let fn_path: ast::path =\n+        nospan({global: false, idents: path, types: ~[]});\n+\n+    let fn_expr: ast::expr =\n+        {id: cx.next_node_id(),\n+         node: ast::expr_path(fn_path),\n+         span: {lo: 0u, hi: 0u}};\n+\n+    let fn_field: ast::field =\n+        nospan({mut: ast::imm, ident: \"fn\", expr: @fn_expr});\n+\n+    let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n+\n+    let ignore_expr: ast::expr =\n+        {id: cx.next_node_id(),\n+         node: ast::expr_lit(@ignore_lit),\n+         span: {lo: 0u, hi: 0u}};\n+\n+    let ignore_field: ast::field =\n+        nospan({mut: ast::imm, ident: \"ignore\", expr: @ignore_expr});\n+\n+    let desc_rec_: ast::expr_ =\n+        ast::expr_rec(~[name_field, fn_field, ignore_field], option::none);\n+    let desc_rec: ast::expr =\n+        {id: cx.next_node_id(), node: desc_rec_, span: {lo: 0u, hi: 0u}};\n     ret @desc_rec;\n }\n \n-fn mk_main(&test_ctxt cx) -> @ast::item {\n+fn mk_main(cx: &test_ctxt) -> @ast::item {\n \n-    let ast::mt args_mt = rec(ty = @nospan(ast::ty_str),\n-                              mut = ast::imm);\n-    let ast::ty args_ty = nospan(ast::ty_vec(args_mt));\n+    let args_mt: ast::mt = {ty: @nospan(ast::ty_str), mut: ast::imm};\n+    let args_ty: ast::ty = nospan(ast::ty_vec(args_mt));\n \n-    let ast::arg args_arg = rec(mode = ast::val,\n-                                ty = @args_ty,\n-                                ident = \"args\",\n-                                id = cx.next_node_id());\n+    let args_arg: ast::arg =\n+        {mode: ast::val, ty: @args_ty, ident: \"args\", id: cx.next_node_id()};\n \n-    auto ret_ty = nospan(ast::ty_nil);\n+    let ret_ty = nospan(ast::ty_nil);\n \n-    let ast::fn_decl decl = rec(inputs = ~[args_arg],\n-                                output = @ret_ty,\n-                                purity = ast::impure_fn,\n-                                cf = ast::return,\n-                                constraints = ~[]);\n-    auto proto = ast::proto_fn;\n+    let decl: ast::fn_decl =\n+        {inputs: ~[args_arg],\n+         output: @ret_ty,\n+         purity: ast::impure_fn,\n+         cf: ast::return,\n+         constraints: ~[]};\n+    let proto = ast::proto_fn;\n \n-    auto test_main_call_expr = mk_test_main_call(cx);\n+    let test_main_call_expr = mk_test_main_call(cx);\n \n-    let ast::blk_ body_ = rec(stmts = ~[],\n-                                expr = option::some(test_main_call_expr),\n-                                id = cx.next_node_id());\n-    auto body = rec(node = body_, span = rec(lo=0u, hi=0u));\n+    let body_: ast::blk_ =\n+        {stmts: ~[],\n+         expr: option::some(test_main_call_expr),\n+         id: cx.next_node_id()};\n+    let body = {node: body_, span: {lo: 0u, hi: 0u}};\n \n-    auto fn_ = rec(decl = decl,\n-                   proto = proto,\n-                   body = body);\n+    let fn_ = {decl: decl, proto: proto, body: body};\n \n-    auto item_ = ast::item_fn(fn_, ~[]);\n-    let ast::item item = rec(ident = \"main\",\n-                             attrs = ~[],\n-                             id = cx.next_node_id(),\n-                             node = item_,\n-                             span = rec(lo=0u, hi=0u));\n+    let item_ = ast::item_fn(fn_, ~[]);\n+    let item: ast::item =\n+        {ident: \"main\",\n+         attrs: ~[],\n+         id: cx.next_node_id(),\n+         node: item_,\n+         span: {lo: 0u, hi: 0u}};\n     ret @item;\n }\n \n-fn mk_test_main_call(&test_ctxt cx) -> @ast::expr {\n+fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n \n     // Get the args passed to main so we can pass the to test_main\n-    let ast::path args_path = nospan(rec(global = false,\n-                                         idents = ~[\"args\"],\n-                                         types = ~[]));\n+    let args_path: ast::path =\n+        nospan({global: false, idents: ~[\"args\"], types: ~[]});\n \n-    let ast::expr_ args_path_expr_ = ast::expr_path(args_path);\n+    let args_path_expr_: ast::expr_ = ast::expr_path(args_path);\n \n-    let ast::expr args_path_expr = rec(id = cx.next_node_id(),\n-                                       node = args_path_expr_,\n-                                       span = rec(lo=0u, hi=0u));\n+    let args_path_expr: ast::expr =\n+        {id: cx.next_node_id(),\n+         node: args_path_expr_,\n+         span: {lo: 0u, hi: 0u}};\n \n     // Call __test::test to generate the vector of test_descs\n-    let ast::path test_path = nospan(rec(global = false,\n-                                         idents = ~[\"tests\"],\n-                                         types = ~[]));\n+    let test_path: ast::path =\n+        nospan({global: false, idents: ~[\"tests\"], types: ~[]});\n \n-    let ast::expr_ test_path_expr_ = ast::expr_path(test_path);\n+    let test_path_expr_: ast::expr_ = ast::expr_path(test_path);\n \n-    let ast::expr test_path_expr = rec(id = cx.next_node_id(),\n-                                       node = test_path_expr_,\n-                                       span = rec(lo=0u, hi=0u));\n+    let test_path_expr: ast::expr =\n+        {id: cx.next_node_id(),\n+         node: test_path_expr_,\n+         span: {lo: 0u, hi: 0u}};\n \n-    let ast::expr_ test_call_expr_ = ast::expr_call(@test_path_expr, ~[]);\n+    let test_call_expr_: ast::expr_ = ast::expr_call(@test_path_expr, ~[]);\n \n-    let ast::expr test_call_expr = rec(id = cx.next_node_id(),\n-                                       node = test_call_expr_,\n-                                       span = rec(lo=0u, hi=0u));\n+    let test_call_expr: ast::expr =\n+        {id: cx.next_node_id(),\n+         node: test_call_expr_,\n+         span: {lo: 0u, hi: 0u}};\n \n     // Call std::test::test_main\n-    let ast::path test_main_path = nospan(rec(global = false,\n-                                              idents = ~[\"std\",\n-                                                         \"test\",\n-                                                         \"test_main\"],\n-                                              types = ~[]));\n-\n-    let ast::expr_ test_main_path_expr_\n-        = ast::expr_path(test_main_path);\n-\n-    let ast::expr test_main_path_expr = rec(id = cx.next_node_id(),\n-                                            node = test_main_path_expr_,\n-                                            span = rec(lo=0u, hi=0u));\n-\n-    let ast::expr_ test_main_call_expr_\n-        = ast::expr_call(@test_main_path_expr, ~[@args_path_expr,\n-                                                 @test_call_expr]);\n-\n-    let ast::expr test_main_call_expr = rec(id = cx.next_node_id(),\n-                                            node = test_main_call_expr_,\n-                                            span = rec(lo=0u, hi=0u));\n+    let test_main_path: ast::path =\n+        nospan({global: false,\n+                idents: ~[\"std\", \"test\", \"test_main\"],\n+                types: ~[]});\n+\n+    let test_main_path_expr_: ast::expr_ = ast::expr_path(test_main_path);\n+\n+    let test_main_path_expr: ast::expr =\n+        {id: cx.next_node_id(),\n+         node: test_main_path_expr_,\n+         span: {lo: 0u, hi: 0u}};\n+\n+    let test_main_call_expr_: ast::expr_ =\n+        ast::expr_call(@test_main_path_expr,\n+                       ~[@args_path_expr, @test_call_expr]);\n+\n+    let test_main_call_expr: ast::expr =\n+        {id: cx.next_node_id(),\n+         node: test_main_call_expr_,\n+         span: {lo: 0u, hi: 0u}};\n \n     ret @test_main_call_expr;\n }"}, {"sha": "019179d45ec6fccf53f6260902bf166ade498de6", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 867, "deletions": 875, "changes": 1742, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "e8fce2da7dfd01489f9ac2b26c3146bab0df1338", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -2,72 +2,72 @@\n \n import std::str;\n \n-const uint tag_paths = 0x01u;\n+const tag_paths: uint = 0x01u;\n \n-const uint tag_items = 0x02u;\n+const tag_items: uint = 0x02u;\n \n-const uint tag_paths_data = 0x03u;\n+const tag_paths_data: uint = 0x03u;\n \n-const uint tag_paths_data_name = 0x04u;\n+const tag_paths_data_name: uint = 0x04u;\n \n-const uint tag_paths_data_item = 0x05u;\n+const tag_paths_data_item: uint = 0x05u;\n \n-const uint tag_paths_data_mod = 0x06u;\n+const tag_paths_data_mod: uint = 0x06u;\n \n-const uint tag_def_id = 0x07u;\n+const tag_def_id: uint = 0x07u;\n \n-const uint tag_items_data = 0x08u;\n+const tag_items_data: uint = 0x08u;\n \n-const uint tag_items_data_item = 0x09u;\n+const tag_items_data_item: uint = 0x09u;\n \n-const uint tag_items_data_item_kind = 0x0au;\n+const tag_items_data_item_kind: uint = 0x0au;\n \n-const uint tag_items_data_item_ty_param_count = 0x0bu;\n+const tag_items_data_item_ty_param_count: uint = 0x0bu;\n \n-const uint tag_items_data_item_type = 0x0cu;\n+const tag_items_data_item_type: uint = 0x0cu;\n \n-const uint tag_items_data_item_symbol = 0x0du;\n+const tag_items_data_item_symbol: uint = 0x0du;\n \n-const uint tag_items_data_item_variant = 0x0eu;\n+const tag_items_data_item_variant: uint = 0x0eu;\n \n-const uint tag_items_data_item_tag_id = 0x0fu;\n+const tag_items_data_item_tag_id: uint = 0x0fu;\n \n-const uint tag_index = 0x11u;\n+const tag_index: uint = 0x11u;\n \n-const uint tag_index_buckets = 0x12u;\n+const tag_index_buckets: uint = 0x12u;\n \n-const uint tag_index_buckets_bucket = 0x13u;\n+const tag_index_buckets_bucket: uint = 0x13u;\n \n-const uint tag_index_buckets_bucket_elt = 0x14u;\n+const tag_index_buckets_bucket_elt: uint = 0x14u;\n \n-const uint tag_index_table = 0x15u;\n+const tag_index_table: uint = 0x15u;\n \n-const uint tag_meta_item_name_value = 0x18u;\n+const tag_meta_item_name_value: uint = 0x18u;\n \n-const uint tag_meta_item_name = 0x19u;\n+const tag_meta_item_name: uint = 0x19u;\n \n-const uint tag_meta_item_value = 0x20u;\n+const tag_meta_item_value: uint = 0x20u;\n \n-const uint tag_attributes = 0x21u;\n+const tag_attributes: uint = 0x21u;\n \n-const uint tag_attribute = 0x22u;\n+const tag_attribute: uint = 0x22u;\n \n-const uint tag_meta_item_word = 0x23u;\n+const tag_meta_item_word: uint = 0x23u;\n \n-const uint tag_meta_item_list = 0x24u;\n+const tag_meta_item_list: uint = 0x24u;\n \n // The list of crates that this crate depends on\n-const uint tag_crate_deps = 0x25u;\n+const tag_crate_deps: uint = 0x25u;\n \n // A single crate dependency\n-const uint tag_crate_dep = 0x26u;\n+const tag_crate_dep: uint = 0x26u;\n \n // djb's cdb hashes.\n-fn hash_node_id(&int node_id) -> uint { ret 177573u ^ (node_id as uint); }\n+fn hash_node_id(node_id: &int) -> uint { ret 177573u ^ (node_id as uint); }\n \n-fn hash_path(&str s) -> uint {\n-    auto h = 5381u;\n-    for (u8 ch in str::bytes(s)) { h = (h << 5u) + h ^ (ch as uint); }\n+fn hash_path(s: &str) -> uint {\n+    let h = 5381u;\n+    for ch: u8  in str::bytes(s) { h = (h << 5u) + h ^ (ch as uint); }\n     ret h;\n }\n "}, {"sha": "abbc887cd12e1db14c5fbb18b44220437d7d5740", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 142, "deletions": 158, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -29,260 +29,244 @@ export list_file_metadata;\n \n // Traverses an AST, reading all the information about use'd crates and native\n // libraries necessary for later resolving, typechecking, linking, etc.\n-fn read_crates(session::session sess,\n-               &ast::crate crate) {\n-    auto e =\n-        @rec(sess=sess,\n-             crate_cache=@std::map::new_str_hash[int](),\n-             library_search_paths=sess.get_opts().library_search_paths,\n-             mutable next_crate_num=1);\n-    auto v = visit::mk_simple_visitor\n-        (@rec(visit_view_item=bind visit_view_item(e, _),\n-              visit_item=bind visit_item(e, _)\n-              with *visit::default_simple_visitor()));\n+fn read_crates(sess: session::session, crate: &ast::crate) {\n+    let e =\n+        @{sess: sess,\n+          crate_cache: @std::map::new_str_hash[int](),\n+          library_search_paths: sess.get_opts().library_search_paths,\n+          mutable next_crate_num: 1};\n+    let v =\n+        visit::mk_simple_visitor(@{visit_view_item:\n+                                       bind visit_view_item(e, _),\n+                                   visit_item: bind visit_item(e, _)\n+                                      with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), v);\n }\n \n type env =\n-    @rec(session::session sess,\n-         @hashmap[str, int] crate_cache,\n-         str[] library_search_paths,\n-         mutable ast::crate_num next_crate_num);\n+    @{sess: session::session,\n+      crate_cache: @hashmap[str, int],\n+      library_search_paths: str[],\n+      mutable next_crate_num: ast::crate_num};\n \n-fn visit_view_item(env e, &@ast::view_item i) {\n-    alt (i.node) {\n-        case (ast::view_item_use(?ident, ?meta_items, ?id)) {\n-            auto cnum = resolve_crate(e, ident, meta_items, i.span);\n-            cstore::add_use_stmt_cnum(e.sess.get_cstore(), id, cnum);\n-        }\n-        case (_) { }\n+fn visit_view_item(e: env, i: &@ast::view_item) {\n+    alt i.node {\n+      ast::view_item_use(ident, meta_items, id) {\n+        let cnum = resolve_crate(e, ident, meta_items, i.span);\n+        cstore::add_use_stmt_cnum(e.sess.get_cstore(), id, cnum);\n+      }\n+      _ { }\n     }\n }\n \n-fn visit_item(env e, &@ast::item i) {\n-    alt (i.node) {\n-        case (ast::item_native_mod(?m)) {\n-            if (m.abi != ast::native_abi_rust &&\n-                m.abi != ast::native_abi_cdecl) {\n-                ret;\n-            }\n-            auto cstore = e.sess.get_cstore();\n-            if (!cstore::add_used_library(cstore, m.native_name)) {\n-                ret;\n-            }\n-            for (ast::attribute a in\n-                     attr::find_attrs_by_name(i.attrs, \"link_args\")) {\n-                alt (attr::get_meta_item_value_str(attr::attr_meta(a))) {\n-                    case (some(?linkarg)) {\n-                        cstore::add_used_link_args(cstore, linkarg);\n-                    }\n-                    case (none) { /* fallthrough */ }\n-                }\n-            }\n+fn visit_item(e: env, i: &@ast::item) {\n+    alt i.node {\n+      ast::item_native_mod(m) {\n+        if m.abi != ast::native_abi_rust && m.abi != ast::native_abi_cdecl {\n+            ret;\n         }\n-        case (_) {\n+        let cstore = e.sess.get_cstore();\n+        if !cstore::add_used_library(cstore, m.native_name) { ret; }\n+        for a: ast::attribute  in\n+            attr::find_attrs_by_name(i.attrs, \"link_args\") {\n+            alt attr::get_meta_item_value_str(attr::attr_meta(a)) {\n+              some(linkarg) { cstore::add_used_link_args(cstore, linkarg); }\n+              none. {/* fallthrough */ }\n+            }\n         }\n+      }\n+      _ { }\n     }\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-fn list_file_metadata(str path, ioivec::writer out) {\n-    alt (get_metadata_section(path)) {\n-        case (option::some(?bytes)) {\n-            decoder::list_crate_metadata(bytes, out);\n-        }\n-        case (option::none) {\n-            out.write_str(\"Could not find metadata in \" + path + \".\\n\");\n-        }\n+fn list_file_metadata(path: str, out: ioivec::writer) {\n+    alt get_metadata_section(path) {\n+      option::some(bytes) { decoder::list_crate_metadata(bytes, out); }\n+      option::none. {\n+        out.write_str(\"Could not find metadata in \" + path + \".\\n\");\n+      }\n     }\n }\n \n-fn metadata_matches(&@u8[] crate_data, &(@ast::meta_item)[] metas) -> bool {\n-    auto attrs = decoder::get_crate_attributes(crate_data);\n-    auto linkage_metas = attr::find_linkage_metas(attrs);\n+fn metadata_matches(crate_data: &@u8[], metas: &(@ast::meta_item)[]) -> bool {\n+    let attrs = decoder::get_crate_attributes(crate_data);\n+    let linkage_metas = attr::find_linkage_metas(attrs);\n \n     log #fmt(\"matching %u metadata requirements against %u items\",\n              ivec::len(metas), ivec::len(linkage_metas));\n \n-    for (@ast::meta_item needed in metas) {\n-        if (!attr::contains(linkage_metas, needed)) {\n+    for needed: @ast::meta_item  in metas {\n+        if !attr::contains(linkage_metas, needed) {\n             log #fmt(\"missing %s\", pprust::meta_item_to_str(*needed));\n             ret false;\n         }\n     }\n     ret true;\n }\n \n-fn default_native_lib_naming(session::session sess, bool static) ->\n-   rec(str prefix, str suffix) {\n-    if (static) {\n-        ret rec(prefix=\"lib\", suffix=\".rlib\");\n-    }\n-    alt (sess.get_targ_cfg().os) {\n-        case (session::os_win32) { ret rec(prefix=\"\", suffix=\".dll\"); }\n-        case (session::os_macos) { ret rec(prefix=\"lib\", suffix=\".dylib\"); }\n-        case (session::os_linux) { ret rec(prefix=\"lib\", suffix=\".so\"); }\n+fn default_native_lib_naming(sess: session::session, static: bool) ->\n+   {prefix: str, suffix: str} {\n+    if static { ret {prefix: \"lib\", suffix: \".rlib\"}; }\n+    alt sess.get_targ_cfg().os {\n+      session::os_win32. { ret {prefix: \"\", suffix: \".dll\"}; }\n+      session::os_macos. { ret {prefix: \"lib\", suffix: \".dylib\"}; }\n+      session::os_linux. { ret {prefix: \"lib\", suffix: \".so\"}; }\n     }\n }\n \n-fn find_library_crate(&session::session sess, &ast::ident ident,\n-                      &(@ast::meta_item)[] metas,\n-                      &str[] library_search_paths)\n-        -> option::t[rec(str ident, @u8[] data)] {\n+fn find_library_crate(sess: &session::session, ident: &ast::ident,\n+                      metas: &(@ast::meta_item)[],\n+                      library_search_paths: &str[]) ->\n+   option::t[{ident: str, data: @u8[]}] {\n \n     attr::require_unique_names(sess, metas);\n \n-    auto crate_name = {\n-        auto name_items = attr::find_meta_items_by_name(metas, \"name\");\n-        alt (ivec::last(name_items)) {\n-            case (some(?i)) {\n-                alt (attr::get_meta_item_value_str(i)) {\n-                    case (some(?n)) { n }\n-                    case (_) {\n-                        // FIXME: Probably want a warning here since the user\n-                        // is using the wrong type of meta item\n-                        ident\n-                    }\n+    let \n+        // FIXME: Probably want a warning here since the user\n+        // is using the wrong type of meta item\n+        crate_name =\n+        {\n+            let name_items = attr::find_meta_items_by_name(metas, \"name\");\n+            alt ivec::last(name_items) {\n+              some(i) {\n+                alt attr::get_meta_item_value_str(i) {\n+                  some(n) { n }\n+                  _ { ident }\n                 }\n+              }\n+              none. { ident }\n             }\n-            case (none) { ident }\n-        }\n-    };\n+        };\n \n-    auto nn = default_native_lib_naming(sess, sess.get_opts().static);\n-    auto x = find_library_crate_aux(nn, crate_name, metas,\n-                                    library_search_paths);\n-    if (x != none || sess.get_opts().static) {\n-        ret x;\n-    }\n-    auto nn2 = default_native_lib_naming(sess, true);\n+    let nn = default_native_lib_naming(sess, sess.get_opts().static);\n+    let x =\n+        find_library_crate_aux(nn, crate_name, metas, library_search_paths);\n+    if x != none || sess.get_opts().static { ret x; }\n+    let nn2 = default_native_lib_naming(sess, true);\n     ret find_library_crate_aux(nn2, crate_name, metas, library_search_paths);\n }\n \n-fn find_library_crate_aux(&rec(str prefix, str suffix) nn, str crate_name,\n-                          &(@ast::meta_item)[] metas,\n-                          &str[] library_search_paths)\n-    -> option::t[rec(str ident, @u8[] data)] {\n-    let str prefix = nn.prefix + crate_name;\n+fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: str,\n+                          metas: &(@ast::meta_item)[],\n+                          library_search_paths: &str[]) ->\n+   option::t[{ident: str, data: @u8[]}] {\n+    let prefix: str = nn.prefix + crate_name;\n     // FIXME: we could probably use a 'glob' function in std::fs but it will\n     // be much easier to write once the unsafe module knows more about FFI\n     // tricks. Currently the glob(3) interface is a bit more than we can\n     // stomach from here, and writing a C++ wrapper is more work than just\n     // manually filtering fs::list_dir here.\n \n-    for (str library_search_path in library_search_paths) {\n+    for library_search_path: str  in library_search_paths {\n         log #fmt(\"searching %s\", library_search_path);\n-        for (str path in fs::list_dir(library_search_path)) {\n+        for path: str  in fs::list_dir(library_search_path) {\n             log #fmt(\"searching %s\", path);\n-            let str f = fs::basename(path);\n-            if (!(str::starts_with(f, prefix) &&\n-                      str::ends_with(f, nn.suffix))) {\n+            let f: str = fs::basename(path);\n+            if !(str::starts_with(f, prefix) && str::ends_with(f, nn.suffix))\n+               {\n                 log #fmt(\"skipping %s, doesn't look like %s*%s\", path, prefix,\n                          nn.suffix);\n                 cont;\n             }\n-            alt (get_metadata_section(path)) {\n-                case (option::some(?cvec)) {\n-                    if (!metadata_matches(cvec, metas)) {\n-                        log #fmt(\"skipping %s, metadata doesn't match\", path);\n-                        cont;\n-                    }\n-                    log #fmt(\"found %s with matching metadata\", path);\n-                    ret some(rec(ident=path, data=cvec));\n+            alt get_metadata_section(path) {\n+              option::some(cvec) {\n+                if !metadata_matches(cvec, metas) {\n+                    log #fmt(\"skipping %s, metadata doesn't match\", path);\n+                    cont;\n                 }\n-                case (_) { }\n+                log #fmt(\"found %s with matching metadata\", path);\n+                ret some({ident: path, data: cvec});\n+              }\n+              _ { }\n             }\n         }\n     }\n     ret none;\n }\n \n-fn get_metadata_section(str filename) -> option::t[@u8[]] {\n-    auto b = str::buf(filename);\n-    auto mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n-    if (mb as int == 0) { ret option::none[@u8[]]; }\n-    auto of = mk_object_file(mb);\n-    auto si = mk_section_iter(of.llof);\n-    while (llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False) {\n-        auto name_buf = llvm::LLVMGetSectionName(si.llsi);\n-        auto name = str::str_from_cstr(name_buf);\n-        if (str::eq(name, x86::get_meta_sect_name())) {\n-            auto cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-            auto csz = llvm::LLVMGetSectionSize(si.llsi);\n-            let *u8 cvbuf = std::unsafe::reinterpret_cast(cbuf);\n+fn get_metadata_section(filename: str) -> option::t[@u8[]] {\n+    let b = str::buf(filename);\n+    let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n+    if mb as int == 0 { ret option::none[@u8[]]; }\n+    let of = mk_object_file(mb);\n+    let si = mk_section_iter(of.llof);\n+    while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n+        let name_buf = llvm::LLVMGetSectionName(si.llsi);\n+        let name = str::str_from_cstr(name_buf);\n+        if str::eq(name, x86::get_meta_sect_name()) {\n+            let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n+            let csz = llvm::LLVMGetSectionSize(si.llsi);\n+            let cvbuf: *u8 = std::unsafe::reinterpret_cast(cbuf);\n             ret option::some[@u8[]](@ivec::unsafe::from_buf(cvbuf, csz));\n         }\n         llvm::LLVMMoveToNextSection(si.llsi);\n     }\n     ret option::none[@u8[]];\n }\n \n-fn load_library_crate(&session::session sess, span span,\n-                      &ast::ident ident, &(@ast::meta_item)[] metas,\n-                      &str[] library_search_paths)\n-    -> rec(str ident, @u8[] data) {\n+fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n+                      metas: &(@ast::meta_item)[],\n+                      library_search_paths: &str[]) ->\n+   {ident: str, data: @u8[]} {\n \n-    alt (find_library_crate(sess, ident, metas, library_search_paths)) {\n-        case (some(?t)) {\n-            ret t;\n-        }\n-        case (none) {\n-            sess.span_fatal(span, #fmt(\"can't find crate for '%s'\", ident));\n-        }\n+\n+    alt find_library_crate(sess, ident, metas, library_search_paths) {\n+      some(t) { ret t; }\n+      none. {\n+        sess.span_fatal(span, #fmt(\"can't find crate for '%s'\", ident));\n+      }\n     }\n }\n \n-fn resolve_crate(env e, ast::ident ident, (@ast::meta_item)[] metas,\n-                 span span) -> ast::crate_num {\n-    if (!e.crate_cache.contains_key(ident)) {\n-        auto cinfo = load_library_crate(e.sess, span, ident, metas,\n-                                        e.library_search_paths);\n+fn resolve_crate(e: env, ident: ast::ident, metas: (@ast::meta_item)[],\n+                 span: span) -> ast::crate_num {\n+    if !e.crate_cache.contains_key(ident) {\n+        let cinfo =\n+            load_library_crate(e.sess, span, ident, metas,\n+                               e.library_search_paths);\n \n-        auto cfilename = cinfo.ident;\n-        auto cdata = cinfo.data;\n+        let cfilename = cinfo.ident;\n+        let cdata = cinfo.data;\n \n         // Claim this crate number and cache it\n-        auto cnum = e.next_crate_num;\n+        let cnum = e.next_crate_num;\n         e.crate_cache.insert(ident, cnum);\n         e.next_crate_num += 1;\n \n         // Now resolve the crates referenced by this crate\n-        auto cnum_map = resolve_crate_deps(e, cdata);\n+        let cnum_map = resolve_crate_deps(e, cdata);\n \n-        auto cmeta = rec(name=ident,\n-                         data=cdata,\n-                         cnum_map=cnum_map);\n+        let cmeta = {name: ident, data: cdata, cnum_map: cnum_map};\n \n-        auto cstore = e.sess.get_cstore();\n+        let cstore = e.sess.get_cstore();\n         cstore::set_crate_data(cstore, cnum, cmeta);\n         cstore::add_used_crate_file(cstore, cfilename);\n         ret cnum;\n-    } else {\n-        ret e.crate_cache.get(ident);\n-    }\n+    } else { ret e.crate_cache.get(ident); }\n }\n \n // Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(env e, &@u8[] cdata) -> cstore::cnum_map {\n+fn resolve_crate_deps(e: env, cdata: &@u8[]) -> cstore::cnum_map {\n     log \"resolving deps of external crate\";\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n-    auto cnum_map = new_int_hash[ast::crate_num]();\n-    for (decoder::crate_dep dep in decoder::get_crate_deps(cdata)) {\n-        auto extrn_cnum = dep.cnum;\n-        auto cname = dep.ident;\n+    let cnum_map = new_int_hash[ast::crate_num]();\n+    for dep: decoder::crate_dep  in decoder::get_crate_deps(cdata) {\n+        let extrn_cnum = dep.cnum;\n+        let cname = dep.ident;\n         log #fmt(\"resolving dep %s\", cname);\n-        if (e.crate_cache.contains_key(cname)) {\n+        if e.crate_cache.contains_key(cname) {\n             log \"already have it\";\n             // We've already seen this crate\n-            auto local_cnum = e.crate_cache.get(cname);\n+            let local_cnum = e.crate_cache.get(cname);\n             cnum_map.insert(extrn_cnum, local_cnum);\n         } else {\n             log \"need to load it\";\n             // This is a new one so we've got to load it\n             // FIXME: Need better error reporting than just a bogus span\n-            auto fake_span = rec(lo=0u,hi=0u);\n-            auto local_cnum = resolve_crate(e, cname, ~[], fake_span);\n+            let fake_span = {lo: 0u, hi: 0u};\n+            let local_cnum = resolve_crate(e, cname, ~[], fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n         }\n     }"}, {"sha": "a6086704183cf8d1a5da05a9795c1b2468f2e32e", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -11,35 +11,35 @@ export lookup_defs;\n export get_tag_variants;\n export get_type;\n \n-fn get_symbol(&cstore::cstore cstore, ast::def_id def) -> str {\n-    auto cdata = cstore::get_crate_data(cstore, def.crate).data;\n+fn get_symbol(cstore: &cstore::cstore, def: ast::def_id) -> str {\n+    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     ret decoder::get_symbol(cdata, def.node);\n }\n \n-fn get_type_param_count(&cstore::cstore cstore, &ast::def_id def) -> uint {\n-    auto cdata = cstore::get_crate_data(cstore, def.crate).data;\n+fn get_type_param_count(cstore: &cstore::cstore, def: &ast::def_id) -> uint {\n+    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     ret decoder::get_type_param_count(cdata, def.node);\n }\n \n-fn lookup_defs(&cstore::cstore cstore, ast::crate_num cnum,\n-               &ast::ident[] path) -> ast::def[] {\n-    auto cdata = cstore::get_crate_data(cstore, cnum).data;\n+fn lookup_defs(cstore: &cstore::cstore, cnum: ast::crate_num,\n+               path: &ast::ident[]) -> ast::def[] {\n+    let cdata = cstore::get_crate_data(cstore, cnum).data;\n     ret decoder::lookup_defs(cdata, cnum, path);\n }\n \n-fn get_tag_variants(ty::ctxt tcx, ast::def_id def) -> ty::variant_info[] {\n-    auto cstore = tcx.sess.get_cstore();\n-    auto cnum = def.crate;\n-    auto cdata = cstore::get_crate_data(cstore, cnum).data;\n-    auto resolver = bind translate_def_id(tcx.sess, cnum, _);\n+fn get_tag_variants(tcx: ty::ctxt, def: ast::def_id) -> ty::variant_info[] {\n+    let cstore = tcx.sess.get_cstore();\n+    let cnum = def.crate;\n+    let cdata = cstore::get_crate_data(cstore, cnum).data;\n+    let resolver = bind translate_def_id(tcx.sess, cnum, _);\n     ret decoder::get_tag_variants(cdata, def, tcx, resolver)\n }\n \n-fn get_type(ty::ctxt tcx, ast::def_id def) -> ty::ty_param_count_and_ty {\n-    auto cstore = tcx.sess.get_cstore();\n-    auto cnum = def.crate;\n-    auto cdata = cstore::get_crate_data(cstore, cnum).data;\n-    auto resolver = bind translate_def_id(tcx.sess, cnum, _);\n+fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_count_and_ty {\n+    let cstore = tcx.sess.get_cstore();\n+    let cnum = def.crate;\n+    let cdata = cstore::get_crate_data(cstore, cnum).data;\n+    let resolver = bind translate_def_id(tcx.sess, cnum, _);\n     decoder::get_type(cdata, def, tcx, resolver)\n }\n \n@@ -48,27 +48,25 @@ fn get_type(ty::ctxt tcx, ast::def_id def) -> ty::ty_param_count_and_ty {\n // external crates - if those types further refer to types in other crates\n // then we must translate the crate number from that encoded in the external\n // crate to the correct local crate number.\n-fn translate_def_id(&session::session sess,\n-                    ast::crate_num searched_crate,\n-                    &ast::def_id def_id) -> ast::def_id {\n+fn translate_def_id(sess: &session::session, searched_crate: ast::crate_num,\n+                    def_id: &ast::def_id) -> ast::def_id {\n \n-    auto ext_cnum = def_id.crate;\n-    auto node_id = def_id.node;\n+    let ext_cnum = def_id.crate;\n+    let node_id = def_id.node;\n \n-    assert searched_crate != ast::local_crate;\n-    assert ext_cnum != ast::local_crate;\n+    assert (searched_crate != ast::local_crate);\n+    assert (ext_cnum != ast::local_crate);\n \n-    auto cstore = sess.get_cstore();\n-    auto cmeta = cstore::get_crate_data(cstore, searched_crate);\n+    let cstore = sess.get_cstore();\n+    let cmeta = cstore::get_crate_data(cstore, searched_crate);\n \n-    auto local_cnum = alt (cmeta.cnum_map.find(ext_cnum)) {\n-        case (option::some(?n)) { n }\n-        case (option::none) {\n-            sess.bug(\"didn't find a crate in the cnum_map\")\n-        }\n-    };\n+    let local_cnum =\n+        alt cmeta.cnum_map.find(ext_cnum) {\n+          option::some(n) { n }\n+          option::none. { sess.bug(\"didn't find a crate in the cnum_map\") }\n+        };\n \n-    ret rec(crate=local_cnum, node=node_id);\n+    ret {crate: local_cnum, node: node_id};\n }\n \n // Local Variables:"}, {"sha": "1b1249b8f9bd43da42aa773239b0d7cbc7908545", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -29,106 +29,102 @@ export get_use_stmt_cnum;\n // own crate numbers.\n type cnum_map = map::hashmap[ast::crate_num, ast::crate_num];\n \n-type crate_metadata = rec(str name, @u8[] data, cnum_map cnum_map);\n+type crate_metadata = {name: str, data: @u8[], cnum_map: cnum_map};\n \n // This is a bit of an experiment at encapsulating the data in cstore. By\n // keeping all the data in a non-exported tag variant, it's impossible for\n // other modules to access the cstore's private data. This could also be\n // achieved with an obj, but at the expense of a vtable. Not sure if this is a\n // good pattern or not.\n-tag cstore {\n-    private(cstore_private);\n-}\n+tag cstore { private(cstore_private); }\n \n-type cstore_private = @rec(map::hashmap[ast::crate_num, crate_metadata] metas,\n-                           use_crate_map use_crate_map,\n-                           mutable str[] used_crate_files,\n-                           mutable str[] used_libraries,\n-                           mutable str[] used_link_args);\n+type cstore_private =\n+    @{metas: map::hashmap[ast::crate_num, crate_metadata],\n+      use_crate_map: use_crate_map,\n+      mutable used_crate_files: str[],\n+      mutable used_libraries: str[],\n+      mutable used_link_args: str[]};\n \n // Map from node_id's of local use statements to crate numbers\n type use_crate_map = map::hashmap[ast::node_id, ast::crate_num];\n \n // Internal method to retrieve the data from the cstore\n-fn p(&cstore cstore) -> cstore_private {\n-    alt (cstore) {\n-        case (private(?p)) { p }\n-    }\n-}\n+fn p(cstore: &cstore) -> cstore_private { alt cstore { private(p) { p } } }\n \n fn mk_cstore() -> cstore {\n-    auto meta_cache = map::new_int_hash[crate_metadata]();\n-    auto crate_map = map::new_int_hash[ast::crate_num]();\n-    ret private(@rec(metas = meta_cache,\n-                     use_crate_map = crate_map,\n-                     mutable used_crate_files = ~[],\n-                     mutable used_libraries = ~[],\n-                     mutable used_link_args = ~[]));\n+    let meta_cache = map::new_int_hash[crate_metadata]();\n+    let crate_map = map::new_int_hash[ast::crate_num]();\n+    ret private(@{metas: meta_cache,\n+                  use_crate_map: crate_map,\n+                  mutable used_crate_files: ~[],\n+                  mutable used_libraries: ~[],\n+                  mutable used_link_args: ~[]});\n }\n \n-fn get_crate_data(&cstore cstore, ast::crate_num cnum) -> crate_metadata {\n+fn get_crate_data(cstore: &cstore, cnum: ast::crate_num) -> crate_metadata {\n     ret p(cstore).metas.get(cnum);\n }\n \n-fn set_crate_data(&cstore cstore, ast::crate_num cnum, &crate_metadata data) {\n+fn set_crate_data(cstore: &cstore, cnum: ast::crate_num,\n+                  data: &crate_metadata) {\n     p(cstore).metas.insert(cnum, data);\n }\n \n-fn have_crate_data(&cstore cstore, ast::crate_num cnum) -> bool {\n+fn have_crate_data(cstore: &cstore, cnum: ast::crate_num) -> bool {\n     ret p(cstore).metas.contains_key(cnum);\n }\n \n-iter iter_crate_data(&cstore cstore)\n-    -> @rec(ast::crate_num key, crate_metadata val) {\n-    for each (@rec(ast::crate_num key, crate_metadata val) kv\n-              in p(cstore).metas.items()) {\n+iter iter_crate_data(cstore: &cstore) ->\n+     @{key: ast::crate_num, val: crate_metadata} {\n+    for each kv: @{key: ast::crate_num, val: crate_metadata}  in\n+             p(cstore).metas.items() {\n         put kv;\n     }\n }\n \n-fn add_used_crate_file(&cstore cstore, &str lib) {\n-    if (!ivec::member(lib, p(cstore).used_crate_files)) {\n+fn add_used_crate_file(cstore: &cstore, lib: &str) {\n+    if !ivec::member(lib, p(cstore).used_crate_files) {\n         p(cstore).used_crate_files += ~[lib];\n     }\n }\n \n-fn get_used_crate_files(&cstore cstore) -> str[] {\n+fn get_used_crate_files(cstore: &cstore) -> str[] {\n     ret p(cstore).used_crate_files;\n }\n \n-fn add_used_library(&cstore cstore, &str lib) -> bool {\n-    if (lib == \"\") { ret false; }\n+fn add_used_library(cstore: &cstore, lib: &str) -> bool {\n+    if lib == \"\" { ret false; }\n \n-    if (ivec::member(lib, p(cstore).used_libraries)) {\n-        ret false;\n-    }\n+    if ivec::member(lib, p(cstore).used_libraries) { ret false; }\n \n     p(cstore).used_libraries += ~[lib];\n     ret true;\n }\n \n-fn get_used_libraries(&cstore cstore) -> str[] {\n+fn get_used_libraries(cstore: &cstore) -> str[] {\n     ret p(cstore).used_libraries;\n }\n \n-fn add_used_link_args(&cstore cstore, &str args) {\n-    auto used_link_args_vec = str::split(args, ' ' as u8);\n+fn add_used_link_args(cstore: &cstore, args: &str) {\n+    let used_link_args_vec = str::split(args, ' ' as u8);\n+\n     // TODO: Remove this vec->ivec conversion.\n-    for (str ula in used_link_args_vec) {\n+    for ula: str  in used_link_args_vec {\n         p(cstore).used_link_args += ~[ula];\n     }\n }\n \n-fn get_used_link_args(&cstore cstore) -> str[] {\n+fn get_used_link_args(cstore: &cstore) -> str[] {\n     ret p(cstore).used_link_args;\n }\n \n-fn add_use_stmt_cnum(&cstore cstore, ast::node_id use_id,\n-                     ast::crate_num cnum) {\n+fn add_use_stmt_cnum(cstore: &cstore, use_id: ast::node_id,\n+                     cnum: ast::crate_num) {\n     p(cstore).use_crate_map.insert(use_id, cnum);\n }\n \n-fn get_use_stmt_cnum(&cstore cstore, ast::node_id use_id) -> ast::crate_num {\n+fn get_use_stmt_cnum(cstore: &cstore, use_id: ast::node_id) ->\n+   ast::crate_num {\n     ret p(cstore).use_crate_map.get(use_id);\n }\n "}, {"sha": "d7d82c1fa36f1d6f4230402c086c40a541f89e12", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 220, "deletions": 222, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -32,373 +32,371 @@ export external_resolver;\n // def_id for an item defined in another crate, somebody needs to figure out\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n-type external_resolver = fn(&ast::def_id def_id) -> ast::def_id;\n-\n-fn lookup_hash(&ebmlivec::doc d, fn(&u8[]) -> bool  eq_fn, uint hash) ->\n-   (ebmlivec::doc)[] {\n-    auto index = ebmlivec::get_doc(d, tag_index);\n-    auto table = ebmlivec::get_doc(index, tag_index_table);\n-    auto hash_pos = table.start + hash % 256u * 4u;\n-    auto pos = ebmlivec::be_uint_from_bytes(d.data, hash_pos, 4u);\n-    auto bucket = ebmlivec::doc_at(d.data, pos);\n+type external_resolver = fn(&ast::def_id) -> ast::def_id ;\n+\n+fn lookup_hash(d: &ebmlivec::doc, eq_fn: fn(&u8[]) -> bool , hash: uint) ->\n+   ebmlivec::doc[] {\n+    let index = ebmlivec::get_doc(d, tag_index);\n+    let table = ebmlivec::get_doc(index, tag_index_table);\n+    let hash_pos = table.start + hash % 256u * 4u;\n+    let pos = ebmlivec::be_uint_from_bytes(d.data, hash_pos, 4u);\n+    let bucket = ebmlivec::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n \n-    let (ebmlivec::doc)[] result = ~[];\n-    auto belt = tag_index_buckets_bucket_elt;\n-    for each (ebmlivec::doc elt in ebmlivec::tagged_docs(bucket, belt)) {\n-        auto pos = ebmlivec::be_uint_from_bytes(elt.data, elt.start, 4u);\n-        if (eq_fn(ivec::slice[u8](*elt.data, elt.start + 4u, elt.end))) {\n+    let result: ebmlivec::doc[] = ~[];\n+    let belt = tag_index_buckets_bucket_elt;\n+    for each elt: ebmlivec::doc  in ebmlivec::tagged_docs(bucket, belt) {\n+        let pos = ebmlivec::be_uint_from_bytes(elt.data, elt.start, 4u);\n+        if eq_fn(ivec::slice[u8](*elt.data, elt.start + 4u, elt.end)) {\n             result += ~[ebmlivec::doc_at(d.data, pos)];\n         }\n     }\n     ret result;\n }\n \n-fn maybe_find_item(int item_id, &ebmlivec::doc items)\n-    -> option::t[ebmlivec::doc] {\n-    fn eq_item(&u8[] bytes, int item_id) -> bool {\n+fn maybe_find_item(item_id: int, items: &ebmlivec::doc) ->\n+   option::t[ebmlivec::doc] {\n+    fn eq_item(bytes: &u8[], item_id: int) -> bool {\n         ret ebmlivec::be_uint_from_bytes(@bytes, 0u, 4u) as int == item_id;\n     }\n-    auto eqer = bind eq_item(_, item_id);\n-    auto found = lookup_hash(items, eqer, hash_node_id(item_id));\n-    if (ivec::len(found) == 0u) {\n+    let eqer = bind eq_item(_, item_id);\n+    let found = lookup_hash(items, eqer, hash_node_id(item_id));\n+    if ivec::len(found) == 0u {\n         ret option::none[ebmlivec::doc];\n     } else { ret option::some[ebmlivec::doc](found.(0)); }\n }\n \n-fn find_item(int item_id, &ebmlivec::doc items) -> ebmlivec::doc {\n+fn find_item(item_id: int, items: &ebmlivec::doc) -> ebmlivec::doc {\n     ret option::get(maybe_find_item(item_id, items));\n }\n \n // Looks up an item in the given metadata and returns an ebmlivec doc pointing\n // to the item data.\n-fn lookup_item(int item_id, &@u8[] data) -> ebmlivec::doc {\n-    auto items = ebmlivec::get_doc(ebmlivec::new_doc(data), tag_items);\n+fn lookup_item(item_id: int, data: &@u8[]) -> ebmlivec::doc {\n+    let items = ebmlivec::get_doc(ebmlivec::new_doc(data), tag_items);\n     ret find_item(item_id, items);\n }\n \n-fn item_kind(&ebmlivec::doc item) -> u8 {\n-    auto kind = ebmlivec::get_doc(item, tag_items_data_item_kind);\n+fn item_kind(item: &ebmlivec::doc) -> u8 {\n+    let kind = ebmlivec::get_doc(item, tag_items_data_item_kind);\n     ret ebmlivec::doc_as_uint(kind) as u8;\n }\n \n-fn item_symbol(&ebmlivec::doc item) -> str {\n-    auto sym = ebmlivec::get_doc(item, tag_items_data_item_symbol);\n+fn item_symbol(item: &ebmlivec::doc) -> str {\n+    let sym = ebmlivec::get_doc(item, tag_items_data_item_symbol);\n     ret str::unsafe_from_bytes_ivec(ebmlivec::doc_data(sym));\n }\n \n-fn variant_tag_id(&ebmlivec::doc d) -> ast::def_id {\n-    auto tagdoc = ebmlivec::get_doc(d, tag_items_data_item_tag_id);\n+fn variant_tag_id(d: &ebmlivec::doc) -> ast::def_id {\n+    let tagdoc = ebmlivec::get_doc(d, tag_items_data_item_tag_id);\n     ret parse_def_id(ebmlivec::doc_data(tagdoc));\n }\n \n-fn item_type(&ebmlivec::doc item, ast::crate_num this_cnum,\n-             ty::ctxt tcx, &external_resolver extres) -> ty::t {\n-    fn parse_external_def_id(ast::crate_num this_cnum,\n-                             &external_resolver extres,\n-                             str s) -> ast::def_id {\n-        auto buf = str::bytes_ivec(s);\n-        auto external_def_id = parse_def_id(buf);\n+fn item_type(item: &ebmlivec::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n+             extres: &external_resolver) -> ty::t {\n+    fn parse_external_def_id(this_cnum: ast::crate_num,\n+                             extres: &external_resolver, s: str) ->\n+       ast::def_id {\n+        let buf = str::bytes_ivec(s);\n+        let external_def_id = parse_def_id(buf);\n+\n \n         // This item was defined in the crate we're searching if it's has the\n         // local crate number, otherwise we need to search a different crate\n-        if (external_def_id.crate == ast::local_crate) {\n-            ret rec(crate=this_cnum, node=external_def_id.node);\n-        } else {\n-            ret extres(external_def_id);\n-        }\n+        if external_def_id.crate == ast::local_crate {\n+            ret {crate: this_cnum, node: external_def_id.node};\n+        } else { ret extres(external_def_id); }\n     }\n-    auto tp = ebmlivec::get_doc(item, tag_items_data_item_type);\n-    auto def_parser = bind parse_external_def_id(this_cnum, extres, _);\n+    let tp = ebmlivec::get_doc(item, tag_items_data_item_type);\n+    let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n     ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n                       def_parser, tcx);\n }\n \n-fn item_ty_param_count(&ebmlivec::doc item) -> uint {\n-    let uint ty_param_count = 0u;\n-    auto tp = tag_items_data_item_ty_param_count;\n-    for each (ebmlivec::doc p in ebmlivec::tagged_docs(item, tp)) {\n+fn item_ty_param_count(item: &ebmlivec::doc) -> uint {\n+    let ty_param_count: uint = 0u;\n+    let tp = tag_items_data_item_ty_param_count;\n+    for each p: ebmlivec::doc  in ebmlivec::tagged_docs(item, tp) {\n         ty_param_count = ebmlivec::vint_at(ebmlivec::doc_data(p), 0u).val;\n     }\n     ret ty_param_count;\n }\n \n-fn tag_variant_ids(&ebmlivec::doc item,\n-                   ast::crate_num this_cnum) -> ast::def_id[] {\n-    let ast::def_id[] ids = ~[];\n-    auto v = tag_items_data_item_variant;\n-    for each (ebmlivec::doc p in ebmlivec::tagged_docs(item, v)) {\n-        auto ext = parse_def_id(ebmlivec::doc_data(p));\n-        ids += ~[rec(crate=this_cnum, node=ext.node)];\n+fn tag_variant_ids(item: &ebmlivec::doc, this_cnum: ast::crate_num) ->\n+   ast::def_id[] {\n+    let ids: ast::def_id[] = ~[];\n+    let v = tag_items_data_item_variant;\n+    for each p: ebmlivec::doc  in ebmlivec::tagged_docs(item, v) {\n+        let ext = parse_def_id(ebmlivec::doc_data(p));\n+        ids += ~[{crate: this_cnum, node: ext.node}];\n     }\n     ret ids;\n }\n \n // Given a path and serialized crate metadata, returns the ID of the\n // definition the path refers to.\n-fn resolve_path(&ast::ident[] path, @u8[] data) -> ast::def_id[] {\n-    fn eq_item(&u8[] data, str s) -> bool {\n+fn resolve_path(path: &ast::ident[], data: @u8[]) -> ast::def_id[] {\n+    fn eq_item(data: &u8[], s: str) -> bool {\n         ret str::eq(str::unsafe_from_bytes_ivec(data), s);\n     }\n-    auto s = str::connect_ivec(path, \"::\");\n-    auto md = ebmlivec::new_doc(data);\n-    auto paths = ebmlivec::get_doc(md, tag_paths);\n-    auto eqer = bind eq_item(_, s);\n-    let ast::def_id[] result = ~[];\n-    for (ebmlivec::doc doc in lookup_hash(paths, eqer, hash_path(s))) {\n-        auto did_doc = ebmlivec::get_doc(doc, tag_def_id);\n+    let s = str::connect_ivec(path, \"::\");\n+    let md = ebmlivec::new_doc(data);\n+    let paths = ebmlivec::get_doc(md, tag_paths);\n+    let eqer = bind eq_item(_, s);\n+    let result: ast::def_id[] = ~[];\n+    for doc: ebmlivec::doc  in lookup_hash(paths, eqer, hash_path(s)) {\n+        let did_doc = ebmlivec::get_doc(doc, tag_def_id);\n         result += ~[parse_def_id(ebmlivec::doc_data(did_doc))];\n     }\n     ret result;\n }\n \n // Crate metadata queries\n-fn lookup_defs(&@u8[] data, ast::crate_num cnum, &ast::ident[] path)\n-        -> ast::def[] {\n+fn lookup_defs(data: &@u8[], cnum: ast::crate_num, path: &ast::ident[]) ->\n+   ast::def[] {\n     ret ivec::map(bind lookup_def(cnum, data, _), resolve_path(path, data));\n }\n \n \n // FIXME doesn't yet handle re-exported externals\n-fn lookup_def(ast::crate_num cnum, @u8[] data, &ast::def_id did_)\n-        -> ast::def {\n-    auto item = lookup_item(did_.node, data);\n-    auto kind_ch = item_kind(item);\n-    auto did = rec(crate=cnum, node=did_.node);\n-    auto def =\n-        alt (kind_ch as char) {\n-            case ('c') { ast::def_const(did) }\n-            case ('f') { ast::def_fn(did, ast::impure_fn) }\n-            case ('p') { ast::def_fn(did, ast::pure_fn) }\n-            case ('F') { ast::def_native_fn(did) }\n-            case ('y') { ast::def_ty(did) }\n-            case ('T') { ast::def_native_ty(did) }\n-            // We treat references to tags as references to types.\n-            case ('t') { ast::def_ty(did) }\n-            case ('m') { ast::def_mod(did) }\n-            case ('n') { ast::def_native_mod(did) }\n-            case ('v') {\n-                auto tid = variant_tag_id(item);\n-                tid = rec(crate=cnum, node=tid.node);\n-                ast::def_variant(tid, did)\n-            }\n+fn lookup_def(cnum: ast::crate_num, data: @u8[], did_: &ast::def_id) ->\n+   ast::def {\n+    let item = lookup_item(did_.node, data);\n+    let kind_ch = item_kind(item);\n+    let did = {crate: cnum, node: did_.node};\n+    let \n+        // We treat references to tags as references to types.\n+        def =\n+        alt kind_ch as char {\n+          'c' { ast::def_const(did) }\n+          'f' { ast::def_fn(did, ast::impure_fn) }\n+          'p' { ast::def_fn(did, ast::pure_fn) }\n+          'F' { ast::def_native_fn(did) }\n+          'y' { ast::def_ty(did) }\n+          'T' { ast::def_native_ty(did) }\n+          't' { ast::def_ty(did) }\n+          'm' { ast::def_mod(did) }\n+          'n' { ast::def_native_mod(did) }\n+          'v' {\n+            let tid = variant_tag_id(item);\n+            tid = {crate: cnum, node: tid.node};\n+            ast::def_variant(tid, did)\n+          }\n         };\n     ret def;\n }\n \n-fn get_type(@u8[] data, ast::def_id def, &ty::ctxt tcx,\n-            &external_resolver extres) -> ty::ty_param_count_and_ty {\n-    auto this_cnum = def.crate;\n-    auto node_id = def.node;\n-    auto item = lookup_item(node_id, data);\n-    auto t = item_type(item, this_cnum, tcx, extres);\n-    auto tp_count;\n-    auto kind_ch = item_kind(item);\n-    auto has_ty_params = kind_has_type_params(kind_ch);\n-    if (has_ty_params) {\n+fn get_type(data: @u8[], def: ast::def_id, tcx: &ty::ctxt,\n+            extres: &external_resolver) -> ty::ty_param_count_and_ty {\n+    let this_cnum = def.crate;\n+    let node_id = def.node;\n+    let item = lookup_item(node_id, data);\n+    let t = item_type(item, this_cnum, tcx, extres);\n+    let tp_count;\n+    let kind_ch = item_kind(item);\n+    let has_ty_params = kind_has_type_params(kind_ch);\n+    if has_ty_params {\n         tp_count = item_ty_param_count(item);\n     } else { tp_count = 0u; }\n-    ret rec(count=tp_count, ty=t);\n+    ret {count: tp_count, ty: t};\n }\n \n-fn get_type_param_count(@u8[] data, ast::node_id id) -> uint {\n+fn get_type_param_count(data: @u8[], id: ast::node_id) -> uint {\n     ret item_ty_param_count(lookup_item(id, data));\n }\n \n-fn get_symbol(@u8[] data, ast::node_id id) -> str {\n+fn get_symbol(data: @u8[], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n \n-fn get_tag_variants(&@u8[] data, ast::def_id def,\n-                    &ty::ctxt tcx,\n-                    &external_resolver extres) -> ty::variant_info[] {\n-    auto external_crate_id = def.crate;\n-    auto data = cstore::get_crate_data(tcx.sess.get_cstore(),\n-                                       external_crate_id).data;\n-    auto items = ebmlivec::get_doc(ebmlivec::new_doc(data), tag_items);\n-    auto item = find_item(def.node, items);\n-    let ty::variant_info[] infos = ~[];\n-    auto variant_ids = tag_variant_ids(item, external_crate_id);\n-    for (ast::def_id did in variant_ids) {\n-        auto item = find_item(did.node, items);\n-        auto ctor_ty = item_type(item, external_crate_id, tcx, extres);\n-        let ty::t[] arg_tys = ~[];\n-        alt (ty::struct(tcx, ctor_ty)) {\n-            case (ty::ty_fn(_, ?args, _, _, _)) {\n-                for (ty::arg a in args) { arg_tys += ~[a.ty]; }\n-            }\n-            case (_) {\n-                // Nullary tag variant.\n-\n-            }\n+fn get_tag_variants(data: &@u8[], def: ast::def_id, tcx: &ty::ctxt,\n+                    extres: &external_resolver) -> ty::variant_info[] {\n+    let external_crate_id = def.crate;\n+    let data =\n+        cstore::get_crate_data(tcx.sess.get_cstore(), external_crate_id).data;\n+    let items = ebmlivec::get_doc(ebmlivec::new_doc(data), tag_items);\n+    let item = find_item(def.node, items);\n+    let infos: ty::variant_info[] = ~[];\n+    let variant_ids = tag_variant_ids(item, external_crate_id);\n+    for did: ast::def_id  in variant_ids {\n+        let item = find_item(did.node, items);\n+        let ctor_ty = item_type(item, external_crate_id, tcx, extres);\n+        let arg_tys: ty::t[] = ~[];\n+        alt ty::struct(tcx, ctor_ty) {\n+          ty::ty_fn(_, args, _, _, _) {\n+            for a: ty::arg  in args { arg_tys += ~[a.ty]; }\n+          }\n+          _ {\n+            // Nullary tag variant.\n+\n+          }\n         }\n-        infos += ~[rec(args=arg_tys, ctor_ty=ctor_ty, id=did)];\n+        infos += ~[{args: arg_tys, ctor_ty: ctor_ty, id: did}];\n     }\n     ret infos;\n }\n \n-fn kind_has_type_params(u8 kind_ch) -> bool {\n-    ret alt (kind_ch as char) {\n-            case ('c') { false }\n-            case ('f') { true }\n-            case ('p') { true }\n-            case ('F') { true }\n-            case ('y') { true }\n-            case ('t') { true }\n-            case ('T') { false }\n-            case ('m') { false }\n-            case ('n') { false }\n-            case ('v') { true }\n+fn kind_has_type_params(kind_ch: u8) -> bool {\n+    ret alt kind_ch as char {\n+          'c' { false }\n+          'f' { true }\n+          'p' { true }\n+          'F' { true }\n+          'y' { true }\n+          't' { true }\n+          'T' { false }\n+          'm' { false }\n+          'n' { false }\n+          'v' { true }\n         };\n }\n \n-fn read_path(&ebmlivec::doc d) -> rec(str path, uint pos) {\n-    auto desc = ebmlivec::doc_data(d);\n-    auto pos = ebmlivec::be_uint_from_bytes(@desc, 0u, 4u);\n-    auto pathbytes = ivec::slice[u8](desc, 4u, ivec::len[u8](desc));\n-    auto path = str::unsafe_from_bytes_ivec(pathbytes);\n-    ret rec(path=path, pos=pos);\n+fn read_path(d: &ebmlivec::doc) -> {path: str, pos: uint} {\n+    let desc = ebmlivec::doc_data(d);\n+    let pos = ebmlivec::be_uint_from_bytes(@desc, 0u, 4u);\n+    let pathbytes = ivec::slice[u8](desc, 4u, ivec::len[u8](desc));\n+    let path = str::unsafe_from_bytes_ivec(pathbytes);\n+    ret {path: path, pos: pos};\n }\n \n-fn describe_def(&ebmlivec::doc items, ast::def_id id) -> str {\n-    if (id.crate != ast::local_crate) { ret \"external\"; }\n+fn describe_def(items: &ebmlivec::doc, id: ast::def_id) -> str {\n+    if id.crate != ast::local_crate { ret \"external\"; }\n     ret item_kind_to_str(item_kind(find_item(id.node, items)));\n }\n \n-fn item_kind_to_str(u8 kind) -> str {\n-    alt (kind as char) {\n-        case ('c') { ret \"const\"; }\n-        case ('f') { ret \"fn\"; }\n-        case ('p') { ret \"pred\"; }\n-        case ('F') { ret \"native fn\"; }\n-        case ('y') { ret \"type\"; }\n-        case ('T') { ret \"native type\"; }\n-        case ('t') { ret \"type\"; }\n-        case ('m') { ret \"mod\"; }\n-        case ('n') { ret \"native mod\"; }\n-        case ('v') { ret \"tag\"; }\n+fn item_kind_to_str(kind: u8) -> str {\n+    alt kind as char {\n+      'c' { ret \"const\"; }\n+      'f' { ret \"fn\"; }\n+      'p' { ret \"pred\"; }\n+      'F' { ret \"native fn\"; }\n+      'y' { ret \"type\"; }\n+      'T' { ret \"native type\"; }\n+      't' { ret \"type\"; }\n+      'm' { ret \"mod\"; }\n+      'n' { ret \"native mod\"; }\n+      'v' { ret \"tag\"; }\n     }\n }\n \n-fn get_meta_items(&ebmlivec::doc md) -> (@ast::meta_item)[] {\n-    let (@ast::meta_item)[] items = ~[];\n-    for each (ebmlivec::doc meta_item_doc in\n-              ebmlivec::tagged_docs(md, tag_meta_item_word)) {\n-        auto nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n-        auto n = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(nd));\n+fn get_meta_items(md: &ebmlivec::doc) -> (@ast::meta_item)[] {\n+    let items: (@ast::meta_item)[] = ~[];\n+    for each meta_item_doc: ebmlivec::doc  in\n+             ebmlivec::tagged_docs(md, tag_meta_item_word) {\n+        let nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(nd));\n         items += ~[attr::mk_word_item(n)];\n     }\n-    for each (ebmlivec::doc meta_item_doc in\n-              ebmlivec::tagged_docs(md, tag_meta_item_name_value)) {\n-        auto nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n-        auto vd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_value);\n-        auto n = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(nd));\n-        auto v = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(vd));\n+    for each meta_item_doc: ebmlivec::doc  in\n+             ebmlivec::tagged_docs(md, tag_meta_item_name_value) {\n+        let nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n+        let vd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_value);\n+        let n = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(nd));\n+        let v = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(vd));\n         // FIXME (#611): Should be able to decode meta_name_value variants,\n         // but currently they can't be encoded\n         items += ~[attr::mk_name_value_item_str(n, v)];\n     }\n-    for each (ebmlivec::doc meta_item_doc in\n-              ebmlivec::tagged_docs(md, tag_meta_item_list)) {\n-        auto nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n-        auto n = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(nd));\n-        auto subitems = get_meta_items(meta_item_doc);\n+    for each meta_item_doc: ebmlivec::doc  in\n+             ebmlivec::tagged_docs(md, tag_meta_item_list) {\n+        let nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(nd));\n+        let subitems = get_meta_items(meta_item_doc);\n         items += ~[attr::mk_list_item(n, subitems)];\n     }\n     ret items;\n }\n \n-fn get_attributes(&ebmlivec::doc md) -> ast::attribute[] {\n-    let ast::attribute[] attrs = ~[];\n-    alt (ebmlivec::maybe_get_doc(md, tag_attributes)) {\n-        case (option::some(?attrs_d)) {\n-            for each (ebmlivec::doc attr_doc in\n-                      ebmlivec::tagged_docs(attrs_d, tag_attribute)) {\n-                auto meta_items = get_meta_items(attr_doc);\n-                // Currently it's only possible to have a single meta item on\n-                // an attribute\n-                assert (ivec::len(meta_items) == 1u);\n-                auto meta_item = meta_items.(0);\n-                attrs += ~[rec(node=rec(style=ast::attr_outer,\n-                                        value=*meta_item),\n-                               span=rec(lo=0u, hi=0u))];\n-            }\n+fn get_attributes(md: &ebmlivec::doc) -> ast::attribute[] {\n+    let attrs: ast::attribute[] = ~[];\n+    alt ebmlivec::maybe_get_doc(md, tag_attributes) {\n+      option::some(attrs_d) {\n+        for each attr_doc: ebmlivec::doc  in\n+                 ebmlivec::tagged_docs(attrs_d, tag_attribute) {\n+            let meta_items = get_meta_items(attr_doc);\n+            // Currently it's only possible to have a single meta item on\n+            // an attribute\n+            assert (ivec::len(meta_items) == 1u);\n+            let meta_item = meta_items.(0);\n+            attrs +=\n+                ~[{node: {style: ast::attr_outer, value: *meta_item},\n+                   span: {lo: 0u, hi: 0u}}];\n         }\n-        case (option::none) { }\n+      }\n+      option::none. { }\n     }\n     ret attrs;\n }\n \n-fn list_meta_items(&ebmlivec::doc meta_items, ioivec::writer out) {\n-    for (@ast::meta_item mi in get_meta_items(meta_items)) {\n+fn list_meta_items(meta_items: &ebmlivec::doc, out: ioivec::writer) {\n+    for mi: @ast::meta_item  in get_meta_items(meta_items) {\n         out.write_str(#fmt(\"%s\\n\", pprust::meta_item_to_str(*mi)));\n     }\n }\n \n-fn list_crate_attributes(&ebmlivec::doc md, ioivec::writer out) {\n+fn list_crate_attributes(md: &ebmlivec::doc, out: ioivec::writer) {\n     out.write_str(\"=Crate Attributes=\\n\");\n \n-    for (ast::attribute attr in get_attributes(md)) {\n+    for attr: ast::attribute  in get_attributes(md) {\n         out.write_str(#fmt(\"%s\\n\", pprust::attribute_to_str(attr)));\n     }\n \n     out.write_str(\"\\n\\n\");\n }\n \n-fn get_crate_attributes(@u8[] data) -> ast::attribute[] {\n+fn get_crate_attributes(data: @u8[]) -> ast::attribute[] {\n     ret get_attributes(ebmlivec::new_doc(data));\n }\n \n-type crate_dep = rec(ast::crate_num cnum, str ident);\n-\n-fn get_crate_deps(@u8[] data) -> crate_dep[] {\n-    let crate_dep[] deps = ~[];\n-    auto cratedoc = ebmlivec::new_doc(data);\n-    auto depsdoc = ebmlivec::get_doc(cratedoc, tag_crate_deps);\n-    auto crate_num = 1;\n-    for each (ebmlivec::doc depdoc in\n-              ebmlivec::tagged_docs(depsdoc, tag_crate_dep)) {\n-        auto depname =\n-            str::unsafe_from_bytes_ivec(ebmlivec::doc_data(depdoc));\n-        deps += ~[rec(cnum=crate_num, ident=depname)];\n+type crate_dep = {cnum: ast::crate_num, ident: str};\n+\n+fn get_crate_deps(data: @u8[]) -> crate_dep[] {\n+    let deps: crate_dep[] = ~[];\n+    let cratedoc = ebmlivec::new_doc(data);\n+    let depsdoc = ebmlivec::get_doc(cratedoc, tag_crate_deps);\n+    let crate_num = 1;\n+    for each depdoc: ebmlivec::doc  in\n+             ebmlivec::tagged_docs(depsdoc, tag_crate_dep) {\n+        let depname = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(depdoc));\n+        deps += ~[{cnum: crate_num, ident: depname}];\n         crate_num += 1;\n     }\n     ret deps;\n }\n \n-fn list_crate_deps(@u8[] data, ioivec::writer out) {\n+fn list_crate_deps(data: @u8[], out: ioivec::writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n-    for (crate_dep dep in get_crate_deps(data)) {\n+    for dep: crate_dep  in get_crate_deps(data) {\n         out.write_str(#fmt(\"%d %s\\n\", dep.cnum, dep.ident));\n     }\n \n     out.write_str(\"\\n\");\n }\n \n-fn list_crate_items(&@u8[] bytes, &ebmlivec::doc md, ioivec::writer out) {\n+fn list_crate_items(bytes: &@u8[], md: &ebmlivec::doc, out: ioivec::writer) {\n     out.write_str(\"=Items=\\n\");\n-    auto paths = ebmlivec::get_doc(md, tag_paths);\n-    auto items = ebmlivec::get_doc(md, tag_items);\n-    auto index = ebmlivec::get_doc(paths, tag_index);\n-    auto bs = ebmlivec::get_doc(index, tag_index_buckets);\n-    for each (ebmlivec::doc bucket in\n-             ebmlivec::tagged_docs(bs, tag_index_buckets_bucket)) {\n-        auto et = tag_index_buckets_bucket_elt;\n-        for each (ebmlivec::doc elt in ebmlivec::tagged_docs(bucket, et)) {\n-            auto data = read_path(elt);\n-            auto def = ebmlivec::doc_at(bytes, data.pos);\n-            auto did_doc = ebmlivec::get_doc(def, tag_def_id);\n-            auto did = parse_def_id(ebmlivec::doc_data(did_doc));\n+    let paths = ebmlivec::get_doc(md, tag_paths);\n+    let items = ebmlivec::get_doc(md, tag_items);\n+    let index = ebmlivec::get_doc(paths, tag_index);\n+    let bs = ebmlivec::get_doc(index, tag_index_buckets);\n+    for each bucket: ebmlivec::doc  in\n+             ebmlivec::tagged_docs(bs, tag_index_buckets_bucket) {\n+        let et = tag_index_buckets_bucket_elt;\n+        for each elt: ebmlivec::doc  in ebmlivec::tagged_docs(bucket, et) {\n+            let data = read_path(elt);\n+            let def = ebmlivec::doc_at(bytes, data.pos);\n+            let did_doc = ebmlivec::get_doc(def, tag_def_id);\n+            let did = parse_def_id(ebmlivec::doc_data(did_doc));\n             out.write_str(#fmt(\"%s (%s)\\n\", data.path,\n                                describe_def(items, did)));\n         }\n     }\n     out.write_str(\"\\n\");\n }\n \n-fn list_crate_metadata(&@u8[] bytes, ioivec::writer out) {\n-    auto md = ebmlivec::new_doc(bytes);\n+fn list_crate_metadata(bytes: &@u8[], out: ioivec::writer) {\n+    let md = ebmlivec::new_doc(bytes);\n     list_crate_attributes(md, out);\n     list_crate_deps(bytes, out);\n     list_crate_items(bytes, md, out);"}, {"sha": "f6ad31a41b92f6b252da0094253bc19019d914de", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 343, "deletions": 353, "changes": 696, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -21,28 +21,26 @@ export encoded_ty;\n \n type abbrev_map = map::hashmap[ty::t, tyencode::ty_abbrev];\n \n-type encode_ctxt = rec(@crate_ctxt ccx,\n-                       abbrev_map type_abbrevs);\n+type encode_ctxt = {ccx: @crate_ctxt, type_abbrevs: abbrev_map};\n \n // Path table encoding\n-fn encode_name(&ebmlivec::writer ebml_w, &str name) {\n+fn encode_name(ebml_w: &ebmlivec::writer, name: &str) {\n     ebmlivec::start_tag(ebml_w, tag_paths_data_name);\n     ebml_w.writer.write(str::bytes_ivec(name));\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_def_id(&ebmlivec::writer ebml_w, &def_id id) {\n+fn encode_def_id(ebml_w: &ebmlivec::writer, id: &def_id) {\n     ebmlivec::start_tag(ebml_w, tag_def_id);\n     ebml_w.writer.write(str::bytes_ivec(def_to_str(id)));\n     ebmlivec::end_tag(ebml_w);\n }\n \n-type entry[T] = rec(T val, uint pos);\n+type entry[T] = {val: T, pos: uint};\n \n-fn encode_tag_variant_paths(&ebmlivec::writer ebml_w, &variant[] variants,\n-                            &str[] path,\n-                            &mutable (entry[str])[] index) {\n-    for (variant variant in variants) {\n+fn encode_tag_variant_paths(ebml_w: &ebmlivec::writer, variants: &variant[],\n+                            path: &str[], index: &mutable (entry[str])[]) {\n+    for variant: variant  in variants {\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, variant.node.name);\n@@ -51,17 +49,18 @@ fn encode_tag_variant_paths(&ebmlivec::writer ebml_w, &variant[] variants,\n     }\n }\n \n-fn add_to_index(&ebmlivec::writer ebml_w, &str[] path,\n-                &mutable (entry[str])[] index, &str name) {\n-    auto full_path = path + ~[name];\n-    index += ~[rec(val=str::connect_ivec(full_path, \"::\"),\n-                   pos=ebml_w.writer.tell())];\n+fn add_to_index(ebml_w: &ebmlivec::writer, path: &str[],\n+                index: &mutable (entry[str])[], name: &str) {\n+    let full_path = path + ~[name];\n+    index +=\n+        ~[{val: str::connect_ivec(full_path, \"::\"),\n+           pos: ebml_w.writer.tell()}];\n }\n \n-fn encode_native_module_item_paths\n-    (&ebmlivec::writer ebml_w, &native_mod nmod, &str[] path,\n-     &mutable (entry[str])[] index) {\n-    for (@native_item nitem in nmod.items) {\n+fn encode_native_module_item_paths(ebml_w: &ebmlivec::writer,\n+                                   nmod: &native_mod, path: &str[],\n+                                   index: &mutable (entry[str])[]) {\n+    for nitem: @native_item  in nmod.items {\n         add_to_index(ebml_w, path, index, nitem.ident);\n         ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, nitem.ident);\n@@ -70,91 +69,89 @@ fn encode_native_module_item_paths\n     }\n }\n \n-fn encode_module_item_paths(&ebmlivec::writer ebml_w, &_mod module,\n-                            &str[] path,\n-                            &mutable (entry[str])[] index) {\n-    for (@item it in module.items) {\n-        if (!is_exported(it.ident, module)) { cont; }\n-        alt (it.node) {\n-            case (item_const(_, _)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebmlivec::end_tag(ebml_w);\n-            }\n-            case (item_fn(_, ?tps)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebmlivec::end_tag(ebml_w);\n-            }\n-            case (item_mod(?_mod)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebmlivec::start_tag(ebml_w, tag_paths_data_mod);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                encode_module_item_paths(ebml_w, _mod, path + ~[it.ident],\n-                                         index);\n-                ebmlivec::end_tag(ebml_w);\n-            }\n-            case (item_native_mod(?nmod)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebmlivec::start_tag(ebml_w, tag_paths_data_mod);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                encode_native_module_item_paths(ebml_w, nmod,\n-                                                path + ~[it.ident], index);\n-                ebmlivec::end_tag(ebml_w);\n-            }\n-            case (item_ty(_, ?tps)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebmlivec::end_tag(ebml_w);\n-            }\n-            case (item_res(_, _, ?tps, ?ctor_id)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(ctor_id));\n-                ebmlivec::end_tag(ebml_w);\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebmlivec::end_tag(ebml_w);\n-            }\n-            case (item_tag(?variants, ?tps)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebmlivec::end_tag(ebml_w);\n-                encode_tag_variant_paths(ebml_w, variants, path, index);\n-            }\n-            case (item_obj(_, ?tps, ?ctor_id)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(ctor_id));\n-                ebmlivec::end_tag(ebml_w);\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebmlivec::end_tag(ebml_w);\n-            }\n+fn encode_module_item_paths(ebml_w: &ebmlivec::writer, module: &_mod,\n+                            path: &str[], index: &mutable (entry[str])[]) {\n+    for it: @item  in module.items {\n+        if !is_exported(it.ident, module) { cont; }\n+        alt it.node {\n+          item_const(_, _) {\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(it.id));\n+            ebmlivec::end_tag(ebml_w);\n+          }\n+          item_fn(_, tps) {\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(it.id));\n+            ebmlivec::end_tag(ebml_w);\n+          }\n+          item_mod(_mod) {\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebmlivec::start_tag(ebml_w, tag_paths_data_mod);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(it.id));\n+            encode_module_item_paths(ebml_w, _mod, path + ~[it.ident], index);\n+            ebmlivec::end_tag(ebml_w);\n+          }\n+          item_native_mod(nmod) {\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebmlivec::start_tag(ebml_w, tag_paths_data_mod);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(it.id));\n+            encode_native_module_item_paths(ebml_w, nmod, path + ~[it.ident],\n+                                            index);\n+            ebmlivec::end_tag(ebml_w);\n+          }\n+          item_ty(_, tps) {\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(it.id));\n+            ebmlivec::end_tag(ebml_w);\n+          }\n+          item_res(_, _, tps, ctor_id) {\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(ctor_id));\n+            ebmlivec::end_tag(ebml_w);\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(it.id));\n+            ebmlivec::end_tag(ebml_w);\n+          }\n+          item_tag(variants, tps) {\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(it.id));\n+            ebmlivec::end_tag(ebml_w);\n+            encode_tag_variant_paths(ebml_w, variants, path, index);\n+          }\n+          item_obj(_, tps, ctor_id) {\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(ctor_id));\n+            ebmlivec::end_tag(ebml_w);\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(it.id));\n+            ebmlivec::end_tag(ebml_w);\n+          }\n         }\n     }\n }\n \n-fn encode_item_paths(&ebmlivec::writer ebml_w, &@crate crate)\n-        -> (entry[str])[] {\n-    let (entry[str])[] index = ~[];\n-    let str[] path = ~[];\n+fn encode_item_paths(ebml_w: &ebmlivec::writer, crate: &@crate) ->\n+   (entry[str])[] {\n+    let index: (entry[str])[] = ~[];\n+    let path: str[] = ~[];\n     ebmlivec::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n     ebmlivec::end_tag(ebml_w);\n@@ -163,69 +160,69 @@ fn encode_item_paths(&ebmlivec::writer ebml_w, &@crate crate)\n \n \n // Item info table encoding\n-fn encode_kind(&ebmlivec::writer ebml_w, u8 c) {\n+fn encode_kind(ebml_w: &ebmlivec::writer, c: u8) {\n     ebmlivec::start_tag(ebml_w, tag_items_data_item_kind);\n     ebml_w.writer.write(~[c]);\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn def_to_str(&def_id did) -> str { ret #fmt(\"%d:%d\", did.crate, did.node); }\n+fn def_to_str(did: &def_id) -> str { ret #fmt(\"%d:%d\", did.crate, did.node); }\n \n-fn encode_type_param_count(&ebmlivec::writer ebml_w, &ty_param[] tps) {\n+fn encode_type_param_count(ebml_w: &ebmlivec::writer, tps: &ty_param[]) {\n     ebmlivec::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n     ebmlivec::write_vint(ebml_w.writer, ivec::len[ty_param](tps));\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_variant_id(&ebmlivec::writer ebml_w, &def_id vid) {\n+fn encode_variant_id(ebml_w: &ebmlivec::writer, vid: &def_id) {\n     ebmlivec::start_tag(ebml_w, tag_items_data_item_variant);\n     ebml_w.writer.write(str::bytes_ivec(def_to_str(vid)));\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_type(&@encode_ctxt ecx, &ebmlivec::writer ebml_w, &ty::t typ) {\n+fn encode_type(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer, typ: &ty::t) {\n     ebmlivec::start_tag(ebml_w, tag_items_data_item_type);\n-    auto f = def_to_str;\n-    auto ty_str_ctxt =\n-        @rec(ds=f, tcx=ecx.ccx.tcx,\n-             abbrevs=tyencode::ac_use_abbrevs(ecx.type_abbrevs));\n+    let f = def_to_str;\n+    let ty_str_ctxt =\n+        @{ds: f,\n+          tcx: ecx.ccx.tcx,\n+          abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(ioivec::new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_symbol(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n-                 node_id id) {\n+fn encode_symbol(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer, id: node_id) {\n     ebmlivec::start_tag(ebml_w, tag_items_data_item_symbol);\n     ebml_w.writer.write(str::bytes_ivec(ecx.ccx.item_symbols.get(id)));\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_discriminant(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n-                       node_id id) {\n+fn encode_discriminant(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n+                       id: node_id) {\n     ebmlivec::start_tag(ebml_w, tag_items_data_item_symbol);\n     ebml_w.writer.write(str::bytes_ivec(ecx.ccx.discrim_symbols.get(id)));\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_tag_id(&ebmlivec::writer ebml_w, &def_id id) {\n+fn encode_tag_id(ebml_w: &ebmlivec::writer, id: &def_id) {\n     ebmlivec::start_tag(ebml_w, tag_items_data_item_tag_id);\n     ebml_w.writer.write(str::bytes_ivec(def_to_str(id)));\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_info(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n-                           node_id id, &variant[] variants,\n-                           &mutable (entry[int])[] index,\n-                           &ty_param[] ty_params) {\n-    for (variant variant in variants) {\n-        index += ~[rec(val=variant.node.id, pos=ebml_w.writer.tell())];\n+fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n+                           id: node_id, variants: &variant[],\n+                           index: &mutable (entry[int])[],\n+                           ty_params: &ty_param[]) {\n+    for variant: variant  in variants {\n+        index += ~[{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_kind(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, local_def(id));\n         encode_type(ecx, ebml_w,\n                     node_id_to_monotype(ecx.ccx.tcx, variant.node.id));\n-        if (ivec::len[variant_arg](variant.node.args) > 0u) {\n+        if ivec::len[variant_arg](variant.node.args) > 0u {\n             encode_symbol(ecx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(ecx, ebml_w, variant.node.id);\n@@ -234,145 +231,139 @@ fn encode_tag_variant_info(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n     }\n }\n \n-fn encode_info_for_item(@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n-                        @item item, &mutable (entry[int])[] index) {\n-    alt (item.node) {\n-        case (item_const(_, _)) {\n-            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'c' as u8);\n-            encode_type(ecx, ebml_w,\n-                        node_id_to_monotype(ecx.ccx.tcx, item.id));\n-            encode_symbol(ecx, ebml_w, item.id);\n-            ebmlivec::end_tag(ebml_w);\n-        }\n-        case (item_fn(?fd, ?tps)) {\n-            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, alt (fd.decl.purity) {\n-                                  case (pure_fn) { 'p' }\n-                                  case (impure_fn) { 'f' } } as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(ecx, ebml_w,\n-                        node_id_to_monotype(ecx.ccx.tcx, item.id));\n-            encode_symbol(ecx, ebml_w, item.id);\n-            ebmlivec::end_tag(ebml_w);\n-        }\n-        case (item_mod(_)) {\n-            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'm' as u8);\n-            ebmlivec::end_tag(ebml_w);\n-        }\n-        case (item_native_mod(_)) {\n-            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'n' as u8);\n-            ebmlivec::end_tag(ebml_w);\n-        }\n-        case (item_ty(_, ?tps)) {\n-            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'y' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(ecx, ebml_w,\n-                        node_id_to_monotype(ecx.ccx.tcx, item.id));\n-            ebmlivec::end_tag(ebml_w);\n-        }\n-        case (item_tag(?variants, ?tps)) {\n-            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 't' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(ecx, ebml_w,\n-                        node_id_to_monotype(ecx.ccx.tcx, item.id));\n-            for (variant v in variants) {\n-                encode_variant_id(ebml_w, local_def(v.node.id));\n-            }\n-            ebmlivec::end_tag(ebml_w);\n-            encode_tag_variant_info(ecx, ebml_w, item.id, variants, index,\n-                                    tps);\n+fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebmlivec::writer,\n+                        item: @item, index: &mutable (entry[int])[]) {\n+    alt item.node {\n+      item_const(_, _) {\n+        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_kind(ebml_w, 'c' as u8);\n+        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_symbol(ecx, ebml_w, item.id);\n+        ebmlivec::end_tag(ebml_w);\n+      }\n+      item_fn(fd, tps) {\n+        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_kind(ebml_w,\n+                    alt fd.decl.purity { pure_fn. { 'p' } impure_fn. { 'f' } }\n+                        as u8);\n+        encode_type_param_count(ebml_w, tps);\n+        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_symbol(ecx, ebml_w, item.id);\n+        ebmlivec::end_tag(ebml_w);\n+      }\n+      item_mod(_) {\n+        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_kind(ebml_w, 'm' as u8);\n+        ebmlivec::end_tag(ebml_w);\n+      }\n+      item_native_mod(_) {\n+        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_kind(ebml_w, 'n' as u8);\n+        ebmlivec::end_tag(ebml_w);\n+      }\n+      item_ty(_, tps) {\n+        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_kind(ebml_w, 'y' as u8);\n+        encode_type_param_count(ebml_w, tps);\n+        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        ebmlivec::end_tag(ebml_w);\n+      }\n+      item_tag(variants, tps) {\n+        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_kind(ebml_w, 't' as u8);\n+        encode_type_param_count(ebml_w, tps);\n+        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        for v: variant  in variants {\n+            encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n-        case (item_res(_, _, ?tps, ?ctor_id)) {\n-            auto fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n+        ebmlivec::end_tag(ebml_w);\n+        encode_tag_variant_info(ecx, ebml_w, item.id, variants, index, tps);\n+      }\n+      item_res(_, _, tps, ctor_id) {\n+        let fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n \n-            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(ctor_id));\n-            encode_kind(ebml_w, 'y' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n-            encode_symbol(ecx, ebml_w, item.id);\n-            ebmlivec::end_tag(ebml_w);\n+        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(ctor_id));\n+        encode_kind(ebml_w, 'y' as u8);\n+        encode_type_param_count(ebml_w, tps);\n+        encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n+        encode_symbol(ecx, ebml_w, item.id);\n+        ebmlivec::end_tag(ebml_w);\n \n-            index += ~[rec(val=ctor_id, pos=ebml_w.writer.tell())];\n-            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(ctor_id));\n-            encode_kind(ebml_w, 'f' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(ecx, ebml_w, fn_ty);\n-            encode_symbol(ecx, ebml_w, ctor_id);\n-            ebmlivec::end_tag(ebml_w);\n-        }\n-        case (item_obj(_, ?tps, ?ctor_id)) {\n-            auto fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n-\n-            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'y' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n-            ebmlivec::end_tag(ebml_w);\n+        index += ~[{val: ctor_id, pos: ebml_w.writer.tell()}];\n+        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(ctor_id));\n+        encode_kind(ebml_w, 'f' as u8);\n+        encode_type_param_count(ebml_w, tps);\n+        encode_type(ecx, ebml_w, fn_ty);\n+        encode_symbol(ecx, ebml_w, ctor_id);\n+        ebmlivec::end_tag(ebml_w);\n+      }\n+      item_obj(_, tps, ctor_id) {\n+        let fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n \n-            index += ~[rec(val=ctor_id, pos=ebml_w.writer.tell())];\n-            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(ctor_id));\n-            encode_kind(ebml_w, 'f' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(ecx, ebml_w, fn_ty);\n-            encode_symbol(ecx, ebml_w, ctor_id);\n-            ebmlivec::end_tag(ebml_w);\n-        }\n+        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_kind(ebml_w, 'y' as u8);\n+        encode_type_param_count(ebml_w, tps);\n+        encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n+        ebmlivec::end_tag(ebml_w);\n+\n+        index += ~[{val: ctor_id, pos: ebml_w.writer.tell()}];\n+        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(ctor_id));\n+        encode_kind(ebml_w, 'f' as u8);\n+        encode_type_param_count(ebml_w, tps);\n+        encode_type(ecx, ebml_w, fn_ty);\n+        encode_symbol(ecx, ebml_w, ctor_id);\n+        ebmlivec::end_tag(ebml_w);\n+      }\n     }\n }\n \n-fn encode_info_for_native_item(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n-                               &@native_item nitem) {\n+fn encode_info_for_native_item(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n+                               nitem: &@native_item) {\n     ebmlivec::start_tag(ebml_w, tag_items_data_item);\n-    alt (nitem.node) {\n-        case (native_item_ty) {\n-            encode_def_id(ebml_w, local_def(nitem.id));\n-            encode_kind(ebml_w, 'T' as u8);\n-            encode_type(ecx, ebml_w,\n-                        ty::mk_native(ecx.ccx.tcx, local_def(nitem.id)));\n-        }\n-        case (native_item_fn(_, _, ?tps)) {\n-            encode_def_id(ebml_w, local_def(nitem.id));\n-            encode_kind(ebml_w, 'F' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(ecx, ebml_w,\n-                        node_id_to_monotype(ecx.ccx.tcx, nitem.id));\n-            encode_symbol(ecx, ebml_w, nitem.id);\n-        }\n+    alt nitem.node {\n+      native_item_ty. {\n+        encode_def_id(ebml_w, local_def(nitem.id));\n+        encode_kind(ebml_w, 'T' as u8);\n+        encode_type(ecx, ebml_w,\n+                    ty::mk_native(ecx.ccx.tcx, local_def(nitem.id)));\n+      }\n+      native_item_fn(_, _, tps) {\n+        encode_def_id(ebml_w, local_def(nitem.id));\n+        encode_kind(ebml_w, 'F' as u8);\n+        encode_type_param_count(ebml_w, tps);\n+        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, nitem.id));\n+        encode_symbol(ecx, ebml_w, nitem.id);\n+      }\n     }\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(&@encode_ctxt ecx, &ebmlivec::writer ebml_w)\n-        -> (entry[int])[] {\n-    let (entry[int])[] index = ~[];\n+fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer) ->\n+   (entry[int])[] {\n+    let index: (entry[int])[] = ~[];\n     ebmlivec::start_tag(ebml_w, tag_items_data);\n-    for each (@rec(node_id key, middle::ast_map::ast_node val) kvp\n-              in ecx.ccx.ast_map.items()) {\n-        alt (kvp.val) {\n-            case (middle::ast_map::node_item(?i)) {\n-                index += ~[rec(val=kvp.key, pos=ebml_w.writer.tell())];\n-                encode_info_for_item(ecx, ebml_w, i, index);\n-            }\n-            case (middle::ast_map::node_native_item(?i)) {\n-                index += ~[rec(val=kvp.key, pos=ebml_w.writer.tell())];\n-                encode_info_for_native_item(ecx, ebml_w, i);\n-            }\n-            case (_) {}\n+    for each kvp: @{key: node_id, val: middle::ast_map::ast_node}  in\n+             ecx.ccx.ast_map.items() {\n+        alt kvp.val {\n+          middle::ast_map::node_item(i) {\n+            index += ~[{val: kvp.key, pos: ebml_w.writer.tell()}];\n+            encode_info_for_item(ecx, ebml_w, i, index);\n+          }\n+          middle::ast_map::node_native_item(i) {\n+            index += ~[{val: kvp.key, pos: ebml_w.writer.tell()}];\n+            encode_info_for_native_item(ecx, ebml_w, i);\n+          }\n+          _ { }\n         }\n     }\n     ebmlivec::end_tag(ebml_w);\n@@ -382,32 +373,32 @@ fn encode_info_for_items(&@encode_ctxt ecx, &ebmlivec::writer ebml_w)\n \n // Path and definition ID indexing\n \n-fn create_index[T](&(entry[T])[] index, fn(&T) -> uint  hash_fn)\n-        -> (@(entry[T])[])[] {\n-    let (@mutable (entry[T])[])[] buckets = ~[];\n-    for each (uint i in uint::range(0u, 256u)) { buckets += ~[@mutable ~[]]; }\n-    for (entry[T] elt in index) {\n-        auto h = hash_fn(elt.val);\n-        *(buckets.(h % 256u)) += ~[elt];\n+fn create_index[T](index: &(entry[T])[], hash_fn: fn(&T) -> uint ) ->\n+   (@(entry[T])[])[] {\n+    let buckets: (@mutable (entry[T])[])[] = ~[];\n+    for each i: uint  in uint::range(0u, 256u) { buckets += ~[@mutable ~[]]; }\n+    for elt: entry[T]  in index {\n+        let h = hash_fn(elt.val);\n+        *buckets.(h % 256u) += ~[elt];\n     }\n \n-    auto buckets_frozen = ~[];\n-    for (@mutable (entry[T])[] bucket in buckets) {\n+    let buckets_frozen = ~[];\n+    for bucket: @mutable (entry[T])[]  in buckets {\n         buckets_frozen += ~[@*bucket];\n     }\n     ret buckets_frozen;\n }\n \n-fn encode_index[T](&ebmlivec::writer ebml_w, &(@(entry[T])[])[] buckets,\n-                   fn(&ioivec::writer, &T)  write_fn) {\n-    auto writer = ioivec::new_writer_(ebml_w.writer);\n+fn encode_index[T](ebml_w: &ebmlivec::writer, buckets: &(@(entry[T])[])[],\n+                   write_fn: fn(&ioivec::writer, &T) ) {\n+    let writer = ioivec::new_writer_(ebml_w.writer);\n     ebmlivec::start_tag(ebml_w, tag_index);\n-    let uint[] bucket_locs = ~[];\n+    let bucket_locs: uint[] = ~[];\n     ebmlivec::start_tag(ebml_w, tag_index_buckets);\n-    for (@(entry[T])[] bucket in buckets) {\n+    for bucket: @(entry[T])[]  in buckets {\n         bucket_locs += ~[ebml_w.writer.tell()];\n         ebmlivec::start_tag(ebml_w, tag_index_buckets_bucket);\n-        for (entry[T] elt in *bucket) {\n+        for elt: entry[T]  in *bucket {\n             ebmlivec::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt.pos, 4u);\n             write_fn(writer, elt.val);\n@@ -417,57 +408,57 @@ fn encode_index[T](&ebmlivec::writer ebml_w, &(@(entry[T])[])[] buckets,\n     }\n     ebmlivec::end_tag(ebml_w);\n     ebmlivec::start_tag(ebml_w, tag_index_table);\n-    for (uint pos in bucket_locs) { writer.write_be_uint(pos, 4u); }\n+    for pos: uint  in bucket_locs { writer.write_be_uint(pos, 4u); }\n     ebmlivec::end_tag(ebml_w);\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn write_str(&ioivec::writer writer, &str s) { writer.write_str(s); }\n+fn write_str(writer: &ioivec::writer, s: &str) { writer.write_str(s); }\n \n-fn write_int(&ioivec::writer writer, &int n) {\n+fn write_int(writer: &ioivec::writer, n: &int) {\n     writer.write_be_uint(n as uint, 4u);\n }\n \n-fn encode_meta_item(&ebmlivec::writer ebml_w, &meta_item mi) {\n-    alt (mi.node) {\n-        case (meta_word(?name)) {\n-            ebmlivec::start_tag(ebml_w, tag_meta_item_word);\n+fn encode_meta_item(ebml_w: &ebmlivec::writer, mi: &meta_item) {\n+    alt mi.node {\n+      meta_word(name) {\n+        ebmlivec::start_tag(ebml_w, tag_meta_item_word);\n+        ebmlivec::start_tag(ebml_w, tag_meta_item_name);\n+        ebml_w.writer.write(str::bytes_ivec(name));\n+        ebmlivec::end_tag(ebml_w);\n+        ebmlivec::end_tag(ebml_w);\n+      }\n+      meta_name_value(name, value) {\n+        alt value.node {\n+          lit_str(value, _) {\n+            ebmlivec::start_tag(ebml_w, tag_meta_item_name_value);\n             ebmlivec::start_tag(ebml_w, tag_meta_item_name);\n             ebml_w.writer.write(str::bytes_ivec(name));\n             ebmlivec::end_tag(ebml_w);\n+            ebmlivec::start_tag(ebml_w, tag_meta_item_value);\n+            ebml_w.writer.write(str::bytes_ivec(value));\n             ebmlivec::end_tag(ebml_w);\n-        }\n-        case (meta_name_value(?name, ?value)) {\n-            alt (value.node) {\n-                case (lit_str(?value, _)) {\n-                    ebmlivec::start_tag(ebml_w, tag_meta_item_name_value);\n-                    ebmlivec::start_tag(ebml_w, tag_meta_item_name);\n-                    ebml_w.writer.write(str::bytes_ivec(name));\n-                    ebmlivec::end_tag(ebml_w);\n-                    ebmlivec::start_tag(ebml_w, tag_meta_item_value);\n-                    ebml_w.writer.write(str::bytes_ivec(value));\n-                    ebmlivec::end_tag(ebml_w);\n-                    ebmlivec::end_tag(ebml_w);\n-                }\n-                case (_) { /* FIXME (#611) */ }\n-            }\n-        }\n-        case (meta_list(?name, ?items)) {\n-            ebmlivec::start_tag(ebml_w, tag_meta_item_list);\n-            ebmlivec::start_tag(ebml_w, tag_meta_item_name);\n-            ebml_w.writer.write(str::bytes_ivec(name));\n-            ebmlivec::end_tag(ebml_w);\n-            for (@meta_item inner_item in items) {\n-                encode_meta_item(ebml_w, *inner_item);\n-            }\n             ebmlivec::end_tag(ebml_w);\n+          }\n+          _ {/* FIXME (#611) */ }\n+        }\n+      }\n+      meta_list(name, items) {\n+        ebmlivec::start_tag(ebml_w, tag_meta_item_list);\n+        ebmlivec::start_tag(ebml_w, tag_meta_item_name);\n+        ebml_w.writer.write(str::bytes_ivec(name));\n+        ebmlivec::end_tag(ebml_w);\n+        for inner_item: @meta_item  in items {\n+            encode_meta_item(ebml_w, *inner_item);\n         }\n+        ebmlivec::end_tag(ebml_w);\n+      }\n     }\n }\n \n-fn encode_attributes(&ebmlivec::writer ebml_w, &attribute[] attrs) {\n+fn encode_attributes(ebml_w: &ebmlivec::writer, attrs: &attribute[]) {\n     ebmlivec::start_tag(ebml_w, tag_attributes);\n-    for (attribute attr in attrs) {\n+    for attr: attribute  in attrs {\n         ebmlivec::start_tag(ebml_w, tag_attribute);\n         encode_meta_item(ebml_w, attr.node.value);\n         ebmlivec::end_tag(ebml_w);\n@@ -479,81 +470,82 @@ fn encode_attributes(&ebmlivec::writer ebml_w, &attribute[] attrs) {\n // metadata that Rust cares about for linking crates. This attribute requires\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n // them in anyway with default values.\n-fn synthesize_crate_attrs(&@encode_ctxt ecx,\n-                          &@crate crate) -> attribute[] {\n+fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> attribute[] {\n \n-    fn synthesize_link_attr(&@encode_ctxt ecx, &(@meta_item)[] items)\n-            -> attribute {\n+    fn synthesize_link_attr(ecx: &@encode_ctxt, items: &(@meta_item)[]) ->\n+       attribute {\n \n-        assert ecx.ccx.link_meta.name != \"\";\n-        assert ecx.ccx.link_meta.vers != \"\";\n+        assert (ecx.ccx.link_meta.name != \"\");\n+        assert (ecx.ccx.link_meta.vers != \"\");\n \n-        auto name_item = attr::mk_name_value_item_str(\"name\",\n-                                                      ecx.ccx.link_meta.name);\n-        auto vers_item = attr::mk_name_value_item_str(\"vers\",\n-                                                      ecx.ccx.link_meta.vers);\n+        let name_item =\n+            attr::mk_name_value_item_str(\"name\", ecx.ccx.link_meta.name);\n+        let vers_item =\n+            attr::mk_name_value_item_str(\"vers\", ecx.ccx.link_meta.vers);\n \n-        auto other_items = {\n-            auto tmp = attr::remove_meta_items_by_name(items, \"name\");\n-            attr::remove_meta_items_by_name(tmp, \"vers\")\n-        };\n+        let other_items =\n+            {\n+                let tmp = attr::remove_meta_items_by_name(items, \"name\");\n+                attr::remove_meta_items_by_name(tmp, \"vers\")\n+            };\n \n-        auto meta_items = ~[name_item, vers_item] + other_items;\n-        auto link_item = attr::mk_list_item(\"link\", meta_items);\n+        let meta_items = ~[name_item, vers_item] + other_items;\n+        let link_item = attr::mk_list_item(\"link\", meta_items);\n \n         ret attr::mk_attr(link_item);\n     }\n \n-    let attribute[] attrs = ~[];\n-    auto found_link_attr = false;\n-    for (attribute attr in crate.node.attrs) {\n-        attrs += if (attr::get_attr_name(attr) != \"link\") {\n-            ~[attr]\n-        } else {\n-            alt (attr.node.value.node) {\n-                case (meta_list(?n, ?l)) {\n+    let attrs: attribute[] = ~[];\n+    let found_link_attr = false;\n+    for attr: attribute  in crate.node.attrs {\n+        attrs +=\n+            if attr::get_attr_name(attr) != \"link\" {\n+                ~[attr]\n+            } else {\n+                alt attr.node.value.node {\n+                  meta_list(n, l) {\n                     found_link_attr = true;\n                     ~[synthesize_link_attr(ecx, l)]\n+                  }\n+                  _ { ~[attr] }\n                 }\n-                case (_) { ~[attr] }\n             }\n-        }\n     }\n \n-    if (!found_link_attr) {\n-        attrs += ~[synthesize_link_attr(ecx, ~[])];\n-    }\n+    if !found_link_attr { attrs += ~[synthesize_link_attr(ecx, ~[])]; }\n \n     ret attrs;\n }\n \n-fn encode_crate_deps(&ebmlivec::writer ebml_w, &cstore::cstore cstore) {\n+fn encode_crate_deps(ebml_w: &ebmlivec::writer, cstore: &cstore::cstore) {\n \n-    fn get_ordered_names(&cstore::cstore cstore) -> str[] {\n-        type hashkv = @rec(crate_num key, cstore::crate_metadata val);\n-        type numname = rec(crate_num crate, str ident);\n+    fn get_ordered_names(cstore: &cstore::cstore) -> str[] {\n+        type hashkv = @{key: crate_num, val: cstore::crate_metadata};\n+        type numname = {crate: crate_num, ident: str};\n \n         // Pull the cnums and names out of cstore\n-        let numname[mutable] pairs = ~[mutable];\n-        for each (hashkv hashkv in cstore::iter_crate_data(cstore)) {\n-            pairs += ~[mutable rec(crate=hashkv.key, ident=hashkv.val.name)];\n+        let pairs: numname[mutable ] = ~[mutable ];\n+        for each hashkv: hashkv  in cstore::iter_crate_data(cstore) {\n+            pairs += ~[mutable {crate: hashkv.key, ident: hashkv.val.name}];\n         }\n \n         // Sort by cnum\n-        fn lteq(&numname kv1, &numname kv2) -> bool { kv1.crate <= kv2.crate }\n+        fn lteq(kv1: &numname, kv2: &numname) -> bool {\n+            kv1.crate <= kv2.crate\n+        }\n         std::sort::ivector::quick_sort(lteq, pairs);\n \n         // Sanity-check the crate numbers\n-        auto expected_cnum = 1;\n-        for (numname n in pairs) {\n-            assert n.crate == expected_cnum;\n+        let expected_cnum = 1;\n+        for n: numname  in pairs {\n+            assert (n.crate == expected_cnum);\n             expected_cnum += 1;\n         }\n \n         // Return just the names\n-        fn name(&numname kv) -> str { kv.ident }\n+        fn name(kv: &numname) -> str { kv.ident }\n         // mutable -> immutable hack for ivec::map\n-        auto immpairs = ivec::slice(pairs, 0u, ivec::len(pairs));\n+        let immpairs = ivec::slice(pairs, 0u, ivec::len(pairs));\n         ret ivec::map(name, immpairs);\n     }\n \n@@ -562,40 +554,40 @@ fn encode_crate_deps(&ebmlivec::writer ebml_w, &cstore::cstore cstore) {\n     // FIXME: This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ebmlivec::start_tag(ebml_w, tag_crate_deps);\n-    for (str cname in get_ordered_names(cstore)) {\n+    for cname: str  in get_ordered_names(cstore) {\n         ebmlivec::start_tag(ebml_w, tag_crate_dep);\n         ebml_w.writer.write(str::bytes_ivec(cname));\n         ebmlivec::end_tag(ebml_w);\n     }\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_metadata(&@crate_ctxt cx, &@crate crate) -> str {\n+fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n \n-    auto abbrevs = map::mk_hashmap(ty::hash_ty, ty::eq_ty);\n-    auto ecx = @rec(ccx = cx, type_abbrevs = abbrevs);\n+    let abbrevs = map::mk_hashmap(ty::hash_ty, ty::eq_ty);\n+    let ecx = @{ccx: cx, type_abbrevs: abbrevs};\n \n-    auto string_w = ioivec::string_writer();\n-    auto buf_w = string_w.get_writer().get_buf_writer();\n-    auto ebml_w = ebmlivec::create_writer(buf_w);\n+    let string_w = ioivec::string_writer();\n+    let buf_w = string_w.get_writer().get_buf_writer();\n+    let ebml_w = ebmlivec::create_writer(buf_w);\n \n-    auto crate_attrs = synthesize_crate_attrs(ecx, crate);\n+    let crate_attrs = synthesize_crate_attrs(ecx, crate);\n     encode_attributes(ebml_w, crate_attrs);\n \n     encode_crate_deps(ebml_w, cx.sess.get_cstore());\n \n     // Encode and index the paths.\n \n     ebmlivec::start_tag(ebml_w, tag_paths);\n-    auto paths_index = encode_item_paths(ebml_w, crate);\n-    auto paths_buckets = create_index(paths_index, hash_path);\n+    let paths_index = encode_item_paths(ebml_w, crate);\n+    let paths_buckets = create_index(paths_index, hash_path);\n     encode_index(ebml_w, paths_buckets, write_str);\n     ebmlivec::end_tag(ebml_w);\n     // Encode and index the items.\n \n     ebmlivec::start_tag(ebml_w, tag_items);\n-    auto items_index = encode_info_for_items(ecx, ebml_w);\n-    auto items_buckets = create_index(items_index, hash_node_id);\n+    let items_index = encode_info_for_items(ecx, ebml_w);\n+    let items_buckets = create_index(items_index, hash_node_id);\n     encode_index(ebml_w, items_buckets, write_int);\n     ebmlivec::end_tag(ebml_w);\n     // Pad this, since something (LLVM, presumably) is cutting off the\n@@ -606,11 +598,9 @@ fn encode_metadata(&@crate_ctxt cx, &@crate crate) -> str {\n }\n \n // Get the encoded string for a type\n-fn encoded_ty(&ty::ctxt tcx, &ty::t t) -> str {\n-    auto cx = @rec(ds = def_to_str,\n-                   tcx = tcx,\n-                   abbrevs = tyencode::ac_no_abbrevs);\n-    auto sw = ioivec::string_writer();\n+fn encoded_ty(tcx: &ty::ctxt, t: &ty::t) -> str {\n+    let cx = @{ds: def_to_str, tcx: tcx, abbrevs: tyencode::ac_no_abbrevs};\n+    let sw = ioivec::string_writer();\n     tyencode::enc_ty(sw.get_writer(), cx, t);\n     ret sw.get_str();\n }"}, {"sha": "d0a00c9bf69bb7c2586699f5ffa2e91cde3f9eea", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 267, "deletions": 297, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -22,126 +22,115 @@ export parse_ty_data;\n type str_def = fn(str) -> ast::def_id ;\n \n type pstate =\n-    rec(@u8[] data, int crate, mutable uint pos, uint len, ty::ctxt tcx);\n+    {data: @u8[], crate: int, mutable pos: uint, len: uint, tcx: ty::ctxt};\n \n tag ty_or_bang { a_ty(ty::t); a_bang; }\n \n-fn peek(@pstate st) -> u8 { ret st.data.(st.pos); }\n+fn peek(st: @pstate) -> u8 { ret st.data.(st.pos); }\n \n-fn next(@pstate st) -> u8 {\n-    auto ch = st.data.(st.pos);\n+fn next(st: @pstate) -> u8 {\n+    let ch = st.data.(st.pos);\n     st.pos = st.pos + 1u;\n     ret ch;\n }\n \n-fn parse_ident(@pstate st, str_def sd, char last) -> ast::ident {\n-    fn is_last(char b, char c) -> bool {\n-        ret c == b;\n-    }\n+fn parse_ident(st: @pstate, sd: str_def, last: char) -> ast::ident {\n+    fn is_last(b: char, c: char) -> bool { ret c == b; }\n     ret parse_ident_(st, sd, bind is_last(last, _));\n }\n \n-fn parse_ident_(@pstate st, str_def sd, fn(char) -> bool is_last)\n-    -> ast::ident {\n-    auto rslt = \"\";\n-    while (! is_last(peek(st) as char)) {\n+fn parse_ident_(st: @pstate, sd: str_def, is_last: fn(char) -> bool ) ->\n+   ast::ident {\n+    let rslt = \"\";\n+    while !is_last(peek(st) as char) {\n         rslt += str::unsafe_from_byte(next(st));\n     }\n     ret rslt;\n }\n \n \n-fn parse_ty_data(@u8[] data, int crate_num, uint pos, uint len, str_def sd,\n-                 ty::ctxt tcx) -> ty::t {\n-    auto st =\n-        @rec(data=data, crate=crate_num, mutable pos=pos, len=len, tcx=tcx);\n-    auto result = parse_ty(st, sd);\n+fn parse_ty_data(data: @u8[], crate_num: int, pos: uint, len: uint,\n+                 sd: str_def, tcx: ty::ctxt) -> ty::t {\n+    let st =\n+        @{data: data, crate: crate_num, mutable pos: pos, len: len, tcx: tcx};\n+    let result = parse_ty(st, sd);\n     ret result;\n }\n \n-fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n-    alt (peek(st) as char) {\n-        case ('!') { next(st); ret a_bang; }\n-        case (_) { ret a_ty(parse_ty(st, sd)); }\n+fn parse_ty_or_bang(st: @pstate, sd: str_def) -> ty_or_bang {\n+    alt peek(st) as char {\n+      '!' { next(st); ret a_bang; }\n+      _ { ret a_ty(parse_ty(st, sd)); }\n     }\n }\n \n-fn parse_constrs(@pstate st, str_def sd) -> (@ty::constr)[] {\n-    let (@ty::constr)[] rslt = ~[];\n-    alt (peek(st) as char) {\n-        case (':') {\n-            do {\n-                next(st);\n-                let @ty::constr one = parse_constr[uint](st, sd,\n-                                                         parse_constr_arg);\n-                rslt += ~[one];\n-            } while (peek(st) as char == ';')\n-        }\n-        case (_) { }\n+fn parse_constrs(st: @pstate, sd: str_def) -> (@ty::constr)[] {\n+    let rslt: (@ty::constr)[] = ~[];\n+    alt peek(st) as char {\n+      ':' {\n+        do  {\n+            next(st);\n+            let one: @ty::constr =\n+                parse_constr[uint](st, sd, parse_constr_arg);\n+            rslt += ~[one];\n+        } while peek(st) as char == ';'\n+      }\n+      _ { }\n     }\n     ret rslt;\n }\n \n // FIXME less copy-and-paste\n-fn parse_ty_constrs(@pstate st, str_def sd) -> (@ty::type_constr)[] {\n-    let (@ty::type_constr)[] rslt = ~[];\n-    alt (peek(st) as char) {\n-        case (':') {\n-            do {\n-                next(st);\n-                let @ty::type_constr one = parse_constr[path](st, sd,\n-                                                  parse_ty_constr_arg);\n-                rslt += ~[one];\n-            } while (peek(st) as char == ';')\n-        }\n-        case (_) { }\n+fn parse_ty_constrs(st: @pstate, sd: str_def) -> (@ty::type_constr)[] {\n+    let rslt: (@ty::type_constr)[] = ~[];\n+    alt peek(st) as char {\n+      ':' {\n+        do  {\n+            next(st);\n+            let one: @ty::type_constr =\n+                parse_constr[path](st, sd, parse_ty_constr_arg);\n+            rslt += ~[one];\n+        } while peek(st) as char == ';'\n+      }\n+      _ { }\n     }\n     ret rslt;\n }\n \n-fn parse_path(@pstate st, str_def sd) -> ast::path {\n-    let ast::ident[] idents = ~[];\n-    fn is_last(char c) -> bool {\n-        ret (c == '(' || c == ':');\n-    }\n+fn parse_path(st: @pstate, sd: str_def) -> ast::path {\n+    let idents: ast::ident[] = ~[];\n+    fn is_last(c: char) -> bool { ret c == '(' || c == ':'; }\n     idents += ~[parse_ident_(st, sd, is_last)];\n-    while (true) {\n-        alt (peek(st) as char) {\n-            case (':') { next(st); next(st); }\n-            case (?c) {\n-                if (c == '(') {\n-                    ret respan(rec(lo=0u, hi=0u),\n-                               rec(global=false, idents=idents, types=~[]));\n-                }\n-                else {\n-                    idents += ~[parse_ident_(st, sd, is_last)];\n-                }\n-            }\n+    while true {\n+        alt peek(st) as char {\n+          ':' { next(st); next(st); }\n+          c {\n+            if c == '(' {\n+                ret respan({lo: 0u, hi: 0u},\n+                           {global: false, idents: idents, types: ~[]});\n+            } else { idents += ~[parse_ident_(st, sd, is_last)]; }\n+          }\n         }\n     }\n     fail \"parse_path: ill-formed path\";\n }\n \n-type arg_parser[T] = fn (@pstate st, str_def sd)\n-                       -> ast::constr_arg_general_[T];\n+type arg_parser[T] = fn(@pstate, str_def) -> ast::constr_arg_general_[T] ;\n+\n+fn parse_constr_arg(st: @pstate, sd: str_def) -> ast::fn_constr_arg {\n+    alt peek(st) as char {\n+      '*' { st.pos += 1u; ret ast::carg_base; }\n+      c {\n \n-fn parse_constr_arg(@pstate st, str_def sd) -> ast::fn_constr_arg {\n-     alt (peek(st) as char) {\n-      case ('*') {\n-        st.pos += 1u;\n-        ret ast::carg_base;\n-      }\n-      case (?c) {\n         /* how will we disambiguate between\n            an arg index and a lit argument? */\n-        if (c >= '0' && c <= '9') {\n+        if c >= '0' && c <= '9' {\n             next(st);\n-          // FIXME\n-          ret ast::carg_ident((c as uint) - 48u);\n-        }\n-        else {\n-          log_err(\"Lit args are unimplemented\");\n-          fail; // FIXME\n+            // FIXME\n+            ret ast::carg_ident((c as uint) - 48u);\n+        } else {\n+            log_err \"Lit args are unimplemented\";\n+            fail; // FIXME\n         }\n         /*\n           else {\n@@ -153,288 +142,269 @@ fn parse_constr_arg(@pstate st, str_def sd) -> ast::fn_constr_arg {\n     }\n }\n \n-fn parse_ty_constr_arg(@pstate st, str_def sd)\n-    -> ast::constr_arg_general_[path] {\n-     alt (peek(st) as char) {\n-      case ('*') {\n-        st.pos += 1u;\n-        ret ast::carg_base;\n-      }\n-      case (?c) {\n-          ret ast::carg_ident(parse_path(st, sd));\n-      }\n+fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n+   ast::constr_arg_general_[path] {\n+    alt peek(st) as char {\n+      '*' { st.pos += 1u; ret ast::carg_base; }\n+      c { ret ast::carg_ident(parse_path(st, sd)); }\n     }\n }\n \n-fn parse_constr[T](@pstate st, str_def sd, arg_parser[T] pser)\n-    -> @ty::constr_general[T] {\n-    auto sp = rec(lo=0u,hi=0u); // FIXME: use a real span\n-    let (@sp_constr_arg[T])[] args = ~[];\n-    let path pth = parse_path(st, sd);\n-    let char ignore = next(st) as char;\n-    assert(ignore as char == '(');\n-    auto def = parse_def(st, sd);\n-    let constr_arg_general_[T] an_arg;\n-    do {\n+fn parse_constr[T](st: @pstate, sd: str_def, pser: arg_parser[T]) ->\n+   @ty::constr_general[T] {\n+    let sp = {lo: 0u, hi: 0u}; // FIXME: use a real span\n+    let args: (@sp_constr_arg[T])[] = ~[];\n+    let pth: path = parse_path(st, sd);\n+    let ignore: char = next(st) as char;\n+    assert (ignore as char == '(');\n+    let def = parse_def(st, sd);\n+    let an_arg: constr_arg_general_[T];\n+    do  {\n         an_arg = pser(st, sd);\n         // FIXME use a real span\n         args += ~[@respan(sp, an_arg)];\n         ignore = next(st) as char;\n-    } while (ignore == ';');\n-    assert(ignore == ')');\n-    ret @respan(sp, rec(path=pth, args=args, id=def));\n+    } while ignore == ';'\n+    assert (ignore == ')');\n+    ret @respan(sp, {path: pth, args: args, id: def});\n }\n \n-fn parse_ty(@pstate st, str_def sd) -> ty::t {\n-    alt (next(st) as char) {\n-        case ('n') { ret ty::mk_nil(st.tcx); }\n-        case ('z') { ret ty::mk_bot(st.tcx); }\n-        case ('b') { ret ty::mk_bool(st.tcx); }\n-        case ('i') { ret ty::mk_int(st.tcx); }\n-        case ('u') { ret ty::mk_uint(st.tcx); }\n-        case ('l') { ret ty::mk_float(st.tcx); }\n-        case ('M') {\n-            alt (next(st) as char) {\n-                case ('b') { ret ty::mk_mach(st.tcx, ast::ty_u8); }\n-                case ('w') { ret ty::mk_mach(st.tcx, ast::ty_u16); }\n-                case ('l') { ret ty::mk_mach(st.tcx, ast::ty_u32); }\n-                case ('d') { ret ty::mk_mach(st.tcx, ast::ty_u64); }\n-                case ('B') { ret ty::mk_mach(st.tcx, ast::ty_i8); }\n-                case ('W') { ret ty::mk_mach(st.tcx, ast::ty_i16); }\n-                case ('L') { ret ty::mk_mach(st.tcx, ast::ty_i32); }\n-                case ('D') { ret ty::mk_mach(st.tcx, ast::ty_i64); }\n-                case ('f') { ret ty::mk_mach(st.tcx, ast::ty_f32); }\n-                case ('F') { ret ty::mk_mach(st.tcx, ast::ty_f64); }\n-            }\n-        }\n-        case ('c') { ret ty::mk_char(st.tcx); }\n-        case ('s') { ret ty::mk_str(st.tcx); }\n-        case ('S') { ret ty::mk_istr(st.tcx); }\n-        case ('t') {\n-            assert (next(st) as char == '[');\n-            auto def = parse_def(st, sd);\n-            let ty::t[] params = ~[];\n-            while (peek(st) as char != ']') { params += ~[parse_ty(st, sd)]; }\n-            st.pos = st.pos + 1u;\n-            ret ty::mk_tag(st.tcx, def, params);\n+fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n+    alt next(st) as char {\n+      'n' { ret ty::mk_nil(st.tcx); }\n+      'z' { ret ty::mk_bot(st.tcx); }\n+      'b' { ret ty::mk_bool(st.tcx); }\n+      'i' { ret ty::mk_int(st.tcx); }\n+      'u' { ret ty::mk_uint(st.tcx); }\n+      'l' { ret ty::mk_float(st.tcx); }\n+      'M' {\n+        alt next(st) as char {\n+          'b' { ret ty::mk_mach(st.tcx, ast::ty_u8); }\n+          'w' { ret ty::mk_mach(st.tcx, ast::ty_u16); }\n+          'l' { ret ty::mk_mach(st.tcx, ast::ty_u32); }\n+          'd' { ret ty::mk_mach(st.tcx, ast::ty_u64); }\n+          'B' { ret ty::mk_mach(st.tcx, ast::ty_i8); }\n+          'W' { ret ty::mk_mach(st.tcx, ast::ty_i16); }\n+          'L' { ret ty::mk_mach(st.tcx, ast::ty_i32); }\n+          'D' { ret ty::mk_mach(st.tcx, ast::ty_i64); }\n+          'f' { ret ty::mk_mach(st.tcx, ast::ty_f32); }\n+          'F' { ret ty::mk_mach(st.tcx, ast::ty_f64); }\n         }\n-        case ('p') { ret ty::mk_param(st.tcx, parse_int(st) as uint); }\n-        case ('@') { ret ty::mk_box(st.tcx, parse_mt(st, sd)); }\n-        case ('*') { ret ty::mk_ptr(st.tcx, parse_mt(st, sd)); }\n-        case ('V') { ret ty::mk_vec(st.tcx, parse_mt(st, sd)); }\n-        case ('I') { ret ty::mk_ivec(st.tcx, parse_mt(st, sd)); }\n-        case ('a') { ret ty::mk_task(st.tcx); }\n-        case ('P') { ret ty::mk_port(st.tcx, parse_ty(st, sd)); }\n-        case ('C') { ret ty::mk_chan(st.tcx, parse_ty(st, sd)); }\n-        case ('R') {\n-            assert (next(st) as char == '[');\n-            let ty::field[] fields = ~[];\n-            while (peek(st) as char != ']') {\n-                auto name = \"\";\n-                while (peek(st) as char != '=') {\n-                    name += str::unsafe_from_byte(next(st));\n-                }\n-                st.pos = st.pos + 1u;\n-                fields += ~[rec(ident=name, mt=parse_mt(st, sd))];\n+      }\n+      'c' { ret ty::mk_char(st.tcx); }\n+      's' { ret ty::mk_str(st.tcx); }\n+      'S' { ret ty::mk_istr(st.tcx); }\n+      't' {\n+        assert (next(st) as char == '[');\n+        let def = parse_def(st, sd);\n+        let params: ty::t[] = ~[];\n+        while peek(st) as char != ']' { params += ~[parse_ty(st, sd)]; }\n+        st.pos = st.pos + 1u;\n+        ret ty::mk_tag(st.tcx, def, params);\n+      }\n+      'p' { ret ty::mk_param(st.tcx, parse_int(st) as uint); }\n+      '@' { ret ty::mk_box(st.tcx, parse_mt(st, sd)); }\n+      '*' { ret ty::mk_ptr(st.tcx, parse_mt(st, sd)); }\n+      'V' { ret ty::mk_vec(st.tcx, parse_mt(st, sd)); }\n+      'I' { ret ty::mk_ivec(st.tcx, parse_mt(st, sd)); }\n+      'a' { ret ty::mk_task(st.tcx); }\n+      'P' { ret ty::mk_port(st.tcx, parse_ty(st, sd)); }\n+      'C' { ret ty::mk_chan(st.tcx, parse_ty(st, sd)); }\n+      'R' {\n+        assert (next(st) as char == '[');\n+        let fields: ty::field[] = ~[];\n+        while peek(st) as char != ']' {\n+            let name = \"\";\n+            while peek(st) as char != '=' {\n+                name += str::unsafe_from_byte(next(st));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty::mk_rec(st.tcx, fields);\n-        }\n-        case ('F') {\n-            auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_fn, func.args, func.ty, func.cf,\n-                          func.cs);\n-        }\n-        case ('W') {\n-            auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_iter, func.args, func.ty,\n-                          func.cf, func.cs);\n-        }\n-        case ('B') {\n-            auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_block, func.args, func.ty,\n-                          func.cf, func.cs);\n+            fields += ~[{ident: name, mt: parse_mt(st, sd)}];\n         }\n-        case ('N') {\n-            auto abi;\n-            alt (next(st) as char) {\n-                case ('r') { abi = ast::native_abi_rust; }\n-                case ('i') { abi = ast::native_abi_rust_intrinsic; }\n-                case ('c') { abi = ast::native_abi_cdecl; }\n-                case ('l') { abi = ast::native_abi_llvm; }\n-                case ('s') { abi = ast::native_abi_x86stdcall; }\n-            }\n-            auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_native_fn(st.tcx, abi, func.args, func.ty);\n+        st.pos = st.pos + 1u;\n+        ret ty::mk_rec(st.tcx, fields);\n+      }\n+      'F' {\n+        let func = parse_ty_fn(st, sd);\n+        ret ty::mk_fn(st.tcx, ast::proto_fn, func.args, func.ty, func.cf,\n+                      func.cs);\n+      }\n+      'W' {\n+        let func = parse_ty_fn(st, sd);\n+        ret ty::mk_fn(st.tcx, ast::proto_iter, func.args, func.ty, func.cf,\n+                      func.cs);\n+      }\n+      'B' {\n+        let func = parse_ty_fn(st, sd);\n+        ret ty::mk_fn(st.tcx, ast::proto_block, func.args, func.ty, func.cf,\n+                      func.cs);\n+      }\n+      'N' {\n+        let abi;\n+        alt next(st) as char {\n+          'r' { abi = ast::native_abi_rust; }\n+          'i' { abi = ast::native_abi_rust_intrinsic; }\n+          'c' { abi = ast::native_abi_cdecl; }\n+          'l' { abi = ast::native_abi_llvm; }\n+          's' { abi = ast::native_abi_x86stdcall; }\n         }\n-        case ('O') {\n-            assert (next(st) as char == '[');\n-            let ty::method[] methods = ~[];\n-            while (peek(st) as char != ']') {\n-                auto proto;\n-                alt (next(st) as char) {\n-                    case ('W') { proto = ast::proto_iter; }\n-                    case ('F') { proto = ast::proto_fn; }\n-                }\n-                auto name = \"\";\n-                while (peek(st) as char != '[') {\n-                    name += str::unsafe_from_byte(next(st));\n-                }\n-                auto func = parse_ty_fn(st, sd);\n-                methods +=\n-                    ~[rec(proto=proto,\n-                          ident=name,\n-                          inputs=func.args,\n-                          output=func.ty,\n-                          cf=func.cf,\n-                          constrs=func.cs)];\n+        let func = parse_ty_fn(st, sd);\n+        ret ty::mk_native_fn(st.tcx, abi, func.args, func.ty);\n+      }\n+      'O' {\n+        assert (next(st) as char == '[');\n+        let methods: ty::method[] = ~[];\n+        while peek(st) as char != ']' {\n+            let proto;\n+            alt next(st) as char {\n+              'W' { proto = ast::proto_iter; }\n+              'F' { proto = ast::proto_fn; }\n             }\n-            st.pos += 1u;\n-            ret ty::mk_obj(st.tcx, methods);\n-        }\n-        case ('r') {\n-            assert (next(st) as char == '[');\n-            auto def = parse_def(st, sd);\n-            auto inner = parse_ty(st, sd);\n-            let ty::t[] params = ~[];\n-            while (peek(st) as char != ']') { params += ~[parse_ty(st, sd)]; }\n-            st.pos = st.pos + 1u;\n-            ret ty::mk_res(st.tcx, def, inner, params);\n-        }\n-        case ('X') { ret ty::mk_var(st.tcx, parse_int(st)); }\n-        case ('E') {\n-            auto def = parse_def(st, sd);\n-            ret ty::mk_native(st.tcx, def);\n-        }\n-        case ('Y') { ret ty::mk_type(st.tcx); }\n-        case ('#') {\n-            auto pos = parse_hex(st);\n-            assert (next(st) as char == ':');\n-            auto len = parse_hex(st);\n-            assert (next(st) as char == '#');\n-            alt (st.tcx.rcache.find(rec(cnum=st.crate, pos=pos, len=len))) {\n-                case (some(?tt)) { ret tt; }\n-                case (none) {\n-                    auto ps = @rec(pos=pos, len=len with *st);\n-                    auto tt = parse_ty(ps, sd);\n-                    st.tcx.rcache.insert(rec(cnum=st.crate, pos=pos, len=len),\n-                                         tt);\n-                    ret tt;\n-                }\n+            let name = \"\";\n+            while peek(st) as char != '[' {\n+                name += str::unsafe_from_byte(next(st));\n             }\n+            let func = parse_ty_fn(st, sd);\n+            methods +=\n+                ~[{proto: proto,\n+                   ident: name,\n+                   inputs: func.args,\n+                   output: func.ty,\n+                   cf: func.cf,\n+                   constrs: func.cs}];\n         }\n-        case ('A') {\n-            assert (next(st) as char == '[');\n-            auto tt = parse_ty(st, sd);\n-            auto tcs = parse_ty_constrs(st, sd);\n-            assert (next(st) as char == ']');\n-            ret ty::mk_constr(st.tcx, tt, tcs);\n-        }\n-        case (?c) {\n-            log_err \"unexpected char in type string: \";\n-            log_err c;\n-            fail;\n+        st.pos += 1u;\n+        ret ty::mk_obj(st.tcx, methods);\n+      }\n+      'r' {\n+        assert (next(st) as char == '[');\n+        let def = parse_def(st, sd);\n+        let inner = parse_ty(st, sd);\n+        let params: ty::t[] = ~[];\n+        while peek(st) as char != ']' { params += ~[parse_ty(st, sd)]; }\n+        st.pos = st.pos + 1u;\n+        ret ty::mk_res(st.tcx, def, inner, params);\n+      }\n+      'X' { ret ty::mk_var(st.tcx, parse_int(st)); }\n+      'E' { let def = parse_def(st, sd); ret ty::mk_native(st.tcx, def); }\n+      'Y' { ret ty::mk_type(st.tcx); }\n+      '#' {\n+        let pos = parse_hex(st);\n+        assert (next(st) as char == ':');\n+        let len = parse_hex(st);\n+        assert (next(st) as char == '#');\n+        alt st.tcx.rcache.find({cnum: st.crate, pos: pos, len: len}) {\n+          some(tt) { ret tt; }\n+          none. {\n+            let ps = @{pos: pos, len: len with *st};\n+            let tt = parse_ty(ps, sd);\n+            st.tcx.rcache.insert({cnum: st.crate, pos: pos, len: len}, tt);\n+            ret tt;\n+          }\n         }\n+      }\n+      'A' {\n+        assert (next(st) as char == '[');\n+        let tt = parse_ty(st, sd);\n+        let tcs = parse_ty_constrs(st, sd);\n+        assert (next(st) as char == ']');\n+        ret ty::mk_constr(st.tcx, tt, tcs);\n+      }\n+      c { log_err \"unexpected char in type string: \"; log_err c; fail; }\n     }\n }\n \n-fn parse_mt(@pstate st, str_def sd) -> ty::mt {\n-    auto mut;\n-    alt (peek(st) as char) {\n-        case ('m') { next(st); mut = ast::mut; }\n-        case ('?') { next(st); mut = ast::maybe_mut; }\n-        case (_) { mut = ast::imm; }\n+fn parse_mt(st: @pstate, sd: str_def) -> ty::mt {\n+    let mut;\n+    alt peek(st) as char {\n+      'm' { next(st); mut = ast::mut; }\n+      '?' { next(st); mut = ast::maybe_mut; }\n+      _ { mut = ast::imm; }\n     }\n-    ret rec(ty=parse_ty(st, sd), mut=mut);\n+    ret {ty: parse_ty(st, sd), mut: mut};\n }\n \n-fn parse_def(@pstate st, str_def sd) -> ast::def_id {\n-    auto def = \"\";\n-    while (peek(st) as char != '|') {\n-        def += str::unsafe_from_byte(next(st));\n-    }\n+fn parse_def(st: @pstate, sd: str_def) -> ast::def_id {\n+    let def = \"\";\n+    while peek(st) as char != '|' { def += str::unsafe_from_byte(next(st)); }\n     st.pos = st.pos + 1u;\n     ret sd(def);\n }\n \n-fn parse_int(@pstate st) -> int {\n-    auto n = 0;\n-    while (true) {\n-        auto cur = peek(st) as char;\n-        if (cur < '0' || cur > '9') { break; }\n+fn parse_int(st: @pstate) -> int {\n+    let n = 0;\n+    while true {\n+        let cur = peek(st) as char;\n+        if cur < '0' || cur > '9' { break; }\n         st.pos = st.pos + 1u;\n         n *= 10;\n         n += (cur as int) - ('0' as int);\n     }\n     ret n;\n }\n \n-fn parse_hex(@pstate st) -> uint {\n-    auto n = 0u;\n-    while (true) {\n-        auto cur = peek(st) as char;\n-        if ((cur < '0' || cur > '9') && (cur < 'a' || cur > 'f')) { break; }\n+fn parse_hex(st: @pstate) -> uint {\n+    let n = 0u;\n+    while true {\n+        let cur = peek(st) as char;\n+        if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { break; }\n         st.pos = st.pos + 1u;\n         n *= 16u;\n-        if ('0' <= cur && cur <= '9') {\n+        if '0' <= cur && cur <= '9' {\n             n += (cur as uint) - ('0' as uint);\n         } else { n += 10u + (cur as uint) - ('a' as uint); }\n     }\n     ret n;\n }\n \n-fn parse_ty_fn(@pstate st, str_def sd) ->\n-    rec(ty::arg[] args, ty::t ty, ast::controlflow cf, (@ty::constr)[] cs) {\n+fn parse_ty_fn(st: @pstate, sd: str_def) ->\n+   {args: ty::arg[], ty: ty::t, cf: ast::controlflow, cs: (@ty::constr)[]} {\n     assert (next(st) as char == '[');\n-    let ty::arg[] inputs = ~[];\n-    while (peek(st) as char != ']') {\n-        auto mode = ty::mo_val;\n-        if (peek(st) as char == '&') {\n+    let inputs: ty::arg[] = ~[];\n+    while peek(st) as char != ']' {\n+        let mode = ty::mo_val;\n+        if peek(st) as char == '&' {\n             mode = ty::mo_alias(false);\n             st.pos += 1u;\n-            if (peek(st) as char == 'm') {\n+            if peek(st) as char == 'm' {\n                 mode = ty::mo_alias(true);\n                 st.pos += 1u;\n             }\n         }\n-        inputs += ~[rec(mode=mode, ty=parse_ty(st, sd))];\n+        inputs += ~[{mode: mode, ty: parse_ty(st, sd)}];\n     }\n     st.pos += 1u; // eat the ']'\n-    auto cs = parse_constrs(st, sd);\n-    alt (parse_ty_or_bang(st, sd)) {\n-        case (a_bang) {\n-            ret rec(args=inputs, ty=ty::mk_bot(st.tcx),\n-                    cf=ast::noreturn, cs=cs);\n-        }\n-        case (a_ty(?t)) {\n-          ret rec(args=inputs, ty=t, cf=ast::return, cs=cs);\n-        }\n+    let cs = parse_constrs(st, sd);\n+    alt parse_ty_or_bang(st, sd) {\n+      a_bang. {\n+        ret {args: inputs, ty: ty::mk_bot(st.tcx), cf: ast::noreturn, cs: cs};\n+      }\n+      a_ty(t) { ret {args: inputs, ty: t, cf: ast::return, cs: cs}; }\n     }\n }\n \n \n // Rust metadata parsing\n-fn parse_def_id(&u8[] buf) -> ast::def_id {\n-    auto colon_idx = 0u;\n-    auto len = ivec::len[u8](buf);\n-    while (colon_idx < len && buf.(colon_idx) != ':' as u8) {\n-        colon_idx += 1u;\n-    }\n-    if (colon_idx == len) {\n+fn parse_def_id(buf: &u8[]) -> ast::def_id {\n+    let colon_idx = 0u;\n+    let len = ivec::len[u8](buf);\n+    while colon_idx < len && buf.(colon_idx) != ':' as u8 { colon_idx += 1u; }\n+    if colon_idx == len {\n         log_err \"didn't find ':' when parsing def id\";\n         fail;\n     }\n-    auto crate_part = ivec::slice[u8](buf, 0u, colon_idx);\n-    auto def_part = ivec::slice[u8](buf, colon_idx + 1u, len);\n+    let crate_part = ivec::slice[u8](buf, 0u, colon_idx);\n+    let def_part = ivec::slice[u8](buf, colon_idx + 1u, len);\n \n     // FIXME: Remove these ivec->vec conversions.\n-    auto crate_part_vec = []; auto def_part_vec = [];\n-    for (u8 b in crate_part) { crate_part_vec += [b]; }\n-    for (u8 b in def_part) { def_part_vec += [b]; }\n+    let crate_part_vec = [];\n+    let def_part_vec = [];\n+    for b: u8  in crate_part { crate_part_vec += [b]; }\n+    for b: u8  in def_part { def_part_vec += [b]; }\n \n-    auto crate_num = uint::parse_buf(crate_part_vec, 10u) as int;\n-    auto def_num = uint::parse_buf(def_part_vec, 10u) as int;\n-    ret rec(crate=crate_num, node=def_num);\n+    let crate_num = uint::parse_buf(crate_part_vec, 10u) as int;\n+    let def_num = uint::parse_buf(def_part_vec, 10u) as int;\n+    ret {crate: crate_num, node: def_num};\n }\n \n //"}, {"sha": "be9837c75046d7781f7361faf6c70a47da0de150", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 176, "deletions": 195, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -17,256 +17,237 @@ export ac_no_abbrevs;\n export ac_use_abbrevs;\n export enc_ty;\n \n-type ctxt =\n-    rec(fn(&def_id) -> str  ds, // Def -> str Callback:\n-        ty::ctxt tcx, // The type context.\n-        abbrev_ctxt abbrevs);\n+type ctxt =  // Def -> str Callback:\n+     // The type context.\n+    {ds: fn(&def_id) -> str , tcx: ty::ctxt, abbrevs: abbrev_ctxt};\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n-type ty_abbrev = rec(uint pos, uint len, str s);\n+type ty_abbrev = {pos: uint, len: uint, s: str};\n \n tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap[ty::t, ty_abbrev]); }\n \n-fn cx_uses_abbrevs(&@ctxt cx) -> bool {\n-    alt (cx.abbrevs) {\n-        case (ac_no_abbrevs) { ret false; }\n-        case (ac_use_abbrevs(_)) { ret true; }\n+fn cx_uses_abbrevs(cx: &@ctxt) -> bool {\n+    alt cx.abbrevs {\n+      ac_no_abbrevs. { ret false; }\n+      ac_use_abbrevs(_) { ret true; }\n     }\n }\n \n-fn enc_ty(&ioivec::writer w, &@ctxt cx, &ty::t t) {\n-    alt (cx.abbrevs) {\n-        case (ac_no_abbrevs) {\n-            auto result_str;\n-            alt (cx.tcx.short_names_cache.find(t)) {\n-                case (some(?s)) { result_str = s; }\n-                case (none) {\n-                    auto sw = ioivec::string_writer();\n-                    enc_sty(sw.get_writer(), cx, ty::struct(cx.tcx, t));\n-                    result_str = sw.get_str();\n-                    cx.tcx.short_names_cache.insert(t, result_str);\n-                }\n-            }\n-            w.write_str(result_str);\n+fn enc_ty(w: &ioivec::writer, cx: &@ctxt, t: &ty::t) {\n+    alt cx.abbrevs {\n+      ac_no_abbrevs. {\n+        let result_str;\n+        alt cx.tcx.short_names_cache.find(t) {\n+          some(s) { result_str = s; }\n+          none. {\n+            let sw = ioivec::string_writer();\n+            enc_sty(sw.get_writer(), cx, ty::struct(cx.tcx, t));\n+            result_str = sw.get_str();\n+            cx.tcx.short_names_cache.insert(t, result_str);\n+          }\n         }\n-        case (ac_use_abbrevs(?abbrevs)) {\n-            alt (abbrevs.find(t)) {\n-                case (some(?a)) { w.write_str(a.s); ret; }\n-                case (none) {\n-                    auto pos = w.get_buf_writer().tell();\n-                    enc_sty(w, cx, ty::struct(cx.tcx, t));\n-                    auto end = w.get_buf_writer().tell();\n-                    auto len = end - pos;\n-                    fn estimate_sz(uint u) -> uint {\n-                        auto n = u;\n-                        auto len = 0u;\n-                        while (n != 0u) { len += 1u; n = n >> 4u; }\n-                        ret len;\n-                    }\n-                    auto abbrev_len =\n-                        3u + estimate_sz(pos) + estimate_sz(len);\n-                    if (abbrev_len < len) {\n-                        // I.e. it's actually an abbreviation.\n+        w.write_str(result_str);\n+      }\n+      ac_use_abbrevs(abbrevs) {\n+        alt abbrevs.find(t) {\n+          some(a) { w.write_str(a.s); ret; }\n+          none. {\n+            let pos = w.get_buf_writer().tell();\n+            enc_sty(w, cx, ty::struct(cx.tcx, t));\n+            let end = w.get_buf_writer().tell();\n+            let len = end - pos;\n+            fn estimate_sz(u: uint) -> uint {\n+                let n = u;\n+                let len = 0u;\n+                while n != 0u { len += 1u; n = n >> 4u; }\n+                ret len;\n+            }\n+            let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n+            if abbrev_len < len {\n+                // I.e. it's actually an abbreviation.\n \n-                        auto s =\n-                            \"#\" + uint::to_str(pos, 16u) + \":\" +\n-                            uint::to_str(len, 16u) + \"#\";\n-                        auto a = rec(pos=pos, len=len, s=s);\n-                        abbrevs.insert(t, a);\n-                    }\n-                    ret;\n-                }\n+                let s =\n+                    \"#\" + uint::to_str(pos, 16u) + \":\" +\n+                        uint::to_str(len, 16u) + \"#\";\n+                let a = {pos: pos, len: len, s: s};\n+                abbrevs.insert(t, a);\n             }\n+            ret;\n+          }\n         }\n+      }\n     }\n }\n-fn enc_mt(&ioivec::writer w, &@ctxt cx, &ty::mt mt) {\n-    alt (mt.mut) {\n-        case (imm) { }\n-        case (mut) { w.write_char('m'); }\n-        case (maybe_mut) { w.write_char('?'); }\n+fn enc_mt(w: &ioivec::writer, cx: &@ctxt, mt: &ty::mt) {\n+    alt mt.mut {\n+      imm. { }\n+      mut. { w.write_char('m'); }\n+      maybe_mut. { w.write_char('?'); }\n     }\n     enc_ty(w, cx, mt.ty);\n }\n-fn enc_sty(&ioivec::writer w, &@ctxt cx, &ty::sty st) {\n-    alt (st) {\n-        case (ty::ty_nil) { w.write_char('n'); }\n-        case (ty::ty_bot) { w.write_char('z'); }\n-        case (ty::ty_bool) { w.write_char('b'); }\n-        case (ty::ty_int) { w.write_char('i'); }\n-        case (ty::ty_uint) { w.write_char('u'); }\n-        case (ty::ty_float) { w.write_char('l'); }\n-        case (ty::ty_machine(?mach)) {\n-            alt (mach) {\n-                case (ty_u8) { w.write_str(\"Mb\"); }\n-                case (ty_u16) { w.write_str(\"Mw\"); }\n-                case (ty_u32) { w.write_str(\"Ml\"); }\n-                case (ty_u64) { w.write_str(\"Md\"); }\n-                case (ty_i8) { w.write_str(\"MB\"); }\n-                case (ty_i16) { w.write_str(\"MW\"); }\n-                case (ty_i32) { w.write_str(\"ML\"); }\n-                case (ty_i64) { w.write_str(\"MD\"); }\n-                case (ty_f32) { w.write_str(\"Mf\"); }\n-                case (ty_f64) { w.write_str(\"MF\"); }\n-            }\n-        }\n-        case (ty::ty_char) { w.write_char('c'); }\n-        case (ty::ty_str) { w.write_char('s'); }\n-        case (ty::ty_istr) { w.write_char('S'); }\n-        case (ty::ty_tag(?def, ?tys)) {\n-            w.write_str(\"t[\");\n-            w.write_str(cx.ds(def));\n-            w.write_char('|');\n-            for (ty::t t in tys) { enc_ty(w, cx, t); }\n-            w.write_char(']');\n-        }\n-        case (ty::ty_box(?mt)) { w.write_char('@'); enc_mt(w, cx, mt); }\n-        case (ty::ty_ptr(?mt)) { w.write_char('*'); enc_mt(w, cx, mt); }\n-        case (ty::ty_vec(?mt)) { w.write_char('V'); enc_mt(w, cx, mt); }\n-        case (ty::ty_ivec(?mt)) { w.write_char('I'); enc_mt(w, cx, mt); }\n-        case (ty::ty_port(?t)) { w.write_char('P'); enc_ty(w, cx, t); }\n-        case (ty::ty_chan(?t)) { w.write_char('C'); enc_ty(w, cx, t); }\n-        case (ty::ty_rec(?fields)) {\n-            w.write_str(\"R[\");\n-            for (ty::field field in fields) {\n-                w.write_str(field.ident);\n-                w.write_char('=');\n-                enc_mt(w, cx, field.mt);\n-            }\n-            w.write_char(']');\n-        }\n-        case (ty::ty_fn(?proto, ?args, ?out, ?cf, ?constrs)) {\n-            enc_proto(w, proto);\n-            enc_ty_fn(w, cx, args, out, cf, constrs);\n-        }\n-        case (ty::ty_native_fn(?abi, ?args, ?out)) {\n-            w.write_char('N');\n-            alt (abi) {\n-                case (native_abi_rust) { w.write_char('r'); }\n-                case (native_abi_rust_intrinsic) {\n-                    w.write_char('i');\n-                }\n-                case (native_abi_cdecl) { w.write_char('c'); }\n-                case (native_abi_llvm) { w.write_char('l'); }\n-                case (native_abi_x86stdcall) { w.write_char('s'); }\n-            }\n-            enc_ty_fn(w, cx, args, out, return, ~[]);\n+fn enc_sty(w: &ioivec::writer, cx: &@ctxt, st: &ty::sty) {\n+    alt st {\n+      ty::ty_nil. { w.write_char('n'); }\n+      ty::ty_bot. { w.write_char('z'); }\n+      ty::ty_bool. { w.write_char('b'); }\n+      ty::ty_int. { w.write_char('i'); }\n+      ty::ty_uint. { w.write_char('u'); }\n+      ty::ty_float. { w.write_char('l'); }\n+      ty::ty_machine(mach) {\n+        alt mach {\n+          ty_u8. { w.write_str(\"Mb\"); }\n+          ty_u16. { w.write_str(\"Mw\"); }\n+          ty_u32. { w.write_str(\"Ml\"); }\n+          ty_u64. { w.write_str(\"Md\"); }\n+          ty_i8. { w.write_str(\"MB\"); }\n+          ty_i16. { w.write_str(\"MW\"); }\n+          ty_i32. { w.write_str(\"ML\"); }\n+          ty_i64. { w.write_str(\"MD\"); }\n+          ty_f32. { w.write_str(\"Mf\"); }\n+          ty_f64. { w.write_str(\"MF\"); }\n         }\n-        case (ty::ty_obj(?methods)) {\n-            w.write_str(\"O[\");\n-            for (ty::method m in methods) {\n-                enc_proto(w, m.proto);\n-                w.write_str(m.ident);\n-                enc_ty_fn(w, cx, m.inputs, m.output, m.cf, m.constrs);\n-            }\n-            w.write_char(']');\n-        }\n-        case (ty::ty_res(?def, ?ty, ?tps)) {\n-            w.write_str(\"r[\");\n-            w.write_str(cx.ds(def));\n-            w.write_char('|');\n-            enc_ty(w, cx, ty);\n-            for (ty::t t in tps) { enc_ty(w, cx, t); }\n-            w.write_char(']');\n-        }\n-        case (ty::ty_var(?id)) {\n-            w.write_char('X');\n-            w.write_str(int::str(id));\n+      }\n+      ty::ty_char. { w.write_char('c'); }\n+      ty::ty_str. { w.write_char('s'); }\n+      ty::ty_istr. { w.write_char('S'); }\n+      ty::ty_tag(def, tys) {\n+        w.write_str(\"t[\");\n+        w.write_str(cx.ds(def));\n+        w.write_char('|');\n+        for t: ty::t  in tys { enc_ty(w, cx, t); }\n+        w.write_char(']');\n+      }\n+      ty::ty_box(mt) { w.write_char('@'); enc_mt(w, cx, mt); }\n+      ty::ty_ptr(mt) { w.write_char('*'); enc_mt(w, cx, mt); }\n+      ty::ty_vec(mt) { w.write_char('V'); enc_mt(w, cx, mt); }\n+      ty::ty_ivec(mt) { w.write_char('I'); enc_mt(w, cx, mt); }\n+      ty::ty_port(t) { w.write_char('P'); enc_ty(w, cx, t); }\n+      ty::ty_chan(t) { w.write_char('C'); enc_ty(w, cx, t); }\n+      ty::ty_rec(fields) {\n+        w.write_str(\"R[\");\n+        for field: ty::field  in fields {\n+            w.write_str(field.ident);\n+            w.write_char('=');\n+            enc_mt(w, cx, field.mt);\n         }\n-        case (ty::ty_native(?def)) {\n-            w.write_char('E');\n-            w.write_str(cx.ds(def));\n-            w.write_char('|');\n+        w.write_char(']');\n+      }\n+      ty::ty_fn(proto, args, out, cf, constrs) {\n+        enc_proto(w, proto);\n+        enc_ty_fn(w, cx, args, out, cf, constrs);\n+      }\n+      ty::ty_native_fn(abi, args, out) {\n+        w.write_char('N');\n+        alt abi {\n+          native_abi_rust. { w.write_char('r'); }\n+          native_abi_rust_intrinsic. { w.write_char('i'); }\n+          native_abi_cdecl. { w.write_char('c'); }\n+          native_abi_llvm. { w.write_char('l'); }\n+          native_abi_x86stdcall. { w.write_char('s'); }\n         }\n-        case (ty::ty_param(?id)) {\n-            w.write_char('p');\n-            w.write_str(uint::str(id));\n-        }\n-        case (ty::ty_type) { w.write_char('Y'); }\n-        case (ty::ty_task) { w.write_char('a'); }\n-        case (ty::ty_constr(?ty, ?cs)) {\n-            w.write_str(\"A[\");\n-            enc_ty(w, cx, ty);\n-            for (@ty::type_constr tc in cs) {\n-                enc_ty_constr(w, cx, tc);\n-            }\n-            w.write_char(']');\n+        enc_ty_fn(w, cx, args, out, return, ~[]);\n+      }\n+      ty::ty_obj(methods) {\n+        w.write_str(\"O[\");\n+        for m: ty::method  in methods {\n+            enc_proto(w, m.proto);\n+            w.write_str(m.ident);\n+            enc_ty_fn(w, cx, m.inputs, m.output, m.cf, m.constrs);\n         }\n+        w.write_char(']');\n+      }\n+      ty::ty_res(def, ty, tps) {\n+        w.write_str(\"r[\");\n+        w.write_str(cx.ds(def));\n+        w.write_char('|');\n+        enc_ty(w, cx, ty);\n+        for t: ty::t  in tps { enc_ty(w, cx, t); }\n+        w.write_char(']');\n+      }\n+      ty::ty_var(id) { w.write_char('X'); w.write_str(int::str(id)); }\n+      ty::ty_native(def) {\n+        w.write_char('E');\n+        w.write_str(cx.ds(def));\n+        w.write_char('|');\n+      }\n+      ty::ty_param(id) { w.write_char('p'); w.write_str(uint::str(id)); }\n+      ty::ty_type. { w.write_char('Y'); }\n+      ty::ty_task. { w.write_char('a'); }\n+      ty::ty_constr(ty, cs) {\n+        w.write_str(\"A[\");\n+        enc_ty(w, cx, ty);\n+        for tc: @ty::type_constr  in cs { enc_ty_constr(w, cx, tc); }\n+        w.write_char(']');\n+      }\n     }\n }\n-fn enc_proto(&ioivec::writer w, proto proto) {\n-    alt (proto) {\n-        case (proto_iter) { w.write_char('W'); }\n-        case (proto_fn) { w.write_char('F'); }\n-        case (proto_block) { w.write_char('B'); }\n+fn enc_proto(w: &ioivec::writer, proto: proto) {\n+    alt proto {\n+      proto_iter. { w.write_char('W'); }\n+      proto_fn. { w.write_char('F'); }\n+      proto_block. { w.write_char('B'); }\n     }\n }\n \n-fn enc_ty_fn(&ioivec::writer w, &@ctxt cx, &ty::arg[] args, &ty::t out,\n-             &controlflow cf, &(@ty::constr)[] constrs) {\n+fn enc_ty_fn(w: &ioivec::writer, cx: &@ctxt, args: &ty::arg[], out: &ty::t,\n+             cf: &controlflow, constrs: &(@ty::constr)[]) {\n     w.write_char('[');\n-    for (ty::arg arg in args) {\n-        alt (arg.mode) {\n-            case (ty::mo_alias(?mut)) {\n-                w.write_char('&');\n-                if (mut) { w.write_char('m'); }\n-            }\n-            case (ty::mo_val) { }\n+    for arg: ty::arg  in args {\n+        alt arg.mode {\n+          ty::mo_alias(mut) {\n+            w.write_char('&');\n+            if mut { w.write_char('m'); }\n+          }\n+          ty::mo_val. { }\n         }\n         enc_ty(w, cx, arg.ty);\n     }\n     w.write_char(']');\n-    auto colon = true;\n-    for (@ty::constr c in constrs) {\n-        if (colon) {\n+    let colon = true;\n+    for c: @ty::constr  in constrs {\n+        if colon {\n             w.write_char(':');\n             colon = false;\n         } else { w.write_char(';'); }\n         enc_constr(w, cx, c);\n     }\n-    alt (cf) {\n-        case (noreturn) { w.write_char('!'); }\n-        case (_) { enc_ty(w, cx, out); }\n-    }\n+    alt cf { noreturn. { w.write_char('!'); } _ { enc_ty(w, cx, out); } }\n \n }\n \n // FIXME less copy-and-paste\n-fn enc_constr(&ioivec::writer w, &@ctxt cx, &@ty::constr c) {\n+fn enc_constr(w: &ioivec::writer, cx: &@ctxt, c: &@ty::constr) {\n     w.write_str(path_to_str(c.node.path));\n     w.write_char('(');\n     w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n-    auto semi = false;\n-    for (@constr_arg a in c.node.args) {\n-        if (semi) { w.write_char(';'); } else { semi = true; }\n-        alt (a.node) {\n-            case (carg_base) { w.write_char('*'); }\n-            case (carg_ident(?i)) {\n-                w.write_uint(i);\n-            }\n-            case (carg_lit(?l)) { w.write_str(lit_to_str(l)); }\n+    let semi = false;\n+    for a: @constr_arg  in c.node.args {\n+        if semi { w.write_char(';'); } else { semi = true; }\n+        alt a.node {\n+          carg_base. { w.write_char('*'); }\n+          carg_ident(i) { w.write_uint(i); }\n+          carg_lit(l) { w.write_str(lit_to_str(l)); }\n         }\n     }\n     w.write_char(')');\n }\n \n-fn enc_ty_constr(&ioivec::writer w, &@ctxt cx, &@ty::type_constr c) {\n+fn enc_ty_constr(w: &ioivec::writer, cx: &@ctxt, c: &@ty::type_constr) {\n     w.write_str(path_to_str(c.node.path));\n     w.write_char('(');\n     w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n-    auto semi = false;\n-    for (@ty::ty_constr_arg a in c.node.args) {\n-        if (semi) { w.write_char(';'); } else { semi = true; }\n-        alt (a.node) {\n-            case (carg_base) { w.write_char('*'); }\n-            case (carg_ident(?p)) {\n-                w.write_str(path_to_str(p));\n-            }\n-            case (carg_lit(?l)) { w.write_str(lit_to_str(l)); }\n+    let semi = false;\n+    for a: @ty::ty_constr_arg  in c.node.args {\n+        if semi { w.write_char(';'); } else { semi = true; }\n+        alt a.node {\n+          carg_base. { w.write_char('*'); }\n+          carg_ident(p) { w.write_str(path_to_str(p)); }\n+          carg_lit(l) { w.write_str(lit_to_str(l)); }\n         }\n     }\n     w.write_char(')');"}, {"sha": "f958b88e76e36ceadee24972503579fef801c398", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 444, "deletions": 448, "changes": 892, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -25,192 +25,185 @@ import std::option::is_none;\n tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n \n type restrict =\n-    @rec(node_id[] root_vars,\n-         node_id block_defnum,\n-         node_id[] bindings,\n-         ty::t[] tys,\n-         uint[] depends_on,\n-         mutable valid ok);\n+    @{root_vars: node_id[],\n+      block_defnum: node_id,\n+      bindings: node_id[],\n+      tys: ty::t[],\n+      depends_on: uint[],\n+      mutable ok: valid};\n \n type scope = @restrict[];\n \n tag local_info { arg(ast::mode); objfield(ast::mutability); }\n \n-type ctx = rec(ty::ctxt tcx,\n-               std::map::hashmap[node_id, local_info] local_map);\n-\n-fn check_crate(ty::ctxt tcx, &@ast::crate crate) {\n-    auto cx = @rec(tcx=tcx,\n-                   // Stores information about object fields and function\n-                   // arguments that's otherwise not easily available.\n-                   local_map=std::map::new_int_hash());\n-    auto v =\n-        @rec(visit_fn=bind visit_fn(cx, _, _, _, _, _, _, _),\n-             visit_item=bind visit_item(cx, _, _, _),\n-             visit_expr=bind visit_expr(cx, _, _, _),\n-             visit_decl=bind visit_decl(cx, _, _, _)\n-             with *visit::default_visitor[scope]());\n+type ctx = {tcx: ty::ctxt, local_map: std::map::hashmap[node_id, local_info]};\n+\n+fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n+    let \n+        // Stores information about object fields and function\n+        // arguments that's otherwise not easily available.\n+        cx =\n+        @{tcx: tcx, local_map: std::map::new_int_hash()};\n+    let v =\n+        @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n+          visit_item: bind visit_item(cx, _, _, _),\n+          visit_expr: bind visit_expr(cx, _, _, _),\n+          visit_decl: bind visit_decl(cx, _, _, _)\n+             with *visit::default_visitor[scope]()};\n     visit::visit_crate(*crate, @~[], visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n }\n \n-fn visit_fn(&@ctx cx, &ast::_fn f, &ast::ty_param[] tp, &span sp,\n-            &fn_ident name, ast::node_id id, &scope sc, &vt[scope] v) {\n+fn visit_fn(cx: &@ctx, f: &ast::_fn, tp: &ast::ty_param[], sp: &span,\n+            name: &fn_ident, id: ast::node_id, sc: &scope, v: &vt[scope]) {\n     visit::visit_fn_decl(f.decl, sc, v);\n-    for (ast::arg arg_ in f.decl.inputs) {\n+    for arg_: ast::arg  in f.decl.inputs {\n         cx.local_map.insert(arg_.id, arg(arg_.mode));\n     }\n     v.visit_block(f.body, @~[], v);\n }\n \n-fn visit_item(&@ctx cx, &@ast::item i, &scope sc, &vt[scope] v) {\n-    alt (i.node) {\n-        case (ast::item_obj(?o, _, _)) {\n-            for (ast::obj_field f in o.fields) {\n-                cx.local_map.insert(f.id, objfield(f.mut));\n-            }\n+fn visit_item(cx: &@ctx, i: &@ast::item, sc: &scope, v: &vt[scope]) {\n+    alt i.node {\n+      ast::item_obj(o, _, _) {\n+        for f: ast::obj_field  in o.fields {\n+            cx.local_map.insert(f.id, objfield(f.mut));\n         }\n-        case (_) { }\n+      }\n+      _ { }\n     }\n     visit::visit_item(i, sc, v);\n }\n \n-fn visit_expr(&@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n-    auto handled = true;\n-    alt (ex.node) {\n-        ast::expr_call(?f, ?args) {\n-            check_call(*cx, f, args, sc);\n-            handled = false;\n-        }\n-        ast::expr_be(?cl) {\n-            check_tail_call(*cx, cl);\n-            visit::visit_expr(cl, sc, v);\n-        }\n-        ast::expr_alt(?input, ?arms) {\n-            check_alt(*cx, input, arms, sc, v);\n-        }\n-        ast::expr_put(?val) {\n-            alt (val) {\n-                case (some(?ex)) {\n-                    auto root = expr_root(*cx, ex, false);\n-                    if (mut_field(root.ds)) {\n-                        cx.tcx.sess.span_err(ex.span,\n-                                             \"result of put must be\" +\n-                                                 \" immutably rooted\");\n-                    }\n-                    visit_expr(cx, ex, sc, v);\n-                }\n-                case (_) { }\n+fn visit_expr(cx: &@ctx, ex: &@ast::expr, sc: &scope, v: &vt[scope]) {\n+    let handled = true;\n+    alt ex.node {\n+      ast::expr_call(f, args) {\n+        check_call(*cx, f, args, sc);\n+        handled = false;\n+      }\n+      ast::expr_be(cl) {\n+        check_tail_call(*cx, cl);\n+        visit::visit_expr(cl, sc, v);\n+      }\n+      ast::expr_alt(input, arms) { check_alt(*cx, input, arms, sc, v); }\n+      ast::expr_put(val) {\n+        alt val {\n+          some(ex) {\n+            let root = expr_root(*cx, ex, false);\n+            if mut_field(root.ds) {\n+                cx.tcx.sess.span_err(ex.span,\n+                                     \"result of put must be\" +\n+                                         \" immutably rooted\");\n             }\n+            visit_expr(cx, ex, sc, v);\n+          }\n+          _ { }\n         }\n-        ast::expr_for_each(?decl, ?call, ?blk) {\n-            check_for_each(*cx, decl, call, blk, sc, v);\n-        }\n-        ast::expr_for(?decl, ?seq, ?blk) {\n-            check_for(*cx, decl, seq, blk, sc, v);\n-        }\n-        ast::expr_path(?pt) {\n-            check_var(*cx, ex, pt, ex.id, false, sc);\n-            handled = false;\n-        }\n-        ast::expr_swap(?lhs, ?rhs) {\n-            check_lval(cx, lhs, sc, v);\n-            check_lval(cx, rhs, sc, v);\n-            handled = false;\n-        }\n-        ast::expr_move(?dest, ?src) {\n-            check_assign(cx, dest, src, sc, v);\n-            check_move_rhs(cx, src, sc, v);\n-        }\n-        ast::expr_assign(?dest, ?src) | ast::expr_assign_op(_, ?dest, ?src) {\n-            check_assign(cx, dest, src, sc, v);\n-        }\n-        _ { handled = false; }\n+      }\n+      ast::expr_for_each(decl, call, blk) {\n+        check_for_each(*cx, decl, call, blk, sc, v);\n+      }\n+      ast::expr_for(decl, seq, blk) { check_for(*cx, decl, seq, blk, sc, v); }\n+      ast::expr_path(pt) {\n+        check_var(*cx, ex, pt, ex.id, false, sc);\n+        handled = false;\n+      }\n+      ast::expr_swap(lhs, rhs) {\n+        check_lval(cx, lhs, sc, v);\n+        check_lval(cx, rhs, sc, v);\n+        handled = false;\n+      }\n+      ast::expr_move(dest, src) {\n+        check_assign(cx, dest, src, sc, v);\n+        check_move_rhs(cx, src, sc, v);\n+      }\n+      ast::expr_assign(dest, src) | ast::expr_assign_op(_, dest, src) {\n+        check_assign(cx, dest, src, sc, v);\n+      }\n+      _ { handled = false; }\n     }\n-    if (!handled) { visit::visit_expr(ex, sc, v); }\n+    if !handled { visit::visit_expr(ex, sc, v); }\n }\n \n-fn visit_decl(&@ctx cx, &@ast::decl d, &scope sc, &vt[scope] v) {\n+fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt[scope]) {\n     visit::visit_decl(d, sc, v);\n-    alt (d.node) {\n-      ast::decl_local(?locs) {\n-        for (@ast::local loc in locs) {\n-            alt (loc.node.init) {\n-              some(?init) {\n-                if (init.op == ast::init_move) {\n+    alt d.node {\n+      ast::decl_local(locs) {\n+        for loc: @ast::local  in locs {\n+            alt loc.node.init {\n+              some(init) {\n+                if init.op == ast::init_move {\n                     check_move_rhs(cx, init.expr, sc, v);\n                 }\n               }\n-              none {}\n+              none. { }\n             }\n         }\n       }\n-      _ {}\n+      _ { }\n     }\n }\n \n-fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n-   rec(node_id[] root_vars, ty::t[] unsafe_ts) {\n-    auto fty = ty::expr_ty(cx.tcx, f);\n-    auto arg_ts = fty_args(cx, fty);\n-    let node_id[] roots = ~[];\n-    let rec(uint arg, node_id node)[] mut_roots = ~[];\n-    let ty::t[] unsafe_ts = ~[];\n-    let uint[] unsafe_t_offsets = ~[];\n-    auto i = 0u;\n-    for (ty::arg arg_t in arg_ts) {\n-        if (arg_t.mode != ty::mo_val) {\n-            auto arg = args.(i);\n-            auto root = expr_root(cx, arg, false);\n-            if (arg_t.mode == ty::mo_alias(true)) {\n-                alt (path_def_id(cx, arg)) {\n-                  some(?did) { mut_roots += ~[rec(arg=i, node=did.node)]; }\n+fn check_call(cx: &ctx, f: &@ast::expr, args: &(@ast::expr)[], sc: &scope) ->\n+   {root_vars: node_id[], unsafe_ts: ty::t[]} {\n+    let fty = ty::expr_ty(cx.tcx, f);\n+    let arg_ts = fty_args(cx, fty);\n+    let roots: node_id[] = ~[];\n+    let mut_roots: {arg: uint, node: node_id}[] = ~[];\n+    let unsafe_ts: ty::t[] = ~[];\n+    let unsafe_t_offsets: uint[] = ~[];\n+    let i = 0u;\n+    for arg_t: ty::arg  in arg_ts {\n+        if arg_t.mode != ty::mo_val {\n+            let arg = args.(i);\n+            let root = expr_root(cx, arg, false);\n+            if arg_t.mode == ty::mo_alias(true) {\n+                alt path_def_id(cx, arg) {\n+                  some(did) { mut_roots += ~[{arg: i, node: did.node}]; }\n                   _ {\n-                    if (!mut_field(root.ds)) {\n-                        auto m = \"passing a temporary value or \\\n+                    if !mut_field(root.ds) {\n+                        let m =\n+                            \"passing a temporary value or \\\n                                  immutable field by mutable alias\";\n                         cx.tcx.sess.span_err(arg.span, m);\n                     }\n                   }\n                 }\n             }\n-            alt (path_def_id(cx, root.ex)) {\n-              some(?did) { roots += ~[did.node]; }\n+            alt path_def_id(cx, root.ex) {\n+              some(did) { roots += ~[did.node]; }\n               _ { }\n             }\n-            alt (inner_mut(root.ds)) {\n-              some(?t) {\n-                unsafe_ts += ~[t];\n-                unsafe_t_offsets += ~[i];\n-              }\n+            alt inner_mut(root.ds) {\n+              some(t) { unsafe_ts += ~[t]; unsafe_t_offsets += ~[i]; }\n               _ { }\n             }\n         }\n         i += 1u;\n     }\n-    if (ivec::len(unsafe_ts) > 0u) {\n-        alt (f.node) {\n-            case (ast::expr_path(_)) {\n-                if (def_is_local(cx.tcx.def_map.get(f.id), true)) {\n-                    cx.tcx.sess.span_err(f.span,\n-                                         #fmt(\"function may alias with \\\n+    if ivec::len(unsafe_ts) > 0u {\n+        alt f.node {\n+          ast::expr_path(_) {\n+            if def_is_local(cx.tcx.def_map.get(f.id), true) {\n+                cx.tcx.sess.span_err(f.span,\n+                                     #fmt(\"function may alias with \\\n                          argument %u, which is not immutably rooted\",\n-                                              unsafe_t_offsets.(0)));\n-                }\n+                                          unsafe_t_offsets.(0)));\n             }\n-            case (_) { }\n+          }\n+          _ { }\n         }\n     }\n-    auto j = 0u;\n-    for (ty::t unsafe in unsafe_ts) {\n-        auto offset = unsafe_t_offsets.(j);\n+    let j = 0u;\n+    for unsafe: ty::t  in unsafe_ts {\n+        let offset = unsafe_t_offsets.(j);\n         j += 1u;\n-        auto i = 0u;\n-        for (ty::arg arg_t in arg_ts) {\n-            auto mut_alias = arg_t.mode == ty::mo_alias(true);\n-            if (i != offset &&\n-                    ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias))\n-               {\n+        let i = 0u;\n+        for arg_t: ty::arg  in arg_ts {\n+            let mut_alias = arg_t.mode == ty::mo_alias(true);\n+            if i != offset &&\n+                   ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias) {\n                 cx.tcx.sess.span_err(args.(i).span,\n                                      #fmt(\"argument %u may alias with \\\n                      argument %u, which is not immutably rooted\",\n@@ -221,10 +214,10 @@ fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n     }\n     // Ensure we're not passing a root by mutable alias.\n \n-    for (rec(uint arg, node_id node) root in mut_roots) {\n-        auto mut_alias_to_root = false;\n-        auto mut_alias_to_root_count = 0u;\n-        for (node_id r in roots) {\n+    for root: {arg: uint, node: node_id}  in mut_roots {\n+        let mut_alias_to_root = false;\n+        let mut_alias_to_root_count = 0u;\n+        for r: node_id  in roots {\n             if root.node == r {\n                 mut_alias_to_root_count += 1u;\n                 if mut_alias_to_root_count > 1u {\n@@ -234,160 +227,158 @@ fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n             }\n         }\n \n-        if (mut_alias_to_root) {\n+\n+        if mut_alias_to_root {\n             cx.tcx.sess.span_err(args.(root.arg).span,\n                                  \"passing a mutable alias to a \\\n                  variable that roots another alias\");\n         }\n     }\n-    ret rec(root_vars=roots, unsafe_ts=unsafe_ts);\n+    ret {root_vars: roots, unsafe_ts: unsafe_ts};\n }\n \n-fn check_tail_call(&ctx cx, &@ast::expr call) {\n-    auto args;\n-    auto f =\n-        alt (call.node) {\n-            case (ast::expr_call(?f, ?args_)) { args = args_; f }\n-        };\n-    auto i = 0u;\n-    for (ty::arg arg_t in fty_args(cx, ty::expr_ty(cx.tcx, f))) {\n-        if (arg_t.mode != ty::mo_val) {\n-            auto mut_a = arg_t.mode == ty::mo_alias(true);\n-            auto ok = true;\n-            alt (args.(i).node) {\n-                case (ast::expr_path(_)) {\n-                    auto def = cx.tcx.def_map.get(args.(i).id);\n-                    auto dnum = ast::def_id_of_def(def).node;\n-                    alt (cx.local_map.find(dnum)) {\n-                        case (some(arg(ast::alias(?mut)))) {\n-                            if (mut_a && !mut) {\n-                                cx.tcx.sess.span_err(args.(i).span,\n-                                                      \"passing an immutable \\\n+fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n+    let args;\n+    let f = alt call.node { ast::expr_call(f, args_) { args = args_; f } };\n+    let i = 0u;\n+    for arg_t: ty::arg  in fty_args(cx, ty::expr_ty(cx.tcx, f)) {\n+        if arg_t.mode != ty::mo_val {\n+            let mut_a = arg_t.mode == ty::mo_alias(true);\n+            let ok = true;\n+            alt args.(i).node {\n+              ast::expr_path(_) {\n+                let def = cx.tcx.def_map.get(args.(i).id);\n+                let dnum = ast::def_id_of_def(def).node;\n+                alt cx.local_map.find(dnum) {\n+                  some(arg(ast::alias(mut))) {\n+                    if mut_a && !mut {\n+                        cx.tcx.sess.span_err(args.(i).span,\n+                                             \"passing an immutable \\\n                                      alias by mutable alias\");\n-                            }\n-                        }\n-                        case (_) { ok = !def_is_local(def, false); }\n                     }\n+                  }\n+                  _ { ok = !def_is_local(def, false); }\n                 }\n-                case (_) { ok = false; }\n+              }\n+              _ { ok = false; }\n             }\n-            if (!ok) {\n+            if !ok {\n                 cx.tcx.sess.span_err(args.(i).span,\n-                                      \"can not pass a local value by \\\n+                                     \"can not pass a local value by \\\n                                      alias to a tail call\");\n             }\n         }\n         i += 1u;\n     }\n }\n \n-fn check_alt(&ctx cx, &@ast::expr input, &ast::arm[] arms, &scope sc,\n-             &vt[scope] v) {\n+fn check_alt(cx: &ctx, input: &@ast::expr, arms: &ast::arm[], sc: &scope,\n+             v: &vt[scope]) {\n     visit::visit_expr(input, sc, v);\n-    auto root = expr_root(cx, input, true);\n-    auto roots = alt (path_def_id(cx, root.ex)) {\n-      some(?did) { ~[did.node] }\n-      _ { ~[] }\n-    };\n-    let ty::t[] forbidden_tp =\n-        alt (inner_mut(root.ds)) { some(?t) { ~[t] } _ { ~[] } };\n-    for (ast::arm a in arms) {\n-        auto dnums = arm_defnums(a);\n-        auto new_sc = sc;\n-        if (ivec::len(dnums) > 0u) {\n-            new_sc = @(*sc + ~[@rec(root_vars=roots,\n-                                    block_defnum=dnums.(0),\n-                                    bindings=dnums,\n-                                    tys=forbidden_tp,\n-                                    depends_on=deps(sc, roots),\n-                                    mutable ok=valid)]);\n+    let root = expr_root(cx, input, true);\n+    let roots =\n+        alt path_def_id(cx, root.ex) { some(did) { ~[did.node] } _ { ~[] } };\n+    let forbidden_tp: ty::t[] =\n+        alt inner_mut(root.ds) { some(t) { ~[t] } _ { ~[] } };\n+    for a: ast::arm  in arms {\n+        let dnums = arm_defnums(a);\n+        let new_sc = sc;\n+        if ivec::len(dnums) > 0u {\n+            new_sc =\n+                @(*sc +\n+                      ~[@{root_vars: roots,\n+                          block_defnum: dnums.(0),\n+                          bindings: dnums,\n+                          tys: forbidden_tp,\n+                          depends_on: deps(sc, roots),\n+                          mutable ok: valid}]);\n         }\n         visit::visit_arm(a, new_sc, v);\n     }\n }\n \n-fn arm_defnums(&ast::arm arm) -> node_id[] {\n-    auto dnums = ~[];\n-    fn walk_pat(&mutable node_id[] found, &@ast::pat p) {\n-        alt (p.node) {\n-            case (ast::pat_bind(_)) { found += ~[p.id]; }\n-            case (ast::pat_tag(_, ?children)) {\n-                for (@ast::pat child in children) { walk_pat(found, child); }\n-            }\n-            case (ast::pat_rec(?fields, _)) {\n-                for (ast::field_pat f in fields) { walk_pat(found, f.pat); }\n-            }\n-            case (ast::pat_box(?inner)) { walk_pat(found, inner); }\n-            case (_) { }\n+fn arm_defnums(arm: &ast::arm) -> node_id[] {\n+    let dnums = ~[];\n+    fn walk_pat(found: &mutable node_id[], p: &@ast::pat) {\n+        alt p.node {\n+          ast::pat_bind(_) { found += ~[p.id]; }\n+          ast::pat_tag(_, children) {\n+            for child: @ast::pat  in children { walk_pat(found, child); }\n+          }\n+          ast::pat_rec(fields, _) {\n+            for f: ast::field_pat  in fields { walk_pat(found, f.pat); }\n+          }\n+          ast::pat_box(inner) { walk_pat(found, inner); }\n+          _ { }\n         }\n     }\n     walk_pat(dnums, arm.pats.(0));\n     ret dnums;\n }\n \n-fn check_for_each(&ctx cx, &@ast::local local, &@ast::expr call,\n-                  &ast::blk blk, &scope sc, &vt[scope] v) {\n+fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n+                  blk: &ast::blk, sc: &scope, v: &vt[scope]) {\n     visit::visit_expr(call, sc, v);\n-    alt (call.node) {\n-        case (ast::expr_call(?f, ?args)) {\n-            auto data = check_call(cx, f, args, sc);\n-            auto defnum = local.node.id;\n-            auto new_sc =\n-                @rec(root_vars=data.root_vars,\n-                     block_defnum=defnum,\n-                     bindings=~[defnum],\n-                     tys=data.unsafe_ts,\n-                     depends_on=deps(sc, data.root_vars),\n-                     mutable ok=valid);\n-            visit::visit_block(blk, @(*sc + ~[new_sc]), v);\n-        }\n+    alt call.node {\n+      ast::expr_call(f, args) {\n+        let data = check_call(cx, f, args, sc);\n+        let defnum = local.node.id;\n+        let new_sc =\n+            @{root_vars: data.root_vars,\n+              block_defnum: defnum,\n+              bindings: ~[defnum],\n+              tys: data.unsafe_ts,\n+              depends_on: deps(sc, data.root_vars),\n+              mutable ok: valid};\n+        visit::visit_block(blk, @(*sc + ~[new_sc]), v);\n+      }\n     }\n }\n \n-fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::blk blk,\n-             &scope sc, &vt[scope] v) {\n+fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n+             sc: &scope, v: &vt[scope]) {\n     visit::visit_expr(seq, sc, v);\n-    auto defnum = local.node.id;\n-    auto root = expr_root(cx, seq, false);\n-    auto root_def = alt (path_def_id(cx, root.ex)) {\n-      some(?did) { ~[did.node] }\n-      _ { ~[] }\n-    };\n-    auto unsafe = alt (inner_mut(root.ds)) { some(?t) { ~[t] } _ { ~[] } };\n+    let defnum = local.node.id;\n+    let root = expr_root(cx, seq, false);\n+    let root_def =\n+        alt path_def_id(cx, root.ex) { some(did) { ~[did.node] } _ { ~[] } };\n+    let unsafe = alt inner_mut(root.ds) { some(t) { ~[t] } _ { ~[] } };\n \n     // If this is a mutable vector, don't allow it to be touched.\n-    auto seq_t = ty::expr_ty(cx.tcx, seq);\n-    alt (ty::struct(cx.tcx, seq_t)) {\n-        ty::ty_vec(?mt) | ty::ty_ivec(?mt) {\n-            if (mt.mut != ast::imm) { unsafe = ~[seq_t]; }\n-        }\n-        ty::ty_str | ty::ty_istr { /* no-op */ }\n-        _ {\n-            cx.tcx.sess.span_unimpl(seq.span, \"unknown seq type \" +\n+    let seq_t = ty::expr_ty(cx.tcx, seq);\n+    alt ty::struct(cx.tcx, seq_t) {\n+      ty::ty_vec(mt) | ty::ty_ivec(mt) {\n+        if mt.mut != ast::imm { unsafe = ~[seq_t]; }\n+      }\n+      ty::ty_str. | ty::ty_istr. {/* no-op */ }\n+      _ {\n+        cx.tcx.sess.span_unimpl(seq.span,\n+                                \"unknown seq type \" +\n                                     util::ppaux::ty_to_str(cx.tcx, seq_t));\n-        }\n+      }\n     }\n-    auto new_sc =\n-        @rec(root_vars=root_def,\n-             block_defnum=defnum,\n-             bindings=~[defnum],\n-             tys=unsafe,\n-             depends_on=deps(sc, root_def),\n-             mutable ok=valid);\n+    let new_sc =\n+        @{root_vars: root_def,\n+          block_defnum: defnum,\n+          bindings: ~[defnum],\n+          tys: unsafe,\n+          depends_on: deps(sc, root_def),\n+          mutable ok: valid};\n     visit::visit_block(blk, @(*sc + ~[new_sc]), v);\n }\n \n-fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::node_id id,\n-             bool assign, &scope sc) {\n-    auto def = cx.tcx.def_map.get(id);\n-    if (!def_is_local(def, true)) { ret; }\n-    auto my_defnum = ast::def_id_of_def(def).node;\n-    auto var_t = ty::expr_ty(cx.tcx, ex);\n-    for (restrict r in *sc) {\n+fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n+             assign: bool, sc: &scope) {\n+    let def = cx.tcx.def_map.get(id);\n+    if !def_is_local(def, true) { ret; }\n+    let my_defnum = ast::def_id_of_def(def).node;\n+    let var_t = ty::expr_ty(cx.tcx, ex);\n+    for r: restrict  in *sc {\n+\n         // excludes variables introduced since the alias was made\n-        if (my_defnum < r.block_defnum) {\n-            for (ty::t t in r.tys) {\n-                if (ty_can_unsafely_include(cx, t, var_t, assign)) {\n+        if my_defnum < r.block_defnum {\n+            for t: ty::t  in r.tys {\n+                if ty_can_unsafely_include(cx, t, var_t, assign) {\n                     r.ok = val_taken(ex.span, p);\n                 }\n             }\n@@ -397,114 +388,113 @@ fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::node_id id,\n     }\n }\n \n-fn check_lval(&@ctx cx, &@ast::expr dest, &scope sc, &vt[scope] v) {\n-    alt (dest.node) {\n-        case (ast::expr_path(?p)) {\n-            auto dnum = ast::def_id_of_def(cx.tcx.def_map.get(dest.id)).node;\n-            if (is_immutable_alias(cx, sc, dnum)) {\n-                cx.tcx.sess.span_err(dest.span,\n-                                     \"assigning to immutable alias\");\n-            } else if (is_immutable_objfield(cx, dnum)) {\n-                cx.tcx.sess.span_err(dest.span,\n-                                     \"assigning to immutable obj field\");\n-            }\n-            for (restrict r in *sc) {\n-                if (ivec::member(dnum, r.root_vars)) {\n-                    r.ok = overwritten(dest.span, p);\n-                }\n+fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt[scope]) {\n+    alt dest.node {\n+      ast::expr_path(p) {\n+        let dnum = ast::def_id_of_def(cx.tcx.def_map.get(dest.id)).node;\n+        if is_immutable_alias(cx, sc, dnum) {\n+            cx.tcx.sess.span_err(dest.span, \"assigning to immutable alias\");\n+        } else if (is_immutable_objfield(cx, dnum)) {\n+            cx.tcx.sess.span_err(dest.span,\n+                                 \"assigning to immutable obj field\");\n+        }\n+        for r: restrict  in *sc {\n+            if ivec::member(dnum, r.root_vars) {\n+                r.ok = overwritten(dest.span, p);\n             }\n         }\n-        case (_) {\n-            auto root = expr_root(*cx, dest, false);\n-            if (ivec::len(*root.ds) == 0u) {\n-                cx.tcx.sess.span_err(dest.span, \"assignment to non-lvalue\");\n-            } else if (!root.ds.(0).mut) {\n-                auto name =\n-                    alt (root.ds.(0).kind) {\n-                        case (unbox) { \"box\" }\n-                        case (field) { \"field\" }\n-                        case (index) { \"vec content\" }\n-                    };\n-                cx.tcx.sess.span_err(dest.span,\n-                                     \"assignment to immutable \" + name);\n-            }\n-            visit_expr(cx, dest, sc, v);\n-        }\n+      }\n+      _ {\n+        let root = expr_root(*cx, dest, false);\n+        if ivec::len(*root.ds) == 0u {\n+            cx.tcx.sess.span_err(dest.span, \"assignment to non-lvalue\");\n+        } else if (!root.ds.(0).mut) {\n+            let name =\n+                alt root.ds.(0).kind {\n+                  unbox. { \"box\" }\n+                  field. { \"field\" }\n+                  index. { \"vec content\" }\n+                };\n+            cx.tcx.sess.span_err(dest.span,\n+                                 \"assignment to immutable \" + name);\n+        }\n+        visit_expr(cx, dest, sc, v);\n+      }\n     }\n }\n \n-fn check_move_rhs(&@ctx cx, &@ast::expr src, &scope sc, &vt[scope] v) {\n-    alt (src.node) {\n-        case (ast::expr_path(?p)) {\n-            alt (cx.tcx.def_map.get(src.id)) {\n-                ast::def_obj_field(_) {\n-                    cx.tcx.sess.span_err\n-                        (src.span, \"may not move out of an obj field\");\n-                }\n-                _ {}\n-            }\n-            check_lval(cx, src, sc, v);\n-        }\n-        case (_) {\n-            auto root = expr_root(*cx, src, false);\n-            // Not a path and no-derefs means this is a temporary.\n-            if (ivec::len(*root.ds) != 0u) {\n-                cx.tcx.sess.span_err\n-                    (src.span, \"moving out of a data structure\");\n-            }\n+fn check_move_rhs(cx: &@ctx, src: &@ast::expr, sc: &scope, v: &vt[scope]) {\n+    alt src.node {\n+      ast::expr_path(p) {\n+        alt cx.tcx.def_map.get(src.id) {\n+          ast::def_obj_field(_) {\n+            cx.tcx.sess.span_err(src.span,\n+                                 \"may not move out of an obj field\");\n+          }\n+          _ { }\n+        }\n+        check_lval(cx, src, sc, v);\n+      }\n+      _ {\n+        let root = expr_root(*cx, src, false);\n+\n+        // Not a path and no-derefs means this is a temporary.\n+        if ivec::len(*root.ds) != 0u {\n+            cx.tcx.sess.span_err(src.span, \"moving out of a data structure\");\n         }\n+      }\n     }\n }\n \n-fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n-                &vt[scope] v) {\n+fn check_assign(cx: &@ctx, dest: &@ast::expr, src: &@ast::expr, sc: &scope,\n+                v: &vt[scope]) {\n     visit_expr(cx, src, sc, v);\n     check_lval(cx, dest, sc, v);\n }\n \n \n-fn is_immutable_alias(&@ctx cx, &scope sc, node_id dnum) -> bool {\n-    alt (cx.local_map.find(dnum)) {\n-        case (some(arg(ast::alias(false)))) { ret true; }\n-        case (_) { }\n+fn is_immutable_alias(cx: &@ctx, sc: &scope, dnum: node_id) -> bool {\n+    alt cx.local_map.find(dnum) {\n+      some(arg(ast::alias(false))) { ret true; }\n+      _ { }\n     }\n-    for (restrict r in *sc) {\n-        if (ivec::member(dnum, r.bindings)) { ret true; }\n+    for r: restrict  in *sc {\n+        if ivec::member(dnum, r.bindings) { ret true; }\n     }\n     ret false;\n }\n \n-fn is_immutable_objfield(&@ctx cx, node_id dnum) -> bool {\n+fn is_immutable_objfield(cx: &@ctx, dnum: node_id) -> bool {\n     ret cx.local_map.find(dnum) == some(objfield(ast::imm));\n }\n \n-fn test_scope(&ctx cx, &scope sc, &restrict r, &ast::path p) {\n-    auto prob = r.ok;\n-    for (uint dep in r.depends_on) {\n-        if (prob != valid) { break; }\n+fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n+    let prob = r.ok;\n+    for dep: uint  in r.depends_on {\n+        if prob != valid { break; }\n         prob = sc.(dep).ok;\n     }\n-    if (prob != valid) {\n-        auto msg =\n-            alt (prob) {\n-                case (overwritten(?sp, ?wpt)) {\n-                    rec(span=sp, msg=\"overwriting \" + ast::path_name(wpt))\n-                }\n-                case (val_taken(?sp, ?vpt)) {\n-                    rec(span=sp, msg=\"taking the value of \" +\n-                        ast::path_name(vpt))\n-                }\n+    if prob != valid {\n+        let msg =\n+            alt prob {\n+              overwritten(sp, wpt) {\n+                {span: sp, msg: \"overwriting \" + ast::path_name(wpt)}\n+              }\n+              val_taken(sp, vpt) {\n+                {span: sp, msg: \"taking the value of \" + ast::path_name(vpt)}\n+              }\n             };\n-        cx.tcx.sess.span_err(msg.span, msg.msg + \" will invalidate alias \" +\n-                             ast::path_name(p) + \", which is still used\");\n+        cx.tcx.sess.span_err(msg.span,\n+                             msg.msg + \" will invalidate alias \" +\n+                                 ast::path_name(p) + \", which is still used\");\n     }\n }\n \n-fn deps(&scope sc, &node_id[] roots) -> uint[] {\n-    auto i = 0u;\n-    auto result = ~[];\n-    for (restrict r in *sc) {\n-        for (node_id dn in roots) {\n+fn deps(sc: &scope, roots: &node_id[]) -> uint[] {\n+    let i = 0u;\n+    let result = ~[];\n+    for r: restrict  in *sc {\n+        for dn: node_id  in roots {\n             if ivec::member(dn, r.bindings) { result += ~[i]; }\n         }\n         i += 1u;\n@@ -514,178 +504,184 @@ fn deps(&scope sc, &node_id[] roots) -> uint[] {\n \n tag deref_t { unbox; field; index; }\n \n-type deref = @rec(bool mut, deref_t kind, ty::t outer_t);\n+type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n \n \n // Finds the root (the thing that is dereferenced) for the given expr, and a\n // vec of dereferences that were used on this root. Note that, in this vec,\n // the inner derefs come in front, so foo.bar.baz becomes rec(ex=foo,\n // ds=[field(baz),field(bar)])\n-fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n-   rec(@ast::expr ex, @deref[] ds) {\n-    fn maybe_auto_unbox(&ctx cx, ty::t t) -> rec(ty::t t, deref[] ds) {\n-        auto ds = ~[];\n-        while (true) {\n-            alt (ty::struct(cx.tcx, t)) {\n-              ty::ty_box(?mt) {\n-                ds += ~[@rec(mut=mt.mut != ast::imm, kind=unbox, outer_t=t)];\n+fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n+   {ex: @ast::expr, ds: @deref[]} {\n+    fn maybe_auto_unbox(cx: &ctx, t: ty::t) -> {t: ty::t, ds: deref[]} {\n+        let ds = ~[];\n+        while true {\n+            alt ty::struct(cx.tcx, t) {\n+              ty::ty_box(mt) {\n+                ds += ~[@{mut: mt.mut != ast::imm, kind: unbox, outer_t: t}];\n                 t = mt.ty;\n               }\n-              ty::ty_res(_, ?inner, ?tps) {\n-                ds += ~[@rec(mut=false, kind=unbox, outer_t=t)];\n+              ty::ty_res(_, inner, tps) {\n+                ds += ~[@{mut: false, kind: unbox, outer_t: t}];\n                 t = ty::substitute_type_params(cx.tcx, tps, inner);\n               }\n-              ty::ty_tag(?did, ?tps) {\n-                auto variants = ty::tag_variants(cx.tcx, did);\n-                if (ivec::len(variants) != 1u ||\n-                    ivec::len(variants.(0).args) != 1u) {\n+              ty::ty_tag(did, tps) {\n+                let variants = ty::tag_variants(cx.tcx, did);\n+                if ivec::len(variants) != 1u ||\n+                       ivec::len(variants.(0).args) != 1u {\n                     break;\n                 }\n-                ds += ~[@rec(mut=false, kind=unbox, outer_t=t)];\n-                t = ty::substitute_type_params(cx.tcx, tps,\n+                ds += ~[@{mut: false, kind: unbox, outer_t: t}];\n+                t =\n+                    ty::substitute_type_params(cx.tcx, tps,\n                                                variants.(0).args.(0));\n               }\n               _ { break; }\n             }\n         }\n-        ret rec(t=t, ds=ds);\n+        ret {t: t, ds: ds};\n     }\n-    let deref[] ds = ~[];\n-    while (true) {\n-        alt ({ ex.node }) {\n-            case (ast::expr_field(?base, ?ident)) {\n-                auto auto_unbox =\n-                    maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, base));\n-                auto mut = false;\n-                alt (ty::struct(cx.tcx, auto_unbox.t)) {\n-                    case (ty::ty_rec(?fields)) {\n-                        for (ty::field fld in fields) {\n-                            if (str::eq(ident, fld.ident)) {\n-                                mut = fld.mt.mut != ast::imm;\n-                                break;\n-                            }\n-                        }\n+    let ds: deref[] = ~[];\n+    while true {\n+        alt { ex.node } {\n+          ast::expr_field(base, ident) {\n+            let auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, base));\n+            let mut = false;\n+            alt ty::struct(cx.tcx, auto_unbox.t) {\n+              ty::ty_rec(fields) {\n+                for fld: ty::field  in fields {\n+                    if str::eq(ident, fld.ident) {\n+                        mut = fld.mt.mut != ast::imm;\n+                        break;\n                     }\n-                    case (ty::ty_obj(_)) { }\n                 }\n-                ds += ~[@rec(mut=mut, kind=field, outer_t=auto_unbox.t)];\n-                ds += auto_unbox.ds;\n-                ex = base;\n+              }\n+              ty::ty_obj(_) { }\n             }\n-            case (ast::expr_index(?base, _)) {\n-                auto auto_unbox =\n-                    maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, base));\n-                alt (ty::struct(cx.tcx, auto_unbox.t)) {\n-                    case (ty::ty_vec(?mt)) {\n-                        ds += ~[@rec(mut=mt.mut != ast::imm,\n-                                    kind=index,\n-                                    outer_t=auto_unbox.t)];\n-                    }\n-                    case (ty::ty_ivec(?mt)) {\n-                        ds += ~[@rec(mut=mt.mut != ast::imm,\n-                                    kind=index,\n-                                    outer_t=auto_unbox.t)];\n-                    }\n+            ds += ~[@{mut: mut, kind: field, outer_t: auto_unbox.t}];\n+            ds += auto_unbox.ds;\n+            ex = base;\n+          }\n+          ast::expr_index(base, _) {\n+            let auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, base));\n+            alt ty::struct(cx.tcx, auto_unbox.t) {\n+              ty::ty_vec(mt) {\n+                ds +=\n+                    ~[@{mut: mt.mut != ast::imm,\n+                        kind: index,\n+                        outer_t: auto_unbox.t}];\n+              }\n+              ty::ty_ivec(mt) {\n+                ds +=\n+                    ~[@{mut: mt.mut != ast::imm,\n+                        kind: index,\n+                        outer_t: auto_unbox.t}];\n+              }\n+            }\n+            ds += auto_unbox.ds;\n+            ex = base;\n+          }\n+          ast::expr_unary(op, base) {\n+            if op == ast::deref {\n+                let base_t = ty::expr_ty(cx.tcx, base);\n+                let mut = false;\n+                alt ty::struct(cx.tcx, base_t) {\n+                  ty::ty_box(mt) { mut = mt.mut != ast::imm; }\n+                  ty::ty_res(_, _, _) { }\n+                  ty::ty_tag(_, _) { }\n+                  ty::ty_ptr(mt) { mut = mt.mut != ast::imm; }\n                 }\n-                ds += auto_unbox.ds;\n+                ds += ~[@{mut: mut, kind: unbox, outer_t: base_t}];\n                 ex = base;\n-            }\n-            case (ast::expr_unary(?op, ?base)) {\n-                if (op == ast::deref) {\n-                    auto base_t = ty::expr_ty(cx.tcx, base);\n-                    auto mut = false;\n-                    alt (ty::struct(cx.tcx, base_t)) {\n-                        case (ty::ty_box(?mt)) { mut = mt.mut != ast::imm; }\n-                        case (ty::ty_res(_, _, _)) {}\n-                        case (ty::ty_tag(_, _)) {}\n-                        case (ty::ty_ptr(?mt)) { mut = mt.mut != ast::imm; }\n-                    }\n-                    ds += ~[@rec(mut=mut, kind=unbox, outer_t=base_t)];\n-                    ex = base;\n-                } else { break; }\n-            }\n-            case (_) { break; }\n+            } else { break; }\n+          }\n+          _ { break; }\n         }\n     }\n-    if (autoderef) {\n-        auto auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, ex));\n+    if autoderef {\n+        let auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, ex));\n         ds += auto_unbox.ds;\n     }\n-    ret rec(ex=ex, ds=@ds);\n+    ret {ex: ex, ds: @ds};\n }\n \n-fn mut_field(&@deref[] ds) -> bool {\n-    for (deref d in *ds) { if (d.mut) { ret true; } }\n+fn mut_field(ds: &@deref[]) -> bool {\n+    for d: deref  in *ds { if d.mut { ret true; } }\n     ret false;\n }\n \n-fn inner_mut(&@deref[] ds) -> option::t[ty::t] {\n-    for (deref d in *ds) { if (d.mut) { ret some(d.outer_t); } }\n+fn inner_mut(ds: &@deref[]) -> option::t[ty::t] {\n+    for d: deref  in *ds { if d.mut { ret some(d.outer_t); } }\n     ret none;\n }\n \n-fn path_def_id(&ctx cx, &@ast::expr ex) -> option::t[ast::def_id] {\n-    alt (ex.node) {\n-        case (ast::expr_path(_)) {\n-            ret some(ast::def_id_of_def(cx.tcx.def_map.get(ex.id)));\n-        }\n-        case (_) { ret none; }\n+fn path_def_id(cx: &ctx, ex: &@ast::expr) -> option::t[ast::def_id] {\n+    alt ex.node {\n+      ast::expr_path(_) {\n+        ret some(ast::def_id_of_def(cx.tcx.def_map.get(ex.id)));\n+      }\n+      _ { ret none; }\n     }\n }\n \n-fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut) ->\n-   bool {\n-    fn get_mut(bool cur, &ty::mt mt) -> bool {\n+fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n+                           mut: bool) -> bool {\n+    fn get_mut(cur: bool, mt: &ty::mt) -> bool {\n         ret cur || mt.mut != ast::imm;\n     }\n-    fn helper(&ty::ctxt tcx, ty::t needle, ty::t haystack, bool mut) -> bool {\n-        if (needle == haystack) { ret true; }\n-        alt (ty::struct(tcx, haystack)) {\n-            ty::ty_tag(_, ?ts) {\n-                for (ty::t t in ts) {\n-                    if (helper(tcx, needle, t, mut)) { ret true; }\n-                }\n-                ret false;\n-            }\n-            ty::ty_box(?mt) | ty::ty_vec(?mt) | ty::ty_ptr(?mt) {\n-                ret helper(tcx, needle, mt.ty, get_mut(mut, mt));\n+    fn helper(tcx: &ty::ctxt, needle: ty::t, haystack: ty::t, mut: bool) ->\n+       bool {\n+        if needle == haystack { ret true; }\n+        alt ty::struct(tcx, haystack) {\n+          ty::ty_tag(_, ts) {\n+            for t: ty::t  in ts {\n+                if helper(tcx, needle, t, mut) { ret true; }\n             }\n-            ty::ty_rec(?fields) {\n-                for (ty::field f in fields) {\n-                    if (helper(tcx, needle, f.mt.ty, get_mut(mut, f.mt))) {\n-                        ret true;\n-                    }\n+            ret false;\n+          }\n+          ty::ty_box(mt) | ty::ty_vec(mt) | ty::ty_ptr(mt) {\n+            ret helper(tcx, needle, mt.ty, get_mut(mut, mt));\n+          }\n+          ty::ty_rec(fields) {\n+            for f: ty::field  in fields {\n+                if helper(tcx, needle, f.mt.ty, get_mut(mut, f.mt)) {\n+                    ret true;\n                 }\n-                ret false;\n-            }\n-            // These may contain anything.\n-            ty::ty_fn(_, _, _, _, _) {\n-                ret true;\n             }\n-            ty::ty_obj(_) { ret true; }\n-            // A type param may include everything, but can only be\n-            // treated as opaque downstream, and is thus safe unless we\n-            // saw mutable fields, in which case the whole thing can be\n-            // overwritten.\n-            ty::ty_param(_) { ret mut; }\n-            _ { ret false; }\n+            ret false;\n+          }\n+\n+          // These may contain anything.\n+          ty::ty_fn(_, _, _, _, _) {\n+            ret true;\n+          }\n+          ty::ty_obj(_) { ret true; }\n+\n+          // A type param may include everything, but can only be\n+          // treated as opaque downstream, and is thus safe unless we\n+          // saw mutable fields, in which case the whole thing can be\n+          // overwritten.\n+          ty::ty_param(_) {\n+            ret mut;\n+          }\n+          _ { ret false; }\n         }\n     }\n     ret helper(cx.tcx, needle, haystack, mut);\n }\n \n-fn def_is_local(&ast::def d, bool objfields_count) -> bool {\n-    ret alt (d) {\n-        ast::def_local(_) | ast::def_arg(_) | ast::def_binding(_) { true }\n-        ast::def_obj_field(_) { objfields_count }\n-        _ { false }\n-    };\n+fn def_is_local(d: &ast::def, objfields_count: bool) -> bool {\n+    ret alt d {\n+          ast::def_local(_) | ast::def_arg(_) | ast::def_binding(_) { true }\n+          ast::def_obj_field(_) { objfields_count }\n+          _ { false }\n+        };\n }\n \n-fn fty_args(&ctx cx, ty::t fty) -> ty::arg[] {\n-    ret alt (ty::struct(cx.tcx, ty::type_autoderef(cx.tcx, fty))) {\n-        ty::ty_fn(_, ?args, _, _, _) | ty::ty_native_fn(_, ?args, _) { args }\n-    };\n+fn fty_args(cx: &ctx, fty: ty::t) -> ty::arg[] {\n+    ret alt ty::struct(cx.tcx, ty::type_autoderef(cx.tcx, fty)) {\n+          ty::ty_fn(_, args, _, _, _) | ty::ty_native_fn(_, args, _) { args }\n+        };\n }\n // Local Variables:\n // mode: rust"}, {"sha": "172c9d939e903379fc356d978ea4491eaa97dab8", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 41, "deletions": 44, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -13,44 +13,43 @@ tag ast_node {\n \n type map = std::map::hashmap[node_id, ast_node];\n \n-fn map_crate(&crate c) -> map {\n+fn map_crate(c: &crate) -> map {\n     // FIXME: This is using an adapter to convert the smallintmap\n     // interface to the hashmap interface. It would be better to just\n     // convert everything to use the smallintmap.\n-    auto map = new_smallintmap_int_adapter[ast_node]();\n+    let map = new_smallintmap_int_adapter[ast_node]();\n \n-    auto v_map = @rec(visit_item=bind map_item(map, _, _, _),\n-                      visit_native_item=bind map_native_item(map, _, _, _),\n-                      visit_expr=bind map_expr(map, _, _, _)\n-                      with *visit::default_visitor[()]());\n+    let v_map =\n+        @{visit_item: bind map_item(map, _, _, _),\n+          visit_native_item: bind map_native_item(map, _, _, _),\n+          visit_expr: bind map_expr(map, _, _, _)\n+             with *visit::default_visitor[()]()};\n     visit::visit_crate(c, (), visit::mk_vt(v_map));\n     ret map;\n }\n \n-fn map_item(&map map, &@item i, &() e, &vt[()] v) {\n+fn map_item(map: &map, i: &@item, e: &(), v: &vt[()]) {\n     map.insert(i.id, node_item(i));\n-    alt (i.node) {\n-        case (item_obj(_, _, ?ctor_id)) {\n-            map.insert(ctor_id, node_obj_ctor(i));\n-        }\n-        case (_) {}\n+    alt i.node {\n+      item_obj(_, _, ctor_id) { map.insert(ctor_id, node_obj_ctor(i)); }\n+      _ { }\n     }\n     visit::visit_item(i, e, v);\n }\n \n-fn map_native_item(&map map, &@native_item i, &() e, &vt[()] v) {\n+fn map_native_item(map: &map, i: &@native_item, e: &(), v: &vt[()]) {\n     map.insert(i.id, node_native_item(i));\n     visit::visit_native_item(i, e, v);\n }\n \n-fn map_expr(&map map, &@expr ex, &() e, &vt[()] v) {\n+fn map_expr(map: &map, ex: &@expr, e: &(), v: &vt[()]) {\n     map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, e, v);\n }\n \n fn new_smallintmap_int_adapter[V]() -> std::map::hashmap[int, V] {\n-    auto key_idx = fn(&int key) -> uint { key as uint };\n-    auto idx_key = fn(&uint idx) -> int { idx as int };\n+    let key_idx = fn (key: &int) -> uint { key as uint };\n+    let idx_key = fn (idx: &uint) -> int { idx as int };\n     ret new_smallintmap_adapter(key_idx, idx_key);\n }\n \n@@ -59,60 +58,58 @@ fn new_smallintmap_int_adapter[V]() -> std::map::hashmap[int, V] {\n // the entire codebase adapting all the callsites to the different\n // interface.\n // FIXME: hashmap and smallintmap should support the same interface.\n-fn new_smallintmap_adapter[K, V](fn(&K) -> uint key_idx,\n-                                 fn(&uint) -> K idx_key)\n-    -> std::map::hashmap[K, V] {\n+fn new_smallintmap_adapter[K,\n+                           V](key_idx: fn(&K) -> uint ,\n+                              idx_key: fn(&uint) -> K ) ->\n+   std::map::hashmap[K, V] {\n \n-    obj adapter[K, V](smallintmap::smallintmap[V] map,\n-                      fn(&K) -> uint key_idx,\n-                      fn(&uint) -> K idx_key) {\n+    obj adapter[K,\n+                V](map: smallintmap::smallintmap[V],\n+                   key_idx: fn(&K) -> uint ,\n+                   idx_key: fn(&uint) -> K ) {\n \n         fn size() -> uint { fail }\n \n-        fn insert(&K key, &V value) -> bool {\n-            auto exists = smallintmap::contains_key(map, key_idx(key));\n+        fn insert(key: &K, value: &V) -> bool {\n+            let exists = smallintmap::contains_key(map, key_idx(key));\n             smallintmap::insert(map, key_idx(key), value);\n             ret !exists;\n         }\n \n-        fn contains_key(&K key) -> bool {\n+        fn contains_key(key: &K) -> bool {\n             ret smallintmap::contains_key(map, key_idx(key));\n         }\n \n-        fn get(&K key) -> V {\n-            ret smallintmap::get(map, key_idx(key));\n-        }\n+        fn get(key: &K) -> V { ret smallintmap::get(map, key_idx(key)); }\n \n-        fn find(&K key) -> option::t[V] {\n+        fn find(key: &K) -> option::t[V] {\n             ret smallintmap::find(map, key_idx(key));\n         }\n \n-        fn remove(&K key) -> option::t[V] { fail }\n+        fn remove(key: &K) -> option::t[V] { fail }\n \n         fn rehash() { fail }\n \n-        iter items() -> @rec(K key, V val) {\n-            auto idx = 0u;\n-            for (option::t[V] item in map.v) {\n-                alt (item) {\n-                    case (option::some(?elt)) {\n-                        auto value = elt;\n-                        auto key = idx_key(idx);\n-                        put @rec(key=key, val=value);\n-                    }\n-                    case (option::none) { }\n+        iter items() -> @{key: K, val: V} {\n+            let idx = 0u;\n+            for item: option::t[V]  in map.v {\n+                alt item {\n+                  option::some(elt) {\n+                    let value = elt;\n+                    let key = idx_key(idx);\n+                    put @{key: key, val: value};\n+                  }\n+                  option::none. { }\n                 }\n                 idx += 1u;\n             }\n         }\n         iter keys() -> K {\n-            for each (@rec(K key, V val) p in self.items()) {\n-                put p.key;\n-            }\n+            for each p: @{key: K, val: V}  in self.items() { put p.key; }\n         }\n     }\n \n-    auto map = smallintmap::mk[V]();\n+    let map = smallintmap::mk[V]();\n     ret adapter(map, key_idx, idx_key);\n }\n "}, {"sha": "5c9b9e9b0489b1c24cb4bcb9c4d98d5987eb50d4", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -1,29 +1,27 @@\n import syntax::ast::*;\n import syntax::visit;\n \n-fn check_crate(&ty::ctxt tcx, &@crate crate) {\n-    auto v = @rec(visit_expr=bind check_expr(tcx, _, _, _)\n-                  with *visit::default_visitor[()]());\n+fn check_crate(tcx: &ty::ctxt, crate: &@crate) {\n+    let v =\n+        @{visit_expr: bind check_expr(tcx, _, _, _)\n+             with *visit::default_visitor[()]()};\n     visit::visit_crate(*crate, (), visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_expr(&ty::ctxt tcx, &@expr ex, &() s, &visit::vt[()] v) {\n+fn check_expr(tcx: &ty::ctxt, ex: &@expr, s: &(), v: &visit::vt[()]) {\n     visit::visit_expr(ex, s, v);\n-    alt ex.node {\n-      expr_alt(_, ?arms) { check_arms(tcx, arms); }\n-      _ {}\n-    }\n+    alt ex.node { expr_alt(_, arms) { check_arms(tcx, arms); } _ { } }\n }\n \n-fn check_arms(&ty::ctxt tcx, &arm[] arms) {\n-    auto i = 0;\n-    for (arm arm in arms) {\n-        for (@pat arm_pat in arm.pats) {\n-            auto reachable = true;\n-            auto j = 0;\n+fn check_arms(tcx: &ty::ctxt, arms: &arm[]) {\n+    let i = 0;\n+    for arm: arm  in arms {\n+        for arm_pat: @pat  in arm.pats {\n+            let reachable = true;\n+            let j = 0;\n             while j < i {\n-                for (@pat prev_pat in arms.(j).pats) {\n+                for prev_pat: @pat  in arms.(j).pats {\n                     if pattern_supersedes(tcx, prev_pat, arm_pat) {\n                         reachable = false;\n                     }\n@@ -38,54 +36,56 @@ fn check_arms(&ty::ctxt tcx, &arm[] arms) {\n     }\n }\n \n-fn pattern_supersedes(&ty::ctxt tcx, &@pat a, &@pat b) -> bool {\n-    fn patterns_supersede(&ty::ctxt tcx, &(@pat)[] as, &(@pat)[] bs) -> bool {\n-        auto i = 0;\n-        for (@pat a in as) {\n+fn pattern_supersedes(tcx: &ty::ctxt, a: &@pat, b: &@pat) -> bool {\n+    fn patterns_supersede(tcx: &ty::ctxt, as: &(@pat)[], bs: &(@pat)[]) ->\n+       bool {\n+        let i = 0;\n+        for a: @pat  in as {\n             if !pattern_supersedes(tcx, a, bs.(i)) { ret false; }\n             i += 1;\n         }\n         ret true;\n     }\n-    fn field_patterns_supersede(&ty::ctxt tcx, &field_pat[] fas,\n-                                &field_pat[] fbs) -> bool {\n-        auto wild = @rec(id=0, node=pat_wild, span=rec(lo=0u, hi=0u));\n-        for (field_pat fa in fas) {\n-            auto pb = wild;\n-            for (field_pat fb in fbs) {\n+    fn field_patterns_supersede(tcx: &ty::ctxt, fas: &field_pat[],\n+                                fbs: &field_pat[]) -> bool {\n+        let wild = @{id: 0, node: pat_wild, span: {lo: 0u, hi: 0u}};\n+        for fa: field_pat  in fas {\n+            let pb = wild;\n+            for fb: field_pat  in fbs {\n                 if fa.ident == fb.ident { pb = fb.pat; }\n             }\n             if !pattern_supersedes(tcx, fa.pat, pb) { ret false; }\n         }\n         ret true;\n     }\n \n+\n     alt a.node {\n-      pat_wild | pat_bind(_) { ret true; }\n-      pat_lit(?la) {\n+      pat_wild. | pat_bind(_) { ret true; }\n+      pat_lit(la) {\n         alt b.node {\n-          pat_lit(?lb) { ret util::common::lit_eq(la, lb); }\n+          pat_lit(lb) { ret util::common::lit_eq(la, lb); }\n           _ { ret false; }\n         }\n       }\n-      pat_tag(?va, ?suba) {\n+      pat_tag(va, suba) {\n         alt b.node {\n-          pat_tag(?vb, ?subb) {\n+          pat_tag(vb, subb) {\n             ret tcx.def_map.get(a.id) == tcx.def_map.get(b.id) &&\n-                patterns_supersede(tcx, suba, subb);\n+                    patterns_supersede(tcx, suba, subb);\n           }\n           _ { ret false; }\n         }\n       }\n-      pat_rec(?suba, _) {\n+      pat_rec(suba, _) {\n         alt b.node {\n-          pat_rec(?subb, _) { ret field_patterns_supersede(tcx, suba, subb); }\n+          pat_rec(subb, _) { ret field_patterns_supersede(tcx, suba, subb); }\n           _ { ret false; }\n         }\n       }\n-      pat_box(?suba) {\n+      pat_box(suba) {\n         alt b.node {\n-          pat_box(?subb) { ret pattern_supersedes(tcx, suba, subb); }\n+          pat_box(subb) { ret pattern_supersedes(tcx, suba, subb); }\n           _ { ret pattern_supersedes(tcx, suba, b); }\n         }\n       }"}, {"sha": "d157499734ec2956eabbab9bc6189a361040dfae", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 86, "deletions": 95, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -24,159 +24,150 @@ export is_freevar_of;\n export def_lookup;\n \n type freevar_set = hashset[ast::node_id];\n-type freevar_info = rec(freevar_set defs, @ast::node_id[] uses);\n+type freevar_info = {defs: freevar_set, uses: @ast::node_id[]};\n type freevar_map = hashmap[ast::node_id, freevar_info];\n \n // Searches through part of the AST for all references to locals or\n // upvars in this frame and returns the list of definition IDs thus found.\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(&resolve::def_map def_map, &session::session sess,\n-                    &fn (&visit::vt[()]) walker,\n-                    ast::node_id[] initial_decls) -> freevar_info {\n+fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n+                    walker: &fn(&visit::vt[()]) ,\n+                    initial_decls: ast::node_id[]) -> freevar_info {\n     type env =\n-        @rec(mutable ast::node_id[] refs,\n-             hashset[ast::node_id] decls,\n-             resolve::def_map def_map,\n-             session::session sess);\n+        @{mutable refs: ast::node_id[],\n+          decls: hashset[ast::node_id],\n+          def_map: resolve::def_map,\n+          sess: session::session};\n \n-    fn walk_fn(env e, &ast::_fn f, &ast::ty_param[] tps, &span sp,\n-               &ast::fn_ident i, ast::node_id nid) {\n-        for (ast::arg a in f.decl.inputs) { e.decls.insert(a.id, ()); }\n+    fn walk_fn(e: env, f: &ast::_fn, tps: &ast::ty_param[], sp: &span,\n+               i: &ast::fn_ident, nid: ast::node_id) {\n+        for a: ast::arg  in f.decl.inputs { e.decls.insert(a.id, ()); }\n     }\n-    fn walk_expr(env e, &@ast::expr expr) {\n-        alt (expr.node) {\n-            case (ast::expr_path(?path)) {\n-                if (! e.def_map.contains_key(expr.id)) {\n-                    e.sess.span_fatal(expr.span,\n-                       \"internal error in collect_freevars\");\n-                }\n-                alt (e.def_map.get(expr.id)) {\n-                    case (ast::def_arg(?did)) { e.refs += ~[expr.id]; }\n-                    case (ast::def_local(?did)) { e.refs += ~[expr.id]; }\n-                    case (ast::def_binding(?did)) { e.refs += ~[expr.id]; }\n-                    case (_) { /* no-op */ }\n-                }\n+    fn walk_expr(e: env, expr: &@ast::expr) {\n+        alt expr.node {\n+          ast::expr_path(path) {\n+            if !e.def_map.contains_key(expr.id) {\n+                e.sess.span_fatal(expr.span,\n+                                  \"internal error in collect_freevars\");\n             }\n-            case (_) { }\n+            alt e.def_map.get(expr.id) {\n+              ast::def_arg(did) { e.refs += ~[expr.id]; }\n+              ast::def_local(did) { e.refs += ~[expr.id]; }\n+              ast::def_binding(did) { e.refs += ~[expr.id]; }\n+              _ {/* no-op */ }\n+            }\n+          }\n+          _ { }\n         }\n     }\n-    fn walk_local(env e, &@ast::local local) {\n+    fn walk_local(e: env, local: &@ast::local) {\n         set_add(e.decls, local.node.id);\n     }\n-    fn walk_pat(env e, &@ast::pat p) {\n-        alt (p.node) {\n-            case (ast::pat_bind(_)) {\n-                set_add(e.decls, p.id);\n-            }\n-            case (_) {}\n-        }\n+    fn walk_pat(e: env, p: &@ast::pat) {\n+        alt p.node { ast::pat_bind(_) { set_add(e.decls, p.id); } _ { } }\n     }\n-    let hashset[ast::node_id] decls = new_int_hash();\n-    for (ast::node_id decl in initial_decls) { set_add(decls, decl); }\n+    let decls: hashset[ast::node_id] = new_int_hash();\n+    for decl: ast::node_id  in initial_decls { set_add(decls, decl); }\n \n-    let env e = @rec(mutable refs=~[],\n-                     decls=decls,\n-                     def_map=def_map,\n-                     sess=sess);\n-    walker(visit::mk_simple_visitor(\n-        @rec(visit_local=bind walk_local(e, _),\n-             visit_pat=bind walk_pat(e, _),\n-             visit_expr=bind walk_expr(e, _),\n-             visit_fn=bind walk_fn(e, _, _, _, _, _)\n-             with *visit::default_simple_visitor())));\n+    let e: env =\n+        @{mutable refs: ~[], decls: decls, def_map: def_map, sess: sess};\n+    walker(visit::mk_simple_visitor(@{visit_local: bind walk_local(e, _),\n+                                      visit_pat: bind walk_pat(e, _),\n+                                      visit_expr: bind walk_expr(e, _),\n+                                      visit_fn: bind walk_fn(e, _, _, _, _, _)\n+                                         with\n+                                             *visit::default_simple_visitor()}));\n \n     // Calculate (refs - decls). This is the set of captured upvars.\n     // We build a vec of the node ids of the uses and a set of the\n     // node ids of the definitions.\n-    auto uses = ~[];\n-    auto defs = new_int_hash();\n-    for (ast::node_id ref_id_ in e.refs) {\n-        auto ref_id = ref_id_;\n-        auto def_id = ast::def_id_of_def(def_map.get(ref_id)).node;\n+    let uses = ~[];\n+    let defs = new_int_hash();\n+    for ref_id_: ast::node_id  in e.refs {\n+        let ref_id = ref_id_;\n+        let def_id = ast::def_id_of_def(def_map.get(ref_id)).node;\n         if !decls.contains_key(def_id) {\n             uses += ~[ref_id];\n             set_add(defs, def_id);\n         }\n     }\n-    ret rec(defs=defs, uses=@uses);\n+    ret {defs: defs, uses: @uses};\n }\n \n // Build a map from every function and for-each body to a set of the\n // freevars contained in it. The implementation is not particularly\n // efficient as it fully recomputes the free variables at every\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n-fn annotate_freevars(&session::session sess, &resolve::def_map def_map,\n-                     &@ast::crate crate) -> freevar_map {\n+fn annotate_freevars(sess: &session::session, def_map: &resolve::def_map,\n+                     crate: &@ast::crate) -> freevar_map {\n     type env =\n-        rec(freevar_map freevars,\n-            resolve::def_map def_map,\n-            session::session sess);\n+        {freevars: freevar_map,\n+         def_map: resolve::def_map,\n+         sess: session::session};\n \n-    fn walk_fn(env e, &ast::_fn f, &ast::ty_param[] tps, &span sp,\n-               &ast::fn_ident i, ast::node_id nid) {\n-        fn start_walk(&ast::_fn f, &ast::ty_param[] tps, &span sp,\n-                      &ast::fn_ident i, ast::node_id nid, &visit::vt[()] v) {\n+    fn walk_fn(e: env, f: &ast::_fn, tps: &ast::ty_param[], sp: &span,\n+               i: &ast::fn_ident, nid: ast::node_id) {\n+        fn start_walk(f: &ast::_fn, tps: &ast::ty_param[], sp: &span,\n+                      i: &ast::fn_ident, nid: ast::node_id,\n+                      v: &visit::vt[()]) {\n             v.visit_fn(f, tps, sp, i, nid, (), v);\n         }\n-        auto walker = bind start_walk(f, tps, sp, i, nid, _);\n-        auto vars = collect_freevars(e.def_map, e.sess, walker, ~[]);\n+        let walker = bind start_walk(f, tps, sp, i, nid, _);\n+        let vars = collect_freevars(e.def_map, e.sess, walker, ~[]);\n         e.freevars.insert(nid, vars);\n     }\n-    fn walk_expr(env e, &@ast::expr expr) {\n-        alt (expr.node) {\n-            ast::expr_for_each(?local, _, ?body) {\n-                fn start_walk(&ast::blk b, &visit::vt[()] v) {\n-                    v.visit_block(b, (), v);\n-                }\n-                auto vars = collect_freevars\n-                    (e.def_map, e.sess, bind start_walk(body, _),\n-                     ~[local.node.id]);\n-                e.freevars.insert(body.node.id, vars);\n+    fn walk_expr(e: env, expr: &@ast::expr) {\n+        alt expr.node {\n+          ast::expr_for_each(local, _, body) {\n+            fn start_walk(b: &ast::blk, v: &visit::vt[()]) {\n+                v.visit_block(b, (), v);\n             }\n-            _ {}\n+            let vars =\n+                collect_freevars(e.def_map, e.sess, bind start_walk(body, _),\n+                                 ~[local.node.id]);\n+            e.freevars.insert(body.node.id, vars);\n+          }\n+          _ { }\n         }\n     }\n \n-    let env e =\n-        rec(freevars = new_int_hash(), def_map=def_map, sess=sess);\n-    auto visitor = visit::mk_simple_visitor\n-        (@rec(visit_fn=bind walk_fn(e, _, _, _, _, _),\n-              visit_expr=bind walk_expr(e, _)\n-              with *visit::default_simple_visitor()));\n+    let e: env = {freevars: new_int_hash(), def_map: def_map, sess: sess};\n+    let visitor =\n+        visit::mk_simple_visitor(@{visit_fn: bind walk_fn(e, _, _, _, _, _),\n+                                   visit_expr: bind walk_expr(e, _)\n+                                      with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visitor);\n \n     ret e.freevars;\n }\n \n-fn get_freevar_info(&ty::ctxt tcx, ast::node_id fid) -> freevar_info {\n-    alt (tcx.freevars.find(fid)) {\n-        none {\n-            fail \"get_freevars: \" + int::str(fid) + \" has no freevars\";\n-        }\n-        some(?d) { ret d; }\n+fn get_freevar_info(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_info {\n+    alt tcx.freevars.find(fid) {\n+      none. { fail \"get_freevars: \" + int::str(fid) + \" has no freevars\"; }\n+      some(d) { ret d; }\n     }\n }\n-fn get_freevars(&ty::ctxt tcx, ast::node_id fid) -> freevar_set {\n+fn get_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_set {\n     ret get_freevar_info(tcx, fid).defs;\n }\n-fn get_freevar_uses(&ty::ctxt tcx, ast::node_id fid) -> @ast::node_id[] {\n+fn get_freevar_uses(tcx: &ty::ctxt, fid: ast::node_id) -> @ast::node_id[] {\n     ret get_freevar_info(tcx, fid).uses;\n }\n-fn has_freevars(&ty::ctxt tcx, ast::node_id fid) -> bool {\n+fn has_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> bool {\n     ret get_freevars(tcx, fid).size() != 0u;\n }\n-fn is_freevar_of(&ty::ctxt tcx, ast::node_id var, ast::node_id f) -> bool {\n+fn is_freevar_of(tcx: &ty::ctxt, var: ast::node_id, f: ast::node_id) -> bool {\n     ret get_freevars(tcx, f).contains_key(var);\n }\n-fn def_lookup(&ty::ctxt tcx, ast::node_id f, ast::node_id id) ->\n-    option::t[ast::def] {\n-    alt (tcx.def_map.find(id)) {\n-      none { ret none; }\n-      some(?d) {\n-        auto did = ast::def_id_of_def(d);\n+fn def_lookup(tcx: &ty::ctxt, f: ast::node_id, id: ast::node_id) ->\n+   option::t[ast::def] {\n+    alt tcx.def_map.find(id) {\n+      none. { ret none; }\n+      some(d) {\n+        let did = ast::def_id_of_def(d);\n         if is_freevar_of(tcx, did.node, f) {\n             ret some(ast::def_upvar(did, @d));\n         } else { ret some(d); }"}, {"sha": "443e5cc8c73b7131198aaaa8e176957a51bcd2fd", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 823, "deletions": 873, "changes": 1696, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -52,6 +52,7 @@ tag scope {\n     scope_fn(ast::fn_decl, ast::proto, ast::ty_param[]);\n     scope_native_item(@ast::native_item);\n     scope_loop(@ast::local); // there's only 1 decl per loop.\n+\n     scope_block(ast::blk);\n     scope_arm(ast::arm);\n }\n@@ -60,28 +61,30 @@ type scopes = list[scope];\n \n tag import_state {\n     todo(@ast::view_item, scopes); // only used for explicit imports\n+\n     resolving(span);\n-    resolved(option::t[def], /* value */\n-             option::t[def], /* type */\n+    resolved(option::t[def],\n+              /* value */\n+             option::t[def],\n+              /* type */\n              option::t[def]); /* module */\n }\n \n-type ext_hash = hashmap[rec(def_id did, str ident, namespace ns), def];\n+type ext_hash = hashmap[{did: def_id, ident: str, ns: namespace}, def];\n \n fn new_ext_hash() -> ext_hash {\n-    type key = rec(def_id did, str ident, namespace ns);\n-    fn hash(&key v) -> uint {\n+    type key = {did: def_id, ident: str, ns: namespace};\n+    fn hash(v: &key) -> uint {\n         ret str::hash(v.ident) + util::common::hash_def(v.did) +\n-                alt (v.ns) {\n-                    case (ns_value) { 1u }\n-                    case (ns_type) { 2u }\n-                    case (ns_module) { 3u }\n+                alt v.ns {\n+                  ns_value. { 1u }\n+                  ns_type. { 2u }\n+                  ns_module. { 3u }\n                 };\n     }\n-    fn eq(&key v1, &key v2) ->\n-       bool {\n+    fn eq(v1: &key, v2: &key) -> bool {\n         ret util::common::def_eq(v1.did, v2.did) &&\n-            str::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n+                str::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n     }\n     ret std::map::mk_hashmap[key, def](hash, eq);\n }\n@@ -90,19 +93,19 @@ tag mod_index_entry {\n     mie_view_item(@ast::view_item);\n     mie_item(@ast::item);\n     mie_native_item(@ast::native_item);\n-    mie_tag_variant(@ast::item /* tag item */, uint /* variant index */);\n+    mie_tag_variant(/* tag item */@ast::item, /* variant index */uint);\n }\n \n type mod_index = hashmap[ident, list[mod_index_entry]];\n \n // A tuple of an imported def and the import stmt that brung it\n-type glob_imp_def = rec(def def, @ast::view_item item);\n+type glob_imp_def = {def: def, item: @ast::view_item};\n \n type indexed_mod =\n-    rec(option::t[ast::_mod] m,\n-        mod_index index,\n-        mutable glob_imp_def[] glob_imports,\n-        hashmap[str, import_state] glob_imported_names);\n+    {m: option::t[ast::_mod],\n+     index: mod_index,\n+     mutable glob_imports: glob_imp_def[],\n+     glob_imported_names: hashmap[str, import_state]};\n \n \n /* native modules can't contain tags, and we don't store their ASTs because we\n@@ -111,15 +114,15 @@ type indexed_mod =\n type def_map = hashmap[node_id, def];\n \n type env =\n-    rec(cstore::cstore cstore,\n-        def_map def_map,\n-        ast_map::map ast_map,\n-        hashmap[ast::node_id, import_state] imports,\n-        hashmap[ast::node_id, @indexed_mod] mod_map,\n-        hashmap[def_id, ident[]] ext_map,\n-        ext_hash ext_cache,\n-        mutable rec(str ident, scope sc)[] reported,\n-        session sess);\n+    {cstore: cstore::cstore,\n+     def_map: def_map,\n+     ast_map: ast_map::map,\n+     imports: hashmap[ast::node_id, import_state],\n+     mod_map: hashmap[ast::node_id, @indexed_mod],\n+     ext_map: hashmap[def_id, ident[]],\n+     ext_cache: ext_hash,\n+     mutable reported: {ident: str, sc: scope}[],\n+     sess: session};\n \n \n // Used to distinguish between lookups from outside and from inside modules,\n@@ -128,18 +131,18 @@ tag dir { inside; outside; }\n \n tag namespace { ns_value; ns_type; ns_module; }\n \n-fn resolve_crate(session sess, &ast_map::map amap, @ast::crate crate)\n-  -> def_map {\n-    auto e =\n-        @rec(cstore=sess.get_cstore(),\n-             def_map=new_int_hash[def](),\n-             ast_map=amap,\n-             imports=new_int_hash[import_state](),\n-             mod_map=new_int_hash[@indexed_mod](),\n-             ext_map=new_def_hash[ident[]](),\n-             ext_cache=new_ext_hash(),\n-             mutable reported=~[],\n-             sess=sess);\n+fn resolve_crate(sess: session, amap: &ast_map::map, crate: @ast::crate) ->\n+   def_map {\n+    let e =\n+        @{cstore: sess.get_cstore(),\n+          def_map: new_int_hash[def](),\n+          ast_map: amap,\n+          imports: new_int_hash[import_state](),\n+          mod_map: new_int_hash[@indexed_mod](),\n+          ext_map: new_def_hash[ident[]](),\n+          ext_cache: new_ext_hash(),\n+          mutable reported: ~[],\n+          sess: sess};\n     map_crate(e, crate);\n     resolve_imports(*e);\n     check_for_collisions(e, *crate);\n@@ -150,325 +153,318 @@ fn resolve_crate(session sess, &ast_map::map amap, @ast::crate crate)\n \n // Locate all modules and imports and index them, so that the next passes can\n // resolve through them.\n-fn map_crate(&@env e, &@ast::crate c) {\n+fn map_crate(e: &@env, c: &@ast::crate) {\n     // First, find all the modules, and index the names that they contain\n \n-    auto v_map_mod =\n-        @rec(visit_view_item=bind index_vi(e, _, _, _),\n-             visit_item=bind index_i(e, _, _, _)\n-             with *visit::default_visitor[scopes]());\n-    visit::visit_crate(*c, cons(scope_crate, @nil),\n-                       visit::mk_vt(v_map_mod));\n+    let v_map_mod =\n+        @{visit_view_item: bind index_vi(e, _, _, _),\n+          visit_item: bind index_i(e, _, _, _)\n+             with *visit::default_visitor[scopes]()};\n+    visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v_map_mod));\n     // Register the top-level mod\n \n     e.mod_map.insert(-1,\n-                     @rec(m=some(c.node.module),\n-                          index=index_mod(c.node.module),\n-                          mutable glob_imports=~[],\n-                          glob_imported_names=new_str_hash[import_state]()));\n-    fn index_vi(@env e, &@ast::view_item i, &scopes sc, &vt[scopes] v) {\n-        alt (i.node) {\n-            case (ast::view_item_import(_, ?ids, ?id)) {\n-                e.imports.insert(id, todo(i, sc));\n-            }\n-            case (_) { }\n+                     @{m: some(c.node.module),\n+                       index: index_mod(c.node.module),\n+                       mutable glob_imports: ~[],\n+                       glob_imported_names: new_str_hash[import_state]()});\n+    fn index_vi(e: @env, i: &@ast::view_item, sc: &scopes, v: &vt[scopes]) {\n+        alt i.node {\n+          ast::view_item_import(_, ids, id) {\n+            e.imports.insert(id, todo(i, sc));\n+          }\n+          _ { }\n         }\n     }\n-    fn index_i(@env e, &@ast::item i, &scopes sc, &vt[scopes] v) {\n+    fn index_i(e: @env, i: &@ast::item, sc: &scopes, v: &vt[scopes]) {\n         visit_item_with_scope(i, sc, v);\n-        alt (i.node) {\n-            case (ast::item_mod(?md)) {\n-                auto s = new_str_hash[import_state]();\n-                e.mod_map.insert(i.id,\n-                                 @rec(m=some(md),\n-                                      index=index_mod(md),\n-                                      mutable glob_imports=~[],\n-                                      glob_imported_names=s));\n-            }\n-            case (ast::item_native_mod(?nmd)) {\n-                auto s = new_str_hash[import_state]();\n-                e.mod_map.insert(i.id,\n-                                 @rec(m=none[ast::_mod],\n-                                      index=index_nmod(nmd),\n-                                      mutable glob_imports=~[],\n-                                      glob_imported_names=s));\n-            }\n-            case (_) { }\n+        alt i.node {\n+          ast::item_mod(md) {\n+            let s = new_str_hash[import_state]();\n+            e.mod_map.insert(i.id,\n+                             @{m: some(md),\n+                               index: index_mod(md),\n+                               mutable glob_imports: ~[],\n+                               glob_imported_names: s});\n+          }\n+          ast::item_native_mod(nmd) {\n+            let s = new_str_hash[import_state]();\n+            e.mod_map.insert(i.id,\n+                             @{m: none[ast::_mod],\n+                               index: index_nmod(nmd),\n+                               mutable glob_imports: ~[],\n+                               glob_imported_names: s});\n+          }\n+          _ { }\n         }\n     }\n     // Next, assemble the links for globbed imports.\n \n-    auto v_link_glob =\n-        @rec(visit_view_item=bind link_glob(e, _, _, _),\n-             visit_item=visit_item_with_scope\n-             with *visit::default_visitor[scopes]());\n+    let v_link_glob =\n+        @{visit_view_item: bind link_glob(e, _, _, _),\n+          visit_item: visit_item_with_scope\n+             with *visit::default_visitor[scopes]()};\n     visit::visit_crate(*c, cons(scope_crate, @nil),\n                        visit::mk_vt(v_link_glob));\n-    fn link_glob(@env e, &@ast::view_item vi, &scopes sc, &vt[scopes] v) {\n-        fn find_mod(@env e, scopes sc) -> @indexed_mod {\n-            alt (sc) {\n-                case (cons(scope_item(?i), ?tl)) {\n-                    alt (i.node) {\n-                        ast::item_mod(_) | ast::item_native_mod(_) {\n-                            ret e.mod_map.get(i.id);\n-                        }\n-                        _ { be find_mod(e, *tl); }\n-                    }\n+    fn link_glob(e: @env, vi: &@ast::view_item, sc: &scopes, v: &vt[scopes]) {\n+        fn find_mod(e: @env, sc: scopes) -> @indexed_mod {\n+            alt sc {\n+              cons(scope_item(i), tl) {\n+                alt i.node {\n+                  ast::item_mod(_) | ast::item_native_mod(_) {\n+                    ret e.mod_map.get(i.id);\n+                  }\n+                  _ { be find_mod(e, *tl); }\n                 }\n-                case (_) {\n-                    ret e.mod_map.get(-1); //top-level\n+              }\n+              _ {\n+                ret e.mod_map.get(-1); //top-level\n \n-                }\n+              }\n             }\n         }\n-        alt (vi.node) {\n-            //if it really is a glob import, that is\n-            case (ast::view_item_import_glob(?path, _)) {\n-                auto imp = follow_import(*e, sc, path, vi.span);\n-                if (option::is_some(imp)) {\n-                    find_mod(e, sc).glob_imports +=\n-                        ~[rec(def=option::get(imp), item=vi)];\n-                }\n+        alt vi.node {\n+\n+          //if it really is a glob import, that is\n+          ast::view_item_import_glob(path, _) {\n+            let imp = follow_import(*e, sc, path, vi.span);\n+            if option::is_some(imp) {\n+                find_mod(e, sc).glob_imports +=\n+                    ~[{def: option::get(imp), item: vi}];\n             }\n-            case (_) { }\n+          }\n+          _ { }\n         }\n     }\n }\n \n-fn resolve_imports(&env e) {\n-    for each (@rec(ast::node_id key, import_state val) it\n-              in e.imports.items()) {\n-        alt (it.val) {\n-            case (todo(?item, ?sc)) { resolve_import(e, item, sc); }\n-            case (resolved(_, _, _)) { }\n+fn resolve_imports(e: &env) {\n+    for each it: @{key: ast::node_id, val: import_state}  in e.imports.items()\n+             {\n+        alt it.val {\n+          todo(item, sc) { resolve_import(e, item, sc); }\n+          resolved(_, _, _) { }\n         }\n     }\n     e.sess.abort_if_errors();\n }\n \n-fn resolve_names(&@env e, &@ast::crate c) {\n-    auto v =\n-        @rec(visit_native_item=visit_native_item_with_scope,\n-             visit_item=visit_item_with_scope,\n-             visit_block=visit_block_with_scope,\n-             visit_arm=bind walk_arm(e, _, _, _),\n-             visit_expr=bind walk_expr(e, _, _, _),\n-             visit_ty=bind walk_ty(e, _, _, _),\n-             visit_constr=bind walk_constr(e, _, _, _, _, _),\n-             visit_fn=bind visit_fn_with_scope(e, _, _, _, _, _, _, _)\n-             with *visit::default_visitor());\n+fn resolve_names(e: &@env, c: &@ast::crate) {\n+    let v =\n+        @{visit_native_item: visit_native_item_with_scope,\n+          visit_item: visit_item_with_scope,\n+          visit_block: visit_block_with_scope,\n+          visit_arm: bind walk_arm(e, _, _, _),\n+          visit_expr: bind walk_expr(e, _, _, _),\n+          visit_ty: bind walk_ty(e, _, _, _),\n+          visit_constr: bind walk_constr(e, _, _, _, _, _),\n+          visit_fn: bind visit_fn_with_scope(e, _, _, _, _, _, _, _)\n+             with *visit::default_visitor()};\n     visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v));\n     e.sess.abort_if_errors();\n \n-    fn walk_expr(@env e, &@ast::expr exp, &scopes sc, &vt[scopes] v) {\n+    fn walk_expr(e: @env, exp: &@ast::expr, sc: &scopes, v: &vt[scopes]) {\n         visit_expr_with_scope(exp, sc, v);\n-        alt (exp.node) {\n-            case (ast::expr_path(?p)) {\n-                maybe_insert(e, exp.id,\n-                             lookup_path_strict(*e, sc, exp.span, p.node,\n-                                                ns_value));\n-            }\n-            case (_) { }\n+        alt exp.node {\n+          ast::expr_path(p) {\n+            maybe_insert(e, exp.id,\n+                         lookup_path_strict(*e, sc, exp.span, p.node,\n+                                            ns_value));\n+          }\n+          _ { }\n         }\n     }\n-    fn walk_ty(@env e, &@ast::ty t, &scopes sc, &vt[scopes] v) {\n+    fn walk_ty(e: @env, t: &@ast::ty, sc: &scopes, v: &vt[scopes]) {\n         visit::visit_ty(t, sc, v);\n-        alt (t.node) {\n-            case (ast::ty_path(?p, ?id)) {\n-                maybe_insert(e, id,\n-                             lookup_path_strict(*e, sc, t.span, p.node,\n-                                                ns_type));\n-            }\n-            case (_) { }\n+        alt t.node {\n+          ast::ty_path(p, id) {\n+            maybe_insert(e, id,\n+                         lookup_path_strict(*e, sc, t.span, p.node, ns_type));\n+          }\n+          _ { }\n         }\n     }\n-    fn walk_constr(@env e, &ast::path p, &span sp, node_id id,\n-                   &scopes sc, &vt[scopes] v) {\n+    fn walk_constr(e: @env, p: &ast::path, sp: &span, id: node_id,\n+                   sc: &scopes, v: &vt[scopes]) {\n         maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p.node, ns_value));\n     }\n-    fn walk_arm(@env e, &ast::arm a, &scopes sc, &vt[scopes] v) {\n-        for (@ast::pat p in a.pats) { walk_pat(*e, sc, p); }\n+    fn walk_arm(e: @env, a: &ast::arm, sc: &scopes, v: &vt[scopes]) {\n+        for p: @ast::pat  in a.pats { walk_pat(*e, sc, p); }\n         visit_arm_with_scope(a, sc, v);\n     }\n-    fn walk_pat(&env e, &scopes sc, &@ast::pat pat) {\n-        alt (pat.node) {\n-            case (ast::pat_tag(?p, ?children)) {\n-                auto fnd =\n-                    lookup_path_strict(e, sc, p.span, p.node, ns_value);\n-                if (option::is_some(fnd)) {\n-                    alt (option::get(fnd)) {\n-                        case (ast::def_variant(?did, ?vid)) {\n-                            e.def_map.insert(pat.id, option::get(fnd));\n-                            for (@ast::pat child in children) {\n-                                walk_pat(e, sc, child);\n-                            }\n-                        }\n-                        case (_) {\n-                            e.sess.span_err(p.span,\n-                                            \"not a tag variant: \" +\n-                                            ast::path_name(p));\n-                        }\n+    fn walk_pat(e: &env, sc: &scopes, pat: &@ast::pat) {\n+        alt pat.node {\n+          ast::pat_tag(p, children) {\n+            let fnd = lookup_path_strict(e, sc, p.span, p.node, ns_value);\n+            if option::is_some(fnd) {\n+                alt option::get(fnd) {\n+                  ast::def_variant(did, vid) {\n+                    e.def_map.insert(pat.id, option::get(fnd));\n+                    for child: @ast::pat  in children {\n+                        walk_pat(e, sc, child);\n                     }\n+                  }\n+                  _ {\n+                    e.sess.span_err(p.span,\n+                                    \"not a tag variant: \" +\n+                                        ast::path_name(p));\n+                  }\n                 }\n             }\n-            case (ast::pat_rec(?fields, _)) {\n-                for (ast::field_pat f in fields) { walk_pat(e, sc, f.pat); }\n-            }\n-            case (ast::pat_box(?inner)) { walk_pat(e, sc, inner); }\n-            case (_) { }\n+          }\n+          ast::pat_rec(fields, _) {\n+            for f: ast::field_pat  in fields { walk_pat(e, sc, f.pat); }\n+          }\n+          ast::pat_box(inner) { walk_pat(e, sc, inner); }\n+          _ { }\n         }\n     }\n \n-    fn maybe_insert(@env e, node_id id,\n-                    option::t[def] def) {\n-        if (option::is_some(def)) {\n-            e.def_map.insert(id, option::get(def));\n-        }\n+    fn maybe_insert(e: @env, id: node_id, def: option::t[def]) {\n+        if option::is_some(def) { e.def_map.insert(id, option::get(def)); }\n     }\n }\n \n \n // Visit helper functions\n-fn visit_item_with_scope(&@ast::item i, &scopes sc, &vt[scopes] v) {\n+fn visit_item_with_scope(i: &@ast::item, sc: &scopes, v: &vt[scopes]) {\n     visit::visit_item(i, cons(scope_item(i), @sc), v);\n }\n \n-fn visit_native_item_with_scope(&@ast::native_item ni, &scopes sc,\n-                                &vt[scopes] v) {\n+fn visit_native_item_with_scope(ni: &@ast::native_item, sc: &scopes,\n+                                v: &vt[scopes]) {\n     visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n \n-fn visit_fn_with_scope(&@env e, &ast::_fn f, &ast::ty_param[] tp, &span sp,\n-                       &fn_ident name, node_id id, &scopes sc,\n-                       &vt[scopes] v) {\n+fn visit_fn_with_scope(e: &@env, f: &ast::_fn, tp: &ast::ty_param[],\n+                       sp: &span, name: &fn_ident, id: node_id, sc: &scopes,\n+                       v: &vt[scopes]) {\n     // is this a main fn declaration?\n-    alt (name) {\n-        case (some(?nm)) {\n-            if (is_main_name(~[nm]) && !e.sess.get_opts().library) {\n-                // This is a main function -- set it in the session\n-                // as the main ID\n-                e.sess.set_main_id(id);\n-            }\n+    alt name {\n+      some(nm) {\n+        if is_main_name(~[nm]) && !e.sess.get_opts().library {\n+            // This is a main function -- set it in the session\n+            // as the main ID\n+            e.sess.set_main_id(id);\n         }\n-        case (_) {}\n+      }\n+      _ { }\n     }\n \n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n \n-    for (@ast::constr c in f.decl.constraints) {\n+    for c: @ast::constr  in f.decl.constraints {\n         resolve_constr(e, id, c, sc, v);\n     }\n     visit::visit_fn(f, tp, sp, name, id,\n                     cons(scope_fn(f.decl, f.proto, tp), @sc), v);\n }\n \n-fn visit_block_with_scope(&ast::blk b, &scopes sc, &vt[scopes] v) {\n+fn visit_block_with_scope(b: &ast::blk, sc: &scopes, v: &vt[scopes]) {\n     visit::visit_block(b, cons(scope_block(b), @sc), v);\n }\n \n-fn visit_arm_with_scope(&ast::arm a, &scopes sc, &vt[scopes] v) {\n+fn visit_arm_with_scope(a: &ast::arm, sc: &scopes, v: &vt[scopes]) {\n     visit::visit_arm(a, cons(scope_arm(a), @sc), v);\n }\n \n-fn visit_expr_with_scope(&@ast::expr x, &scopes sc, &vt[scopes] v) {\n-    alt (x.node) {\n-      ast::expr_for(?decl, ?coll, ?blk) |\n-      ast::expr_for_each(?decl, ?coll, ?blk) {\n-        auto new_sc = cons[scope](scope_loop(decl), @sc);\n+fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt[scopes]) {\n+    alt x.node {\n+      ast::expr_for(decl, coll, blk) | ast::expr_for_each(decl, coll, blk) {\n+        let new_sc = cons[scope](scope_loop(decl), @sc);\n         v.visit_expr(coll, sc, v);\n         v.visit_local(decl, new_sc, v);\n         v.visit_block(blk, new_sc, v);\n       }\n-      ast::expr_fn(?f) {\n+      ast::expr_fn(f) {\n         visit::visit_expr(x, cons(scope_fn(f.decl, f.proto, ~[]), @sc), v);\n       }\n       _ { visit::visit_expr(x, sc, v); }\n-    };\n+    }\n }\n \n-fn follow_import(&env e, &scopes sc, &ident[] path, &span sp)\n-        -> option::t[def] {\n-    auto path_len = ivec::len(path);\n-    auto dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n-    auto i = 1u;\n-    while (true && option::is_some(dcur)) {\n-        if (i == path_len) { break; }\n-        dcur = lookup_in_mod_strict(e, sc, option::get(dcur),\n-                                    sp, path.(i), ns_module, outside);\n+fn follow_import(e: &env, sc: &scopes, path: &ident[], sp: &span) ->\n+   option::t[def] {\n+    let path_len = ivec::len(path);\n+    let dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n+    let i = 1u;\n+    while true && option::is_some(dcur) {\n+        if i == path_len { break; }\n+        dcur =\n+            lookup_in_mod_strict(e, sc, option::get(dcur), sp, path.(i),\n+                                 ns_module, outside);\n         i += 1u;\n     }\n-    if (i == path_len) {\n-        alt (option::get(dcur)) {\n-            ast::def_mod(_) | ast::def_native_mod(_) { ret dcur; }\n-            _ {\n-                e.sess.span_err(sp, str::connect_ivec(path, \"::\") +\n+    if i == path_len {\n+        alt option::get(dcur) {\n+          ast::def_mod(_) | ast::def_native_mod(_) { ret dcur; }\n+          _ {\n+            e.sess.span_err(sp,\n+                            str::connect_ivec(path, \"::\") +\n                                 \" does not name a module.\");\n-                ret none;\n-            }\n+            ret none;\n+          }\n         }\n-    } else {\n-        ret none;\n-    }\n+    } else { ret none; }\n }\n \n-fn resolve_constr(@env e, node_id id, &@ast::constr c, &scopes sc,\n-                  &vt[scopes] v) {\n-    auto new_def =\n+fn resolve_constr(e: @env, id: node_id, c: &@ast::constr, sc: &scopes,\n+                  v: &vt[scopes]) {\n+    let new_def =\n         lookup_path_strict(*e, sc, c.span, c.node.path.node, ns_value);\n-    if (option::is_some(new_def)) {\n-        alt (option::get(new_def)) {\n-            case (ast::def_fn(?pred_id, ast::pure_fn)) {\n-                e.def_map.insert(c.node.id, ast::def_fn(pred_id,\n-                                                        ast::pure_fn));\n-            }\n-            case (_) {\n-                e.sess.span_err(c.span,\n-                                \"Non-predicate in constraint: \" +\n+    if option::is_some(new_def) {\n+        alt option::get(new_def) {\n+          ast::def_fn(pred_id, ast::pure_fn.) {\n+            e.def_map.insert(c.node.id, ast::def_fn(pred_id, ast::pure_fn));\n+          }\n+          _ {\n+            e.sess.span_err(c.span,\n+                            \"Non-predicate in constraint: \" +\n                                 path_to_str(c.node.path));\n-            }\n+          }\n         }\n     }\n }\n \n // Import resolution\n-fn resolve_import(&env e, &@ast::view_item it, &scopes sc_in) {\n-    auto defid;\n-    auto ids;\n-    auto name;\n-    alt (it.node) {\n-        case (ast::view_item_import(?_name, ?_ids, ?_id)) {\n-            defid = local_def(_id);\n-            ids = _ids;\n-            name = _name;\n-        }\n+fn resolve_import(e: &env, it: &@ast::view_item, sc_in: &scopes) {\n+    let defid;\n+    let ids;\n+    let name;\n+    alt it.node {\n+      ast::view_item_import(_name, _ids, _id) {\n+        defid = local_def(_id);\n+        ids = _ids;\n+        name = _name;\n+      }\n     }\n     e.imports.insert(defid.node, resolving(it.span));\n-    auto n_idents = ivec::len(ids);\n-    auto end_id = ids.(n_idents - 1u);\n+    let n_idents = ivec::len(ids);\n+    let end_id = ids.(n_idents - 1u);\n     // Ignore the current scope if this import would shadow itself.\n-    auto sc = if str::eq(name, ids.(0)) { std::list::cdr(sc_in) }\n-              else { sc_in };\n-    if (n_idents == 1u) {\n+    let sc =\n+        if str::eq(name, ids.(0)) { std::list::cdr(sc_in) } else { sc_in };\n+    if n_idents == 1u {\n         register(e, defid, it.span, end_id, sc_in,\n                  lookup_in_scope(e, sc, it.span, end_id, ns_value),\n                  lookup_in_scope(e, sc, it.span, end_id, ns_type),\n                  lookup_in_scope(e, sc, it.span, end_id, ns_module));\n         remove_if_unresolved(e.imports, defid.node);\n     } else {\n-        auto dcur = alt(lookup_in_scope(e, sc, it.span, ids.(0), ns_module)) {\n-            case (some(?dcur)) {\n-                dcur\n-            }\n-            case (none) {\n+        let  // FIXME (issue #521)\n+            dcur =\n+            alt lookup_in_scope(e, sc, it.span, ids.(0), ns_module) {\n+              some(dcur) { dcur }\n+              none. {\n                 unresolved_err(e, sc, it.span, ids.(0), ns_name(ns_module));\n                 remove_if_unresolved(e.imports, defid.node);\n-                ret () // FIXME (issue #521)\n-            }\n-        };\n-        auto i = 1u;\n-        while (true) {\n-            if (i == n_idents - 1u) {\n+                ret ()\n+              }\n+            };\n+        let i = 1u;\n+        while true {\n+            if i == n_idents - 1u {\n                 register(e, defid, it.span, end_id, sc_in,\n                          lookup_in_mod(e, dcur, it.span, end_id, ns_value,\n                                        outside),\n@@ -479,64 +475,60 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc_in) {\n                 remove_if_unresolved(e.imports, defid.node);\n                 break;\n             } else {\n-                dcur = alt (lookup_in_mod(e, dcur, it.span, ids.(i),\n-                                          ns_module, outside)) {\n-                    case (some(?dcur)) {\n-                        dcur\n-                    }\n-                    case (none) {\n+                dcur =\n+                    alt lookup_in_mod(e, dcur, it.span, ids.(i), ns_module,\n+                                      outside) {\n+                      some(dcur) { dcur }\n+                      none. {\n                         unresolved_err(e, sc, it.span, ids.(i),\n                                        ns_name(ns_module));\n                         remove_if_unresolved(e.imports, defid.node);\n                         ret () // FIXME (issue #521)\n-                    }\n-                };\n+                      }\n+                    };\n                 i += 1u;\n             }\n         }\n     }\n-    fn register(&env e, def_id defid, &span sp, &ident name, &scopes sc,\n-                &option::t[def] val, &option::t[def] typ,\n-                &option::t[def] md) {\n+    fn register(e: &env, defid: def_id, sp: &span, name: &ident, sc: &scopes,\n+                val: &option::t[def], typ: &option::t[def],\n+                md: &option::t[def]) {\n         if is_none(val) && is_none(typ) && is_none(md) {\n             unresolved_err(e, sc, sp, name, \"import\");\n-        } else {\n-            e.imports.insert(defid.node, resolved(val, typ, md));\n-        }\n+        } else { e.imports.insert(defid.node, resolved(val, typ, md)); }\n     }\n-    fn remove_if_unresolved(hashmap[ast::node_id, import_state] imports,\n-                            ast::node_id node_id) {\n+    fn remove_if_unresolved(imports: hashmap[ast::node_id, import_state],\n+                            node_id: ast::node_id) {\n+\n         // If we couldn't resolve the import, don't leave it in a partially\n         // resolved state, to avoid having it reported later as a cyclic\n         // import\n-        if (imports.contains_key(node_id)) {\n-            alt (imports.get(node_id)) {\n-                case (resolving(_)) {\n-                    imports.remove(node_id);\n-                }\n-                case (_) { }\n+        if imports.contains_key(node_id) {\n+            alt imports.get(node_id) {\n+              resolving(_) { imports.remove(node_id); }\n+              _ { }\n             }\n         }\n     }\n }\n \n \n // Utilities\n-fn ns_name(namespace ns) -> str {\n-    alt (ns) {\n-        case (ns_type) { ret \"typename\"; }\n-        case (ns_value) { ret \"name\"; }\n-        case (ns_module) { ret \"modulename\"; }\n+fn ns_name(ns: namespace) -> str {\n+    alt ns {\n+      ns_type. { ret \"typename\"; }\n+      ns_value. { ret \"name\"; }\n+      ns_module. { ret \"modulename\"; }\n     }\n }\n \n-fn unresolved_err(&env e, &scopes sc, &span sp, &ident name, &str kind) {\n-    fn find_fn_or_mod_scope(scopes sc) -> scope {\n+fn unresolved_err(e: &env, sc: &scopes, sp: &span, name: &ident, kind: &str) {\n+    fn find_fn_or_mod_scope(sc: scopes) -> scope {\n         while true {\n             alt sc {\n-              cons(?cur, ?rest) {\n+              cons(cur, rest) {\n                 alt cur {\n-                  scope_crate | scope_fn(_, _, _) |\n+                  scope_crate. | scope_fn(_, _, _) |\n                   scope_item(@{node: ast::item_mod(_), _}) {\n                     ret cur;\n                   }\n@@ -547,880 +539,838 @@ fn unresolved_err(&env e, &scopes sc, &span sp, &ident name, &str kind) {\n         }\n         fail;\n     }\n-    auto err_scope = find_fn_or_mod_scope(sc);\n-    for (rec(str ident, scope sc) rs in e.reported) {\n+    let err_scope = find_fn_or_mod_scope(sc);\n+    for rs: {ident: str, sc: scope}  in e.reported {\n         if str::eq(rs.ident, name) && err_scope == rs.sc { ret; }\n     }\n-    e.reported += ~[rec(ident=name, sc=err_scope)];\n+    e.reported += ~[{ident: name, sc: err_scope}];\n     e.sess.span_err(sp, mk_unresolved_msg(name, kind));\n }\n \n-fn unresolved_fatal(&env e, &span sp, &ident id, &str kind) -> ! {\n+fn unresolved_fatal(e: &env, sp: &span, id: &ident, kind: &str) -> ! {\n     e.sess.span_fatal(sp, mk_unresolved_msg(id, kind));\n }\n \n-fn mk_unresolved_msg(&ident id, &str kind) -> str {\n+fn mk_unresolved_msg(id: &ident, kind: &str) -> str {\n     ret #fmt(\"unresolved %s: %s\", kind, id);\n }\n \n // Lookup helpers\n-fn lookup_path_strict(&env e, &scopes sc, &span sp, &ast::path_ pth,\n-                      namespace ns) -> option::t[def] {\n-    auto n_idents = ivec::len(pth.idents);\n-    auto headns = if (n_idents == 1u) { ns } else { ns_module };\n+fn lookup_path_strict(e: &env, sc: &scopes, sp: &span, pth: &ast::path_,\n+                      ns: namespace) -> option::t[def] {\n+    let n_idents = ivec::len(pth.idents);\n+    let headns = if n_idents == 1u { ns } else { ns_module };\n \n-    auto first_scope;\n-    if (pth.global) {\n+    let first_scope;\n+    if pth.global {\n         first_scope = list::cons(scope_crate, @list::nil);\n-    } else {\n-        first_scope = sc;\n-    }\n+    } else { first_scope = sc; }\n \n-    auto dcur = lookup_in_scope_strict(e, first_scope, sp, pth.idents.(0),\n-                                       headns);\n+    let dcur =\n+        lookup_in_scope_strict(e, first_scope, sp, pth.idents.(0), headns);\n \n-    auto i = 1u;\n-    while (i < n_idents && option::is_some(dcur)) {\n-        auto curns = if (n_idents == i + 1u) { ns } else { ns_module };\n-        dcur = lookup_in_mod_strict(e, sc, option::get(dcur),\n-                                    sp, pth.idents.(i), curns, outside);\n+    let i = 1u;\n+    while i < n_idents && option::is_some(dcur) {\n+        let curns = if n_idents == i + 1u { ns } else { ns_module };\n+        dcur =\n+            lookup_in_mod_strict(e, sc, option::get(dcur), sp, pth.idents.(i),\n+                                 curns, outside);\n         i += 1u;\n     }\n     ret dcur;\n }\n \n-fn lookup_in_scope_strict(&env e, scopes sc, &span sp, &ident name,\n-                          namespace ns) -> option::t[def] {\n-    alt (lookup_in_scope(e, sc, sp, name, ns)) {\n-        case (none) {\n-            unresolved_err(e, sc, sp, name, ns_name(ns));\n-            ret none;\n-        }\n-        case (some(?d)) { ret some(d); }\n+fn lookup_in_scope_strict(e: &env, sc: scopes, sp: &span, name: &ident,\n+                          ns: namespace) -> option::t[def] {\n+    alt lookup_in_scope(e, sc, sp, name, ns) {\n+      none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n+      some(d) { ret some(d); }\n     }\n }\n \n-fn scope_is_fn(&scope sc) -> bool {\n-    ret alt (sc) {\n-        scope_fn(_, ast::proto_iter, _) |\n-            scope_fn(_, ast::proto_fn, _) |\n-            scope_native_item(_) { true }\n-        _ { false }\n-    };\n+fn scope_is_fn(sc: &scope) -> bool {\n+    ret alt sc {\n+          scope_fn(_, ast::proto_iter., _) | scope_fn(_, ast::proto_fn., _) |\n+          scope_native_item(_) {\n+            true\n+          }\n+          _ { false }\n+        };\n }\n \n-fn def_is_local(&def d) -> bool {\n-    ret alt (d) {\n-        ast::def_arg(_) | ast::def_local(_) | ast::def_binding(_) { true }\n-        _ { false }\n-    };\n+fn def_is_local(d: &def) -> bool {\n+    ret alt d {\n+          ast::def_arg(_) | ast::def_local(_) | ast::def_binding(_) { true }\n+          _ { false }\n+        };\n }\n \n-fn def_is_obj_field(&def d) -> bool {\n-    ret alt (d) { case (ast::def_obj_field(_)) { true } case (_) { false } };\n+fn def_is_obj_field(d: &def) -> bool {\n+    ret alt d { ast::def_obj_field(_) { true } _ { false } };\n }\n \n-fn def_is_ty_arg(&def d) -> bool {\n-    ret alt(d) { case (ast::def_ty_arg(_)) { true } case (_) { false } };\n+fn def_is_ty_arg(d: &def) -> bool {\n+    ret alt d { ast::def_ty_arg(_) { true } _ { false } };\n }\n \n-fn lookup_in_scope(&env e, scopes sc, &span sp, &ident name, namespace ns) ->\n-   option::t[def] {\n-    fn in_scope(&env e, &span sp, &ident name, &scope s, namespace ns) ->\n+fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n+                   ns: namespace) -> option::t[def] {\n+    fn in_scope(e: &env, sp: &span, name: &ident, s: &scope, ns: namespace) ->\n        option::t[def] {\n-        alt (s) {\n-            case (scope_crate) {\n-                ret lookup_in_local_mod(e, -1, sp, name, ns, inside);\n-            }\n-            case (scope_item(?it)) {\n-                alt (it.node) {\n-                    case (ast::item_obj(?ob, ?ty_params, _)) {\n-                        ret lookup_in_obj(name, ob, ty_params, ns);\n-                    }\n-                    case (ast::item_tag(_, ?ty_params)) {\n-                        if (ns == ns_type) {\n-                            ret lookup_in_ty_params(name, ty_params);\n-                        }\n-                    }\n-                    case (ast::item_mod(_)) {\n-                        ret lookup_in_local_mod\n-                            (e, it.id, sp, name, ns, inside);\n-                    }\n-                    case (ast::item_native_mod(?m)) {\n-                        ret lookup_in_local_native_mod\n-                            (e, it.id, sp, name, ns);\n-                    }\n-                    case (ast::item_ty(_, ?ty_params)) {\n-                        if (ns == ns_type) {\n-                            ret lookup_in_ty_params(name, ty_params);\n-                        }\n-                    }\n-                    case (_) { }\n-                }\n-            }\n-            case (scope_native_item(?it)) {\n-                alt (it.node) {\n-                    case (ast::native_item_fn(_, ?decl, ?ty_params)) {\n-                        ret lookup_in_fn(name, decl, ty_params, ns);\n-                    }\n-                }\n+        alt s {\n+          scope_crate. {\n+            ret lookup_in_local_mod(e, -1, sp, name, ns, inside);\n+          }\n+          scope_item(it) {\n+            alt it.node {\n+              ast::item_obj(ob, ty_params, _) {\n+                ret lookup_in_obj(name, ob, ty_params, ns);\n+              }\n+              ast::item_tag(_, ty_params) {\n+                if ns == ns_type { ret lookup_in_ty_params(name, ty_params); }\n+              }\n+              ast::item_mod(_) {\n+                ret lookup_in_local_mod(e, it.id, sp, name, ns, inside);\n+              }\n+              ast::item_native_mod(m) {\n+                ret lookup_in_local_native_mod(e, it.id, sp, name, ns);\n+              }\n+              ast::item_ty(_, ty_params) {\n+                if ns == ns_type { ret lookup_in_ty_params(name, ty_params); }\n+              }\n+              _ { }\n             }\n-            case (scope_fn(?decl, _, ?ty_params)) {\n+          }\n+          scope_native_item(it) {\n+            alt it.node {\n+              ast::native_item_fn(_, decl, ty_params) {\n                 ret lookup_in_fn(name, decl, ty_params, ns);\n+              }\n             }\n-            case (scope_loop(?local)) {\n-                if (ns == ns_value) {\n-                    if (str::eq(local.node.ident, name)) {\n-                        ret some(ast::def_local(local_def(local.node.id)));\n-                    }\n+          }\n+          scope_fn(decl, _, ty_params) {\n+            ret lookup_in_fn(name, decl, ty_params, ns);\n+          }\n+          scope_loop(local) {\n+            if ns == ns_value {\n+                if str::eq(local.node.ident, name) {\n+                    ret some(ast::def_local(local_def(local.node.id)));\n                 }\n             }\n-            case (scope_block(?b)) { ret lookup_in_block(name, b.node, ns); }\n-            case (scope_arm(?a)) {\n-                if (ns == ns_value) { ret lookup_in_pat(name, *a.pats.(0)); }\n-            }\n+          }\n+          scope_block(b) { ret lookup_in_block(name, b.node, ns); }\n+          scope_arm(a) {\n+            if ns == ns_value { ret lookup_in_pat(name, *a.pats.(0)); }\n+          }\n         }\n         ret none[def];\n     }\n-    auto left_fn = false;\n+    let left_fn = false;\n     // Used to determine whether obj fields are in scope\n \n-    auto left_fn_level2 = false;\n-    while (true) {\n-        alt ({ sc }) {\n-            case (nil) { ret none[def]; }\n-            case (cons(?hd, ?tl)) {\n-                auto fnd = in_scope(e, sp, name, hd, ns);\n-                if (!is_none(fnd)) {\n-                    auto df = option::get(fnd);\n-                    if (left_fn && def_is_local(df) ||\n-                        left_fn_level2 && def_is_obj_field(df)\n-                        || (scope_is_fn(hd) && left_fn\n-                            && def_is_ty_arg(df))) {\n-                        auto msg = alt (ns) {\n-                            case (ns_type) {\n-                                \"Attempt to use a type \\\n+    let left_fn_level2 = false;\n+    while true {\n+        alt { sc } {\n+          nil. { ret none[def]; }\n+          cons(hd, tl) {\n+            let fnd = in_scope(e, sp, name, hd, ns);\n+            if !is_none(fnd) {\n+                let df = option::get(fnd);\n+                if left_fn && def_is_local(df) ||\n+                       left_fn_level2 && def_is_obj_field(df) ||\n+                       scope_is_fn(hd) && left_fn && def_is_ty_arg(df) {\n+                    let msg =\n+                        alt ns {\n+                          ns_type. {\n+                            \"Attempt to use a type \\\n                                 argument out of scope\"\n-                            }\n-                            case (_) { \"attempted dynamic \\\n-                                       environment-capture\" }\n+                          }\n+                          _ {\n+                            \"attempted dynamic \\\n+                                       environment-capture\"\n+                          }\n                         };\n-                        e.sess.span_fatal(sp, msg);\n-                    }\n-                    ret fnd;\n+                    e.sess.span_fatal(sp, msg);\n                 }\n-                if (left_fn) { left_fn_level2 = true; }\n-                if ((ns == ns_value || ns == ns_type) && !left_fn) {\n-                    left_fn = scope_is_fn(hd); }\n-                sc = *tl;\n+                ret fnd;\n             }\n+            if left_fn { left_fn_level2 = true; }\n+            if (ns == ns_value || ns == ns_type) && !left_fn {\n+                left_fn = scope_is_fn(hd);\n+            }\n+            sc = *tl;\n+          }\n         }\n     }\n     e.sess.bug(\"reached unreachable code in lookup_in_scope\"); // sigh\n \n }\n \n-fn lookup_in_ty_params(&ident name, &ast::ty_param[] ty_params) ->\n+fn lookup_in_ty_params(name: &ident, ty_params: &ast::ty_param[]) ->\n    option::t[def] {\n-    auto i = 0u;\n-    for (ast::ty_param tp in ty_params) {\n-        if (str::eq(tp, name)) { ret some(ast::def_ty_arg(i)); }\n+    let i = 0u;\n+    for tp: ast::ty_param  in ty_params {\n+        if str::eq(tp, name) { ret some(ast::def_ty_arg(i)); }\n         i += 1u;\n     }\n     ret none[def];\n }\n \n-fn lookup_in_pat(&ident name, &ast::pat pat) -> option::t[def] {\n-    alt (pat.node) {\n-        case (ast::pat_bind(?p_name)) {\n-            if (str::eq(p_name, name)) {\n-                ret some(ast::def_binding(local_def(pat.id)));\n-            }\n+fn lookup_in_pat(name: &ident, pat: &ast::pat) -> option::t[def] {\n+    alt pat.node {\n+      ast::pat_bind(p_name) {\n+        if str::eq(p_name, name) {\n+            ret some(ast::def_binding(local_def(pat.id)));\n         }\n-        case (ast::pat_wild) { }\n-        case (ast::pat_lit(_)) { }\n-        case (ast::pat_tag(_, ?pats)) {\n-            for (@ast::pat p in pats) {\n-                auto found = lookup_in_pat(name, *p);\n-                if (!is_none(found)) { ret found; }\n-            }\n+      }\n+      ast::pat_wild. { }\n+      ast::pat_lit(_) { }\n+      ast::pat_tag(_, pats) {\n+        for p: @ast::pat  in pats {\n+            let found = lookup_in_pat(name, *p);\n+            if !is_none(found) { ret found; }\n         }\n-        case (ast::pat_rec(?fields, _)) {\n-            for (ast::field_pat f in fields) {\n-                auto found = lookup_in_pat(name, *f.pat);\n-                if (!is_none(found)) { ret found; }\n-            }\n+      }\n+      ast::pat_rec(fields, _) {\n+        for f: ast::field_pat  in fields {\n+            let found = lookup_in_pat(name, *f.pat);\n+            if !is_none(found) { ret found; }\n         }\n-        case (ast::pat_box(?inner)) { ret lookup_in_pat(name, *inner); }\n+      }\n+      ast::pat_box(inner) { ret lookup_in_pat(name, *inner); }\n     }\n     ret none[def];\n }\n \n-fn lookup_in_fn(&ident name, &ast::fn_decl decl,\n-                &ast::ty_param[] ty_params,\n-                namespace ns) -> option::t[def] {\n-    alt (ns) {\n-        case (ns_value) {\n-            for (ast::arg a in decl.inputs) {\n-                if (str::eq(a.ident, name)) {\n-                    ret some(ast::def_arg(local_def(a.id)));\n-                }\n+fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n+                ty_params: &ast::ty_param[], ns: namespace) ->\n+   option::t[def] {\n+    alt ns {\n+      ns_value. {\n+        for a: ast::arg  in decl.inputs {\n+            if str::eq(a.ident, name) {\n+                ret some(ast::def_arg(local_def(a.id)));\n             }\n-            ret none[def];\n         }\n-        case (ns_type) { ret lookup_in_ty_params(name, ty_params); }\n-        case (_) { ret none[def]; }\n+        ret none[def];\n+      }\n+      ns_type. { ret lookup_in_ty_params(name, ty_params); }\n+      _ { ret none[def]; }\n     }\n }\n \n-fn lookup_in_obj(&ident name, &ast::_obj ob, &ast::ty_param[] ty_params,\n-                 namespace ns) -> option::t[def] {\n-    alt (ns) {\n-        case (ns_value) {\n-            for (ast::obj_field f in ob.fields) {\n-                if (str::eq(f.ident, name)) {\n-                    ret some(ast::def_obj_field(local_def(f.id)));\n-                }\n+fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &ast::ty_param[],\n+                 ns: namespace) -> option::t[def] {\n+    alt ns {\n+      ns_value. {\n+        for f: ast::obj_field  in ob.fields {\n+            if str::eq(f.ident, name) {\n+                ret some(ast::def_obj_field(local_def(f.id)));\n             }\n-            ret none[def];\n         }\n-        case (ns_type) { ret lookup_in_ty_params(name, ty_params); }\n-        case (_) { ret none[def]; }\n+        ret none[def];\n+      }\n+      ns_type. { ret lookup_in_ty_params(name, ty_params); }\n+      _ { ret none[def]; }\n     }\n }\n \n-fn lookup_in_block(&ident name, &ast::blk_ b, namespace ns) ->\n+fn lookup_in_block(name: &ident, b: &ast::blk_, ns: namespace) ->\n    option::t[def] {\n-    for (@ast::stmt st in b.stmts) {\n-        alt (st.node) {\n-            case (ast::stmt_decl(?d, _)) {\n-                alt (d.node) {\n-                    ast::decl_local(?locs) {\n-                      for (@ast::local loc in locs) {\n-                          if ns == ns_value && str::eq(name, loc.node.ident) {\n-                              ret some(ast::def_local\n-                                       (local_def(loc.node.id)));\n-                          }\n-                      }\n+    for st: @ast::stmt  in b.stmts {\n+        alt st.node {\n+          ast::stmt_decl(d, _) {\n+            alt d.node {\n+              ast::decl_local(locs) {\n+                for loc: @ast::local  in locs {\n+                    if ns == ns_value && str::eq(name, loc.node.ident) {\n+                        ret some(ast::def_local(local_def(loc.node.id)));\n                     }\n-                    case (ast::decl_item(?it)) {\n-                        alt (it.node) {\n-                            case (ast::item_tag(?variants, _)) {\n-                                if (ns == ns_type) {\n-                                    if (str::eq(it.ident, name)) {\n-                                        ret some(ast::def_ty\n-                                                 (local_def(it.id)));\n-                                    }\n-                                } else if (ns == ns_value) {\n-                                    for (ast::variant v in variants) {\n-                                        if (str::eq(v.node.name, name)) {\n-                                            auto i = v.node.id;\n-                                            ret some(ast::def_variant\n-                                                     (local_def(it.id),\n-                                                      local_def(i)));\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            case (_) {\n-                                if (str::eq(it.ident, name)) {\n-                                    auto found = found_def_item(it, ns);\n-                                    if (!is_none(found)) {\n-                                        ret found;\n-                                    }\n-                                }\n+                }\n+              }\n+              ast::decl_item(it) {\n+                alt it.node {\n+                  ast::item_tag(variants, _) {\n+                    if ns == ns_type {\n+                        if str::eq(it.ident, name) {\n+                            ret some(ast::def_ty(local_def(it.id)));\n+                        }\n+                    } else if (ns == ns_value) {\n+                        for v: ast::variant  in variants {\n+                            if str::eq(v.node.name, name) {\n+                                let i = v.node.id;\n+                                ret some(ast::def_variant(local_def(it.id),\n+                                                          local_def(i)));\n                             }\n                         }\n                     }\n+                  }\n+                  _ {\n+                    if str::eq(it.ident, name) {\n+                        let found = found_def_item(it, ns);\n+                        if !is_none(found) { ret found; }\n+                    }\n+                  }\n                 }\n+              }\n             }\n-            case (_) { }\n+          }\n+          _ { }\n         }\n     }\n     ret none[def];\n }\n \n-fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n-    alt (i.node) {\n-        case (ast::item_const(_, _)) {\n-            if (ns == ns_value) {\n-                ret some(ast::def_const(local_def(i.id)));\n-            }\n-        }\n-        case (ast::item_fn(?f, _)) {\n-            if (ns == ns_value) {\n-                ret some(ast::def_fn(local_def(i.id), f.decl.purity));\n-            }\n-        }\n-        case (ast::item_mod(_)) {\n-            if (ns == ns_module) {\n-                ret some(ast::def_mod(local_def(i.id)));\n-            }\n-        }\n-        case (ast::item_native_mod(_)) {\n-            if (ns == ns_module) {\n-                ret some(ast::def_native_mod(local_def(i.id)));\n-            }\n-        }\n-        case (ast::item_ty(_, _)) {\n-            if (ns == ns_type) {\n-                ret some(ast::def_ty(local_def(i.id)));\n-            }\n-        }\n-        case (ast::item_res(_, _, _, ?ctor_id)) {\n-            alt (ns) {\n-                case (ns_value) { ret some(ast::def_fn(local_def(ctor_id),\n-                                                       ast::impure_fn)); }\n-                case (ns_type) { ret some(ast::def_ty(local_def(i.id))); }\n-                case (_) { }\n-            }\n+fn found_def_item(i: &@ast::item, ns: namespace) -> option::t[def] {\n+    alt i.node {\n+      ast::item_const(_, _) {\n+        if ns == ns_value { ret some(ast::def_const(local_def(i.id))); }\n+      }\n+      ast::item_fn(f, _) {\n+        if ns == ns_value {\n+            ret some(ast::def_fn(local_def(i.id), f.decl.purity));\n         }\n-        case (ast::item_tag(_, _)) {\n-            if (ns == ns_type) {\n-                ret some(ast::def_ty(local_def(i.id)));\n-            }\n+      }\n+      ast::item_mod(_) {\n+        if ns == ns_module { ret some(ast::def_mod(local_def(i.id))); }\n+      }\n+      ast::item_native_mod(_) {\n+        if ns == ns_module { ret some(ast::def_native_mod(local_def(i.id))); }\n+      }\n+      ast::item_ty(_, _) {\n+        if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n+      }\n+      ast::item_res(_, _, _, ctor_id) {\n+        alt ns {\n+          ns_value. {\n+            ret some(ast::def_fn(local_def(ctor_id), ast::impure_fn));\n+          }\n+          ns_type. { ret some(ast::def_ty(local_def(i.id))); }\n+          _ { }\n         }\n-        case (ast::item_obj(_, _, ?ctor_id)) {\n-            alt (ns) {\n-                case (ns_value) { ret some(ast::def_fn(local_def(ctor_id),\n-                                                       ast::impure_fn)); }\n-                case (ns_type) { ret some(ast::def_ty(local_def(i.id))); }\n-                case (_) { }\n-            }\n+      }\n+      ast::item_tag(_, _) {\n+        if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n+      }\n+      ast::item_obj(_, _, ctor_id) {\n+        alt ns {\n+          ns_value. {\n+            ret some(ast::def_fn(local_def(ctor_id), ast::impure_fn));\n+          }\n+          ns_type. { ret some(ast::def_ty(local_def(i.id))); }\n+          _ { }\n         }\n-        case (_) { }\n+      }\n+      _ { }\n     }\n     ret none[def];\n }\n \n-fn lookup_in_mod_strict(&env e, &scopes sc, def m, &span sp, &ident name,\n-                        namespace ns, dir dr) -> option::t[def] {\n-    alt (lookup_in_mod(e, m, sp, name, ns, dr)) {\n-        case (none) {\n-            unresolved_err(e, sc, sp, name, ns_name(ns));\n-            ret none;\n-        }\n-        case (some(?d)) { ret some(d); }\n+fn lookup_in_mod_strict(e: &env, sc: &scopes, m: def, sp: &span, name: &ident,\n+                        ns: namespace, dr: dir) -> option::t[def] {\n+    alt lookup_in_mod(e, m, sp, name, ns, dr) {\n+      none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n+      some(d) { ret some(d); }\n     }\n }\n \n-fn lookup_in_mod(&env e, &def m, &span sp, &ident name, namespace ns,\n-                 dir dr) -> option::t[def] {\n-    auto defid = ast::def_id_of_def(m);\n-    if (defid.crate != ast::local_crate) {\n+fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n+                 dr: dir) -> option::t[def] {\n+    let defid = ast::def_id_of_def(m);\n+    if defid.crate != ast::local_crate {\n         // examining a module in an external crate\n \n-        auto cached = e.ext_cache.find(rec(did=defid, ident=name, ns=ns));\n-        if (!is_none(cached)) { ret cached; }\n-        auto path = ~[name];\n-        if (defid.node != -1) { path = e.ext_map.get(defid) + path; }\n-        auto fnd = lookup_external(e, defid.crate, path, ns);\n-        if (!is_none(fnd)) {\n-            e.ext_cache.insert(rec(did=defid, ident=name, ns=ns),\n+        let cached = e.ext_cache.find({did: defid, ident: name, ns: ns});\n+        if !is_none(cached) { ret cached; }\n+        let path = ~[name];\n+        if defid.node != -1 { path = e.ext_map.get(defid) + path; }\n+        let fnd = lookup_external(e, defid.crate, path, ns);\n+        if !is_none(fnd) {\n+            e.ext_cache.insert({did: defid, ident: name, ns: ns},\n                                option::get(fnd));\n         }\n         ret fnd;\n     }\n-    alt (m) {\n-        case (ast::def_mod(?defid)) {\n-            ret lookup_in_local_mod(e, defid.node, sp, name, ns, dr);\n-        }\n-        case (ast::def_native_mod(?defid)) {\n-            ret lookup_in_local_native_mod(e, defid.node, sp, name, ns);\n-        }\n+    alt m {\n+      ast::def_mod(defid) {\n+        ret lookup_in_local_mod(e, defid.node, sp, name, ns, dr);\n+      }\n+      ast::def_native_mod(defid) {\n+        ret lookup_in_local_native_mod(e, defid.node, sp, name, ns);\n+      }\n     }\n }\n \n-fn found_view_item(&env e, @ast::view_item vi, namespace ns) ->\n+fn found_view_item(e: &env, vi: @ast::view_item, ns: namespace) ->\n    option::t[def] {\n-    alt (vi.node) {\n-        case (ast::view_item_use(_, _, ?id)) {\n-            auto cnum = cstore::get_use_stmt_cnum(e.cstore, id);\n-            ret some(ast::def_mod(rec(crate=cnum, node=-1)));\n-        }\n-        case (ast::view_item_import(_, _, ?id)) {\n-            ret lookup_import(e, local_def(id), ns);\n-        }\n-        case (ast::view_item_import_glob(_, ?defid)) {\n-            ret none[def]; //will be handled in the fallback glob pass\n+    alt vi.node {\n+      ast::view_item_use(_, _, id) {\n+        let cnum = cstore::get_use_stmt_cnum(e.cstore, id);\n+        ret some(ast::def_mod({crate: cnum, node: -1}));\n+      }\n+      ast::view_item_import(_, _, id) {\n+        ret lookup_import(e, local_def(id), ns);\n+      }\n+      ast::view_item_import_glob(_, defid) {\n+        ret none[def]; //will be handled in the fallback glob pass\n \n-        }\n+      }\n     }\n }\n \n-fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n-    alt (e.imports.get(defid.node)) {\n-        case (todo(?item, ?sc)) {\n-            resolve_import(e, item, sc);\n-            ret lookup_import(e, defid, ns);\n-        }\n-        case (resolving(?sp)) {\n-            e.sess.span_err(sp, \"cyclic import\");\n-            ret none;\n-        }\n-        case (resolved(?val, ?typ, ?md)) {\n-            ret alt (ns) {\n-                    case (ns_value) { val }\n-                    case (ns_type) { typ }\n-                    case (ns_module) { md }\n-                };\n-        }\n+fn lookup_import(e: &env, defid: def_id, ns: namespace) -> option::t[def] {\n+    alt e.imports.get(defid.node) {\n+      todo(item, sc) {\n+        resolve_import(e, item, sc);\n+        ret lookup_import(e, defid, ns);\n+      }\n+      resolving(sp) { e.sess.span_err(sp, \"cyclic import\"); ret none; }\n+      resolved(val, typ, md) {\n+        ret alt ns { ns_value. { val } ns_type. { typ } ns_module. { md } };\n+      }\n     }\n }\n \n-fn lookup_in_local_native_mod(&env e, node_id node_id, &span sp, &ident id,\n-                              namespace ns) -> option::t[def] {\n+fn lookup_in_local_native_mod(e: &env, node_id: node_id, sp: &span,\n+                              id: &ident, ns: namespace) -> option::t[def] {\n     ret lookup_in_local_mod(e, node_id, sp, id, ns, inside);\n }\n \n-fn lookup_in_local_mod(&env e, node_id node_id, &span sp, &ident id,\n-                       namespace ns, dir dr) -> option::t[def] {\n-    auto info = e.mod_map.get(node_id);\n-    if (dr == outside && !ast::is_exported(id, option::get(info.m))) {\n+fn lookup_in_local_mod(e: &env, node_id: node_id, sp: &span, id: &ident,\n+                       ns: namespace, dr: dir) -> option::t[def] {\n+    let info = e.mod_map.get(node_id);\n+    if dr == outside && !ast::is_exported(id, option::get(info.m)) {\n         // if we're in a native mod, then dr==inside, so info.m is some _mod\n \n         ret none[def]; // name is not visible\n \n     }\n-    alt (info.index.find(id)) {\n-        case (none) { }\n-        case (some(?lst_)) {\n-            auto lst = lst_;\n-            while (true) {\n-                alt (lst) {\n-                    case (nil) { break; }\n-                    case (cons(?hd, ?tl)) {\n-                        auto found = lookup_in_mie(e, hd, ns);\n-                        if (!is_none(found)) { ret found; }\n-                        lst = *tl;\n-                    }\n-                }\n+    alt info.index.find(id) {\n+      none. { }\n+      some(lst_) {\n+        let lst = lst_;\n+        while true {\n+            alt lst {\n+              nil. { break; }\n+              cons(hd, tl) {\n+                let found = lookup_in_mie(e, hd, ns);\n+                if !is_none(found) { ret found; }\n+                lst = *tl;\n+              }\n             }\n         }\n+      }\n     }\n \n     // not local or explicitly imported; try globs:\n     ret lookup_glob_in_mod(e, info, sp, id, ns, outside);\n }\n \n-fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, &ident id,\n-                      namespace wanted_ns, dir dr) -> option::t[def] {\n-    fn per_ns(&env e, @indexed_mod info, &span sp, &ident id, namespace ns,\n-              dir dr) -> option::t[def] {\n-\n-        fn lookup_in_mod_(&env e, &glob_imp_def def, &span sp,\n-                          &ident name, namespace ns,\n-                          dir dr) -> option::t[glob_imp_def] {\n-            alt (lookup_in_mod(e, def.def, sp, name, ns, dr)) {\n-                case (option::some(?d)) {\n-                    option::some(rec(def=d, item=def.item))\n-                }\n-                case (option::none) {\n-                    option::none\n-                }\n+fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n+                      wanted_ns: namespace, dr: dir) -> option::t[def] {\n+    fn per_ns(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n+              ns: namespace, dr: dir) -> option::t[def] {\n+\n+        fn lookup_in_mod_(e: &env, def: &glob_imp_def, sp: &span,\n+                          name: &ident, ns: namespace, dr: dir) ->\n+           option::t[glob_imp_def] {\n+            alt lookup_in_mod(e, def.def, sp, name, ns, dr) {\n+              option::some(d) { option::some({def: d, item: def.item}) }\n+              option::none. { option::none }\n             }\n         }\n \n-        auto matches =\n+        let matches =\n             ivec::filter_map(bind lookup_in_mod_(e, _, sp, id, ns, dr),\n                              { info.glob_imports });\n-        if (ivec::len(matches) == 0u) {\n+        if ivec::len(matches) == 0u {\n             ret none;\n         } else if (ivec::len(matches) == 1u) {\n             ret some(matches.(0).def);\n         } else {\n-            for (glob_imp_def match in matches) {\n-                auto sp = match.item.span;\n+            for match: glob_imp_def  in matches {\n+                let sp = match.item.span;\n                 e.sess.span_note(sp, #fmt(\"'%s' is imported here\", id));\n             }\n             e.sess.span_fatal(sp,\n-                            \"'\" + id + \"' is glob-imported from\" +\n-                                \" multiple different modules.\");\n+                              \"'\" + id + \"' is glob-imported from\" +\n+                                  \" multiple different modules.\");\n         }\n     }\n     // since we don't know what names we have in advance,\n     // absence takes the place of todo()\n \n-    if (!info.glob_imported_names.contains_key(id)) {\n+    if !info.glob_imported_names.contains_key(id) {\n         info.glob_imported_names.insert(id, resolving(sp));\n-        auto val = per_ns(e, info, sp, id, ns_value, dr);\n-        auto typ = per_ns(e, info, sp, id, ns_type, dr);\n-        auto md = per_ns(e, info, sp, id, ns_module, dr);\n+        let val = per_ns(e, info, sp, id, ns_value, dr);\n+        let typ = per_ns(e, info, sp, id, ns_type, dr);\n+        let md = per_ns(e, info, sp, id, ns_module, dr);\n         info.glob_imported_names.insert(id, resolved(val, typ, md));\n     }\n-    alt (info.glob_imported_names.get(id)) {\n-        case (todo(_, _)) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n-        case (resolving(?sp)) {\n-            ret none[def]; //circularity is okay in import globs\n+    alt info.glob_imported_names.get(id) {\n+      todo(_, _) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n+      resolving(sp) {\n+        ret none[def]; //circularity is okay in import globs\n \n-        }\n-        case (resolved(?val, ?typ, ?md)) {\n-            ret alt (wanted_ns) {\n-                    case (ns_value) { val }\n-                    case (ns_type) { typ }\n-                    case (ns_module) { md }\n-                };\n-        }\n+      }\n+      resolved(val, typ, md) {\n+        ret alt wanted_ns {\n+              ns_value. { val }\n+              ns_type. { typ }\n+              ns_module. { md }\n+            };\n+      }\n     }\n }\n \n-fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns) ->\n+fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n    option::t[def] {\n-    alt (mie) {\n-        case (mie_view_item(?view_item)) {\n-            ret found_view_item(e, view_item, ns);\n+    alt mie {\n+      mie_view_item(view_item) { ret found_view_item(e, view_item, ns); }\n+      mie_item(item) { ret found_def_item(item, ns); }\n+      mie_tag_variant(item, variant_idx) {\n+        alt item.node {\n+          ast::item_tag(variants, _) {\n+            if ns == ns_value {\n+                let vid = variants.(variant_idx).node.id;\n+                ret some(ast::def_variant(local_def(item.id),\n+                                          local_def(vid)));\n+            } else { ret none[def]; }\n+          }\n         }\n-        case (mie_item(?item)) { ret found_def_item(item, ns); }\n-        case (mie_tag_variant(?item, ?variant_idx)) {\n-            alt (item.node) {\n-                case (ast::item_tag(?variants, _)) {\n-                    if (ns == ns_value) {\n-                        auto vid = variants.(variant_idx).node.id;\n-                        ret some(ast::def_variant(local_def(item.id),\n-                                                  local_def(vid)));\n-                    } else { ret none[def]; }\n-                }\n+      }\n+      mie_native_item(native_item) {\n+        alt native_item.node {\n+          ast::native_item_ty. {\n+            if ns == ns_type {\n+                ret some(ast::def_native_ty(local_def(native_item.id)));\n             }\n-        }\n-        case (mie_native_item(?native_item)) {\n-            alt (native_item.node) {\n-                case (ast::native_item_ty) {\n-                    if (ns == ns_type) {\n-                        ret some(ast::def_native_ty\n-                                 (local_def(native_item.id)));\n-                    }\n-                }\n-                case (ast::native_item_fn(_, _, _)) {\n-                    if (ns == ns_value) {\n-                        ret some(ast::def_native_fn\n-                                 (local_def(native_item.id)));\n-                    }\n-                }\n+          }\n+          ast::native_item_fn(_, _, _) {\n+            if ns == ns_value {\n+                ret some(ast::def_native_fn(local_def(native_item.id)));\n             }\n+          }\n         }\n-        case (_) { }\n+      }\n+      _ { }\n     }\n     ret none[def];\n }\n \n \n // Module indexing\n-fn add_to_index(&hashmap[ident, list[mod_index_entry]] index, &ident id,\n-                &mod_index_entry ent) {\n-    alt (index.find(id)) {\n-        case (none) { index.insert(id, cons(ent, @nil[mod_index_entry])); }\n-        case (some(?prev)) { index.insert(id, cons(ent, @prev)); }\n+fn add_to_index(index: &hashmap[ident, list[mod_index_entry]], id: &ident,\n+                ent: &mod_index_entry) {\n+    alt index.find(id) {\n+      none. { index.insert(id, cons(ent, @nil[mod_index_entry])); }\n+      some(prev) { index.insert(id, cons(ent, @prev)); }\n     }\n }\n \n-fn index_mod(&ast::_mod md) -> mod_index {\n-    auto index = new_str_hash[list[mod_index_entry]]();\n-    for (@ast::view_item it in md.view_items) {\n-        alt (it.node) {\n-          ast::view_item_import(?ident, _, _) |\n-          ast::view_item_use(?ident, _, _) {\n+fn index_mod(md: &ast::_mod) -> mod_index {\n+    let index = new_str_hash[list[mod_index_entry]]();\n+    for it: @ast::view_item  in md.view_items {\n+        alt it.node {\n+          ast::view_item_import(ident, _, _) | ast::view_item_use(ident, _, _)\n+          {\n             add_to_index(index, ident, mie_view_item(it));\n           }\n+\n           //globbed imports have to be resolved lazily.\n-          ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) {}\n+          ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) {\n+          }\n         }\n     }\n-    for (@ast::item it in md.items) {\n-        alt (it.node) {\n-            ast::item_const(_, _) | ast::item_fn(_, _) | ast::item_mod(_) |\n-            ast::item_native_mod(_) | ast::item_ty(_, _) |\n-            ast::item_res(_, _, _, _) | ast::item_obj(_, _, _) {\n-                add_to_index(index, it.ident, mie_item(it));\n-            }\n-            ast::item_tag(?variants, _) {\n-                add_to_index(index, it.ident, mie_item(it));\n-                let uint variant_idx = 0u;\n-                for (ast::variant v in variants) {\n-                    add_to_index(index, v.node.name,\n-                                 mie_tag_variant(it, variant_idx));\n-                    variant_idx += 1u;\n-                }\n+    for it: @ast::item  in md.items {\n+        alt it.node {\n+          ast::item_const(_, _) | ast::item_fn(_, _) | ast::item_mod(_) |\n+          ast::item_native_mod(_) | ast::item_ty(_, _) |\n+          ast::item_res(_, _, _, _) | ast::item_obj(_, _, _) {\n+            add_to_index(index, it.ident, mie_item(it));\n+          }\n+          ast::item_tag(variants, _) {\n+            add_to_index(index, it.ident, mie_item(it));\n+            let variant_idx: uint = 0u;\n+            for v: ast::variant  in variants {\n+                add_to_index(index, v.node.name,\n+                             mie_tag_variant(it, variant_idx));\n+                variant_idx += 1u;\n             }\n+          }\n         }\n     }\n     ret index;\n }\n \n-fn index_nmod(&ast::native_mod md) -> mod_index {\n-    auto index = new_str_hash[list[mod_index_entry]]();\n-    for (@ast::view_item it in md.view_items) {\n-        alt (it.node) {\n-          ast::view_item_use(?ident, _, _) |\n-          ast::view_item_import(?ident, _, _) {\n+fn index_nmod(md: &ast::native_mod) -> mod_index {\n+    let index = new_str_hash[list[mod_index_entry]]();\n+    for it: @ast::view_item  in md.view_items {\n+        alt it.node {\n+          ast::view_item_use(ident, _, _) | ast::view_item_import(ident, _, _)\n+          {\n             add_to_index(index, ident, mie_view_item(it));\n           }\n-          ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) {}\n+          ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) { }\n         }\n     }\n-    for (@ast::native_item it in md.items) {\n+    for it: @ast::native_item  in md.items {\n         add_to_index(index, it.ident, mie_native_item(it));\n     }\n     ret index;\n }\n \n \n // External lookups\n-fn ns_for_def(def d) -> namespace {\n-    ret alt (d) {\n-            case (ast::def_fn(?id, _)) { ns_value }\n-            case (ast::def_obj_field(?id)) { ns_value }\n-            case (ast::def_mod(?id)) { ns_module }\n-            case (ast::def_native_mod(?id)) { ns_module }\n-            case (ast::def_const(?id)) { ns_value }\n-            case (ast::def_arg(?id)) { ns_value }\n-            case (ast::def_local(?id)) { ns_value }\n-            case (ast::def_variant(_, ?id)) { ns_value }\n-            case (ast::def_ty(?id)) { ns_type }\n-            case (ast::def_binding(?id)) { ns_type }\n-            case (ast::def_use(?id)) { ns_module }\n-            case (ast::def_native_ty(?id)) { ns_type }\n-            case (ast::def_native_fn(?id)) { ns_value }\n+fn ns_for_def(d: def) -> namespace {\n+    ret alt d {\n+          ast::def_fn(id, _) { ns_value }\n+          ast::def_obj_field(id) { ns_value }\n+          ast::def_mod(id) { ns_module }\n+          ast::def_native_mod(id) { ns_module }\n+          ast::def_const(id) { ns_value }\n+          ast::def_arg(id) { ns_value }\n+          ast::def_local(id) { ns_value }\n+          ast::def_variant(_, id) { ns_value }\n+          ast::def_ty(id) { ns_type }\n+          ast::def_binding(id) { ns_type }\n+          ast::def_use(id) { ns_module }\n+          ast::def_native_ty(id) { ns_type }\n+          ast::def_native_fn(id) { ns_value }\n         };\n }\n \n-fn lookup_external(&env e, int cnum, &ident[] ids, namespace ns) ->\n+fn lookup_external(e: &env, cnum: int, ids: &ident[], ns: namespace) ->\n    option::t[def] {\n-    for (def d in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids)) {\n+    for d: def  in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids) {\n         e.ext_map.insert(ast::def_id_of_def(d), ids);\n-        if (ns == ns_for_def(d)) { ret some(d); }\n+        if ns == ns_for_def(d) { ret some(d); }\n     }\n     ret none[def];\n }\n \n \n // Collision detection\n-fn check_for_collisions(&@env e, &ast::crate c) {\n+fn check_for_collisions(e: &@env, c: &ast::crate) {\n     // Module indices make checking those relatively simple -- just check each\n     // name for multiple entities in the same namespace.\n \n-    for each (@rec(ast::node_id key, @indexed_mod val) m\n-              in e.mod_map.items()) {\n-        for each (@rec(ident key, list[mod_index_entry] val) name\n-                  in m.val.index.items()) {\n+    for each m: @{key: ast::node_id, val: @indexed_mod}  in e.mod_map.items()\n+             {\n+        for each name: @{key: ident, val: list[mod_index_entry]}  in\n+                 m.val.index.items() {\n             check_mod_name(*e, name.key, name.val);\n         }\n     }\n     // Other scopes have to be checked the hard way.\n \n-    auto v =\n-        @rec(visit_item=bind check_item(e, _, _, _),\n-             visit_block=bind check_block(e, _, _, _),\n-             visit_arm=bind check_arm(e, _, _, _),\n-             visit_expr=bind check_expr(e, _, _, _),\n-             visit_ty=bind check_ty(e, _, _, _)\n-             with *visit::default_visitor());\n+    let v =\n+        @{visit_item: bind check_item(e, _, _, _),\n+          visit_block: bind check_block(e, _, _, _),\n+          visit_arm: bind check_arm(e, _, _, _),\n+          visit_expr: bind check_expr(e, _, _, _),\n+          visit_ty: bind check_ty(e, _, _, _) with *visit::default_visitor()};\n     visit::visit_crate(c, (), visit::mk_vt(v));\n }\n \n-fn check_mod_name(&env e, &ident name, list[mod_index_entry] entries) {\n-    auto saw_mod = false;\n-    auto saw_type = false;\n-    auto saw_value = false;\n-    fn dup(&env e, &span sp, &str word, &ident name) {\n+fn check_mod_name(e: &env, name: &ident, entries: list[mod_index_entry]) {\n+    let saw_mod = false;\n+    let saw_type = false;\n+    let saw_value = false;\n+    fn dup(e: &env, sp: &span, word: &str, name: &ident) {\n         e.sess.span_fatal(sp, \"duplicate definition of \" + word + name);\n     }\n-    while (true) {\n-        alt (entries) {\n-            case (cons(?entry, ?rest)) {\n-                if (!is_none(lookup_in_mie(e, entry, ns_value))) {\n-                    if (saw_value) {\n-                        dup(e, mie_span(entry), \"\", name);\n-                    } else { saw_value = true; }\n-                }\n-                if (!is_none(lookup_in_mie(e, entry, ns_type))) {\n-                    if (saw_type) {\n-                        dup(e, mie_span(entry), \"type \", name);\n-                    } else { saw_type = true; }\n-                }\n-                if (!is_none(lookup_in_mie(e, entry, ns_module))) {\n-                    if (saw_mod) {\n-                        dup(e, mie_span(entry), \"module \", name);\n-                    } else { saw_mod = true; }\n-                }\n-                entries = *rest;\n+    while true {\n+        alt entries {\n+          cons(entry, rest) {\n+            if !is_none(lookup_in_mie(e, entry, ns_value)) {\n+                if saw_value {\n+                    dup(e, mie_span(entry), \"\", name);\n+                } else { saw_value = true; }\n             }\n-            case (nil) { break; }\n+            if !is_none(lookup_in_mie(e, entry, ns_type)) {\n+                if saw_type {\n+                    dup(e, mie_span(entry), \"type \", name);\n+                } else { saw_type = true; }\n+            }\n+            if !is_none(lookup_in_mie(e, entry, ns_module)) {\n+                if saw_mod {\n+                    dup(e, mie_span(entry), \"module \", name);\n+                } else { saw_mod = true; }\n+            }\n+            entries = *rest;\n+          }\n+          nil. { break; }\n         }\n     }\n }\n \n-fn mie_span(&mod_index_entry mie) -> span {\n-    ret alt (mie) {\n-        mie_view_item(?item) { item.span }\n-        mie_item(?item) { item.span }\n-        mie_tag_variant(?item, _) { item.span }\n-        mie_native_item(?item) { item.span }\n-    };\n+fn mie_span(mie: &mod_index_entry) -> span {\n+    ret alt mie {\n+          mie_view_item(item) { item.span }\n+          mie_item(item) { item.span }\n+          mie_tag_variant(item, _) { item.span }\n+          mie_native_item(item) { item.span }\n+        };\n }\n \n-fn check_item(&@env e, &@ast::item i, &() x, &vt[()] v) {\n+fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt[()]) {\n     visit::visit_item(i, x, v);\n-    alt (i.node) {\n-        case (ast::item_fn(?f, ?ty_params)) {\n-            check_fn(*e, i.span, f);\n-            ensure_unique(*e, i.span, ty_params, ident_id,\n-                               \"type parameter\");\n-        }\n-        case (ast::item_obj(?ob, ?ty_params, _)) {\n-            fn field_name(&ast::obj_field field) -> ident { ret field.ident; }\n-            ensure_unique(*e, i.span, ob.fields, field_name,\n-                               \"object field\");\n-            for (@ast::method m in ob.methods) {\n-                check_fn(*e, m.span, m.node.meth);\n-            }\n-            ensure_unique(*e, i.span, ty_params, ident_id,\n-                               \"type parameter\");\n-        }\n-        case (ast::item_tag(_, ?ty_params)) {\n-            ensure_unique(*e, i.span, ty_params, ident_id,\n-                               \"type parameter\");\n+    alt i.node {\n+      ast::item_fn(f, ty_params) {\n+        check_fn(*e, i.span, f);\n+        ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n+      }\n+      ast::item_obj(ob, ty_params, _) {\n+        fn field_name(field: &ast::obj_field) -> ident { ret field.ident; }\n+        ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n+        for m: @ast::method  in ob.methods {\n+            check_fn(*e, m.span, m.node.meth);\n         }\n-        case (_) { }\n+        ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n+      }\n+      ast::item_tag(_, ty_params) {\n+        ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n+      }\n+      _ { }\n     }\n }\n \n-fn check_arm(&@env e, &ast::arm a, &() x, &vt[()] v) {\n+fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt[()]) {\n     visit::visit_arm(a, x, v);\n-    fn walk_pat(checker ch, &@ast::pat p) {\n-        alt (p.node) {\n-            case (ast::pat_bind(?name)) { add_name(ch, p.span, name); }\n-            case (ast::pat_tag(_, ?children)) {\n-                for (@ast::pat child in children) { walk_pat(ch, child); }\n-            }\n-            case (ast::pat_rec(?fields, _)) {\n-                for (ast::field_pat f in fields) { walk_pat(ch, f.pat); }\n-            }\n-            case (ast::pat_box(?inner)) { walk_pat(ch, inner); }\n-            case (_) { }\n+    fn walk_pat(ch: checker, p: &@ast::pat) {\n+        alt p.node {\n+          ast::pat_bind(name) { add_name(ch, p.span, name); }\n+          ast::pat_tag(_, children) {\n+            for child: @ast::pat  in children { walk_pat(ch, child); }\n+          }\n+          ast::pat_rec(fields, _) {\n+            for f: ast::field_pat  in fields { walk_pat(ch, f.pat); }\n+          }\n+          ast::pat_box(inner) { walk_pat(ch, inner); }\n+          _ { }\n         }\n     }\n-    auto ch0 = checker(*e, \"binding\");\n+    let ch0 = checker(*e, \"binding\");\n     walk_pat(ch0, a.pats.(0));\n-    auto seen0 = ch0.seen;\n-    auto i = ivec::len(a.pats);\n-    while (i > 1u) {\n+    let seen0 = ch0.seen;\n+    let i = ivec::len(a.pats);\n+    while i > 1u {\n         i -= 1u;\n-        auto ch = checker(*e, \"binding\");\n+        let ch = checker(*e, \"binding\");\n         walk_pat(ch, a.pats.(i));\n+\n         // Ensure the bindings introduced in this pattern are the same as in\n         // the first pattern.\n-        if (ivec::len(ch.seen) != ivec::len(seen0)) {\n+        if ivec::len(ch.seen) != ivec::len(seen0) {\n             e.sess.span_err(a.pats.(i).span,\n                             \"inconsistent number of bindings\");\n         } else {\n-            for (ident name in ch.seen) {\n-                if (is_none(ivec::find(bind str::eq(name, _), seen0))) {\n+            for name: ident  in ch.seen {\n+                if is_none(ivec::find(bind str::eq(name, _), seen0)) {\n                     // Fight the alias checker\n-                    auto name_ = name;\n-                    e.sess.span_err\n-                        (a.pats.(i).span, \"binding \" + name_ +\n-                         \" does not occur in first pattern\");\n+                    let name_ = name;\n+                    e.sess.span_err(a.pats.(i).span,\n+                                    \"binding \" + name_ +\n+                                        \" does not occur in first pattern\");\n                 }\n             }\n         }\n     }\n }\n \n-fn check_block(&@env e, &ast::blk b, &() x, &vt[()] v) {\n+fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt[()]) {\n     visit::visit_block(b, x, v);\n-    auto values = checker(*e, \"value\");\n-    auto types = checker(*e, \"type\");\n-    auto mods = checker(*e, \"module\");\n-    for (@ast::stmt st in b.node.stmts) {\n-        alt (st.node) {\n-            case (ast::stmt_decl(?d, _)) {\n-                alt (d.node) {\n-                    ast::decl_local(?locs) {\n-                        for (@ast::local loc in locs) {\n-                            add_name(values, d.span, loc.node.ident);\n-                        }\n-                    }\n-                    ast::decl_item(?it) {\n-                        alt (it.node) {\n-                            ast::item_tag(?variants, _) {\n-                                add_name(types, it.span, it.ident);\n-                                for (ast::variant v in variants) {\n-                                    add_name(values, v.span, v.node.name);\n-                                }\n-                            }\n-                            ast::item_mod(_) | ast::item_native_mod(_) {\n-                                add_name(mods, it.span, it.ident);\n-                            }\n-                            ast::item_const(_, _) | ast::item_fn(_, _) {\n-                                add_name(values, it.span, it.ident);\n-                            }\n-                            ast::item_ty(_, _) {\n-                                add_name(types, it.span, it.ident);\n-                            }\n-                            ast::item_res(_, _, _, _) |\n-                            ast::item_obj(_, _, _) {\n-                                add_name(types, it.span, it.ident);\n-                                add_name(values, it.span, it.ident);\n-                            }\n-                            _ { }\n-                        }\n+    let values = checker(*e, \"value\");\n+    let types = checker(*e, \"type\");\n+    let mods = checker(*e, \"module\");\n+    for st: @ast::stmt  in b.node.stmts {\n+        alt st.node {\n+          ast::stmt_decl(d, _) {\n+            alt d.node {\n+              ast::decl_local(locs) {\n+                for loc: @ast::local  in locs {\n+                    add_name(values, d.span, loc.node.ident);\n+                }\n+              }\n+              ast::decl_item(it) {\n+                alt it.node {\n+                  ast::item_tag(variants, _) {\n+                    add_name(types, it.span, it.ident);\n+                    for v: ast::variant  in variants {\n+                        add_name(values, v.span, v.node.name);\n                     }\n+                  }\n+                  ast::item_mod(_) | ast::item_native_mod(_) {\n+                    add_name(mods, it.span, it.ident);\n+                  }\n+                  ast::item_const(_, _) | ast::item_fn(_, _) {\n+                    add_name(values, it.span, it.ident);\n+                  }\n+                  ast::item_ty(_, _) { add_name(types, it.span, it.ident); }\n+                  ast::item_res(_, _, _, _) | ast::item_obj(_, _, _) {\n+                    add_name(types, it.span, it.ident);\n+                    add_name(values, it.span, it.ident);\n+                  }\n+                  _ { }\n                 }\n+              }\n             }\n-            case (_) { }\n+          }\n+          _ { }\n         }\n     }\n }\n \n-fn check_fn(&env e, &span sp, &ast::_fn f) {\n-    fn arg_name(&ast::arg a) -> ident { ret a.ident; }\n+fn check_fn(e: &env, sp: &span, f: &ast::_fn) {\n+    fn arg_name(a: &ast::arg) -> ident { ret a.ident; }\n     ensure_unique(e, sp, f.decl.inputs, arg_name, \"argument\");\n }\n \n-fn check_expr(&@env e, &@ast::expr ex, &() x, &vt[()] v) {\n+fn check_expr(e: &@env, ex: &@ast::expr, x: &(), v: &vt[()]) {\n     alt ex.node {\n-      ast::expr_rec(?fields, _) {\n-        fn field_name(&ast::field f) -> ident { ret f.node.ident; }\n+      ast::expr_rec(fields, _) {\n+        fn field_name(f: &ast::field) -> ident { ret f.node.ident; }\n         ensure_unique(*e, ex.span, fields, field_name, \"field\");\n       }\n-      _ {}\n+      _ { }\n     }\n     visit::visit_expr(ex, x, v);\n }\n \n-fn check_ty(&@env e, &@ast::ty ty, &() x, &vt[()] v) {\n+fn check_ty(e: &@env, ty: &@ast::ty, x: &(), v: &vt[()]) {\n     alt ty.node {\n-      ast::ty_rec(?fields) {\n-        fn field_name(&ast::ty_field f) -> ident { ret f.node.ident; }\n+      ast::ty_rec(fields) {\n+        fn field_name(f: &ast::ty_field) -> ident { ret f.node.ident; }\n         ensure_unique(*e, ty.span, fields, field_name, \"field\");\n       }\n-      _ {}\n+      _ { }\n     }\n     visit::visit_ty(ty, x, v);\n }\n \n-type checker = @rec(mutable ident[] seen, str kind, session sess);\n+type checker = @{mutable seen: ident[], kind: str, sess: session};\n \n-fn checker(&env e, str kind) -> checker {\n-    let ident[] seen = ~[];\n-    ret @rec(mutable seen=seen, kind=kind, sess=e.sess);\n+fn checker(e: &env, kind: str) -> checker {\n+    let seen: ident[] = ~[];\n+    ret @{mutable seen: seen, kind: kind, sess: e.sess};\n }\n \n-fn add_name(&checker ch, &span sp, &ident name) {\n-    for (ident s in ch.seen) {\n-        if (str::eq(s, name)) {\n+fn add_name(ch: &checker, sp: &span, name: &ident) {\n+    for s: ident  in ch.seen {\n+        if str::eq(s, name) {\n             ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + name);\n         }\n     }\n     ch.seen += ~[name];\n }\n \n-fn ident_id(&ident i) -> ident { ret i; }\n+fn ident_id(i: &ident) -> ident { ret i; }\n \n-fn ensure_unique[T](&env e, &span sp, &T[] elts, fn(&T) -> ident  id,\n-                    &str kind) {\n-    auto ch = checker(e, kind);\n-    for (T elt in elts) { add_name(ch, sp, id(elt)); }\n+fn ensure_unique[T](e: &env, sp: &span, elts: &T[], id: fn(&T) -> ident ,\n+                    kind: &str) {\n+    let ch = checker(e, kind);\n+    for elt: T  in elts { add_name(ch, sp, id(elt)); }\n }\n \n // Local Variables:"}, {"sha": "43b6f8d1d065dc4aeb3db9f0cb01b9a55772f682", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4323, "deletions": 4497, "changes": 8820, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "dbf8e472e53945610efa79d6e7e997735e518889", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 265, "deletions": 290, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -23,262 +23,246 @@ import trans_common::*;\n // An option identifying a branch (either a literal or a tag variant)\n tag opt {\n     lit(@ast::lit);\n-    var(uint /* variant id */, rec(def_id tg, def_id var) /* variant dids */);\n+    var(/* variant id */uint, /* variant dids */{tg: def_id, var: def_id});\n }\n-fn opt_eq(&opt a, &opt b) -> bool {\n-    alt (a) {\n-        lit(?la) {\n-            ret alt (b) { lit(?lb) { lit_eq(la, lb) } var(_, _) { false } };\n-        }\n-        var(?ida, _) {\n-            ret alt (b) { lit(_) { false } var(?idb, _) { ida == idb } };\n-        }\n+fn opt_eq(a: &opt, b: &opt) -> bool {\n+    alt a {\n+      lit(la) {\n+        ret alt b { lit(lb) { lit_eq(la, lb) } var(_, _) { false } };\n+      }\n+      var(ida, _) {\n+        ret alt b { lit(_) { false } var(idb, _) { ida == idb } };\n+      }\n     }\n }\n-fn trans_opt(&@block_ctxt bcx, &opt o) -> result {\n-    alt (o) {\n-        lit(?l) { ret trans::trans_lit(bcx, *l); }\n-        var(?id, _) { ret rslt(bcx, C_int(id as int)); }\n+fn trans_opt(bcx: &@block_ctxt, o: &opt) -> result {\n+    alt o {\n+      lit(l) { ret trans::trans_lit(bcx, *l); }\n+      var(id, _) { ret rslt(bcx, C_int(id as int)); }\n     }\n }\n \n-fn variant_opt(&@crate_ctxt ccx, ast::node_id pat_id) -> opt {\n-    auto vdef = ast::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n-    auto variants = ty::tag_variants(ccx.tcx, vdef.tg);\n-    auto i = 0u;\n-    for (ty::variant_info v in variants) {\n-        if (vdef.var == v.id) { ret var(i, vdef); }\n+fn variant_opt(ccx: &@crate_ctxt, pat_id: ast::node_id) -> opt {\n+    let vdef = ast::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n+    let variants = ty::tag_variants(ccx.tcx, vdef.tg);\n+    let i = 0u;\n+    for v: ty::variant_info  in variants {\n+        if vdef.var == v.id { ret var(i, vdef); }\n         i += 1u;\n     }\n     fail;\n }\n \n-type bind_map = rec(ast::ident ident, ValueRef val)[];\n-type match_branch = @rec((@ast::pat)[] pats,\n-                         BasicBlockRef body,\n-                         mutable bind_map bound);\n+type bind_map = {ident: ast::ident, val: ValueRef}[];\n+type match_branch =\n+    @{pats: (@ast::pat)[], body: BasicBlockRef, mutable bound: bind_map};\n type match = match_branch[];\n \n-fn matches_always(&@ast::pat p) -> bool {\n+fn matches_always(p: &@ast::pat) -> bool {\n     ret alt p.node {\n-        ast::pat_wild { true }\n-        ast::pat_bind(_) { true }\n-        ast::pat_rec(_, _) { true }\n-        _ { false }\n-    };\n+          ast::pat_wild. { true }\n+          ast::pat_bind(_) { true }\n+          ast::pat_rec(_, _) { true }\n+          _ { false }\n+        };\n }\n \n \n-fn bind_for_pat(&@ast::pat p, &match_branch br, ValueRef val) {\n+fn bind_for_pat(p: &@ast::pat, br: &match_branch, val: ValueRef) {\n     alt p.node {\n-        ast::pat_bind(?name) {\n-            br.bound += ~[rec(ident=name, val=val)];\n-        }\n-        _ {}\n+      ast::pat_bind(name) { br.bound += ~[{ident: name, val: val}]; }\n+      _ { }\n     }\n }\n \n-type enter_pat = fn(&@ast::pat) -> option::t[(@ast::pat)[]];\n-\n-fn enter_match(&match m, uint col, ValueRef val, &enter_pat e) -> match {\n-    auto result = ~[];\n-    for (match_branch br in m) {\n-        alt (e(br.pats.(col))) {\n-            some(?sub) {\n-                auto pats = ivec::slice(br.pats, 0u, col) +\n-                    sub + ivec::slice(br.pats, col + 1u, ivec::len(br.pats));\n-                auto new_br = @rec(pats=pats with *br);\n-                result += ~[new_br];\n-                bind_for_pat(br.pats.(col), new_br, val);\n-            }\n-            none {}\n+type enter_pat = fn(&@ast::pat) -> option::t[(@ast::pat)[]] ;\n+\n+fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n+    let result = ~[];\n+    for br: match_branch  in m {\n+        alt e(br.pats.(col)) {\n+          some(sub) {\n+            let pats =\n+                ivec::slice(br.pats, 0u, col) + sub +\n+                    ivec::slice(br.pats, col + 1u, ivec::len(br.pats));\n+            let new_br = @{pats: pats with *br};\n+            result += ~[new_br];\n+            bind_for_pat(br.pats.(col), new_br, val);\n+          }\n+          none. { }\n         }\n     }\n     ret result;\n }\n \n-fn enter_default(&match m, uint col, ValueRef val) -> match {\n-    fn e(&@ast::pat p) -> option::t[(@ast::pat)[]] {\n-        ret if (matches_always(p)) { some(~[]) }\n-            else { none };\n+fn enter_default(m: &match, col: uint, val: ValueRef) -> match {\n+    fn e(p: &@ast::pat) -> option::t[(@ast::pat)[]] {\n+        ret if matches_always(p) { some(~[]) } else { none };\n     }\n     ret enter_match(m, col, val, e);\n }\n \n-fn enter_opt(&@crate_ctxt ccx, &match m, &opt opt,\n-             uint col, uint tag_size, ValueRef val) -> match {\n-    auto dummy = @rec(id=0, node=ast::pat_wild, span=rec(lo=0u, hi=0u));\n-    fn e(&@crate_ctxt ccx, &@ast::pat dummy, &opt opt, uint size,\n-         &@ast::pat p) -> option::t[(@ast::pat)[]] {\n-        alt (p.node) {\n-            ast::pat_tag(?ctor, ?subpats) {\n-                ret if (opt_eq(variant_opt(ccx, p.id), opt)) { some(subpats) }\n-                    else { none };\n-            }\n-            ast::pat_lit(?l) {\n-                ret if (opt_eq(lit(l), opt)) { some(~[]) }\n-                    else { none };\n-            }\n-            _ { ret some(ivec::init_elt(dummy, size)); }\n+fn enter_opt(ccx: &@crate_ctxt, m: &match, opt: &opt, col: uint,\n+             tag_size: uint, val: ValueRef) -> match {\n+    let dummy = @{id: 0, node: ast::pat_wild, span: {lo: 0u, hi: 0u}};\n+    fn e(ccx: &@crate_ctxt, dummy: &@ast::pat, opt: &opt, size: uint,\n+         p: &@ast::pat) -> option::t[(@ast::pat)[]] {\n+        alt p.node {\n+          ast::pat_tag(ctor, subpats) {\n+            ret if opt_eq(variant_opt(ccx, p.id), opt) {\n+                    some(subpats)\n+                } else { none };\n+          }\n+          ast::pat_lit(l) {\n+            ret if opt_eq(lit(l), opt) { some(~[]) } else { none };\n+          }\n+          _ { ret some(ivec::init_elt(dummy, size)); }\n         }\n     }\n     ret enter_match(m, col, val, bind e(ccx, dummy, opt, tag_size, _));\n }\n \n-fn enter_rec(&match m, uint col, &ast::ident[] fields,\n-             ValueRef val) -> match {\n-    auto dummy = @rec(id=0, node=ast::pat_wild, span=rec(lo=0u, hi=0u));\n-    fn e(&@ast::pat dummy, &ast::ident[] fields, &@ast::pat p)\n-        -> option::t[(@ast::pat)[]] {\n-        alt (p.node) {\n-            ast::pat_rec(?fpats, _) {\n-                auto pats = ~[];\n-                for (ast::ident fname in fields) {\n-                    auto pat = dummy;\n-                    for (ast::field_pat fpat in fpats) {\n-                        if (str::eq(fpat.ident, fname)) {\n-                            pat = fpat.pat;\n-                            break;\n-                        }\n-                    }\n-                    pats += ~[pat];\n+fn enter_rec(m: &match, col: uint, fields: &ast::ident[], val: ValueRef) ->\n+   match {\n+    let dummy = @{id: 0, node: ast::pat_wild, span: {lo: 0u, hi: 0u}};\n+    fn e(dummy: &@ast::pat, fields: &ast::ident[], p: &@ast::pat) ->\n+       option::t[(@ast::pat)[]] {\n+        alt p.node {\n+          ast::pat_rec(fpats, _) {\n+            let pats = ~[];\n+            for fname: ast::ident  in fields {\n+                let pat = dummy;\n+                for fpat: ast::field_pat  in fpats {\n+                    if str::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n                 }\n-                ret some(pats);\n+                pats += ~[pat];\n             }\n-            _ { ret some(ivec::init_elt(dummy, ivec::len(fields))); }\n+            ret some(pats);\n+          }\n+          _ { ret some(ivec::init_elt(dummy, ivec::len(fields))); }\n         }\n     }\n     ret enter_match(m, col, val, bind e(dummy, fields, _));\n }\n \n-fn enter_box(&match m, uint col, ValueRef val) -> match {\n-    auto dummy = @rec(id=0, node=ast::pat_wild, span=rec(lo=0u, hi=0u));\n-    fn e(&@ast::pat dummy, &@ast::pat p) -> option::t[(@ast::pat)[]] {\n-        alt (p.node) {\n-            ast::pat_box(?sub) { ret some(~[sub]); }\n-            _ { ret some(~[dummy]); }\n+fn enter_box(m: &match, col: uint, val: ValueRef) -> match {\n+    let dummy = @{id: 0, node: ast::pat_wild, span: {lo: 0u, hi: 0u}};\n+    fn e(dummy: &@ast::pat, p: &@ast::pat) -> option::t[(@ast::pat)[]] {\n+        alt p.node {\n+          ast::pat_box(sub) { ret some(~[sub]); }\n+          _ { ret some(~[dummy]); }\n         }\n     }\n     ret enter_match(m, col, val, bind e(dummy, _));\n }\n \n-fn get_options(&@crate_ctxt ccx, &match m, uint col) -> opt[] {\n-    fn add_to_set(&mutable opt[] set, &opt val) {\n-        for (opt l in set) {\n-            if (opt_eq(l, val)) { ret; }\n-        }\n+fn get_options(ccx: &@crate_ctxt, m: &match, col: uint) -> opt[] {\n+    fn add_to_set(set: &mutable opt[], val: &opt) {\n+        for l: opt  in set { if opt_eq(l, val) { ret; } }\n         set += ~[val];\n     }\n \n-    auto found = ~[];\n-    for (match_branch br in m) {\n-        alt (br.pats.(col).node) {\n-            ast::pat_lit(?l) { add_to_set(found, lit(l)); }\n-            ast::pat_tag(_, _) {\n-                add_to_set(found, variant_opt(ccx, br.pats.(col).id));\n-            }\n-            _ {}\n+    let found = ~[];\n+    for br: match_branch  in m {\n+        alt br.pats.(col).node {\n+          ast::pat_lit(l) { add_to_set(found, lit(l)); }\n+          ast::pat_tag(_, _) {\n+            add_to_set(found, variant_opt(ccx, br.pats.(col).id));\n+          }\n+          _ { }\n         }\n     }\n     ret found;\n }\n \n-fn extract_variant_args(@block_ctxt bcx, ast::node_id pat_id,\n-                        &rec(def_id tg, def_id var) vdefs, ValueRef val)\n-    -> rec(ValueRef[] vals, @block_ctxt bcx) {\n-    auto ccx = bcx.fcx.lcx.ccx;\n-    auto ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n-    auto blobptr = val;\n-    auto variants = ty::tag_variants(ccx.tcx, vdefs.tg);\n-    auto args = ~[];\n-    auto size = ivec::len(ty::tag_variant_with_id\n-                          (ccx.tcx, vdefs.tg, vdefs.var).args);\n-    if (size > 0u && ivec::len(variants) != 1u) {\n-        auto tagptr = bcx.build.PointerCast\n-            (val, trans_common::T_opaque_tag_ptr(ccx.tn));\n+fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n+                        vdefs: &{tg: def_id, var: def_id}, val: ValueRef) ->\n+   {vals: ValueRef[], bcx: @block_ctxt} {\n+    let ccx = bcx.fcx.lcx.ccx;\n+    let ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n+    let blobptr = val;\n+    let variants = ty::tag_variants(ccx.tcx, vdefs.tg);\n+    let args = ~[];\n+    let size =\n+        ivec::len(ty::tag_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n+    if size > 0u && ivec::len(variants) != 1u {\n+        let tagptr =\n+            bcx.build.PointerCast(val,\n+                                  trans_common::T_opaque_tag_ptr(ccx.tn));\n         blobptr = bcx.build.GEP(tagptr, ~[C_int(0), C_int(1)]);\n     }\n-    auto i = 0u;\n-    while (i < size) {\n-        auto r = trans::GEP_tag(bcx, blobptr, vdefs.tg, vdefs.var,\n-                                ty_param_substs, i as int);\n+    let i = 0u;\n+    while i < size {\n+        let r =\n+            trans::GEP_tag(bcx, blobptr, vdefs.tg, vdefs.var, ty_param_substs,\n+                           i as int);\n         bcx = r.bcx;\n         args += ~[r.val];\n         i += 1u;\n     }\n-    ret rec(vals=args, bcx=bcx);\n+    ret {vals: args, bcx: bcx};\n }\n \n-fn collect_record_fields(&match m, uint col) -> ast::ident[] {\n-    auto fields = ~[];\n-    for (match_branch br in m) {\n-        alt (br.pats.(col).node) {\n-            ast::pat_rec(?fs, _) {\n-                for (ast::field_pat f in fs) {\n-                    if (!ivec::any(bind str::eq(f.ident, _), fields)) {\n-                        fields += ~[f.ident];\n-                    }\n+fn collect_record_fields(m: &match, col: uint) -> ast::ident[] {\n+    let fields = ~[];\n+    for br: match_branch  in m {\n+        alt br.pats.(col).node {\n+          ast::pat_rec(fs, _) {\n+            for f: ast::field_pat  in fs {\n+                if !ivec::any(bind str::eq(f.ident, _), fields) {\n+                    fields += ~[f.ident];\n                 }\n             }\n-            _ {}\n+          }\n+          _ { }\n         }\n     }\n     ret fields;\n }\n \n-fn any_box_pat(&match m, uint col) -> bool {\n-    for (match_branch br in m) {\n-        alt (br.pats.(col).node) {\n-            ast::pat_box(_) { ret true; }\n-            _ {}\n-        }\n+fn any_box_pat(m: &match, col: uint) -> bool {\n+    for br: match_branch  in m {\n+        alt br.pats.(col).node { ast::pat_box(_) { ret true; } _ { } }\n     }\n     ret false;\n }\n \n-type exit_node = rec(bind_map bound,\n-                     BasicBlockRef from,\n-                     BasicBlockRef to);\n-type mk_fail = fn() -> BasicBlockRef;\n+type exit_node = {bound: bind_map, from: BasicBlockRef, to: BasicBlockRef};\n+type mk_fail = fn() -> BasicBlockRef ;\n \n-fn compile_submatch(@block_ctxt bcx, &match m, ValueRef[] vals, &mk_fail f,\n-                    &mutable exit_node[] exits) {\n-    if (ivec::len(m) == 0u) {\n-        bcx.build.Br(f());\n-        ret;\n-    }\n-    if (ivec::len(m.(0).pats) == 0u) {\n-        exits += ~[rec(bound=m.(0).bound,\n-                       from=bcx.llbb,\n-                       to=m.(0).body)];\n+fn compile_submatch(bcx: @block_ctxt, m: &match, vals: ValueRef[],\n+                    f: &mk_fail, exits: &mutable exit_node[]) {\n+    if ivec::len(m) == 0u { bcx.build.Br(f()); ret; }\n+    if ivec::len(m.(0).pats) == 0u {\n+        exits += ~[{bound: m.(0).bound, from: bcx.llbb, to: m.(0).body}];\n         bcx.build.Br(m.(0).body);\n         ret;\n     }\n \n     // FIXME maybe be clever about picking a column.\n-    auto col = 0u;\n-    auto val = vals.(col);\n-    auto vals_left = ivec::slice(vals, 1u, ivec::len(vals));\n-    auto ccx = bcx.fcx.lcx.ccx;\n-    auto pat_id = 0;\n-    for (match_branch br in m) {\n+    let col = 0u;\n+    let val = vals.(col);\n+    let vals_left = ivec::slice(vals, 1u, ivec::len(vals));\n+    let ccx = bcx.fcx.lcx.ccx;\n+    let pat_id = 0;\n+    for br: match_branch  in m {\n+\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n-        if (pat_id == 0) { pat_id = br.pats.(col).id; }\n+        if pat_id == 0 { pat_id = br.pats.(col).id; }\n     }\n \n-    auto rec_fields = collect_record_fields(m, col);\n+    let rec_fields = collect_record_fields(m, col);\n     // Separate path for extracting and binding record fields\n-    if (ivec::len(rec_fields) > 0u) {\n-        auto rec_ty = ty::node_id_to_monotype(ccx.tcx, pat_id);\n-        auto fields = alt (ty::struct(ccx.tcx, rec_ty)) {\n-            ty::ty_rec(?fields) { fields }\n-        };\n-        auto rec_vals = ~[];\n-        for (ast::ident field_name in rec_fields) {\n-            let uint ix = ty::field_idx(ccx.sess, rec(lo=0u, hi=0u),\n-                                        field_name, fields);\n-            auto r = trans::GEP_tup_like(bcx, rec_ty, val, ~[0, ix as int]);\n+    if ivec::len(rec_fields) > 0u {\n+        let rec_ty = ty::node_id_to_monotype(ccx.tcx, pat_id);\n+        let fields =\n+            alt ty::struct(ccx.tcx, rec_ty) { ty::ty_rec(fields) { fields } };\n+        let rec_vals = ~[];\n+        for field_name: ast::ident  in rec_fields {\n+            let ix: uint =\n+                ty::field_idx(ccx.sess, {lo: 0u, hi: 0u}, field_name, fields);\n+            let r = trans::GEP_tup_like(bcx, rec_ty, val, ~[0, ix as int]);\n             rec_vals += ~[r.val];\n             bcx = r.bcx;\n         }\n@@ -288,171 +272,162 @@ fn compile_submatch(@block_ctxt bcx, &match m, ValueRef[] vals, &mk_fail f,\n     }\n \n     // Unbox in case of a box field\n-    if (any_box_pat(m, col)) {\n-        auto box = bcx.build.Load(val);\n-        auto unboxed = bcx.build.InBoundsGEP\n-            (box, ~[C_int(0), C_int(back::abi::box_rc_field_body)]);\n-        compile_submatch(bcx, enter_box(m, col, val),\n-                         ~[unboxed] + vals_left, f, exits);\n+    if any_box_pat(m, col) {\n+        let box = bcx.build.Load(val);\n+        let unboxed =\n+            bcx.build.InBoundsGEP(box,\n+                                  ~[C_int(0),\n+                                    C_int(back::abi::box_rc_field_body)]);\n+        compile_submatch(bcx, enter_box(m, col, val), ~[unboxed] + vals_left,\n+                         f, exits);\n         ret;\n     }\n \n     // Decide what kind of branch we need\n-    auto opts = get_options(ccx, m, col);\n+    let opts = get_options(ccx, m, col);\n     tag branch_kind { no_branch; single; switch; compare; }\n-    auto kind = no_branch;\n-    auto test_val = val;\n-    if (ivec::len(opts) > 0u) {\n-        alt (opts.(0)) {\n-            var(_, ?vdef) {\n-                if (ivec::len(ty::tag_variants(ccx.tcx, vdef.tg)) == 1u) {\n-                    kind = single;\n-                } else {\n-                    auto tagptr = bcx.build.PointerCast\n-                        (val, trans_common::T_opaque_tag_ptr(ccx.tn));\n-                    auto discrimptr = bcx.build.GEP\n-                        (tagptr, ~[C_int(0), C_int(0)]);\n-                    test_val = bcx.build.Load(discrimptr);\n-                    kind = switch;\n-                }\n-            }\n-            lit(?l) {\n-                test_val = bcx.build.Load(val);\n-                kind = alt (l.node) {\n-                    ast::lit_str(_, _) { compare }\n-                    _ { switch }\n-                };\n+    let kind = no_branch;\n+    let test_val = val;\n+    if ivec::len(opts) > 0u {\n+        alt opts.(0) {\n+          var(_, vdef) {\n+            if ivec::len(ty::tag_variants(ccx.tcx, vdef.tg)) == 1u {\n+                kind = single;\n+            } else {\n+                let tagptr =\n+                    bcx.build.PointerCast(val,\n+                                          trans_common::T_opaque_tag_ptr(ccx.tn));\n+                let discrimptr = bcx.build.GEP(tagptr, ~[C_int(0), C_int(0)]);\n+                test_val = bcx.build.Load(discrimptr);\n+                kind = switch;\n             }\n+          }\n+          lit(l) {\n+            test_val = bcx.build.Load(val);\n+            kind = alt l.node { ast::lit_str(_, _) { compare } _ { switch } };\n+          }\n         }\n     }\n-    auto else_cx = alt (kind) {\n-        no_branch | single { bcx }\n-        _ { new_sub_block_ctxt(bcx, \"match_else\") }\n-    };\n-    auto sw = if (kind == switch) {\n-        bcx.build.Switch(test_val, else_cx.llbb, ivec::len(opts))\n-    } else { C_int(0) }; // Placeholder for when not using a switch\n-\n-    // Compile subtrees for each option\n-    for (opt opt in opts) {\n-        auto opt_cx = new_sub_block_ctxt(bcx, \"match_case\");\n-        alt (kind) {\n-            single { bcx.build.Br(opt_cx.llbb); }\n-            switch {\n-                auto r = trans_opt(bcx, opt);\n-                bcx = r.bcx;\n-                llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n-            }\n-            compare {\n-                auto r = trans_opt(bcx, opt);\n-                bcx = r.bcx;\n-                auto t = ty::node_id_to_type(ccx.tcx, pat_id);\n-                auto eq = trans::trans_compare(bcx, ast::eq, t, test_val,\n-                                               r.val);\n-                bcx = new_sub_block_ctxt(bcx, \"next\");\n-                eq.bcx.build.CondBr(eq.val, opt_cx.llbb, bcx.llbb);\n-            }\n-            _ {}\n+    let else_cx =\n+        alt kind {\n+          no_branch. | single. { bcx }\n+          _ { new_sub_block_ctxt(bcx, \"match_else\") }\n+        };\n+    let sw =\n+        if kind == switch {\n+            bcx.build.Switch(test_val, else_cx.llbb, ivec::len(opts))\n+        } else { C_int(0) }; // Placeholder for when not using a switch\n+\n+     // Compile subtrees for each option\n+    for opt: opt  in opts {\n+        let opt_cx = new_sub_block_ctxt(bcx, \"match_case\");\n+        alt kind {\n+          single. { bcx.build.Br(opt_cx.llbb); }\n+          switch. {\n+            let r = trans_opt(bcx, opt);\n+            bcx = r.bcx;\n+            llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n+          }\n+          compare. {\n+            let r = trans_opt(bcx, opt);\n+            bcx = r.bcx;\n+            let t = ty::node_id_to_type(ccx.tcx, pat_id);\n+            let eq = trans::trans_compare(bcx, ast::eq, t, test_val, r.val);\n+            bcx = new_sub_block_ctxt(bcx, \"next\");\n+            eq.bcx.build.CondBr(eq.val, opt_cx.llbb, bcx.llbb);\n+          }\n+          _ { }\n         }\n-        auto size = 0u;\n-        auto unpacked = ~[];\n+        let size = 0u;\n+        let unpacked = ~[];\n         alt opt {\n-             var(_, ?vdef) {\n-                 auto args = extract_variant_args(opt_cx, pat_id, vdef, val);\n-                 size = ivec::len(args.vals);\n-                 unpacked = args.vals;\n-                 opt_cx = args.bcx;\n-             }\n-             lit(_) { }\n+          var(_, vdef) {\n+            let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n+            size = ivec::len(args.vals);\n+            unpacked = args.vals;\n+            opt_cx = args.bcx;\n+          }\n+          lit(_) { }\n         }\n         compile_submatch(opt_cx, enter_opt(ccx, m, opt, col, size, val),\n                          unpacked + vals_left, f, exits);\n     }\n \n     // Compile the fall-through case\n-    if (kind == compare) { bcx.build.Br(else_cx.llbb); }\n-    if (kind != single) {\n-        compile_submatch(else_cx, enter_default(m, col, val), vals_left,\n-                         f, exits);\n+    if kind == compare { bcx.build.Br(else_cx.llbb); }\n+    if kind != single {\n+        compile_submatch(else_cx, enter_default(m, col, val), vals_left, f,\n+                         exits);\n     }\n }\n \n // Returns false for unreachable blocks\n-fn make_phi_bindings(&@block_ctxt bcx, &exit_node[] map,\n-                     &ast::pat_id_map ids) -> bool {\n-    fn assoc(str key, &bind_map list)\n-        -> option::t[ValueRef] {\n-        for (rec(ast::ident ident, ValueRef val) elt in list) {\n-            if (str::eq(elt.ident, key)) { ret some(elt.val); }\n+fn make_phi_bindings(bcx: &@block_ctxt, map: &exit_node[],\n+                     ids: &ast::pat_id_map) -> bool {\n+    fn assoc(key: str, list: &bind_map) -> option::t[ValueRef] {\n+        for elt: {ident: ast::ident, val: ValueRef}  in list {\n+            if str::eq(elt.ident, key) { ret some(elt.val); }\n         }\n         ret none;\n     }\n \n-    auto our_block = bcx.llbb as uint;\n-    auto success = true;\n-    for each (@rec(ast::ident key, ast::node_id val) item\n-              in ids.items()) {\n-        auto llbbs = ~[];\n-        auto vals = ~[];\n-        for (exit_node ex in map) {\n-            if (ex.to as uint == our_block) {\n-                alt (assoc(item.key, ex.bound)) {\n-                    some(?val) {\n-                        llbbs += ~[ex.from];\n-                        vals += ~[val];\n-                    }\n-                    none {}\n+    let our_block = bcx.llbb as uint;\n+    let success = true;\n+    for each item: @{key: ast::ident, val: ast::node_id}  in ids.items() {\n+        let llbbs = ~[];\n+        let vals = ~[];\n+        for ex: exit_node  in map {\n+            if ex.to as uint == our_block {\n+                alt assoc(item.key, ex.bound) {\n+                  some(val) { llbbs += ~[ex.from]; vals += ~[val]; }\n+                  none. { }\n                 }\n             }\n         }\n-        if (ivec::len(vals) > 0u) {\n-            auto phi = bcx.build.Phi(val_ty(vals.(0)), vals, llbbs);\n+        if ivec::len(vals) > 0u {\n+            let phi = bcx.build.Phi(val_ty(vals.(0)), vals, llbbs);\n             bcx.fcx.lllocals.insert(item.val, phi);\n         } else { success = false; }\n     }\n     ret success;\n }\n \n-fn trans_alt(&@block_ctxt cx, &@ast::expr expr, &ast::arm[] arms,\n-             ast::node_id id, &trans::out_method output) -> result {\n-    auto bodies = ~[];\n-    let match match = ~[];\n-    for (ast::arm a in arms) {\n-        auto body = new_scope_block_ctxt(cx, \"case_body\");\n+fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &ast::arm[],\n+             id: ast::node_id, output: &trans::out_method) -> result {\n+    let bodies = ~[];\n+    let match: match = ~[];\n+    for a: ast::arm  in arms {\n+        let body = new_scope_block_ctxt(cx, \"case_body\");\n         bodies += ~[body];\n-        for (@ast::pat p in a.pats) {\n-            match += ~[@rec(pats=~[p], body=body.llbb, mutable bound=~[])];\n+        for p: @ast::pat  in a.pats {\n+            match += ~[@{pats: ~[p], body: body.llbb, mutable bound: ~[]}];\n         }\n     }\n \n     // Cached fail-on-fallthrough block\n-    auto fail_cx = @mutable none;\n-    fn mk_fail(&@block_ctxt cx, &span sp,\n-               @mutable option::t[BasicBlockRef] done) -> BasicBlockRef {\n-        alt (*done) {\n-            some(?bb) { ret bb; }\n-            _ {}\n-        }\n-        auto fail_cx = new_sub_block_ctxt(cx, \"case_fallthrough\");\n+    let fail_cx = @mutable none;\n+    fn mk_fail(cx: &@block_ctxt, sp: &span,\n+               done: @mutable option::t[BasicBlockRef]) -> BasicBlockRef {\n+        alt *done { some(bb) { ret bb; } _ { } }\n+        let fail_cx = new_sub_block_ctxt(cx, \"case_fallthrough\");\n         trans::trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");\n         *done = some(fail_cx.llbb);\n         ret fail_cx.llbb;\n     }\n \n-    auto exit_map = ~[];\n-    auto er = trans::trans_expr(cx, expr);\n-    auto t = trans::node_id_type(cx.fcx.lcx.ccx, expr.id);\n-    auto v = trans::spill_if_immediate(er.bcx, er.val, t);\n+    let exit_map = ~[];\n+    let er = trans::trans_expr(cx, expr);\n+    let t = trans::node_id_type(cx.fcx.lcx.ccx, expr.id);\n+    let v = trans::spill_if_immediate(er.bcx, er.val, t);\n     compile_submatch(er.bcx, match, ~[v],\n                      bind mk_fail(cx, expr.span, fail_cx), exit_map);\n \n-    auto i = 0u;\n-    auto arm_results = ~[];\n-    for (ast::arm a in arms) {\n-        auto body_cx = bodies.(i);\n-        if (make_phi_bindings(body_cx, exit_map,\n-                              ast::pat_id_map(a.pats.(0)))) {\n-            auto block_res = trans::trans_block(body_cx, a.block, output);\n+    let i = 0u;\n+    let arm_results = ~[];\n+    for a: ast::arm  in arms {\n+        let body_cx = bodies.(i);\n+        if make_phi_bindings(body_cx, exit_map, ast::pat_id_map(a.pats.(0))) {\n+            let block_res = trans::trans_block(body_cx, a.block, output);\n             arm_results += ~[block_res];\n         } else { // Unreachable\n             arm_results += ~[rslt(body_cx, C_nil())];"}, {"sha": "17285b9f1c417abe7dc75ffcdd10b34dcb3f9ce5", "filename": "src/comp/middle/trans_comm.rs", "status": "modified", "additions": 107, "deletions": 116, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -28,54 +28,53 @@ export trans_spawn;\n export trans_send;\n export trans_recv;\n \n-fn trans_port(&@block_ctxt cx, ast::node_id id) -> result {\n-    auto t = node_id_type(cx.fcx.lcx.ccx, id);\n-    auto unit_ty;\n-    alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n-        case (ty::ty_port(?t)) { unit_ty = t; }\n-        case (_) { cx.fcx.lcx.ccx.sess.bug(\"non-port type in trans_port\"); }\n+fn trans_port(cx: &@block_ctxt, id: ast::node_id) -> result {\n+    let t = node_id_type(cx.fcx.lcx.ccx, id);\n+    let unit_ty;\n+    alt ty::struct(cx.fcx.lcx.ccx.tcx, t) {\n+      ty::ty_port(t) { unit_ty = t; }\n+      _ { cx.fcx.lcx.ccx.sess.bug(\"non-port type in trans_port\"); }\n     }\n-    auto bcx = cx;\n-    auto unit_sz = size_of(bcx, unit_ty);\n+    let bcx = cx;\n+    let unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n-    auto port_raw_val =\n+    let port_raw_val =\n         bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_port,\n                        ~[bcx.fcx.lltaskptr, unit_sz.val]);\n-    auto llty = type_of(cx.fcx.lcx.ccx, cx.sp, t);\n-    auto port_val = bcx.build.PointerCast(port_raw_val, llty);\n+    let llty = type_of(cx.fcx.lcx.ccx, cx.sp, t);\n+    let port_val = bcx.build.PointerCast(port_raw_val, llty);\n     add_clean_temp(bcx, port_val, t);\n     ret rslt(bcx, port_val);\n }\n \n-fn trans_chan(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n-    auto bcx = cx;\n-    auto prt = trans_expr(bcx, e);\n+fn trans_chan(cx: &@block_ctxt, e: &@ast::expr, id: ast::node_id) -> result {\n+    let bcx = cx;\n+    let prt = trans_expr(bcx, e);\n     bcx = prt.bcx;\n-    auto prt_val = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n-    auto chan_raw_val =\n+    let prt_val = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n+    let chan_raw_val =\n         bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_chan,\n                        ~[bcx.fcx.lltaskptr, prt_val]);\n-    auto chan_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n-    auto chan_llty = type_of(bcx.fcx.lcx.ccx, e.span, chan_ty);\n-    auto chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n+    let chan_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n+    let chan_llty = type_of(bcx.fcx.lcx.ccx, e.span, chan_ty);\n+    let chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n     add_clean_temp(bcx, chan_val, chan_ty);\n     ret rslt(bcx, chan_val);\n }\n \n-fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n-               &@ast::expr func, &(@ast::expr)[] args, ast::node_id id)\n-        -> result {\n-    auto bcx = cx;\n+fn trans_spawn(cx: &@block_ctxt, dom: &ast::spawn_dom, name: &option::t[str],\n+               func: &@ast::expr, args: &(@ast::expr)[], id: ast::node_id) ->\n+   result {\n+    let bcx = cx;\n     // Make the task name\n \n-    auto tname =\n-        alt (name) {\n-            case (none) {\n-                auto argss = std::ivec::map(expr_to_str, args);\n-                #fmt(\"%s(%s)\", expr_to_str(func),\n-                     str::connect_ivec(argss, \", \"))\n-            }\n-            case (some(?n)) { n }\n+    let tname =\n+        alt name {\n+          none. {\n+            let argss = std::ivec::map(expr_to_str, args);\n+            #fmt(\"%s(%s)\", expr_to_str(func), str::connect_ivec(argss, \", \"))\n+          }\n+          some(n) { n }\n         };\n     // Generate code\n     //\n@@ -100,19 +99,19 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n \n     // But first, we'll create a task.\n \n-    let ValueRef lltname = C_str(bcx.fcx.lcx.ccx, tname);\n-    auto new_task =\n+    let lltname: ValueRef = C_str(bcx.fcx.lcx.ccx, tname);\n+    let new_task =\n         bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_task,\n                        ~[bcx.fcx.lltaskptr, lltname]);\n \n     // Translate the arguments, remembering their types and where the values\n     // ended up.\n \n-    let ty::t[] arg_tys = ~[];\n-    let ValueRef[] arg_vals = ~[];\n-    for (@ast::expr e in args) {\n-        auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n-        auto arg = trans_expr(bcx, e);\n+    let arg_tys: ty::t[] = ~[];\n+    let arg_vals: ValueRef[] = ~[];\n+    for e: @ast::expr  in args {\n+        let e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n+        let arg = trans_expr(bcx, e);\n \n         arg = deep_copy(arg.bcx, arg.val, e_ty, new_task);\n \n@@ -123,74 +122,74 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n     }\n     // Make the tuple.\n \n-    auto args_ty = ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, arg_tys);\n+    let args_ty = ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, arg_tys);\n     // Allocate and fill the tuple.\n \n-    auto llargs = alloc_ty(bcx, args_ty);\n-    auto i = 0u;\n-    for (ValueRef v in arg_vals) {\n-        auto target = bcx.build.GEP(llargs.val, ~[C_int(0), C_int(i as int)]);\n+    let llargs = alloc_ty(bcx, args_ty);\n+    let i = 0u;\n+    for v: ValueRef  in arg_vals {\n+        let target = bcx.build.GEP(llargs.val, ~[C_int(0), C_int(i as int)]);\n \n         bcx.build.Store(v, target);\n         i += 1u;\n     }\n \n     // Generate the wrapper function\n-    auto wrapper = mk_spawn_wrapper(bcx, func, args_ty);\n+    let wrapper = mk_spawn_wrapper(bcx, func, args_ty);\n     bcx = wrapper.bcx;\n-    auto llfnptr_i = bcx.build.PointerCast(wrapper.val, T_int());\n+    let llfnptr_i = bcx.build.PointerCast(wrapper.val, T_int());\n \n     // And start the task\n-    auto llargs_i = bcx.build.PointerCast(llargs.val, T_int());\n-    auto args_size = size_of(bcx, args_ty).val;\n+    let llargs_i = bcx.build.PointerCast(llargs.val, T_int());\n+    let args_size = size_of(bcx, args_ty).val;\n     bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.start_task,\n                    ~[bcx.fcx.lltaskptr, new_task, llfnptr_i, llargs_i,\n                      args_size]);\n-    auto task_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n+    let task_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n     add_clean_temp(bcx, new_task, task_ty);\n     ret rslt(bcx, new_task);\n }\n \n-fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n+fn mk_spawn_wrapper(cx: &@block_ctxt, func: &@ast::expr, args_ty: &ty::t) ->\n    result {\n-    auto llmod = cx.fcx.lcx.ccx.llmod;\n-    auto wrapper_fn_type =\n+    let llmod = cx.fcx.lcx.ccx.llmod;\n+    let wrapper_fn_type =\n         type_of_fn(cx.fcx.lcx.ccx, cx.sp, ast::proto_fn,\n-                   ~[rec(mode=ty::mo_alias(false), ty=args_ty)], ty::idx_nil,\n+                   ~[{mode: ty::mo_alias(false), ty: args_ty}], ty::idx_nil,\n                    0u);\n     // TODO: construct a name based on tname\n \n-    let str wrap_name =\n+    let wrap_name: str =\n         mangle_internal_name_by_path_and_seq(cx.fcx.lcx.ccx, cx.fcx.lcx.path,\n                                              \"spawn_wrapper\");\n-    auto llfndecl = decl_cdecl_fn(llmod, wrap_name, wrapper_fn_type);\n-    auto fcx = new_fn_ctxt(cx.fcx.lcx, cx.sp, llfndecl);\n-    auto fbcx = new_top_block_ctxt(fcx);\n+    let llfndecl = decl_cdecl_fn(llmod, wrap_name, wrapper_fn_type);\n+    let fcx = new_fn_ctxt(cx.fcx.lcx, cx.sp, llfndecl);\n+    let fbcx = new_top_block_ctxt(fcx);\n     // 3u to skip the three implicit args\n \n-    let ValueRef arg = llvm::LLVMGetParam(fcx.llfn, 3u);\n-    let ValueRef[] child_args =\n+    let arg: ValueRef = llvm::LLVMGetParam(fcx.llfn, 3u);\n+    let child_args: ValueRef[] =\n         ~[llvm::LLVMGetParam(fcx.llfn, 0u), llvm::LLVMGetParam(fcx.llfn, 1u),\n           llvm::LLVMGetParam(fcx.llfn, 2u)];\n     // unpack the arguments\n \n-    alt (ty::struct(fcx.lcx.ccx.tcx, args_ty)) {\n-        case (ty::ty_rec(?fields)) {\n-            auto i = 0;\n-            for (ty::field f in fields) {\n-                auto src = fbcx.build.GEP(arg, ~[C_int(0), C_int(i)]);\n-                i += 1;\n-                auto child_arg = fbcx.build.Load(src);\n-                child_args += ~[child_arg];\n-            }\n+    alt ty::struct(fcx.lcx.ccx.tcx, args_ty) {\n+      ty::ty_rec(fields) {\n+        let i = 0;\n+        for f: ty::field  in fields {\n+            let src = fbcx.build.GEP(arg, ~[C_int(0), C_int(i)]);\n+            i += 1;\n+            let child_arg = fbcx.build.Load(src);\n+            child_args += ~[child_arg];\n         }\n+      }\n     }\n     // Find the function\n \n-    auto fnptr = trans_lval(fbcx, func).res;\n+    let fnptr = trans_lval(fbcx, func).res;\n     fbcx = fnptr.bcx;\n-    auto llfnptr = fbcx.build.GEP(fnptr.val, ~[C_int(0), C_int(0)]);\n-    auto llfn = fbcx.build.Load(llfnptr);\n+    let llfnptr = fbcx.build.GEP(fnptr.val, ~[C_int(0), C_int(0)]);\n+    let llfn = fbcx.build.Load(llfnptr);\n     fbcx.build.FastCall(llfn, child_args);\n     fbcx.build.RetVoid();\n     finish_fn(fcx, fbcx.llbb);\n@@ -199,48 +198,46 @@ fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n     ret rslt(cx, llfndecl);\n }\n \n-fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n-              ast::node_id id) -> result {\n-    auto bcx = cx;\n-    auto chn = trans_expr(bcx, lhs);\n+fn trans_send(cx: &@block_ctxt, lhs: &@ast::expr, rhs: &@ast::expr,\n+              id: ast::node_id) -> result {\n+    let bcx = cx;\n+    let chn = trans_expr(bcx, lhs);\n     bcx = chn.bcx;\n-    auto data = trans_lval(bcx, rhs);\n+    let data = trans_lval(bcx, rhs);\n     bcx = data.res.bcx;\n-    auto chan_ty = node_id_type(cx.fcx.lcx.ccx, id);\n-    alt (ty::struct(cx.fcx.lcx.ccx.tcx, chan_ty)) {\n-        case (ty::ty_chan(?t)) { unit_ty = t; }\n-        case (_) { bcx.fcx.lcx.ccx.sess.bug(\"non-chan type in trans_send\"); }\n+    let chan_ty = node_id_type(cx.fcx.lcx.ccx, id);\n+    alt ty::struct(cx.fcx.lcx.ccx.tcx, chan_ty) {\n+      ty::ty_chan(t) { unit_ty = t; }\n+      _ { bcx.fcx.lcx.ccx.sess.bug(\"non-chan type in trans_send\"); }\n     }\n-    auto data_alloc = alloc_ty(bcx, unit_ty);\n+    let data_alloc = alloc_ty(bcx, unit_ty);\n     bcx = data_alloc.bcx;\n-    auto data_tmp = move_val_if_temp(bcx, INIT, data_alloc.val,\n-                                     data, unit_ty);\n+    let data_tmp = move_val_if_temp(bcx, INIT, data_alloc.val, data, unit_ty);\n     bcx = data_tmp.bcx;\n-    auto llchanval = bcx.build.PointerCast(chn.val, T_opaque_chan_ptr());\n-    auto lldataptr = bcx.build.PointerCast(data_alloc.val, T_ptr(T_i8()));\n+    let llchanval = bcx.build.PointerCast(chn.val, T_opaque_chan_ptr());\n+    let lldataptr = bcx.build.PointerCast(data_alloc.val, T_ptr(T_i8()));\n     bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.send,\n                    ~[bcx.fcx.lltaskptr, llchanval, lldataptr]);\n \n     // Deinit the stuff we sent.\n     bcx = zero_alloca(bcx, data_alloc.val, unit_ty).bcx;\n \n     ret rslt(bcx, chn.val);\n-    auto unit_ty;\n+    let unit_ty;\n }\n \n-fn trans_recv(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n-              ast::node_id id) -> result {\n-    auto bcx = cx;\n-    auto data = trans_lval(bcx, rhs);\n+fn trans_recv(cx: &@block_ctxt, lhs: &@ast::expr, rhs: &@ast::expr,\n+              id: ast::node_id) -> result {\n+    let bcx = cx;\n+    let data = trans_lval(bcx, rhs);\n     assert (data.is_mem);\n     bcx = data.res.bcx;\n     // FIXME: calculate copy init-ness in typestate.\n \n-    auto prt = trans_expr(bcx, lhs);\n+    let prt = trans_expr(bcx, lhs);\n     bcx = prt.bcx;\n-    auto lldataptr = bcx.build.PointerCast(data.res.val,\n-                                           T_ptr(T_ptr(T_i8())));\n-    auto llportptr = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n+    let lldataptr = bcx.build.PointerCast(data.res.val, T_ptr(T_ptr(T_i8())));\n+    let llportptr = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n     bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.recv,\n                    ~[bcx.fcx.lltaskptr, lldataptr, llportptr]);\n \n@@ -251,48 +248,42 @@ fn trans_recv(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n // tasks, and for sending things through channels. There are probably some\n // uniqueness optimizations and things we can do here for tasks in the same\n // domain.\n-fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task)\n-    -> result\n-{\n+fn deep_copy(bcx: &@block_ctxt, v: ValueRef, t: ty::t, target_task: ValueRef)\n+   -> result {\n     // TODO: make sure all paths add any reference counting that they need to.\n \n     // TODO: Teach deep copy to understand everything else it needs to.\n \n-    auto tcx = bcx.fcx.lcx.ccx.tcx;\n-    if(ty::type_is_scalar(tcx, t)) {\n+    let tcx = bcx.fcx.lcx.ccx.tcx;\n+    if ty::type_is_scalar(tcx, t) {\n         ret rslt(bcx, v);\n-    }\n-    else if(ty::type_is_str(tcx, t)) {\n+    } else if (ty::type_is_str(tcx, t)) {\n         ret rslt(bcx,\n-                bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.dup_str,\n-                               ~[bcx.fcx.lltaskptr, target_task, v]));\n-    }\n-    else if(ty::type_is_chan(tcx, t)) {\n+                 bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.dup_str,\n+                                ~[bcx.fcx.lltaskptr, target_task, v]));\n+    } else if (ty::type_is_chan(tcx, t)) {\n         // If this is a channel, we need to clone it.\n-        auto chan_ptr = bcx.build.PointerCast(v, T_opaque_chan_ptr());\n+        let chan_ptr = bcx.build.PointerCast(v, T_opaque_chan_ptr());\n \n-        auto chan_raw_val =\n+        let chan_raw_val =\n             bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.clone_chan,\n                            ~[bcx.fcx.lltaskptr, target_task, chan_ptr]);\n \n         // Cast back to the type the context was expecting.\n-        auto chan_val = bcx.build.PointerCast(chan_raw_val,\n-                                              val_ty(v));\n+        let chan_val = bcx.build.PointerCast(chan_raw_val, val_ty(v));\n \n         ret rslt(bcx, chan_val);\n-    }\n-    else if(ty::type_is_structural(tcx, t)) {\n-        fn inner_deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n+    } else if (ty::type_is_structural(tcx, t)) {\n+        fn inner_deep_copy(bcx: &@block_ctxt, v: ValueRef, t: ty::t) ->\n+           result {\n             log_err \"Unimplemented type for deep_copy.\";\n             fail;\n         }\n \n         ret iter_structural_ty(bcx, v, t, inner_deep_copy);\n-    }\n-    else {\n-        bcx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" +\n-                                 \"trans::deep_copy: \" +\n-                                 ty_to_str(tcx, t));\n+    } else {\n+        bcx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" + \"trans::deep_copy: \"\n+                                     + ty_to_str(tcx, t));\n     }\n }\n "}, {"sha": "7f6392397d4c3c162265481a1b42770876eb9247", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 361, "deletions": 356, "changes": 717, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -61,24 +61,24 @@ import trans::type_of_fn_full;\n import trans::drop_slot;\n import trans::drop_ty;\n \n-obj namegen(mutable int i) {\n-    fn next(str prefix) -> str { i += 1; ret prefix + int::str(i); }\n+obj namegen(mutable i: int) {\n+    fn next(prefix: str) -> str { i += 1; ret prefix + int::str(i); }\n }\n \n-type derived_tydesc_info = rec(ValueRef lltydesc, bool escapes);\n+type derived_tydesc_info = {lltydesc: ValueRef, escapes: bool};\n \n-type glue_fns = rec(ValueRef no_op_type_glue);\n+type glue_fns = {no_op_type_glue: ValueRef};\n \n type tydesc_info =\n-    rec(ty::t ty,\n-        ValueRef tydesc,\n-        ValueRef size,\n-        ValueRef align,\n-        mutable option::t[ValueRef] copy_glue,\n-        mutable option::t[ValueRef] drop_glue,\n-        mutable option::t[ValueRef] free_glue,\n-        mutable option::t[ValueRef] cmp_glue,\n-        uint[] ty_params);\n+    {ty: ty::t,\n+     tydesc: ValueRef,\n+     size: ValueRef,\n+     align: ValueRef,\n+     mutable copy_glue: option::t[ValueRef],\n+     mutable drop_glue: option::t[ValueRef],\n+     mutable free_glue: option::t[ValueRef],\n+     mutable cmp_glue: option::t[ValueRef],\n+     ty_params: uint[]};\n \n /*\n  * A note on nomenclature of linking: \"upcall\", \"extern\" and \"native\".\n@@ -96,224 +96,227 @@ type tydesc_info =\n  *\n  */\n type stats =\n-    rec(mutable uint n_static_tydescs,\n-        mutable uint n_derived_tydescs,\n-        mutable uint n_glues_created,\n-        mutable uint n_null_glues,\n-        mutable uint n_real_glues,\n-        @mutable (rec(str ident, int time)[]) fn_times);\n+    {mutable n_static_tydescs: uint,\n+     mutable n_derived_tydescs: uint,\n+     mutable n_glues_created: uint,\n+     mutable n_null_glues: uint,\n+     mutable n_real_glues: uint,\n+     fn_times: @mutable {ident: str, time: int}[]};\n \n // Crate context.  Every crate we compile has one of these.\n type crate_ctxt =\n-    rec(session::session sess,\n-        ModuleRef llmod,\n-        target_data td,\n-        type_names tn,\n-        hashmap[str, ValueRef] externs,\n-        hashmap[str, ValueRef] intrinsics,\n-\n-        // A mapping from the def_id of each item in this crate to the address\n-        // of the first instruction of the item's definition in the executable\n-        // we're generating.\n-        hashmap[ast::node_id, ValueRef] item_ids,\n-        ast_map::map ast_map,\n-        hashmap[ast::node_id, str] item_symbols,\n-        mutable option::t[ValueRef] main_fn,\n-        link::link_meta link_meta,\n-\n-        // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n-        hashmap[ty::t, uint] tag_sizes,\n-        hashmap[ast::node_id, ValueRef] discrims,\n-        hashmap[ast::node_id, str] discrim_symbols,\n-        hashmap[ast::node_id, ValueRef] fn_pairs,\n-        hashmap[ast::node_id, ValueRef] consts,\n-        hashmap[ast::node_id, ()] obj_methods,\n-        hashmap[ty::t, @tydesc_info] tydescs,\n-        hashmap[str, ValueRef] module_data,\n-        hashmap[ty::t, TypeRef] lltypes,\n-        @glue_fns glues,\n-        namegen names,\n-        std::sha1::sha1 sha,\n-        hashmap[ty::t, str] type_sha1s,\n-        hashmap[ty::t, str] type_short_names,\n-        ty::ctxt tcx,\n-        stats stats,\n-        @upcall::upcalls upcalls,\n-        TypeRef rust_object_type,\n-        TypeRef tydesc_type,\n-        TypeRef task_type);\n+\n+    // A mapping from the def_id of each item in this crate to the address\n+    // of the first instruction of the item's definition in the executable\n+    // we're generating.\n+\n+    // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n+    {sess: session::session,\n+     llmod: ModuleRef,\n+     td: target_data,\n+     tn: type_names,\n+     externs: hashmap[str, ValueRef],\n+     intrinsics: hashmap[str, ValueRef],\n+     item_ids: hashmap[ast::node_id, ValueRef],\n+     ast_map: ast_map::map,\n+     item_symbols: hashmap[ast::node_id, str],\n+     mutable main_fn: option::t[ValueRef],\n+     link_meta: link::link_meta,\n+     tag_sizes: hashmap[ty::t, uint],\n+     discrims: hashmap[ast::node_id, ValueRef],\n+     discrim_symbols: hashmap[ast::node_id, str],\n+     fn_pairs: hashmap[ast::node_id, ValueRef],\n+     consts: hashmap[ast::node_id, ValueRef],\n+     obj_methods: hashmap[ast::node_id, ()],\n+     tydescs: hashmap[ty::t, @tydesc_info],\n+     module_data: hashmap[str, ValueRef],\n+     lltypes: hashmap[ty::t, TypeRef],\n+     glues: @glue_fns,\n+     names: namegen,\n+     sha: std::sha1::sha1,\n+     type_sha1s: hashmap[ty::t, str],\n+     type_short_names: hashmap[ty::t, str],\n+     tcx: ty::ctxt,\n+     stats: stats,\n+     upcalls: @upcall::upcalls,\n+     rust_object_type: TypeRef,\n+     tydesc_type: TypeRef,\n+     task_type: TypeRef};\n \n type local_ctxt =\n-    rec(str[] path,\n-        str[] module_path,\n-        ast::ty_param[] obj_typarams,\n-        ast::obj_field[] obj_fields,\n-        @crate_ctxt ccx);\n+    {path: str[],\n+     module_path: str[],\n+     obj_typarams: ast::ty_param[],\n+     obj_fields: ast::obj_field[],\n+     ccx: @crate_ctxt};\n \n // Types used for llself.\n-type val_self_pair = rec(ValueRef v, ty::t t);\n+type val_self_pair = {v: ValueRef, t: ty::t};\n \n // Function context.  Every LLVM function we create will have one of these.\n type fn_ctxt =\n-    rec(\n-        // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n-        // address of the first instruction in the sequence of instructions\n-        // for this function that will go in the .text section of the\n-        // executable we're generating.\n-        ValueRef llfn,\n-\n-        // The three implicit arguments that arrive in the function we're\n-        // creating.  For instance, foo(int, int) is really foo(ret*, task*,\n-        // env*, int, int).  These are also available via\n-        // llvm::LLVMGetParam(llfn, uint) where uint = 1, 2, 0 respectively,\n-        // but we unpack them into these fields for convenience.\n-\n-        // Points to the current task.\n-        ValueRef lltaskptr,\n-\n-        // Points to the current environment (bindings of variables to\n-        // values), if this is a regular function; points to the current\n-        // object, if this is a method.\n-        ValueRef llenv,\n-\n-        // Points to where the return value of this function should end up.\n-        ValueRef llretptr,\n-\n-        // The next three elements: \"hoisted basic blocks\" containing\n-        // administrative activities that have to happen in only one place in\n-        // the function, due to LLVM's quirks.\n-\n-        // A block for all the function's static allocas, so that LLVM will\n-        // coalesce them into a single alloca call.\n-        mutable BasicBlockRef llstaticallocas,\n-\n-        // A block containing code that copies incoming arguments to space\n-        // already allocated by code in one of the llallocas blocks.  (LLVM\n-        // requires that arguments be copied to local allocas before allowing\n-        // most any operation to be performed on them.)\n-        mutable BasicBlockRef llcopyargs,\n-\n-        // The first block containing derived tydescs received from the\n-        // runtime.  See description of derived_tydescs, below.\n-        mutable BasicBlockRef llderivedtydescs_first,\n-\n-        // The last block of the llderivedtydescs group.\n-        mutable BasicBlockRef llderivedtydescs,\n-\n-        // A block for all of the dynamically sized allocas.  This must be\n-        // after llderivedtydescs, because these sometimes depend on\n-        // information computed from derived tydescs.\n-        mutable BasicBlockRef lldynamicallocas,\n-\n-        // FIXME: Is llcopyargs actually the block containing the allocas for\n-        // incoming function arguments?  Or is it merely the block containing\n-        // code that copies incoming args to space already alloca'd by code in\n-        // llallocas?\n-\n-        // The 'self' object currently in use in this function, if there is\n-        // one.\n-        mutable option::t[val_self_pair] llself,\n-\n-        // If this function is actually a iter, a block containing the code\n-        // called whenever the iter calls 'put'.\n-        mutable option::t[ValueRef] lliterbody,\n-\n-        // The next four items: hash tables mapping from AST def_ids to\n-        // LLVM-stuff-in-the-frame.\n-\n-        // Maps arguments to allocas created for them in llallocas.\n-        hashmap[ast::node_id, ValueRef] llargs,\n-\n-        // Maps fields in objects to pointers into the interior of llself's\n-        // body.\n-        hashmap[ast::node_id, ValueRef] llobjfields,\n-\n-        // Maps the def_ids for local variables to the allocas created for\n-        // them in llallocas.\n-        hashmap[ast::node_id, ValueRef] lllocals,\n-\n-        // The same as above, but for variables accessed via the frame pointer\n-        // we pass into an iter, for access to the static environment of the\n-        // iter-calling frame.\n-        hashmap[ast::node_id, ValueRef] llupvars,\n-\n-        // For convenience, a vector of the incoming tydescs for each of this\n-        // functions type parameters, fetched via llvm::LLVMGetParam.  For\n-        // example, for a function foo[A, B, C](), lltydescs contains the\n-        // ValueRefs for the tydescs for A, B, and C.\n-        mutable ValueRef[] lltydescs,\n-\n-        // Derived tydescs are tydescs created at runtime, for types that\n-        // involve type parameters inside type constructors.  For example,\n-        // suppose a function parameterized by T creates a vector of type\n-        // [T].  The function doesn't know what T is until runtime, and the\n-        // function's caller knows T but doesn't know that a vector is\n-        // involved.  So a tydesc for [T] can't be created until runtime,\n-        // when information about both \"[T]\" and \"T\" are available.  When such\n-        // a tydesc is created, we cache it in the derived_tydescs table for\n-        // the next time that such a tydesc is needed.\n-        hashmap[ty::t, derived_tydesc_info] derived_tydescs,\n-\n-        // The source span where this function comes from, for error\n-        // reporting.\n-        span sp,\n-\n-        // This function's enclosing local context.\n-        @local_ctxt lcx);\n+    // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n+    // address of the first instruction in the sequence of instructions\n+    // for this function that will go in the .text section of the\n+    // executable we're generating.\n+\n+    // The three implicit arguments that arrive in the function we're\n+    // creating.  For instance, foo(int, int) is really foo(ret*, task*,\n+    // env*, int, int).  These are also available via\n+    // llvm::LLVMGetParam(llfn, uint) where uint = 1, 2, 0 respectively,\n+    // but we unpack them into these fields for convenience.\n+\n+    // Points to the current task.\n+\n+    // Points to the current environment (bindings of variables to\n+    // values), if this is a regular function; points to the current\n+    // object, if this is a method.\n+\n+    // Points to where the return value of this function should end up.\n+\n+    // The next three elements: \"hoisted basic blocks\" containing\n+    // administrative activities that have to happen in only one place in\n+    // the function, due to LLVM's quirks.\n+\n+    // A block for all the function's static allocas, so that LLVM will\n+    // coalesce them into a single alloca call.\n+\n+    // A block containing code that copies incoming arguments to space\n+    // already allocated by code in one of the llallocas blocks.  (LLVM\n+    // requires that arguments be copied to local allocas before allowing\n+    // most any operation to be performed on them.)\n+\n+    // The first block containing derived tydescs received from the\n+    // runtime.  See description of derived_tydescs, below.\n+\n+    // The last block of the llderivedtydescs group.\n+\n+    // A block for all of the dynamically sized allocas.  This must be\n+    // after llderivedtydescs, because these sometimes depend on\n+    // information computed from derived tydescs.\n+\n+    // FIXME: Is llcopyargs actually the block containing the allocas for\n+    // incoming function arguments?  Or is it merely the block containing\n+    // code that copies incoming args to space already alloca'd by code in\n+    // llallocas?\n+\n+    // The 'self' object currently in use in this function, if there is\n+    // one.\n+\n+    // If this function is actually a iter, a block containing the code\n+    // called whenever the iter calls 'put'.\n+\n+    // The next four items: hash tables mapping from AST def_ids to\n+    // LLVM-stuff-in-the-frame.\n+\n+    // Maps arguments to allocas created for them in llallocas.\n+\n+    // Maps fields in objects to pointers into the interior of llself's\n+    // body.\n+\n+    // Maps the def_ids for local variables to the allocas created for\n+    // them in llallocas.\n+\n+    // The same as above, but for variables accessed via the frame pointer\n+    // we pass into an iter, for access to the static environment of the\n+    // iter-calling frame.\n+\n+    // For convenience, a vector of the incoming tydescs for each of this\n+    // functions type parameters, fetched via llvm::LLVMGetParam.  For\n+    // example, for a function foo[A, B, C](), lltydescs contains the\n+    // ValueRefs for the tydescs for A, B, and C.\n+\n+    // Derived tydescs are tydescs created at runtime, for types that\n+    // involve type parameters inside type constructors.  For example,\n+    // suppose a function parameterized by T creates a vector of type\n+    // [T].  The function doesn't know what T is until runtime, and the\n+    // function's caller knows T but doesn't know that a vector is\n+    // involved.  So a tydesc for [T] can't be created until runtime,\n+    // when information about both \"[T]\" and \"T\" are available.  When such\n+    // a tydesc is created, we cache it in the derived_tydescs table for\n+    // the next time that such a tydesc is needed.\n+\n+    // The source span where this function comes from, for error\n+    // reporting.\n+\n+    // This function's enclosing local context.\n+    {llfn: ValueRef,\n+     lltaskptr: ValueRef,\n+     llenv: ValueRef,\n+     llretptr: ValueRef,\n+     mutable llstaticallocas: BasicBlockRef,\n+     mutable llcopyargs: BasicBlockRef,\n+     mutable llderivedtydescs_first: BasicBlockRef,\n+     mutable llderivedtydescs: BasicBlockRef,\n+     mutable lldynamicallocas: BasicBlockRef,\n+     mutable llself: option::t[val_self_pair],\n+     mutable lliterbody: option::t[ValueRef],\n+     llargs: hashmap[ast::node_id, ValueRef],\n+     llobjfields: hashmap[ast::node_id, ValueRef],\n+     lllocals: hashmap[ast::node_id, ValueRef],\n+     llupvars: hashmap[ast::node_id, ValueRef],\n+     mutable lltydescs: ValueRef[],\n+     derived_tydescs: hashmap[ty::t, derived_tydesc_info],\n+     sp: span,\n+     lcx: @local_ctxt};\n \n tag cleanup {\n-    clean(fn(&@block_ctxt) -> result);\n-    clean_temp(ValueRef, fn(&@block_ctxt) -> result);\n+    clean(fn(&@block_ctxt) -> result );\n+    clean_temp(ValueRef, fn(&@block_ctxt) -> result );\n }\n \n-fn add_clean(&@block_ctxt cx, ValueRef val, ty::t ty) {\n+fn add_clean(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n     find_scope_cx(cx).cleanups += ~[clean(bind drop_slot(_, val, ty))];\n }\n-fn add_clean_temp(&@block_ctxt cx, ValueRef val, ty::t ty) {\n-    find_scope_cx(cx).cleanups += ~[clean_temp(val,\n-                                               bind drop_ty(_, val, ty))];\n+fn add_clean_temp(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n+    find_scope_cx(cx).cleanups +=\n+        ~[clean_temp(val, bind drop_ty(_, val, ty))];\n }\n \n // Note that this only works for temporaries. We should, at some point, move\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n-fn revoke_clean(&@block_ctxt cx, ValueRef val) {\n-    auto sc_cx = find_scope_cx(cx);\n-    auto found = -1;\n-    auto i = 0;\n-    for (cleanup c in sc_cx.cleanups) {\n-        alt (c) {\n-            case (clean_temp(?v, _)) {\n-                if (v as uint == val as uint) { found = i; break; }\n-            }\n-            case (_) {}\n+fn revoke_clean(cx: &@block_ctxt, val: ValueRef) {\n+    let sc_cx = find_scope_cx(cx);\n+    let found = -1;\n+    let i = 0;\n+    for c: cleanup  in sc_cx.cleanups {\n+        alt c {\n+          clean_temp(v, _) {\n+            if v as uint == val as uint { found = i; break; }\n+          }\n+          _ { }\n         }\n         i += 1;\n     }\n     // The value does not have a cleanup associated with it. Might be a\n     // constant or some immediate value.\n-    if (found == -1) { ret; }\n+    if found == -1 { ret; }\n     // We found the cleanup and remove it\n-    sc_cx.cleanups = std::ivec::slice(sc_cx.cleanups, 0u, found as uint) +\n-        std::ivec::slice(sc_cx.cleanups, found as uint + 1u,\n-                         std::ivec::len(sc_cx.cleanups));\n+    sc_cx.cleanups =\n+        std::ivec::slice(sc_cx.cleanups, 0u, found as uint) +\n+            std::ivec::slice(sc_cx.cleanups, (found as uint) + 1u,\n+                             std::ivec::len(sc_cx.cleanups));\n }\n \n tag block_kind {\n \n+\n     // A scope block is a basic block created by translating a block { ... }\n     // the the source language.  Since these blocks create variable scope, any\n     // variables created in them that are still live at the end of the block\n     // must be dropped and cleaned up when the block ends.\n     SCOPE_BLOCK;\n \n+\n     // A basic block created from the body of a loop.  Contains pointers to\n     // which block to jump to in the case of \"continue\" or \"break\", with the\n     // \"continue\" block optional, because \"while\" and \"do while\" don't support\n     // \"continue\" (TODO: is this intentional?)\n     LOOP_SCOPE_BLOCK(option::t[@block_ctxt], @block_ctxt);\n \n+\n     // A non-scope block is a basic block created as a translation artifact\n     // from translating code that expresses conditional logic rather than by\n     // explicit { ... } block structure in the source language.  It's called a\n@@ -328,87 +331,86 @@ tag block_kind {\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n type block_ctxt =\n-    rec(\n-        // The BasicBlockRef returned from a call to\n-        // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic block to\n-        // the function pointed to by llfn.  We insert instructions into that\n-        // block by way of this block context.\n-        BasicBlockRef llbb,\n+    // The BasicBlockRef returned from a call to\n+    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic block to\n+    // the function pointed to by llfn.  We insert instructions into that\n+    // block by way of this block context.\n \n-        // The llvm::builder object serving as an interface to LLVM's\n-        // LLVMBuild* functions.\n-        builder build,\n+    // The llvm::builder object serving as an interface to LLVM's\n+    // LLVMBuild* functions.\n \n-        // The block pointing to this one in the function's digraph.\n-        block_parent parent,\n+    // The block pointing to this one in the function's digraph.\n \n-        // The 'kind' of basic block this is.\n-        block_kind kind,\n+    // The 'kind' of basic block this is.\n \n-        // A list of functions that run at the end of translating this block,\n-        // cleaning up any variables that were introduced in the block and\n-        // need to go out of scope at the end of it.\n-        mutable cleanup[] cleanups,\n+    // A list of functions that run at the end of translating this block,\n+    // cleaning up any variables that were introduced in the block and\n+    // need to go out of scope at the end of it.\n \n-        // The source span where this block comes from, for error reporting.\n-        span sp,\n+    // The source span where this block comes from, for error reporting.\n \n-        // The function context for the function to which this block is\n-        // attached.\n-        @fn_ctxt fcx);\n+    // The function context for the function to which this block is\n+    // attached.\n+    {llbb: BasicBlockRef,\n+     build: builder,\n+     parent: block_parent,\n+     kind: block_kind,\n+     mutable cleanups: cleanup[],\n+     sp: span,\n+     fcx: @fn_ctxt};\n \n // FIXME: we should be able to use option::t[@block_parent] here but\n // the infinite-tag check in rustboot gets upset.\n tag block_parent { parent_none; parent_some(@block_ctxt); }\n \n-type result = rec(@block_ctxt bcx, ValueRef val);\n-type result_t = rec(@block_ctxt bcx, ValueRef val, ty::t ty);\n+type result = {bcx: @block_ctxt, val: ValueRef};\n+type result_t = {bcx: @block_ctxt, val: ValueRef, ty: ty::t};\n \n-fn extend_path(@local_ctxt cx, &str name) -> @local_ctxt {\n-    ret @rec(path=cx.path + ~[name] with *cx);\n+fn extend_path(cx: @local_ctxt, name: &str) -> @local_ctxt {\n+    ret @{path: cx.path + ~[name] with *cx};\n }\n \n-fn rslt(@block_ctxt bcx, ValueRef val) -> result {\n-    ret rec(bcx=bcx, val=val);\n+fn rslt(bcx: @block_ctxt, val: ValueRef) -> result {\n+    ret {bcx: bcx, val: val};\n }\n \n-fn ty_str(type_names tn, TypeRef t) -> str {\n+fn ty_str(tn: type_names, t: TypeRef) -> str {\n     ret lib::llvm::type_to_str(tn, t);\n }\n \n-fn val_ty(ValueRef v) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n+fn val_ty(v: ValueRef) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n \n-fn val_str(type_names tn, ValueRef v) -> str { ret ty_str(tn, val_ty(v)); }\n+fn val_str(tn: type_names, v: ValueRef) -> str { ret ty_str(tn, val_ty(v)); }\n \n // Returns the nth element of the given LLVM structure type.\n-fn struct_elt(TypeRef llstructty, uint n) -> TypeRef {\n-    auto elt_count = llvm::LLVMCountStructElementTypes(llstructty);\n+fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n+    let elt_count = llvm::LLVMCountStructElementTypes(llstructty);\n     assert (n < elt_count);\n-    auto elt_tys = std::ivec::init_elt(T_nil(), elt_count);\n+    let elt_tys = std::ivec::init_elt(T_nil(), elt_count);\n     llvm::LLVMGetStructElementTypes(llstructty, std::ivec::to_ptr(elt_tys));\n     ret llvm::LLVMGetElementType(elt_tys.(n));\n }\n \n-fn find_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n-    if (cx.kind != NON_SCOPE_BLOCK) { ret cx; }\n-    alt (cx.parent) {\n-        case (parent_some(?b)) { ret find_scope_cx(b); }\n-        case (parent_none) {\n-            cx.fcx.lcx.ccx.sess.bug(\"trans::find_scope_cx() \" +\n-                                        \"called on parentless block_ctxt\");\n-        }\n+fn find_scope_cx(cx: &@block_ctxt) -> @block_ctxt {\n+    if cx.kind != NON_SCOPE_BLOCK { ret cx; }\n+    alt cx.parent {\n+      parent_some(b) { ret find_scope_cx(b); }\n+      parent_none. {\n+        cx.fcx.lcx.ccx.sess.bug(\"trans::find_scope_cx() \" +\n+                                    \"called on parentless block_ctxt\");\n+      }\n     }\n }\n \n // Accessors\n // TODO: When we have overloading, simplify these names!\n \n-fn bcx_tcx(&@block_ctxt bcx) -> ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n-fn bcx_ccx(&@block_ctxt bcx) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n-fn bcx_lcx(&@block_ctxt bcx) -> @local_ctxt { ret bcx.fcx.lcx; }\n-fn bcx_fcx(&@block_ctxt bcx) -> @fn_ctxt { ret bcx.fcx; }\n-fn lcx_ccx(&@local_ctxt lcx) -> @crate_ctxt { ret lcx.ccx; }\n-fn ccx_tcx(&@crate_ctxt ccx) -> ty::ctxt { ret ccx.tcx; }\n+fn bcx_tcx(bcx: &@block_ctxt) -> ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n+fn bcx_ccx(bcx: &@block_ctxt) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n+fn bcx_lcx(bcx: &@block_ctxt) -> @local_ctxt { ret bcx.fcx.lcx; }\n+fn bcx_fcx(bcx: &@block_ctxt) -> @fn_ctxt { ret bcx.fcx; }\n+fn lcx_ccx(lcx: &@local_ctxt) -> @crate_ctxt { ret lcx.ccx; }\n+fn ccx_tcx(ccx: &@crate_ctxt) -> ty::ctxt { ret ccx.tcx; }\n \n // LLVM type constructors.\n fn T_void() -> TypeRef {\n@@ -467,126 +469,130 @@ fn T_size_t() -> TypeRef {\n     ret T_i32();\n }\n \n-fn T_fn(&TypeRef[] inputs, TypeRef output) -> TypeRef {\n+fn T_fn(inputs: &TypeRef[], output: TypeRef) -> TypeRef {\n     ret llvm::LLVMFunctionType(output, std::ivec::to_ptr(inputs),\n                                std::ivec::len[TypeRef](inputs), False);\n }\n \n-fn T_fn_pair(&crate_ctxt cx, TypeRef tfn) -> TypeRef {\n+fn T_fn_pair(cx: &crate_ctxt, tfn: TypeRef) -> TypeRef {\n     ret T_struct(~[T_ptr(tfn), T_opaque_closure_ptr(cx)]);\n }\n \n-fn T_ptr(TypeRef t) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n+fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n \n-fn T_struct(&TypeRef[] elts) -> TypeRef {\n+fn T_struct(elts: &TypeRef[]) -> TypeRef {\n     ret llvm::LLVMStructType(std::ivec::to_ptr(elts), std::ivec::len(elts),\n                              False);\n }\n \n-fn T_named_struct(&str name) -> TypeRef {\n-    auto c = llvm::LLVMGetGlobalContext();\n+fn T_named_struct(name: &str) -> TypeRef {\n+    let c = llvm::LLVMGetGlobalContext();\n     ret llvm::LLVMStructCreateNamed(c, str::buf(name));\n }\n \n-fn set_struct_body(TypeRef t, &TypeRef[] elts) {\n+fn set_struct_body(t: TypeRef, elts: &TypeRef[]) {\n     llvm::LLVMStructSetBody(t, std::ivec::to_ptr(elts), std::ivec::len(elts),\n                             False);\n }\n \n fn T_empty_struct() -> TypeRef { ret T_struct(~[]); }\n \n fn T_rust_object() -> TypeRef {\n-    auto t = T_named_struct(\"rust_object\");\n-    auto e = T_ptr(T_empty_struct());\n-    set_struct_body(t, ~[e,e]);\n+    let t = T_named_struct(\"rust_object\");\n+    let e = T_ptr(T_empty_struct());\n+    set_struct_body(t, ~[e, e]);\n     ret t;\n }\n \n fn T_task() -> TypeRef {\n-    auto t = T_named_struct(\"task\");\n-\n-    auto elems = ~[T_int(), // Refcount\n-                   T_int(), // Delegate pointer\n-                   T_int(), // Stack segment pointer\n-                   T_int(), // Runtime SP\n-                   T_int(), // Rust SP\n-                   T_int(), // GC chain\n-\n-                   T_int(), // Domain pointer\n-                            // Crate cache pointer\n-                   T_int()];\n+    let t = T_named_struct(\"task\");\n+\n+    let  // Refcount\n+         // Delegate pointer\n+         // Stack segment pointer\n+         // Runtime SP\n+         // Rust SP\n+         // GC chain\n+\n+         // Domain pointer\n+         // Crate cache pointer\n+         elems =\n+        ~[T_int(), T_int(), T_int(), T_int(), T_int(), T_int(), T_int(),\n+          T_int()];\n     set_struct_body(t, elems);\n     ret t;\n }\n \n-fn T_tydesc_field(&crate_ctxt cx, int field) -> TypeRef {\n+fn T_tydesc_field(cx: &crate_ctxt, field: int) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n-    let TypeRef[] tydesc_elts =\n+    let tydesc_elts: TypeRef[] =\n         std::ivec::init_elt[TypeRef](T_nil(), abi::n_tydesc_fields as uint);\n     llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n                                     std::ivec::to_ptr[TypeRef](tydesc_elts));\n-    auto t = llvm::LLVMGetElementType(tydesc_elts.(field));\n+    let t = llvm::LLVMGetElementType(tydesc_elts.(field));\n     ret t;\n }\n \n-fn T_glue_fn(&crate_ctxt cx) -> TypeRef {\n-    auto s = \"glue_fn\";\n-    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n-    auto t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n+fn T_glue_fn(cx: &crate_ctxt) -> TypeRef {\n+    let s = \"glue_fn\";\n+    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n+    let t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n-fn T_dtor(&@crate_ctxt ccx, &span sp) -> TypeRef {\n-    ret type_of_fn_full(ccx, sp, ast::proto_fn, true,\n-                        ~[], ty::mk_nil(ccx.tcx), 0u);\n+fn T_dtor(ccx: &@crate_ctxt, sp: &span) -> TypeRef {\n+    ret type_of_fn_full(ccx, sp, ast::proto_fn, true, ~[],\n+                        ty::mk_nil(ccx.tcx), 0u);\n }\n \n-fn T_cmp_glue_fn(&crate_ctxt cx) -> TypeRef {\n-    auto s = \"cmp_glue_fn\";\n-    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n-    auto t = T_tydesc_field(cx, abi::tydesc_field_cmp_glue);\n+fn T_cmp_glue_fn(cx: &crate_ctxt) -> TypeRef {\n+    let s = \"cmp_glue_fn\";\n+    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n+    let t = T_tydesc_field(cx, abi::tydesc_field_cmp_glue);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n-fn T_tydesc(TypeRef taskptr_type) -> TypeRef {\n-    auto tydesc = T_named_struct(\"tydesc\");\n-    auto tydescpp = T_ptr(T_ptr(tydesc));\n-    auto pvoid = T_ptr(T_i8());\n-    auto glue_fn_ty =\n+fn T_tydesc(taskptr_type: TypeRef) -> TypeRef {\n+    let tydesc = T_named_struct(\"tydesc\");\n+    let tydescpp = T_ptr(T_ptr(tydesc));\n+    let pvoid = T_ptr(T_i8());\n+    let glue_fn_ty =\n         T_ptr(T_fn(~[T_ptr(T_nil()), taskptr_type, T_ptr(T_nil()), tydescpp,\n                      pvoid], T_void()));\n-    auto cmp_glue_fn_ty =\n+    let cmp_glue_fn_ty =\n         T_ptr(T_fn(~[T_ptr(T_i1()), taskptr_type, T_ptr(T_nil()), tydescpp,\n                      pvoid, pvoid, T_i8()], T_void()));\n \n-    auto elems = ~[tydescpp,   // first_param\n-                   T_int(),    // size\n-                   T_int(),    // align\n-                   glue_fn_ty, // copy_glue\n-                   glue_fn_ty, // drop_glue\n-                   glue_fn_ty, // free_glue\n-                   glue_fn_ty, // sever_glue\n-                   glue_fn_ty, // mark_glue\n-                   glue_fn_ty, // obj_drop_glue\n-                   glue_fn_ty, // is_stateful\n-                   cmp_glue_fn_ty];\n+    let  // first_param\n+         // size\n+         // align\n+         // copy_glue\n+         // drop_glue\n+         // free_glue\n+         // sever_glue\n+         // mark_glue\n+         // obj_drop_glue\n+         // is_stateful\n+        elems =\n+        ~[tydescpp, T_int(), T_int(), glue_fn_ty, glue_fn_ty, glue_fn_ty,\n+          glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty, cmp_glue_fn_ty];\n     set_struct_body(tydesc, elems);\n     ret tydesc;\n }\n \n-fn T_array(TypeRef t, uint n) -> TypeRef { ret llvm::LLVMArrayType(t, n); }\n+fn T_array(t: TypeRef, n: uint) -> TypeRef { ret llvm::LLVMArrayType(t, n); }\n \n-fn T_vec(TypeRef t) -> TypeRef {\n+fn T_vec(t: TypeRef) -> TypeRef {\n     ret T_struct(~[T_int(), // Refcount\n                    T_int(), // Alloc\n                    T_int(), // Fill\n \n                    T_int(), // Pad\n-                           // Body elements\n-                            T_array(t, 0u)]);\n+                            // Body elements\n+                             T_array(t, 0u)]);\n }\n \n fn T_opaque_vec_ptr() -> TypeRef { ret T_ptr(T_vec(T_int())); }\n@@ -595,7 +601,7 @@ fn T_opaque_vec_ptr() -> TypeRef { ret T_ptr(T_vec(T_int())); }\n // Interior vector.\n //\n // TODO: Support user-defined vector sizes.\n-fn T_ivec(TypeRef t) -> TypeRef {\n+fn T_ivec(t: TypeRef) -> TypeRef {\n     ret T_struct(~[T_int(), // Length (\"fill\"; if zero, heapified)\n                    T_int(), // Alloc\n                    T_array(t, abi::ivec_default_length)]); // Body elements\n@@ -611,7 +617,7 @@ fn T_opaque_ivec() -> TypeRef {\n \n }\n \n-fn T_ivec_heap_part(TypeRef t) -> TypeRef {\n+fn T_ivec_heap_part(t: TypeRef) -> TypeRef {\n     ret T_struct(~[T_int(), // Real length\n                    T_array(t, 0u)]); // Body elements\n \n@@ -620,7 +626,7 @@ fn T_ivec_heap_part(TypeRef t) -> TypeRef {\n \n // Interior vector on the heap, also known as the \"stub\". Cast to this when\n // the allocated length (second element of T_ivec above) is zero.\n-fn T_ivec_heap(TypeRef t) -> TypeRef {\n+fn T_ivec_heap(t: TypeRef) -> TypeRef {\n     ret T_struct(~[T_int(), // Length (zero)\n                    T_int(), // Alloc\n                    T_ptr(T_ivec_heap_part(t))]); // Pointer\n@@ -642,34 +648,34 @@ fn T_opaque_ivec_heap() -> TypeRef {\n \n fn T_str() -> TypeRef { ret T_vec(T_i8()); }\n \n-fn T_box(TypeRef t) -> TypeRef { ret T_struct(~[T_int(), t]); }\n+fn T_box(t: TypeRef) -> TypeRef { ret T_struct(~[T_int(), t]); }\n \n-fn T_port(TypeRef t) -> TypeRef {\n+fn T_port(t: TypeRef) -> TypeRef {\n     ret T_struct(~[T_int()]); // Refcount\n \n }\n \n-fn T_chan(TypeRef t) -> TypeRef {\n+fn T_chan(t: TypeRef) -> TypeRef {\n     ret T_struct(~[T_int()]); // Refcount\n \n }\n \n-fn T_taskptr(&crate_ctxt cx) -> TypeRef { ret T_ptr(cx.task_type); }\n+fn T_taskptr(cx: &crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n \n \n // This type must never be used directly; it must always be cast away.\n-fn T_typaram(&type_names tn) -> TypeRef {\n-    auto s = \"typaram\";\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n-    auto t = T_i8();\n+fn T_typaram(tn: &type_names) -> TypeRef {\n+    let s = \"typaram\";\n+    if tn.name_has_type(s) { ret tn.get_type(s); }\n+    let t = T_i8();\n     tn.associate(s, t);\n     ret t;\n }\n \n-fn T_typaram_ptr(&type_names tn) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n+fn T_typaram_ptr(tn: &type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n \n-fn T_closure_ptr(&crate_ctxt cx, TypeRef lltarget_ty, TypeRef llbindings_ty,\n-                 uint n_ty_params) -> TypeRef {\n+fn T_closure_ptr(cx: &crate_ctxt, lltarget_ty: TypeRef,\n+                 llbindings_ty: TypeRef, n_ty_params: uint) -> TypeRef {\n     // NB: keep this in sync with code in trans_bind; we're making\n     // an LLVM typeref structure that has the same \"shape\" as the ty::t\n     // it constructs.\n@@ -679,64 +685,62 @@ fn T_closure_ptr(&crate_ctxt cx, TypeRef lltarget_ty, TypeRef llbindings_ty,\n                                T_captured_tydescs(cx, n_ty_params)])));\n }\n \n-fn T_opaque_closure_ptr(&crate_ctxt cx) -> TypeRef {\n-    auto s = \"*closure\";\n-    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n-    auto t =\n-        T_closure_ptr(cx,\n-                      T_struct(~[T_ptr(T_nil()), T_ptr(T_nil())]),\n-                      T_nil(),\n-                      0u);\n+fn T_opaque_closure_ptr(cx: &crate_ctxt) -> TypeRef {\n+    let s = \"*closure\";\n+    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n+    let t =\n+        T_closure_ptr(cx, T_struct(~[T_ptr(T_nil()), T_ptr(T_nil())]),\n+                      T_nil(), 0u);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n-fn T_tag(&type_names tn, uint size) -> TypeRef {\n-    auto s = \"tag_\" + uint::to_str(size, 10u);\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n-    auto t = T_struct(~[T_int(), T_array(T_i8(), size)]);\n+fn T_tag(tn: &type_names, size: uint) -> TypeRef {\n+    let s = \"tag_\" + uint::to_str(size, 10u);\n+    if tn.name_has_type(s) { ret tn.get_type(s); }\n+    let t = T_struct(~[T_int(), T_array(T_i8(), size)]);\n     tn.associate(s, t);\n     ret t;\n }\n \n-fn T_opaque_tag(&type_names tn) -> TypeRef {\n-    auto s = \"opaque_tag\";\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n-    auto t = T_struct(~[T_int(), T_i8()]);\n+fn T_opaque_tag(tn: &type_names) -> TypeRef {\n+    let s = \"opaque_tag\";\n+    if tn.name_has_type(s) { ret tn.get_type(s); }\n+    let t = T_struct(~[T_int(), T_i8()]);\n     tn.associate(s, t);\n     ret t;\n }\n \n-fn T_opaque_tag_ptr(&type_names tn) -> TypeRef {\n+fn T_opaque_tag_ptr(tn: &type_names) -> TypeRef {\n     ret T_ptr(T_opaque_tag(tn));\n }\n \n-fn T_captured_tydescs(&crate_ctxt cx, uint n) -> TypeRef {\n+fn T_captured_tydescs(cx: &crate_ctxt, n: uint) -> TypeRef {\n     ret T_struct(std::ivec::init_elt[TypeRef](T_ptr(cx.tydesc_type), n));\n }\n \n-fn T_obj_ptr(&crate_ctxt cx, uint n_captured_tydescs) -> TypeRef {\n+fn T_obj_ptr(cx: &crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n     // This function is not publicly exposed because it returns an incomplete\n     // type. The dynamically-sized fields follow the captured tydescs.\n \n-    fn T_obj(&crate_ctxt cx, uint n_captured_tydescs) -> TypeRef {\n+    fn T_obj(cx: &crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n         ret T_struct(~[T_ptr(cx.tydesc_type),\n                        T_captured_tydescs(cx, n_captured_tydescs)]);\n     }\n     ret T_ptr(T_box(T_obj(cx, n_captured_tydescs)));\n }\n \n-fn T_opaque_obj_ptr(&crate_ctxt cx) -> TypeRef { ret T_obj_ptr(cx, 0u); }\n+fn T_opaque_obj_ptr(cx: &crate_ctxt) -> TypeRef { ret T_obj_ptr(cx, 0u); }\n \n fn T_opaque_port_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n \n fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n \n \n // LLVM constant constructors.\n-fn C_null(TypeRef t) -> ValueRef { ret llvm::LLVMConstNull(t); }\n+fn C_null(t: TypeRef) -> ValueRef { ret llvm::LLVMConstNull(t); }\n \n-fn C_integral(TypeRef t, uint u, Bool sign_extend) -> ValueRef {\n+fn C_integral(t: TypeRef, u: uint, sign_extend: Bool) -> ValueRef {\n     // FIXME: We can't use LLVM::ULongLong with our existing minimal native\n     // API, which only knows word-sized args.\n     //\n@@ -746,11 +750,11 @@ fn C_integral(TypeRef t, uint u, Bool sign_extend) -> ValueRef {\n     ret llvm::LLVMRustConstSmallInt(t, u, sign_extend);\n }\n \n-fn C_float(&str s) -> ValueRef {\n+fn C_float(s: &str) -> ValueRef {\n     ret llvm::LLVMConstRealOfString(T_float(), str::buf(s));\n }\n \n-fn C_floating(&str s, TypeRef t) -> ValueRef {\n+fn C_floating(s: &str, t: TypeRef) -> ValueRef {\n     ret llvm::LLVMConstRealOfString(t, str::buf(s));\n }\n \n@@ -760,24 +764,24 @@ fn C_nil() -> ValueRef {\n     ret C_integral(T_i1(), 0u, False);\n }\n \n-fn C_bool(bool b) -> ValueRef {\n-    if (b) {\n+fn C_bool(b: bool) -> ValueRef {\n+    if b {\n         ret C_integral(T_bool(), 1u, False);\n     } else { ret C_integral(T_bool(), 0u, False); }\n }\n \n-fn C_int(int i) -> ValueRef { ret C_integral(T_int(), i as uint, True); }\n+fn C_int(i: int) -> ValueRef { ret C_integral(T_int(), i as uint, True); }\n \n-fn C_uint(uint i) -> ValueRef { ret C_integral(T_int(), i, False); }\n+fn C_uint(i: uint) -> ValueRef { ret C_integral(T_int(), i, False); }\n \n-fn C_u8(uint i) -> ValueRef { ret C_integral(T_i8(), i, False); }\n+fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i, False); }\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-fn C_cstr(&@crate_ctxt cx, &str s) -> ValueRef {\n-    auto sc = llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n-    auto g =\n+fn C_cstr(cx: &@crate_ctxt, s: &str) -> ValueRef {\n+    let sc = llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n+    let g =\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(sc),\n                             str::buf(cx.names.next(\"str\")));\n     llvm::LLVMSetInitializer(g, sc);\n@@ -788,15 +792,16 @@ fn C_cstr(&@crate_ctxt cx, &str s) -> ValueRef {\n \n \n // A rust boxed-and-length-annotated string.\n-fn C_str(&@crate_ctxt cx, &str s) -> ValueRef {\n-    auto len = str::byte_len(s);\n-    auto box =\n-        C_struct(~[C_int(abi::const_refcount as int),\n-                   C_int(len + 1u as int), // 'alloc'\n-                   C_int(len + 1u as int), // 'fill'\n-                   C_int(0), // 'pad'\n+fn C_str(cx: &@crate_ctxt, s: &str) -> ValueRef {\n+    let len = str::byte_len(s);\n+    let  // 'alloc'\n+         // 'fill'\n+         // 'pad'\n+        box =\n+        C_struct(~[C_int(abi::const_refcount as int), C_int(len + 1u as int),\n+                   C_int(len + 1u as int), C_int(0),\n                    llvm::LLVMConstString(str::buf(s), len, False)]);\n-    auto g =\n+    let g =\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(box),\n                             str::buf(cx.names.next(\"str\")));\n     llvm::LLVMSetInitializer(g, box);\n@@ -806,29 +811,29 @@ fn C_str(&@crate_ctxt cx, &str s) -> ValueRef {\n }\n \n // Returns a Plain Old LLVM String:\n-fn C_postr(&str s) -> ValueRef {\n+fn C_postr(s: &str) -> ValueRef {\n     ret llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n }\n \n-fn C_zero_byte_arr(uint size) -> ValueRef {\n-    auto i = 0u;\n-    let ValueRef[] elts = ~[];\n-    while (i < size) { elts += ~[C_u8(0u)]; i += 1u; }\n+fn C_zero_byte_arr(size: uint) -> ValueRef {\n+    let i = 0u;\n+    let elts: ValueRef[] = ~[];\n+    while i < size { elts += ~[C_u8(0u)]; i += 1u; }\n     ret llvm::LLVMConstArray(T_i8(), std::ivec::to_ptr(elts),\n                              std::ivec::len(elts));\n }\n \n-fn C_struct(&ValueRef[] elts) -> ValueRef {\n+fn C_struct(elts: &ValueRef[]) -> ValueRef {\n     ret llvm::LLVMConstStruct(std::ivec::to_ptr(elts), std::ivec::len(elts),\n                               False);\n }\n \n-fn C_named_struct(TypeRef T, &ValueRef[] elts) -> ValueRef {\n+fn C_named_struct(T: TypeRef, elts: &ValueRef[]) -> ValueRef {\n     ret llvm::LLVMConstNamedStruct(T, std::ivec::to_ptr(elts),\n                                    std::ivec::len(elts));\n }\n \n-fn C_array(TypeRef ty, &ValueRef[] elts) -> ValueRef {\n+fn C_array(ty: TypeRef, elts: &ValueRef[]) -> ValueRef {\n     ret llvm::LLVMConstArray(ty, std::ivec::to_ptr(elts),\n                              std::ivec::len(elts));\n-}\n+}\n\\ No newline at end of file"}, {"sha": "4e659349ef0d7174c7391f8793e488916817a3df", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 286, "deletions": 272, "changes": 558, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -29,22 +29,22 @@ import type_of_node = trans::node_id_type;\n \n // LLVM utilities\n \n-fn llelement_type(TypeRef llty) -> TypeRef {\n+fn llelement_type(llty: TypeRef) -> TypeRef {\n     lib::llvm::llvm::LLVMGetElementType(llty)\n }\n \n-fn llalign_of(&@crate_ctxt ccx, TypeRef llty) -> uint {\n+fn llalign_of(ccx: &@crate_ctxt, llty: TypeRef) -> uint {\n     ret llvm::LLVMPreferredAlignmentOfType(ccx.td.lltd, llty);\n }\n \n-fn llsize_of(&@crate_ctxt ccx, TypeRef llty) -> uint {\n+fn llsize_of(ccx: &@crate_ctxt, llty: TypeRef) -> uint {\n     ret llvm::LLVMStoreSizeOfType(ccx.td.lltd, llty);\n }\n \n-fn mk_const(&@crate_ctxt ccx, &str name, bool exported, ValueRef llval)\n-        -> ValueRef {\n-    auto llglobal = llvm::LLVMAddGlobal(ccx.llmod, tc::val_ty(llval),\n-                                        str::buf(name));\n+fn mk_const(ccx: &@crate_ctxt, name: &str, exported: bool, llval: ValueRef) ->\n+   ValueRef {\n+    let llglobal =\n+        llvm::LLVMAddGlobal(ccx.llmod, tc::val_ty(llval), str::buf(name));\n \n     llvm::LLVMSetInitializer(llglobal, llval);\n     llvm::LLVMSetGlobalConstant(llglobal, LLTrue);\n@@ -60,10 +60,10 @@ fn mk_const(&@crate_ctxt ccx, &str name, bool exported, ValueRef llval)\n \n // Type utilities\n \n-fn size_of(&@crate_ctxt ccx, &span sp, ty::t t) -> uint {\n+fn size_of(ccx: &@crate_ctxt, sp: &span, t: ty::t) -> uint {\n     if ty::type_has_dynamic_size(ccx.tcx, t) {\n         ccx.sess.bug(\"trans_dps::size_of() called on a type with dynamic \" +\n-                     \"size\");\n+                         \"size\");\n     }\n     ret llsize_of(ccx, trans::type_of_inner(ccx, sp, t));\n }\n@@ -72,126 +72,131 @@ fn size_of(&@crate_ctxt ccx, &span sp, ty::t t) -> uint {\n // Destination utilities\n \n tag dest {\n-    dst_nil;                                // Unit destination; ignore.\n-    dst_imm(@mutable option[ValueRef]);     // Fill with an immediate value.\n-    dst_alias(@mutable option[ValueRef]);   // Fill with an alias pointer.\n-    dst_copy(ValueRef);                     // Copy to the given address.\n-    dst_move(ValueRef);                     // Move to the given address.\n+    dst_nil; // Unit destination; ignore.\n+\n+    dst_imm(@mutable option[ValueRef]); // Fill with an immediate value.\n+\n+    dst_alias(@mutable option[ValueRef]); // Fill with an alias pointer.\n+\n+    dst_copy(ValueRef); // Copy to the given address.\n+\n+    dst_move(ValueRef); // Move to the given address.\n }\n \n-fn dest_imm(&ty::ctxt tcx, ty::t t) -> dest {\n+fn dest_imm(tcx: &ty::ctxt, t: ty::t) -> dest {\n     if ty::type_is_nil(tcx, t) { dst_nil } else { dst_imm(@mutable none) }\n }\n \n-fn dest_alias(&ty::ctxt tcx, ty::t t) -> dest {\n+fn dest_alias(tcx: &ty::ctxt, t: ty::t) -> dest {\n     if ty::type_is_nil(tcx, t) { dst_nil } else { dst_alias(@mutable none) }\n }\n \n-fn dest_copy(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest {\n+fn dest_copy(tcx: &ty::ctxt, llptr: ValueRef, t: ty::t) -> dest {\n     if ty::type_is_nil(tcx, t) { dst_nil } else { dst_copy(llptr) }\n }\n \n-fn dest_move(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest {\n+fn dest_move(tcx: &ty::ctxt, llptr: ValueRef, t: ty::t) -> dest {\n     if ty::type_is_nil(tcx, t) { dst_nil } else { dst_move(llptr) }\n }\n \n // Invariant: the type of the destination must be structural (non-immediate).\n-fn dest_ptr(&dest dest) -> ValueRef {\n-    alt (dest) {\n-      dst_nil { fail \"nil dest in dest_ptr\" }\n+fn dest_ptr(dest: &dest) -> ValueRef {\n+    alt dest {\n+      dst_nil. { fail \"nil dest in dest_ptr\" }\n       dst_imm(_) { fail \"immediate dest in dest_ptr\" }\n-      dst_alias(?box) {\n-        alt (*box) {\n-          none { fail \"alias wasn't filled in prior to dest_ptr\" }\n-          some(?llval) { llval }\n+      dst_alias(box) {\n+        alt *box {\n+          none. { fail \"alias wasn't filled in prior to dest_ptr\" }\n+          some(llval) { llval }\n         }\n       }\n-      dst_copy(?llptr) { llptr }\n-      dst_move(?llptr) { llptr }\n+      dst_copy(llptr) { llptr }\n+      dst_move(llptr) { llptr }\n     }\n }\n \n-fn dest_llval(&dest dest) -> ValueRef {\n-    alt (dest) {\n-      dst_nil { ret tc::C_nil(); }\n-      dst_imm(?box) {\n-        alt (*box) {\n-          none { fail \"immediate wasn't filled in prior to dest_llval\"; }\n-          some(?llval) { ret llval; }\n+fn dest_llval(dest: &dest) -> ValueRef {\n+    alt dest {\n+      dst_nil. { ret tc::C_nil(); }\n+      dst_imm(box) {\n+        alt *box {\n+          none. { fail \"immediate wasn't filled in prior to dest_llval\"; }\n+          some(llval) { ret llval; }\n         }\n       }\n-      dst_alias(?box) {\n-        alt (*box) {\n-          none { fail \"alias wasn't filled in prior to dest_llval\"; }\n-          some(?llval) { ret llval; }\n+      dst_alias(box) {\n+        alt *box {\n+          none. { fail \"alias wasn't filled in prior to dest_llval\"; }\n+          some(llval) { ret llval; }\n         }\n       }\n-      dst_copy(?llptr) { ret llptr; }\n-      dst_move(?llptr) { ret llptr; }\n+      dst_copy(llptr) { ret llptr; }\n+      dst_move(llptr) { ret llptr; }\n     }\n }\n \n-fn dest_is_alias(&dest dest) -> bool {\n-    alt (dest) { dst_alias(_) { true } _ { false } }\n+fn dest_is_alias(dest: &dest) -> bool {\n+    alt dest { dst_alias(_) { true } _ { false } }\n }\n \n \n // Common operations\n \n-fn memmove(&@block_ctxt bcx, ValueRef lldestptr, ValueRef llsrcptr,\n-           ValueRef llsz) {\n-    auto lldestty = llelement_type(tc::val_ty(lldestptr));\n-    auto llsrcty = llelement_type(tc::val_ty(llsrcptr));\n-    auto dest_align = llalign_of(bcx_ccx(bcx), lldestty);\n-    auto src_align = llalign_of(bcx_ccx(bcx), llsrcty);\n-    auto align = uint::min(dest_align, src_align);\n-    auto llfn = bcx_ccx(bcx).intrinsics.get(\"llvm.memmove.p0i8.p0i8.i32\");\n-    auto lldestptr_i8 = bcx.build.PointerCast(lldestptr,\n-                                              tc::T_ptr(tc::T_i8()));\n-    auto llsrcptr_i8 = bcx.build.PointerCast(llsrcptr,\n-                                             tc::T_ptr(tc::T_i8()));\n-    bcx.build.Call(llfn, ~[lldestptr_i8, llsrcptr_i8, llsz, tc::C_uint(align),\n-                           tc::C_bool(false)]);\n+fn memmove(bcx: &@block_ctxt, lldestptr: ValueRef, llsrcptr: ValueRef,\n+           llsz: ValueRef) {\n+    let lldestty = llelement_type(tc::val_ty(lldestptr));\n+    let llsrcty = llelement_type(tc::val_ty(llsrcptr));\n+    let dest_align = llalign_of(bcx_ccx(bcx), lldestty);\n+    let src_align = llalign_of(bcx_ccx(bcx), llsrcty);\n+    let align = uint::min(dest_align, src_align);\n+    let llfn = bcx_ccx(bcx).intrinsics.get(\"llvm.memmove.p0i8.p0i8.i32\");\n+    let lldestptr_i8 =\n+        bcx.build.PointerCast(lldestptr, tc::T_ptr(tc::T_i8()));\n+    let llsrcptr_i8 = bcx.build.PointerCast(llsrcptr, tc::T_ptr(tc::T_i8()));\n+    bcx.build.Call(llfn,\n+                   ~[lldestptr_i8, llsrcptr_i8, llsz, tc::C_uint(align),\n+                     tc::C_bool(false)]);\n }\n \n // If \"cast\" is true, casts dest appropriately before the store.\n-fn store_imm(&@block_ctxt bcx, &dest dest, ValueRef llsrc, bool cast)\n-        -> @block_ctxt {\n-    alt (dest) {\n-      dst_nil { /* no-op */ }\n-      dst_imm(?box) {\n+fn store_imm(bcx: &@block_ctxt, dest: &dest, llsrc: ValueRef, cast: bool) ->\n+   @block_ctxt {\n+    alt dest {\n+      dst_nil. {/* no-op */ }\n+      dst_imm(box) {\n         assert (std::option::is_none(*box));\n         *box = some(llsrc);\n       }\n-      dst_alias(?box) {\n+      dst_alias(box) {\n         bcx_ccx(bcx).sess.unimpl(\"dst_alias spill in store_imm\");\n       }\n-      dst_copy(?lldestptr_orig) | dst_move(?lldestptr_orig) {\n-        auto lldestptr = lldestptr_orig;\n+      dst_copy(lldestptr_orig) | dst_move(lldestptr_orig) {\n+        let lldestptr = lldestptr_orig;\n         if cast {\n-            lldestptr = bcx.build.PointerCast(lldestptr,\n-                                              tc::T_ptr(lltype_of(llsrc)));\n+            lldestptr =\n+                bcx.build.PointerCast(lldestptr, tc::T_ptr(lltype_of(llsrc)));\n         }\n         bcx.build.Store(llsrc, lldestptr);\n       }\n     }\n     ret bcx;\n }\n \n-fn store_ptr(&@block_ctxt bcx, &dest dest, ValueRef llsrcptr) -> @block_ctxt {\n-    alt (dest) {\n-      dst_nil { /* no-op */ }\n-      dst_imm(?box) {\n+fn store_ptr(bcx: &@block_ctxt, dest: &dest, llsrcptr: ValueRef) ->\n+   @block_ctxt {\n+    alt dest {\n+      dst_nil. {/* no-op */ }\n+      dst_imm(box) {\n         assert (std::option::is_none(*box));\n         *box = some(bcx.build.Load(llsrcptr));\n       }\n-      dst_alias(?box) {\n+      dst_alias(box) {\n         assert (std::option::is_none(*box));\n         *box = some(llsrcptr);\n       }\n-      dst_copy(?lldestptr) | dst_move(?lldestptr) {\n-        auto llsrcty = llelement_type(tc::val_ty(llsrcptr));\n-        auto llsz = tc::C_uint(llsize_of(bcx_ccx(bcx), llsrcty));\n+      dst_copy(lldestptr) | dst_move(lldestptr) {\n+        let llsrcty = llelement_type(tc::val_ty(llsrcptr));\n+        let llsz = tc::C_uint(llsize_of(bcx_ccx(bcx), llsrcty));\n         memmove(bcx, lldestptr, llsrcptr, llsz);\n         ret bcx;\n       }\n@@ -205,219 +210,224 @@ fn store_ptr(&@block_ctxt bcx, &dest dest, ValueRef llsrcptr) -> @block_ctxt {\n // TODO: This should *not* use destination-passing style, because doing so\n // makes callers incur an extra load.\n tag heap { hp_task; hp_shared; }\n-fn malloc(&@block_ctxt bcx, ValueRef lldest, heap heap,\n-          option[ValueRef] llcustom_size_opt) -> @block_ctxt {\n-    auto llptrty = llelement_type(lltype_of(lldest));\n-    auto llty = llelement_type(llptrty);\n+fn malloc(bcx: &@block_ctxt, lldest: ValueRef, heap: heap,\n+          llcustom_size_opt: option[ValueRef]) -> @block_ctxt {\n+    let llptrty = llelement_type(lltype_of(lldest));\n+    let llty = llelement_type(llptrty);\n \n-    auto lltydescptr = tc::C_null(tc::T_ptr(bcx_ccx(bcx).tydesc_type));\n+    let lltydescptr = tc::C_null(tc::T_ptr(bcx_ccx(bcx).tydesc_type));\n \n-    auto llsize;\n-    alt (llcustom_size_opt) {\n-      none { llsize = trans::llsize_of(llty); }\n-      some(?llcustom_size) { llsize = llcustom_size; }\n+    let llsize;\n+    alt llcustom_size_opt {\n+      none. { llsize = trans::llsize_of(llty); }\n+      some(llcustom_size) { llsize = llcustom_size; }\n     }\n \n-    auto llupcall;\n-    alt (heap) {\n-      hp_task { llupcall = bcx_ccx(bcx).upcalls.malloc; }\n-      hp_shared { llupcall = bcx_ccx(bcx).upcalls.shared_malloc; }\n+    let llupcall;\n+    alt heap {\n+      hp_task. { llupcall = bcx_ccx(bcx).upcalls.malloc; }\n+      hp_shared. { llupcall = bcx_ccx(bcx).upcalls.shared_malloc; }\n     }\n \n-    auto llresult = bcx.build.Call(llupcall, ~[bcx_fcx(bcx).lltaskptr, llsize,\n-                                               lltydescptr]);\n+    let llresult =\n+        bcx.build.Call(llupcall,\n+                       ~[bcx_fcx(bcx).lltaskptr, llsize, lltydescptr]);\n     llresult = bcx.build.PointerCast(llresult, llptrty);\n     bcx.build.Store(llresult, lldest);\n     ret bcx;\n }\n \n // If the supplied destination is an alias, spills to a temporary. Returns the\n // new destination.\n-fn spill_alias(&@block_ctxt cx, &dest dest, ty::t t)\n-        -> rec(@block_ctxt bcx, dest dest) {\n-    auto bcx = cx;\n-    alt (dest) {\n-      dst_alias(?box) {\n+fn spill_alias(cx: &@block_ctxt, dest: &dest, t: ty::t) ->\n+   {bcx: @block_ctxt, dest: dest} {\n+    let bcx = cx;\n+    alt dest {\n+      dst_alias(box) {\n         // TODO: Mark the alias as needing a cleanup.\n         assert (std::option::is_none(*box));\n-        auto r = trans::alloc_ty(cx, t);\n-        bcx = r.bcx; auto llptr = r.val;\n+        let r = trans::alloc_ty(cx, t);\n+        bcx = r.bcx;\n+        let llptr = r.val;\n         *box = some(llptr);\n-        ret rec(bcx=bcx, dest=dst_move(llptr));\n+        ret {bcx: bcx, dest: dst_move(llptr)};\n       }\n-      _ { ret rec(bcx=bcx, dest=dest); }\n+      _ { ret {bcx: bcx, dest: dest}; }\n     }\n }\n \n-fn mk_temp(&@block_ctxt cx, ty::t t) -> rec(@block_ctxt bcx, dest dest) {\n-    auto bcx = cx;\n-    if ty::type_is_nil(bcx_tcx(bcx), t) { ret rec(bcx=bcx, dest=dst_nil); }\n+fn mk_temp(cx: &@block_ctxt, t: ty::t) -> {bcx: @block_ctxt, dest: dest} {\n+    let bcx = cx;\n+    if ty::type_is_nil(bcx_tcx(bcx), t) { ret {bcx: bcx, dest: dst_nil}; }\n     if trans::type_is_immediate(bcx_ccx(bcx), t) {\n-        ret rec(bcx=bcx, dest=dst_imm(@mutable none));\n+        ret {bcx: bcx, dest: dst_imm(@mutable none)};\n     }\n \n-    auto r = trans::alloc_ty(cx, t);\n-    bcx = r.bcx; auto llptr = r.val;\n-    ret rec(bcx=bcx, dest=dst_copy(llptr));\n+    let r = trans::alloc_ty(cx, t);\n+    bcx = r.bcx;\n+    let llptr = r.val;\n+    ret {bcx: bcx, dest: dst_copy(llptr)};\n }\n \n \n // AST substructure translation, with destinations\n \n-fn trans_lit(&@block_ctxt cx, &dest dest, &ast::lit lit) -> @block_ctxt {\n-    auto bcx = cx;\n-    alt (lit.node) {\n-      ast::lit_str(?s, ast::sk_unique) {\n-        auto r = trans_lit_str_common(bcx_ccx(bcx), s, dest_is_alias(dest));\n-        auto llstackpart = r.stack; auto llheappartopt = r.heap;\n+fn trans_lit(cx: &@block_ctxt, dest: &dest, lit: &ast::lit) -> @block_ctxt {\n+    let bcx = cx;\n+    alt lit.node {\n+      ast::lit_str(s, ast::sk_unique.) {\n+        let r = trans_lit_str_common(bcx_ccx(bcx), s, dest_is_alias(dest));\n+        let llstackpart = r.stack;\n+        let llheappartopt = r.heap;\n         bcx = store_ptr(bcx, dest, llstackpart);\n-        alt (llheappartopt) {\n-          none { /* no-op */ }\n-          some(?llheappart) {\n-            auto lldestptrptr =\n+        alt llheappartopt {\n+          none. {/* no-op */ }\n+          some(llheappart) {\n+            let lldestptrptr =\n                 bcx.build.InBoundsGEP(dest_ptr(dest),\n                                       ~[tc::C_int(0),\n                                         tc::C_uint(abi::ivec_elt_elems)]);\n-            auto llheappartty = lltype_of(llheappart);\n+            let llheappartty = lltype_of(llheappart);\n             lldestptrptr =\n                 bcx.build.PointerCast(lldestptrptr,\n                                       tc::T_ptr(tc::T_ptr(llheappartty)));\n             malloc(bcx, lldestptrptr, hp_shared, none);\n-            auto lldestptr = bcx.build.Load(lldestptrptr);\n+            let lldestptr = bcx.build.Load(lldestptrptr);\n             store_ptr(bcx, dst_copy(lldestptr), llheappart);\n           }\n         }\n       }\n       _ {\n-        bcx = store_imm(bcx, dest, trans_lit_common(bcx_ccx(bcx), lit),\n-                        false);\n+        bcx =\n+            store_imm(bcx, dest, trans_lit_common(bcx_ccx(bcx), lit), false);\n       }\n     }\n \n     ret bcx;\n }\n \n-fn trans_binary(&@block_ctxt cx, &dest dest, &span sp, ast::binop op,\n-                &@ast::expr lhs, &@ast::expr rhs) -> @block_ctxt {\n-    auto bcx = cx;\n-    alt (op) {\n-      ast::add {\n-        bcx = trans_vec::trans_concat(bcx, dest, sp,\n-                                      ty::expr_ty(bcx_tcx(bcx), rhs), lhs,\n-                                      rhs);\n+fn trans_binary(cx: &@block_ctxt, dest: &dest, sp: &span, op: ast::binop,\n+                lhs: &@ast::expr, rhs: &@ast::expr) -> @block_ctxt {\n+    let bcx = cx;\n+    alt op {\n+      ast::add. {\n+        bcx =\n+            trans_vec::trans_concat(bcx, dest, sp,\n+                                    ty::expr_ty(bcx_tcx(bcx), rhs), lhs, rhs);\n       }\n-      // TODO: Many more to add here.\n     }\n+    // TODO: Many more to add here.\n     ret bcx;\n }\n \n-fn trans_log(&@block_ctxt cx, &span sp, int level, &@ast::expr expr)\n-        -> @block_ctxt {\n-    fn trans_log_level(&@local_ctxt lcx) -> ValueRef {\n-        auto modname = str::connect_ivec(lcx.module_path, \"::\");\n+fn trans_log(cx: &@block_ctxt, sp: &span, level: int, expr: &@ast::expr) ->\n+   @block_ctxt {\n+    fn trans_log_level(lcx: &@local_ctxt) -> ValueRef {\n+        let modname = str::connect_ivec(lcx.module_path, \"::\");\n \n-        if (lcx_ccx(lcx).module_data.contains_key(modname)) {\n+        if lcx_ccx(lcx).module_data.contains_key(modname) {\n             ret lcx_ccx(lcx).module_data.get(modname);\n         }\n \n-        auto s =\n+        let s =\n             link::mangle_internal_name_by_path_and_seq(lcx_ccx(lcx),\n                                                        lcx.module_path,\n                                                        \"loglevel\");\n-        auto lllevelptr = llvm::LLVMAddGlobal(lcx.ccx.llmod, tc::T_int(),\n-                                              str::buf(s));\n+        let lllevelptr =\n+            llvm::LLVMAddGlobal(lcx.ccx.llmod, tc::T_int(), str::buf(s));\n         llvm::LLVMSetGlobalConstant(lllevelptr, LLFalse);\n         llvm::LLVMSetInitializer(lllevelptr, tc::C_int(0));\n-        llvm::LLVMSetLinkage(lllevelptr, lib::llvm::LLVMInternalLinkage as\n-                             llvm::Linkage);\n+        llvm::LLVMSetLinkage(lllevelptr,\n+                             lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n         lcx_ccx(lcx).module_data.insert(modname, lllevelptr);\n         ret lllevelptr;\n     }\n \n     tag upcall_style { us_imm; us_imm_i32_zext; us_alias; us_alias_istr; }\n-    fn get_upcall(&@crate_ctxt ccx, &span sp, ty::t t)\n-            -> rec(ValueRef val, upcall_style st) {\n-        alt (ty::struct(ccx_tcx(ccx), t)) {\n-          ty::ty_machine(ast::ty_f32) {\n-            ret rec(val=ccx.upcalls.log_float, st=us_imm);\n+    fn get_upcall(ccx: &@crate_ctxt, sp: &span, t: ty::t) ->\n+       {val: ValueRef, st: upcall_style} {\n+        alt ty::struct(ccx_tcx(ccx), t) {\n+          ty::ty_machine(ast::ty_f32.) {\n+            ret {val: ccx.upcalls.log_float, st: us_imm};\n           }\n-          ty::ty_machine(ast::ty_f64) | ty::ty_float {\n+          ty::ty_machine(ast::ty_f64.) | ty::ty_float. {\n             // TODO: We have to spill due to legacy calling conventions that\n             // should probably be modernized.\n-            ret rec(val=ccx.upcalls.log_double, st=us_alias);\n-          }\n-          ty::ty_bool | ty::ty_machine(ast::ty_i8) |\n-                ty::ty_machine(ast::ty_i16) | ty::ty_machine(ast::ty_u8) |\n-                ty::ty_machine(ast::ty_u16) {\n-            ret rec(val=ccx.upcalls.log_int, st=us_imm_i32_zext);\n+            ret {val: ccx.upcalls.log_double, st: us_alias};\n           }\n-          ty::ty_int | ty::ty_machine(ast::ty_i32) |\n-                ty::ty_machine(ast::ty_u32) {\n-            ret rec(val=ccx.upcalls.log_int, st=us_imm);\n+          ty::ty_bool. | ty::ty_machine(ast::ty_i8.) |\n+          ty::ty_machine(ast::ty_i16.) | ty::ty_machine(ast::ty_u8.) |\n+          ty::ty_machine(ast::ty_u16.) {\n+            ret {val: ccx.upcalls.log_int, st: us_imm_i32_zext};\n           }\n-          ty::ty_istr {\n-            ret rec(val=ccx.upcalls.log_istr, st=us_alias_istr);\n+          ty::ty_int. | ty::ty_machine(ast::ty_i32.) |\n+          ty::ty_machine(ast::ty_u32.) {\n+            ret {val: ccx.upcalls.log_int, st: us_imm};\n           }\n+          ty::ty_istr. { ret {val: ccx.upcalls.log_istr, st: us_alias_istr}; }\n           _ {\n-            ccx.sess.span_unimpl(sp, \"logging for values of type \" +\n-                                 ppaux::ty_to_str(ccx_tcx(ccx), t));\n+            ccx.sess.span_unimpl(sp,\n+                                 \"logging for values of type \" +\n+                                     ppaux::ty_to_str(ccx_tcx(ccx), t));\n           }\n         }\n     }\n \n-    auto bcx = cx;\n+    let bcx = cx;\n \n-    auto lllevelptr = trans_log_level(bcx_lcx(bcx));\n+    let lllevelptr = trans_log_level(bcx_lcx(bcx));\n \n-    auto log_bcx = trans::new_scope_block_ctxt(bcx, \"log\");\n-    auto next_bcx = trans::new_scope_block_ctxt(bcx, \"next_log\");\n+    let log_bcx = trans::new_scope_block_ctxt(bcx, \"log\");\n+    let next_bcx = trans::new_scope_block_ctxt(bcx, \"next_log\");\n \n-    auto should_log = bcx.build.ICmp(ll::LLVMIntSGE,\n-                                     bcx.build.Load(lllevelptr),\n-                                     tc::C_int(level));\n+    let should_log =\n+        bcx.build.ICmp(ll::LLVMIntSGE, bcx.build.Load(lllevelptr),\n+                       tc::C_int(level));\n     bcx.build.CondBr(should_log, log_bcx.llbb, next_bcx.llbb);\n \n-    auto expr_t = ty::expr_ty(bcx_tcx(log_bcx), expr);\n-    auto r = get_upcall(bcx_ccx(bcx), sp, expr_t);\n-    auto llupcall = r.val; auto style = r.st;\n+    let expr_t = ty::expr_ty(bcx_tcx(log_bcx), expr);\n+    let r = get_upcall(bcx_ccx(bcx), sp, expr_t);\n+    let llupcall = r.val;\n+    let style = r.st;\n \n-    auto arg_dest;\n-    alt (style) {\n-      us_imm | us_imm_i32_zext {\n+    let arg_dest;\n+    alt style {\n+      us_imm. | us_imm_i32_zext. {\n         arg_dest = dest_imm(bcx_tcx(log_bcx), expr_t);\n       }\n-      us_alias | us_alias_istr {\n+      us_alias. | us_alias_istr. {\n         arg_dest = dest_alias(bcx_tcx(log_bcx), expr_t);\n       }\n     }\n     log_bcx = trans_expr(log_bcx, arg_dest, expr);\n \n-    auto llarg = dest_llval(arg_dest);\n-    alt (style) {\n-      us_imm | us_alias { /* no-op */ }\n-      us_imm_i32_zext { llarg = log_bcx.build.ZExt(llarg, tc::T_i32()); }\n-      us_alias_istr {\n-        llarg = log_bcx.build.PointerCast(llarg,\n-                                          tc::T_ptr(tc::T_ivec(tc::T_i8())));\n+    let llarg = dest_llval(arg_dest);\n+    alt style {\n+      us_imm. | us_alias. {/* no-op */ }\n+      us_imm_i32_zext. { llarg = log_bcx.build.ZExt(llarg, tc::T_i32()); }\n+      us_alias_istr. {\n+        llarg =\n+            log_bcx.build.PointerCast(llarg,\n+                                      tc::T_ptr(tc::T_ivec(tc::T_i8())));\n       }\n     }\n \n     log_bcx.build.Call(llupcall,\n                        ~[bcx_fcx(bcx).lltaskptr, tc::C_int(level), llarg]);\n \n-    log_bcx = trans::trans_block_cleanups(log_bcx,\n-                                          tc::find_scope_cx(log_bcx));\n+    log_bcx =\n+        trans::trans_block_cleanups(log_bcx, tc::find_scope_cx(log_bcx));\n     log_bcx.build.Br(next_bcx.llbb);\n     ret next_bcx;\n }\n \n-fn trans_path(&@block_ctxt bcx, &dest dest, &ast::path path, ast::node_id id)\n-        -> @block_ctxt {\n-    alt (bcx_tcx(bcx).def_map.get(id)) {\n-      ast::def_local(?def_id) {\n-        alt (bcx_fcx(bcx).lllocals.find(def_id.node)) {\n-          none { bcx_ccx(bcx).sess.unimpl(\"upvar in trans_path\"); }\n-          some(?llptr) {\n+fn trans_path(bcx: &@block_ctxt, dest: &dest, path: &ast::path,\n+              id: ast::node_id) -> @block_ctxt {\n+    alt bcx_tcx(bcx).def_map.get(id) {\n+      ast::def_local(def_id) {\n+        alt bcx_fcx(bcx).lllocals.find(def_id.node) {\n+          none. { bcx_ccx(bcx).sess.unimpl(\"upvar in trans_path\"); }\n+          some(llptr) {\n             // TODO: Copy hooks.\n             store_ptr(bcx, dest, llptr);\n           }\n@@ -428,42 +438,44 @@ fn trans_path(&@block_ctxt bcx, &dest dest, &ast::path path, ast::node_id id)\n     ret bcx;\n }\n \n-fn trans_expr(&@block_ctxt bcx, &dest dest, &@ast::expr expr) -> @block_ctxt {\n-    alt (expr.node) {\n-      ast::expr_lit(?lit) { trans_lit(bcx, dest, *lit); ret bcx; }\n-      ast::expr_log(?level, ?operand) {\n+fn trans_expr(bcx: &@block_ctxt, dest: &dest, expr: &@ast::expr) ->\n+   @block_ctxt {\n+    alt expr.node {\n+      ast::expr_lit(lit) { trans_lit(bcx, dest, *lit); ret bcx; }\n+      ast::expr_log(level, operand) {\n         ret trans_log(bcx, expr.span, level, operand);\n       }\n-      ast::expr_binary(?op, ?lhs, ?rhs) {\n+      ast::expr_binary(op, lhs, rhs) {\n         ret trans_binary(bcx, dest, expr.span, op, lhs, rhs);\n       }\n-      ast::expr_path(?path) { ret trans_path(bcx, dest, path, expr.id); }\n+      ast::expr_path(path) { ret trans_path(bcx, dest, path, expr.id); }\n       _ { fail \"unhandled expr type in trans_expr\"; }\n     }\n }\n \n-fn trans_recv(&@block_ctxt bcx, &dest dest, &@ast::expr expr) -> @block_ctxt {\n-    ret bcx;    // TODO\n+fn trans_recv(bcx: &@block_ctxt, dest: &dest, expr: &@ast::expr) ->\n+   @block_ctxt {\n+    ret bcx; // TODO\n }\n \n-fn trans_block(&@block_ctxt cx, &dest dest, &ast::blk blk)\n-        -> @block_ctxt {\n-    auto bcx = cx;\n-    for each (@ast::local local in trans::block_locals(blk)) {\n+fn trans_block(cx: &@block_ctxt, dest: &dest, blk: &ast::blk) -> @block_ctxt {\n+    let bcx = cx;\n+    for each local: @ast::local  in trans::block_locals(blk) {\n         bcx = trans::alloc_local(bcx, local).bcx;\n     }\n \n-    for (@ast::stmt stmt in blk.node.stmts) {\n+    for stmt: @ast::stmt  in blk.node.stmts {\n         bcx = trans_stmt(bcx, stmt);\n \n+\n         // If we hit a terminator, control won't go any further so\n         // we're in dead-code land. Stop here.\n         if trans::is_terminated(bcx) { ret bcx; }\n     }\n \n-    alt (blk.node.expr) {\n-      some(?e) { bcx = trans_expr(bcx, dest, e); }\n-      none { /* no-op */ }\n+    alt blk.node.expr {\n+      some(e) { bcx = trans_expr(bcx, dest, e); }\n+      none. {/* no-op */ }\n     }\n \n     bcx = trans::trans_block_cleanups(bcx, tc::find_scope_cx(bcx));\n@@ -480,131 +492,133 @@ fn trans_block(&@block_ctxt cx, &dest dest, &ast::blk blk)\n //\n // If |expand| is true, we never spill to the heap. This should be used\n // whenever the destination size isn't fixed.\n-fn trans_lit_str_common(&@crate_ctxt ccx, &str s, bool expand)\n-        -> rec(ValueRef stack, option[ValueRef] heap) {\n-    auto llstackpart; auto llheappartopt;\n+fn trans_lit_str_common(ccx: &@crate_ctxt, s: &str, expand: bool) ->\n+   {stack: ValueRef, heap: option[ValueRef]} {\n+    let llstackpart;\n+    let llheappartopt;\n \n-    auto len = str::byte_len(s);\n+    let len = str::byte_len(s);\n \n-    auto array = ~[];\n-    for (u8 ch in s) { array += ~[tc::C_u8(ch as uint)]; }\n+    let array = ~[];\n+    for ch: u8  in s { array += ~[tc::C_u8(ch as uint)]; }\n     array += ~[tc::C_u8(0u)];\n \n     if expand {\n-        llstackpart = tc::C_struct(~[tc::C_uint(len + 1u),\n-                                     tc::C_uint(len + 1u),\n-                                     tc::C_array(tc::T_i8(), array)]);\n+        llstackpart =\n+            tc::C_struct(~[tc::C_uint(len + 1u), tc::C_uint(len + 1u),\n+                           tc::C_array(tc::T_i8(), array)]);\n         llheappartopt = none;\n-    } else if len < abi::ivec_default_length - 1u { // minus one for the null\n-        while (ivec::len(array) < abi::ivec_default_length) {\n+    } else if (len < abi::ivec_default_length - 1u)\n+     { // minus one for the null\n+        while ivec::len(array) < abi::ivec_default_length {\n             array += ~[tc::C_u8(0u)];\n         }\n \n-        llstackpart = tc::C_struct(~[tc::C_uint(len + 1u),\n-                                     tc::C_uint(abi::ivec_default_length),\n-                                     tc::C_array(tc::T_i8(), array)]);\n+        llstackpart =\n+            tc::C_struct(~[tc::C_uint(len + 1u),\n+                           tc::C_uint(abi::ivec_default_length),\n+                           tc::C_array(tc::T_i8(), array)]);\n         llheappartopt = none;\n     } else {\n-        auto llheappart = tc::C_struct(~[tc::C_uint(len),\n-                                         tc::C_array(tc::T_i8(), array)]);\n+        let llheappart =\n+            tc::C_struct(~[tc::C_uint(len), tc::C_array(tc::T_i8(), array)]);\n         llstackpart =\n             tc::C_struct(~[tc::C_uint(0u),\n                            tc::C_uint(abi::ivec_default_length),\n                            tc::C_null(tc::T_ptr(lltype_of(llheappart)))]);\n-        llheappartopt = some(mk_const(ccx, \"const_istr_heap\", false,\n-                                      llheappart));\n+        llheappartopt =\n+            some(mk_const(ccx, \"const_istr_heap\", false, llheappart));\n     }\n \n-    ret rec(stack=mk_const(ccx, \"const_istr_stack\", false, llstackpart),\n-            heap=llheappartopt);\n+    ret {stack: mk_const(ccx, \"const_istr_stack\", false, llstackpart),\n+         heap: llheappartopt};\n }\n \n // As above, we don't use destination-passing style here.\n-fn trans_lit_common(&@crate_ctxt ccx, &ast::lit lit) -> ValueRef {\n-    alt (lit.node) {\n-      ast::lit_int(?i) { ret tc::C_int(i); }\n-      ast::lit_uint(?u) { ret tc::C_int(u as int); }\n-      ast::lit_mach_int(?tm, ?i) {\n+fn trans_lit_common(ccx: &@crate_ctxt, lit: &ast::lit) -> ValueRef {\n+    alt lit.node {\n+      ast::lit_int(i) { ret tc::C_int(i); }\n+      ast::lit_uint(u) { ret tc::C_int(u as int); }\n+      ast::lit_mach_int(tm, i) {\n         // FIXME: the entire handling of mach types falls apart\n         // if target int width is larger than host, at the moment;\n         // re-do the mach-int types using 'big' when that works.\n \n-        auto t = tc::T_int();\n-        auto s = LLTrue;\n-        alt (tm) {\n-          ast::ty_u8 { t = tc::T_i8(); s = LLFalse; }\n-          ast::ty_u16 { t = tc::T_i16(); s = LLFalse; }\n-          ast::ty_u32 { t = tc::T_i32(); s = LLFalse; }\n-          ast::ty_u64 { t = tc::T_i64(); s = LLFalse; }\n-          ast::ty_i8 { t = tc::T_i8(); }\n-          ast::ty_i16 { t = tc::T_i16(); }\n-          ast::ty_i32 { t = tc::T_i32(); }\n-          ast::ty_i64 { t = tc::T_i64(); }\n+        let t = tc::T_int();\n+        let s = LLTrue;\n+        alt tm {\n+          ast::ty_u8. { t = tc::T_i8(); s = LLFalse; }\n+          ast::ty_u16. { t = tc::T_i16(); s = LLFalse; }\n+          ast::ty_u32. { t = tc::T_i32(); s = LLFalse; }\n+          ast::ty_u64. { t = tc::T_i64(); s = LLFalse; }\n+          ast::ty_i8. { t = tc::T_i8(); }\n+          ast::ty_i16. { t = tc::T_i16(); }\n+          ast::ty_i32. { t = tc::T_i32(); }\n+          ast::ty_i64. { t = tc::T_i64(); }\n         }\n         ret tc::C_integral(t, i as uint, s);\n       }\n-      ast::lit_float(?fs) { ret tc::C_float(fs); }\n-      ast::lit_mach_float(?tm, ?s) {\n-        auto t = tc::T_float();\n-        alt (tm) {\n-          ast::ty_f32 { t = tc::T_f32(); }\n-          ast::ty_f64 { t = tc::T_f64(); }\n+      ast::lit_float(fs) { ret tc::C_float(fs); }\n+      ast::lit_mach_float(tm, s) {\n+        let t = tc::T_float();\n+        alt tm {\n+          ast::ty_f32. { t = tc::T_f32(); }\n+          ast::ty_f64. { t = tc::T_f64(); }\n         }\n         ret tc::C_floating(s, t);\n       }\n-      ast::lit_char(?c) {\n+      ast::lit_char(c) {\n         ret tc::C_integral(tc::T_char(), c as uint, LLFalse);\n       }\n-      ast::lit_bool(?b) { ret tc::C_bool(b); }\n-      ast::lit_nil { ret tc::C_nil(); }\n-      ast::lit_str(?s, ast::sk_rc) { ret tc::C_str(ccx, s); }\n-      ast::lit_str(?s, ast::sk_unique) {\n+      ast::lit_bool(b) { ret tc::C_bool(b); }\n+      ast::lit_nil. { ret tc::C_nil(); }\n+      ast::lit_str(s, ast::sk_rc.) { ret tc::C_str(ccx, s); }\n+      ast::lit_str(s, ast::sk_unique.) {\n         fail \"unique str in trans_lit_common\";\n       }\n     }\n }\n \n-fn trans_init_local(&@block_ctxt bcx, &@ast::local local) -> @block_ctxt {\n-    auto llptr = bcx_fcx(bcx).lllocals.get(local.node.id);\n+fn trans_init_local(bcx: &@block_ctxt, local: &@ast::local) -> @block_ctxt {\n+    let llptr = bcx_fcx(bcx).lllocals.get(local.node.id);\n \n-    auto t = type_of_node(bcx_ccx(bcx), local.node.id);\n+    let t = type_of_node(bcx_ccx(bcx), local.node.id);\n     tc::add_clean(bcx, llptr, t);\n \n-    alt (local.node.init) {\n-      some(?init) {\n-        alt (init.op) {\n-          ast::init_assign {\n+\n+    alt local.node.init {\n+      some(init) {\n+        alt init.op {\n+          ast::init_assign. {\n             ret trans_expr(bcx, dest_copy(bcx_tcx(bcx), llptr, t), init.expr);\n           }\n-          ast::init_move {\n+          ast::init_move. {\n             ret trans_expr(bcx, dest_move(bcx_tcx(bcx), llptr, t), init.expr);\n           }\n-          ast::init_recv {\n+          ast::init_recv. {\n             ret trans_recv(bcx, dest_copy(bcx_tcx(bcx), llptr, t), init.expr);\n           }\n         }\n       }\n-      none { ret bcx; }\n+      none. { ret bcx; }\n     }\n }\n \n-fn trans_stmt(&@block_ctxt cx, &@ast::stmt stmt) -> @block_ctxt {\n-    auto bcx = cx;\n-    alt (stmt.node) {\n-      ast::stmt_expr(?e, _) {\n-        auto tmp = dest_alias(bcx_tcx(bcx), ty::expr_ty(bcx_tcx(bcx), e));\n+fn trans_stmt(cx: &@block_ctxt, stmt: &@ast::stmt) -> @block_ctxt {\n+    let bcx = cx;\n+    alt stmt.node {\n+      ast::stmt_expr(e, _) {\n+        let tmp = dest_alias(bcx_tcx(bcx), ty::expr_ty(bcx_tcx(bcx), e));\n         ret trans_expr(bcx, tmp, e);\n       }\n-      ast::stmt_decl(?d, _) {\n-        alt (d.node) {\n-          ast::decl_local(?locals) {\n-            for (@ast::local local in locals) {\n+      ast::stmt_decl(d, _) {\n+        alt d.node {\n+          ast::decl_local(locals) {\n+            for local: @ast::local  in locals {\n                 bcx = trans_init_local(bcx, local);\n             }\n           }\n-          ast::decl_item(?item) {\n-            trans::trans_item(bcx_lcx(bcx), *item);\n-          }\n+          ast::decl_item(item) { trans::trans_item(bcx_lcx(bcx), *item); }\n         }\n         ret bcx;\n       }"}, {"sha": "d2b30593b483ee487ac58a3d9f0885ebb50e70ac", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 79, "deletions": 80, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -38,175 +38,174 @@ import tc = middle::trans_common;\n //\n // TODO: We can optimize this in the cases in which we statically know the\n // vector must be on the stack.\n-fn get_len_and_data(&@block_ctxt cx, ty::t t, ValueRef llvecptr)\n-        -> rec(@block_ctxt bcx, ValueRef len, ValueRef data) {\n-    auto bcx = cx;\n+fn get_len_and_data(cx: &@block_ctxt, t: ty::t, llvecptr: ValueRef) ->\n+   {bcx: @block_ctxt, len: ValueRef, data: ValueRef} {\n+    let bcx = cx;\n \n     // If this interior vector has dynamic size, we can't assume anything\n     // about the LLVM type of the value passed in, so we cast it to an\n     // opaque vector type.\n-    auto unit_ty = ty::sequence_element_type(bcx_tcx(bcx), t);\n-    auto v;\n-    if (ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty)) {\n+    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), t);\n+    let v;\n+    if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n         v = bcx.build.PointerCast(llvecptr, T_ptr(T_opaque_ivec()));\n-    } else {\n-        v = llvecptr;\n-    }\n-\n-    auto llunitty = type_of_or_i8(bcx, unit_ty);\n-    auto stack_len = load_inbounds(bcx, v, ~[C_int(0),\n-                                             C_uint(abi::ivec_elt_len)]);\n-    auto stack_elem =\n+    } else { v = llvecptr; }\n+\n+    let llunitty = type_of_or_i8(bcx, unit_ty);\n+    let stack_len =\n+        load_inbounds(bcx, v, ~[C_int(0), C_uint(abi::ivec_elt_len)]);\n+    let stack_elem =\n         bcx.build.InBoundsGEP(v,\n                               ~[C_int(0), C_uint(abi::ivec_elt_elems),\n                                 C_int(0)]);\n-    auto on_heap =\n-        bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n-    auto on_heap_cx = new_sub_block_ctxt(bcx, \"on_heap\");\n-    auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n+    let on_heap = bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n+    let on_heap_cx = new_sub_block_ctxt(bcx, \"on_heap\");\n+    let next_cx = new_sub_block_ctxt(bcx, \"next\");\n     bcx.build.CondBr(on_heap, on_heap_cx.llbb, next_cx.llbb);\n-    auto heap_stub =\n+    let heap_stub =\n         on_heap_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n-    auto heap_ptr = load_inbounds(on_heap_cx, heap_stub,\n-                                  ~[C_int(0),\n-                                    C_uint(abi::ivec_heap_stub_elt_ptr)]);\n+    let heap_ptr =\n+        load_inbounds(on_heap_cx, heap_stub,\n+                      ~[C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]);\n \n     // Check whether the heap pointer is null. If it is, the vector length\n     // is truly zero.\n \n-    auto llstubty = T_ivec_heap(llunitty);\n-    auto llheapptrty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n-    auto heap_ptr_is_null =\n+    let llstubty = T_ivec_heap(llunitty);\n+    let llheapptrty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n+    let heap_ptr_is_null =\n         on_heap_cx.build.ICmp(lib::llvm::LLVMIntEQ, heap_ptr,\n                               C_null(T_ptr(llheapptrty)));\n-    auto zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n-    auto nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n+    let zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n+    let nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n     on_heap_cx.build.CondBr(heap_ptr_is_null, zero_len_cx.llbb,\n                             nonzero_len_cx.llbb);\n     // Technically this context is unnecessary, but it makes this function\n     // clearer.\n \n-    auto zero_len = C_int(0);\n-    auto zero_elem = C_null(T_ptr(llunitty));\n+    let zero_len = C_int(0);\n+    let zero_elem = C_null(T_ptr(llunitty));\n     zero_len_cx.build.Br(next_cx.llbb);\n     // If we're here, then we actually have a heapified vector.\n \n-    auto heap_len = load_inbounds(nonzero_len_cx, heap_ptr,\n-                                  ~[C_int(0),\n-                                    C_uint(abi::ivec_heap_elt_len)]);\n-    auto heap_elem =\n+    let heap_len =\n+        load_inbounds(nonzero_len_cx, heap_ptr,\n+                      ~[C_int(0), C_uint(abi::ivec_heap_elt_len)]);\n+    let heap_elem =\n         {\n-            auto v = ~[C_int(0), C_uint(abi::ivec_heap_elt_elems),\n-                       C_int(0)];\n-            nonzero_len_cx.build.InBoundsGEP(heap_ptr,v)\n+            let v = ~[C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)];\n+            nonzero_len_cx.build.InBoundsGEP(heap_ptr, v)\n         };\n \n     nonzero_len_cx.build.Br(next_cx.llbb);\n \n     // Now we can figure out the length of |v| and get a pointer to its\n     // first element.\n \n-    auto len =\n+    let len =\n         next_cx.build.Phi(T_int(), ~[stack_len, zero_len, heap_len],\n-                          ~[bcx.llbb, zero_len_cx.llbb,\n-                            nonzero_len_cx.llbb]);\n-    auto elem =\n+                          ~[bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n+    let elem =\n         next_cx.build.Phi(T_ptr(llunitty),\n                           ~[stack_elem, zero_elem, heap_elem],\n-                          ~[bcx.llbb, zero_len_cx.llbb,\n-                            nonzero_len_cx.llbb]);\n-    ret rec(bcx=next_cx, len=len, data=elem);\n+                          ~[bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n+    ret {bcx: next_cx, len: len, data: elem};\n }\n \n-fn trans_concat(&@block_ctxt cx, &dest in_dest, &span sp, ty::t t,\n-                &@ast::expr lhs, &@ast::expr rhs) -> @block_ctxt {\n-    auto bcx = cx;\n+fn trans_concat(cx: &@block_ctxt, in_dest: &dest, sp: &span, t: ty::t,\n+                lhs: &@ast::expr, rhs: &@ast::expr) -> @block_ctxt {\n+    let bcx = cx;\n \n     // TODO: Detect \"a = a + b\" and promote to trans_append.\n     // TODO: Detect \"a + [ literal ]\" and optimize to copying the literal\n     //       elements in directly.\n \n-    auto t = ty::expr_ty(bcx_tcx(bcx), lhs);\n-    auto skip_null = ty::type_is_str(bcx_tcx(bcx), t);\n+    let t = ty::expr_ty(bcx_tcx(bcx), lhs);\n+    let skip_null = ty::type_is_str(bcx_tcx(bcx), t);\n \n     // Translate the LHS and RHS. Pull out their length and data.\n-    auto lhs_tmp = trans_dps::dest_alias(bcx_tcx(bcx), t);\n+    let lhs_tmp = trans_dps::dest_alias(bcx_tcx(bcx), t);\n     bcx = trans_dps::trans_expr(bcx, lhs_tmp, lhs);\n-    auto lllhsptr = trans_dps::dest_ptr(lhs_tmp);\n+    let lllhsptr = trans_dps::dest_ptr(lhs_tmp);\n \n-    auto rhs_tmp = trans_dps::dest_alias(bcx_tcx(bcx), t);\n+    let rhs_tmp = trans_dps::dest_alias(bcx_tcx(bcx), t);\n     bcx = trans_dps::trans_expr(bcx, rhs_tmp, rhs);\n-    auto llrhsptr = trans_dps::dest_ptr(rhs_tmp);\n+    let llrhsptr = trans_dps::dest_ptr(rhs_tmp);\n \n-    auto r0 = get_len_and_data(bcx, t, lllhsptr);\n-    bcx = r0.bcx; auto lllhslen = r0.len; auto lllhsdata = r0.data;\n+    let r0 = get_len_and_data(bcx, t, lllhsptr);\n+    bcx = r0.bcx;\n+    let lllhslen = r0.len;\n+    let lllhsdata = r0.data;\n     r0 = get_len_and_data(bcx, t, llrhsptr);\n-    bcx = r0.bcx; auto llrhslen = r0.len; auto llrhsdata = r0.data;\n+    bcx = r0.bcx;\n+    let llrhslen = r0.len;\n+    let llrhsdata = r0.data;\n \n     if skip_null { lllhslen = bcx.build.Sub(lllhslen, C_int(1)); }\n \n     // Allocate the destination.\n-    auto r1 = trans_dps::spill_alias(bcx, in_dest, t);\n-    bcx = r1.bcx; auto dest = r1.dest;\n+    let r1 = trans_dps::spill_alias(bcx, in_dest, t);\n+    bcx = r1.bcx;\n+    let dest = r1.dest;\n \n-    auto unit_t = ty::sequence_element_type(bcx_tcx(bcx), t);\n-    auto unit_sz = trans_dps::size_of(bcx_ccx(bcx), sp, unit_t);\n+    let unit_t = ty::sequence_element_type(bcx_tcx(bcx), t);\n+    let unit_sz = trans_dps::size_of(bcx_ccx(bcx), sp, unit_t);\n \n-    auto stack_elems_sz = unit_sz * abi::ivec_default_length;\n-    auto lldestptr = trans_dps::dest_ptr(dest);\n-    auto llunitty = trans::type_of(bcx_ccx(bcx), sp, unit_t);\n+    let stack_elems_sz = unit_sz * abi::ivec_default_length;\n+    let lldestptr = trans_dps::dest_ptr(dest);\n+    let llunitty = trans::type_of(bcx_ccx(bcx), sp, unit_t);\n \n     // Decide whether to allocate the result on the stack or on the heap.\n-    auto llnewlen = bcx.build.Add(lllhslen, llrhslen);\n-    auto llonstack = bcx.build.ICmp(lib::llvm::LLVMIntULE, llnewlen,\n-                                    C_uint(stack_elems_sz));\n-    auto on_stack_bcx = new_sub_block_ctxt(bcx, \"on_stack\");\n-    auto on_heap_bcx = new_sub_block_ctxt(bcx, \"on_heap\");\n+    let llnewlen = bcx.build.Add(lllhslen, llrhslen);\n+    let llonstack =\n+        bcx.build.ICmp(lib::llvm::LLVMIntULE, llnewlen,\n+                       C_uint(stack_elems_sz));\n+    let on_stack_bcx = new_sub_block_ctxt(bcx, \"on_stack\");\n+    let on_heap_bcx = new_sub_block_ctxt(bcx, \"on_heap\");\n     bcx.build.CondBr(llonstack, on_stack_bcx.llbb, on_heap_bcx.llbb);\n \n     // On-stack case.\n-    auto next_bcx = new_sub_block_ctxt(bcx, \"next\");\n+    let next_bcx = new_sub_block_ctxt(bcx, \"next\");\n     trans::store_inbounds(on_stack_bcx, llnewlen, lldestptr,\n                           ~[C_int(0), C_uint(abi::ivec_elt_len)]);\n     trans::store_inbounds(on_stack_bcx, C_uint(stack_elems_sz), lldestptr,\n                           ~[C_int(0), C_uint(abi::ivec_elt_alen)]);\n-    auto llonstackdataptr =\n+    let llonstackdataptr =\n         on_stack_bcx.build.InBoundsGEP(lldestptr,\n                                        ~[C_int(0),\n                                          C_uint(abi::ivec_elt_elems),\n                                          C_int(0)]);\n     on_stack_bcx.build.Br(next_bcx.llbb);\n \n     // On-heap case.\n-    auto llheappartty = tc::T_ivec_heap(llunitty);\n-    auto lldeststubptr =\n+    let llheappartty = tc::T_ivec_heap(llunitty);\n+    let lldeststubptr =\n         on_heap_bcx.build.PointerCast(lldestptr, tc::T_ptr(llheappartty));\n     trans::store_inbounds(on_heap_bcx, C_int(0), lldeststubptr,\n                           ~[C_int(0), C_uint(abi::ivec_elt_len)]);\n     trans::store_inbounds(on_heap_bcx, llnewlen, lldeststubptr,\n                           ~[C_int(0), C_uint(abi::ivec_elt_alen)]);\n \n-    auto llheappartptrptr =\n+    let llheappartptrptr =\n         on_heap_bcx.build.InBoundsGEP(lldeststubptr,\n                                       ~[C_int(0),\n                                         C_uint(abi::ivec_elt_elems)]);\n-    auto llsizeofint = C_uint(llsize_of(bcx_ccx(bcx), tc::T_int()));\n-    on_heap_bcx = trans_dps::malloc(on_heap_bcx, llheappartptrptr,\n-                                    trans_dps::hp_shared,\n-                                    some(on_heap_bcx.build.Add(llnewlen,\n-                                                               llsizeofint)));\n-    auto llheappartptr = on_heap_bcx.build.Load(llheappartptrptr);\n+    let llsizeofint = C_uint(llsize_of(bcx_ccx(bcx), tc::T_int()));\n+    on_heap_bcx =\n+        trans_dps::malloc(on_heap_bcx, llheappartptrptr, trans_dps::hp_shared,\n+                          some(on_heap_bcx.build.Add(llnewlen, llsizeofint)));\n+    let llheappartptr = on_heap_bcx.build.Load(llheappartptrptr);\n     trans::store_inbounds(on_heap_bcx, llnewlen, llheappartptr,\n                           ~[C_int(0), C_uint(abi::ivec_heap_elt_len)]);\n-    auto llheapdataptr =\n+    let llheapdataptr =\n         on_heap_bcx.build.InBoundsGEP(llheappartptr,\n                                       ~[C_int(0),\n                                         C_uint(abi::ivec_heap_elt_elems),\n                                         C_int(0)]);\n     on_heap_bcx.build.Br(next_bcx.llbb);\n \n     // Perform the memmove.\n-    auto lldataptr =\n+    let lldataptr =\n         next_bcx.build.Phi(T_ptr(llunitty),\n                            ~[llonstackdataptr, llheapdataptr],\n                            ~[on_stack_bcx.llbb, on_heap_bcx.llbb]);"}, {"sha": "f88d803b7bf6bc9f10e488c50ec89b467bb2af45", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 63, "deletions": 73, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -31,226 +31,216 @@ type poststate = t;\n  */\n \n /* named thus so as not to confuse with prestate and poststate */\n-type pre_and_post = @rec(precond precondition, postcond postcondition);\n+type pre_and_post = @{precondition: precond, postcondition: postcond};\n \n \n /* FIXME: once it's implemented: */\n \n //  : ((*.precondition).nbits == (*.postcondition).nbits);\n-type pre_and_post_state = rec(prestate prestate, poststate poststate);\n+type pre_and_post_state = {prestate: prestate, poststate: poststate};\n \n-type ts_ann = @rec(pre_and_post conditions, pre_and_post_state states);\n+type ts_ann = @{conditions: pre_and_post, states: pre_and_post_state};\n \n-fn true_precond(uint num_vars) -> precond {\n-    be create_tritv(num_vars);\n-}\n+fn true_precond(num_vars: uint) -> precond { be create_tritv(num_vars); }\n \n-fn true_postcond(uint num_vars) -> postcond { be true_precond(num_vars); }\n+fn true_postcond(num_vars: uint) -> postcond { be true_precond(num_vars); }\n \n-fn empty_prestate(uint num_vars) -> prestate { be true_precond(num_vars); }\n+fn empty_prestate(num_vars: uint) -> prestate { be true_precond(num_vars); }\n \n-fn empty_poststate(uint num_vars) -> poststate { be true_precond(num_vars); }\n+fn empty_poststate(num_vars: uint) -> poststate { be true_precond(num_vars); }\n \n-fn false_postcond(uint num_vars) -> postcond {\n-    auto rslt = create_tritv(num_vars);\n+fn false_postcond(num_vars: uint) -> postcond {\n+    let rslt = create_tritv(num_vars);\n     tritv_set_all(rslt);\n     ret rslt;\n }\n \n-fn empty_pre_post(uint num_vars) -> pre_and_post {\n-    ret @rec(precondition=empty_prestate(num_vars),\n-             postcondition=empty_poststate(num_vars));\n+fn empty_pre_post(num_vars: uint) -> pre_and_post {\n+    ret @{precondition: empty_prestate(num_vars),\n+          postcondition: empty_poststate(num_vars)};\n }\n \n-fn empty_states(uint num_vars) -> pre_and_post_state {\n-    ret rec(prestate=true_precond(num_vars),\n-            poststate=true_postcond(num_vars));\n+fn empty_states(num_vars: uint) -> pre_and_post_state {\n+    ret {prestate: true_precond(num_vars),\n+         poststate: true_postcond(num_vars)};\n }\n \n-fn empty_ann(uint num_vars) -> ts_ann {\n-    ret @rec(conditions=empty_pre_post(num_vars),\n-             states=empty_states(num_vars));\n+fn empty_ann(num_vars: uint) -> ts_ann {\n+    ret @{conditions: empty_pre_post(num_vars),\n+          states: empty_states(num_vars)};\n }\n \n-fn get_pre(&pre_and_post p) -> precond { ret p.precondition; }\n+fn get_pre(p: &pre_and_post) -> precond { ret p.precondition; }\n \n-fn get_post(&pre_and_post p) -> postcond { ret p.postcondition; }\n+fn get_post(p: &pre_and_post) -> postcond { ret p.postcondition; }\n \n-fn difference(&precond p1, &precond p2) -> bool {\n+fn difference(p1: &precond, p2: &precond) -> bool {\n     ret tritv_difference(p1, p2);\n }\n \n-fn union(&precond p1, &precond p2) -> bool {\n-    ret tritv_union(p1, p2);\n-}\n+fn union(p1: &precond, p2: &precond) -> bool { ret tritv_union(p1, p2); }\n \n-fn intersect(&precond p1, &precond p2) -> bool {\n+fn intersect(p1: &precond, p2: &precond) -> bool {\n     ret tritv_intersect(p1, p2);\n }\n \n-fn pps_len(&pre_and_post p) -> uint {\n+fn pps_len(p: &pre_and_post) -> uint {\n     // gratuitous check\n \n     assert (p.precondition.nbits == p.postcondition.nbits);\n     ret p.precondition.nbits;\n }\n \n-fn require(uint i, &pre_and_post p) {\n+fn require(i: uint, p: &pre_and_post) {\n     // sets the ith bit in p's pre\n     tritv_set(i, p.precondition, ttrue);\n }\n \n-fn require_and_preserve(uint i, &pre_and_post p) {\n+fn require_and_preserve(i: uint, p: &pre_and_post) {\n     // sets the ith bit in p's pre and post\n     tritv_set(i, p.precondition, ttrue);\n     tritv_set(i, p.postcondition, ttrue);\n }\n \n-fn set_in_postcond(uint i, &pre_and_post p) -> bool {\n+fn set_in_postcond(i: uint, p: &pre_and_post) -> bool {\n     // sets the ith bit in p's post\n     ret set_in_postcond_(i, p.postcondition);\n }\n \n-fn set_in_postcond_(uint i, &postcond p) -> bool {\n-    auto was_set = tritv_get(p, i);\n+fn set_in_postcond_(i: uint, p: &postcond) -> bool {\n+    let was_set = tritv_get(p, i);\n     tritv_set(i, p, ttrue);\n     ret was_set != ttrue;\n }\n \n-fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n+fn set_in_poststate(i: uint, s: &pre_and_post_state) -> bool {\n     // sets the ith bit in p's post\n     ret set_in_poststate_(i, s.poststate);\n }\n \n-fn set_in_poststate_(uint i, &poststate p) -> bool {\n-    auto was_set = tritv_get(p, i);\n+fn set_in_poststate_(i: uint, p: &poststate) -> bool {\n+    let was_set = tritv_get(p, i);\n     tritv_set(i, p, ttrue);\n     ret was_set != ttrue;\n \n }\n \n-fn clear_in_poststate(uint i, &pre_and_post_state s) -> bool {\n+fn clear_in_poststate(i: uint, s: &pre_and_post_state) -> bool {\n     // sets the ith bit in p's post\n     ret clear_in_poststate_(i, s.poststate);\n }\n \n-fn clear_in_poststate_(uint i, &poststate s) -> bool {\n-    auto was_set = tritv_get(s, i);\n+fn clear_in_poststate_(i: uint, s: &poststate) -> bool {\n+    let was_set = tritv_get(s, i);\n     tritv_set(i, s, tfalse);\n     ret was_set != tfalse;\n }\n \n-fn clear_in_prestate(uint i, &pre_and_post_state s) -> bool {\n+fn clear_in_prestate(i: uint, s: &pre_and_post_state) -> bool {\n     // sets the ith bit in p's pre\n     ret clear_in_prestate_(i, s.prestate);\n }\n \n-fn clear_in_prestate_(uint i, &prestate s) -> bool {\n-    auto was_set = tritv_get(s, i);\n+fn clear_in_prestate_(i: uint, s: &prestate) -> bool {\n+    let was_set = tritv_get(s, i);\n     tritv_set(i, s, tfalse);\n     ret was_set != tfalse;\n }\n \n-fn clear_in_postcond(uint i, &pre_and_post s) -> bool {\n+fn clear_in_postcond(i: uint, s: &pre_and_post) -> bool {\n     // sets the ith bit in p's post\n-    auto was_set = tritv_get(s.postcondition, i);\n+    let was_set = tritv_get(s.postcondition, i);\n     tritv_set(i, s.postcondition, tfalse);\n     ret was_set != tfalse;\n }\n \n // Sets all the bits in a's precondition to equal the\n // corresponding bit in p's precondition.\n-fn set_precondition(ts_ann a, &precond p) {\n+fn set_precondition(a: ts_ann, p: &precond) {\n     tritv_copy(a.conditions.precondition, p);\n }\n \n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-fn set_postcondition(ts_ann a, &postcond p) {\n+fn set_postcondition(a: ts_ann, p: &postcond) {\n     tritv_copy(a.conditions.postcondition, p);\n }\n \n \n // Sets all the bits in a's prestate to equal the\n // corresponding bit in p's prestate.\n-fn set_prestate(ts_ann a, &prestate p) -> bool {\n+fn set_prestate(a: ts_ann, p: &prestate) -> bool {\n     ret tritv_copy(a.states.prestate, p);\n }\n \n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-fn set_poststate(ts_ann a, &poststate p) -> bool {\n+fn set_poststate(a: ts_ann, p: &poststate) -> bool {\n     ret tritv_copy(a.states.poststate, p);\n }\n \n \n // Set all the bits in p that are set in new\n-fn extend_prestate(&prestate p, &poststate new) -> bool {\n+fn extend_prestate(p: &prestate, new: &poststate) -> bool {\n     ret tritv_union(p, new);\n }\n \n \n // Set all the bits in p that are set in new\n-fn extend_poststate(&poststate p, &poststate new) -> bool {\n+fn extend_poststate(p: &poststate, new: &poststate) -> bool {\n     ret tritv_union(p, new);\n }\n \n // Sets the given bit in p to \"don't care\"\n // FIXME: is this correct?\n-fn relax_prestate(uint i, &prestate p) -> bool {\n-    auto was_set = tritv_get(p, i);\n+fn relax_prestate(i: uint, p: &prestate) -> bool {\n+    let was_set = tritv_get(p, i);\n     tritv_set(i, p, dont_care);\n     ret was_set != dont_care;\n }\n \n // Clears the given bit in p\n-fn relax_poststate(uint i, &poststate p) -> bool {\n+fn relax_poststate(i: uint, p: &poststate) -> bool {\n     ret relax_prestate(i, p);\n }\n \n // Clears the given bit in p\n-fn relax_precond(uint i, &precond p) {\n-    relax_prestate(i, p);\n-}\n+fn relax_precond(i: uint, p: &precond) { relax_prestate(i, p); }\n \n // Sets all the bits in p to \"don't care\"\n-fn clear(&precond p) { tritv_clear(p); }\n+fn clear(p: &precond) { tritv_clear(p); }\n \n // Sets all the bits in p to true\n-fn set(&precond p) { tritv_set_all(p); }\n+fn set(p: &precond) { tritv_set_all(p); }\n \n-fn ann_precond(&ts_ann a) -> precond { ret a.conditions.precondition; }\n+fn ann_precond(a: &ts_ann) -> precond { ret a.conditions.precondition; }\n \n-fn ann_prestate(&ts_ann a) -> prestate { ret a.states.prestate; }\n+fn ann_prestate(a: &ts_ann) -> prestate { ret a.states.prestate; }\n \n-fn ann_poststate(&ts_ann a) -> poststate { ret a.states.poststate; }\n+fn ann_poststate(a: &ts_ann) -> poststate { ret a.states.poststate; }\n \n-fn pp_clone(&pre_and_post p) -> pre_and_post {\n-    ret @rec(precondition=clone(p.precondition),\n-             postcondition=clone(p.postcondition));\n+fn pp_clone(p: &pre_and_post) -> pre_and_post {\n+    ret @{precondition: clone(p.precondition),\n+          postcondition: clone(p.postcondition)};\n }\n \n-fn clone(prestate p) -> prestate { ret tritv_clone(p); }\n+fn clone(p: prestate) -> prestate { ret tritv_clone(p); }\n \n \n // returns true if a implies b\n // that is, returns true except if for some bits c and d,\n // c = 1 and d = either 0 or \"don't know\"\n // FIXME: is this correct?\n-fn implies(t a, t b) -> bool {\n-    auto tmp = tritv_clone(b);\n+fn implies(a: t, b: t) -> bool {\n+    let tmp = tritv_clone(b);\n     tritv_difference(tmp, a);\n     ret tritv_doesntcare(tmp);\n }\n \n-fn trit_str(trit t) -> str {\n-    alt (t) {\n-        case (dont_care) { \"?\" }\n-        case (ttrue)     { \"1\" }\n-        case (tfalse)    { \"0\" }\n-    }\n+fn trit_str(t: trit) -> str {\n+    alt t { dont_care. { \"?\" } ttrue. { \"1\" } tfalse. { \"0\" } }\n }\n //\n // Local Variables:"}, {"sha": "03f5f2d7e64386bb6e34da722f4206621fa04db6", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -23,70 +23,67 @@ import aux::crate_ctxt;\n import aux::add_node;\n import middle::tstate::ann::empty_ann;\n \n-fn collect_ids_expr(&@expr e, @mutable node_id[] rs) {\n-    *rs += ~[e.id];\n-}\n+fn collect_ids_expr(e: &@expr, rs: @mutable node_id[]) { *rs += ~[e.id]; }\n \n-fn collect_ids_block(&blk b, @mutable node_id[] rs) {\n-    *rs += ~[b.node.id];\n-}\n+fn collect_ids_block(b: &blk, rs: @mutable node_id[]) { *rs += ~[b.node.id]; }\n \n-fn collect_ids_stmt(&@stmt s, @mutable node_id[] rs) {\n-    alt (s.node) {\n-        case (stmt_decl(_, ?id)) {\n-            log \"node_id \" + int::str(id);\n-            log_stmt(*s);\n-            *rs += ~[id];\n-        }\n-        case (stmt_expr(_, ?id)) {\n-            log \"node_id \" + int::str(id);\n-            log_stmt(*s);\n-            *rs += ~[id];\n-        }\n-        case (_) { }\n+fn collect_ids_stmt(s: &@stmt, rs: @mutable node_id[]) {\n+    alt s.node {\n+      stmt_decl(_, id) {\n+        log \"node_id \" + int::str(id);\n+        log_stmt(*s);\n+        *rs += ~[id];\n+      }\n+      stmt_expr(_, id) {\n+        log \"node_id \" + int::str(id);\n+        log_stmt(*s);\n+        *rs += ~[id];\n+      }\n+      _ { }\n     }\n }\n \n-fn collect_ids_local(&@local l, @mutable node_id[] rs) {\n+fn collect_ids_local(l: &@local, rs: @mutable node_id[]) {\n     *rs += ~[l.node.id];\n }\n \n-fn node_ids_in_fn(&_fn f, &ty_param[] tps, &span sp, &fn_ident i,\n-                  node_id id, @mutable node_id[] rs) {\n-    auto collect_ids = visit::mk_simple_visitor\n-        (@rec(visit_expr=bind collect_ids_expr(_, rs),\n-              visit_block=bind collect_ids_block(_, rs),\n-              visit_stmt=bind collect_ids_stmt(_, rs),\n-              visit_local=bind collect_ids_local(_, rs)\n-              with *visit::default_simple_visitor()));\n+fn node_ids_in_fn(f: &_fn, tps: &ty_param[], sp: &span, i: &fn_ident,\n+                  id: node_id, rs: @mutable node_id[]) {\n+    let collect_ids =\n+        visit::mk_simple_visitor(@{visit_expr: bind collect_ids_expr(_, rs),\n+                                   visit_block: bind collect_ids_block(_, rs),\n+                                   visit_stmt: bind collect_ids_stmt(_, rs),\n+                                   visit_local: bind collect_ids_local(_, rs)\n+                                      with *visit::default_simple_visitor()});\n     visit::visit_fn(f, tps, sp, i, id, (), collect_ids);\n }\n \n-fn init_vecs(&crate_ctxt ccx, &node_id[] node_ids, uint len) {\n-    for (node_id i in node_ids) {\n+fn init_vecs(ccx: &crate_ctxt, node_ids: &node_id[], len: uint) {\n+    for i: node_id  in node_ids {\n         log int::str(i) + \" |-> \" + uint::str(len);\n         add_node(ccx, i, empty_ann(len));\n     }\n }\n \n-fn visit_fn(&crate_ctxt ccx, uint num_constraints, &_fn f, &ty_param[] tps,\n-            &span sp, &fn_ident i, node_id id) {\n-    let @mutable node_id[] node_ids = @mutable ~[];\n+fn visit_fn(ccx: &crate_ctxt, num_constraints: uint, f: &_fn,\n+            tps: &ty_param[], sp: &span, i: &fn_ident, id: node_id) {\n+    let node_ids: @mutable node_id[] = @mutable ~[];\n     node_ids_in_fn(f, tps, sp, i, id, node_ids);\n-    auto node_id_vec = *node_ids;\n+    let node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);\n }\n \n-fn annotate_in_fn(&crate_ctxt ccx, &_fn f, &ty_param[] tps,\n-                  &span sp, &fn_ident i, node_id id) {\n-    auto f_info = get_fn_info(ccx, id);\n+fn annotate_in_fn(ccx: &crate_ctxt, f: &_fn, tps: &ty_param[], sp: &span,\n+                  i: &fn_ident, id: node_id) {\n+    let f_info = get_fn_info(ccx, id);\n     visit_fn(ccx, num_constraints(f_info), f, tps, sp, i, id);\n }\n \n-fn annotate_crate(&crate_ctxt ccx, &crate crate) {\n-    auto do_ann = visit::mk_simple_visitor\n-        (@rec(visit_fn=bind annotate_in_fn(ccx, _, _, _, _, _)\n-              with *visit::default_simple_visitor()));\n+fn annotate_crate(ccx: &crate_ctxt, crate: &crate) {\n+    let do_ann =\n+        visit::mk_simple_visitor(@{visit_fn:\n+                                       bind annotate_in_fn(ccx, _, _, _, _, _)\n+                                      with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), do_ann);\n }\n //"}, {"sha": "44eaa53edd1d4c821bd3613ae48fc6af9ab2b712", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 476, "deletions": 529, "changes": 1005, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -54,121 +54,123 @@ tag oper_type {\n }\n \n /* logging funs */\n-fn def_id_to_str(def_id d) -> str {\n+fn def_id_to_str(d: def_id) -> str {\n     ret int::str(d.crate) + \",\" + int::str(d.node);\n }\n \n-fn comma_str(&(@constr_arg_use)[] args) -> str {\n-    auto rslt = \"\";\n-    auto comma = false;\n-    for (@constr_arg_use a in args) {\n-        if (comma) { rslt += \", \"; } else { comma = true; }\n-        alt (a.node) {\n-            case (carg_base) { rslt += \"*\"; }\n-            case (carg_ident(?i)) { rslt += i.ident; }\n-            case (carg_lit(?l)) { rslt += lit_to_str(l); }\n+fn comma_str(args: &(@constr_arg_use)[]) -> str {\n+    let rslt = \"\";\n+    let comma = false;\n+    for a: @constr_arg_use  in args {\n+        if comma { rslt += \", \"; } else { comma = true; }\n+        alt a.node {\n+          carg_base. { rslt += \"*\"; }\n+          carg_ident(i) { rslt += i.ident; }\n+          carg_lit(l) { rslt += lit_to_str(l); }\n         }\n     }\n     ret rslt;\n }\n \n-fn constraint_to_str(&ty::ctxt tcx, &sp_constr c) -> str {\n-    alt (c.node) {\n-        case (ninit(_,?i)) {\n-            ret \"init(\" + i + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n-        }\n-        case (npred(?p, _, ?args)) {\n-            ret path_to_str(p) + \"(\" + comma_str(args) + \")\" + \"[\" +\n-                    tcx.sess.span_str(c.span) + \"]\";\n-        }\n+fn constraint_to_str(tcx: &ty::ctxt, c: &sp_constr) -> str {\n+    alt c.node {\n+      ninit(_, i) {\n+        ret \"init(\" + i + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n+      }\n+      npred(p, _, args) {\n+        ret path_to_str(p) + \"(\" + comma_str(args) + \")\" + \"[\" +\n+                tcx.sess.span_str(c.span) + \"]\";\n+      }\n     }\n }\n \n-fn tritv_to_str(fn_ctxt fcx, &tritv::t v) -> str {\n-    auto s = \"\";\n-    auto comma = false;\n-    for (norm_constraint p in constraints(fcx)) {\n-        alt (tritv_get(v, p.bit_num)) {\n-            case (dont_care) { }\n-            case (?t) {\n-                s +=\n-                    if (comma) { \", \" } else { comma = true; \"\" } +\n-                    if (t == tfalse) { \"!\" } else { \"\" } +\n+fn tritv_to_str(fcx: fn_ctxt, v: &tritv::t) -> str {\n+    let s = \"\";\n+    let comma = false;\n+    for p: norm_constraint  in constraints(fcx) {\n+        alt tritv_get(v, p.bit_num) {\n+          dont_care. { }\n+          t {\n+            s +=\n+                if comma { \", \" } else { comma = true; \"\" } +\n+                    if t == tfalse { \"!\" } else { \"\" } +\n                     constraint_to_str(fcx.ccx.tcx, p.c);\n-            }\n+          }\n         }\n     }\n     ret s;\n }\n \n-fn log_tritv(&fn_ctxt fcx, &tritv::t v) { log tritv_to_str(fcx, v); }\n+fn log_tritv(fcx: &fn_ctxt, v: &tritv::t) { log tritv_to_str(fcx, v); }\n \n-fn first_difference_string(&fn_ctxt fcx, &tritv::t expected, &tritv::t actual)\n-   -> str {\n-    let str s = \"\";\n-    for (norm_constraint c in constraints(fcx)) {\n-        if (tritv_get(expected, c.bit_num) == ttrue &&\n-            tritv_get(actual, c.bit_num) != ttrue) {\n+fn first_difference_string(fcx: &fn_ctxt, expected: &tritv::t,\n+                           actual: &tritv::t) -> str {\n+    let s: str = \"\";\n+    for c: norm_constraint  in constraints(fcx) {\n+        if tritv_get(expected, c.bit_num) == ttrue &&\n+               tritv_get(actual, c.bit_num) != ttrue {\n             ret constraint_to_str(fcx.ccx.tcx, c.c);\n         }\n     }\n     ret s;\n }\n \n-fn log_tritv_err(fn_ctxt fcx, tritv::t v) { log_err tritv_to_str(fcx, v); }\n+fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) { log_err tritv_to_str(fcx, v); }\n \n-fn tos(&uint[] v) -> str {\n-    auto rslt = \"\";\n-    for (uint i in v) { if (i == 0u) { rslt += \"0\"; }\n-        else if (i == 1u) { rslt += \"1\"; }\n-        else { rslt += \"?\"; } }\n+fn tos(v: &uint[]) -> str {\n+    let rslt = \"\";\n+    for i: uint  in v {\n+        if i == 0u {\n+            rslt += \"0\";\n+        } else if (i == 1u) { rslt += \"1\"; } else { rslt += \"?\"; }\n+    }\n     ret rslt;\n }\n \n-fn log_cond(&uint[] v) { log tos(v); }\n+fn log_cond(v: &uint[]) { log tos(v); }\n \n-fn log_cond_err(&uint[] v) { log_err tos(v); }\n+fn log_cond_err(v: &uint[]) { log_err tos(v); }\n \n-fn log_pp(&pre_and_post pp) {\n-    auto p1 = tritv::to_vec(pp.precondition);\n-    auto p2 = tritv::to_vec(pp.postcondition);\n+fn log_pp(pp: &pre_and_post) {\n+    let p1 = tritv::to_vec(pp.precondition);\n+    let p2 = tritv::to_vec(pp.postcondition);\n     log \"pre:\";\n     log_cond(p1);\n     log \"post:\";\n     log_cond(p2);\n }\n \n-fn log_pp_err(&pre_and_post pp) {\n-    auto p1 = tritv::to_vec(pp.precondition);\n-    auto p2 = tritv::to_vec(pp.postcondition);\n+fn log_pp_err(pp: &pre_and_post) {\n+    let p1 = tritv::to_vec(pp.precondition);\n+    let p2 = tritv::to_vec(pp.postcondition);\n     log_err \"pre:\";\n     log_cond_err(p1);\n     log_err \"post:\";\n     log_cond_err(p2);\n }\n \n-fn log_states(&pre_and_post_state pp) {\n-    auto p1 = tritv::to_vec(pp.prestate);\n-    auto p2 = tritv::to_vec(pp.poststate);\n+fn log_states(pp: &pre_and_post_state) {\n+    let p1 = tritv::to_vec(pp.prestate);\n+    let p2 = tritv::to_vec(pp.poststate);\n     log \"prestate:\";\n     log_cond(p1);\n     log \"poststate:\";\n     log_cond(p2);\n }\n \n-fn log_states_err(&pre_and_post_state pp) {\n-    auto p1 = tritv::to_vec(pp.prestate);\n-    auto p2 = tritv::to_vec(pp.poststate);\n+fn log_states_err(pp: &pre_and_post_state) {\n+    let p1 = tritv::to_vec(pp.prestate);\n+    let p2 = tritv::to_vec(pp.poststate);\n     log_err \"prestate:\";\n     log_cond_err(p1);\n     log_err \"poststate:\";\n     log_cond_err(p2);\n }\n \n-fn print_ident(&ident i) { log \" \" + i + \" \"; }\n+fn print_ident(i: &ident) { log \" \" + i + \" \"; }\n \n-fn print_idents(&mutable ident[] idents) {\n-    if (ivec::len[ident](idents) == 0u) { ret; }\n+fn print_idents(idents: &mutable ident[]) {\n+    if ivec::len[ident](idents) == 0u { ret; }\n     log \"an ident: \" + ivec::pop[ident](idents);\n     print_idents(idents);\n }\n@@ -204,7 +206,7 @@ to represent predicate *arguments* however. This type\n \n Both types store an ident and span, for error-logging purposes.\n */\n-type pred_args_ = rec((@constr_arg_use)[] args, uint bit_num);\n+type pred_args_ = {args: (@constr_arg_use)[], bit_num: uint};\n \n type pred_args = spanned[pred_args_];\n \n@@ -214,9 +216,10 @@ type constr_arg_use = spanned[constr_arg_general_[inst]];\n \n tag constraint {\n     cinit(uint, span, ident);\n+\n     // FIXME: really only want it to be mutable during collect_locals.\n     // freeze it after that.\n-    cpred(path, @mutable (pred_args[]));\n+    cpred(path, @mutable pred_args[]);\n }\n \n // An ninit variant has a node_id because it refers to a local var.\n@@ -231,308 +234,307 @@ tag tsconstr {\n \n type sp_constr = spanned[tsconstr];\n \n-type norm_constraint = rec(uint bit_num, sp_constr c);\n+type norm_constraint = {bit_num: uint, c: sp_constr};\n \n type constr_map = @std::map::hashmap[def_id, constraint];\n \n-type fn_info = rec(constr_map constrs,\n-                   uint num_constraints,\n-                   controlflow cf,\n-                   /* list, accumulated during pre/postcondition\n-                    computation, of all local variables that may be\n-                    used*/\n-                   // Doesn't seem to work without the @ --\n-                   // bug?\n-                   @mutable node_id[] used_vars);\n-\n-fn tsconstr_to_def_id(&tsconstr t) -> def_id {\n-    alt (t) {\n-        case (ninit(?id,_)) { local_def(id) }\n-        case (npred(_,?id,_)) { id }\n-    }\n+type fn_info =\n+    /* list, accumulated during pre/postcondition\n+     computation, of all local variables that may be\n+     used*/\n+    // Doesn't seem to work without the @ --\n+    // bug?\n+    {constrs: constr_map,\n+     num_constraints: uint,\n+     cf: controlflow,\n+     used_vars: @mutable node_id[]};\n+\n+fn tsconstr_to_def_id(t: &tsconstr) -> def_id {\n+    alt t { ninit(id, _) { local_def(id) } npred(_, id, _) { id } }\n }\n \n /* mapping from node ID to typestate annotation */\n-type node_ann_table = @mutable ts_ann[mutable];\n+type node_ann_table = @mutable ts_ann[mutable ];\n \n \n /* mapping from function name to fn_info map */\n type fn_info_map = @std::map::hashmap[node_id, fn_info];\n \n-type fn_ctxt = rec(fn_info enclosing, node_id id, ident name, crate_ctxt ccx);\n+type fn_ctxt =\n+    {enclosing: fn_info, id: node_id, name: ident, ccx: crate_ctxt};\n \n-type crate_ctxt = rec(ty::ctxt tcx, node_ann_table node_anns, fn_info_map fm);\n+type crate_ctxt = {tcx: ty::ctxt, node_anns: node_ann_table, fm: fn_info_map};\n \n-fn get_fn_info(&crate_ctxt ccx, node_id id) -> fn_info {\n+fn get_fn_info(ccx: &crate_ctxt, id: node_id) -> fn_info {\n     assert (ccx.fm.contains_key(id));\n     ret ccx.fm.get(id);\n }\n \n-fn add_node(&crate_ctxt ccx, node_id i, &ts_ann a) {\n-    auto sz = ivec::len(*ccx.node_anns);\n-    if (sz <= i as uint) {\n+fn add_node(ccx: &crate_ctxt, i: node_id, a: &ts_ann) {\n+    let sz = ivec::len(*ccx.node_anns);\n+    if sz <= i as uint {\n         ivec::grow_mut(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n     }\n     ccx.node_anns.(i) = a;\n }\n \n-fn get_ts_ann(&crate_ctxt ccx, node_id i) -> option::t[ts_ann] {\n-    if (i as uint < ivec::len(*ccx.node_anns)) {\n+fn get_ts_ann(ccx: &crate_ctxt, i: node_id) -> option::t[ts_ann] {\n+    if i as uint < ivec::len(*ccx.node_anns) {\n         ret some[ts_ann](ccx.node_anns.(i));\n     } else { ret none[ts_ann]; }\n }\n \n \n /********* utils ********/\n-fn node_id_to_ts_ann(&crate_ctxt ccx, node_id id) -> ts_ann {\n-    alt (get_ts_ann(ccx, id)) {\n-        case (none) {\n-            log_err \"node_id_to_ts_ann: no ts_ann for node_id \" +\n-                int::str(id);\n-            fail;\n-        }\n-        case (some(?t)) { ret t; }\n+fn node_id_to_ts_ann(ccx: &crate_ctxt, id: node_id) -> ts_ann {\n+    alt get_ts_ann(ccx, id) {\n+      none. {\n+        log_err \"node_id_to_ts_ann: no ts_ann for node_id \" + int::str(id);\n+        fail;\n+      }\n+      some(t) { ret t; }\n     }\n }\n \n-fn node_id_to_poststate(&crate_ctxt ccx, node_id id) -> poststate {\n+fn node_id_to_poststate(ccx: &crate_ctxt, id: node_id) -> poststate {\n     log \"node_id_to_poststate\";\n     ret node_id_to_ts_ann(ccx, id).states.poststate;\n }\n \n-fn stmt_to_ann(&crate_ctxt ccx, &stmt s) -> ts_ann {\n+fn stmt_to_ann(ccx: &crate_ctxt, s: &stmt) -> ts_ann {\n     log \"stmt_to_ann\";\n-    alt (s.node) {\n-        case (stmt_decl(_, ?id)) { ret node_id_to_ts_ann(ccx, id); }\n-        case (stmt_expr(_, ?id)) { ret node_id_to_ts_ann(ccx, id); }\n-        case (stmt_crate_directive(_)) {\n-            log_err \"expecting an annotated statement here\";\n-            fail;\n-        }\n+    alt s.node {\n+      stmt_decl(_, id) { ret node_id_to_ts_ann(ccx, id); }\n+      stmt_expr(_, id) { ret node_id_to_ts_ann(ccx, id); }\n+      stmt_crate_directive(_) {\n+        log_err \"expecting an annotated statement here\";\n+        fail;\n+      }\n     }\n }\n \n \n /* fails if e has no annotation */\n-fn expr_states(&crate_ctxt ccx, @expr e) -> pre_and_post_state {\n+fn expr_states(ccx: &crate_ctxt, e: @expr) -> pre_and_post_state {\n     log \"expr_states\";\n     ret node_id_to_ts_ann(ccx, e.id).states;\n }\n \n \n /* fails if e has no annotation */\n-fn expr_pp(&crate_ctxt ccx, @expr e) -> pre_and_post {\n+fn expr_pp(ccx: &crate_ctxt, e: @expr) -> pre_and_post {\n     log \"expr_pp\";\n     ret node_id_to_ts_ann(ccx, e.id).conditions;\n }\n \n-fn stmt_pp(&crate_ctxt ccx, &stmt s) -> pre_and_post {\n+fn stmt_pp(ccx: &crate_ctxt, s: &stmt) -> pre_and_post {\n     ret stmt_to_ann(ccx, s).conditions;\n }\n \n \n /* fails if b has no annotation */\n-fn block_pp(&crate_ctxt ccx, &blk b) -> pre_and_post {\n+fn block_pp(ccx: &crate_ctxt, b: &blk) -> pre_and_post {\n     log \"block_pp\";\n     ret node_id_to_ts_ann(ccx, b.node.id).conditions;\n }\n \n-fn clear_pp(pre_and_post pp) {\n+fn clear_pp(pp: pre_and_post) {\n     ann::clear(pp.precondition);\n     ann::clear(pp.postcondition);\n }\n \n-fn clear_precond(&crate_ctxt ccx, node_id id) {\n-    auto pp = node_id_to_ts_ann(ccx, id);\n+fn clear_precond(ccx: &crate_ctxt, id: node_id) {\n+    let pp = node_id_to_ts_ann(ccx, id);\n     ann::clear(pp.conditions.precondition);\n }\n \n-fn block_states(&crate_ctxt ccx, &blk b) -> pre_and_post_state {\n+fn block_states(ccx: &crate_ctxt, b: &blk) -> pre_and_post_state {\n     log \"block_states\";\n     ret node_id_to_ts_ann(ccx, b.node.id).states;\n }\n \n-fn stmt_states(&crate_ctxt ccx, &stmt s) -> pre_and_post_state {\n+fn stmt_states(ccx: &crate_ctxt, s: &stmt) -> pre_and_post_state {\n     ret stmt_to_ann(ccx, s).states;\n }\n \n-fn expr_precond(&crate_ctxt ccx, @expr e) -> precond {\n+fn expr_precond(ccx: &crate_ctxt, e: @expr) -> precond {\n     ret expr_pp(ccx, e).precondition;\n }\n \n-fn expr_postcond(&crate_ctxt ccx, @expr e) -> postcond {\n+fn expr_postcond(ccx: &crate_ctxt, e: @expr) -> postcond {\n     ret expr_pp(ccx, e).postcondition;\n }\n \n-fn expr_prestate(&crate_ctxt ccx, @expr e) -> prestate {\n+fn expr_prestate(ccx: &crate_ctxt, e: @expr) -> prestate {\n     ret expr_states(ccx, e).prestate;\n }\n \n-fn expr_poststate(&crate_ctxt ccx, @expr e) -> poststate {\n+fn expr_poststate(ccx: &crate_ctxt, e: @expr) -> poststate {\n     ret expr_states(ccx, e).poststate;\n }\n \n-fn stmt_precond(&crate_ctxt ccx, &stmt s) -> precond {\n+fn stmt_precond(ccx: &crate_ctxt, s: &stmt) -> precond {\n     ret stmt_pp(ccx, s).precondition;\n }\n \n-fn stmt_postcond(&crate_ctxt ccx, &stmt s) -> postcond {\n+fn stmt_postcond(ccx: &crate_ctxt, s: &stmt) -> postcond {\n     ret stmt_pp(ccx, s).postcondition;\n }\n \n-fn states_to_poststate(&pre_and_post_state ss) -> poststate {\n+fn states_to_poststate(ss: &pre_and_post_state) -> poststate {\n     ret ss.poststate;\n }\n \n-fn stmt_prestate(&crate_ctxt ccx, &stmt s) -> prestate {\n+fn stmt_prestate(ccx: &crate_ctxt, s: &stmt) -> prestate {\n     ret stmt_states(ccx, s).prestate;\n }\n \n-fn stmt_poststate(&crate_ctxt ccx, &stmt s) -> poststate {\n+fn stmt_poststate(ccx: &crate_ctxt, s: &stmt) -> poststate {\n     ret stmt_states(ccx, s).poststate;\n }\n \n-fn block_precond(&crate_ctxt ccx, &blk b) -> precond {\n+fn block_precond(ccx: &crate_ctxt, b: &blk) -> precond {\n     ret block_pp(ccx, b).precondition;\n }\n \n-fn block_postcond(&crate_ctxt ccx, &blk b) -> postcond {\n+fn block_postcond(ccx: &crate_ctxt, b: &blk) -> postcond {\n     ret block_pp(ccx, b).postcondition;\n }\n \n-fn block_prestate(&crate_ctxt ccx, &blk b) -> prestate {\n+fn block_prestate(ccx: &crate_ctxt, b: &blk) -> prestate {\n     ret block_states(ccx, b).prestate;\n }\n \n-fn block_poststate(&crate_ctxt ccx, &blk b) -> poststate {\n+fn block_poststate(ccx: &crate_ctxt, b: &blk) -> poststate {\n     ret block_states(ccx, b).poststate;\n }\n \n-fn set_prestate_ann(&crate_ctxt ccx, node_id id, &prestate pre) -> bool {\n+fn set_prestate_ann(ccx: &crate_ctxt, id: node_id, pre: &prestate) -> bool {\n     log \"set_prestate_ann\";\n     ret set_prestate(node_id_to_ts_ann(ccx, id), pre);\n }\n \n-fn extend_prestate_ann(&crate_ctxt ccx, node_id id, &prestate pre) -> bool {\n+fn extend_prestate_ann(ccx: &crate_ctxt, id: node_id, pre: &prestate) ->\n+   bool {\n     log \"extend_prestate_ann\";\n     ret extend_prestate(node_id_to_ts_ann(ccx, id).states.prestate, pre);\n }\n \n-fn set_poststate_ann(&crate_ctxt ccx, node_id id, &poststate post) -> bool {\n+fn set_poststate_ann(ccx: &crate_ctxt, id: node_id, post: &poststate) ->\n+   bool {\n     log \"set_poststate_ann\";\n     ret set_poststate(node_id_to_ts_ann(ccx, id), post);\n }\n \n-fn extend_poststate_ann(&crate_ctxt ccx, node_id id, &poststate post)\n-    -> bool {\n+fn extend_poststate_ann(ccx: &crate_ctxt, id: node_id, post: &poststate) ->\n+   bool {\n     log \"extend_poststate_ann\";\n     ret extend_poststate(node_id_to_ts_ann(ccx, id).states.poststate, post);\n }\n \n-fn set_pre_and_post(&crate_ctxt ccx, node_id id, &precond pre,\n-                    &postcond post) {\n+fn set_pre_and_post(ccx: &crate_ctxt, id: node_id, pre: &precond,\n+                    post: &postcond) {\n     log \"set_pre_and_post\";\n-    auto t = node_id_to_ts_ann(ccx, id);\n+    let t = node_id_to_ts_ann(ccx, id);\n     set_precondition(t, pre);\n     set_postcondition(t, post);\n }\n \n-fn copy_pre_post(&crate_ctxt ccx, node_id id, &@expr sub) {\n+fn copy_pre_post(ccx: &crate_ctxt, id: node_id, sub: &@expr) {\n     log \"set_pre_and_post\";\n-    auto p = expr_pp(ccx, sub);\n+    let p = expr_pp(ccx, sub);\n     copy_pre_post_(ccx, id, p.precondition, p.postcondition);\n }\n \n-fn copy_pre_post_(&crate_ctxt ccx, node_id id, &prestate pre,\n-                  &poststate post) {\n+fn copy_pre_post_(ccx: &crate_ctxt, id: node_id, pre: &prestate,\n+                  post: &poststate) {\n     log \"set_pre_and_post\";\n-    auto t = node_id_to_ts_ann(ccx, id);\n+    let t = node_id_to_ts_ann(ccx, id);\n     set_precondition(t, pre);\n     set_postcondition(t, post);\n }\n \n /* sets all bits to *1* */\n-fn set_postcond_false(&crate_ctxt ccx, node_id id) {\n-    auto p = node_id_to_ts_ann(ccx, id);\n+fn set_postcond_false(ccx: &crate_ctxt, id: node_id) {\n+    let p = node_id_to_ts_ann(ccx, id);\n     ann::set(p.conditions.postcondition);\n }\n \n-fn pure_exp(&crate_ctxt ccx, node_id id, &prestate p) -> bool {\n-    ret set_prestate_ann(ccx, id, p) |\n-        set_poststate_ann(ccx, id, p);\n+fn pure_exp(ccx: &crate_ctxt, id: node_id, p: &prestate) -> bool {\n+    ret set_prestate_ann(ccx, id, p) | set_poststate_ann(ccx, id, p);\n }\n \n-fn num_constraints(fn_info m) -> uint { ret m.num_constraints; }\n+fn num_constraints(m: fn_info) -> uint { ret m.num_constraints; }\n \n-fn new_crate_ctxt(ty::ctxt cx) -> crate_ctxt {\n-    let ts_ann[mutable] na = ~[mutable];\n-    ret rec(tcx=cx, node_anns=@mutable na, fm=@new_int_hash[fn_info]());\n+fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n+    let na: ts_ann[mutable ] = ~[mutable ];\n+    ret {tcx: cx, node_anns: @mutable na, fm: @new_int_hash[fn_info]()};\n }\n \n /* Use e's type to determine whether it returns.\n  If it has a function type with a ! annotation,\n the answer is noreturn. */\n-fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n-    alt (ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, e.id))) {\n-        case (ty::ty_fn(_, _, _, ?cf, _)) { ret cf; }\n-        case (_) { ret return; }\n+fn controlflow_expr(ccx: &crate_ctxt, e: @expr) -> controlflow {\n+    alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, e.id)) {\n+      ty::ty_fn(_, _, _, cf, _) { ret cf; }\n+      _ { ret return; }\n     }\n }\n \n-fn constraints_expr(&ty::ctxt cx, @expr e) -> (@ty::constr)[] {\n-    alt (ty::struct(cx, ty::node_id_to_type(cx, e.id))) {\n-        case (ty::ty_fn(_, _, _, _, ?cs)) { ret cs; }\n-        case (_) { ret ~[]; }\n+fn constraints_expr(cx: &ty::ctxt, e: @expr) -> (@ty::constr)[] {\n+    alt ty::struct(cx, ty::node_id_to_type(cx, e.id)) {\n+      ty::ty_fn(_, _, _, _, cs) { ret cs; }\n+      _ { ret ~[]; }\n     }\n }\n \n-fn node_id_to_def_upvar_strict(&fn_ctxt cx, node_id id) -> def {\n-    alt (freevars::def_lookup(cx.ccx.tcx, cx.id, id)) {\n-        case (none) {\n-            log_err \"node_id_to_def: node_id \" + int::str(id) + \" has no def\";\n-            fail;\n-        }\n-        case (some(?d)) { ret d; }\n+fn node_id_to_def_upvar_strict(cx: &fn_ctxt, id: node_id) -> def {\n+    alt freevars::def_lookup(cx.ccx.tcx, cx.id, id) {\n+      none. {\n+        log_err \"node_id_to_def: node_id \" + int::str(id) + \" has no def\";\n+        fail;\n+      }\n+      some(d) { ret d; }\n     }\n }\n-fn node_id_to_def_strict(&ty::ctxt cx, node_id id) -> def {\n-    alt (cx.def_map.find(id)) {\n-        case (none) {\n-            log_err \"node_id_to_def: node_id \" + int::str(id) + \" has no def\";\n-            fail;\n-        }\n-        case (some(?d)) { ret d; }\n+fn node_id_to_def_strict(cx: &ty::ctxt, id: node_id) -> def {\n+    alt cx.def_map.find(id) {\n+      none. {\n+        log_err \"node_id_to_def: node_id \" + int::str(id) + \" has no def\";\n+        fail;\n+      }\n+      some(d) { ret d; }\n     }\n }\n \n-fn node_id_to_def(&crate_ctxt ccx, node_id id) -> option::t[def] {\n+fn node_id_to_def(ccx: &crate_ctxt, id: node_id) -> option::t[def] {\n     ret ccx.tcx.def_map.find(id);\n }\n \n-fn norm_a_constraint(def_id id, &constraint c) -> norm_constraint[] {\n-    alt (c) {\n-        case (cinit(?n, ?sp, ?i)) {\n-            ret ~[rec(bit_num=n, c=respan(sp, ninit(id.node, i)))];\n-        }\n-        case (cpred(?p, ?descs)) {\n-            let norm_constraint[] rslt = ~[];\n-            for (pred_args pd in *descs) {\n-                rslt += ~[rec(bit_num=pd.node.bit_num,\n-                              c=respan(pd.span,\n-                                       npred(p, id, pd.node.args)))];\n-            }\n-            ret rslt;\n+fn norm_a_constraint(id: def_id, c: &constraint) -> norm_constraint[] {\n+    alt c {\n+      cinit(n, sp, i) {\n+        ret ~[{bit_num: n, c: respan(sp, ninit(id.node, i))}];\n+      }\n+      cpred(p, descs) {\n+        let rslt: norm_constraint[] = ~[];\n+        for pd: pred_args  in *descs {\n+            rslt +=\n+                ~[{bit_num: pd.node.bit_num,\n+                   c: respan(pd.span, npred(p, id, pd.node.args))}];\n         }\n+        ret rslt;\n+      }\n     }\n }\n \n \n // Tried to write this as an iterator, but I got a\n // non-exhaustive match in trans.\n-fn constraints(&fn_ctxt fcx) -> norm_constraint[] {\n-    let norm_constraint[] rslt = ~[];\n-    for each (@rec(def_id key, constraint val) p\n-              in fcx.enclosing.constrs.items()) {\n+fn constraints(fcx: &fn_ctxt) -> norm_constraint[] {\n+    let rslt: norm_constraint[] = ~[];\n+    for each p: @{key: def_id, val: constraint}  in\n+             fcx.enclosing.constrs.items() {\n         rslt += norm_a_constraint(p.key, p.val);\n     }\n     ret rslt;\n@@ -541,254 +543,225 @@ fn constraints(&fn_ctxt fcx) -> norm_constraint[] {\n // FIXME\n // Would rather take an immutable vec as an argument,\n // should freeze it at some earlier point.\n-fn match_args(&fn_ctxt fcx, &(@mutable pred_args[]) occs,\n-              &(@constr_arg_use)[] occ) ->\n-   uint {\n+fn match_args(fcx: &fn_ctxt, occs: &@mutable pred_args[],\n+              occ: &(@constr_arg_use)[]) -> uint {\n     log \"match_args: looking at \" +\n-        constr_args_to_str(fn(&inst i) -> str { ret i.ident; }, occ);\n-    for (pred_args pd in *occs) {\n+            constr_args_to_str(fn (i: &inst) -> str { ret i.ident; }, occ);\n+    for pd: pred_args  in *occs {\n         log \"match_args: candidate \" + pred_args_to_str(pd);\n-        fn eq(&inst p, &inst q) -> bool {\n-            ret p.node == q.node;\n-        }\n-        if (ty::args_eq(eq, pd.node.args, occ)) { ret pd.node.bit_num; }\n+        fn eq(p: &inst, q: &inst) -> bool { ret p.node == q.node; }\n+        if ty::args_eq(eq, pd.node.args, occ) { ret pd.node.bit_num; }\n     }\n     fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");\n }\n \n-fn def_id_for_constr(ty::ctxt tcx, node_id t) -> def_id {\n-    alt (tcx.def_map.find(t)) {\n-        case (none) {\n-            tcx.sess.bug(\"node_id_for_constr: bad node_id \" + int::str(t));\n-        }\n-        case (some(def_fn(?i,_))) { ret i; }\n-        case (_) {\n-            tcx.sess.bug(\"node_id_for_constr: pred is not a function\");\n-        }\n+fn def_id_for_constr(tcx: ty::ctxt, t: node_id) -> def_id {\n+    alt tcx.def_map.find(t) {\n+      none. {\n+        tcx.sess.bug(\"node_id_for_constr: bad node_id \" + int::str(t));\n+      }\n+      some(def_fn(i, _)) { ret i; }\n+      _ { tcx.sess.bug(\"node_id_for_constr: pred is not a function\"); }\n     }\n }\n \n-fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n-    alt (e.node) {\n-        case (expr_path(?p)) {\n-            alt (tcx.def_map.find(e.id)) {\n-                case (some(def_local(?l_id))) {\n-                    ret @respan(p.span,\n-                                carg_ident(rec(ident=p.node.idents.(0),\n-                                               node=l_id.node)));\n-                }\n-                case (some(def_arg(?a_id))) {\n-                    ret @respan(p.span,\n-                                carg_ident(rec(ident=p.node.idents.(0),\n-                                               node=a_id.node)));\n-                }\n-                case (_) {\n-                    tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n-                                 \"as pred arg\");\n-\n-                }\n-            }\n-        }\n-        case (expr_lit(?l)) { ret @respan(e.span, carg_lit(l)); }\n-        case (_) {\n-            tcx.sess.span_fatal(e.span,\n-                              \"Arguments to constrained functions must be \"\n-                              + \"literals or local variables\");\n+fn expr_to_constr_arg(tcx: ty::ctxt, e: &@expr) -> @constr_arg_use {\n+    alt e.node {\n+      expr_path(p) {\n+        alt tcx.def_map.find(e.id) {\n+          some(def_local(l_id)) {\n+            ret @respan(p.span,\n+                        carg_ident({ident: p.node.idents.(0),\n+                                    node: l_id.node}));\n+          }\n+          some(def_arg(a_id)) {\n+            ret @respan(p.span,\n+                        carg_ident({ident: p.node.idents.(0),\n+                                    node: a_id.node}));\n+          }\n+          _ {\n+            tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n+                             \"as pred arg\");\n+\n+          }\n         }\n+      }\n+      expr_lit(l) { ret @respan(e.span, carg_lit(l)); }\n+      _ {\n+        tcx.sess.span_fatal(e.span,\n+                            \"Arguments to constrained functions must be \" +\n+                                \"literals or local variables\");\n+      }\n     }\n }\n \n-fn exprs_to_constr_args(ty::ctxt tcx, &(@expr)[] args)\n-    -> (@constr_arg_use)[] {\n-    auto f = bind expr_to_constr_arg(tcx, _);\n-    let (@constr_arg_use)[] rslt = ~[];\n-    for (@expr e in args) {\n-        rslt += ~[f(e)];\n-    }\n+fn exprs_to_constr_args(tcx: ty::ctxt, args: &(@expr)[]) ->\n+   (@constr_arg_use)[] {\n+    let f = bind expr_to_constr_arg(tcx, _);\n+    let rslt: (@constr_arg_use)[] = ~[];\n+    for e: @expr  in args { rslt += ~[f(e)]; }\n     rslt\n }\n \n-fn expr_to_constr(ty::ctxt tcx, &@expr e) -> sp_constr {\n-    alt (e.node) {\n-        case (\n-             // FIXME change the first pattern to expr_path to test a\n-             // typechecker bug\n-             expr_call(?operator, ?args)) {\n-            alt (operator.node) {\n-                case (expr_path(?p)) {\n-                    ret respan(e.span,\n-                               npred(p, def_id_for_constr(tcx, operator.id),\n-                                     exprs_to_constr_args(tcx, args)));\n-                }\n-                case (_) {\n-                    tcx.sess.span_fatal(operator.span,\n-                                      \"Internal error: \" +\n-                                          \" ill-formed operator \\\n+fn expr_to_constr(tcx: ty::ctxt, e: &@expr) -> sp_constr {\n+    alt e.node {\n+\n+      // FIXME change the first pattern to expr_path to test a\n+      // typechecker bug\n+      expr_call(operator, args) {\n+        alt operator.node {\n+          expr_path(p) {\n+            ret respan(e.span,\n+                       npred(p, def_id_for_constr(tcx, operator.id),\n+                             exprs_to_constr_args(tcx, args)));\n+          }\n+          _ {\n+            tcx.sess.span_fatal(operator.span,\n+                                \"Internal error: \" +\n+                                    \" ill-formed operator \\\n                                             in predicate\");\n-                }\n-            }\n-        }\n-        case (_) {\n-            tcx.sess.span_fatal(e.span,\n-                              \"Internal error: \" + \" ill-formed predicate\");\n+          }\n         }\n+      }\n+      _ {\n+        tcx.sess.span_fatal(e.span,\n+                            \"Internal error: \" + \" ill-formed predicate\");\n+      }\n     }\n }\n \n-fn pred_args_to_str(&pred_args p) -> str {\n+fn pred_args_to_str(p: &pred_args) -> str {\n     \"<\" + uint::str(p.node.bit_num) + \", \" +\n-        constr_args_to_str(fn(&inst i) -> str { ret i.ident; },\n-                           p.node.args) + \">\"\n+        constr_args_to_str(fn (i: &inst) -> str { ret i.ident; }, p.node.args)\n+        + \">\"\n }\n \n-fn substitute_constr_args(&ty::ctxt cx, &(@expr)[] actuals,\n-                          &@ty::constr c) -> tsconstr {\n-    let (@constr_arg_use)[] rslt = ~[];\n-    for (@constr_arg a in c.node.args) {\n+fn substitute_constr_args(cx: &ty::ctxt, actuals: &(@expr)[], c: &@ty::constr)\n+   -> tsconstr {\n+    let rslt: (@constr_arg_use)[] = ~[];\n+    for a: @constr_arg  in c.node.args {\n         rslt += ~[substitute_arg(cx, actuals, a)];\n     }\n     ret npred(c.node.path, c.node.id, rslt);\n }\n \n-fn substitute_arg(&ty::ctxt cx, &(@expr)[] actuals, @constr_arg a) ->\n+fn substitute_arg(cx: &ty::ctxt, actuals: &(@expr)[], a: @constr_arg) ->\n    @constr_arg_use {\n-    auto num_actuals = ivec::len(actuals);\n-    alt (a.node) {\n-        case (carg_ident(?i)) {\n-            if (i < num_actuals) {\n-                ret expr_to_constr_arg(cx, actuals.(i));\n-            } else {\n-                cx.sess.span_fatal(a.span,\n-                                   \"Constraint argument out of bounds\");\n-            }\n+    let num_actuals = ivec::len(actuals);\n+    alt a.node {\n+      carg_ident(i) {\n+        if i < num_actuals {\n+            ret expr_to_constr_arg(cx, actuals.(i));\n+        } else {\n+            cx.sess.span_fatal(a.span, \"Constraint argument out of bounds\");\n         }\n-        case (carg_base) { ret @respan(a.span, carg_base); }\n-        case (carg_lit(?l)) { ret @respan(a.span, carg_lit(l)); }\n+      }\n+      carg_base. { ret @respan(a.span, carg_base); }\n+      carg_lit(l) { ret @respan(a.span, carg_lit(l)); }\n     }\n }\n \n-fn pred_args_matches(&(constr_arg_general_[inst])[] pattern,\n-                     &pred_args desc) -> bool {\n-    auto i = 0u;\n-    for (@constr_arg_use c in desc.node.args) {\n-        auto n = pattern.(i);\n-        alt (c.node) {\n-            case (carg_ident(?p)) {\n-                alt (n) {\n-                    case (carg_ident(?q)) {\n-                        if (p.node != q.node) {\n-                            ret false;\n-                        }\n-                    }\n-                    case (_) { ret false; }\n-                }\n+fn pred_args_matches(pattern: &(constr_arg_general_[inst])[],\n+                     desc: &pred_args) -> bool {\n+    let i = 0u;\n+    for c: @constr_arg_use  in desc.node.args {\n+        let n = pattern.(i);\n+        alt c.node {\n+          carg_ident(p) {\n+            alt n {\n+              carg_ident(q) { if p.node != q.node { ret false; } }\n+              _ { ret false; }\n             }\n-            case (carg_base) {\n-                if (n != carg_base) {\n-                    ret false;\n-                }\n-            }\n-            case (carg_lit(?l)) {\n-                alt (n) {\n-                    case (carg_lit(?m)) {\n-                        if (!lit_eq(l, m)) {\n-                            ret false;\n-                        }\n-                    }\n-                    case (_) { ret false; }\n-                }\n+          }\n+          carg_base. { if n != carg_base { ret false; } }\n+          carg_lit(l) {\n+            alt n {\n+              carg_lit(m) { if !lit_eq(l, m) { ret false; } }\n+              _ { ret false; }\n             }\n+          }\n         }\n         i += 1u;\n     }\n     ret true;\n }\n \n-fn find_instance_(&(constr_arg_general_[inst])[] pattern,\n-                  &pred_args[] descs) -> option::t[uint] {\n-    for (pred_args d in descs) {\n-        if (pred_args_matches(pattern, d)) {\n-            ret some(d.node.bit_num);\n-        }\n+fn find_instance_(pattern: &(constr_arg_general_[inst])[],\n+                  descs: &pred_args[]) -> option::t[uint] {\n+    for d: pred_args  in descs {\n+        if pred_args_matches(pattern, d) { ret some(d.node.bit_num); }\n     }\n     ret none;\n }\n \n-type inst = rec(ident ident, node_id node);\n-type subst = rec(inst from, inst to)[];\n+type inst = {ident: ident, node: node_id};\n+type subst = {from: inst, to: inst}[];\n \n-fn find_instances(&fn_ctxt fcx, &subst subst, &constraint c)\n-        -> (rec(uint from, uint to))[] {\n+fn find_instances(fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n+   {from: uint, to: uint}[] {\n \n-    auto rslt = ~[];\n-    if (ivec::len(subst) == 0u) {\n-        ret rslt;\n-    }\n+    let rslt = ~[];\n+    if ivec::len(subst) == 0u { ret rslt; }\n \n-    alt (c) {\n-        case (cinit(_,_,_)) { /* this is dealt with separately */ }\n-        case (cpred(?p, ?descs)) {\n-            for (pred_args d in *descs) {\n-                if (args_mention(d.node.args, find_in_subst_bool, subst)) {\n-                    auto old_bit_num = d.node.bit_num;\n-                    auto new = replace(subst, d);\n-                    alt (find_instance_(new, *descs)) {\n-                        case (some(?d1)) {\n-                            rslt += ~[rec(from=old_bit_num, to=d1)];\n-                        }\n-                        case (_) { }\n-                    }\n+    alt c {\n+      cinit(_, _, _) {/* this is dealt with separately */ }\n+      cpred(p, descs) {\n+        for d: pred_args  in *descs {\n+            if args_mention(d.node.args, find_in_subst_bool, subst) {\n+                let old_bit_num = d.node.bit_num;\n+                let new = replace(subst, d);\n+                alt find_instance_(new, *descs) {\n+                  some(d1) { rslt += ~[{from: old_bit_num, to: d1}]; }\n+                  _ { }\n                 }\n             }\n         }\n+      }\n     }\n     rslt\n }\n \n-fn find_in_subst(node_id id, &subst s) -> option::t[inst] {\n-    for (rec(inst from, inst to) p in s) {\n-        if (id == p.from.node) {\n-            ret some(p.to);\n-        }\n+fn find_in_subst(id: node_id, s: &subst) -> option::t[inst] {\n+    for p: {from: inst, to: inst}  in s {\n+        if id == p.from.node { ret some(p.to); }\n     }\n     ret none;\n }\n \n-fn find_in_subst_bool(&subst s, node_id id) -> bool {\n+fn find_in_subst_bool(s: &subst, id: node_id) -> bool {\n     is_some(find_in_subst(id, s))\n }\n \n-fn insts_to_str(&(constr_arg_general_[inst])[] stuff) -> str {\n-    auto rslt = \"<\";\n-    for (constr_arg_general_[inst] i in stuff) {\n-        rslt += \" \" + alt(i) {\n-            case (carg_ident(?p)) { p.ident }\n-            case (carg_base) { \"*\" }\n-            case (carg_lit(_)) { \"[lit]\" } } + \" \";\n+fn insts_to_str(stuff: &(constr_arg_general_[inst])[]) -> str {\n+    let rslt = \"<\";\n+    for i: constr_arg_general_[inst]  in stuff {\n+        rslt +=\n+            \" \" +\n+                alt i {\n+                  carg_ident(p) { p.ident }\n+                  carg_base. { \"*\" }\n+                  carg_lit(_) { \"[lit]\" }\n+                } + \" \";\n     }\n     rslt += \">\";\n     rslt\n }\n \n-fn replace(subst subst, pred_args d) -> (constr_arg_general_[inst])[] {\n-    let (constr_arg_general_[inst])[] rslt = ~[];\n-    for (@constr_arg_use c in d.node.args) {\n-        alt (c.node) {\n-            case (carg_ident(?p)) {\n-                alt (find_in_subst(p.node, subst)) {\n-                    case (some(?new)) {\n-                        rslt += ~[carg_ident(new)];\n-                    }\n-                    case (_) {\n-                        rslt += ~[c.node];\n-                    }\n-                }\n-            }\n-            case (_) {\n-                //  log_err \"##\";\n-                rslt += ~[c.node];\n+fn replace(subst: subst, d: pred_args) -> (constr_arg_general_[inst])[] {\n+    let rslt: (constr_arg_general_[inst])[] = ~[];\n+    for c: @constr_arg_use  in d.node.args {\n+        alt c.node {\n+          carg_ident(p) {\n+            alt find_in_subst(p.node, subst) {\n+              some(new) { rslt += ~[carg_ident(new)]; }\n+              _ { rslt += ~[c.node]; }\n             }\n-         }\n+          }\n+          _ {\n+            //  log_err \"##\";\n+            rslt += ~[c.node];\n+          }\n+        }\n     }\n \n     /*\n@@ -805,69 +778,65 @@ fn replace(subst subst, pred_args d) -> (constr_arg_general_[inst])[] {\n     ret rslt;\n }\n \n-fn path_to_ident(&ty::ctxt cx, &path p) -> ident {\n-    alt (ivec::last(p.node.idents)) {\n-        case (none) { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n-        case (some(?i)) { ret i; }\n+fn path_to_ident(cx: &ty::ctxt, p: &path) -> ident {\n+    alt ivec::last(p.node.idents) {\n+      none. { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n+      some(i) { ret i; }\n     }\n }\n \n-tag if_ty {\n-    if_check;\n-    plain_if;\n-}\n+tag if_ty { if_check; plain_if; }\n \n-fn local_node_id_to_def_id_strict(&fn_ctxt fcx, &span sp, &node_id i)\n-    -> def_id {\n-    alt (local_node_id_to_def(fcx, i)) {\n-        case (some(def_local(?d_id))) {\n-            ret d_id;\n-        }\n-        case (some (def_arg(?a_id))) {\n-            ret a_id;\n-        }\n-        case (some(_)) {\n-            fcx.ccx.tcx.sess.span_fatal(sp, \"local_node_id_to_def_id: id \\\n+fn local_node_id_to_def_id_strict(fcx: &fn_ctxt, sp: &span, i: &node_id) ->\n+   def_id {\n+    alt local_node_id_to_def(fcx, i) {\n+      some(def_local(d_id)) { ret d_id; }\n+      some(def_arg(a_id)) { ret a_id; }\n+      some(_) {\n+        fcx.ccx.tcx.sess.span_fatal(sp,\n+                                    \"local_node_id_to_def_id: id \\\n                isn't a local\");\n-        }\n-        case (none) {\n-            // should really be bug. span_bug()?\n-            fcx.ccx.tcx.sess.span_fatal(sp, \"local_node_id_to_def_id: id \\\n+      }\n+      none. {\n+        // should really be bug. span_bug()?\n+        fcx.ccx.tcx.sess.span_fatal(sp,\n+                                    \"local_node_id_to_def_id: id \\\n                is unbound\");\n-        }\n+      }\n     }\n }\n \n-fn local_node_id_to_def(&fn_ctxt fcx, &node_id i) -> option::t[def]\n-  { fcx.ccx.tcx.def_map.find(i) }\n+fn local_node_id_to_def(fcx: &fn_ctxt, i: &node_id) -> option::t[def] {\n+    fcx.ccx.tcx.def_map.find(i)\n+}\n \n-fn local_node_id_to_def_id(&fn_ctxt fcx, &node_id i) -> option::t[def_id] {\n-    alt (local_node_id_to_def(fcx, i)) {\n-        case (some(def_local(?d_id))) { some(d_id) }\n-        case (some (def_arg(?a_id)))  { some(a_id) }\n-        case (_)                      { none }\n+fn local_node_id_to_def_id(fcx: &fn_ctxt, i: &node_id) -> option::t[def_id] {\n+    alt local_node_id_to_def(fcx, i) {\n+      some(def_local(d_id)) { some(d_id) }\n+      some(def_arg(a_id)) { some(a_id) }\n+      _ { none }\n     }\n }\n \n-fn local_node_id_to_local_def_id(&fn_ctxt fcx, &node_id i)\n-    -> option::t[node_id] {\n-    alt (local_node_id_to_def(fcx, i)) {\n-        case (some (def_local(?d_id))) { some(d_id.node) }\n-        case (some (def_arg(?a_id)))  { some(a_id.node) }\n-        case (_)                      { none }\n+fn local_node_id_to_local_def_id(fcx: &fn_ctxt, i: &node_id) ->\n+   option::t[node_id] {\n+    alt local_node_id_to_def(fcx, i) {\n+      some(def_local(d_id)) { some(d_id.node) }\n+      some(def_arg(a_id)) { some(a_id.node) }\n+      _ { none }\n     }\n }\n \n-fn copy_in_postcond(&fn_ctxt fcx, node_id parent_exp, inst dest, inst src,\n-                    oper_type ty) {\n-    auto post = node_id_to_ts_ann(fcx.ccx, parent_exp).conditions.\n-        postcondition;\n+fn copy_in_postcond(fcx: &fn_ctxt, parent_exp: node_id, dest: inst, src: inst,\n+                    ty: oper_type) {\n+    let post =\n+        node_id_to_ts_ann(fcx.ccx, parent_exp).conditions.postcondition;\n     copy_in_poststate_two(fcx, post, post, dest, src, ty);\n }\n \n // FIXME refactor\n-fn copy_in_poststate(&fn_ctxt fcx, &poststate post, inst dest, inst src,\n-                     oper_type ty) {\n+fn copy_in_poststate(fcx: &fn_ctxt, post: &poststate, dest: inst, src: inst,\n+                     ty: oper_type) {\n     copy_in_poststate_two(fcx, post, post, dest, src, ty);\n }\n \n@@ -876,30 +845,26 @@ fn copy_in_poststate(&fn_ctxt fcx, &poststate post, inst dest, inst src,\n // dest substituted for src.\n // (This doesn't create any new constraints. If a new, substituted\n // constraint isn't already in the bit vector, it's ignored.)\n-fn copy_in_poststate_two(&fn_ctxt fcx, &poststate src_post,\n-                         &poststate target_post, inst dest, inst src,\n-                         oper_type ty) {\n-    auto subst;\n-    alt (ty) {\n-        case (oper_swap) {\n-            subst = ~[rec(from=dest, to=src),\n-                      rec(from=src, to=dest)];\n-        }\n-        case (oper_assign_op) {\n-            ret; // Don't do any propagation\n-        }\n-        case (_) {\n-            subst = ~[rec(from=src, to=dest)];\n-        }\n+fn copy_in_poststate_two(fcx: &fn_ctxt, src_post: &poststate,\n+                         target_post: &poststate, dest: inst, src: inst,\n+                         ty: oper_type) {\n+    let subst;\n+    alt ty {\n+      oper_swap. { subst = ~[{from: dest, to: src}, {from: src, to: dest}]; }\n+      oper_assign_op. {\n+        ret; // Don't do any propagation\n+      }\n+      _ { subst = ~[{from: src, to: dest}]; }\n     }\n \n-    for each (@rec(def_id key, constraint val) p in\n-              fcx.enclosing.constrs.items()) {\n+\n+    for each p: @{key: def_id, val: constraint}  in\n+             fcx.enclosing.constrs.items() {\n         // replace any occurrences of the src def_id with the\n         // dest def_id\n-        auto insts = find_instances(fcx, subst, p.val);\n-        for (rec(uint from, uint to) p in insts) {\n-            if (promises_(p.from, src_post)) {\n+        let insts = find_instances(fcx, subst, p.val);\n+        for p: {from: uint, to: uint}  in insts {\n+            if promises_(p.from, src_post) {\n                 set_in_poststate_(p.to, target_post);\n             }\n         }\n@@ -908,108 +873,104 @@ fn copy_in_poststate_two(&fn_ctxt fcx, &poststate src_post,\n \n \n /* FIXME should refactor this better */\n-fn forget_in_postcond(&fn_ctxt fcx, node_id parent_exp, node_id dead_v) {\n+fn forget_in_postcond(fcx: &fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n     // In the postcondition given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n-    auto d = local_node_id_to_local_def_id(fcx, dead_v);\n-    alt (d) {\n-        case (some(?d_id)) {\n-            for (norm_constraint c in constraints(fcx)) {\n-                if (constraint_mentions(fcx, c, d_id)) {\n-                    clear_in_postcond(c.bit_num,\n-                      node_id_to_ts_ann(fcx.ccx, parent_exp).conditions);\n-                }\n+    let d = local_node_id_to_local_def_id(fcx, dead_v);\n+    alt d {\n+      some(d_id) {\n+        for c: norm_constraint  in constraints(fcx) {\n+            if constraint_mentions(fcx, c, d_id) {\n+                clear_in_postcond(c.bit_num,\n+                                  node_id_to_ts_ann(fcx.ccx,\n+                                                    parent_exp).conditions);\n             }\n         }\n-        case (_) {}\n+      }\n+      _ { }\n     }\n }\n \n-fn forget_in_postcond_still_init(&fn_ctxt fcx, node_id parent_exp,\n-                                 node_id dead_v) {\n+fn forget_in_postcond_still_init(fcx: &fn_ctxt, parent_exp: node_id,\n+                                 dead_v: node_id) {\n     // In the postcondition given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n-    auto d = local_node_id_to_local_def_id(fcx, dead_v);\n-    alt (d) {\n-        case (some(?d_id)) {\n-            for (norm_constraint c in constraints(fcx)) {\n-                if (non_init_constraint_mentions(fcx, c, d_id)) {\n-                    clear_in_postcond(c.bit_num,\n-                      node_id_to_ts_ann(fcx.ccx, parent_exp).conditions);\n-                }\n+    let d = local_node_id_to_local_def_id(fcx, dead_v);\n+    alt d {\n+      some(d_id) {\n+        for c: norm_constraint  in constraints(fcx) {\n+            if non_init_constraint_mentions(fcx, c, d_id) {\n+                clear_in_postcond(c.bit_num,\n+                                  node_id_to_ts_ann(fcx.ccx,\n+                                                    parent_exp).conditions);\n             }\n         }\n-        case (_) { }\n+      }\n+      _ { }\n     }\n }\n \n-fn forget_in_poststate(&fn_ctxt fcx, &poststate p, node_id dead_v) -> bool {\n+fn forget_in_poststate(fcx: &fn_ctxt, p: &poststate, dead_v: node_id) ->\n+   bool {\n     // In the poststate given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n-    auto d = local_node_id_to_local_def_id(fcx, dead_v);\n-    auto changed = false;\n-    alt (d) {\n-        case (some(?d_id)) {\n-            for (norm_constraint c in constraints(fcx)) {\n-                if (constraint_mentions(fcx, c, d_id)) {\n-                    changed |= clear_in_poststate_(c.bit_num, p);\n-                }\n+    let d = local_node_id_to_local_def_id(fcx, dead_v);\n+    let changed = false;\n+    alt d {\n+      some(d_id) {\n+        for c: norm_constraint  in constraints(fcx) {\n+            if constraint_mentions(fcx, c, d_id) {\n+                changed |= clear_in_poststate_(c.bit_num, p);\n             }\n         }\n-        case (_) {}\n+      }\n+      _ { }\n     }\n     ret changed;\n }\n \n-fn forget_in_poststate_still_init(&fn_ctxt fcx, &poststate p, node_id dead_v)\n-    -> bool {\n+fn forget_in_poststate_still_init(fcx: &fn_ctxt, p: &poststate,\n+                                  dead_v: node_id) -> bool {\n     // In the poststate given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n-    auto d = local_node_id_to_local_def_id(fcx, dead_v);\n-    auto changed = false;\n-    alt (d) {\n-        case (some(?d_id)) {\n-            for (norm_constraint c in constraints(fcx)) {\n-                if (non_init_constraint_mentions(fcx, c, d_id)) {\n-                    changed |= clear_in_poststate_(c.bit_num, p);\n-                }\n+    let d = local_node_id_to_local_def_id(fcx, dead_v);\n+    let changed = false;\n+    alt d {\n+      some(d_id) {\n+        for c: norm_constraint  in constraints(fcx) {\n+            if non_init_constraint_mentions(fcx, c, d_id) {\n+                changed |= clear_in_poststate_(c.bit_num, p);\n             }\n         }\n-        case (_) {}\n+      }\n+      _ { }\n     }\n     ret changed;\n }\n \n-fn any_eq(&(node_id)[] v, node_id d) -> bool {\n-    for (node_id i in v) {\n-        if (i == d) { ret true; }\n-    }\n+fn any_eq(v: &node_id[], d: node_id) -> bool {\n+    for i: node_id  in v { if i == d { ret true; } }\n     false\n }\n \n-fn constraint_mentions(&fn_ctxt fcx, &norm_constraint c, node_id v) -> bool {\n-    ret (alt (c.c.node) {\n-            case (ninit(?id,_)) { v == id }\n-            case (npred(_, _, ?args)) {\n-                args_mention(args, any_eq, ~[v])\n-            }\n-        });\n+fn constraint_mentions(fcx: &fn_ctxt, c: &norm_constraint, v: node_id) ->\n+   bool {\n+    ret alt c.c.node {\n+          ninit(id, _) { v == id }\n+          npred(_, _, args) { args_mention(args, any_eq, ~[v]) }\n+        };\n }\n \n-fn non_init_constraint_mentions(&fn_ctxt fcx, &norm_constraint c,\n-                                &node_id v) -> bool {\n-    ret (alt (c.c.node) {\n-            case (ninit(_,_)) {\n-                false\n-            }\n-            case (npred(_, _, ?args)) {\n-                args_mention(args, any_eq, ~[v])\n-            }\n-        });\n+fn non_init_constraint_mentions(fcx: &fn_ctxt, c: &norm_constraint,\n+                                v: &node_id) -> bool {\n+    ret alt c.c.node {\n+          ninit(_, _) { false }\n+          npred(_, _, args) { args_mention(args, any_eq, ~[v]) }\n+        };\n }\n \n-fn args_mention[T](&(@constr_arg_use)[] args, fn(&(T)[], node_id) -> bool q,\n-                   &(T)[] s) -> bool {\n+fn args_mention[T](args: &(@constr_arg_use)[], q: fn(&T[], node_id) -> bool ,\n+                   s: &T[]) -> bool {\n     /*\n       FIXME\n       The following version causes an assertion in trans to fail\n@@ -1028,62 +989,48 @@ fn args_mention[T](&(@constr_arg_use)[] args, fn(&(T)[], node_id) -> bool q,\n     ret ivec::any(bind mentions(s,q,_), args);\n     */\n \n-    for (@constr_arg_use a in args) {\n-        alt (a.node) {\n-            case (carg_ident(?p1)) {\n-                if (q(s, p1.node)) {\n-                    ret true;\n-                }\n-            }\n-            case (_)  {}\n-        }\n+    for a: @constr_arg_use  in args {\n+        alt a.node { carg_ident(p1) { if q(s, p1.node) { ret true; } } _ { } }\n     }\n     ret false;\n }\n \n-fn use_var(&fn_ctxt fcx, &node_id v) {\n-    *fcx.enclosing.used_vars += ~[v];\n-}\n+fn use_var(fcx: &fn_ctxt, v: &node_id) { *fcx.enclosing.used_vars += ~[v]; }\n \n // FIXME: This should be a function in std::ivec::.\n-fn vec_contains(&@mutable (node_id[]) v, &node_id i) -> bool {\n-    for (node_id d in *v) {\n-        if (d == i) { ret true; }\n-    }\n+fn vec_contains(v: &@mutable node_id[], i: &node_id) -> bool {\n+    for d: node_id  in *v { if d == i { ret true; } }\n     ret false;\n }\n \n-fn op_to_oper_ty(init_op io) -> oper_type {\n-    alt (io) {\n-        case (init_move) { oper_move }\n-        case (_)         { oper_assign }\n-    }\n+fn op_to_oper_ty(io: init_op) -> oper_type {\n+    alt io { init_move. { oper_move } _ { oper_assign } }\n }\n \n // default function visitor\n-fn do_nothing[T](&_fn f, &ty_param[] tp, &span sp, &fn_ident i,\n-              node_id iid, &T cx, &visit::vt[T] v) {\n+fn do_nothing[T](f: &_fn, tp: &ty_param[], sp: &span, i: &fn_ident,\n+                 iid: node_id, cx: &T, v: &visit::vt[T]) {\n }\n \n \n-fn args_to_constr_args(&span sp, &arg[] args) -> (@constr_arg_use)[] {\n-    let (@constr_arg_use)[] actuals = ~[];\n-    for (arg a in args) {\n-        actuals += ~[@respan(sp, carg_ident(rec(ident=a.ident, node=a.id)))];\n+fn args_to_constr_args(sp: &span, args: &arg[]) -> (@constr_arg_use)[] {\n+    let actuals: (@constr_arg_use)[] = ~[];\n+    for a: arg  in args {\n+        actuals += ~[@respan(sp, carg_ident({ident: a.ident, node: a.id}))];\n     }\n     ret actuals;\n }\n \n-fn ast_constr_to_ts_constr(&ty::ctxt tcx, &arg[] args, &@constr c)\n-    -> tsconstr {\n-    auto tconstr = ty::ast_constr_to_constr(tcx, c);\n+fn ast_constr_to_ts_constr(tcx: &ty::ctxt, args: &arg[], c: &@constr) ->\n+   tsconstr {\n+    let tconstr = ty::ast_constr_to_constr(tcx, c);\n     ret npred(tconstr.node.path, tconstr.node.id,\n-               args_to_constr_args(tconstr.span, args));\n+              args_to_constr_args(tconstr.span, args));\n }\n \n-fn ast_constr_to_sp_constr(&ty::ctxt tcx, &arg[] args, &@constr c)\n-    -> sp_constr {\n-    auto tconstr = ast_constr_to_ts_constr(tcx, args, c);\n+fn ast_constr_to_sp_constr(tcx: &ty::ctxt, args: &arg[], c: &@constr) ->\n+   sp_constr {\n+    let tconstr = ast_constr_to_ts_constr(tcx, args, c);\n     ret respan(c.span, tconstr);\n }\n "}, {"sha": "a14a7a25539558f37cce151b2727acdf5140234e", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 99, "deletions": 117, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -26,224 +26,206 @@ import tstate::ann::clear_in_prestate;\n import tstate::ann::clear_in_poststate_;\n import tritv::*;\n \n-fn bit_num(&fn_ctxt fcx, &tsconstr c) -> uint {\n-    auto d = tsconstr_to_def_id(c);\n+fn bit_num(fcx: &fn_ctxt, c: &tsconstr) -> uint {\n+    let d = tsconstr_to_def_id(c);\n     assert (fcx.enclosing.constrs.contains_key(d));\n-    auto rslt = fcx.enclosing.constrs.get(d);\n-    alt (c) {\n-        case (ninit(_,_)) {\n-            alt (rslt) {\n-                case (cinit(?n, _, _)) { ret n; }\n-                case (_) {\n-                    fcx.ccx.tcx.sess.bug(\"bit_num: asked for init constraint,\"\n-                                             + \" found a pred constraint\");\n-                }\n-            }\n+    let rslt = fcx.enclosing.constrs.get(d);\n+    alt c {\n+      ninit(_, _) {\n+        alt rslt {\n+          cinit(n, _, _) { ret n; }\n+          _ {\n+            fcx.ccx.tcx.sess.bug(\"bit_num: asked for init constraint,\" +\n+                                     \" found a pred constraint\");\n+          }\n         }\n-        case (npred(_, _, ?args)) {\n-            alt (rslt) {\n-                case (cpred(_, ?descs)) {\n-                    ret match_args(fcx, descs, args);\n-                }\n-                case (_) {\n-                    fcx.ccx.tcx.sess.bug(\"bit_num: asked for pred constraint,\"\n-                                             + \" found an init constraint\");\n-                }\n-            }\n+      }\n+      npred(_, _, args) {\n+        alt rslt {\n+          cpred(_, descs) { ret match_args(fcx, descs, args); }\n+          _ {\n+            fcx.ccx.tcx.sess.bug(\"bit_num: asked for pred constraint,\" +\n+                                     \" found an init constraint\");\n+          }\n         }\n+      }\n     }\n }\n \n-fn promises(&fn_ctxt fcx, &poststate p, &tsconstr c) -> bool {\n+fn promises(fcx: &fn_ctxt, p: &poststate, c: &tsconstr) -> bool {\n     ret promises_(bit_num(fcx, c), p);\n }\n \n-fn promises_(uint n, &poststate p) -> bool {\n-    ret tritv_get(p, n) == ttrue;\n-}\n+fn promises_(n: uint, p: &poststate) -> bool { ret tritv_get(p, n) == ttrue; }\n \n // v \"happens after\" u\n-fn seq_trit(trit u, trit v) -> trit {\n-    alt (v) {\n-        case (ttrue)     { ttrue }\n-        case (tfalse)    { tfalse }\n-        case (dont_care) { u }\n-    }\n+fn seq_trit(u: trit, v: trit) -> trit {\n+    alt v { ttrue. { ttrue } tfalse. { tfalse } dont_care. { u } }\n }\n \n // idea: q \"happens after\" p -- so if something is\n // 1 in q and 0 in p, it's 1 in the result; however,\n // if it's 0 in q and 1 in p, it's 0 in the result\n-fn seq_tritv(&postcond p, &postcond q) {\n-    auto i = 0u;\n+fn seq_tritv(p: &postcond, q: &postcond) {\n+    let i = 0u;\n     assert (p.nbits == q.nbits);\n-    while (i < p.nbits) {\n+    while i < p.nbits {\n         tritv_set(i, p, seq_trit(tritv_get(p, i), tritv_get(q, i)));\n         i += 1u;\n     }\n }\n \n-fn seq_postconds(&fn_ctxt fcx, &postcond[] ps) -> postcond {\n-    auto sz = ivec::len(ps);\n-    if (sz >= 1u) {\n-        auto prev = tritv_clone(ps.(0));\n-        for (postcond p in ivec::slice(ps, 1u, sz)) {\n-            seq_tritv(prev, p);\n-        }\n+fn seq_postconds(fcx: &fn_ctxt, ps: &postcond[]) -> postcond {\n+    let sz = ivec::len(ps);\n+    if sz >= 1u {\n+        let prev = tritv_clone(ps.(0));\n+        for p: postcond  in ivec::slice(ps, 1u, sz) { seq_tritv(prev, p); }\n         ret prev;\n-    }\n-    else {\n-        ret ann::empty_poststate(num_constraints(fcx.enclosing));\n-    }\n+    } else { ret ann::empty_poststate(num_constraints(fcx.enclosing)); }\n }\n \n // Given a list of pres and posts for exprs e0 ... en,\n // return the precondition for evaluating each expr in order.\n // So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n // precondition shouldn't include x.\n-fn seq_preconds(&fn_ctxt fcx, &pre_and_post[] pps) -> precond {\n-    let uint sz = ivec::len(pps);\n-    let uint num_vars = num_constraints(fcx.enclosing);\n-\n-    fn seq_preconds_go(&fn_ctxt fcx, &pre_and_post[] pps,\n-                       &pre_and_post first)\n-        -> precond {\n-        let uint sz = ivec::len(pps);\n-        if (sz >= 1u) {\n-            auto second = pps.(0);\n+fn seq_preconds(fcx: &fn_ctxt, pps: &pre_and_post[]) -> precond {\n+    let sz: uint = ivec::len(pps);\n+    let num_vars: uint = num_constraints(fcx.enclosing);\n+\n+    fn seq_preconds_go(fcx: &fn_ctxt, pps: &pre_and_post[],\n+                       first: &pre_and_post) -> precond {\n+        let sz: uint = ivec::len(pps);\n+        if sz >= 1u {\n+            let second = pps.(0);\n             assert (pps_len(second) == num_constraints(fcx.enclosing));\n-            auto second_pre = clone(second.precondition);\n+            let second_pre = clone(second.precondition);\n             difference(second_pre, first.postcondition);\n-            auto next_first = clone(first.precondition);\n+            let next_first = clone(first.precondition);\n             union(next_first, second_pre);\n-            auto next_first_post = clone(first.postcondition);\n+            let next_first_post = clone(first.postcondition);\n             seq_tritv(next_first_post, second.postcondition);\n             ret seq_preconds_go(fcx, ivec::slice(pps, 1u, sz),\n-                                @rec(precondition=next_first,\n-                                     postcondition=next_first_post));\n-        }\n-        else {\n-            ret first.precondition;\n-        }\n+                                @{precondition: next_first,\n+                                  postcondition: next_first_post});\n+        } else { ret first.precondition; }\n     }\n \n-    if (sz >= 1u) {\n-        auto first = pps.(0);\n+\n+    if sz >= 1u {\n+        let first = pps.(0);\n         assert (pps_len(first) == num_vars);\n         ret seq_preconds_go(fcx, ivec::slice(pps, 1u, sz), first);\n     } else { ret true_precond(num_vars); }\n }\n \n-fn intersect_states(&prestate p, &prestate q) -> prestate {\n-    auto rslt = tritv_clone(p);\n+fn intersect_states(p: &prestate, q: &prestate) -> prestate {\n+    let rslt = tritv_clone(p);\n     tritv_intersect(rslt, q);\n     ret rslt;\n }\n \n-fn gen(&fn_ctxt fcx, node_id id, &tsconstr c) -> bool {\n+fn gen(fcx: &fn_ctxt, id: node_id, c: &tsconstr) -> bool {\n     ret set_in_postcond(bit_num(fcx, c),\n                         node_id_to_ts_ann(fcx.ccx, id).conditions);\n }\n \n-fn declare_var(&fn_ctxt fcx, &tsconstr c, prestate pre) -> prestate {\n-    auto rslt = clone(pre);\n+fn declare_var(fcx: &fn_ctxt, c: &tsconstr, pre: prestate) -> prestate {\n+    let rslt = clone(pre);\n     relax_prestate(bit_num(fcx, c), rslt);\n     // idea is this is scoped\n     relax_poststate(bit_num(fcx, c), rslt);\n     ret rslt;\n }\n \n-fn relax_precond_block_non_recursive(&fn_ctxt fcx, node_id i, &blk b) {\n+fn relax_precond_block_non_recursive(fcx: &fn_ctxt, i: node_id, b: &blk) {\n     relax_precond(i as uint, block_precond(fcx.ccx, b));\n }\n \n-fn relax_precond_expr(&fn_ctxt fcx, node_id i, &@expr e) {\n+fn relax_precond_expr(fcx: &fn_ctxt, i: node_id, e: &@expr) {\n     relax_precond(i as uint, expr_precond(fcx.ccx, e));\n }\n \n-fn relax_precond_stmt(&fn_ctxt fcx, node_id i, &@stmt s) {\n+fn relax_precond_stmt(fcx: &fn_ctxt, i: node_id, s: &@stmt) {\n     relax_precond(i as uint, stmt_precond(fcx.ccx, *s));\n }\n \n-fn relax_precond_block(&fn_ctxt fcx, node_id i, &blk b) {\n+fn relax_precond_block(fcx: &fn_ctxt, i: node_id, b: &blk) {\n     relax_precond_block_non_recursive(fcx, i, b);\n     // FIXME: should use visit instead\n     // could at least generalize this pattern\n     // (also seen in ck::check_states_against_conditions)\n-    let @mutable bool keepgoing = @mutable true;\n+    let keepgoing: @mutable bool = @mutable true;\n \n-    fn quit(@mutable bool keepgoing, &@item i) {\n-        *keepgoing = false;\n-    }\n-    fn kg(@mutable bool keepgoing) -> bool { ret *keepgoing; }\n+    fn quit(keepgoing: @mutable bool, i: &@item) { *keepgoing = false; }\n+    fn kg(keepgoing: @mutable bool) -> bool { ret *keepgoing; }\n \n-    auto v = rec(visit_block_pre = bind\n-                    relax_precond_block_non_recursive(fcx, i, _),\n-                 visit_expr_pre  = bind relax_precond_expr(fcx, i, _),\n-                 visit_stmt_pre  = bind relax_precond_stmt(fcx, i, _),\n-                  visit_item_pre=bind quit(keepgoing, _),\n-                  keep_going=bind kg(keepgoing)\n+    let \n \n-                   with walk::default_visitor());\n+        v =\n+        {visit_block_pre: bind relax_precond_block_non_recursive(fcx, i, _),\n+         visit_expr_pre: bind relax_precond_expr(fcx, i, _),\n+         visit_stmt_pre: bind relax_precond_stmt(fcx, i, _),\n+         visit_item_pre: bind quit(keepgoing, _),\n+         keep_going: bind kg(keepgoing) with walk::default_visitor()};\n     walk::walk_block(v, b);\n }\n \n-fn gen_poststate(&fn_ctxt fcx, node_id id, &tsconstr c) -> bool {\n+fn gen_poststate(fcx: &fn_ctxt, id: node_id, c: &tsconstr) -> bool {\n     log \"gen_poststate\";\n     ret set_in_poststate(bit_num(fcx, c),\n                          node_id_to_ts_ann(fcx.ccx, id).states);\n }\n \n-fn kill_prestate(&fn_ctxt fcx, node_id id, &tsconstr c) -> bool {\n+fn kill_prestate(fcx: &fn_ctxt, id: node_id, c: &tsconstr) -> bool {\n     ret clear_in_prestate(bit_num(fcx, c),\n-                           node_id_to_ts_ann(fcx.ccx, id).states);\n+                          node_id_to_ts_ann(fcx.ccx, id).states);\n }\n \n-fn kill_poststate(&fn_ctxt fcx, node_id id, &tsconstr c) -> bool {\n+fn kill_poststate(fcx: &fn_ctxt, id: node_id, c: &tsconstr) -> bool {\n     log \"kill_poststate\";\n     ret clear_in_poststate(bit_num(fcx, c),\n                            node_id_to_ts_ann(fcx.ccx, id).states);\n }\n \n-fn clear_in_poststate_expr(&fn_ctxt fcx, &@expr e, &poststate t) {\n-    alt (e.node) {\n-        case (expr_path(?p)) {\n-            alt (ivec::last(p.node.idents)) {\n-                case (some(?i)) {\n-                    alt (local_node_id_to_def(fcx, e.id)) {\n-                        case (some(def_local(?d_id))) {\n-                            clear_in_poststate_(\n-                               bit_num(fcx,ninit(d_id.node, i)), t);\n-                        }\n-                        case (some(_)) { /* ignore args (for now...) */ }\n-                        case (_) {\n-                            fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr: \\\n-                                   unbound var\"); }\n-                        }\n-                }\n-                case (_) { fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr\"); }\n+fn clear_in_poststate_expr(fcx: &fn_ctxt, e: &@expr, t: &poststate) {\n+    alt e.node {\n+      expr_path(p) {\n+        alt ivec::last(p.node.idents) {\n+          some(i) {\n+            alt local_node_id_to_def(fcx, e.id) {\n+              some(def_local(d_id)) {\n+                clear_in_poststate_(bit_num(fcx, ninit(d_id.node, i)), t);\n+              }\n+              some(_) {/* ignore args (for now...) */ }\n+              _ {\n+                fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr: \\\n+                                   unbound var\");\n+              }\n             }\n+          }\n+          _ { fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr\"); }\n         }\n-        case (_) { /* do nothing */ }\n+      }\n+      _ {/* do nothing */ }\n     }\n }\n \n-fn set_in_poststate_ident(&fn_ctxt fcx, &node_id id, &ident ident,\n-                          &poststate t) -> bool {\n+fn set_in_poststate_ident(fcx: &fn_ctxt, id: &node_id, ident: &ident,\n+                          t: &poststate) -> bool {\n     ret set_in_poststate_(bit_num(fcx, ninit(id, ident)), t);\n }\n \n-fn set_in_prestate_constr(&fn_ctxt fcx, &tsconstr c, &prestate t) -> bool {\n+fn set_in_prestate_constr(fcx: &fn_ctxt, c: &tsconstr, t: &prestate) -> bool {\n     ret set_in_poststate_(bit_num(fcx, c), t);\n }\n \n-fn clear_in_poststate_ident(&fn_ctxt fcx, &node_id id, &ident ident,\n-                            &node_id parent) -> bool {\n+fn clear_in_poststate_ident(fcx: &fn_ctxt, id: &node_id, ident: &ident,\n+                            parent: &node_id) -> bool {\n     ret kill_poststate(fcx, parent, ninit(id, ident));\n }\n \n-fn clear_in_prestate_ident(&fn_ctxt fcx, &node_id id, &ident ident,\n-                            &node_id parent) -> bool {\n+fn clear_in_prestate_ident(fcx: &fn_ctxt, id: &node_id, ident: &ident,\n+                           parent: &node_id) -> bool {\n     ret kill_prestate(fcx, parent, ninit(id, ident));\n }\n "}, {"sha": "37eace68d5decd864fa4a349ad3166d0ed69ba6c", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -46,26 +46,27 @@ import collect_locals::mk_f_to_fn_info;\n import pre_post_conditions::fn_pre_post;\n import states::find_pre_post_state_fn;\n \n-fn check_unused_vars(&fn_ctxt fcx) {\n+fn check_unused_vars(fcx: &fn_ctxt) {\n+\n     // FIXME: could be more efficient\n-    for (norm_constraint c in constraints(fcx)) {\n-        alt (c.c.node) {\n-            case (ninit(?id, ?v)) {\n-                if (!vec_contains(fcx.enclosing.used_vars, id)) {\n-                    fcx.ccx.tcx.sess.span_warn(c.c.span,\n-                                               \"Unused variable \" + v);\n-                }\n+    for c: norm_constraint  in constraints(fcx) {\n+        alt c.c.node {\n+          ninit(id, v) {\n+            if !vec_contains(fcx.enclosing.used_vars, id) {\n+                fcx.ccx.tcx.sess.span_warn(c.c.span, \"Unused variable \" + v);\n             }\n-            case (_) { /* ignore pred constraints */ }\n+          }\n+          _ {/* ignore pred constraints */ }\n         }\n     }\n }\n \n-fn check_states_expr(&@expr e, &fn_ctxt fcx, &visit::vt[fn_ctxt] v) {\n+fn check_states_expr(e: &@expr, fcx: &fn_ctxt, v: &visit::vt[fn_ctxt]) {\n     visit::visit_expr(e, fcx, v);\n \n-    let precond prec = expr_precond(fcx.ccx, e);\n-    let prestate pres = expr_prestate(fcx.ccx, e);\n+    let prec: precond = expr_precond(fcx.ccx, e);\n+    let pres: prestate = expr_prestate(fcx.ccx, e);\n+\n \n     /*\n     log_err(\"check_states_expr:\");\n@@ -76,9 +77,9 @@ fn check_states_expr(&@expr e, &fn_ctxt fcx, &visit::vt[fn_ctxt] v) {\n       log_tritv_err(fcx, pres);\n     */\n \n-    if (!implies(pres, prec)) {\n-        auto s = \"\";\n-        auto diff = first_difference_string(fcx, prec, pres);\n+    if !implies(pres, prec) {\n+        let s = \"\";\n+        let diff = first_difference_string(fcx, prec, pres);\n         s +=\n             \"Unsatisfied precondition constraint (for example, \" + diff +\n                 \") for expression:\\n\";\n@@ -91,12 +92,13 @@ fn check_states_expr(&@expr e, &fn_ctxt fcx, &visit::vt[fn_ctxt] v) {\n     }\n }\n \n-fn check_states_stmt(&@stmt s, &fn_ctxt fcx, &visit::vt[fn_ctxt] v) {\n+fn check_states_stmt(s: &@stmt, fcx: &fn_ctxt, v: &visit::vt[fn_ctxt]) {\n     visit::visit_stmt(s, fcx, v);\n \n-    auto a = stmt_to_ann(fcx.ccx, *s);\n-    let precond prec = ann_precond(a);\n-    let prestate pres = ann_prestate(a);\n+    let a = stmt_to_ann(fcx.ccx, *s);\n+    let prec: precond = ann_precond(a);\n+    let pres: prestate = ann_prestate(a);\n+\n \n     /*\n       log_err(\"check_states_stmt:\");\n@@ -107,9 +109,9 @@ fn check_states_stmt(&@stmt s, &fn_ctxt fcx, &visit::vt[fn_ctxt] v) {\n       log_tritv_err(fcx, pres);\n     */\n \n-    if (!implies(pres, prec)) {\n-        auto ss = \"\";\n-        auto diff = first_difference_string(fcx, prec, pres);\n+    if !implies(pres, prec) {\n+        let ss = \"\";\n+        let diff = first_difference_string(fcx, prec, pres);\n         ss +=\n             \"Unsatisfied precondition constraint (for example, \" + diff +\n                 \") for statement:\\n\";\n@@ -122,44 +124,45 @@ fn check_states_stmt(&@stmt s, &fn_ctxt fcx, &visit::vt[fn_ctxt] v) {\n     }\n }\n \n-fn check_states_against_conditions(&fn_ctxt fcx, &_fn f,\n-                                   &ast::ty_param[] tps,\n-                                   node_id id, &span sp, &fn_ident i) {\n+fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n+                                   tps: &ast::ty_param[], id: node_id,\n+                                   sp: &span, i: &fn_ident) {\n     /* Postorder traversal instead of pre is important\n        because we want the smallest possible erroneous statement\n        or expression. */\n \n-    auto visitor = visit::default_visitor[fn_ctxt]();\n+    let visitor = visit::default_visitor[fn_ctxt]();\n \n-    visitor = @rec(visit_stmt=check_states_stmt,\n-                 visit_expr=check_states_expr,\n-                 visit_fn=do_nothing\n-                 with *visitor);\n+    visitor =\n+        @{visit_stmt: check_states_stmt,\n+          visit_expr: check_states_expr,\n+          visit_fn: do_nothing with *visitor};\n     visit::visit_fn(f, tps, sp, i, id, fcx, visit::mk_vt(visitor));\n \n     /* Check that the return value is initialized */\n-    auto post = aux::block_poststate(fcx.ccx, f.body);\n-    let tsconstr ret_c = ninit(fcx.id, fcx.name);\n-    if (f.proto == ast::proto_fn && !promises(fcx, post, ret_c) &&\n-            !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n-            f.decl.cf == return) {\n+    let post = aux::block_poststate(fcx.ccx, f.body);\n+    let ret_c: tsconstr = ninit(fcx.id, fcx.name);\n+    if f.proto == ast::proto_fn && !promises(fcx, post, ret_c) &&\n+           !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n+           f.decl.cf == return {\n         fcx.ccx.tcx.sess.span_note(f.body.span,\n                                    \"In function \" + fcx.name +\n                                        \", not all control paths \\\n                                         return a value\");\n         fcx.ccx.tcx.sess.span_fatal(f.decl.output.span,\n-                                  \"see declared return type of '\" +\n-                                      ty_to_str(*f.decl.output) + \"'\");\n+                                    \"see declared return type of '\" +\n+                                        ty_to_str(*f.decl.output) + \"'\");\n     } else if (f.decl.cf == noreturn) {\n \n+\n         // check that this really always fails\n         // the fcx.id bit means \"returns\" for a returning fn,\n         // \"diverges\" for a non-returning fn\n-        if (!promises(fcx, post, ret_c)) {\n+        if !promises(fcx, post, ret_c) {\n             fcx.ccx.tcx.sess.span_fatal(f.body.span,\n-                                      \"In non-returning function \" + fcx.name\n-                                          +\n-                                          \", some control paths may \\\n+                                        \"In non-returning function \" +\n+                                            fcx.name +\n+                                            \", some control paths may \\\n                                            return to the caller\");\n         }\n     }\n@@ -168,34 +171,33 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f,\n     check_unused_vars(fcx);\n }\n \n-fn check_fn_states(&fn_ctxt fcx, &_fn f, &ast::ty_param[] tps,\n-                   node_id id, &span sp, &fn_ident i) {\n+fn check_fn_states(fcx: &fn_ctxt, f: &_fn, tps: &ast::ty_param[], id: node_id,\n+                   sp: &span, i: &fn_ident) {\n     /* Compute the pre- and post-states for this function */\n \n     // Fixpoint iteration\n-    while (find_pre_post_state_fn(fcx, f)) {}\n+    while find_pre_post_state_fn(fcx, f) { }\n \n     /* Now compare each expr's pre-state to its precondition\n        and post-state to its postcondition */\n \n     check_states_against_conditions(fcx, f, tps, id, sp, i);\n }\n \n-fn fn_states(&_fn f, &ast::ty_param[] tps,\n-             &span sp, &fn_ident i, node_id id, &crate_ctxt ccx,\n-             &visit::vt[crate_ctxt] v) {\n+fn fn_states(f: &_fn, tps: &ast::ty_param[], sp: &span, i: &fn_ident,\n+             id: node_id, ccx: &crate_ctxt, v: &visit::vt[crate_ctxt]) {\n     visit::visit_fn(f, tps, sp, i, id, ccx, v);\n     /* Look up the var-to-bit-num map for this function */\n \n     assert (ccx.fm.contains_key(id));\n-    auto f_info = ccx.fm.get(id);\n-    auto name = option::from_maybe(\"anon\", i);\n-    auto fcx = rec(enclosing=f_info, id=id, name=name, ccx=ccx);\n+    let f_info = ccx.fm.get(id);\n+    let name = option::from_maybe(\"anon\", i);\n+    let fcx = {enclosing: f_info, id: id, name: name, ccx: ccx};\n     check_fn_states(fcx, f, tps, id, sp, i);\n }\n \n-fn check_crate(ty::ctxt cx, @crate crate) {\n-    let crate_ctxt ccx = new_crate_ctxt(cx);\n+fn check_crate(cx: ty::ctxt, crate: @crate) {\n+    let ccx: crate_ctxt = new_crate_ctxt(cx);\n     /* Build the global map from function id to var-to-bit-num-map */\n \n     mk_f_to_fn_info(ccx, crate);\n@@ -204,13 +206,13 @@ fn check_crate(ty::ctxt cx, @crate crate) {\n     annotate_crate(ccx, *crate);\n     /* Compute the pre and postcondition for every subexpression */\n \n-    auto vtor = visit::default_visitor[crate_ctxt]();\n-    vtor = @rec(visit_fn=fn_pre_post with *vtor);\n+    let vtor = visit::default_visitor[crate_ctxt]();\n+    vtor = @{visit_fn: fn_pre_post with *vtor};\n     visit::visit_crate(*crate, ccx, visit::mk_vt(vtor));\n \n     /* Check the pre- and postcondition against the pre- and poststate\n        for every expression */\n-    vtor = @rec(visit_fn=fn_states with *vtor);\n+    vtor = @{visit_fn: fn_states with *vtor};\n     visit::visit_crate(*crate, ccx, visit::mk_vt(vtor));\n }\n //"}, {"sha": "f9b3012f5272ef29acf7c069079dc83e8f17ec7b", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 69, "deletions": 74, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -11,103 +11,97 @@ import util::common::new_def_hash;\n import syntax::codemap::span;\n import syntax::ast::respan;\n \n-type ctxt = rec(@mutable (sp_constr[]) cs, ty::ctxt tcx);\n+type ctxt = {cs: @mutable sp_constr[], tcx: ty::ctxt};\n \n-fn collect_local(&@local loc, &ctxt cx, &visit::vt[ctxt] v) {\n+fn collect_local(loc: &@local, cx: &ctxt, v: &visit::vt[ctxt]) {\n     log \"collect_local: pushing \" + loc.node.ident;\n     *cx.cs += ~[respan(loc.span, ninit(loc.node.id, loc.node.ident))];\n     visit::visit_local(loc, cx, v);\n }\n \n-fn collect_pred(&@expr e, &ctxt cx, &visit::vt[ctxt] v) {\n-    alt (e.node) {\n-        case (expr_check(_, ?ch)) {\n-            *cx.cs += ~[expr_to_constr(cx.tcx, ch)];\n-        }\n-        case (expr_if_check(?ex, _, _)) {\n-            *cx.cs += ~[expr_to_constr(cx.tcx, ex)];\n-        }\n-        // If it's a call, generate appropriate instances of the\n-        // call's constraints.\n-        case (expr_call(?operator, ?operands)) {\n-            for (@ty::constr c in constraints_expr(cx.tcx, operator)) {\n-                let sp_constr ct = respan(c.span,\n-                           aux::substitute_constr_args(cx.tcx, operands,\n-                                                       c));\n-                *cx.cs += ~[ct];\n-            }\n+fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt[ctxt]) {\n+    alt e.node {\n+      expr_check(_, ch) { *cx.cs += ~[expr_to_constr(cx.tcx, ch)]; }\n+      expr_if_check(ex, _, _) { *cx.cs += ~[expr_to_constr(cx.tcx, ex)]; }\n+\n+      // If it's a call, generate appropriate instances of the\n+      // call's constraints.\n+      expr_call(operator, operands) {\n+        for c: @ty::constr  in constraints_expr(cx.tcx, operator) {\n+            let ct: sp_constr =\n+                respan(c.span,\n+                       aux::substitute_constr_args(cx.tcx, operands, c));\n+            *cx.cs += ~[ct];\n         }\n-        case (_) { }\n+      }\n+      _ { }\n     }\n     // visit subexpressions\n     visit::visit_expr(e, cx, v);\n }\n \n-fn find_locals(&ty::ctxt tcx, &_fn f, &ty_param[] tps, &span sp, &fn_ident i,\n-               node_id id) -> ctxt {\n-    let ctxt cx = rec(cs=@mutable ~[], tcx=tcx);\n-    auto visitor = visit::default_visitor[ctxt]();\n+fn find_locals(tcx: &ty::ctxt, f: &_fn, tps: &ty_param[], sp: &span,\n+               i: &fn_ident, id: node_id) -> ctxt {\n+    let cx: ctxt = {cs: @mutable ~[], tcx: tcx};\n+    let visitor = visit::default_visitor[ctxt]();\n \n-    visitor = @rec(visit_local=collect_local,\n-                   visit_expr=collect_pred,\n-                   visit_fn=do_nothing\n-                   with *visitor);\n+    visitor =\n+        @{visit_local: collect_local,\n+          visit_expr: collect_pred,\n+          visit_fn: do_nothing with *visitor};\n     visit::visit_fn(f, tps, sp, i, id, cx, visit::mk_vt(visitor));\n     ret cx;\n }\n \n-fn add_constraint(&ty::ctxt tcx, sp_constr c, uint next, constr_map tbl) ->\n-   uint {\n+fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n+   -> uint {\n     log constraint_to_str(tcx, c) + \" |-> \" + std::uint::str(next);\n-    alt (c.node) {\n-        case (ninit(?id, ?i)) { tbl.insert(local_def(id),\n-                                           cinit(next, c.span, i)); }\n-        case (npred(?p, ?d_id, ?args)) {\n-            alt (tbl.find(d_id)) {\n-                case (some(?ct)) {\n-                    alt (ct) {\n-                        case (cinit(_, _, _)) {\n-                            tcx.sess.bug(\"add_constraint: same def_id used\" +\n-                                             \" as a variable and a pred\");\n-                        }\n-                        case (cpred(_, ?pds)) {\n-                            *pds += ~[respan(c.span,\n-                                            rec(args=args, bit_num=next))];\n-                        }\n-                    }\n-                }\n-                case (none) {\n-                    let @mutable(pred_args[]) rslt = @mutable(~[respan(c.span,\n-                                                         rec(args=args,\n-                                                             bit_num=next))]);\n-                    tbl.insert(d_id, cpred(p, rslt));\n-                }\n+    alt c.node {\n+      ninit(id, i) { tbl.insert(local_def(id), cinit(next, c.span, i)); }\n+      npred(p, d_id, args) {\n+        alt tbl.find(d_id) {\n+          some(ct) {\n+            alt ct {\n+              cinit(_, _, _) {\n+                tcx.sess.bug(\"add_constraint: same def_id used\" +\n+                                 \" as a variable and a pred\");\n+              }\n+              cpred(_, pds) {\n+                *pds += ~[respan(c.span, {args: args, bit_num: next})];\n+              }\n             }\n+          }\n+          none. {\n+            let rslt: @mutable pred_args[] =\n+                @mutable ~[respan(c.span, {args: args, bit_num: next})];\n+            tbl.insert(d_id, cpred(p, rslt));\n+          }\n         }\n+      }\n     }\n     ret next + 1u;\n }\n \n \n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n-fn mk_fn_info(&crate_ctxt ccx, &_fn f, &ty_param[] tp,\n-              &span f_sp, &fn_ident f_name, node_id id) {\n-    auto name = fn_ident_to_string(id, f_name);\n-    auto res_map = @new_def_hash[constraint]();\n-    let uint next = 0u;\n+fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &ty_param[], f_sp: &span,\n+              f_name: &fn_ident, id: node_id) {\n+    let name = fn_ident_to_string(id, f_name);\n+    let res_map = @new_def_hash[constraint]();\n+    let next: uint = 0u;\n \n-    let ctxt cx = find_locals(ccx.tcx, f, tp, f_sp, f_name, id);\n+    let cx: ctxt = find_locals(ccx.tcx, f, tp, f_sp, f_name, id);\n     /* now we have to add bit nums for both the constraints\n        and the variables... */\n \n-    for (sp_constr c in { *cx.cs }) {\n+    for c: sp_constr  in { *cx.cs } {\n         next = add_constraint(cx.tcx, c, next, res_map);\n     }\n     /* if this function has any constraints, instantiate them to the\n        argument names and add them */\n-    auto sc;\n-    for (@constr c in f.decl.constraints) {\n+    let sc;\n+    for c: @constr  in f.decl.constraints {\n         sc = ast_constr_to_sp_constr(cx.tcx, f.decl.inputs, c);\n         next = add_constraint(cx.tcx, sc, next, res_map);\n     }\n@@ -116,26 +110,27 @@ fn mk_fn_info(&crate_ctxt ccx, &_fn f, &ty_param[] tp,\n        we can safely use the function's name itself for this purpose */\n \n     add_constraint(cx.tcx, respan(f_sp, ninit(id, name)), next, res_map);\n-    let @mutable node_id[] v = @mutable ~[];\n-    auto rslt =\n-        rec(constrs=res_map,\n-            num_constraints=ivec::len(*cx.cs) + ivec::len(f.decl.constraints)\n-                            + 1u,\n-            cf=f.decl.cf,\n-            used_vars=v);\n+    let v: @mutable node_id[] = @mutable ~[];\n+    let rslt =\n+        {constrs: res_map,\n+         num_constraints:\n+             ivec::len(*cx.cs) + ivec::len(f.decl.constraints) + 1u,\n+         cf: f.decl.cf,\n+         used_vars: v};\n     ccx.fm.insert(id, rslt);\n     log name + \" has \" + std::uint::str(num_constraints(rslt)) +\n-        \" constraints\";\n+            \" constraints\";\n }\n \n \n /* initializes the global fn_info_map (mapping each function ID, including\n    nested locally defined functions, onto a mapping from local variable name\n    to bit number) */\n-fn mk_f_to_fn_info(&crate_ctxt ccx, @crate c) {\n-    auto visitor = visit::mk_simple_visitor\n-        (@rec(visit_fn=bind mk_fn_info(ccx, _, _, _, _, _)\n-              with *visit::default_simple_visitor()));\n+fn mk_f_to_fn_info(ccx: &crate_ctxt, c: @crate) {\n+    let visitor =\n+        visit::mk_simple_visitor(@{visit_fn:\n+                                       bind mk_fn_info(ccx, _, _, _, _, _)\n+                                      with *visit::default_simple_visitor()});\n     visit::visit_crate(*c, (), visitor);\n }\n //"}, {"sha": "c849ac8b33fe701bd884c2c0da64b01ad9b7fbed", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 524, "deletions": 548, "changes": 1072, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -46,66 +46,65 @@ import util::common::log_block;\n import syntax::codemap::span;\n import util::ppaux::fn_ident_to_string;\n \n-fn find_pre_post_mod(&_mod m) -> _mod {\n+fn find_pre_post_mod(m: &_mod) -> _mod {\n     log \"implement find_pre_post_mod!\";\n     fail;\n }\n \n-fn find_pre_post_native_mod(&native_mod m) -> native_mod {\n+fn find_pre_post_native_mod(m: &native_mod) -> native_mod {\n     log \"implement find_pre_post_native_mod\";\n     fail;\n }\n \n-fn find_pre_post_obj(&crate_ctxt ccx, _obj o) {\n-    fn do_a_method(crate_ctxt ccx, &@method m) {\n+fn find_pre_post_obj(ccx: &crate_ctxt, o: _obj) {\n+    fn do_a_method(ccx: crate_ctxt, m: &@method) {\n         assert (ccx.fm.contains_key(m.node.id));\n-        let fn_ctxt fcx =\n-            rec(enclosing=ccx.fm.get(m.node.id),\n-                id=m.node.id,\n-                name=m.node.ident,\n-                ccx=ccx);\n+        let fcx: fn_ctxt =\n+            {enclosing: ccx.fm.get(m.node.id),\n+             id: m.node.id,\n+             name: m.node.ident,\n+             ccx: ccx};\n         find_pre_post_fn(fcx, m.node.meth);\n     }\n-    for (@method m in o.methods) { do_a_method(ccx, m); }\n+    for m: @method  in o.methods { do_a_method(ccx, m); }\n     option::map[@method, ()](bind do_a_method(ccx, _), o.dtor);\n }\n \n-fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n-    alt (i.node) {\n-        case (item_const(_, ?e)) {\n-            // make a fake fcx\n-            let @mutable node_id[] v = @mutable ~[];\n-            auto fake_fcx =\n-                rec(enclosing=rec(constrs=@new_def_hash[constraint](),\n-                                  num_constraints=0u,\n-                                  cf=return,\n-                                  used_vars=v),\n-                    id=0,\n-                    name=\"\",\n-                    ccx=ccx);\n-            find_pre_post_expr(fake_fcx, e);\n-        }\n-        case (item_fn(?f, _)) {\n-            assert (ccx.fm.contains_key(i.id));\n-            auto fcx =\n-                rec(enclosing=ccx.fm.get(i.id),\n-                    id=i.id,\n-                    name=i.ident,\n-                    ccx=ccx);\n-            find_pre_post_fn(fcx, f);\n-        }\n-        case (item_mod(?m)) { find_pre_post_mod(m); }\n-        case (item_native_mod(?nm)) { find_pre_post_native_mod(nm); }\n-        case (item_ty(_, _)) { ret; }\n-        case (item_tag(_, _)) { ret; }\n-        case (item_res(?dtor, ?dtor_id, _, _)) {\n-            auto fcx = rec(enclosing=ccx.fm.get(dtor_id),\n-                           id=dtor_id,\n-                           name=i.ident,\n-                           ccx=ccx);\n-            find_pre_post_fn(fcx, dtor);\n-        }\n-        case (item_obj(?o, _, _)) { find_pre_post_obj(ccx, o); }\n+fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n+    alt i.node {\n+      item_const(_, e) {\n+        // make a fake fcx\n+        let v: @mutable node_id[] = @mutable ~[];\n+        let fake_fcx =\n+            {enclosing:\n+                 {constrs: @new_def_hash[constraint](),\n+                  num_constraints: 0u,\n+                  cf: return,\n+                  used_vars: v},\n+             id: 0,\n+             name: \"\",\n+             ccx: ccx};\n+        find_pre_post_expr(fake_fcx, e);\n+      }\n+      item_fn(f, _) {\n+        assert (ccx.fm.contains_key(i.id));\n+        let fcx =\n+            {enclosing: ccx.fm.get(i.id), id: i.id, name: i.ident, ccx: ccx};\n+        find_pre_post_fn(fcx, f);\n+      }\n+      item_mod(m) { find_pre_post_mod(m); }\n+      item_native_mod(nm) { find_pre_post_native_mod(nm); }\n+      item_ty(_, _) { ret; }\n+      item_tag(_, _) { ret; }\n+      item_res(dtor, dtor_id, _, _) {\n+        let fcx =\n+            {enclosing: ccx.fm.get(dtor_id),\n+             id: dtor_id,\n+             name: i.ident,\n+             ccx: ccx};\n+        find_pre_post_fn(fcx, dtor);\n+      }\n+      item_obj(o, _, _) { find_pre_post_obj(ccx, o); }\n     }\n }\n \n@@ -114,545 +113,521 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n    sets the precondition in a to be the result of combining\n    the preconditions for <args>, and the postcondition in a to\n    be the union of all postconditions for <args> */\n-fn find_pre_post_exprs(&fn_ctxt fcx, &(@expr)[] args, node_id id) {\n-    if (ivec::len[@expr](args) > 0u) {\n+fn find_pre_post_exprs(fcx: &fn_ctxt, args: &(@expr)[], id: node_id) {\n+    if ivec::len[@expr](args) > 0u {\n         log \"find_pre_post_exprs: oper =\";\n         log_expr(*args.(0));\n     }\n-    fn do_one(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n-    for (@expr e in args) { do_one(fcx, e); }\n+    fn do_one(fcx: fn_ctxt, e: &@expr) { find_pre_post_expr(fcx, e); }\n+    for e: @expr  in args { do_one(fcx, e); }\n \n-    fn get_pp(crate_ctxt ccx, &@expr e) -> pre_and_post {\n+    fn get_pp(ccx: crate_ctxt, e: &@expr) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n-    auto pps = ivec::map[@expr, pre_and_post](bind get_pp(fcx.ccx, _), args);\n+    let pps = ivec::map[@expr, pre_and_post](bind get_pp(fcx.ccx, _), args);\n \n     set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n                      seq_postconds(fcx, ivec::map(get_post, pps)));\n }\n \n-fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &blk body,\n-                      node_id id) {\n+fn find_pre_post_loop(fcx: &fn_ctxt, l: &@local, index: &@expr, body: &blk,\n+                      id: node_id) {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n-    auto v_init = ninit(l.node.id, l.node.ident);\n+    let v_init = ninit(l.node.id, l.node.ident);\n     relax_precond_block(fcx, bit_num(fcx, v_init) as node_id, body);\n \n     // Hack: for-loop index variables are frequently ignored,\n     // so we pretend they're used\n     use_var(fcx, l.node.id);\n \n-    auto loop_precond = seq_preconds(fcx, ~[expr_pp(fcx.ccx, index),\n-                                            block_pp(fcx.ccx, body)]);\n-    auto loop_postcond = intersect_states(expr_postcond(fcx.ccx, index),\n-                                          block_postcond(fcx.ccx, body));\n+    let loop_precond =\n+        seq_preconds(fcx,\n+                     ~[expr_pp(fcx.ccx, index), block_pp(fcx.ccx, body)]);\n+    let loop_postcond =\n+        intersect_states(expr_postcond(fcx.ccx, index),\n+                         block_postcond(fcx.ccx, body));\n     copy_pre_post_(fcx.ccx, id, loop_precond, loop_postcond);\n }\n \n // Generates a pre/post assuming that a is the\n // annotation for an if-expression with consequent conseq\n // and alternative maybe_alt\n-fn join_then_else(&fn_ctxt fcx, &@expr antec, &blk conseq,\n-                  &option::t[@expr] maybe_alt, node_id id, &if_ty chck) {\n+fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n+                  maybe_alt: &option::t[@expr], id: node_id, chck: &if_ty) {\n     find_pre_post_expr(fcx, antec);\n     find_pre_post_block(fcx, conseq);\n-    alt (maybe_alt) {\n-        case (none) {\n-            alt (chck) {\n-                case (if_check) {\n-                    let sp_constr c = expr_to_constr(fcx.ccx.tcx, antec);\n-                    gen(fcx, antec.id, c.node);\n-                }\n-                case (_) {}\n-            }\n-\n-            auto precond_res = seq_preconds(fcx,\n-                ~[expr_pp(fcx.ccx, antec), block_pp(fcx.ccx, conseq)]);\n-            set_pre_and_post(fcx.ccx, id, precond_res,\n-                             expr_poststate(fcx.ccx, antec));\n-        }\n-        case (some(?altern)) {\n-            /*\n-              if check = if_check, then\n-              be sure that the predicate implied by antec\n-              is *not* true in the alternative\n-             */\n-            find_pre_post_expr(fcx, altern);\n-            auto precond_false_case = seq_preconds(fcx,\n-                ~[expr_pp(fcx.ccx, antec), expr_pp(fcx.ccx, altern)]);\n-            auto postcond_false_case = seq_postconds(fcx,\n-                ~[expr_postcond(fcx.ccx, antec),\n-                  expr_postcond(fcx.ccx, altern)]);\n-\n-            /* Be sure to set the bit for the check condition here,\n-             so that it's *not* set in the alternative. */\n-            alt (chck) {\n-                case (if_check) {\n-                    let sp_constr c = expr_to_constr(fcx.ccx.tcx, antec);\n-                    gen(fcx, antec.id, c.node);\n-                }\n-                case (_) {}\n-            }\n-            auto precond_true_case = seq_preconds(fcx,\n-                ~[expr_pp(fcx.ccx, antec), block_pp(fcx.ccx, conseq)]);\n-            auto postcond_true_case = seq_postconds(fcx,\n-                ~[expr_postcond(fcx.ccx, antec),\n-                  block_postcond(fcx.ccx, conseq)]);\n-\n-            auto precond_res = seq_postconds(fcx, ~[precond_true_case,\n-                                                    precond_false_case]);\n-            auto postcond_res =\n-                intersect_states(postcond_true_case, postcond_false_case);\n-            set_pre_and_post(fcx.ccx, id, precond_res, postcond_res);\n-        }\n+    alt maybe_alt {\n+      none. {\n+        alt chck {\n+          if_check. {\n+            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n+            gen(fcx, antec.id, c.node);\n+          }\n+          _ { }\n+        }\n+\n+        let precond_res =\n+            seq_preconds(fcx,\n+                         ~[expr_pp(fcx.ccx, antec),\n+                           block_pp(fcx.ccx, conseq)]);\n+        set_pre_and_post(fcx.ccx, id, precond_res,\n+                         expr_poststate(fcx.ccx, antec));\n+      }\n+      some(altern) {\n+        /*\n+          if check = if_check, then\n+          be sure that the predicate implied by antec\n+          is *not* true in the alternative\n+         */\n+        find_pre_post_expr(fcx, altern);\n+        let precond_false_case =\n+            seq_preconds(fcx,\n+                         ~[expr_pp(fcx.ccx, antec),\n+                           expr_pp(fcx.ccx, altern)]);\n+        let postcond_false_case =\n+            seq_postconds(fcx,\n+                          ~[expr_postcond(fcx.ccx, antec),\n+                            expr_postcond(fcx.ccx, altern)]);\n+\n+        /* Be sure to set the bit for the check condition here,\n+         so that it's *not* set in the alternative. */\n+        alt chck {\n+          if_check. {\n+            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n+            gen(fcx, antec.id, c.node);\n+          }\n+          _ { }\n+        }\n+        let precond_true_case =\n+            seq_preconds(fcx,\n+                         ~[expr_pp(fcx.ccx, antec),\n+                           block_pp(fcx.ccx, conseq)]);\n+        let postcond_true_case =\n+            seq_postconds(fcx,\n+                          ~[expr_postcond(fcx.ccx, antec),\n+                            block_postcond(fcx.ccx, conseq)]);\n+\n+        let precond_res =\n+            seq_postconds(fcx, ~[precond_true_case, precond_false_case]);\n+        let postcond_res =\n+            intersect_states(postcond_true_case, postcond_false_case);\n+        set_pre_and_post(fcx.ccx, id, precond_res, postcond_res);\n+      }\n     }\n }\n \n-fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs, node_id larger_id,\n-                node_id new_var, &path pth) {\n-    alt (node_id_to_def(fcx.ccx, new_var)) {\n-        case (some(?d)) {\n-            alt (d) {\n-                case (def_local(?d_id)) {\n-                    find_pre_post_expr(fcx, rhs);\n-                    auto p = expr_pp(fcx.ccx, rhs);\n-                    set_pre_and_post(fcx.ccx, larger_id, p.precondition,\n-                                     p.postcondition);\n-                    gen(fcx, larger_id,\n-                        ninit(d_id.node, path_to_ident(fcx.ccx.tcx, pth)));\n-                }\n-                case (_) { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n-            }\n-        }\n-        case (_) { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n+fn gen_if_local(fcx: &fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n+                new_var: node_id, pth: &path) {\n+    alt node_id_to_def(fcx.ccx, new_var) {\n+      some(d) {\n+        alt d {\n+          def_local(d_id) {\n+            find_pre_post_expr(fcx, rhs);\n+            let p = expr_pp(fcx.ccx, rhs);\n+            set_pre_and_post(fcx.ccx, larger_id, p.precondition,\n+                             p.postcondition);\n+            gen(fcx, larger_id,\n+                ninit(d_id.node, path_to_ident(fcx.ccx.tcx, pth)));\n+          }\n+          _ { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n+        }\n+      }\n+      _ { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n     }\n }\n \n-fn handle_update(&fn_ctxt fcx, &@expr parent,\n-                 &@expr lhs, &@expr rhs, oper_type ty) {\n+fn handle_update(fcx: &fn_ctxt, parent: &@expr, lhs: &@expr, rhs: &@expr,\n+                 ty: oper_type) {\n     find_pre_post_expr(fcx, rhs);\n-     alt (lhs.node) {\n-        case (expr_path(?p)) {\n-            auto post = expr_postcond(fcx.ccx, parent);\n-            auto tmp = tritv_clone(post);\n-\n-            alt (ty) {\n-                case (oper_move) {\n-                    if (is_path(rhs)) {\n-                        forget_in_postcond(fcx, parent.id, rhs.id);\n-                    }\n-                }\n-                case (oper_swap) {\n-                    forget_in_postcond_still_init(fcx, parent.id, lhs.id);\n-                    forget_in_postcond_still_init(fcx, parent.id, rhs.id);\n-                }\n-                case (oper_assign) {\n-                    forget_in_postcond_still_init(fcx, parent.id, lhs.id);\n-                }\n-                case (_) {\n-                    // pure and assign_op require the lhs to be init'd\n-                    auto df = node_id_to_def_strict(fcx.ccx.tcx, lhs.id);\n-                    alt (df) {\n-                        case (def_local(?d_id)) {\n-                            auto i =\n-                                bit_num(fcx, ninit(d_id.node,\n-                                        path_to_ident(fcx.ccx.tcx, p)));\n-                            require_and_preserve(i, expr_pp(fcx.ccx, lhs));\n-                        }\n-                        case (_) {}\n-                    }\n-                }\n+    alt lhs.node {\n+      expr_path(p) {\n+        let post = expr_postcond(fcx.ccx, parent);\n+        let tmp = tritv_clone(post);\n+\n+        alt ty {\n+          oper_move. {\n+            if is_path(rhs) { forget_in_postcond(fcx, parent.id, rhs.id); }\n+          }\n+          oper_swap. {\n+            forget_in_postcond_still_init(fcx, parent.id, lhs.id);\n+            forget_in_postcond_still_init(fcx, parent.id, rhs.id);\n+          }\n+          oper_assign. {\n+            forget_in_postcond_still_init(fcx, parent.id, lhs.id);\n+          }\n+          _ {\n+            // pure and assign_op require the lhs to be init'd\n+            let df = node_id_to_def_strict(fcx.ccx.tcx, lhs.id);\n+            alt df {\n+              def_local(d_id) {\n+                let i =\n+                    bit_num(fcx,\n+                            ninit(d_id.node, path_to_ident(fcx.ccx.tcx, p)));\n+                require_and_preserve(i, expr_pp(fcx.ccx, lhs));\n+              }\n+              _ { }\n             }\n-\n-            gen_if_local(fcx, lhs, rhs, parent.id, lhs.id, p);\n-            alt (rhs.node) {\n-                case (expr_path(?p1)) {\n-                    auto d = local_node_id_to_local_def_id(fcx, lhs.id);\n-                    auto d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n-                    alt (d) {\n-                        case (some(?id)) {\n-                            alt (d1) {\n-                                case (some(?id1)) {\n-                                    auto instlhs =\n-                                        rec(ident=path_to_ident\n-                                            (fcx.ccx.tcx, p),\n-                                            node=id);\n-                                    auto instrhs =\n-                                        rec(ident=path_to_ident\n-                                            (fcx.ccx.tcx, p1),\n-                                            node=id1);\n-                                    copy_in_poststate_two(fcx, tmp,\n-                                        post, instlhs, instrhs, ty);\n-                                }\n-                                case (_) {}\n-                            }\n-                        }\n-                        case (_) {}\n-                    }\n+          }\n+        }\n+\n+        gen_if_local(fcx, lhs, rhs, parent.id, lhs.id, p);\n+        alt rhs.node {\n+          expr_path(p1) {\n+            let d = local_node_id_to_local_def_id(fcx, lhs.id);\n+            let d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n+            alt d {\n+              some(id) {\n+                alt d1 {\n+                  some(id1) {\n+                    let instlhs =\n+                        {ident: path_to_ident(fcx.ccx.tcx, p), node: id};\n+                    let instrhs =\n+                        {ident: path_to_ident(fcx.ccx.tcx, p1), node: id1};\n+                    copy_in_poststate_two(fcx, tmp, post, instlhs, instrhs,\n+                                          ty);\n+                  }\n+                  _ { }\n                 }\n-                case (_) { /* do nothing */ }\n+              }\n+              _ { }\n             }\n+          }\n+          _ {/* do nothing */ }\n         }\n-        case (_) {\n-            find_pre_post_expr(fcx, lhs);\n-        }\n+      }\n+      _ { find_pre_post_expr(fcx, lhs); }\n     }\n }\n \n-fn handle_var(&fn_ctxt fcx, &pre_and_post rslt, node_id id, ident name) {\n-    auto df = node_id_to_def_upvar_strict(fcx, id);\n-    alt (df) {\n-        case (def_local(?d_id)) {\n-            auto i = bit_num(fcx, ninit(d_id.node, name));\n-            use_var(fcx, d_id.node);\n-            require_and_preserve(i, rslt);\n-        }\n-        case (_) {/* nothing to check */ }\n+fn handle_var(fcx: &fn_ctxt, rslt: &pre_and_post, id: node_id, name: ident) {\n+    let df = node_id_to_def_upvar_strict(fcx, id);\n+    alt df {\n+      def_local(d_id) {\n+        let i = bit_num(fcx, ninit(d_id.node, name));\n+        use_var(fcx, d_id.node);\n+        require_and_preserve(i, rslt);\n+      }\n+      _ {/* nothing to check */ }\n     }\n }\n \n /* Fills in annotations as a side effect. Does not rebuild the expr */\n-fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n-    auto enclosing = fcx.enclosing;\n-    auto num_local_vars = num_constraints(enclosing);\n-    fn do_rand_(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n-\n-    alt (e.node) {\n-        case (expr_call(?operator, ?operands)) {\n-            auto args = /* copy */ operands;\n-            args += ~[operator];\n-\n-            find_pre_post_exprs(fcx, args, e.id);\n-            /* see if the call has any constraints on its type */\n-            for (@ty::constr c in constraints_expr(fcx.ccx.tcx, operator))\n-                {\n-                    auto i =\n-                        bit_num(fcx, substitute_constr_args(fcx.ccx.tcx,\n-                                                             args, c));\n-                    require(i, expr_pp(fcx.ccx, e));\n-                }\n-\n-            /* if this is a failing call, its postcondition sets everything */\n-            alt (controlflow_expr(fcx.ccx, operator)) {\n-                case (noreturn) { set_postcond_false(fcx.ccx, e.id); }\n-                case (_) { }\n-            }\n-        }\n-        case (expr_spawn(_, _, ?operator, ?operands)) {\n-            auto args = /* copy */ operands;\n-            args += ~[operator];\n-            find_pre_post_exprs(fcx, args, e.id);\n-        }\n-        case (expr_vec(?args, _, _)) {\n-            find_pre_post_exprs(fcx, args, e.id);\n-        }\n-        case (expr_path(?p)) {\n-            auto rslt = expr_pp(fcx.ccx, e);\n-            clear_pp(rslt);\n-            handle_var(fcx, rslt, e.id, path_to_ident(fcx.ccx.tcx, p));\n-        }\n-        case (expr_self_method(?v)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_log(_, ?arg)) {\n-            find_pre_post_expr(fcx, arg);\n-            copy_pre_post(fcx.ccx, e.id, arg);\n-        }\n-        case (expr_chan(?arg)) {\n+fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n+    let enclosing = fcx.enclosing;\n+    let num_local_vars = num_constraints(enclosing);\n+    fn do_rand_(fcx: fn_ctxt, e: &@expr) { find_pre_post_expr(fcx, e); }\n+\n+\n+    alt e.node {\n+      expr_call(operator, operands) {\n+        let /* copy */args = operands;\n+        args += ~[operator];\n+\n+        find_pre_post_exprs(fcx, args, e.id);\n+        /* see if the call has any constraints on its type */\n+        for c: @ty::constr  in constraints_expr(fcx.ccx.tcx, operator) {\n+            let i =\n+                bit_num(fcx, substitute_constr_args(fcx.ccx.tcx, args, c));\n+            require(i, expr_pp(fcx.ccx, e));\n+        }\n+\n+\n+        /* if this is a failing call, its postcondition sets everything */\n+        alt controlflow_expr(fcx.ccx, operator) {\n+          noreturn. { set_postcond_false(fcx.ccx, e.id); }\n+          _ { }\n+        }\n+      }\n+      expr_spawn(_, _, operator, operands) {\n+        let /* copy */args = operands;\n+        args += ~[operator];\n+        find_pre_post_exprs(fcx, args, e.id);\n+      }\n+      expr_vec(args, _, _) { find_pre_post_exprs(fcx, args, e.id); }\n+      expr_path(p) {\n+        let rslt = expr_pp(fcx.ccx, e);\n+        clear_pp(rslt);\n+        handle_var(fcx, rslt, e.id, path_to_ident(fcx.ccx.tcx, p));\n+      }\n+      expr_self_method(v) { clear_pp(expr_pp(fcx.ccx, e)); }\n+      expr_log(_, arg) {\n+        find_pre_post_expr(fcx, arg);\n+        copy_pre_post(fcx.ccx, e.id, arg);\n+      }\n+      expr_chan(arg) {\n+        find_pre_post_expr(fcx, arg);\n+        copy_pre_post(fcx.ccx, e.id, arg);\n+      }\n+      expr_put(opt) {\n+        alt opt {\n+          some(arg) {\n             find_pre_post_expr(fcx, arg);\n             copy_pre_post(fcx.ccx, e.id, arg);\n-        }\n-        case (expr_put(?opt)) {\n-            alt (opt) {\n-                case (some(?arg)) {\n-                    find_pre_post_expr(fcx, arg);\n-                    copy_pre_post(fcx.ccx, e.id, arg);\n-                }\n-                case (none) { clear_pp(expr_pp(fcx.ccx, e)); }\n-            }\n-        }\n-        case (expr_fn(?f)) {\n-            auto rslt = expr_pp(fcx.ccx, e);\n-            clear_pp(rslt);\n-            auto upvars = freevars::get_freevar_uses(fcx.ccx.tcx, e.id);\n-            for (node_id id in *upvars) {\n-                handle_var(fcx, rslt, id, \"upvar\");\n-            }\n-        }\n-        case (expr_block(?b)) {\n-            find_pre_post_block(fcx, b);\n-            auto p = block_pp(fcx.ccx, b);\n-            set_pre_and_post(fcx.ccx, e.id, p.precondition, p.postcondition);\n-        }\n-        case (expr_rec(?fields, ?maybe_base)) {\n-            auto es = field_exprs(fields);\n-            alt (maybe_base) {\n-              case (none) { /* no-op */ }\n-              case (some(?b)) { es += ~[b]; }\n-            }\n-            find_pre_post_exprs(fcx, es, e.id);\n-        }\n-        case (expr_move(?lhs, ?rhs)) {\n-            handle_update(fcx, e, lhs, rhs, oper_move);\n-        }\n-        case (expr_swap(?lhs, ?rhs)) {\n-            handle_update(fcx, e, lhs, rhs, oper_swap);\n-        }\n-        case (expr_assign(?lhs, ?rhs)) {\n-            handle_update(fcx, e, lhs, rhs, oper_assign);\n-        }\n-        case (expr_recv(?lhs, ?rhs)) {\n-            // note inversion of lhs and rhs\n-            handle_update(fcx, e, rhs, lhs, oper_assign);\n-        }\n-        case (expr_assign_op(_, ?lhs, ?rhs)) {\n-            /* Different from expr_assign in that the lhs *must*\n-               already be initialized */\n-\n-            find_pre_post_exprs(fcx, ~[lhs, rhs], e.id);\n-            forget_in_postcond_still_init(fcx, e.id, lhs.id);\n-        }\n-        case (expr_lit(_)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_ret(?maybe_val)) {\n-            alt (maybe_val) {\n-                case (none) {\n-                    clear_precond(fcx.ccx, e.id);\n-                    set_postcond_false(fcx.ccx, e.id);\n-                }\n-                case (some(?ret_val)) {\n-                    find_pre_post_expr(fcx, ret_val);\n-                    set_precondition(node_id_to_ts_ann(fcx.ccx, e.id),\n-                                     expr_precond(fcx.ccx, ret_val));\n-                    set_postcond_false(fcx.ccx, e.id);\n-                }\n-            }\n-        }\n-        case (expr_be(?val)) {\n-            find_pre_post_expr(fcx, val);\n-            set_pre_and_post(fcx.ccx, e.id, expr_prestate(fcx.ccx, val),\n-                             false_postcond(num_local_vars));\n-        }\n-        case (expr_if(?antec, ?conseq, ?maybe_alt)) {\n-            join_then_else(fcx, antec, conseq, maybe_alt, e.id, plain_if);\n-        }\n-        case (expr_ternary(_, _, _)) {\n-            find_pre_post_expr(fcx, ternary_to_if(e));\n-        }\n-        case (expr_binary(?bop, ?l, ?r)) {\n-            if (lazy_binop(bop)) {\n-                find_pre_post_expr(fcx, l);\n-                find_pre_post_expr(fcx, r);\n-                auto overall_pre = seq_preconds(fcx,\n-                   ~[expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]);\n-                set_precondition(node_id_to_ts_ann(fcx.ccx, e.id),\n-                                 overall_pre);\n-                set_postcondition(node_id_to_ts_ann(fcx.ccx, e.id),\n-                                  expr_postcond(fcx.ccx, l));\n-            }\n-            else {\n-                find_pre_post_exprs(fcx, ~[l, r], e.id);\n-            }\n-        }\n-        case (expr_send(?l, ?r)) {\n-            find_pre_post_exprs(fcx, ~[l, r], e.id);\n-        }\n-        case (expr_unary(_, ?operand)) {\n-            find_pre_post_expr(fcx, operand);\n-            copy_pre_post(fcx.ccx, e.id, operand);\n-        }\n-        case (expr_cast(?operand, _)) {\n-            find_pre_post_expr(fcx, operand);\n-            copy_pre_post(fcx.ccx, e.id, operand);\n-        }\n-        case (expr_while(?test, ?body)) {\n-            find_pre_post_expr(fcx, test);\n-            find_pre_post_block(fcx, body);\n-            set_pre_and_post(fcx.ccx, e.id,\n-                             seq_preconds(fcx, ~[expr_pp(fcx.ccx, test),\n-                                                 block_pp(fcx.ccx, body)]),\n-                             intersect_states(expr_postcond(fcx.ccx, test),\n-                                              block_postcond(fcx.ccx, body)));\n-        }\n-        case (expr_do_while(?body, ?test)) {\n-            find_pre_post_block(fcx, body);\n-            find_pre_post_expr(fcx, test);\n-            auto loop_postcond = seq_postconds(fcx,\n-                ~[block_postcond(fcx.ccx, body),\n-                  expr_postcond(fcx.ccx, test)]);\n-            /* conservative approximation: if the body\n-               could break or cont, the test may never be executed */\n-\n-            if (has_nonlocal_exits(body)) {\n-                loop_postcond = empty_poststate(num_local_vars);\n+          }\n+          none. { clear_pp(expr_pp(fcx.ccx, e)); }\n+        }\n+      }\n+      expr_fn(f) {\n+        let rslt = expr_pp(fcx.ccx, e);\n+        clear_pp(rslt);\n+        let upvars = freevars::get_freevar_uses(fcx.ccx.tcx, e.id);\n+        for id: node_id  in *upvars { handle_var(fcx, rslt, id, \"upvar\"); }\n+      }\n+      expr_block(b) {\n+        find_pre_post_block(fcx, b);\n+        let p = block_pp(fcx.ccx, b);\n+        set_pre_and_post(fcx.ccx, e.id, p.precondition, p.postcondition);\n+      }\n+      expr_rec(fields, maybe_base) {\n+        let es = field_exprs(fields);\n+        alt maybe_base { none. {/* no-op */ } some(b) { es += ~[b]; } }\n+        find_pre_post_exprs(fcx, es, e.id);\n+      }\n+      expr_move(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_move); }\n+      expr_swap(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_swap); }\n+      expr_assign(lhs, rhs) { handle_update(fcx, e, lhs, rhs, oper_assign); }\n+      expr_recv(lhs, rhs) {\n+        // note inversion of lhs and rhs\n+        handle_update(fcx, e, rhs, lhs, oper_assign);\n+      }\n+      expr_assign_op(_, lhs, rhs) {\n+        /* Different from expr_assign in that the lhs *must*\n+           already be initialized */\n+\n+        find_pre_post_exprs(fcx, ~[lhs, rhs], e.id);\n+        forget_in_postcond_still_init(fcx, e.id, lhs.id);\n+      }\n+      expr_lit(_) { clear_pp(expr_pp(fcx.ccx, e)); }\n+      expr_ret(maybe_val) {\n+        alt maybe_val {\n+          none. {\n+            clear_precond(fcx.ccx, e.id);\n+            set_postcond_false(fcx.ccx, e.id);\n+          }\n+          some(ret_val) {\n+            find_pre_post_expr(fcx, ret_val);\n+            set_precondition(node_id_to_ts_ann(fcx.ccx, e.id),\n+                             expr_precond(fcx.ccx, ret_val));\n+            set_postcond_false(fcx.ccx, e.id);\n+          }\n+        }\n+      }\n+      expr_be(val) {\n+        find_pre_post_expr(fcx, val);\n+        set_pre_and_post(fcx.ccx, e.id, expr_prestate(fcx.ccx, val),\n+                         false_postcond(num_local_vars));\n+      }\n+      expr_if(antec, conseq, maybe_alt) {\n+        join_then_else(fcx, antec, conseq, maybe_alt, e.id, plain_if);\n+      }\n+      expr_ternary(_, _, _) { find_pre_post_expr(fcx, ternary_to_if(e)); }\n+      expr_binary(bop, l, r) {\n+        if lazy_binop(bop) {\n+            find_pre_post_expr(fcx, l);\n+            find_pre_post_expr(fcx, r);\n+            let overall_pre =\n+                seq_preconds(fcx,\n+                             ~[expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]);\n+            set_precondition(node_id_to_ts_ann(fcx.ccx, e.id), overall_pre);\n+            set_postcondition(node_id_to_ts_ann(fcx.ccx, e.id),\n+                              expr_postcond(fcx.ccx, l));\n+        } else { find_pre_post_exprs(fcx, ~[l, r], e.id); }\n+      }\n+      expr_send(l, r) { find_pre_post_exprs(fcx, ~[l, r], e.id); }\n+      expr_unary(_, operand) {\n+        find_pre_post_expr(fcx, operand);\n+        copy_pre_post(fcx.ccx, e.id, operand);\n+      }\n+      expr_cast(operand, _) {\n+        find_pre_post_expr(fcx, operand);\n+        copy_pre_post(fcx.ccx, e.id, operand);\n+      }\n+      expr_while(test, body) {\n+        find_pre_post_expr(fcx, test);\n+        find_pre_post_block(fcx, body);\n+        set_pre_and_post(fcx.ccx, e.id,\n+                         seq_preconds(fcx,\n+                                      ~[expr_pp(fcx.ccx, test),\n+                                        block_pp(fcx.ccx, body)]),\n+                         intersect_states(expr_postcond(fcx.ccx, test),\n+                                          block_postcond(fcx.ccx, body)));\n+      }\n+      expr_do_while(body, test) {\n+        find_pre_post_block(fcx, body);\n+        find_pre_post_expr(fcx, test);\n+        let loop_postcond =\n+            seq_postconds(fcx,\n+                          ~[block_postcond(fcx.ccx, body),\n+                            expr_postcond(fcx.ccx, test)]);\n+        /* conservative approximation: if the body\n+           could break or cont, the test may never be executed */\n+\n+        if has_nonlocal_exits(body) {\n+            loop_postcond = empty_poststate(num_local_vars);\n+        }\n+        set_pre_and_post(fcx.ccx, e.id,\n+                         seq_preconds(fcx,\n+                                      ~[block_pp(fcx.ccx, body),\n+                                        expr_pp(fcx.ccx, test)]),\n+                         loop_postcond);\n+      }\n+      expr_for(d, index, body) {\n+        find_pre_post_loop(fcx, d, index, body, e.id);\n+      }\n+      expr_for_each(d, index, body) {\n+        find_pre_post_loop(fcx, d, index, body, e.id);\n+      }\n+      expr_index(val, sub) { find_pre_post_exprs(fcx, ~[val, sub], e.id); }\n+      expr_alt(ex, alts) {\n+        find_pre_post_expr(fcx, ex);\n+        fn do_an_alt(fcx: &fn_ctxt, an_alt: &arm) -> pre_and_post {\n+            find_pre_post_block(fcx, an_alt.block);\n+            ret block_pp(fcx.ccx, an_alt.block);\n+        }\n+        let alt_pps = ~[];\n+        for a: arm  in alts { alt_pps += ~[do_an_alt(fcx, a)]; }\n+        fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, pp: &pre_and_post,\n+                      next: &pre_and_post) -> pre_and_post {\n+            union(pp.precondition, seq_preconds(fcx, ~[antec, next]));\n+            intersect(pp.postcondition, next.postcondition);\n+            ret pp;\n+        }\n+        let antec_pp = pp_clone(expr_pp(fcx.ccx, ex));\n+        let e_pp =\n+            @{precondition: empty_prestate(num_local_vars),\n+              postcondition: false_postcond(num_local_vars)};\n+        let g = bind combine_pp(antec_pp, fcx, _, _);\n+        let alts_overall_pp =\n+            ivec::foldl[pre_and_post, pre_and_post](g, e_pp, alt_pps);\n+        set_pre_and_post(fcx.ccx, e.id, alts_overall_pp.precondition,\n+                         alts_overall_pp.postcondition);\n+      }\n+      expr_field(operator, _) {\n+        find_pre_post_expr(fcx, operator);\n+        copy_pre_post(fcx.ccx, e.id, operator);\n+      }\n+      expr_fail(maybe_val) {\n+        let prestate;\n+        alt maybe_val {\n+          none. { prestate = empty_prestate(num_local_vars); }\n+          some(fail_val) {\n+            find_pre_post_expr(fcx, fail_val);\n+            prestate = expr_precond(fcx.ccx, fail_val);\n+          }\n+        }\n+        set_pre_and_post(fcx.ccx, e.id,\n+                         /* if execution continues after fail,\n+                            then everything is true! */\n+                         prestate, false_postcond(num_local_vars));\n+      }\n+      expr_assert(p) {\n+        find_pre_post_expr(fcx, p);\n+        copy_pre_post(fcx.ccx, e.id, p);\n+      }\n+      expr_check(_, p) {\n+        find_pre_post_expr(fcx, p);\n+        copy_pre_post(fcx.ccx, e.id, p);\n+        /* predicate p holds after this expression executes */\n+\n+        let c: sp_constr = expr_to_constr(fcx.ccx.tcx, p);\n+        gen(fcx, e.id, c.node);\n+      }\n+      expr_if_check(p, conseq, maybe_alt) {\n+        join_then_else(fcx, p, conseq, maybe_alt, e.id, if_check);\n+      }\n+\n+\n+      expr_bind(operator, maybe_args) {\n+        let args = ~[];\n+        for expr_opt: option::t[@expr]  in maybe_args {\n+            alt expr_opt {\n+              none. {/* no-op */ }\n+              some(expr) { args += ~[expr]; }\n             }\n-            set_pre_and_post(fcx.ccx, e.id,\n-                             seq_preconds(fcx,\n-                                          ~[block_pp(fcx.ccx, body),\n-                                            expr_pp(fcx.ccx, test)]),\n-                             loop_postcond);\n-        }\n-        case (expr_for(?d, ?index, ?body)) {\n-            find_pre_post_loop(fcx, d, index, body, e.id);\n-        }\n-        case (expr_for_each(?d, ?index, ?body)) {\n-            find_pre_post_loop(fcx, d, index, body, e.id);\n-        }\n-        case (expr_index(?val, ?sub)) {\n-            find_pre_post_exprs(fcx, ~[val, sub], e.id);\n         }\n-        case (expr_alt(?ex, ?alts)) {\n+        args += ~[operator]; /* ??? order of eval? */\n+\n+        find_pre_post_exprs(fcx, args, e.id);\n+      }\n+      expr_break. { clear_pp(expr_pp(fcx.ccx, e)); }\n+      expr_cont. { clear_pp(expr_pp(fcx.ccx, e)); }\n+      expr_port(_) { clear_pp(expr_pp(fcx.ccx, e)); }\n+      expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n+      expr_anon_obj(anon_obj) {\n+        alt anon_obj.with_obj {\n+          some(ex) {\n             find_pre_post_expr(fcx, ex);\n-            fn do_an_alt(&fn_ctxt fcx, &arm an_alt) -> pre_and_post {\n-                find_pre_post_block(fcx, an_alt.block);\n-                ret block_pp(fcx.ccx, an_alt.block);\n-            }\n-            auto alt_pps = ~[];\n-            for (arm a in alts) { alt_pps += ~[do_an_alt(fcx, a)]; }\n-            fn combine_pp(pre_and_post antec, fn_ctxt fcx, &pre_and_post pp,\n-                          &pre_and_post next) -> pre_and_post {\n-                union(pp.precondition, seq_preconds(fcx, ~[antec, next]));\n-                intersect(pp.postcondition, next.postcondition);\n-                ret pp;\n-            }\n-            auto antec_pp = pp_clone(expr_pp(fcx.ccx, ex));\n-            auto e_pp =\n-                @rec(precondition=empty_prestate(num_local_vars),\n-                     postcondition=false_postcond(num_local_vars));\n-            auto g = bind combine_pp(antec_pp, fcx, _, _);\n-            auto alts_overall_pp =\n-                ivec::foldl[pre_and_post, pre_and_post](g, e_pp, alt_pps);\n-            set_pre_and_post(fcx.ccx, e.id, alts_overall_pp.precondition,\n-                             alts_overall_pp.postcondition);\n-        }\n-        case (expr_field(?operator, _)) {\n-            find_pre_post_expr(fcx, operator);\n-            copy_pre_post(fcx.ccx, e.id, operator);\n-        }\n-        case (expr_fail(?maybe_val)) {\n-            auto prestate;\n-            alt (maybe_val) {\n-                case (none) { prestate = empty_prestate(num_local_vars); }\n-                case (some(?fail_val)) {\n-                    find_pre_post_expr(fcx, fail_val);\n-                    prestate = expr_precond(fcx.ccx, fail_val);\n-                }\n-            }\n-            set_pre_and_post(fcx.ccx, e.id,\n-                             /* if execution continues after fail,\n-                                then everything is true! */\n-                             prestate,\n-                             false_postcond(num_local_vars));\n-        }\n-        case (expr_assert(?p)) {\n-            find_pre_post_expr(fcx, p);\n-            copy_pre_post(fcx.ccx, e.id, p);\n-        }\n-        case (expr_check(_, ?p)) {\n-            find_pre_post_expr(fcx, p);\n-            copy_pre_post(fcx.ccx, e.id, p);\n-            /* predicate p holds after this expression executes */\n-\n-            let sp_constr c = expr_to_constr(fcx.ccx.tcx, p);\n-            gen(fcx, e.id, c.node);\n-        }\n-        case (expr_if_check(?p, ?conseq, ?maybe_alt)) {\n-            join_then_else(fcx, p, conseq, maybe_alt, e.id, if_check);\n-        }\n-\n-        case (expr_bind(?operator, ?maybe_args)) {\n-            auto args = ~[];\n-            for (option::t[@expr] expr_opt in maybe_args) {\n-                alt (expr_opt) {\n-                  case (none) { /* no-op */ }\n-                  case (some(?expr)) { args += ~[expr]; }\n-                }\n-            }\n-            args += ~[operator]; /* ??? order of eval? */\n-\n-            find_pre_post_exprs(fcx, args, e.id);\n-        }\n-        case (expr_break) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_cont) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_port(_)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_mac(_)) {\n-            fcx.ccx.tcx.sess.bug(\"unexpanded macro\");\n-        }\n-        case (expr_anon_obj(?anon_obj)) {\n-            alt (anon_obj.with_obj) {\n-                case (some(?ex)) {\n-                    find_pre_post_expr(fcx, ex);\n-                    copy_pre_post(fcx.ccx, e.id, ex);\n-                }\n-                case (none) { clear_pp(expr_pp(fcx.ccx, e)); }\n-            }\n+            copy_pre_post(fcx.ccx, e.id, ex);\n+          }\n+          none. { clear_pp(expr_pp(fcx.ccx, e)); }\n         }\n+      }\n     }\n }\n \n-fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n+fn find_pre_post_stmt(fcx: &fn_ctxt, s: &stmt) {\n     log \"stmt =\";\n     log_stmt(s);\n-    alt (s.node) {\n-        case (stmt_decl(?adecl, ?id)) {\n-            alt (adecl.node) {\n-                case (decl_local(?alocals)) {\n-                  for (@local alocal in alocals) {\n-                    alt (alocal.node.init) {\n-                        case (some(?an_init)) {\n-                            /* LHS always becomes initialized,\n-                             whether or not this is a move */\n-\n-                            find_pre_post_expr(fcx, an_init.expr);\n-                            copy_pre_post(fcx.ccx, alocal.node.id,\n-                                          an_init.expr);\n-                            /* Inherit ann from initializer, and add var being\n-                               initialized to the postcondition */\n-\n-                            copy_pre_post(fcx.ccx, id, an_init.expr);\n-\n-                            alt (an_init.expr.node) {\n-                                case (expr_path(?p)) {\n-                                    copy_in_postcond(fcx, id,\n-                                      rec(ident=alocal.node.ident,\n-                                          node=alocal.node.id),\n-                                      rec(ident=path_to_ident(fcx.ccx.tcx, p),\n-                                          node=an_init.expr.id),\n-                                       op_to_oper_ty(an_init.op));\n-                                }\n-                                case (_) {}\n-                            }\n-\n-                            gen(fcx, id,\n-                                ninit(alocal.node.id,\n-                                      alocal.node.ident));\n-\n-                            if (an_init.op == init_move &&\n-                                is_path(an_init.expr)) {\n-                                forget_in_postcond(fcx, id, an_init.expr.id);\n-                            }\n-                        }\n-                        case (none) {\n-                            clear_pp(node_id_to_ts_ann(fcx.ccx,\n-                                                       alocal.node.id)\n-                                     .conditions);\n-                            clear_pp(node_id_to_ts_ann(fcx.ccx, id)\n-                                     .conditions);\n-                        }\n+    alt s.node {\n+      stmt_decl(adecl, id) {\n+        alt adecl.node {\n+          decl_local(alocals) {\n+            for alocal: @local  in alocals {\n+                alt alocal.node.init {\n+                  some(an_init) {\n+                    /* LHS always becomes initialized,\n+                     whether or not this is a move */\n+\n+                    find_pre_post_expr(fcx, an_init.expr);\n+                    copy_pre_post(fcx.ccx, alocal.node.id, an_init.expr);\n+                    /* Inherit ann from initializer, and add var being\n+                       initialized to the postcondition */\n+\n+                    copy_pre_post(fcx.ccx, id, an_init.expr);\n+\n+                    alt an_init.expr.node {\n+                      expr_path(p) {\n+                        copy_in_postcond(fcx, id,\n+                                         {ident: alocal.node.ident,\n+                                          node: alocal.node.id},\n+                                         {ident:\n+                                              path_to_ident(fcx.ccx.tcx, p),\n+                                          node: an_init.expr.id},\n+                                         op_to_oper_ty(an_init.op));\n+                      }\n+                      _ { }\n+                    }\n+\n+                    gen(fcx, id, ninit(alocal.node.id, alocal.node.ident));\n+\n+\n+                    if an_init.op == init_move && is_path(an_init.expr) {\n+                        forget_in_postcond(fcx, id, an_init.expr.id);\n                     }\n                   }\n-                }\n-                case (decl_item(?anitem)) {\n+                  none. {\n+                    clear_pp(node_id_to_ts_ann(fcx.ccx,\n+                                               alocal.node.id).conditions);\n                     clear_pp(node_id_to_ts_ann(fcx.ccx, id).conditions);\n-                    find_pre_post_item(fcx.ccx, *anitem);\n+                  }\n                 }\n             }\n-        }\n-        case (stmt_expr(?e, ?id)) {\n-            find_pre_post_expr(fcx, e);\n-            copy_pre_post(fcx.ccx, id, e);\n-        }\n+          }\n+          decl_item(anitem) {\n+            clear_pp(node_id_to_ts_ann(fcx.ccx, id).conditions);\n+            find_pre_post_item(fcx.ccx, *anitem);\n+          }\n+        }\n+      }\n+      stmt_expr(e, id) {\n+        find_pre_post_expr(fcx, e);\n+        copy_pre_post(fcx.ccx, id, e);\n+      }\n     }\n }\n \n-fn find_pre_post_block(&fn_ctxt fcx, blk b) {\n+fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n     /* Want to say that if there is a break or cont in this\n      block, then that invalidates the poststate upheld by\n     any of the stmts after it.\n@@ -666,70 +641,71 @@ fn find_pre_post_block(&fn_ctxt fcx, blk b) {\n      This will mean that:\n      x = 0;\n      break;\n-\n+    \n      won't have a postcondition that says x is initialized, but that's ok.\n      */\n \n-    auto nv = num_constraints(fcx.enclosing);\n-    fn do_one_(fn_ctxt fcx, &@stmt s) {\n+    let nv = num_constraints(fcx.enclosing);\n+    fn do_one_(fcx: fn_ctxt, s: &@stmt) {\n         find_pre_post_stmt(fcx, *s);\n         log \"pre_post for stmt:\";\n         log_stmt(*s);\n         log \"is:\";\n         log_pp(stmt_pp(fcx.ccx, *s));\n     }\n-    for (@stmt s in b.node.stmts) { do_one_(fcx, s); }\n-    fn do_inner_(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n-    auto do_inner = bind do_inner_(fcx, _);\n+    for s: @stmt  in b.node.stmts { do_one_(fcx, s); }\n+    fn do_inner_(fcx: fn_ctxt, e: &@expr) { find_pre_post_expr(fcx, e); }\n+    let do_inner = bind do_inner_(fcx, _);\n     option::map[@expr, ()](do_inner, b.node.expr);\n \n-    let pre_and_post[] pps = ~[];\n-    for (@stmt s in b.node.stmts) { pps += ~[stmt_pp(fcx.ccx, *s)]; }\n-    alt (b.node.expr) {\n-      case (none) { /* no-op */ }\n-      case (some(?e)) { pps += ~[expr_pp(fcx.ccx, e)]; }\n+    let pps: pre_and_post[] = ~[];\n+    for s: @stmt  in b.node.stmts { pps += ~[stmt_pp(fcx.ccx, *s)]; }\n+    alt b.node.expr {\n+      none. {/* no-op */ }\n+      some(e) { pps += ~[expr_pp(fcx.ccx, e)]; }\n     }\n \n-    auto block_precond = seq_preconds(fcx, pps);\n+    let block_precond = seq_preconds(fcx, pps);\n \n-    auto postconds = ~[];\n-    for (pre_and_post pp in pps) { postconds += ~[get_post(pp)]; }\n+    let postconds = ~[];\n+    for pp: pre_and_post  in pps { postconds += ~[get_post(pp)]; }\n \n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n     postconds += ~[block_precond];\n \n-    auto block_postcond = empty_poststate(nv);\n+    let block_postcond = empty_poststate(nv);\n     /* conservative approximation */\n \n-    if (!has_nonlocal_exits(b)) {\n+    if !has_nonlocal_exits(b) {\n         block_postcond = seq_postconds(fcx, postconds);\n     }\n     set_pre_and_post(fcx.ccx, b.node.id, block_precond, block_postcond);\n }\n \n-fn find_pre_post_fn(&fn_ctxt fcx, &_fn f) {\n+fn find_pre_post_fn(fcx: &fn_ctxt, f: &_fn) {\n     // hack\n     use_var(fcx, fcx.id);\n \n     find_pre_post_block(fcx, f.body);\n \n+\n     // Treat the tail expression as a return statement\n-    alt (f.body.node.expr) {\n-        case (some(?tailexpr)) {\n-            set_postcond_false(fcx.ccx, tailexpr.id);\n-        }\n-        case (none) {/* fallthrough */ }\n+    alt f.body.node.expr {\n+      some(tailexpr) { set_postcond_false(fcx.ccx, tailexpr.id); }\n+      none. {/* fallthrough */ }\n     }\n }\n \n-fn fn_pre_post(&_fn f, &ty_param[] tps,\n-               &span sp, &fn_ident i, node_id id, &crate_ctxt ccx,\n-               &visit::vt[crate_ctxt] v) {\n+fn fn_pre_post(f: &_fn, tps: &ty_param[], sp: &span, i: &fn_ident,\n+               id: node_id, ccx: &crate_ctxt, v: &visit::vt[crate_ctxt]) {\n     visit::visit_fn(f, tps, sp, i, id, ccx, v);\n     assert (ccx.fm.contains_key(id));\n-    auto fcx = rec(enclosing=ccx.fm.get(id), id=id,\n-                   name=fn_ident_to_string(id, i), ccx=ccx);\n+    let fcx =\n+        {enclosing: ccx.fm.get(id),\n+         id: id,\n+         name: fn_ident_to_string(id, i),\n+         ccx: ccx};\n     find_pre_post_fn(fcx, f);\n }\n //"}, {"sha": "b2ab7fd8c1134f6429aed83564f4a7967eeb28fe", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 548, "deletions": 566, "changes": 1114, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -53,178 +53,169 @@ import util::common::log_stmt;\n import util::common::log_stmt_err;\n import util::common::log_expr_err;\n \n-fn seq_states(&fn_ctxt fcx, prestate pres, &(@expr)[] exprs) ->\n-   rec(bool changed, poststate post) {\n-    auto changed = false;\n-    auto post = pres;\n-    for (@expr e in exprs) {\n+fn seq_states(fcx: &fn_ctxt, pres: prestate, exprs: &(@expr)[]) ->\n+   {changed: bool, post: poststate} {\n+    let changed = false;\n+    let post = pres;\n+    for e: @expr  in exprs {\n         changed |= find_pre_post_state_expr(fcx, post, e) || changed;\n         // log_err(\"Seq_states: changed =\");\n         // log_err changed;\n         post = expr_poststate(fcx.ccx, e);\n     }\n-    ret rec(changed=changed, post=post);\n+    ret {changed: changed, post: post};\n }\n \n-fn find_pre_post_state_sub(&fn_ctxt fcx, &prestate pres, &@expr e,\n-        node_id parent, option::t[tsconstr] c) -> bool {\n-    auto changed = find_pre_post_state_expr(fcx, pres, e);\n+fn find_pre_post_state_sub(fcx: &fn_ctxt, pres: &prestate, e: &@expr,\n+                           parent: node_id, c: option::t[tsconstr]) -> bool {\n+    let changed = find_pre_post_state_expr(fcx, pres, e);\n \n     changed = set_prestate_ann(fcx.ccx, parent, pres) || changed;\n \n-    auto post = tritv_clone(expr_poststate(fcx.ccx, e));\n-    alt (c) {\n-        case (none) {}\n-        case (some(?c1)) {\n-            set_in_poststate_(bit_num(fcx, c1), post);\n-        }\n+    let post = tritv_clone(expr_poststate(fcx.ccx, e));\n+    alt c {\n+      none. { }\n+      some(c1) { set_in_poststate_(bit_num(fcx, c1), post); }\n     }\n \n     changed = set_poststate_ann(fcx.ccx, parent, post) || changed;\n     ret changed;\n }\n \n-fn find_pre_post_state_two(&fn_ctxt fcx, &prestate pres, &@expr lhs,\n-                           &@expr rhs, node_id parent, oper_type ty)\n-    -> bool {\n-    auto changed = set_prestate_ann(fcx.ccx, parent, pres);\n+fn find_pre_post_state_two(fcx: &fn_ctxt, pres: &prestate, lhs: &@expr,\n+                           rhs: &@expr, parent: node_id, ty: oper_type) ->\n+   bool {\n+    let changed = set_prestate_ann(fcx.ccx, parent, pres);\n     changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n-    changed = find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs), rhs)\n-        || changed;\n-\n-    auto post = tritv_clone(expr_poststate(fcx.ccx, rhs));\n-\n-    alt (lhs.node) {\n-        case (expr_path(?p)) {\n-    // for termination, need to make sure intermediate changes don't set\n-    // changed flag\n-            // tmp remembers \"old\" constraints we'd otherwise forget,\n-            // for substitution purposes\n-            auto tmp = tritv_clone(post);\n-\n-            alt (ty) {\n-                case (oper_move) {\n-                    if (is_path(rhs)) {\n-                        forget_in_poststate(fcx, post, rhs.id);\n-                    }\n-                    forget_in_poststate_still_init(fcx, post, lhs.id);\n-                }\n-                case (oper_swap) {\n-                    forget_in_poststate_still_init(fcx, post, lhs.id);\n-                    forget_in_poststate_still_init(fcx, post, rhs.id);\n-                }\n-                case (_) {\n-                    forget_in_poststate_still_init(fcx, post, lhs.id);\n-                }\n-            }\n-\n-            gen_if_local(fcx, post, lhs);\n-            alt (rhs.node) {\n-                case (expr_path(?p1)) {\n-                    auto d = local_node_id_to_local_def_id(fcx, lhs.id);\n-                    auto d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n-                    alt (d) {\n-                        case (some(?id)) {\n-                            alt (d1) {\n-                                case (some(?id1)) {\n-                                    auto instlhs =\n-                                        rec(ident=path_to_ident\n-                                            (fcx.ccx.tcx, p),\n-                                            node=id);\n-                                    auto instrhs =\n-                                        rec(ident=path_to_ident\n-                                            (fcx.ccx.tcx, p1),\n-                                            node=id1);\n-                                    copy_in_poststate_two(fcx, tmp,\n-                                            post, instlhs, instrhs, ty);\n-                                }\n-                                case (_) {}\n-                            }\n-                        }\n-                        case (_) {}\n-                    }\n+    changed =\n+        find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs), rhs) ||\n+            changed;\n+\n+    let post = tritv_clone(expr_poststate(fcx.ccx, rhs));\n+\n+    alt lhs.node {\n+      expr_path(p) {\n+        // for termination, need to make sure intermediate changes don't set\n+        // changed flag\n+        // tmp remembers \"old\" constraints we'd otherwise forget,\n+        // for substitution purposes\n+        let tmp = tritv_clone(post);\n+\n+        alt ty {\n+          oper_move. {\n+            if is_path(rhs) { forget_in_poststate(fcx, post, rhs.id); }\n+            forget_in_poststate_still_init(fcx, post, lhs.id);\n+          }\n+          oper_swap. {\n+            forget_in_poststate_still_init(fcx, post, lhs.id);\n+            forget_in_poststate_still_init(fcx, post, rhs.id);\n+          }\n+          _ { forget_in_poststate_still_init(fcx, post, lhs.id); }\n+        }\n+\n+        gen_if_local(fcx, post, lhs);\n+        alt rhs.node {\n+          expr_path(p1) {\n+            let d = local_node_id_to_local_def_id(fcx, lhs.id);\n+            let d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n+            alt d {\n+              some(id) {\n+                alt d1 {\n+                  some(id1) {\n+                    let instlhs =\n+                        {ident: path_to_ident(fcx.ccx.tcx, p), node: id};\n+                    let instrhs =\n+                        {ident: path_to_ident(fcx.ccx.tcx, p1), node: id1};\n+                    copy_in_poststate_two(fcx, tmp, post, instlhs, instrhs,\n+                                          ty);\n+                  }\n+                  _ { }\n                 }\n-                case (_) { /* do nothing */ }\n+              }\n+              _ { }\n             }\n+          }\n+          _ {/* do nothing */ }\n         }\n-        case (_) { }\n+      }\n+      _ { }\n     }\n     changed = set_poststate_ann(fcx.ccx, parent, post) || changed;\n     ret changed;\n }\n \n-fn find_pre_post_state_call(&fn_ctxt fcx, &prestate pres, &@expr a,\n-                            node_id id, &(@expr)[] bs,\n-                            controlflow cf) -> bool {\n-    auto changed = find_pre_post_state_expr(fcx, pres, a);\n-    ret find_pre_post_state_exprs(fcx,\n-          expr_poststate(fcx.ccx, a), id, bs, cf) || changed;\n+fn find_pre_post_state_call(fcx: &fn_ctxt, pres: &prestate, a: &@expr,\n+                            id: node_id, bs: &(@expr)[], cf: controlflow) ->\n+   bool {\n+    let changed = find_pre_post_state_expr(fcx, pres, a);\n+    ret find_pre_post_state_exprs(fcx, expr_poststate(fcx.ccx, a), id, bs, cf)\n+            || changed;\n }\n \n-fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, node_id id,\n-                             &(@expr)[] es, controlflow cf) -> bool {\n-    auto rs = seq_states(fcx, pres, es);\n-    auto changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n+fn find_pre_post_state_exprs(fcx: &fn_ctxt, pres: &prestate, id: node_id,\n+                             es: &(@expr)[], cf: controlflow) -> bool {\n+    let rs = seq_states(fcx, pres, es);\n+    let changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n     /* if this is a failing call, it sets everything as initialized */\n-    alt (cf) {\n-        case (noreturn) {\n-            changed |= set_poststate_ann\n-                (fcx.ccx, id, false_postcond(num_constraints(fcx.enclosing)));\n-        }\n-        case (_) {\n-            changed |= set_poststate_ann(fcx.ccx, id, rs.post);\n-        }\n+    alt cf {\n+      noreturn. {\n+        changed |=\n+            set_poststate_ann(fcx.ccx, id,\n+                              false_postcond(num_constraints(fcx.enclosing)));\n+      }\n+      _ { changed |= set_poststate_ann(fcx.ccx, id, rs.post); }\n     }\n     ret changed;\n }\n \n-fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@local l,\n-                            &@expr index, &blk body, node_id id)\n-    -> bool {\n-    auto loop_pres = intersect_states(pres,\n-                                      block_poststate(fcx.ccx, body));\n+fn find_pre_post_state_loop(fcx: &fn_ctxt, pres: prestate, l: &@local,\n+                            index: &@expr, body: &blk, id: node_id) -> bool {\n+    let loop_pres = intersect_states(pres, block_poststate(fcx.ccx, body));\n \n-    auto changed = set_prestate_ann(fcx.ccx, id, loop_pres) |\n-        find_pre_post_state_expr(fcx, pres, index);\n+    let changed =\n+        set_prestate_ann(fcx.ccx, id, loop_pres) |\n+            find_pre_post_state_expr(fcx, pres, index);\n \n     // Make sure the index var is considered initialized\n     // in the body\n-    auto index_post = tritv_clone(expr_poststate(fcx.ccx, index));\n+    let index_post = tritv_clone(expr_poststate(fcx.ccx, index));\n     set_in_poststate_ident(fcx, l.node.id, l.node.ident, index_post);\n \n     changed |= find_pre_post_state_block(fcx, index_post, body);\n \n-    if (has_nonlocal_exits(body)) {\n+\n+    if has_nonlocal_exits(body) {\n         // See [Break-unsound]\n-        ret (changed | set_poststate_ann(fcx.ccx, id, pres));\n-    }\n-    else {\n-        auto res_p = intersect_states(expr_poststate(fcx.ccx, index),\n-                                      block_poststate(fcx.ccx, body));\n+        ret changed | set_poststate_ann(fcx.ccx, id, pres);\n+    } else {\n+        let res_p =\n+            intersect_states(expr_poststate(fcx.ccx, index),\n+                             block_poststate(fcx.ccx, body));\n         ret changed | set_poststate_ann(fcx.ccx, id, res_p);\n     }\n }\n \n-fn gen_if_local(&fn_ctxt fcx, &poststate p, &@expr e) -> bool {\n-    alt (e.node) {\n-        case (expr_path(?pth)) {\n-            alt (freevars::def_lookup(fcx.ccx.tcx, fcx.id, e.id)) {\n-                case (some(def_local(?loc))) {\n-                    ret set_in_poststate_ident(fcx, loc.node,\n-                           path_to_ident(fcx.ccx.tcx, pth), p);\n-                }\n-            case (_) { ret false; }\n-            }\n-        }\n-    case (_) { ret false; }\n+fn gen_if_local(fcx: &fn_ctxt, p: &poststate, e: &@expr) -> bool {\n+    alt e.node {\n+      expr_path(pth) {\n+        alt freevars::def_lookup(fcx.ccx.tcx, fcx.id, e.id) {\n+          some(def_local(loc)) {\n+            ret set_in_poststate_ident(fcx, loc.node,\n+                                       path_to_ident(fcx.ccx.tcx, pth), p);\n+          }\n+          _ { ret false; }\n+        }\n+      }\n+      _ { ret false; }\n     }\n }\n \n-fn join_then_else(&fn_ctxt fcx, &@expr antec, &blk conseq,\n-                  &option::t[@expr] maybe_alt, node_id id, &if_ty chk,\n-                  &prestate pres) -> bool {\n-    auto changed = set_prestate_ann(fcx.ccx, id, pres) |\n-        find_pre_post_state_expr(fcx, pres, antec);\n+fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n+                  maybe_alt: &option::t[@expr], id: node_id, chk: &if_ty,\n+                  pres: &prestate) -> bool {\n+    let changed =\n+        set_prestate_ann(fcx.ccx, id, pres) |\n+            find_pre_post_state_expr(fcx, pres, antec);\n \n     /*\n     log_err(\"join_then_else:\");\n@@ -241,345 +232,339 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &blk conseq,\n     log_bitv_err(fcx, block_postcond(fcx.ccx, conseq));\n     */\n \n-    alt (maybe_alt) {\n-        case (none) {\n-            changed |= find_pre_post_state_block\n-                (fcx, expr_poststate(fcx.ccx, antec), conseq) |\n+    alt maybe_alt {\n+      none. {\n+        changed |=\n+            find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, antec),\n+                                      conseq) |\n                 set_poststate_ann(fcx.ccx, id,\n                                   expr_poststate(fcx.ccx, antec));\n-        }\n-        case (some(?altern)) {\n-            changed |= find_pre_post_state_expr\n-                (fcx, expr_poststate(fcx.ccx, antec), altern);\n-\n-            auto conseq_prestate = expr_poststate(fcx.ccx, antec);\n-            alt (chk) {\n-                case (if_check) {\n-                    let sp_constr c = expr_to_constr(fcx.ccx.tcx, antec);\n-                    conseq_prestate = tritv_clone(conseq_prestate);\n-                    tritv_set(bit_num(fcx, c.node), conseq_prestate, ttrue);\n-                }\n-                case (_) {}\n-            }\n-\n-\n-            changed |=\n-                find_pre_post_state_block(fcx, conseq_prestate, conseq);\n-\n-            auto poststate_res =\n-                intersect_states(block_poststate(fcx.ccx, conseq),\n-                                    expr_poststate(fcx.ccx, altern));\n-            /*\n-               fcx.ccx.tcx.sess.span_note(antec.span,\n-               \"poststate_res = \" + aux::tritv_to_str(fcx, poststate_res));\n-            fcx.ccx.tcx.sess.span_note(antec.span,\n-               \"altern poststate = \" +\n-                aux::tritv_to_str(fcx, expr_poststate(fcx.ccx, altern)));\n-            fcx.ccx.tcx.sess.span_note(antec.span,\n-            \"conseq poststate = \" + aux::tritv_to_str(fcx,\n-               block_poststate(fcx.ccx, conseq)));\n-            */\n-\n-            changed |= set_poststate_ann(fcx.ccx, id, poststate_res);\n-        }\n+      }\n+      some(altern) {\n+        changed |=\n+            find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, antec),\n+                                     altern);\n+\n+        let conseq_prestate = expr_poststate(fcx.ccx, antec);\n+        alt chk {\n+          if_check. {\n+            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n+            conseq_prestate = tritv_clone(conseq_prestate);\n+            tritv_set(bit_num(fcx, c.node), conseq_prestate, ttrue);\n+          }\n+          _ { }\n+        }\n+\n+\n+        changed |= find_pre_post_state_block(fcx, conseq_prestate, conseq);\n+\n+        let poststate_res =\n+            intersect_states(block_poststate(fcx.ccx, conseq),\n+                             expr_poststate(fcx.ccx, altern));\n+        /*\n+           fcx.ccx.tcx.sess.span_note(antec.span,\n+           \"poststate_res = \" + aux::tritv_to_str(fcx, poststate_res));\n+        fcx.ccx.tcx.sess.span_note(antec.span,\n+           \"altern poststate = \" +\n+            aux::tritv_to_str(fcx, expr_poststate(fcx.ccx, altern)));\n+        fcx.ccx.tcx.sess.span_note(antec.span,\n+        \"conseq poststate = \" + aux::tritv_to_str(fcx,\n+           block_poststate(fcx.ccx, conseq)));\n+        */\n+\n+        changed |= set_poststate_ann(fcx.ccx, id, poststate_res);\n+      }\n     }\n     ret changed;\n }\n \n-fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n-    auto num_constrs = num_constraints(fcx.enclosing);\n-\n-    alt (e.node) {\n-        case (expr_vec(?elts, _, _)) {\n-            ret find_pre_post_state_exprs(fcx, pres, e.id, elts, return);\n-        }\n-        case (expr_call(?operator, ?operands)) {\n-            ret find_pre_post_state_call\n-                (fcx, pres, operator, e.id, operands,\n-                 controlflow_expr(fcx.ccx, operator));\n-        }\n-        case (expr_spawn(_, _, ?operator, ?operands)) {\n-            ret find_pre_post_state_call(fcx, pres, operator, e.id, operands,\n-                                         return);\n-        }\n-        case (expr_bind(?operator, ?maybe_args)) {\n-            auto args = ~[];\n-            for (option::t[@expr] a_opt in maybe_args) {\n-                alt (a_opt) {\n-                  case (none) { /* no-op */ }\n-                  case (some(?a)) { args += ~[a]; }\n-                }\n-            }\n-\n-            ret find_pre_post_state_call(fcx, pres, operator, e.id, args,\n-                                         return);\n-        }\n-        case (expr_path(_)) { ret pure_exp(fcx.ccx, e.id, pres); }\n-        case (expr_log(_, ?ex)) {\n-            ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n-        }\n-        case (expr_chan(?ex)) {\n-            ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n-        }\n-        case (expr_mac(_)) {\n-            fcx.ccx.tcx.sess.bug(\"unexpanded macro\");\n-        }\n-        case (expr_put(?maybe_e)) {\n-            alt (maybe_e) {\n-                case (some(?arg)) {\n-                    ret find_pre_post_state_sub(fcx, pres, arg, e.id, none);\n-                }\n-                case (none) { ret pure_exp(fcx.ccx, e.id, pres); }\n-            }\n-        }\n-        case (expr_lit(?l)) { ret pure_exp(fcx.ccx, e.id, pres); }\n-        case (expr_fn(?f)) { ret pure_exp(fcx.ccx, e.id, pres); }\n-        case (expr_block(?b)) {\n-            ret find_pre_post_state_block(fcx, pres, b) |\n+fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n+   bool {\n+    let num_constrs = num_constraints(fcx.enclosing);\n+\n+\n+    alt e.node {\n+      expr_vec(elts, _, _) {\n+        ret find_pre_post_state_exprs(fcx, pres, e.id, elts, return);\n+      }\n+      expr_call(operator, operands) {\n+        ret find_pre_post_state_call(fcx, pres, operator, e.id, operands,\n+                                     controlflow_expr(fcx.ccx, operator));\n+      }\n+      expr_spawn(_, _, operator, operands) {\n+        ret find_pre_post_state_call(fcx, pres, operator, e.id, operands,\n+                                     return);\n+      }\n+      expr_bind(operator, maybe_args) {\n+        let args = ~[];\n+        for a_opt: option::t[@expr]  in maybe_args {\n+            alt a_opt { none. {/* no-op */ } some(a) { args += ~[a]; } }\n+        }\n+\n+        ret find_pre_post_state_call(fcx, pres, operator, e.id, args, return);\n+      }\n+      expr_path(_) { ret pure_exp(fcx.ccx, e.id, pres); }\n+      expr_log(_, ex) {\n+        ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n+      }\n+      expr_chan(ex) {\n+        ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n+      }\n+      expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n+      expr_put(maybe_e) {\n+        alt maybe_e {\n+          some(arg) {\n+            ret find_pre_post_state_sub(fcx, pres, arg, e.id, none);\n+          }\n+          none. { ret pure_exp(fcx.ccx, e.id, pres); }\n+        }\n+      }\n+      expr_lit(l) { ret pure_exp(fcx.ccx, e.id, pres); }\n+      expr_fn(f) { ret pure_exp(fcx.ccx, e.id, pres); }\n+      expr_block(b) {\n+        ret find_pre_post_state_block(fcx, pres, b) |\n                 set_prestate_ann(fcx.ccx, e.id, pres) |\n                 set_poststate_ann(fcx.ccx, e.id, block_poststate(fcx.ccx, b));\n-        }\n-        case (expr_rec(?fields, ?maybe_base)) {\n-            auto changed = find_pre_post_state_exprs\n-                (fcx, pres, e.id, field_exprs(fields), return);\n-            alt (maybe_base) {\n-                case (none) {/* do nothing */ }\n-                case (some(?base)) {\n-                    changed |= find_pre_post_state_expr(fcx, pres, base) |\n-                        set_poststate_ann(fcx.ccx, e.id,\n-                                          expr_poststate(fcx.ccx, base));\n-                }\n-            }\n-            ret changed;\n-        }\n-        case (expr_move(?lhs, ?rhs)) {\n-            ret find_pre_post_state_two(fcx, pres, lhs, rhs,\n-                                        e.id, oper_move);\n-        }\n-        case (expr_assign(?lhs, ?rhs)) {\n-            ret find_pre_post_state_two(fcx, pres, lhs, rhs,\n-                                        e.id, oper_assign);\n-        }\n-        case (expr_swap(?lhs, ?rhs)) {\n-           ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id,\n-                                       oper_swap);\n-             // Could be more precise and actually swap the role of\n-             // lhs and rhs in constraints\n-        }\n-        case (expr_recv(?lhs, ?rhs)) {\n-            // Opposite order as most other binary operations,\n-            // so not using find_pre_post_state_two\n-            auto changed = set_prestate_ann(fcx.ccx, e.id, pres) |\n+      }\n+      expr_rec(fields, maybe_base) {\n+        let changed =\n+            find_pre_post_state_exprs(fcx, pres, e.id, field_exprs(fields),\n+                                      return);\n+        alt maybe_base {\n+          none. {/* do nothing */ }\n+          some(base) {\n+            changed |=\n+                find_pre_post_state_expr(fcx, pres, base) |\n+                    set_poststate_ann(fcx.ccx, e.id,\n+                                      expr_poststate(fcx.ccx, base));\n+          }\n+        }\n+        ret changed;\n+      }\n+      expr_move(lhs, rhs) {\n+        ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id, oper_move);\n+      }\n+      expr_assign(lhs, rhs) {\n+        ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id, oper_assign);\n+      }\n+      expr_swap(lhs, rhs) {\n+        ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id, oper_swap);\n+        // Could be more precise and actually swap the role of\n+        // lhs and rhs in constraints\n+      }\n+      expr_recv(lhs, rhs) {\n+        // Opposite order as most other binary operations,\n+        // so not using find_pre_post_state_two\n+        let changed =\n+            set_prestate_ann(fcx.ccx, e.id, pres) |\n                 find_pre_post_state_expr(fcx, pres, lhs) |\n-                find_pre_post_state_expr\n-                (fcx, expr_poststate(fcx.ccx, lhs), rhs);\n-            auto post = tritv_clone(expr_poststate(fcx.ccx, rhs));\n-            forget_in_poststate_still_init(fcx, post, rhs.id);\n-            gen_if_local(fcx, post, rhs);\n-            ret changed | set_poststate_ann(fcx.ccx, e.id, post);\n-        }\n-        case (expr_ret(?maybe_ret_val)) {\n-            auto changed = set_prestate_ann(fcx.ccx, e.id, pres);\n-            /* normally, everything is true if execution continues after\n-               a ret expression (since execution never continues locally\n-               after a ret expression */\n-\n-            set_poststate_ann(fcx.ccx, e.id, false_postcond(num_constrs));\n-            /* return from an always-failing function clears the return bit */\n-\n-            alt (fcx.enclosing.cf) {\n-                case (noreturn) {\n-                    kill_poststate(fcx, e.id, ninit(fcx.id, fcx.name));\n-                }\n-                case (_) { }\n-            }\n-            alt (maybe_ret_val) {\n-                case (none) {/* do nothing */ }\n-                case (some(?ret_val)) {\n-                    changed |= find_pre_post_state_expr(fcx, pres, ret_val);\n-                }\n-            }\n-            ret changed;\n-        }\n-        case (expr_be(?val)) {\n-            auto changed = set_prestate_ann(fcx.ccx, e.id, pres);\n-            set_poststate_ann(fcx.ccx, e.id, false_postcond(num_constrs));\n-            ret changed | find_pre_post_state_expr(fcx, pres, val);\n-        }\n-        case (expr_if(?antec, ?conseq, ?maybe_alt)) {\n-            ret join_then_else\n-                (fcx, antec, conseq, maybe_alt, e.id, plain_if, pres);\n-        }\n-        case (expr_ternary(_, _, _)) {\n-            ret find_pre_post_state_expr(fcx, pres, ternary_to_if(e));\n-        }\n-        case (expr_binary(?bop, ?l, ?r)) {\n-            if (lazy_binop(bop)) {\n-                auto changed = find_pre_post_state_expr(fcx, pres, l);\n-                changed |= find_pre_post_state_expr(fcx,\n-                              expr_poststate(fcx.ccx, l), r);\n-                ret changed\n-                    | set_prestate_ann(fcx.ccx, e.id, pres)\n-                    | set_poststate_ann(fcx.ccx, e.id,\n-                                        expr_poststate(fcx.ccx, l));\n-            }\n-            else {\n-                ret find_pre_post_state_two(fcx, pres, l, r, e.id, oper_pure);\n-            }\n-        }\n-        case (expr_send(?l, ?r)) {\n+                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs),\n+                                         rhs);\n+        let post = tritv_clone(expr_poststate(fcx.ccx, rhs));\n+        forget_in_poststate_still_init(fcx, post, rhs.id);\n+        gen_if_local(fcx, post, rhs);\n+        ret changed | set_poststate_ann(fcx.ccx, e.id, post);\n+      }\n+      expr_ret(maybe_ret_val) {\n+        let changed = set_prestate_ann(fcx.ccx, e.id, pres);\n+        /* normally, everything is true if execution continues after\n+           a ret expression (since execution never continues locally\n+           after a ret expression */\n+\n+        set_poststate_ann(fcx.ccx, e.id, false_postcond(num_constrs));\n+        /* return from an always-failing function clears the return bit */\n+\n+        alt fcx.enclosing.cf {\n+          noreturn. { kill_poststate(fcx, e.id, ninit(fcx.id, fcx.name)); }\n+          _ { }\n+        }\n+        alt maybe_ret_val {\n+          none. {/* do nothing */ }\n+          some(ret_val) {\n+            changed |= find_pre_post_state_expr(fcx, pres, ret_val);\n+          }\n+        }\n+        ret changed;\n+      }\n+      expr_be(val) {\n+        let changed = set_prestate_ann(fcx.ccx, e.id, pres);\n+        set_poststate_ann(fcx.ccx, e.id, false_postcond(num_constrs));\n+        ret changed | find_pre_post_state_expr(fcx, pres, val);\n+      }\n+      expr_if(antec, conseq, maybe_alt) {\n+        ret join_then_else(fcx, antec, conseq, maybe_alt, e.id, plain_if,\n+                           pres);\n+      }\n+      expr_ternary(_, _, _) {\n+        ret find_pre_post_state_expr(fcx, pres, ternary_to_if(e));\n+      }\n+      expr_binary(bop, l, r) {\n+        if lazy_binop(bop) {\n+            let changed = find_pre_post_state_expr(fcx, pres, l);\n+            changed |=\n+                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r);\n+            ret changed | set_prestate_ann(fcx.ccx, e.id, pres) |\n+                    set_poststate_ann(fcx.ccx, e.id,\n+                                      expr_poststate(fcx.ccx, l));\n+        } else {\n             ret find_pre_post_state_two(fcx, pres, l, r, e.id, oper_pure);\n         }\n-        case (expr_assign_op(?op, ?lhs, ?rhs)) {\n-            ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id,\n-                                        oper_assign_op);\n-        }\n-        case (expr_while(?test, ?body)) {\n-            /*\n-            log_err \"in a while loop:\";\n-            log_expr_err(*e);\n-            aux::log_tritv_err(fcx, block_poststate(fcx.ccx, body));\n-            aux::log_tritv_err(fcx, pres);\n-            */\n-            auto loop_pres = intersect_states\n-                (block_poststate(fcx.ccx, body), pres);\n-            // aux::log_tritv_err(fcx, loop_pres);\n-            // log_err \"---------------\";\n-\n-            auto changed = set_prestate_ann(fcx.ccx, e.id, loop_pres) |\n+      }\n+      expr_send(l, r) {\n+        ret find_pre_post_state_two(fcx, pres, l, r, e.id, oper_pure);\n+      }\n+      expr_assign_op(op, lhs, rhs) {\n+        ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id,\n+                                    oper_assign_op);\n+      }\n+      expr_while(test, body) {\n+        /*\n+        log_err \"in a while loop:\";\n+        log_expr_err(*e);\n+        aux::log_tritv_err(fcx, block_poststate(fcx.ccx, body));\n+        aux::log_tritv_err(fcx, pres);\n+        */\n+        let loop_pres =\n+            intersect_states(block_poststate(fcx.ccx, body), pres);\n+        // aux::log_tritv_err(fcx, loop_pres);\n+        // log_err \"---------------\";\n+\n+        let changed =\n+            set_prestate_ann(fcx.ccx, e.id, loop_pres) |\n                 find_pre_post_state_expr(fcx, loop_pres, test) |\n                 find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, test),\n                                           body);\n-            /* conservative approximation: if a loop contains a break\n-               or cont, we assume nothing about the poststate */\n-            /* which is still unsound -- see [Break-unsound] */\n-            if (has_nonlocal_exits(body)) {\n-                ret changed | set_poststate_ann(fcx.ccx, e.id, pres);\n-            }\n-            else {\n-                auto e_post = expr_poststate(fcx.ccx, test);\n-                auto b_post = block_poststate(fcx.ccx, body);\n-                ret changed | set_poststate_ann\n-                    (fcx.ccx, e.id, intersect_states(e_post, b_post));\n-            }\n-        }\n-        case (expr_do_while(?body, ?test)) {\n-            auto loop_pres = intersect_states(expr_poststate(fcx.ccx, test),\n-                                              pres);\n-\n-            auto changed = set_prestate_ann(fcx.ccx, e.id, loop_pres);\n-            changed |= find_pre_post_state_block(fcx, loop_pres, body);\n-            /* conservative approximination: if the body of the loop\n-               could break or cont, we revert to the prestate\n-               (TODO: could treat cont differently from break, since\n-               if there's a cont, the test will execute) */\n-\n-            changed |= find_pre_post_state_expr\n-                (fcx, block_poststate(fcx.ccx, body), test);\n-\n-            auto breaks = has_nonlocal_exits(body);\n-            if (breaks) {\n-                // this should probably be true_poststate and not pres,\n-                // b/c the body could invalidate stuff\n-                // FIXME [Break-unsound]\n-                // This is unsound as it is -- consider\n-                // while (true) {\n-                //    x <- y;\n-                //    break;\n-                // }\n-                // The poststate wouldn't take into account that\n-                // y gets deinitialized\n-                changed |= set_poststate_ann(fcx.ccx, e.id, pres);\n-             }\n-            else {\n-                changed |= set_poststate_ann\n-                    (fcx.ccx, e.id, expr_poststate(fcx.ccx, test));\n-            }\n-            ret changed;\n-        }\n-        case (expr_for(?d, ?index, ?body)) {\n-            ret find_pre_post_state_loop(fcx, pres, d, index, body, e.id);\n-        }\n-        case (expr_for_each(?d, ?index, ?body)) {\n-            ret find_pre_post_state_loop(fcx, pres, d, index, body, e.id);\n-        }\n-        case (expr_index(?val, ?sub)) {\n-            ret find_pre_post_state_two(fcx, pres, val, sub, e.id, oper_pure);\n-        }\n-        case (expr_alt(?val, ?alts)) {\n-            auto changed = set_prestate_ann(fcx.ccx, e.id, pres) |\n-                find_pre_post_state_expr(fcx, pres, val);\n-            auto e_post = expr_poststate(fcx.ccx, val);\n-            auto a_post;\n-            if (ivec::len(alts) > 0u) {\n-                a_post = false_postcond(num_constrs);\n-                for (arm an_alt in alts) {\n-                    changed |= find_pre_post_state_block\n-                        (fcx, e_post, an_alt.block);\n-                    intersect(a_post, block_poststate(fcx.ccx, an_alt.block));\n-                    // We deliberately do *not* update changed here, because\n-                    // we'd go into an infinite loop that way, and the change\n-                    // gets made after the if expression.\n \n-                }\n-            } else {\n-                // No alts; poststate is the poststate of the test\n+        /* conservative approximation: if a loop contains a break\n+           or cont, we assume nothing about the poststate */\n+        /* which is still unsound -- see [Break-unsound] */\n+        if has_nonlocal_exits(body) {\n+            ret changed | set_poststate_ann(fcx.ccx, e.id, pres);\n+        } else {\n+            let e_post = expr_poststate(fcx.ccx, test);\n+            let b_post = block_poststate(fcx.ccx, body);\n+            ret changed |\n+                    set_poststate_ann(fcx.ccx, e.id,\n+                                      intersect_states(e_post, b_post));\n+        }\n+      }\n+      expr_do_while(body, test) {\n+        let loop_pres = intersect_states(expr_poststate(fcx.ccx, test), pres);\n+\n+        let changed = set_prestate_ann(fcx.ccx, e.id, loop_pres);\n+        changed |= find_pre_post_state_block(fcx, loop_pres, body);\n+        /* conservative approximination: if the body of the loop\n+           could break or cont, we revert to the prestate\n+           (TODO: could treat cont differently from break, since\n+           if there's a cont, the test will execute) */\n+\n+        changed |=\n+            find_pre_post_state_expr(fcx, block_poststate(fcx.ccx, body),\n+                                     test);\n+\n+        let breaks = has_nonlocal_exits(body);\n+        if breaks {\n+            // this should probably be true_poststate and not pres,\n+            // b/c the body could invalidate stuff\n+            // FIXME [Break-unsound]\n+            // This is unsound as it is -- consider\n+            // while (true) {\n+            //    x <- y;\n+            //    break;\n+            // }\n+            // The poststate wouldn't take into account that\n+            // y gets deinitialized\n+            changed |= set_poststate_ann(fcx.ccx, e.id, pres);\n+        } else {\n+            changed |=\n+                set_poststate_ann(fcx.ccx, e.id,\n+                                  expr_poststate(fcx.ccx, test));\n+        }\n+        ret changed;\n+      }\n+      expr_for(d, index, body) {\n+        ret find_pre_post_state_loop(fcx, pres, d, index, body, e.id);\n+      }\n+      expr_for_each(d, index, body) {\n+        ret find_pre_post_state_loop(fcx, pres, d, index, body, e.id);\n+      }\n+      expr_index(val, sub) {\n+        ret find_pre_post_state_two(fcx, pres, val, sub, e.id, oper_pure);\n+      }\n+      expr_alt(val, alts) {\n+        let changed =\n+            set_prestate_ann(fcx.ccx, e.id, pres) |\n+                find_pre_post_state_expr(fcx, pres, val);\n+        let e_post = expr_poststate(fcx.ccx, val);\n+        let a_post;\n+        if ivec::len(alts) > 0u {\n+            a_post = false_postcond(num_constrs);\n+            for an_alt: arm  in alts {\n+                changed |=\n+                    find_pre_post_state_block(fcx, e_post, an_alt.block);\n+                intersect(a_post, block_poststate(fcx.ccx, an_alt.block));\n+                // We deliberately do *not* update changed here, because\n+                // we'd go into an infinite loop that way, and the change\n+                // gets made after the if expression.\n \n-                a_post = e_post;\n             }\n-            ret changed | set_poststate_ann(fcx.ccx, e.id, a_post);\n-        }\n-        case (expr_field(?val, _)) {\n-            ret find_pre_post_state_sub(fcx, pres, val, e.id, none);\n-        }\n-        case (expr_unary(_, ?operand)) {\n-            ret find_pre_post_state_sub(fcx, pres, operand, e.id, none);\n-        }\n-        case (expr_cast(?operand, _)) {\n-            ret find_pre_post_state_sub(fcx, pres, operand, e.id, none);\n-        }\n-        case (expr_fail(?maybe_fail_val)) {\n-            ret set_prestate_ann(fcx.ccx, e.id, pres) |\n-            /* if execution continues after fail, then everything is true!\n-               woo! */\n-                set_poststate_ann(fcx.ccx, e.id,\n-                                  false_postcond(num_constrs)) |\n-                alt(maybe_fail_val) {\n-                    case (none) { false }\n-                    case (some(?fail_val)) {\n-                        find_pre_post_state_expr(fcx, pres, fail_val)\n-                    }\n-                }\n-        }\n-        case (expr_assert(?p)) {\n-            ret find_pre_post_state_sub(fcx, pres, p, e.id, none);\n-        }\n-        case (expr_check(_, ?p)) {\n-            /* predicate p holds after this expression executes */\n-            let sp_constr c = expr_to_constr(fcx.ccx.tcx, p);\n-            ret find_pre_post_state_sub(fcx, pres, p, e.id, some(c.node));\n-        }\n-        case (expr_if_check(?p, ?conseq, ?maybe_alt)) {\n-            ret join_then_else\n-                (fcx, p, conseq, maybe_alt, e.id, if_check, pres);\n-        }\n-        case (expr_break) { ret pure_exp(fcx.ccx, e.id, pres); }\n-        case (expr_cont) { ret pure_exp(fcx.ccx, e.id, pres); }\n-        case (expr_port(_)) { ret pure_exp(fcx.ccx, e.id, pres); }\n-        case (expr_self_method(_)) { ret pure_exp(fcx.ccx, e.id, pres); }\n-        case (expr_anon_obj(?anon_obj)) {\n-            alt (anon_obj.with_obj) {\n-                case (some(?wt)) {\n-                    ret find_pre_post_state_sub(fcx, pres, wt, e.id, none);\n+        } else {\n+            // No alts; poststate is the poststate of the test\n+\n+            a_post = e_post;\n+        }\n+        ret changed | set_poststate_ann(fcx.ccx, e.id, a_post);\n+      }\n+      expr_field(val, _) {\n+        ret find_pre_post_state_sub(fcx, pres, val, e.id, none);\n+      }\n+      expr_unary(_, operand) {\n+        ret find_pre_post_state_sub(fcx, pres, operand, e.id, none);\n+      }\n+      expr_cast(operand, _) {\n+        ret find_pre_post_state_sub(fcx, pres, operand, e.id, none);\n+      }\n+      expr_fail(maybe_fail_val) {\n+        ret set_prestate_ann(fcx.ccx, e.id, pres) |\n+                /* if execution continues after fail, then everything is true!\n+                   woo! */\n+                set_poststate_ann(fcx.ccx, e.id, false_postcond(num_constrs))\n+                |\n+                alt maybe_fail_val {\n+                  none. { false }\n+                  some(fail_val) {\n+                    find_pre_post_state_expr(fcx, pres, fail_val)\n+                  }\n                 }\n-                case (none) { ret pure_exp(fcx.ccx, e.id, pres); }\n-            }\n-        }\n+      }\n+      expr_assert(p) {\n+        ret find_pre_post_state_sub(fcx, pres, p, e.id, none);\n+      }\n+      expr_check(_, p) {\n+        /* predicate p holds after this expression executes */\n+        let c: sp_constr = expr_to_constr(fcx.ccx.tcx, p);\n+        ret find_pre_post_state_sub(fcx, pres, p, e.id, some(c.node));\n+      }\n+      expr_if_check(p, conseq, maybe_alt) {\n+        ret join_then_else(fcx, p, conseq, maybe_alt, e.id, if_check, pres);\n+      }\n+      expr_break. { ret pure_exp(fcx.ccx, e.id, pres); }\n+      expr_cont. { ret pure_exp(fcx.ccx, e.id, pres); }\n+      expr_port(_) { ret pure_exp(fcx.ccx, e.id, pres); }\n+      expr_self_method(_) { ret pure_exp(fcx.ccx, e.id, pres); }\n+      expr_anon_obj(anon_obj) {\n+        alt anon_obj.with_obj {\n+          some(wt) { ret find_pre_post_state_sub(fcx, pres, wt, e.id, none); }\n+          none. { ret pure_exp(fcx.ccx, e.id, pres); }\n+        }\n+      }\n     }\n }\n \n-fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n-    auto stmt_ann = stmt_to_ann(fcx.ccx, *s);\n+fn find_pre_post_state_stmt(fcx: &fn_ctxt, pres: &prestate, s: @stmt) ->\n+   bool {\n+    let stmt_ann = stmt_to_ann(fcx.ccx, *s);\n+\n \n     /*\n     log_err \"*At beginning: stmt = \";\n@@ -592,127 +577,123 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n     log_err tritv::to_str(pres);\n     */\n \n-    alt (s.node) {\n-        case (stmt_decl(?adecl, ?id)) {\n-            alt (adecl.node) {\n-                case (decl_local(?alocals)) {\n-                  auto changed = false;\n-                  for (@local alocal in alocals) {\n-                    alt (alocal.node.init) {\n-                        case (some(?an_init)) {\n-                            auto changed = set_prestate(stmt_ann, pres) |\n-                                find_pre_post_state_expr(fcx, pres,\n-                                                         an_init.expr);\n-\n-                            auto post = tritv_clone(expr_poststate(fcx.ccx,\n-                                                      an_init.expr));\n-                            alt (an_init.expr.node) {\n-                                case (expr_path(?p)) {\n-\n-                                    auto instlhs =\n-                                        rec(ident=alocal.node.ident,\n-                                            node=alocal.node.id);\n-                                    auto rhs_d = local_node_id_to_local_def_id\n-                                        (fcx, an_init.expr.id);\n-                                    alt (rhs_d) {\n-                                        case (some(?rhsid)) {\n-                                            auto instrhs =\n-                                                rec(ident=path_to_ident\n-                                                    (fcx.ccx.tcx, p),\n-                                                    node=rhsid);\n-                                            copy_in_poststate(fcx, post,\n-                                               instlhs, instrhs,\n-                                               op_to_oper_ty(an_init.op));\n-                                        }\n-                                        case (_) { }\n-                                    }\n-                                }\n-                                case (_) { }\n-                            }\n-                            if (an_init.op == init_move) {\n-                                forget_in_poststate(fcx, post,\n-                                                    an_init.expr.id);\n-                            }\n-                            set_in_poststate_ident(fcx, alocal.node.id,\n-                                                   alocal.node.ident, post);\n-                            /*\n-                            log_err \"Summary: stmt = \";\n-                            log_stmt_err(*s);\n-                            log_err \"prestate = \";\n-                            log_tritv_err(fcx, stmt_ann.states.prestate);\n-                            log_err \"poststate =\";\n-                            log_tritv_err(fcx, post);\n-                            log_err \"changed =\";\n-                            log_err changed;\n-                            */\n-                            /* important to do this in one step to ensure\n-                               termination (don't want to set changed to true\n-                               for intermediate changes) */\n-                          changed |= set_poststate(stmt_ann, post);\n-                        }\n-                        case (none) {\n-                            // let int = x; => x is uninit in poststate\n-                            set_poststate_ann(fcx.ccx, id, pres);\n-                            clear_in_poststate_ident(fcx, alocal.node.id,\n-                                                     alocal.node.ident, id);\n-                            set_prestate(stmt_ann, pres);\n+    alt s.node {\n+      stmt_decl(adecl, id) {\n+        alt adecl.node {\n+          decl_local(alocals) {\n+            let changed = false;\n+            for alocal: @local  in alocals {\n+                alt alocal.node.init {\n+                  some(an_init) {\n+                    let changed =\n+                        set_prestate(stmt_ann, pres) |\n+                            find_pre_post_state_expr(fcx, pres, an_init.expr);\n+\n+                    let post =\n+                        tritv_clone(expr_poststate(fcx.ccx, an_init.expr));\n+                    alt an_init.expr.node {\n+                      expr_path(p) {\n+\n+                        let instlhs =\n+                            {ident: alocal.node.ident, node: alocal.node.id};\n+                        let rhs_d =\n+                            local_node_id_to_local_def_id(fcx,\n+                                                          an_init.expr.id);\n+                        alt rhs_d {\n+                          some(rhsid) {\n+                            let instrhs =\n+                                {ident: path_to_ident(fcx.ccx.tcx, p),\n+                                 node: rhsid};\n+                            copy_in_poststate(fcx, post, instlhs, instrhs,\n+                                              op_to_oper_ty(an_init.op));\n+                          }\n+                          _ { }\n                         }\n+                      }\n+                      _ { }\n+                    }\n+                    if an_init.op == init_move {\n+                        forget_in_poststate(fcx, post, an_init.expr.id);\n                     }\n+                    set_in_poststate_ident(fcx, alocal.node.id,\n+                                           alocal.node.ident, post);\n+                    /*\n+                    log_err \"Summary: stmt = \";\n+                    log_stmt_err(*s);\n+                    log_err \"prestate = \";\n+                    log_tritv_err(fcx, stmt_ann.states.prestate);\n+                    log_err \"poststate =\";\n+                    log_tritv_err(fcx, post);\n+                    log_err \"changed =\";\n+                    log_err changed;\n+                    */\n+                    /* important to do this in one step to ensure\n+                       termination (don't want to set changed to true\n+                       for intermediate changes) */\n+                    changed |= set_poststate(stmt_ann, post);\n+                  }\n+                  none. {\n+                    // let int = x; => x is uninit in poststate\n+                    set_poststate_ann(fcx.ccx, id, pres);\n+                    clear_in_poststate_ident(fcx, alocal.node.id,\n+                                             alocal.node.ident, id);\n+                    set_prestate(stmt_ann, pres);\n                   }\n-                  ret changed;\n-                }\n-                case (decl_item(?an_item)) {\n-                    ret set_prestate(stmt_ann, pres) |\n-                        set_poststate(stmt_ann, pres);\n-                    /* the outer \"walk\" will recurse into the item */\n                 }\n             }\n-        }\n-        case (stmt_expr(?ex, _)) {\n-            ret find_pre_post_state_expr(fcx, pres, ex) |\n+            ret changed;\n+          }\n+          decl_item(an_item) {\n+            ret set_prestate(stmt_ann, pres) | set_poststate(stmt_ann, pres);\n+            /* the outer \"walk\" will recurse into the item */\n+          }\n+        }\n+      }\n+      stmt_expr(ex, _) {\n+        ret find_pre_post_state_expr(fcx, pres, ex) |\n                 set_prestate(stmt_ann, expr_prestate(fcx.ccx, ex)) |\n                 set_poststate(stmt_ann, expr_poststate(fcx.ccx, ex));\n-            /*\n-            log_err \"Finally:\";\n-              log_stmt_err(*s);\n-              log_err(\"prestate = \");\n-              //              log_err(bitv::to_str(stmt_ann.states.prestate));\n-              log_tritv_err(fcx, stmt_ann.states.prestate);\n-              log_err(\"poststate =\");\n-              //   log_err(bitv::to_str(stmt_ann.states.poststate));\n-              log_tritv_err(fcx, stmt_ann.states.poststate);\n-              log_err(\"changed =\");\n-              log_err(changed);\n-            */\n-        }\n-        case (_) { ret false; }\n+        /*\n+        log_err \"Finally:\";\n+          log_stmt_err(*s);\n+          log_err(\"prestate = \");\n+          //              log_err(bitv::to_str(stmt_ann.states.prestate));\n+          log_tritv_err(fcx, stmt_ann.states.prestate);\n+          log_err(\"poststate =\");\n+          //   log_err(bitv::to_str(stmt_ann.states.poststate));\n+          log_tritv_err(fcx, stmt_ann.states.poststate);\n+          log_err(\"changed =\");\n+          log_err(changed);\n+        */\n+      }\n+      _ { ret false; }\n     }\n }\n \n \n /* Updates the pre- and post-states of statements in the block,\n    returns a boolean flag saying whether any pre- or poststates changed */\n-fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &blk b)\n-    -> bool {\n+fn find_pre_post_state_block(fcx: &fn_ctxt, pres0: &prestate, b: &blk) ->\n+   bool {\n     /* First, set the pre-states and post-states for every expression */\n \n-    auto pres = pres0;\n+    let pres = pres0;\n     /* Iterate over each stmt. The new prestate is <pres>. The poststate\n      consist of improving <pres> with whatever variables this stmt\n      initializes.  Then <pres> becomes the new poststate. */\n \n-    auto changed = false;\n-    for (@stmt s in b.node.stmts) {\n+    let changed = false;\n+    for s: @stmt  in b.node.stmts {\n         changed |= find_pre_post_state_stmt(fcx, pres, s);\n         pres = stmt_poststate(fcx.ccx, *s);\n     }\n-    auto post = pres;\n-    alt (b.node.expr) {\n-        case (none) { }\n-        case (some(?e)) {\n-            changed |= find_pre_post_state_expr(fcx, pres, e);\n-            post = expr_poststate(fcx.ccx, e);\n-        }\n+    let post = pres;\n+    alt b.node.expr {\n+      none. { }\n+      some(e) {\n+        changed |= find_pre_post_state_expr(fcx, pres, e);\n+        post = expr_poststate(fcx.ccx, e);\n+      }\n     }\n \n     set_prestate_ann(fcx.ccx, b.node.id, pres0);\n@@ -732,43 +713,44 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &blk b)\n     ret changed;\n }\n \n-fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n-    auto num_local_vars = num_constraints(fcx.enclosing);\n+fn find_pre_post_state_fn(fcx: &fn_ctxt, f: &_fn) -> bool {\n+    let num_local_vars = num_constraints(fcx.enclosing);\n     // make sure the return bit starts out False\n     clear_in_prestate_ident(fcx, fcx.id, fcx.name, f.body.node.id);\n     // Instantiate any constraints on the arguments so we can use them\n-    auto block_pre = block_prestate(fcx.ccx, f.body);\n-    auto tsc;\n-    for (@constr c in f.decl.constraints) {\n+    let block_pre = block_prestate(fcx.ccx, f.body);\n+    let tsc;\n+    for c: @constr  in f.decl.constraints {\n         tsc = ast_constr_to_ts_constr(fcx.ccx.tcx, f.decl.inputs, c);\n         set_in_prestate_constr(fcx, tsc, block_pre);\n     }\n \n-    auto changed = find_pre_post_state_block(fcx, block_pre, f.body);\n+    let changed = find_pre_post_state_block(fcx, block_pre, f.body);\n     // Treat the tail expression as a return statement\n \n-    alt (f.body.node.expr) {\n-        case (some(?tailexpr)) {\n-            auto tailty = expr_ty(fcx.ccx.tcx, tailexpr);\n-\n-            // Since blocks and alts and ifs that don't have results\n-            // implicitly result in nil, we have to be careful to not\n-            // interpret nil-typed block results as the result of a\n-            // function with some other return type\n-            if (!type_is_nil(fcx.ccx.tcx, tailty) &&\n-                    !type_is_bot(fcx.ccx.tcx, tailty)) {\n-                auto p = false_postcond(num_local_vars);\n-                set_poststate_ann(fcx.ccx, f.body.node.id, p);\n-            }\n+    alt f.body.node.expr {\n+      some(tailexpr) {\n+        let tailty = expr_ty(fcx.ccx.tcx, tailexpr);\n+\n+\n+        // Since blocks and alts and ifs that don't have results\n+        // implicitly result in nil, we have to be careful to not\n+        // interpret nil-typed block results as the result of a\n+        // function with some other return type\n+        if !type_is_nil(fcx.ccx.tcx, tailty) &&\n+               !type_is_bot(fcx.ccx.tcx, tailty) {\n+            let p = false_postcond(num_local_vars);\n+            set_poststate_ann(fcx.ccx, f.body.node.id, p);\n         }\n-        case (none) {/* fallthrough */ }\n+      }\n+      none. {/* fallthrough */ }\n     }\n \n-/*\n-    log_err \"find_pre_post_state_fn\";\n-    log_err changed;\n-    fcx.ccx.tcx.sess.span_note(f.body.span, fcx.name);\n-*/\n+    /*\n+        log_err \"find_pre_post_state_fn\";\n+        log_err changed;\n+        fcx.ccx.tcx.sess.span_note(f.body.span, fcx.name);\n+    */\n \n     ret changed;\n }"}, {"sha": "7615b84aea8dca4906200c98213de23ed14bb3ca", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 168, "deletions": 158, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1", "patch": "@@ -28,229 +28,239 @@ export to_str;\n  have the same length; 11 should never appear in a given position)\n */\n \n-type t = rec(bitv::t uncertain, bitv::t val, uint nbits);\n-tag trit {\n-    ttrue;\n-    tfalse;\n-    dont_care;\n-}\n+type t = {uncertain: bitv::t, val: bitv::t, nbits: uint};\n+tag trit { ttrue; tfalse; dont_care; }\n \n-fn create_tritv(uint len) -> t {\n-  ret rec(uncertain=bitv::create(len, true),\n-          val=bitv::create(len, false),\n-          nbits=len);\n+fn create_tritv(len: uint) -> t {\n+    ret {uncertain: bitv::create(len, true),\n+         val: bitv::create(len, false),\n+         nbits: len};\n }\n \n \n-fn trit_minus(trit a, trit b) -> trit {\n+fn trit_minus(a: trit, b: trit) -> trit {\n+\n     /*   2 - anything = 2\n          1 - 1 = 2\n          1 - 0 is an error\n          1 - 2 = 1\n          0 - 1 is an error\n          0 - anything else - 0\n      */\n-  alt (a) {\n-    case (dont_care) { dont_care }\n-    case (ttrue) {\n-      alt (b) {\n-        case (ttrue)     { dont_care }\n-        case (tfalse)    { ttrue } /* internally contradictory, but\n-                                      I guess it'll get flagged? */\n-        case (dont_care) { ttrue }\n+    alt a {\n+      dont_care. { dont_care }\n+      ttrue. {\n+        alt b {\n+          ttrue. { dont_care }\n+          tfalse. { ttrue }\n+           /* internally contradictory, but\n+              I guess it'll get flagged? */\n+           dont_care. {\n+            ttrue\n+          }\n+        }\n       }\n-    }\n-    case (tfalse) {\n-      alt (b) {\n-        case (ttrue) { tfalse } /* see above comment */\n-        case (_)     { tfalse }\n+      tfalse. {\n+        alt b {\n+          ttrue. { tfalse }\n+           /* see above comment */\n+          _ {\n+            tfalse\n+          }\n+        }\n       }\n     }\n-  }\n }\n \n-fn trit_or(trit a, trit b) -> trit {\n-  alt (a) {\n-    case (dont_care) { b }\n-    case (ttrue)     { ttrue }\n-    case (tfalse)    {\n-      alt (b) {\n-        case (ttrue)  { dont_care } /* FIXME: ?????? */\n-        case (_)      { tfalse }\n+fn trit_or(a: trit, b: trit) -> trit {\n+    alt a {\n+      dont_care. { b }\n+      ttrue. { ttrue }\n+      tfalse. {\n+        alt b {\n+          ttrue. { dont_care }\n+           /* FIXME: ?????? */\n+          _ {\n+            tfalse\n+          }\n+        }\n       }\n     }\n-  }\n }\n \n // FIXME: This still seems kind of dodgy to me (that is,\n // that 1 + ? = 1. But it might work out given that\n // all variables start out in a 0 state. Probably I need\n // to make it so that all constraints start out in a 0 state\n // (we consider a constraint false until proven true), too.\n-fn trit_and(trit a, trit b) -> trit {\n-  alt (a) {\n-      case (dont_care) { b }  // also seems wrong for case b = ttrue\n-      case (ttrue)     {\n-          alt (b) {\n-              case (dont_care) { ttrue } // ??? Seems wrong\n-              case (ttrue)     { ttrue }\n-              // false wins, since if something is uninit\n-              // on one path, we care\n-              // (Rationale: it's always safe to assume that\n-         // a var is uninitialized or that a constraint\n-         // needs to be re-established)\n-              case (tfalse)    { tfalse }\n+fn trit_and(a: trit, b: trit) -> trit {\n+    alt a {\n+      dont_care. { b }\n+       // also seems wrong for case b = ttrue\n+      ttrue. {\n+        alt b {\n+          dont_care. { ttrue }\n+           // ??? Seems wrong\n+          ttrue. {\n+            ttrue\n+          }\n+\n+          // false wins, since if something is uninit\n+          // on one path, we care\n+          // (Rationale: it's always safe to assume that\n+          // a var is uninitialized or that a constraint\n+          // needs to be re-established)\n+          tfalse. {\n+            tfalse\n           }\n+        }\n       }\n+\n       // Rationale: if it's uninit on one path,\n       // we can consider it as uninit on all paths\n-    case (tfalse) { tfalse }\n-  }\n-  // if the result is dont_care, that means\n-  // a and b were both dont_care\n+      tfalse. {\n+        tfalse\n+      }\n+    }\n+    // if the result is dont_care, that means\n+    // a and b were both dont_care\n }\n \n-fn change(bool changed, trit old, trit new) -> bool { changed || new != old }\n+fn change(changed: bool, old: trit, new: trit) -> bool {\n+    changed || new != old\n+}\n \n-fn tritv_difference(&t p1, &t p2) -> bool {\n-    let uint i = 0u;\n+fn tritv_difference(p1: &t, p2: &t) -> bool {\n+    let i: uint = 0u;\n     assert (p1.nbits == p2.nbits);\n-    let uint sz = p1.nbits;\n-    auto changed = false;\n-    while (i < sz) {\n-      auto old = tritv_get(p1, i);\n-      auto new = trit_minus(old, tritv_get(p2, i));\n-      changed = change(changed, old, new);\n-      tritv_set(i, p1, new);\n-      i += 1u;\n+    let sz: uint = p1.nbits;\n+    let changed = false;\n+    while i < sz {\n+        let old = tritv_get(p1, i);\n+        let new = trit_minus(old, tritv_get(p2, i));\n+        changed = change(changed, old, new);\n+        tritv_set(i, p1, new);\n+        i += 1u;\n     }\n     ret changed;\n }\n \n-fn tritv_union(&t p1, &t p2) -> bool {\n-    let uint i = 0u;\n+fn tritv_union(p1: &t, p2: &t) -> bool {\n+    let i: uint = 0u;\n     assert (p1.nbits == p2.nbits);\n-    let uint sz = p1.nbits;\n-    auto changed = false;\n-    while (i < sz) {\n-      auto old = tritv_get(p1, i);\n-      auto new = trit_or(old, tritv_get(p2, i));\n-      changed = change(changed, old, new);\n-      tritv_set(i, p1, new);\n-      i += 1u;\n+    let sz: uint = p1.nbits;\n+    let changed = false;\n+    while i < sz {\n+        let old = tritv_get(p1, i);\n+        let new = trit_or(old, tritv_get(p2, i));\n+        changed = change(changed, old, new);\n+        tritv_set(i, p1, new);\n+        i += 1u;\n     }\n     ret changed;\n }\n \n-fn tritv_intersect(&t p1, &t p2) -> bool {\n-    let uint i = 0u;\n+fn tritv_intersect(p1: &t, p2: &t) -> bool {\n+    let i: uint = 0u;\n     assert (p1.nbits == p2.nbits);\n-    let uint sz = p1.nbits;\n-    auto changed = false;\n-    while (i < sz) {\n-      auto old = tritv_get(p1, i);\n-      auto new = trit_and(old, tritv_get(p2, i));\n-      changed = change(changed, old, new);\n-      tritv_set(i, p1, new);\n-      i += 1u;\n+    let sz: uint = p1.nbits;\n+    let changed = false;\n+    while i < sz {\n+        let old = tritv_get(p1, i);\n+        let new = trit_and(old, tritv_get(p2, i));\n+        changed = change(changed, old, new);\n+        tritv_set(i, p1, new);\n+        i += 1u;\n     }\n     ret changed;\n }\n \n-fn tritv_get(&t v, uint i) -> trit {\n-  auto b1 = bitv::get(v.uncertain, i);\n-  auto b2 = bitv::get(v.val, i);\n-  assert (! (b1 && b2));\n-  if (b1)      { dont_care }\n-  else if (b2) { ttrue }\n-  else         { tfalse}\n+fn tritv_get(v: &t, i: uint) -> trit {\n+    let b1 = bitv::get(v.uncertain, i);\n+    let b2 = bitv::get(v.val, i);\n+    assert (!(b1 && b2));\n+    if b1 { dont_care } else if (b2) { ttrue } else { tfalse }\n }\n \n-fn tritv_set(uint i, &t v, trit t) -> bool {\n-  auto old = tritv_get(v, i);\n-  alt (t) {\n-    case (dont_care) {\n-      bitv::set(v.uncertain, i, true);\n-      bitv::set(v.val, i, false);\n-    }\n-    case (ttrue) {\n-      bitv::set(v.uncertain, i, false);\n-      bitv::set(v.val, i, true);\n-    }\n-    case (tfalse) {\n-      bitv::set(v.uncertain, i, false);\n-      bitv::set(v.val, i, false);\n+fn tritv_set(i: uint, v: &t, t: trit) -> bool {\n+    let old = tritv_get(v, i);\n+    alt t {\n+      dont_care. {\n+        bitv::set(v.uncertain, i, true);\n+        bitv::set(v.val, i, false);\n+      }\n+      ttrue. { bitv::set(v.uncertain, i, false); bitv::set(v.val, i, true); }\n+      tfalse. {\n+        bitv::set(v.uncertain, i, false);\n+        bitv::set(v.val, i, false);\n+      }\n     }\n-  }\n-  ret change(false, old, t);\n+    ret change(false, old, t);\n }\n \n-fn tritv_copy(&t target, &t source) -> bool {\n-  assert (target.nbits == source.nbits);\n-  auto changed = !bitv::equal(target.uncertain, source.uncertain) ||\n-    !bitv::equal(target.val, source.val);\n-  bitv::copy(target.uncertain, source.uncertain);\n-  bitv::copy(target.val, source.val);\n-  ret changed;\n+fn tritv_copy(target: &t, source: &t) -> bool {\n+    assert (target.nbits == source.nbits);\n+    let changed =\n+        !bitv::equal(target.uncertain, source.uncertain) ||\n+            !bitv::equal(target.val, source.val);\n+    bitv::copy(target.uncertain, source.uncertain);\n+    bitv::copy(target.val, source.val);\n+    ret changed;\n }\n \n-fn tritv_set_all(&t v) {\n-  let uint i = 0u;\n-  while (i < v.nbits) {\n-    tritv_set(i, v, ttrue);\n-    i += 1u;\n-  }\n+fn tritv_set_all(v: &t) {\n+    let i: uint = 0u;\n+    while i < v.nbits { tritv_set(i, v, ttrue); i += 1u; }\n }\n \n-fn tritv_clear(&t v) {\n-  let uint i = 0u;\n-  while (i < v.nbits) {\n-    tritv_set(i, v, dont_care);\n-    i += 1u;\n-  }\n+fn tritv_clear(v: &t) {\n+    let i: uint = 0u;\n+    while i < v.nbits { tritv_set(i, v, dont_care); i += 1u; }\n }\n \n-fn tritv_clone(&t v) -> t {\n-  ret rec(uncertain=bitv::clone(v.uncertain),\n-          val=bitv::clone(v.val),\n-          nbits=v.nbits);\n+fn tritv_clone(v: &t) -> t {\n+    ret {uncertain: bitv::clone(v.uncertain),\n+         val: bitv::clone(v.val),\n+         nbits: v.nbits};\n }\n \n-fn tritv_doesntcare(&t v) -> bool {\n-  let uint i = 0u;\n-  while (i < v.nbits) {\n-    if (tritv_get(v, i) != dont_care) {\n-      ret false;\n+fn tritv_doesntcare(v: &t) -> bool {\n+    let i: uint = 0u;\n+    while i < v.nbits {\n+        if tritv_get(v, i) != dont_care { ret false; }\n+        i += 1u;\n     }\n-    i += 1u;\n-  }\n-  ret true;\n+    ret true;\n }\n \n-fn to_vec(&t v) -> uint[] {\n-  let uint i = 0u;\n-  let uint[] rslt = ~[];\n-  while (i < v.nbits) {\n-    rslt += ~[alt (tritv_get(v, i)) {\n-        case (dont_care) { 2u }\n-        case (ttrue)     { 1u }\n-        case (tfalse)    { 0u } }];\n-    i += 1u;\n-  }\n-  ret rslt;\n+fn to_vec(v: &t) -> uint[] {\n+    let i: uint = 0u;\n+    let rslt: uint[] = ~[];\n+    while i < v.nbits {\n+        rslt +=\n+            ~[alt tritv_get(v, i) {\n+                dont_care. { 2u }\n+                ttrue. { 1u }\n+                tfalse. { 0u }\n+              }];\n+        i += 1u;\n+    }\n+    ret rslt;\n }\n \n-fn to_str(&t v) -> str {\n-  let uint i = 0u;\n-  let str rs = \"\";\n-  while (i < v.nbits) {\n-    rs += alt (tritv_get(v, i)) {\n-        case (dont_care) { \"?\" }\n-        case (ttrue)     { \"1\" }\n-        case (tfalse)    { \"0\" } };\n-    i += 1u;\n-  }\n-  ret rs;\n+fn to_str(v: &t) -> str {\n+    let i: uint = 0u;\n+    let rs: str = \"\";\n+    while i < v.nbits {\n+        rs +=\n+            alt tritv_get(v, i) {\n+              dont_care. { \"?\" }\n+              ttrue. { \"1\" }\n+              tfalse. { \"0\" }\n+            };\n+        i += 1u;\n+    }\n+    ret rs;\n }\n \n //"}, {"sha": "1b3bc84b2c7623d5bf992c16c33369ff9bc345e0", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "432930be56d3a9b12d4165b61afb3f8516e5843e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1948, "deletions": 2029, "changes": 3977, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "14375e5c73b2d84c222f67e2cda6382e935e1148", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 230, "deletions": 230, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "3904bd8cb25d3c63f2fe2c3e921007753cc524e0", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 121, "deletions": 135, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "ed869e79f4e72b6bc7da85361ffbe4cb1a006671", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 45, "deletions": 53, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "88b3e3a720c447a67394fc4ff473d9815f53a069", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "e47a0fc2a7146d4ca096de74086d1b491b1d05e6", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4374030d10a691b56e0c6305666ca796c4d6628e", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 226, "deletions": 256, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "729e8e5000eea24ece2a6d93c9307d19294bfa54", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 414, "deletions": 431, "changes": 845, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4bb95450a7aa36f93f69b5b23e5624f60727a06b", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 509, "deletions": 539, "changes": 1048, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "08a60404172f5ca4bba3a62f0ae8d62e14db0c3f", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "8163f8d29fc9cf1e4b053cacec92d09d19f26b20", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 377, "deletions": 402, "changes": 779, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "c93f8ce52a958575798ac0886c623f43ae70e91f", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 1463, "deletions": 1517, "changes": 2980, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "35bd1f1494a57fa7944e1d648a4194f460ad3560", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 113, "deletions": 100, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "b1f84782952ea65e740c74e6608d4ff72ad7d75a", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 222, "deletions": 231, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "fd48b10a317d27f92a19e55123c85d57903ee254", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 1029, "deletions": 1127, "changes": 2156, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "ec48435608970b917e5a6a5870761a53303af752", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "7a88b98d4766f869c002f600dee6c79981ceffcf", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 361, "deletions": 408, "changes": 769, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "528032a1eadbaa69b680892c3746c6b13068f2cf", "filename": "src/comp/syntax/walk.rs", "status": "modified", "additions": 344, "deletions": 376, "changes": 720, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "91ab2665f17b4ca322b3de6c940c6a2547a86d2a", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 78, "deletions": 105, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "946ec1140139521ba8dfd42b5bd01a7457b4d471", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 100, "deletions": 105, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "fd9a5535707be9ae8070b6cd30968ec123518892", "filename": "src/fuzzer/ast_match.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "5a7fa15a9b26c0d352634fc57a6f8c0f346aadd8", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 142, "deletions": 129, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "3f959f649b125a28336c2d51f5c4e445c2b1bb30", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 59, "deletions": 43, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "8201264135d75d7f7a51d4c1016a92de39263692", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "c0c1e748c3c3240c75116309aea9bb062f38276f", "filename": "src/lib/box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbox.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "39e646032ea91ccb75673b69e2e441c5abdd8f42", "filename": "src/lib/dbg.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdbg.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "00ccde1f4b5e90832c751d60ac5cc77faeafbe9f", "filename": "src/lib/deque.rs", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "3b921a863825339fd2017083a9543f2c7fbf1eb6", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "41e5bf03b1a32d19180c2fd59259fa05e32c7163", "filename": "src/lib/ebmlivec.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Febmlivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Febmlivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febmlivec.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a410acd83ad33690f22f2a3ae5ae527dff4495fa", "filename": "src/lib/either.rs", "status": "modified", "additions": 17, "deletions": 30, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "00302ea9e2602ec483085ea46ba3eda6e7bd1dc3", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 194, "deletions": 197, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "7a4467fecd0c937894b5d77b7c7e41c865808d01", "filename": "src/lib/fs.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "bd78f0201049e2f0b8651bb5fc9ec5c720f36705", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "67297e963e112a49af605109a9ce5ff25ce3a557", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 118, "deletions": 146, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "52a1cb1cd665c5e6e35310c87d4c05b5484bda71", "filename": "src/lib/int.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "acbbd4904f913aa096e7985527ef5846ec44310c", "filename": "src/lib/io.rs", "status": "modified", "additions": 160, "deletions": 161, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "548a40586db7a5d87a3895e48c50b15f66bf7f3d", "filename": "src/lib/ioivec.rs", "status": "modified", "additions": 161, "deletions": 164, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fioivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fioivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fioivec.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "71dc9cf7a65dbccaaf3588758f7cb1d42de2c011", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 119, "deletions": 145, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "f6dc6b1a6b5a1f656d211d17ad117bfeede47901", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "ce10fccb588823f487c1dad8f2543fc80dc66e76", "filename": "src/lib/list.rs", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "13e7022184f5d3c1f3aa72ad5b91b71b21eed4ad", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a5a894fc9a6faf58c7971d6d6f0c19f35246c96a", "filename": "src/lib/map.rs", "status": "modified", "additions": 102, "deletions": 111, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "d08fcfd28ccdf51c5b1c97d173a345dc64ca53e9", "filename": "src/lib/option.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "8ae7e3618a800ee766e6e14c96ff3ab13bc9f95d", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "fc336f4427ed7f55a3751efbf3ef41b2b6896c92", "filename": "src/lib/ptr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fptr.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a6cb1cbb665cf507259374deb9d3760d5ecce0b6", "filename": "src/lib/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frand.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "0955020838885e3d12887ac367485753396ecace", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "cd633b28cca55dd8da60d4fe0cd016e5eb48d19d", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "0c11e69c349fa0095e146e5dc1b1940069e9625d", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "65aaf8fd4de882322ebf6aaaf5d6fb05c946da67", "filename": "src/lib/sort.rs", "status": "modified", "additions": 109, "deletions": 108, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "ca0a81add8021a7d9d64f81dd5acc858f77fe3d0", "filename": "src/lib/str.rs", "status": "modified", "additions": 203, "deletions": 213, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "79f3f0ed3c709d3d915d962c6daa173953223ea3", "filename": "src/lib/sys.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsys.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "3c3350f23d7cccdca0f3141bfb814a168ae3a809", "filename": "src/lib/task.rs", "status": "modified", "additions": 60, "deletions": 80, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "6576982dc0597b5b72c06468db3e35592567fe08", "filename": "src/lib/term.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fterm.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "29477ec925f37722100548d497821c5c1d1a2e27", "filename": "src/lib/termivec.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Ftermivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Ftermivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftermivec.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "801d7cff073d15e8d17b32e34ee9891bb7d773cc", "filename": "src/lib/test.rs", "status": "modified", "additions": 153, "deletions": 167, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "cf8ddfc6323c7289ae110463ee90669cfe8784c6", "filename": "src/lib/time.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftime.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "12197adaedf0566e627c9e47d1972bf94663e5fd", "filename": "src/lib/u64.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fu64.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "8a0430884d1b407c9c0923f34a0f5f6aec3e8eee", "filename": "src/lib/u8.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fu8.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "dd2da2562366f522ca2ca62df3a42c3529b1cea5", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "37e44b8a15a7d245e4a20d9850c5d4759cca433b", "filename": "src/lib/ufindivec.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fufindivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fufindivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufindivec.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "248ac494d43847c3ac1a85ce80f49b021d769af8", "filename": "src/lib/uint.rs", "status": "modified", "additions": 56, "deletions": 59, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "663bee542a6eb409ea13ac61cd81a4ff48833e89", "filename": "src/lib/unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Funsafe.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "672090e27db55ea013e43982a51f71b018f39b4a", "filename": "src/lib/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "d7b1e779ef7184ef1d191649c4637c450c95b4a1", "filename": "src/lib/vec.rs", "status": "modified", "additions": 155, "deletions": 171, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "ae3d683bf68bf71fba69d03ec78026ee3b633621", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "65ee769fb5cfbd0fe447c97fa6b0fcdf06a4f4ca", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "3807c893b0b3a82a9f4ea5b8bb478bf58068ee6e", "filename": "src/test/bench/99bob-iter.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-iter.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4bbea0c34bda5a4c916c7eba58cf634efc61980d", "filename": "src/test/bench/99bob-pattern.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-pattern.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "205ab67ff9a081120feb4c0cd980f5a962dc2acb", "filename": "src/test/bench/99bob-simple.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-simple.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "c68d77fe3241e90f583a419471def8f374311809", "filename": "src/test/bench/99bob-tail.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2F99bob-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2F99bob-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-tail.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "91e524d0d3143dc988382e5434a4664ff3be53d5", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "d7b5f527e7dda1581a5240c2cca3e24e61568c2a", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "6e1f12f258ca68aa568cb17370be7946fa81f3e5", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4e38abac7587540ea0171a295422b66401f26442", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "37590c0f9b3037a6cc2153b82b0d62778cf88a18", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4168df1f9344901c7bcc374dccdefd034e35b525", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 118, "deletions": 139, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "bd320611f324a9567853f91c345e8dddb9a018e3", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 46, "deletions": 57, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "6827ea55804ac7ef9c13f0cd212b0aebae8e0b30", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 186, "deletions": 209, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "b22d6c8b6e9b5ae16c18ce12daaf2ad9eaa44b4e", "filename": "src/test/compile-fail/alias-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Falias-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Falias-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falias-mismatch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a376508e8b42b266158ce763ab3c113ce6efa873", "filename": "src/test/compile-fail/aliasness-mismatch.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Faliasness-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Faliasness-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faliasness-mismatch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "3951a51e9c04e9d3dc0dd56ffdb0da8a62b06aaa", "filename": "src/test/compile-fail/alt-tag-nullary.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Falt-tag-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Falt-tag-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-tag-nullary.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "5e0fccf2f7cc5398dbc42a748ccc3df77e2a7312", "filename": "src/test/compile-fail/alt-tag-unary.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Falt-tag-unary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Falt-tag-unary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-tag-unary.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a23fc99958b6997a4cbf4d7d3604021ff755f662", "filename": "src/test/compile-fail/and-init.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fand-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fand-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fand-init.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "604c45607620b68068144868d44d2953b6fab03e", "filename": "src/test/compile-fail/anon-obj-overloading-wrong-type.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fanon-obj-overloading-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fanon-obj-overloading-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fanon-obj-overloading-wrong-type.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "89be0585c34ce7937c0eae1b111911d4e81651e8", "filename": "src/test/compile-fail/arg-count-mismatch.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "3fe2e95c294571204ceae9d61df6603fa6bdd24f", "filename": "src/test/compile-fail/arg-type-mismatch.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "66041f08a7a155c6812f9875fbf80139eef81f40", "filename": "src/test/compile-fail/assign-alias.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fassign-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fassign-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-alias.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "400d420c0aad1dc258300c1de35118fec7168f21", "filename": "src/test/compile-fail/attr-bad-meta.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "184d8b0326c99ae7ad0d2699567cdd8017cd1209", "filename": "src/test/compile-fail/attr-before-stmt.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-before-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-before-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-stmt.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "e0e8b660ef6623f8f10d80b95dee785e8e8fa1fa", "filename": "src/test/compile-fail/attr-before-view-item.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "7c3494842a145bc90f912114937edd69419edb8b", "filename": "src/test/compile-fail/attr-before-view-item2.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4886d5d4d36da11a56a850d3ecdc0f2128cbe7f6", "filename": "src/test/compile-fail/attr-dangling-in-fn.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-fn.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "7684dc82e60a91d4dcc39b0f7a58d34ac21d52a5", "filename": "src/test/compile-fail/attr-dangling-in-mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-mod.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "9d9b0613bd707d1359c1a0f1fdf13f0a8f96c975", "filename": "src/test/compile-fail/auto-deref-bind.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "0d2632ab448f79c4d57ce98e0413e76e5274aed9", "filename": "src/test/compile-fail/bad-alt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-alt.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "15ba26b0dc00123b3b1891d769089c94611e6030", "filename": "src/test/compile-fail/bad-bang-ann-2.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "7077a2e79862ff3bd0fc3a8f28e1dff38adc7122", "filename": "src/test/compile-fail/bad-bang-ann-3.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "20aed480bfca9bf10970fd2de73538c1fe58780e", "filename": "src/test/compile-fail/bad-bang-ann.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "2848d1857396c57abdb0414190fdb317e7200f99", "filename": "src/test/compile-fail/bad-env-capture.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "47e9a4e0ed9b6a84586900e4efc6a5d1777c6039", "filename": "src/test/compile-fail/bad-env-capture2.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "43d9a15665c5543fcc9626c84e3c581668f29791", "filename": "src/test/compile-fail/bad-env-capture3.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "93aa3db161336d77b584939b32140b43ca471fc2", "filename": "src/test/compile-fail/bad-expr-path.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "1498baecb5968cb9459f40fce8e275d83181f98a", "filename": "src/test/compile-fail/bad-expr-path2.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "fd9c3bc27933a32001f4b711b65865b35f6a3474", "filename": "src/test/compile-fail/bad-main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-main.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "bfb796916a393b09ff52c0edf7fdd92c02b516f8", "filename": "src/test/compile-fail/bad-module.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-module.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "b16a806273c43338929a162ab6440ee09451a3dc", "filename": "src/test/compile-fail/bad-name.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-name.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "125b608e4ed4227cbe1ed0a39763d8cba0d7cbea", "filename": "src/test/compile-fail/bad-record-pat-2.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "e8bb2426cd984517b8b018d975c9f66c28053288", "filename": "src/test/compile-fail/bad-record-pat.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "d97d358d9e0a624c0c98e92e9532a3356454cc65", "filename": "src/test/compile-fail/bad-recv.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-recv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-recv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-recv.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "deb7a744c60acf5a1ad88a788712a165aa676417", "filename": "src/test/compile-fail/bad-send.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-send.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "1d56259198b05bb40f53280490bee1a734835b9d", "filename": "src/test/compile-fail/bad-type-env-capture.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-type-env-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbad-type-env-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-type-env-capture.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "8d5300418dc191b8f9f0a4136707ae59be92df5b", "filename": "src/test/compile-fail/bind-alias.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbind-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbind-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-alias.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "2b22cadb4cddf16138974156d67186a18c0780fd", "filename": "src/test/compile-fail/bind-parameterized-args.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbind-parameterized-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbind-parameterized-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-parameterized-args.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "fbd22745ccb13faaf3650a29dd5706ea5c54cc42", "filename": "src/test/compile-fail/binop-add-tup-assign.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup-assign.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "313ec76d8be78d2187640734eb30fa5c63a1707f", "filename": "src/test/compile-fail/binop-add-tup.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "e7f0561cb71e1a78b715cf1259b223bdbae81248", "filename": "src/test/compile-fail/binop-bitxor-str.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4a1edf58044418dad927f92ab9b98cdee2c7323e", "filename": "src/test/compile-fail/binop-logic-float.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-logic-float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-logic-float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-logic-float.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4ac9091dc2ea366826d71ec76adf605425bbc7b8", "filename": "src/test/compile-fail/binop-logic-int.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "dcf7a065145256dd69fbb42bf904e1298b559c23", "filename": "src/test/compile-fail/binop-mul-bool.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-mul-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-mul-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-mul-bool.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "047014a439cc7fd02caab4192f8acf72e291dad8", "filename": "src/test/compile-fail/binop-shift-port.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-shift-port.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-shift-port.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-shift-port.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "e86aa06b7516500df61774785d18cc49b5f9ce3c", "filename": "src/test/compile-fail/binop-sub-obj.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-sub-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-sub-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-sub-obj.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "376bca629999c1710c4fdb118d61f28a81088b1f", "filename": "src/test/compile-fail/binop-typeck.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-typeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbinop-typeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-typeck.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "9afcd2b49d4f3abeddfa9ddf8356453da267bfcc", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "b6dc0096d426824028ef426875a43f447fa58935", "filename": "src/test/compile-fail/block-copy.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "e5c877fbb0d939b7158e02fb83cefc143346ecd9", "filename": "src/test/compile-fail/block-uninit.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "e590a6b32b48a677914229c2d4e37f91da9d88c5", "filename": "src/test/compile-fail/bogus-tag.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "6d9c0e92ab8d7d74af5bc048409267cec8b99b2b", "filename": "src/test/compile-fail/break-outside-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "d1c7a90f7f2c48f4d0c570cf8469cf69fe72fec1", "filename": "src/test/compile-fail/break-uninit.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "9fb89c5c648f46038ecdafd9e5eb9757b474df37", "filename": "src/test/compile-fail/break-uninit2.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "24232933ddeafe52c5d184681721b382216a0652", "filename": "src/test/compile-fail/capture1.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fcapture1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fcapture1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcapture1.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "918939bab0c3424ec7f8347636aa17206ca8f59b", "filename": "src/test/compile-fail/capture2.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fcapture2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fcapture2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcapture2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "93c0b6aaf2e56cfc3d5fe958e3b15e21c982afcf", "filename": "src/test/compile-fail/chan-parameterized-args.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "afc3f85541b2a8a97daeba97f685f745e84195ee", "filename": "src/test/compile-fail/constrained-type-missing-check.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "2bee78316f2b023ea0d4b22f79067be816224241", "filename": "src/test/compile-fail/constructor-as-cast.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fconstructor-as-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fconstructor-as-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconstructor-as-cast.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "aabacdde27f83fda80cb29ed2710d3d952acc8ea", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "3ebc480b62fc5d16c6e5568dd57239a54c0228de", "filename": "src/test/compile-fail/cross-crate-glob-collision.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "7d2168b6a42f9b46588bf79a13866b1a9fb13e46", "filename": "src/test/compile-fail/dead-code-be.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdead-code-be.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdead-code-be.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-be.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "ee3a2af4af8579949ede361713fcd3c0d6e30b9d", "filename": "src/test/compile-fail/dead-code-ret.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "557b6af16965ca2e1092f657692e927e68619080", "filename": "src/test/compile-fail/direct-obj-fn-call.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "b560d00a89c508d9cd8f07ec15dcdd43640c2ffe", "filename": "src/test/compile-fail/do-while-constraints.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdo-while-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdo-while-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo-while-constraints.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "b91e2aa782a852966feffe58caa6e3943f64c1d6", "filename": "src/test/compile-fail/do-while-pred-constraints.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdo-while-pred-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdo-while-pred-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo-while-pred-constraints.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "09671b7149a47db5d72afa37654942824628b923", "filename": "src/test/compile-fail/does-nothing.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "90143e113b532017f38dbdee06a71594611eca1d", "filename": "src/test/compile-fail/dup-link-name.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdup-link-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fdup-link-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdup-link-name.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "294d782f916ac45b755ab18e82cb0714d2e0376d", "filename": "src/test/compile-fail/duplicate-name.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fduplicate-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fduplicate-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fduplicate-name.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "7413777ee2b832acc61f3221c74c02cd16d71d5c", "filename": "src/test/compile-fail/export-fully-qualified.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "2608f52322016d569180eb286b6a21abdf8bf778", "filename": "src/test/compile-fail/export-import.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-import.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a824212ab08355554c7b6023f6c60449474e1f53", "filename": "src/test/compile-fail/export-no-tag-variants.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport-no-tag-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport-no-tag-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-no-tag-variants.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a31ae5615fb21541dcebdf742f2aeefb788b863c", "filename": "src/test/compile-fail/export-tag-variant.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "57967838640f63e0e9ac57e5f7a49cd6ae1b4243", "filename": "src/test/compile-fail/export.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "47b80014a1cb5055a34f4dcc93781b59de69de41", "filename": "src/test/compile-fail/export2.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "530e912e1abd9d365479658ddd52ca5585f58766", "filename": "src/test/compile-fail/ext-after-attrib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "0846633b25e529809c89753a31d6ba8d06130b78", "filename": "src/test/compile-fail/ext-noname.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fext-noname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fext-noname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-noname.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "b86928edc2a002b471cd65338baebfb1a3111ee6", "filename": "src/test/compile-fail/ext-nonexistent.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4a957f5fc737237a2f9fad6639f03133fc7af66e", "filename": "src/test/compile-fail/extend-non-object.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextend-non-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextend-non-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextend-non-object.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "d9230783e98b2aee318b27d15814060b09a29ed1", "filename": "src/test/compile-fail/extenv-no-args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "8ab4953c8fa66b98abfff388096dbeaa7e3a6cb8", "filename": "src/test/compile-fail/extenv-not-string-literal.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "65200e5c11668f6d9575b0514b8d03a3b9692505", "filename": "src/test/compile-fail/extenv-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "23deb75e9e79e19e7797e054b9197a249c40fa34", "filename": "src/test/compile-fail/extfmt-missing-type.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "d6e146a0d14ed3a812814913808ab46315919a5f", "filename": "src/test/compile-fail/extfmt-no-args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "10020abeb524e8276c113ea8cdb9a4bfd9dfd723", "filename": "src/test/compile-fail/extfmt-non-literal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "81727087aaab34d793f8c7b1a496477e2f3575f4", "filename": "src/test/compile-fail/extfmt-non-literal2.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "335a441adde4aedb5da1f9b44baf81c7e99f4486", "filename": "src/test/compile-fail/extfmt-not-enough-args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "3b956fafcb9ff00070fc1f26fda9f6621204a935", "filename": "src/test/compile-fail/extfmt-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "8c272a182a58163e92843d0b94d192461c0443ba", "filename": "src/test/compile-fail/extfmt-unknown-type.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "ad35d4eec4659174afa27d65ec9cf6382dc05db3", "filename": "src/test/compile-fail/extfmt-unsigned-plus.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "898c429efe351c6a3a1f5fbae023dd66049e6db2", "filename": "src/test/compile-fail/extfmt-unsigned-space.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "44a321f578dc881491f4dc1a624d9be66f262fc5", "filename": "src/test/compile-fail/extfmt-unterminated-conv.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "13d91ce5cb231334f6a471d89ed1b4780a921dee", "filename": "src/test/compile-fail/fail-expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "50c59d143c9a1233539f78689c9c7be4e72117bb", "filename": "src/test/compile-fail/fail-simple.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "952043e797bd4fc18141e9596ce36ccb4c780bbf", "filename": "src/test/compile-fail/fail-type-err.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "44ef885606dc61d3e633ded17d7f2ab63c6e8bb3", "filename": "src/test/compile-fail/fn-bad-block-type.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffn-bad-block-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffn-bad-block-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-bad-block-type.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "ba40cd5971d0bc0e867d075695b11a883a2c845d", "filename": "src/test/compile-fail/fn-compare-mismatch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "0be8d79a3999f1cf8db68278174e7bf3d454c9cd", "filename": "src/test/compile-fail/fn-constraint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "cecb7bfbed0cc3d0c425179ad3b5e1f3fc55f773", "filename": "src/test/compile-fail/fn-expr-type-state.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffn-expr-type-state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffn-expr-type-state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-expr-type-state.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "baa0e081121008cff7230a7f05ac6f715adc14ab", "filename": "src/test/compile-fail/fn-expr-typestate-2.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffn-expr-typestate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffn-expr-typestate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-expr-typestate-2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "5b7fa90a74de309e0a4f2e6fbdcff41c853cae26", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "1cdc55ffd870472ab6a941d1fbc591bb3c9aac81", "filename": "src/test/compile-fail/forgot-ret.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "6957da34956b3d41850434e4055d2e84ce092f97", "filename": "src/test/compile-fail/fru-extra-field.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "ce5102cbf655be1805017d6c520b0a0b038491a9", "filename": "src/test/compile-fail/fru-typestate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "345d2509970e4a26666229977fad3b1363d92ec3", "filename": "src/test/compile-fail/if-branch-types.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "0d190374642d281a3b38e15d7ba1e20d0c7f0b42", "filename": "src/test/compile-fail/if-check-precond-fail.rs", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a67b282c4e7560da2b3a1ddfb2ac0118acea8800", "filename": "src/test/compile-fail/if-typeck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fif-typeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fif-typeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-typeck.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "8d74000ef0bcf33e93df2ba2959c5e5f25dde77b", "filename": "src/test/compile-fail/import-glob-0.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "1a937d617c6603edd1a0e9405d619bddf8a7f8f4", "filename": "src/test/compile-fail/import-glob-circular.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "57f154e104fdba6ac77f093b39f5b411947a3e1b", "filename": "src/test/compile-fail/import-glob-export.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-glob-export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-glob-export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-export.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "1abe786ab6b6604dce29e23f8a4b74665fce11e7", "filename": "src/test/compile-fail/import-glob-multiple.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a21950898fa4372984c570c822aa9bea38e2cb8c", "filename": "src/test/compile-fail/import-loop-2.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "6e790829ec85f50c58e102b86df3de440cd2ef87", "filename": "src/test/compile-fail/import-loop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "6667c9a938ab7e7db7105e43511aeda495dadec0", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "6029aad5dee9a323c5822d2855f1b170592843a1", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "b4e76affe121e5b26235f33474f3dc01ff109381", "filename": "src/test/compile-fail/import3.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport3.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "bde87e0da5d81338b5ac9c33f6c5b8f1ef833278", "filename": "src/test/compile-fail/import4.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport4.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4910bb5065e96a6742a71c6e26deca3e8c3d4dc8", "filename": "src/test/compile-fail/import5.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimport5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport5.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "cf775f8d6f129881defd55770cb553fc632b51b2", "filename": "src/test/compile-fail/impure-pred.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "856bd7ffaa287db975a70364daf89ff3adc7f89a", "filename": "src/test/compile-fail/infinite-tag-type-recursion.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "006a084d1c56fe5b0c1c9b142452250b3b9bfa6d", "filename": "src/test/compile-fail/infinite-vec-type-recursion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "fe8da20ea1acac60c477b3e4662ba66ec9f246a2", "filename": "src/test/compile-fail/item-name-overload.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fitem-name-overload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fitem-name-overload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fitem-name-overload.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a2ff7ef8f49248fbe045d9cdee973778b3e214d6", "filename": "src/test/compile-fail/macro-2.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "2118e5ce7fe0a9163a2f2a8339c991f2c8798f1d", "filename": "src/test/compile-fail/macro.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "5386b78d3814e5b07356634523837ee0c94fb479", "filename": "src/test/compile-fail/main-wrong-type-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "58b3b26a8c4ae2b6b40e40b3fc611ac07542337e", "filename": "src/test/compile-fail/main-wrong-type.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4a9199237f2d6c02b95cc4b7be9616ec5c21da8f", "filename": "src/test/compile-fail/missing-main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmissing-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmissing-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-main.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "10502205390696a2cd06e8ae4a731c04a1442c2c", "filename": "src/test/compile-fail/missing-return.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmissing-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmissing-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-return.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "af1612b13235c82dbe90aaf49304feacd9293510", "filename": "src/test/compile-fail/missing-return2.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "220a5e5d0aa6c451609f2169c7989203067129e7", "filename": "src/test/compile-fail/multiline-comment-line-tracking.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmultiline-comment-line-tracking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fmultiline-comment-line-tracking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultiline-comment-line-tracking.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "daa2c9fa96b68091d1bce048330d6268e9845097", "filename": "src/test/compile-fail/native-type-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnative-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnative-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnative-type-mismatch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "d321f6f3c9d4e275370f06346d68874359ef86a7", "filename": "src/test/compile-fail/nested-ty-params.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "6d65be94569b46ca40af5a08fde9c53e417c3bf2", "filename": "src/test/compile-fail/no-constraint-prop.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "b23092b6409727bfd8f85a2bd82f1b650cd3061b", "filename": "src/test/compile-fail/no-self-dispatch.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fno-self-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fno-self-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-self-dispatch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "63aad9b37dfd236d0fa4fc4f487db50162532543", "filename": "src/test/compile-fail/not-a-pred-2.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "6852429b24e88a35c62948b4588f9e216e456eb3", "filename": "src/test/compile-fail/not-a-pred-3.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-3.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "20a0b5a70705335dc2a10a2f79869480026dd8a8", "filename": "src/test/compile-fail/not-a-pred-check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a3421c65613348f15d0afc8102153019ea3f6ae1", "filename": "src/test/compile-fail/not-a-pred.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "81a0cb08af11c95e8a4d8f266a07506e19e30cf6", "filename": "src/test/compile-fail/not-pred-args.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "3aac5cb14178b439cfd58301f3e5ad9aeb71aafa", "filename": "src/test/compile-fail/or-init.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2For-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2For-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2For-init.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "d7525d7b627a961eff4fcb8bec7f62bfd3bde099", "filename": "src/test/compile-fail/or-patter-mismatch.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "38ee7b5a6be7de757ec4bfaa2dda4e8d00a9cf85", "filename": "src/test/compile-fail/output-type-mismatch.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Foutput-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Foutput-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foutput-type-mismatch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "27d7b50e75da0b2ce85206ade4d2cdcb5bfe6b5e", "filename": "src/test/compile-fail/pattern-tyvar-2.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "01da4d3a7c1d22625b1dc7e12dbdea36d5e00d86", "filename": "src/test/compile-fail/pattern-tyvar.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "c70ee8e5e676d02fa1dd4294228fe21e44fe7e36", "filename": "src/test/compile-fail/pred-assign.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "024ff5216f974dc2f39f2dee987db081311042d7", "filename": "src/test/compile-fail/pred-not-bool.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpred-not-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpred-not-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-not-bool.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "adf0f027fbc33125e2809c62b2214486036b04b8", "filename": "src/test/compile-fail/pred-on-wrong-slots.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4d3881c00870d4e88c87038624d4153593e6750a", "filename": "src/test/compile-fail/pred-swap.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "c5e56def981392838d46642665f40b4ac8905ea0", "filename": "src/test/compile-fail/put-in-fn.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fput-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fput-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fput-in-fn.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "61039436c8e1f243aeae868ae5947e8b8f6e97b4", "filename": "src/test/compile-fail/rec-extend.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Frec-extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Frec-extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frec-extend.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "50bf16c9a208de1b1a03b849c92b124bf266c690", "filename": "src/test/compile-fail/rec-missing-fields.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "7c483ed41945390aa41c39d6904f2d842b8ff520", "filename": "src/test/compile-fail/ret-non-nil.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "34b7a6b5af0a57ee7474c18725ca1849e193764a", "filename": "src/test/compile-fail/return-uninit.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "4d238f55a964b5c654ee4a0eebbf0ef8b5156210", "filename": "src/test/compile-fail/self-call-non-obj.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fself-call-non-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fself-call-non-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-call-non-obj.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "32aee6fbb6bc74846668454ef36db03337cd1f6b", "filename": "src/test/compile-fail/self-missing-method.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "24bbf4fd9ff959e6aab9eaf9bf67af30eb666ed0", "filename": "src/test/compile-fail/shadow.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadow.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "ae50c6bf3acbdabfec1470a5bff9fad8ef93fc4a", "filename": "src/test/compile-fail/slot-as-pred.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "33d2b31bbf6b8447e5233be173a40f6b329fd7ab", "filename": "src/test/compile-fail/spawn-non-nil-fn.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a45f524fe093111e25e7cd38b52473004f11a5f1", "filename": "src/test/compile-fail/swap-no-lval.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "e06d539702b36367b60843a47f8d64abce471f3f", "filename": "src/test/compile-fail/swap-uninit.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fswap-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fswap-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fswap-uninit.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "eb9dc2371ec22742c78a0b7a5a981efcbcaca91d", "filename": "src/test/compile-fail/tag-type-args.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "632ea716b7b616793733c5e404fe8ca6712bc2e1", "filename": "src/test/compile-fail/tail-non-call.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftail-non-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftail-non-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftail-non-call.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "7dd315b929bf6247106a3177c27d7046e87b5fb5", "filename": "src/test/compile-fail/tail-typeck.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftail-typeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftail-typeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftail-typeck.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "01b8e92a9764a22bb445d4bd510d401eccd11304", "filename": "src/test/compile-fail/type-arg-out-of-scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "9a7a4b588a7832844ed5c13091b4fa4131b733f6", "filename": "src/test/compile-fail/type-mismatch-multiple.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "059c4cdd5436141fece2a85686c9de1118c15afd", "filename": "src/test/compile-fail/type-mismatch.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftype-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftype-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-mismatch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "b71f47db0418a67875f9a8a07fb63cc2715f35cd", "filename": "src/test/compile-fail/type-recursive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "52022cf67fc8eab67044ca08b02c906ae6b67d4a", "filename": "src/test/compile-fail/type-shadow.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "55d4bfb2d5c82d1595bfc83f7a30678b0496a90b", "filename": "src/test/compile-fail/unbalanced-comment.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "905cef4443474d8a58b5ebfe57b885c05bcf790c", "filename": "src/test/compile-fail/uninit-after-item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funinit-after-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funinit-after-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinit-after-item.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "eaf5d75702f1c21d67f6e1dea5a532c66a253bfb", "filename": "src/test/compile-fail/unreachable-arm.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "3917dd3f88313836fd597847567638f3f96ab095", "filename": "src/test/compile-fail/unsafe-alias-2.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "46fb135b951400fd1103a120353182061f4cab53", "filename": "src/test/compile-fail/unsafe-alias.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "2e0605fa0553457a396f071b00b51aad4e3f11b0", "filename": "src/test/compile-fail/unsafe-alt.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "62fd75519d7d4c3b0f7d961cb4ca2c7e92e11c55", "filename": "src/test/compile-fail/unsafe-for.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "24accc3e48c8e1d6c4bb49e1641583456620e7aa", "filename": "src/test/compile-fail/unsafe-mutable-alias.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "ff20307fece8d36db83a47ff67de02a130683463", "filename": "src/test/compile-fail/use-after-move.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a9e8df49d7dcf2bc2358773cab508fa99380e338", "filename": "src/test/compile-fail/use-meta-dup.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-meta-dup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-meta-dup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-meta-dup.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "a2adca83cd4983e8d059e80e00c62e175740c362", "filename": "src/test/compile-fail/use-meta-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-meta-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-meta-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-meta-mismatch.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "d46c340a9df894604d2fcd34a595e2fd2a0bc538", "filename": "src/test/compile-fail/use-uninit-2.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "cf680f0c18493b81473ef3ef839b04f9e34f6f04", "filename": "src/test/compile-fail/use-uninit-3.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-uninit-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-uninit-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit-3.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "c3c824d7c6f5f1cae0eaf783e2723eafea8a5245", "filename": "src/test/compile-fail/use-uninit-dtor.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit-dtor.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "b787947fe7b0b23f6223ae008dbcaa539bd610ec", "filename": "src/test/compile-fail/use-uninit.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "76464a3f75cc3a80edefab1ed1faa1ecef307556", "filename": "src/test/compile-fail/vec-field.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-field.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}, {"sha": "087fa20d076e2de6008dbb4f700f2f8a513368dc", "filename": "src/test/compile-fail/vector-no-ann.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7f21db093b0f206048b18e977161f91b7c28f1/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs?ref=df7f21db093b0f206048b18e977161f91b7c28f1"}]}