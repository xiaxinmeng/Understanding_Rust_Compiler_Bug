{"sha": "42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYTJhNTNlYzEzYjBlNmU5MTVhY2QwOWEyYTlhOTYzZTVmYTNiOTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-28T15:36:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-28T15:36:38Z"}, "message": "Auto merge of #88390 - sexxi-goose:missing-case, r=nikomatsakis\n\nAdd missing const edge case\n\nWe don't \"process\" const so we need to check for additional cases when the PatKind is a Path. We need to make sure that if there is only one variant that there is no field. If there is one or more field, we will want to borrow the match scrutinee\n\nCloses https://github.com/rust-lang/rust/issues/88331\nr? `@nikomatsakis`", "tree": {"sha": "a83f42849691e128fc2c728dad5001ddcfdd74b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a83f42849691e128fc2c728dad5001ddcfdd74b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92", "html_url": "https://github.com/rust-lang/rust/commit/42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84b018341284798fa47f8171f4eb04f18f45cf23", "url": "https://api.github.com/repos/rust-lang/rust/commits/84b018341284798fa47f8171f4eb04f18f45cf23", "html_url": "https://github.com/rust-lang/rust/commit/84b018341284798fa47f8171f4eb04f18f45cf23"}, {"sha": "c4dba5a64efe340a779d8a1ee8c332140c51180e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4dba5a64efe340a779d8a1ee8c332140c51180e", "html_url": "https://github.com/rust-lang/rust/commit/c4dba5a64efe340a779d8a1ee8c332140c51180e"}], "stats": {"total": 112, "additions": 93, "deletions": 19}, "files": [{"sha": "a8be207dbb363cce1148deea796abde7d220b4c8", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92", "patch": "@@ -2,6 +2,7 @@\n //! normal visitor, which just walks the entire body in one shot, the\n //! `ExprUseVisitor` determines how expressions are being used.\n \n+use hir::def::DefKind;\n // Export these here so that Clippy can use them.\n pub use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection};\n \n@@ -14,7 +15,7 @@ use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::mir::FakeReadCause;\n-use rustc_middle::ty::{self, adjustment, TyCtxt};\n+use rustc_middle::ty::{self, adjustment, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n use std::iter;\n \n@@ -251,28 +252,37 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                                     needs_to_be_read = true;\n                                 }\n                             }\n-                            PatKind::TupleStruct(..)\n-                            | PatKind::Path(..)\n-                            | PatKind::Struct(..)\n-                            | PatKind::Tuple(..) => {\n-                                // If the PatKind is a TupleStruct, Path, Struct or Tuple then we want to check\n-                                // whether the Variant is a MultiVariant or a SingleVariant. We only want\n-                                // to borrow discr if it is a MultiVariant.\n-                                // If it is a SingleVariant and creates a binding we will handle that when\n-                                // this callback gets called again.\n-\n-                                // Get the type of the Place after all projections have been applied\n-                                let place_ty = place.place.ty();\n-\n-                                if let ty::Adt(def, _) = place_ty.kind() {\n-                                    if def.variants.len() > 1 {\n+                            PatKind::Path(qpath) => {\n+                                // A `Path` pattern is just a name like `Foo`. This is either a\n+                                // named constant or else it refers to an ADT variant\n+\n+                                let res = self.mc.typeck_results.qpath_res(qpath, pat.hir_id);\n+                                match res {\n+                                    Res::Def(DefKind::Const, _)\n+                                    | Res::Def(DefKind::AssocConst, _) => {\n+                                        // Named constants have to be equated with the value\n+                                        // being matched, so that's a read of the value being matched.\n+                                        //\n+                                        // FIXME: We don't actually  reads for ZSTs.\n                                         needs_to_be_read = true;\n                                     }\n-                                } else {\n-                                    // If it is not ty::Adt, then it should be read\n-                                    needs_to_be_read = true;\n+                                    _ => {\n+                                        // Otherwise, this is a struct/enum variant, and so it's\n+                                        // only a read if we need to read the discriminant.\n+                                        needs_to_be_read |= is_multivariant_adt(place.place.ty());\n+                                    }\n                                 }\n                             }\n+                            PatKind::TupleStruct(..) | PatKind::Struct(..) | PatKind::Tuple(..) => {\n+                                // For `Foo(..)`, `Foo { ... }` and `(...)` patterns, check if we are matching\n+                                // against a multivariant enum or struct. In that case, we have to read\n+                                // the discriminant. Otherwise this kind of pattern doesn't actually\n+                                // read anything (we'll get invoked for the `...`, which may indeed\n+                                // perform some reads).\n+\n+                                let place_ty = place.place.ty();\n+                                needs_to_be_read |= is_multivariant_adt(place_ty);\n+                            }\n                             PatKind::Lit(_) | PatKind::Range(..) => {\n                                 // If the PatKind is a Lit or a Range then we want\n                                 // to borrow discr.\n@@ -833,3 +843,7 @@ fn delegate_consume<'a, 'tcx>(\n         }\n     }\n }\n+\n+fn is_multivariant_adt(ty: Ty<'tcx>) -> bool {\n+    if let ty::Adt(def, _) = ty.kind() { def.variants.len() > 1 } else { false }\n+}"}, {"sha": "0a6d71c68ae84f7c660ed0f29bb106d53dc9d384", "filename": "src/test/ui/closures/2229_closure_analysis/issue-88331.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-88331.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-88331.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-88331.rs?ref=42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92", "patch": "@@ -0,0 +1,33 @@\n+// edition:2021\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub struct Opcode(pub u8);\n+\n+impl Opcode {\n+    pub const OP1: Opcode = Opcode(0x1);\n+}\n+\n+pub fn example1(msg_type: Opcode) -> impl FnMut(&[u8]) {\n+    move |i| match msg_type {\n+    //~^ ERROR: non-exhaustive patterns: `Opcode(0_u8)` and `Opcode(2_u8..=u8::MAX)` not covered\n+        Opcode::OP1 => unimplemented!(),\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub struct Opcode2(Opcode);\n+\n+impl Opcode2 {\n+    pub const OP2: Opcode2 = Opcode2(Opcode(0x1));\n+}\n+\n+\n+pub fn example2(msg_type: Opcode2) -> impl FnMut(&[u8]) {\n+\n+    move |i| match msg_type {\n+    //~^ ERROR: non-exhaustive patterns: `Opcode2(Opcode(0_u8))` and `Opcode2(Opcode(2_u8..=u8::MAX))` not covered\n+        Opcode2::OP2=> unimplemented!(),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f02d23464f168284574dd689d4cfc2666463250b", "filename": "src/test/ui/closures/2229_closure_analysis/issue-88331.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-88331.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-88331.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue-88331.stderr?ref=42a2a53ec13b0e6e915acd09a2a9a963e5fa3b92", "patch": "@@ -0,0 +1,27 @@\n+error[E0004]: non-exhaustive patterns: `Opcode(0_u8)` and `Opcode(2_u8..=u8::MAX)` not covered\n+  --> $DIR/issue-88331.rs:11:20\n+   |\n+LL | pub struct Opcode(pub u8);\n+   | -------------------------- `Opcode` defined here\n+...\n+LL |     move |i| match msg_type {\n+   |                    ^^^^^^^^ patterns `Opcode(0_u8)` and `Opcode(2_u8..=u8::MAX)` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Opcode`\n+\n+error[E0004]: non-exhaustive patterns: `Opcode2(Opcode(0_u8))` and `Opcode2(Opcode(2_u8..=u8::MAX))` not covered\n+  --> $DIR/issue-88331.rs:27:20\n+   |\n+LL | pub struct Opcode2(Opcode);\n+   | --------------------------- `Opcode2` defined here\n+...\n+LL |     move |i| match msg_type {\n+   |                    ^^^^^^^^ patterns `Opcode2(Opcode(0_u8))` and `Opcode2(Opcode(2_u8..=u8::MAX))` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Opcode2`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}]}