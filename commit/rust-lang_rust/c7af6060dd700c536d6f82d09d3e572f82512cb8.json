{"sha": "c7af6060dd700c536d6f82d09d3e572f82512cb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3YWY2MDYwZGQ3MDBjNTM2ZDZmODJkMDlkM2U1NzJmODI1MTJjYjg=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-06T22:49:48Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-24T18:36:27Z"}, "message": "Clean up and document the public lint API\n\nAlso change some code formatting.\n\nlint::builtin becomes a sibling of lint::context in order to ensure that lints\nimplemented there use the same public API as lint plugins.", "tree": {"sha": "80f302d5219f2abc8764dc0be986bf52c760c66b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80f302d5219f2abc8764dc0be986bf52c760c66b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7af6060dd700c536d6f82d09d3e572f82512cb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7af6060dd700c536d6f82d09d3e572f82512cb8", "html_url": "https://github.com/rust-lang/rust/commit/c7af6060dd700c536d6f82d09d3e572f82512cb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7af6060dd700c536d6f82d09d3e572f82512cb8/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "819f76ca8251b2fd1910546d133e305fda8dc5e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/819f76ca8251b2fd1910546d133e305fda8dc5e5", "html_url": "https://github.com/rust-lang/rust/commit/819f76ca8251b2fd1910546d133e305fda8dc5e5"}], "stats": {"total": 1448, "additions": 767, "deletions": 681}, "files": [{"sha": "83ffd194fad98ebcf4aac2e51770a88526244e78", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7af6060dd700c536d6f82d09d3e572f82512cb8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7af6060dd700c536d6f82d09d3e572f82512cb8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=c7af6060dd700c536d6f82d09d3e572f82512cb8", "patch": "@@ -384,7 +384,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     });\n \n     time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(&ty_cx, &exported_items, krate));\n+         lint::check_crate(&ty_cx, krate, &exported_items));\n \n     CrateAnalysis {\n         exp_map2: exp_map2,"}, {"sha": "d34014c2b65d1269325cfdd47d467ffec48b68ee", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c7af6060dd700c536d6f82d09d3e572f82512cb8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7af6060dd700c536d6f82d09d3e572f82512cb8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c7af6060dd700c536d6f82d09d3e572f82512cb8", "patch": "@@ -9,18 +9,31 @@\n // except according to those terms.\n \n //! Lints built in to rustc.\n+//!\n+//! This is a sibling of `lint::context` in order to ensure that\n+//! lints implemented here use the same public API as lint plugins.\n+//!\n+//! To add a new lint to rustc, declare it here using `declare_lint!()`.\n+//! Then add code to emit the new lint in the appropriate circumstances.\n+//! You can do that in an existing `LintPass` if it makes sense, or in\n+//! a new `LintPass`, or using `Session::add_lint` elsewhere in the\n+//! compiler. Only do the latter if the check can't be written cleanly\n+//! as a `LintPass`.\n+//!\n+//! If you define a new `LintPass`, you will also need to add it to the\n+//! `add_builtin_lints!()` invocation in `context.rs`. That macro\n+//! requires a `Default` impl for your `LintPass` type.\n \n use metadata::csearch;\n use middle::def::*;\n use middle::trans::adt; // for `adt::is_ffi_safe`\n-use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n+use middle::typeck::astconv::ast_ty_to_ty;\n use middle::typeck::infer;\n use middle::privacy::ExportedItems;\n use middle::{typeck, ty, def, pat_util};\n use util::ppaux::{ty_to_str};\n use util::nodemap::NodeSet;\n use lint::{Context, LintPass, LintArray};\n-use lint;\n \n use std::cmp;\n use std::collections::HashMap;\n@@ -169,7 +182,7 @@ impl LintPass for TypeLimits {\n                 match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n                     ty::ty_int(t) => {\n                         let int_type = if t == ast::TyI {\n-                            cx.tcx.sess.targ_cfg.int_type\n+                            cx.sess().targ_cfg.int_type\n                         } else { t };\n                         let (min, max) = int_ty_range(int_type);\n                         let mut lit_val: i64 = match lit.node {\n@@ -188,7 +201,7 @@ impl LintPass for TypeLimits {\n                     },\n                     ty::ty_uint(t) => {\n                         let uint_type = if t == ast::TyU {\n-                            cx.tcx.sess.targ_cfg.uint_type\n+                            cx.sess().targ_cfg.uint_type\n                         } else { t };\n                         let (min, max) = uint_ty_range(uint_type);\n                         let lit_val: u64 = match lit.node {\n@@ -430,9 +443,9 @@ impl LintPass for HeapMemory {\n             ast::ItemFn(..) |\n             ast::ItemTy(..) |\n             ast::ItemEnum(..) |\n-            ast::ItemStruct(..) => self.check_heap_type(cx, it.span,\n-                                                        ty::node_id_to_type(cx.tcx,\n-                                                                            it.id)),\n+            ast::ItemStruct(..)\n+                => self.check_heap_type(cx, it.span,\n+                    ty::node_id_to_type(cx.tcx, it.id)),\n             _ => ()\n         }\n \n@@ -441,8 +454,7 @@ impl LintPass for HeapMemory {\n             ast::ItemStruct(struct_def, _) => {\n                 for struct_field in struct_def.fields.iter() {\n                     self.check_heap_type(cx, struct_field.span,\n-                                         ty::node_id_to_type(cx.tcx,\n-                                                             struct_field.node.id));\n+                    ty::node_id_to_type(cx.tcx, struct_field.node.id));\n                 }\n             }\n             _ => ()\n@@ -677,7 +689,7 @@ impl LintPass for UnusedResult {\n                         _ => {}\n                     }\n                 } else {\n-                    csearch::get_item_attrs(&cx.tcx.sess.cstore, did, |attrs| {\n+                    csearch::get_item_attrs(&cx.sess().cstore, did, |attrs| {\n                         if attr::contains_name(attrs.as_slice(), \"must_use\") {\n                             cx.span_lint(unused_must_use, s.span,\n                                          \"unused result which must be used\");\n@@ -711,7 +723,7 @@ impl LintPass for DeprecatedOwnedVector {\n             ty::ty_uniq(t) => match ty::get(t).sty {\n                 ty::ty_vec(_, None) => {\n                     cx.span_lint(deprecated_owned_vector, e.span,\n-                                 \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n+                        \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n                 }\n                 _ => {}\n             },\n@@ -791,7 +803,7 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n     };\n \n     match cx.tcx.methods.borrow().find_copy(&did) {\n-        None => cx.tcx.sess.span_bug(m.span, \"missing method descriptor?!\"),\n+        None => cx.sess().span_bug(m.span, \"missing method descriptor?!\"),\n         Some(md) => {\n             match md.container {\n                 ty::TraitContainer(..) => TraitDefaultImpl,\n@@ -1110,15 +1122,14 @@ impl UnusedMut {\n                 match mode {\n                     ast::BindByValue(ast::MutMutable) => {\n                         if path.segments.len() != 1 {\n-                            cx.tcx.sess.span_bug(p.span,\n+                            cx.sess().span_bug(p.span,\n                                                  \"mutable binding that doesn't consist \\\n                                                   of exactly one segment\");\n                         }\n                         let ident = path.segments.get(0).identifier;\n                         if !token::get_ident(ident).get().starts_with(\"_\") {\n-                            mutables.insert_or_update_with(ident.name as uint, vec!(id), |_, old| {\n-                                old.push(id);\n-                            });\n+                            mutables.insert_or_update_with(ident.name as uint,\n+                                vec!(id), |_, old| { old.push(id); });\n                         }\n                     }\n                     _ => {\n@@ -1279,7 +1290,7 @@ impl MissingDoc {\n                                desc: &'static str) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n-        if cx.tcx.sess.opts.test { return }\n+        if cx.sess().opts.test { return }\n \n         // `#[doc(hidden)]` disables missing_doc check.\n         if self.doc_hidden() { return }\n@@ -1358,7 +1369,8 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_fn(&mut self, cx: &Context,\n-            fk: &visit::FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) {\n+            fk: &visit::FnKind, _: &ast::FnDecl,\n+            _: &ast::Block, _: Span, _: ast::NodeId) {\n         match *fk {\n             visit::FkMethod(_, _, m) => {\n                 // If the method is an impl for a trait, don't doc.\n@@ -1381,7 +1393,8 @@ impl LintPass for MissingDoc {\n     fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n         match sf.node.kind {\n             ast::NamedField(_, vis) if vis == ast::Public => {\n-                let cur_struct_def = *self.struct_def_stack.last().expect(\"empty struct_def_stack\");\n+                let cur_struct_def = *self.struct_def_stack.last()\n+                    .expect(\"empty struct_def_stack\");\n                 self.check_missing_doc_attrs(cx, Some(cur_struct_def),\n                     sf.node.attrs.as_slice(), sf.span, \"a struct field\")\n             }\n@@ -1404,8 +1417,8 @@ declare_lint!(experimental, Warn,\n declare_lint!(unstable, Allow,\n     \"detects use of #[unstable] items (incl. items with no stability attribute)\")\n \n-/// Checks for use of items with #[deprecated], #[experimental] and\n-/// #[unstable] (or none of them) attributes.\n+/// Checks for use of items with `#[deprecated]`, `#[experimental]` and\n+/// `#[unstable]` attributes, or no stability attribute.\n #[deriving(Default)]\n pub struct Stability;\n \n@@ -1472,7 +1485,7 @@ impl LintPass for Stability {\n             let mut s = None;\n             // run through all the attributes and take the first\n             // stability one.\n-            csearch::get_item_attrs(&cx.tcx.sess.cstore, id, |attrs| {\n+            csearch::get_item_attrs(&cx.sess().cstore, id, |attrs| {\n                 if s.is_none() {\n                     s = attr::find_stability(attrs.as_slice())\n                 }\n@@ -1503,32 +1516,6 @@ impl LintPass for Stability {\n     }\n }\n \n-/// Doesn't actually warn; just gathers information for use by\n-/// checks in trans.\n-#[deriving(Default)]\n-pub struct GatherNodeLevels;\n-\n-impl LintPass for GatherNodeLevels {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!()\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        match it.node {\n-            ast::ItemEnum(..) => {\n-                let lint_id = lint::LintId::of(variant_size_difference);\n-                match cx.lints.get_level_source(lint_id) {\n-                    lvlsrc @ (lvl, _) if lvl != lint::Allow => {\n-                        cx.insert_node_level(it.id, lint_id, lvlsrc);\n-                    },\n-                    _ => { }\n-                }\n-            },\n-            _ => { }\n-        }\n-    }\n-}\n-\n declare_lint!(pub unused_imports, Warn,\n     \"imports that are never used\")\n "}, {"sha": "3f7a4ceb74b50567ea168c9e046730cb4c02143c", "filename": "src/librustc/lint/context.rs", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/rust-lang/rust/blob/c7af6060dd700c536d6f82d09d3e572f82512cb8/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7af6060dd700c536d6f82d09d3e572f82512cb8/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=c7af6060dd700c536d6f82d09d3e572f82512cb8", "patch": "@@ -0,0 +1,628 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of lint checking.\n+//!\n+//! The lint checking is mostly consolidated into one pass which runs just\n+//! before translation to LLVM bytecode. Throughout compilation, lint warnings\n+//! can be added via the `add_lint` method on the Session structure. This\n+//! requires a span and an id of the node that the lint is being added to. The\n+//! lint isn't actually emitted at that time because it is unknown what the\n+//! actual lint level at that location is.\n+//!\n+//! To actually emit lint warnings/errors, a separate pass is used just before\n+//! translation. A context keeps track of the current state of all lint levels.\n+//! Upon entering a node of the ast which can modify the lint settings, the\n+//! previous lint state is pushed onto a stack and the ast is then recursed\n+//! upon.  As the ast is traversed, this keeps track of the current lint level\n+//! for all lint attributes.\n+\n+use middle::privacy::ExportedItems;\n+use middle::ty;\n+use middle::typeck::astconv::AstConv;\n+use middle::typeck::infer;\n+use driver::session::Session;\n+use driver::early_error;\n+use lint::{Level, LevelSource, Lint, LintId, LintArray, LintPass, LintPassObject};\n+use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n+use lint::builtin;\n+\n+use std::collections::HashMap;\n+use std::rc::Rc;\n+use std::cell::RefCell;\n+use std::default::Default;\n+use std::tuple::Tuple2;\n+use std::mem;\n+use syntax::ast_util::IdVisitingOperation;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::visit::{Visitor, FnKind};\n+use syntax::{ast, ast_util, visit};\n+\n+/// Information about the registered lints.\n+///\n+/// This is basically the subset of `Context` that we can\n+/// build early in the compile pipeline.\n+pub struct LintStore {\n+    /// Registered lints. The bool is true if the lint was\n+    /// added by a plugin.\n+    lints: Vec<(&'static Lint, bool)>,\n+\n+    /// Trait objects for each lint pass.\n+    passes: Vec<RefCell<LintPassObject>>,\n+\n+    /// Lints indexed by name.\n+    by_name: HashMap<&'static str, LintId>,\n+\n+    /// Current levels of each lint, and where they were set.\n+    levels: HashMap<LintId, LevelSource>,\n+}\n+\n+impl LintStore {\n+    fn get_level_source(&self, lint: LintId) -> LevelSource {\n+        match self.levels.find(&lint) {\n+            Some(&s) => s,\n+            None => (Allow, Default),\n+        }\n+    }\n+\n+    fn set_level(&mut self, lint: LintId, lvlsrc: LevelSource) {\n+        if lvlsrc.val0() == Allow {\n+            self.levels.remove(&lint);\n+        } else {\n+            self.levels.insert(lint, lvlsrc);\n+        }\n+    }\n+\n+    pub fn new() -> LintStore {\n+        LintStore {\n+            lints: vec!(),\n+            passes: vec!(),\n+            by_name: HashMap::new(),\n+            levels: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n+        self.lints.as_slice()\n+    }\n+\n+    pub fn register_pass(&mut self, sess: Option<&Session>,\n+                         from_plugin: bool, pass: LintPassObject) {\n+        for &lint in pass.get_lints().iter() {\n+            self.lints.push((lint, from_plugin));\n+\n+            let id = LintId::of(lint);\n+            if !self.by_name.insert(lint.name, id) {\n+                let msg = format!(\"duplicate specification of lint {}\", lint.name);\n+                match (sess, from_plugin) {\n+                    // We load builtin lints first, so a duplicate is a compiler bug.\n+                    // Use early_error when handling -W help with no crate.\n+                    (None, _) => early_error(msg.as_slice()),\n+                    (Some(sess), false) => sess.bug(msg.as_slice()),\n+\n+                    // A duplicate name from a plugin is a user error.\n+                    (Some(sess), true)  => sess.err(msg.as_slice()),\n+                }\n+            }\n+\n+            if lint.default_level != Allow {\n+                self.levels.insert(id, (lint.default_level, Default));\n+            }\n+        }\n+        self.passes.push(RefCell::new(pass));\n+    }\n+\n+    pub fn register_builtin(&mut self, sess: Option<&Session>) {\n+        macro_rules! add_builtin_lints ( ( $sess:ident, $($name:ident),*, ) => (\n+            {$(\n+                {\n+                    let obj: builtin::$name = Default::default();\n+                    self.register_pass($sess, false, box obj as LintPassObject);\n+                };\n+            )*}\n+        ))\n+\n+        add_builtin_lints!(sess, HardwiredLints,\n+            WhileTrue, UnusedCasts, TypeLimits, CTypes, HeapMemory,\n+            RawPointerDeriving, UnusedAttribute, PathStatement,\n+            UnusedResult, DeprecatedOwnedVector, NonCamelCaseTypes,\n+            NonSnakeCaseFunctions, NonUppercaseStatics,\n+            NonUppercasePatternStatics, UppercaseVariables,\n+            UnnecessaryParens, UnusedUnsafe, UnsafeBlock, UnusedMut,\n+            UnnecessaryAllocation, MissingDoc, Stability,\n+        )\n+\n+        // We have one lint pass defined in this module.\n+        self.register_pass(sess, false, box GatherNodeLevels as LintPassObject);\n+    }\n+\n+    pub fn process_command_line(&mut self, sess: &Session) {\n+        for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n+            match self.by_name.find_equiv(&lint_name.as_slice()) {\n+                Some(&lint_id) => self.set_level(lint_id, (level, CommandLine)),\n+                None => sess.err(format!(\"unknown {} flag: {}\",\n+                    level.as_str(), lint_name).as_slice()),\n+            }\n+        }\n+    }\n+}\n+\n+/// Context for lint checking.\n+pub struct Context<'a> {\n+    /// Type context we're checking in.\n+    pub tcx: &'a ty::ctxt,\n+\n+    /// The store of registered lints.\n+    lints: LintStore,\n+\n+    /// When recursing into an attributed node of the ast which modifies lint\n+    /// levels, this stack keeps track of the previous lint levels of whatever\n+    /// was modified.\n+    level_stack: Vec<(LintId, LevelSource)>,\n+\n+    /// Level of lints for certain NodeIds, stored here because the body of\n+    /// the lint needs to run in trans.\n+    node_levels: RefCell<HashMap<(ast::NodeId, LintId), LevelSource>>,\n+}\n+\n+/// Convenience macro for calling a `LintPass` method on every pass in the context.\n+macro_rules! run_lints ( ($cx:expr, $f:ident, $($args:expr),*) => (\n+    for obj in $cx.lints.passes.iter() {\n+        obj.borrow_mut().$f($cx, $($args),*);\n+    }\n+))\n+\n+/// Emit a lint as a warning or an error (or not at all)\n+/// according to `level`.\n+///\n+/// This lives outside of `Context` so it can be used by checks\n+/// in trans that run after the main lint pass is finished. Most\n+/// lints elsewhere in the compiler should call\n+/// `Session::add_lint()` instead.\n+pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n+                     lvlsrc: LevelSource, span: Option<Span>, msg: &str) {\n+    let (mut level, source) = lvlsrc;\n+    if level == Allow { return }\n+\n+    let mut note = None;\n+    let msg = match source {\n+        Default => {\n+            format!(\"{}, #[{}({})] on by default\", msg,\n+                level.as_str(), lint.name)\n+        },\n+        CommandLine => {\n+            format!(\"{} [-{} {}]\", msg,\n+                match level {\n+                    Warn => 'W', Deny => 'D', Forbid => 'F',\n+                    Allow => fail!()\n+                }, lint.name.replace(\"_\", \"-\"))\n+        },\n+        Node(src) => {\n+            note = Some(src);\n+            msg.to_string()\n+        }\n+    };\n+\n+    // For purposes of printing, we can treat forbid as deny.\n+    if level == Forbid { level = Deny; }\n+\n+    match (level, span) {\n+        (Warn, Some(sp)) => sess.span_warn(sp, msg.as_slice()),\n+        (Warn, None)     => sess.warn(msg.as_slice()),\n+        (Deny, Some(sp)) => sess.span_err(sp, msg.as_slice()),\n+        (Deny, None)     => sess.err(msg.as_slice()),\n+        _ => sess.bug(\"impossible level in raw_emit_lint\"),\n+    }\n+\n+    for span in note.move_iter() {\n+        sess.span_note(span, \"lint level defined here\");\n+    }\n+}\n+\n+impl<'a> Context<'a> {\n+    fn new(tcx: &'a ty::ctxt) -> Context<'a> {\n+        // We want to own the lint store, so move it out of the session.\n+        let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n+            LintStore::new());\n+\n+        Context {\n+            lints: lint_store,\n+            tcx: tcx,\n+            level_stack: vec!(),\n+            node_levels: RefCell::new(HashMap::new()),\n+        }\n+    }\n+\n+    /// Get the overall compiler `Session` object.\n+    pub fn sess(&'a self) -> &'a Session {\n+        &self.tcx.sess\n+    }\n+\n+    fn lookup_and_emit(&self, lint: &'static Lint, span: Option<Span>, msg: &str) {\n+        let (level, src) = match self.lints.levels.find(&LintId::of(lint)) {\n+            None => return,\n+            Some(&(Warn, src)) => {\n+                let lint_id = LintId::of(builtin::warnings);\n+                (self.lints.get_level_source(lint_id).val0(), src)\n+            }\n+            Some(&pair) => pair,\n+        };\n+\n+        raw_emit_lint(&self.tcx.sess, lint, (level, src), span, msg);\n+    }\n+\n+    /// Emit a lint at the appropriate level, with no associated span.\n+    pub fn lint(&self, lint: &'static Lint, msg: &str) {\n+        self.lookup_and_emit(lint, None, msg);\n+    }\n+\n+    /// Emit a lint at the appropriate level, for a particular span.\n+    pub fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n+        self.lookup_and_emit(lint, Some(span), msg);\n+    }\n+\n+    /**\n+     * Merge the lints specified by any lint attributes into the\n+     * current lint context, call the provided function, then reset the\n+     * lints in effect to their previous state.\n+     */\n+    fn with_lint_attrs(&mut self,\n+                       attrs: &[ast::Attribute],\n+                       f: |&mut Context|) {\n+        // Parse all of the lint attributes, and then add them all to the\n+        // current dictionary of lint information. Along the way, keep a history\n+        // of what we changed so we can roll everything back after invoking the\n+        // specified closure\n+        let lint_attrs = self.gather_lint_attrs(attrs);\n+        let mut pushed = 0u;\n+        for (lint_id, level, span) in lint_attrs.move_iter() {\n+            let now = self.lints.get_level_source(lint_id).val0();\n+            if now == Forbid && level != Forbid {\n+                let lint_name = lint_id.as_str();\n+                self.tcx.sess.span_err(span,\n+                    format!(\"{}({}) overruled by outer forbid({})\",\n+                        level.as_str(), lint_name, lint_name).as_slice());\n+            } else if now != level {\n+                let src = self.lints.get_level_source(lint_id).val1();\n+                self.level_stack.push((lint_id, (now, src)));\n+                pushed += 1;\n+                self.lints.set_level(lint_id, (level, Node(span)));\n+            }\n+        }\n+\n+        run_lints!(self, enter_lint_attrs, attrs);\n+        f(self);\n+        run_lints!(self, exit_lint_attrs, attrs);\n+\n+        // rollback\n+        for _ in range(0, pushed) {\n+            let (lint, lvlsrc) = self.level_stack.pop().unwrap();\n+            self.lints.set_level(lint, lvlsrc);\n+        }\n+    }\n+\n+    fn visit_ids(&self, f: |&mut ast_util::IdVisitor<Context>|) {\n+        let mut v = ast_util::IdVisitor {\n+            operation: self,\n+            pass_through_items: false,\n+            visited_outermost: false,\n+        };\n+        f(&mut v);\n+    }\n+\n+    fn gather_lint_attrs(&mut self, attrs: &[ast::Attribute]) -> Vec<(LintId, Level, Span)> {\n+        // Doing this as an iterator is messy due to multiple borrowing.\n+        // Allocating and copying these should be quick.\n+        let mut out = vec!();\n+        for attr in attrs.iter() {\n+            let level = match Level::from_str(attr.name().get()) {\n+                None => continue,\n+                Some(lvl) => lvl,\n+            };\n+\n+            attr::mark_used(attr);\n+\n+            let meta = attr.node.value;\n+            let metas = match meta.node {\n+                ast::MetaList(_, ref metas) => metas,\n+                _ => {\n+                    self.tcx.sess.span_err(meta.span, \"malformed lint attribute\");\n+                    continue;\n+                }\n+            };\n+\n+            for meta in metas.iter() {\n+                match meta.node {\n+                    ast::MetaWord(ref lint_name) => {\n+                        match self.lints.by_name.find_equiv(lint_name) {\n+                            Some(lint_id) => out.push((*lint_id, level, meta.span)),\n+\n+                            None => self.span_lint(builtin::unrecognized_lint,\n+                                meta.span,\n+                                format!(\"unknown `{}` attribute: `{}`\",\n+                                    level.as_str(), lint_name).as_slice()),\n+                        }\n+                    }\n+                    _ => self.tcx.sess.span_err(meta.span, \"malformed lint attribute\"),\n+                }\n+            }\n+        }\n+        out\n+    }\n+}\n+\n+impl<'a> AstConv for Context<'a>{\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n+        ty::lookup_item_type(self.tcx, id)\n+    }\n+\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+        ty::lookup_trait_def(self.tcx, id)\n+    }\n+\n+    fn ty_infer(&self, _span: Span) -> ty::t {\n+        infer::new_infer_ctxt(self.tcx).next_ty_var()\n+    }\n+}\n+\n+impl<'a> Visitor<()> for Context<'a> {\n+    fn visit_item(&mut self, it: &ast::Item, _: ()) {\n+        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_item, it);\n+            cx.visit_ids(|v| v.visit_item(it, ()));\n+            visit::walk_item(cx, it, ());\n+        })\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &ast::ForeignItem, _: ()) {\n+        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_foreign_item, it);\n+            visit::walk_foreign_item(cx, it, ());\n+        })\n+    }\n+\n+    fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n+        self.with_lint_attrs(i.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_view_item, i);\n+            cx.visit_ids(|v| v.visit_view_item(i, ()));\n+            visit::walk_view_item(cx, i, ());\n+        })\n+    }\n+\n+    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n+        run_lints!(self, check_pat, p);\n+        visit::walk_pat(self, p, ());\n+    }\n+\n+    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n+        run_lints!(self, check_expr, e);\n+        visit::walk_expr(self, e, ());\n+    }\n+\n+    fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) {\n+        run_lints!(self, check_stmt, s);\n+        visit::walk_stmt(self, s, ());\n+    }\n+\n+    fn visit_fn(&mut self, fk: &FnKind, decl: &ast::FnDecl,\n+                body: &ast::Block, span: Span, id: ast::NodeId, _: ()) {\n+        match *fk {\n+            visit::FkMethod(_, _, m) => {\n+                self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n+                    run_lints!(cx, check_fn, fk, decl, body, span, id);\n+                    cx.visit_ids(|v| {\n+                        v.visit_fn(fk, decl, body, span, id, ());\n+                    });\n+                    visit::walk_fn(cx, fk, decl, body, span, ());\n+                })\n+            },\n+            _ => {\n+                run_lints!(self, check_fn, fk, decl, body, span, id);\n+                visit::walk_fn(self, fk, decl, body, span, ());\n+            }\n+        }\n+    }\n+\n+    fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n+        self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_ty_method, t);\n+            visit::walk_ty_method(cx, t, ());\n+        })\n+    }\n+\n+    fn visit_struct_def(&mut self,\n+                        s: &ast::StructDef,\n+                        ident: ast::Ident,\n+                        g: &ast::Generics,\n+                        id: ast::NodeId,\n+                        _: ()) {\n+        run_lints!(self, check_struct_def, s, ident, g, id);\n+        visit::walk_struct_def(self, s, ());\n+        run_lints!(self, check_struct_def_post, s, ident, g, id);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n+        self.with_lint_attrs(s.node.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_struct_field, s);\n+            visit::walk_struct_field(cx, s, ());\n+        })\n+    }\n+\n+    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n+        self.with_lint_attrs(v.node.attrs.as_slice(), |cx| {\n+            run_lints!(cx, check_variant, v, g);\n+            visit::walk_variant(cx, v, g, ());\n+        })\n+    }\n+\n+    // FIXME(#10894) should continue recursing\n+    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+        run_lints!(self, check_ty, t);\n+    }\n+\n+    fn visit_ident(&mut self, sp: Span, id: ast::Ident, _: ()) {\n+        run_lints!(self, check_ident, sp, id);\n+    }\n+\n+    fn visit_mod(&mut self, m: &ast::Mod, s: Span, n: ast::NodeId, _: ()) {\n+        run_lints!(self, check_mod, m, s, n);\n+        visit::walk_mod(self, m, ());\n+    }\n+\n+    fn visit_local(&mut self, l: &ast::Local, _: ()) {\n+        run_lints!(self, check_local, l);\n+        visit::walk_local(self, l, ());\n+    }\n+\n+    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n+        run_lints!(self, check_block, b);\n+        visit::walk_block(self, b, ());\n+    }\n+\n+    fn visit_arm(&mut self, a: &ast::Arm, _: ()) {\n+        run_lints!(self, check_arm, a);\n+        visit::walk_arm(self, a, ());\n+    }\n+\n+    fn visit_decl(&mut self, d: &ast::Decl, _: ()) {\n+        run_lints!(self, check_decl, d);\n+        visit::walk_decl(self, d, ());\n+    }\n+\n+    fn visit_expr_post(&mut self, e: &ast::Expr, _: ()) {\n+        run_lints!(self, check_expr_post, e);\n+    }\n+\n+    fn visit_generics(&mut self, g: &ast::Generics, _: ()) {\n+        run_lints!(self, check_generics, g);\n+        visit::walk_generics(self, g, ());\n+    }\n+\n+    fn visit_trait_method(&mut self, m: &ast::TraitMethod, _: ()) {\n+        run_lints!(self, check_trait_method, m);\n+        visit::walk_trait_method(self, m, ());\n+    }\n+\n+    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>, _: ()) {\n+        run_lints!(self, check_opt_lifetime_ref, sp, lt);\n+    }\n+\n+    fn visit_lifetime_ref(&mut self, lt: &ast::Lifetime, _: ()) {\n+        run_lints!(self, check_lifetime_ref, lt);\n+    }\n+\n+    fn visit_lifetime_decl(&mut self, lt: &ast::Lifetime, _: ()) {\n+        run_lints!(self, check_lifetime_decl, lt);\n+    }\n+\n+    fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf, _: ()) {\n+        run_lints!(self, check_explicit_self, es);\n+        visit::walk_explicit_self(self, es, ());\n+    }\n+\n+    fn visit_mac(&mut self, mac: &ast::Mac, _: ()) {\n+        run_lints!(self, check_mac, mac);\n+        visit::walk_mac(self, mac, ());\n+    }\n+\n+    fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId, _: ()) {\n+        run_lints!(self, check_path, p, id);\n+        visit::walk_path(self, p, ());\n+    }\n+\n+    fn visit_attribute(&mut self, attr: &ast::Attribute, _: ()) {\n+        run_lints!(self, check_attribute, attr);\n+    }\n+}\n+\n+// Output any lints that were previously added to the session.\n+impl<'a> IdVisitingOperation for Context<'a> {\n+    fn visit_id(&self, id: ast::NodeId) {\n+        match self.tcx.sess.lints.borrow_mut().pop(&id) {\n+            None => {}\n+            Some(lints) => {\n+                for (lint_id, span, msg) in lints.move_iter() {\n+                    self.span_lint(lint_id.lint, span, msg.as_slice())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// This lint pass is defined here because it touches parts of the `Context`\n+// that we don't want to expose. It records the lint level at certain AST\n+// nodes, so that the variant size difference check in trans can call\n+// `raw_emit_lint`.\n+\n+struct GatherNodeLevels;\n+\n+impl LintPass for GatherNodeLevels {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!()\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemEnum(..) => {\n+                let lint_id = LintId::of(builtin::variant_size_difference);\n+                match cx.lints.get_level_source(lint_id) {\n+                    lvlsrc @ (lvl, _) if lvl != Allow => {\n+                        cx.node_levels.borrow_mut()\n+                            .insert((it.id, lint_id), lvlsrc);\n+                    },\n+                    _ => { }\n+                }\n+            },\n+            _ => { }\n+        }\n+    }\n+}\n+\n+/// Perform lint checking on a crate.\n+///\n+/// Consumes the `lint_store` field of the `Session`.\n+pub fn check_crate(tcx: &ty::ctxt,\n+                   krate: &ast::Crate,\n+                   exported_items: &ExportedItems) {\n+    let mut cx = Context::new(tcx);\n+\n+    // Visit the whole crate.\n+    cx.with_lint_attrs(krate.attrs.as_slice(), |cx| {\n+        cx.visit_id(ast::CRATE_NODE_ID);\n+        cx.visit_ids(|v| {\n+            v.visited_outermost = true;\n+            visit::walk_crate(v, krate, ());\n+        });\n+\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        run_lints!(cx, check_crate, exported_items, krate);\n+\n+        visit::walk_crate(cx, krate, ());\n+    });\n+\n+    // If we missed any lints added to the session, then there's a bug somewhere\n+    // in the iteration code.\n+    for (id, v) in tcx.sess.lints.borrow().iter() {\n+        for &(lint, span, ref msg) in v.iter() {\n+            tcx.sess.span_bug(span,\n+                format!(\"unprocessed lint {} at {}: {}\",\n+                    lint.as_str(), tcx.map.node_to_str(*id), *msg)\n+                .as_slice())\n+        }\n+    }\n+\n+    tcx.sess.abort_if_errors();\n+    *tcx.node_lint_levels.borrow_mut() = cx.node_levels.unwrap();\n+}"}, {"sha": "ea7023b3bc82c944955552c7882bab1946109420", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 61, "deletions": 591, "changes": 652, "blob_url": "https://github.com/rust-lang/rust/blob/c7af6060dd700c536d6f82d09d3e572f82512cb8/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7af6060dd700c536d6f82d09d3e572f82512cb8/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=c7af6060dd700c536d6f82d09d3e572f82512cb8", "patch": "@@ -8,65 +8,55 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Lints, aka compiler warnings.\n+//!\n //! A 'lint' check is a kind of miscellaneous constraint that a user _might_\n //! want to enforce, but might reasonably want to permit as well, on a\n //! module-by-module basis. They contrast with static constraints enforced by\n //! other phases of the compiler, which are generally required to hold in order\n //! to compile the program at all.\n //!\n-//! The lint checking is all consolidated into one pass which runs just before\n-//! translation to LLVM bytecode. Throughout compilation, lint warnings can be\n-//! added via the `add_lint` method on the Session structure. This requires a\n-//! span and an id of the node that the lint is being added to. The lint isn't\n-//! actually emitted at that time because it is unknown what the actual lint\n-//! level at that location is.\n-//!\n-//! To actually emit lint warnings/errors, a separate pass is used just before\n-//! translation. A context keeps track of the current state of all lint levels.\n-//! Upon entering a node of the ast which can modify the lint settings, the\n-//! previous lint state is pushed onto a stack and the ast is then recursed\n-//! upon.  As the ast is traversed, this keeps track of the current lint level\n-//! for all lint attributes.\n-//!\n-//! Most of the lints built into `rustc` are structs implementing `LintPass`,\n-//! and are defined within `builtin.rs`. To add a new lint you can define such\n-//! a struct and add it to the `builtin_lints!` macro invocation in this file.\n-//! `LintPass` itself is not a subtrait of `Default`, but the `builtin_lints!`\n-//! macro requires `Default` (usually via `deriving`).\n+//! Most lints can be written as `LintPass` instances. These run just before\n+//! translation to LLVM bytecode. The `LintPass`es built into rustc are defined\n+//! within `builtin.rs`, which has further comments on how to add such a lint.\n //!\n-//! Some lints are defined elsewhere in the compiler and work by calling\n-//! `add_lint()` on the overall `Session` object.\n-//!\n-//! If you're adding lints to the `Context` infrastructure itself, defined in\n-//! this file, use `span_lint` instead of `add_lint`.\n+//! Some of rustc's lints are defined elsewhere in the compiler and work by\n+//! calling `add_lint()` on the overall `Session` object. This works when\n+//! it happens before the main lint pass, which emits the lints stored by\n+//! `add_lint()`. To emit lints after the main lint pass (from trans, for\n+//! example) requires more effort. See `emit_lint` and `GatherNodeLevels`\n+//! in `context.rs`.\n \n-#![allow(non_camel_case_types)]\n #![macro_escape]\n \n use middle::privacy::ExportedItems;\n-use middle::ty;\n-use middle::typeck::astconv::AstConv;\n-use middle::typeck::infer;\n-use driver::session::Session;\n-use driver::early_error;\n-\n-use std::collections::HashMap;\n-use std::rc::Rc;\n-use std::gc::Gc;\n-use std::to_str::ToStr;\n-use std::cell::RefCell;\n-use std::default::Default;\n-use std::hash::Hash;\n-use std::tuple::Tuple2;\n use std::hash;\n-use std::mem;\n-use syntax::ast_util::IdVisitingOperation;\n-use syntax::attr::AttrMetaMethods;\n-use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::visit::{Visitor, FnKind};\n-use syntax::{ast, ast_util, visit};\n+use syntax::visit::FnKind;\n+use syntax::ast;\n+\n+pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate};\n \n+/// Specification of a single lint.\n+pub struct Lint {\n+    /// A string identifier for the lint.\n+    ///\n+    /// Written with underscores, e.g. \"unused_imports\".\n+    /// This identifies the lint in attributes and in\n+    /// command-line arguments. On the command line,\n+    /// underscores become dashes.\n+    pub name: &'static str,\n+\n+    /// Default level for the lint.\n+    pub default_level: Level,\n+\n+    /// Description of the lint or the issue it detects.\n+    ///\n+    /// e.g. \"imports that are never used\"\n+    pub desc: &'static str,\n+}\n+\n+/// Build a `Lint` initializer.\n #[macro_export]\n macro_rules! lint_initializer (\n     ($name:ident, $level:ident, $desc:expr) => (\n@@ -78,6 +68,7 @@ macro_rules! lint_initializer (\n     )\n )\n \n+/// Declare a static item of type `&'static Lint`.\n #[macro_export]\n macro_rules! declare_lint (\n     // FIXME(#14660): deduplicate\n@@ -91,6 +82,7 @@ macro_rules! declare_lint (\n     );\n )\n \n+/// Declare a static `LintArray` and return it as an expression.\n #[macro_export]\n macro_rules! lint_array ( ($( $lint:expr ),*) => (\n     {\n@@ -99,29 +91,13 @@ macro_rules! lint_array ( ($( $lint:expr ),*) => (\n     }\n ))\n \n-pub mod builtin;\n-\n-/// Specification of a single lint.\n-pub struct Lint {\n-    /// An identifier for the lint, written with underscores,\n-    /// e.g. \"unused_imports\". This identifies the lint in\n-    /// attributes and in command-line arguments. On the\n-    /// command line, underscores become dashes.\n-    pub name: &'static str,\n-\n-    /// Default level for the lint.\n-    pub default_level: Level,\n-\n-    /// Description of the lint or the issue it detects,\n-    /// e.g. \"imports that are never used\"\n-    pub desc: &'static str,\n-}\n-\n pub type LintArray = &'static [&'static Lint];\n \n-/// Trait for types providing lint checks. Each `check` method checks a single\n-/// syntax node, and should not invoke methods recursively (unlike `Visitor`).\n-/// By default they do nothing.\n+/// Trait for types providing lint checks.\n+///\n+/// Each `check` method checks a single syntax node, and should not\n+/// invoke methods recursively (unlike `Visitor`). By default they\n+/// do nothing.\n //\n // FIXME: eliminate the duplication with `Visitor`. But this also\n // contains a few lint-specific methods with no equivalent in `Visitor`.\n@@ -176,7 +152,8 @@ pub trait LintPass {\n     fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n }\n \n-type LintPassObject = Box<LintPass + 'static>;\n+/// A lint pass boxed up as a trait object.\n+pub type LintPassObject = Box<LintPass + 'static>;\n \n /// Identifies a lint known to the compiler.\n #[deriving(Clone)]\n@@ -193,31 +170,35 @@ impl PartialEq for LintId {\n \n impl Eq for LintId { }\n \n-impl<S: hash::Writer> Hash<S> for LintId {\n+impl<S: hash::Writer> hash::Hash<S> for LintId {\n     fn hash(&self, state: &mut S) {\n         let ptr = self.lint as *Lint;\n         ptr.hash(state);\n     }\n }\n \n impl LintId {\n+    /// Get the `LintId` for a `Lint`.\n     pub fn of(lint: &'static Lint) -> LintId {\n         LintId {\n             lint: lint,\n         }\n     }\n \n+    /// Get the name of the lint.\n     pub fn as_str(&self) -> &'static str {\n         self.lint.name\n     }\n }\n \n+/// Setting for how to handle a lint.\n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n pub enum Level {\n     Allow, Warn, Deny, Forbid\n }\n \n impl Level {\n+    /// Convert a level to a lower-case string.\n     pub fn as_str(self) -> &'static str {\n         match self {\n             Allow => \"allow\",\n@@ -227,6 +208,7 @@ impl Level {\n         }\n     }\n \n+    /// Convert a lower-case string to a level.\n     pub fn from_str(x: &str) -> Option<Level> {\n         match x {\n             \"allow\" => Some(Allow),\n@@ -238,534 +220,22 @@ impl Level {\n     }\n }\n \n-// this is public for the lints that run in trans\n-#[deriving(PartialEq)]\n+/// How a lint level was set.\n+#[deriving(Clone, PartialEq, Eq)]\n pub enum LintSource {\n-    Node(Span),\n+    /// Lint is at the default level as declared\n+    /// in rustc or a plugin.\n     Default,\n-    CommandLine\n-}\n-\n-pub type LevelSource = (Level, LintSource);\n-\n-/// Information about the registered lints.\n-/// This is basically the subset of `Context` that we can\n-/// build early in the compile pipeline.\n-pub struct LintStore {\n-    /// Registered lints. The bool is true if the lint was\n-    /// added by a plugin.\n-    lints: Vec<(&'static Lint, bool)>,\n-\n-    /// Trait objects for each lint pass.\n-    passes: Vec<RefCell<LintPassObject>>,\n-\n-    /// Lints indexed by name.\n-    by_name: HashMap<&'static str, LintId>,\n-\n-    /// Current levels of each lint, and where they were set.\n-    levels: HashMap<LintId, LevelSource>,\n-}\n-\n-impl LintStore {\n-    fn get_level_source(&self, lint: LintId) -> LevelSource {\n-        match self.levels.find(&lint) {\n-            Some(&s) => s,\n-            None => (Allow, Default),\n-        }\n-    }\n-\n-    fn set_level(&mut self, lint: LintId, lvlsrc: LevelSource) {\n-        if lvlsrc.val0() == Allow {\n-            self.levels.remove(&lint);\n-        } else {\n-            self.levels.insert(lint, lvlsrc);\n-        }\n-    }\n-\n-    pub fn new() -> LintStore {\n-        LintStore {\n-            lints: vec!(),\n-            passes: vec!(),\n-            by_name: HashMap::new(),\n-            levels: HashMap::new(),\n-        }\n-    }\n-\n-    pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n-        self.lints.as_slice()\n-    }\n-\n-    pub fn register_pass(&mut self, sess: Option<&Session>,\n-                         from_plugin: bool, pass: LintPassObject) {\n-        for &lint in pass.get_lints().iter() {\n-            self.lints.push((lint, from_plugin));\n-\n-            let id = LintId::of(lint);\n-            if !self.by_name.insert(lint.name, id) {\n-                let msg = format!(\"duplicate specification of lint {}\", lint.name);\n-                match (sess, from_plugin) {\n-                    // We load builtin lints first, so a duplicate is a compiler bug.\n-                    // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(msg.as_slice()),\n-                    (Some(sess), false) => sess.bug(msg.as_slice()),\n-\n-                    // A duplicate name from a plugin is a user error.\n-                    (Some(sess), true)  => sess.err(msg.as_slice()),\n-                }\n-            }\n-\n-            if lint.default_level != Allow {\n-                self.levels.insert(id, (lint.default_level, Default));\n-            }\n-        }\n-        self.passes.push(RefCell::new(pass));\n-    }\n-\n-    pub fn register_builtin(&mut self, sess: Option<&Session>) {\n-        macro_rules! add_builtin_lints ( ( $sess:ident, $($name:ident),*, ) => (\n-            {$(\n-                {\n-                    let obj: builtin::$name = Default::default();\n-                    self.register_pass($sess, false, box obj as LintPassObject);\n-                };\n-            )*}\n-        ))\n-\n-        add_builtin_lints!(sess,\n-            WhileTrue, UnusedCasts, TypeLimits, CTypes, HeapMemory,\n-            RawPointerDeriving, UnusedAttribute, PathStatement,\n-            UnusedResult, DeprecatedOwnedVector, NonCamelCaseTypes,\n-            NonSnakeCaseFunctions, NonUppercaseStatics,\n-            NonUppercasePatternStatics, UppercaseVariables,\n-            UnnecessaryParens, UnusedUnsafe, UnsafeBlock, UnusedMut,\n-            UnnecessaryAllocation, MissingDoc, Stability,\n-\n-            GatherNodeLevels, HardwiredLints,\n-        )\n-    }\n-\n-    pub fn process_command_line(&mut self, sess: &Session) {\n-        for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n-            match self.by_name.find_equiv(&lint_name.as_slice()) {\n-                Some(&lint_id) => self.set_level(lint_id, (level, CommandLine)),\n-                None => sess.err(format!(\"unknown {} flag: {}\",\n-                    level.as_str(), lint_name).as_slice()),\n-            }\n-        }\n-    }\n-}\n-\n-/// Context for lint checking.\n-pub struct Context<'a> {\n-    /// The store of registered lints.\n-    lints: LintStore,\n-\n-    /// Context we're checking in (used to access fields like sess).\n-    tcx: &'a ty::ctxt,\n-\n-    /// When recursing into an attributed node of the ast which modifies lint\n-    /// levels, this stack keeps track of the previous lint levels of whatever\n-    /// was modified.\n-    level_stack: Vec<(LintId, LevelSource)>,\n-\n-    /// Level of lints for certain NodeIds, stored here because the body of\n-    /// the lint needs to run in trans.\n-    node_levels: RefCell<HashMap<(ast::NodeId, LintId), LevelSource>>,\n-}\n-\n-/// Convenience macro for calling a `LintPass` method on every pass in the context.\n-macro_rules! run_lints ( ($cx:expr, $f:ident, $($args:expr),*) => (\n-    for obj in $cx.lints.passes.iter() {\n-        obj.borrow_mut().$f($cx, $($args),*);\n-    }\n-))\n-\n-/// Emit a lint as a `span_warn` or `span_err` (or not at all)\n-/// according to `level`.  This lives outside of `Context` so\n-/// it can be used by checks in trans that run after the main\n-/// lint phase is finished.\n-pub fn emit_lint(sess: &Session, lint: &'static Lint,\n-                 lvlsrc: LevelSource, span: Span, msg: &str) {\n-    let (level, source) = lvlsrc;\n-    if level == Allow { return }\n-\n-    let mut note = None;\n-    let msg = match source {\n-        Default => {\n-            format!(\"{}, #[{}({})] on by default\", msg,\n-                level_to_str(level), lint_str)\n-        },\n-        CommandLine => {\n-            format!(\"{} [-{} {}]\", msg,\n-                match level {\n-                    Warn => 'W', Deny => 'D', Forbid => 'F',\n-                    Allow => fail!()\n-                }, lint.name.replace(\"_\", \"-\"))\n-        },\n-        Node(src) => {\n-            note = Some(src);\n-            msg.to_string()\n-        }\n-    };\n-\n-    match level {\n-        Warn =>          { sess.span_warn(span, msg.as_slice()); }\n-        Deny | Forbid => { sess.span_err(span, msg.as_slice());  }\n-        Allow => fail!(),\n-    }\n-\n-    for span in note.move_iter() {\n-        sess.span_note(span, \"lint level defined here\");\n-    }\n-}\n-\n-impl<'a> Context<'a> {\n-    pub fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n-        let (level, src) = match self.lints.levels.find(&LintId::of(lint)) {\n-            None => return,\n-            Some(&(Warn, src))\n-                => (self.lints.get_level_source(LintId::of(builtin::warnings)).val0(), src),\n-            Some(&pair) => pair,\n-        };\n-\n-        emit_lint(&self.tcx.sess, lint, (level, src), span, msg);\n-    }\n-\n-    /**\n-     * Merge the lints specified by any lint attributes into the\n-     * current lint context, call the provided function, then reset the\n-     * lints in effect to their previous state.\n-     */\n-    fn with_lint_attrs(&mut self,\n-                       attrs: &[ast::Attribute],\n-                       f: |&mut Context|) {\n-        // Parse all of the lint attributes, and then add them all to the\n-        // current dictionary of lint information. Along the way, keep a history\n-        // of what we changed so we can roll everything back after invoking the\n-        // specified closure\n-        let lint_attrs = self.gather_lint_attrs(attrs);\n-        let mut pushed = 0u;\n-        for (lint_id, level, span) in lint_attrs.move_iter() {\n-            let now = self.lints.get_level_source(lint_id).val0();\n-            if now == Forbid && level != Forbid {\n-                let lint_name = lint_id.as_str();\n-                self.tcx.sess.span_err(span,\n-                format!(\"{}({}) overruled by outer forbid({})\",\n-                        level.as_str(), lint_name, lint_name).as_slice());\n-            } else if now != level {\n-                let src = self.lints.get_level_source(lint_id).val1();\n-                self.level_stack.push((lint_id, (now, src)));\n-                pushed += 1;\n-                self.lints.set_level(lint_id, (level, Node(span)));\n-            }\n-        }\n-\n-        run_lints!(self, enter_lint_attrs, attrs);\n-        f(self);\n-        run_lints!(self, exit_lint_attrs, attrs);\n-\n-        // rollback\n-        for _ in range(0, pushed) {\n-            let (lint, lvlsrc) = self.level_stack.pop().unwrap();\n-            self.lints.set_level(lint, lvlsrc);\n-        }\n-    }\n \n-    fn visit_ids(&self, f: |&mut ast_util::IdVisitor<Context>|) {\n-        let mut v = ast_util::IdVisitor {\n-            operation: self,\n-            pass_through_items: false,\n-            visited_outermost: false,\n-        };\n-        f(&mut v);\n-    }\n-\n-    fn insert_node_level(&self, id: ast::NodeId, lint: LintId, lvlsrc: LevelSource) {\n-        self.node_levels.borrow_mut().insert((id, lint), lvlsrc);\n-    }\n-\n-    fn gather_lint_attrs(&mut self, attrs: &[ast::Attribute]) -> Vec<(LintId, Level, Span)> {\n-        // Doing this as an iterator is messy due to multiple borrowing.\n-        // Allocating and copying these should be quick.\n-        let mut out = vec!();\n-        for attr in attrs.iter() {\n-            let level = match Level::from_str(attr.name().get()) {\n-                None => continue,\n-                Some(lvl) => lvl,\n-            };\n-\n-            attr::mark_used(attr);\n-\n-            let meta = attr.node.value;\n-            let metas = match meta.node {\n-                ast::MetaList(_, ref metas) => metas,\n-                _ => {\n-                    self.tcx.sess.span_err(meta.span, \"malformed lint attribute\");\n-                    continue;\n-                }\n-            };\n-\n-            for meta in metas.iter() {\n-                match meta.node {\n-                    ast::MetaWord(ref lint_name) => {\n-                        match self.lints.by_name.find_equiv(lint_name) {\n-                            Some(lint_id) => out.push((*lint_id, level, meta.span)),\n-\n-                            None => self.span_lint(builtin::unrecognized_lint,\n-                                meta.span,\n-                                format!(\"unknown `{}` attribute: `{}`\",\n-                                    level.as_str(), lint_name).as_slice()),\n-                        }\n-                    }\n-                    _ => self.tcx.sess.span_err(meta.span, \"malformed lint attribute\"),\n-                }\n-            }\n-        }\n-        out\n-    }\n-}\n-\n-impl<'a> AstConv for Context<'a>{\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n-        ty::lookup_item_type(self.tcx, id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n-        ty::lookup_trait_def(self.tcx, id)\n-    }\n-\n-    fn ty_infer(&self, _span: Span) -> ty::t {\n-        infer::new_infer_ctxt(self.tcx).next_ty_var()\n-    }\n-}\n-\n-impl<'a> Visitor<()> for Context<'a> {\n-    fn visit_item(&mut self, it: &ast::Item, _: ()) {\n-        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n-            run_lints!(cx, check_item, it);\n-            cx.visit_ids(|v| v.visit_item(it, ()));\n-            visit::walk_item(cx, it, ());\n-        })\n-    }\n-\n-    fn visit_foreign_item(&mut self, it: &ast::ForeignItem, _: ()) {\n-        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n-            run_lints!(cx, check_foreign_item, it);\n-            visit::walk_foreign_item(cx, it, ());\n-        })\n-    }\n-\n-    fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n-        self.with_lint_attrs(i.attrs.as_slice(), |cx| {\n-            run_lints!(cx, check_view_item, i);\n-            cx.visit_ids(|v| v.visit_view_item(i, ()));\n-            visit::walk_view_item(cx, i, ());\n-        })\n-    }\n-\n-    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n-        run_lints!(self, check_pat, p);\n-        visit::walk_pat(self, p, ());\n-    }\n-\n-    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n-        run_lints!(self, check_expr, e);\n-        visit::walk_expr(self, e, ());\n-    }\n-\n-    fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) {\n-        run_lints!(self, check_stmt, s);\n-        visit::walk_stmt(self, s, ());\n-    }\n-\n-    fn visit_fn(&mut self, fk: &FnKind, decl: &ast::FnDecl,\n-                body: &ast::Block, span: Span, id: ast::NodeId, _: ()) {\n-        match *fk {\n-            visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n-                    run_lints!(cx, check_fn, fk, decl, body, span, id);\n-                    cx.visit_ids(|v| {\n-                        v.visit_fn(fk, decl, body, span, id, ());\n-                    });\n-                    visit::walk_fn(cx, fk, decl, body, span, ());\n-                })\n-            },\n-            _ => {\n-                run_lints!(self, check_fn, fk, decl, body, span, id);\n-                visit::walk_fn(self, fk, decl, body, span, ());\n-            }\n-        }\n-    }\n-\n-    fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n-        self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n-            run_lints!(cx, check_ty_method, t);\n-            visit::walk_ty_method(cx, t, ());\n-        })\n-    }\n-\n-    fn visit_struct_def(&mut self,\n-                        s: &ast::StructDef,\n-                        ident: ast::Ident,\n-                        g: &ast::Generics,\n-                        id: ast::NodeId,\n-                        _: ()) {\n-        run_lints!(self, check_struct_def, s, ident, g, id);\n-        visit::walk_struct_def(self, s, ());\n-        run_lints!(self, check_struct_def_post, s, ident, g, id);\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n-        self.with_lint_attrs(s.node.attrs.as_slice(), |cx| {\n-            run_lints!(cx, check_struct_field, s);\n-            visit::walk_struct_field(cx, s, ());\n-        })\n-    }\n-\n-    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n-        self.with_lint_attrs(v.node.attrs.as_slice(), |cx| {\n-            run_lints!(cx, check_variant, v, g);\n-            visit::walk_variant(cx, v, g, ());\n-        })\n-    }\n-\n-    // FIXME(#10894) should continue recursing\n-    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n-        run_lints!(self, check_ty, t);\n-    }\n-\n-    fn visit_ident(&mut self, sp: Span, id: ast::Ident, _: ()) {\n-        run_lints!(self, check_ident, sp, id);\n-    }\n-\n-    fn visit_mod(&mut self, m: &ast::Mod, s: Span, n: ast::NodeId, _: ()) {\n-        run_lints!(self, check_mod, m, s, n);\n-        visit::walk_mod(self, m, ());\n-    }\n-\n-    fn visit_local(&mut self, l: &ast::Local, _: ()) {\n-        run_lints!(self, check_local, l);\n-        visit::walk_local(self, l, ());\n-    }\n-\n-    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n-        run_lints!(self, check_block, b);\n-        visit::walk_block(self, b, ());\n-    }\n-\n-    fn visit_arm(&mut self, a: &ast::Arm, _: ()) {\n-        run_lints!(self, check_arm, a);\n-        visit::walk_arm(self, a, ());\n-    }\n-\n-    fn visit_decl(&mut self, d: &ast::Decl, _: ()) {\n-        run_lints!(self, check_decl, d);\n-        visit::walk_decl(self, d, ());\n-    }\n-\n-    fn visit_expr_post(&mut self, e: &ast::Expr, _: ()) {\n-        run_lints!(self, check_expr_post, e);\n-    }\n-\n-    fn visit_generics(&mut self, g: &ast::Generics, _: ()) {\n-        run_lints!(self, check_generics, g);\n-        visit::walk_generics(self, g, ());\n-    }\n-\n-    fn visit_trait_method(&mut self, m: &ast::TraitMethod, _: ()) {\n-        run_lints!(self, check_trait_method, m);\n-        visit::walk_trait_method(self, m, ());\n-    }\n-\n-    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>, _: ()) {\n-        run_lints!(self, check_opt_lifetime_ref, sp, lt);\n-    }\n-\n-    fn visit_lifetime_ref(&mut self, lt: &ast::Lifetime, _: ()) {\n-        run_lints!(self, check_lifetime_ref, lt);\n-    }\n-\n-    fn visit_lifetime_decl(&mut self, lt: &ast::Lifetime, _: ()) {\n-        run_lints!(self, check_lifetime_decl, lt);\n-    }\n-\n-    fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf, _: ()) {\n-        run_lints!(self, check_explicit_self, es);\n-        visit::walk_explicit_self(self, es, ());\n-    }\n-\n-    fn visit_mac(&mut self, mac: &ast::Mac, _: ()) {\n-        run_lints!(self, check_mac, mac);\n-        visit::walk_mac(self, mac, ());\n-    }\n-\n-    fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId, _: ()) {\n-        run_lints!(self, check_path, p, id);\n-        visit::walk_path(self, p, ());\n-    }\n-\n-    fn visit_attribute(&mut self, attr: &ast::Attribute, _: ()) {\n-        run_lints!(self, check_attribute, attr);\n-    }\n-}\n+    /// Lint level was set by an attribute.\n+    Node(Span),\n \n-// Output any lints that were previously added to the session.\n-impl<'a> IdVisitingOperation for Context<'a> {\n-    fn visit_id(&self, id: ast::NodeId) {\n-        match self.tcx.sess.lints.borrow_mut().pop(&id) {\n-            None => {}\n-            Some(lints) => {\n-                for (lint_id, span, msg) in lints.move_iter() {\n-                    self.span_lint(lint_id.lint, span, msg.as_slice())\n-                }\n-            }\n-        }\n-    }\n+    /// Lint level was set by a command-line flag.\n+    CommandLine,\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   exported_items: &ExportedItems,\n-                   krate: &ast::Crate) {\n-\n-    // We want to own the lint store, so move it out of the session.\n-    let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n-        LintStore::new());\n-\n-    let mut cx = Context {\n-        lints: lint_store,\n-        tcx: tcx,\n-        level_stack: Vec::new(),\n-        node_levels: RefCell::new(HashMap::new()),\n-    };\n-\n-    // Visit the whole crate.\n-    cx.with_lint_attrs(krate.attrs.as_slice(), |cx| {\n-        cx.visit_id(ast::CRATE_NODE_ID);\n-        cx.visit_ids(|v| {\n-            v.visited_outermost = true;\n-            visit::walk_crate(v, krate, ());\n-        });\n-\n-        // since the root module isn't visited as an item (because it isn't an\n-        // item), warn for it here.\n-        run_lints!(cx, check_crate, exported_items, krate);\n-\n-        visit::walk_crate(cx, krate, ());\n-    });\n+pub type LevelSource = (Level, LintSource);\n \n-    // If we missed any lints added to the session, then there's a bug somewhere\n-    // in the iteration code.\n-    for (id, v) in tcx.sess.lints.borrow().iter() {\n-        for &(lint, span, ref msg) in v.iter() {\n-            tcx.sess.span_bug(span,\n-                format!(\"unprocessed lint {} at {}: {}\",\n-                    lint.as_str(), tcx.map.node_to_str(*id), *msg)\n-                .as_slice())\n-        }\n-    }\n+pub mod builtin;\n \n-    tcx.sess.abort_if_errors();\n-    *tcx.node_lint_levels.borrow_mut() = cx.node_levels.unwrap();\n-}\n+mod context;"}, {"sha": "56ec7ea865494a3f8cf4b774adb49259fb2d4950", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c7af6060dd700c536d6f82d09d3e572f82512cb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7af6060dd700c536d6f82d09d3e572f82512cb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c7af6060dd700c536d6f82d09d3e572f82512cb8", "patch": "@@ -1553,50 +1553,51 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n     let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n \n     let levels = ccx.tcx.node_lint_levels.borrow();\n-    match levels.find(&(id, lint::LintId::of(lint::builtin::variant_size_difference))) {\n-        None | Some(&(lint::Allow, _)) => (),\n-        Some(&lvlsrc) => {\n-            let avar = adt::represent_type(ccx, ty::node_id_to_type(ccx.tcx(), id));\n-            match *avar {\n-                adt::General(_, ref variants) => {\n-                    for var in variants.iter() {\n-                        let mut size = 0;\n-                        for field in var.fields.iter().skip(1) {\n-                            // skip the discriminant\n-                            size += llsize_of_real(ccx, sizing_type_of(ccx, *field));\n-                        }\n-                        sizes.push(size);\n-                    }\n-                },\n-                _ => { /* its size is either constant or unimportant */ }\n+    let lint_id = lint::LintId::of(lint::builtin::variant_size_difference);\n+    let lvlsrc = match levels.find(&(id, lint_id)) {\n+        None | Some(&(lint::Allow, _)) => return,\n+        Some(&lvlsrc) => lvlsrc,\n+    };\n+\n+    let avar = adt::represent_type(ccx, ty::node_id_to_type(ccx.tcx(), id));\n+    match *avar {\n+        adt::General(_, ref variants) => {\n+            for var in variants.iter() {\n+                let mut size = 0;\n+                for field in var.fields.iter().skip(1) {\n+                    // skip the discriminant\n+                    size += llsize_of_real(ccx, sizing_type_of(ccx, *field));\n+                }\n+                sizes.push(size);\n             }\n+        },\n+        _ => { /* its size is either constant or unimportant */ }\n+    }\n \n-            let (largest, slargest, largest_index) = sizes.iter().enumerate().fold((0, 0, 0),\n-                |(l, s, li), (idx, &size)|\n-                    if size > l {\n-                        (size, l, idx)\n-                    } else if size > s {\n-                        (l, size, li)\n-                    } else {\n-                        (l, s, li)\n-                    }\n-            );\n-\n-            // we only warn if the largest variant is at least thrice as large as\n-            // the second-largest.\n-            if largest > slargest * 3 && slargest > 0 {\n-                // Use lint::emit_lint rather than sess.add_lint because the lint-printing\n-                // pass for the latter already ran.\n-                lint::emit_lint(&ccx.tcx().sess, lint::builtin::variant_size_difference,\n-                                lvlsrc, sp,\n-                                format!(\"enum variant is more than three times larger \\\n-                                        ({} bytes) than the next largest (ignoring padding)\",\n-                                        largest).as_slice());\n-\n-                ccx.sess().span_note(enum_def.variants.get(largest_index).span,\n-                                     \"this variant is the largest\");\n+    let (largest, slargest, largest_index) = sizes.iter().enumerate().fold((0, 0, 0),\n+        |(l, s, li), (idx, &size)|\n+            if size > l {\n+                (size, l, idx)\n+            } else if size > s {\n+                (l, size, li)\n+            } else {\n+                (l, s, li)\n             }\n-        }\n+    );\n+\n+    // we only warn if the largest variant is at least thrice as large as\n+    // the second-largest.\n+    if largest > slargest * 3 && slargest > 0 {\n+        // Use lint::raw_emit_lint rather than sess.add_lint because the lint-printing\n+        // pass for the latter already ran.\n+        lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::variant_size_difference,\n+            lvlsrc, Some(sp),\n+            format!(\"enum variant is more than three times larger \\\n+                     ({} bytes) than the next largest (ignoring padding)\",\n+                    largest).as_slice());\n+\n+        ccx.sess().span_note(enum_def.variants.get(largest_index).span,\n+                             \"this variant is the largest\");\n     }\n }\n "}]}