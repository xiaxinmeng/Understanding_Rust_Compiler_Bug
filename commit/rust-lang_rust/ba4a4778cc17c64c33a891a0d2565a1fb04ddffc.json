{"sha": "ba4a4778cc17c64c33a891a0d2565a1fb04ddffc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNGE0Nzc4Y2MxN2M2NGMzM2E4OTFhMGQyNTY1YTFmYjA0ZGRmZmM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-11T02:20:47Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-12T02:21:04Z"}, "message": "std: convert str::{*shift,pop}* to methods.", "tree": {"sha": "bfb5e61af23ac057078304f8708d1dd1a8b27261", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfb5e61af23ac057078304f8708d1dd1a8b27261"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba4a4778cc17c64c33a891a0d2565a1fb04ddffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba4a4778cc17c64c33a891a0d2565a1fb04ddffc", "html_url": "https://github.com/rust-lang/rust/commit/ba4a4778cc17c64c33a891a0d2565a1fb04ddffc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba4a4778cc17c64c33a891a0d2565a1fb04ddffc/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8786bca7e2978e6c1d6eed7e61680b0f25db1f18", "url": "https://api.github.com/repos/rust-lang/rust/commits/8786bca7e2978e6c1d6eed7e61680b0f25db1f18", "html_url": "https://github.com/rust-lang/rust/commit/8786bca7e2978e6c1d6eed7e61680b0f25db1f18"}], "stats": {"total": 160, "additions": 93, "deletions": 67}, "files": [{"sha": "1d31e4ddd874fda6a540ebb14a770822f8563570", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba4a4778cc17c64c33a891a0d2565a1fb04ddffc/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba4a4778cc17c64c33a891a0d2565a1fb04ddffc/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=ba4a4778cc17c64c33a891a0d2565a1fb04ddffc", "patch": "@@ -637,7 +637,7 @@ pub fn symbol_hash(tcx: ty::ctxt,\n     write_string(symbol_hasher, encoder::encoded_ty(tcx, t));\n     let mut hash = truncated_hash_result(symbol_hasher);\n     // Prefix with _ so that it never blends into adjacent digits\n-    str::unshift_char(&mut hash, '_');\n+    hash.unshift_char('_');\n     // tjc: allocation is unfortunate; need to change core::hash\n     hash.to_managed()\n }"}, {"sha": "959fe199b93133a8bfc5f4dfe2986cee8572524c", "filename": "src/libstd/str.rs", "status": "modified", "additions": 87, "deletions": 61, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/ba4a4778cc17c64c33a891a0d2565a1fb04ddffc/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba4a4778cc17c64c33a891a0d2565a1fb04ddffc/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=ba4a4778cc17c64c33a891a0d2565a1fb04ddffc", "patch": "@@ -304,63 +304,6 @@ impl<'self> StrVector for &'self [&'self str] {\n     }\n }\n \n-/*\n-Section: Adding to and removing from a string\n-*/\n-\n-/**\n- * Remove the final character from a string and return it\n- *\n- * # Failure\n- *\n- * If the string does not contain any characters\n- */\n-pub fn pop_char(s: &mut ~str) -> char {\n-    let end = s.len();\n-    assert!(end > 0u);\n-    let CharRange {ch, next} = s.char_range_at_reverse(end);\n-    unsafe { raw::set_len(s, next); }\n-    return ch;\n-}\n-\n-/**\n- * Remove the first character from a string and return it\n- *\n- * # Failure\n- *\n- * If the string does not contain any characters\n- */\n-pub fn shift_char(s: &mut ~str) -> char {\n-    let CharRange {ch, next} = s.char_range_at(0u);\n-    *s = unsafe { raw::slice_bytes_owned(*s, next, s.len()) };\n-    return ch;\n-}\n-\n-/**\n- * Removes the first character from a string slice and returns it. This does\n- * not allocate a new string; instead, it mutates a slice to point one\n- * character beyond the character that was shifted.\n- *\n- * # Failure\n- *\n- * If the string does not contain any characters\n- */\n-#[inline]\n-pub fn slice_shift_char<'a>(s: &'a str) -> (char, &'a str) {\n-    let CharRange {ch, next} = s.char_range_at(0u);\n-    let next_s = unsafe { raw::slice_bytes(s, next, s.len()) };\n-    return (ch, next_s);\n-}\n-\n-/// Prepend a char to a string\n-pub fn unshift_char(s: &mut ~str, ch: char) {\n-    // This could be more efficient.\n-    let mut new_str = ~\"\";\n-    new_str.push_char(ch);\n-    new_str.push_str(*s);\n-    *s = new_str;\n-}\n-\n /*\n Section: Transforming strings\n */\n@@ -1546,6 +1489,8 @@ pub trait StrSlice<'self> {\n     fn find_str(&self, &str) -> Option<uint>;\n \n     fn repeat(&self, nn: uint) -> ~str;\n+\n+    fn slice_shift_char(&self) -> (char, &'self str);\n }\n \n /// Extension methods for strings\n@@ -1757,7 +1702,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         else { match_at(*self, needle, 0u) }\n     }\n     /// Returns true if `needle` is a suffix of the string.\n-    pub fn ends_with(&self, needle: &str) -> bool {\n+    fn ends_with(&self, needle: &str) -> bool {\n         let (self_len, needle_len) = (self.len(), needle.len());\n         if needle_len == 0u { true }\n         else if needle_len > self_len { false }\n@@ -2085,13 +2030,35 @@ impl<'self> StrSlice<'self> for &'self str {\n             ret\n         }\n     }\n+\n+    /**\n+     * Retrieves the first character from a string slice and returns\n+     * it. This does not allocate a new string; instead, it returns a\n+     * slice that point one character beyond the character that was\n+     * shifted.\n+     *\n+     * # Failure\n+     *\n+     * If the string does not contain any characters\n+     */\n+    #[inline]\n+    fn slice_shift_char(&self) -> (char, &'self str) {\n+        let CharRange {ch, next} = self.char_range_at(0u);\n+        let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n+        return (ch, next_s);\n+    }\n+\n+\n }\n \n #[allow(missing_doc)]\n pub trait OwnedStr {\n     fn push_str_no_overallocate(&mut self, rhs: &str);\n     fn push_str(&mut self, rhs: &str);\n     fn push_char(&mut self, c: char);\n+    fn pop_char(&mut self) -> char;\n+    fn shift_char(&mut self) -> char;\n+    fn unshift_char(&mut self, ch: char);\n     fn append(&self, rhs: &str) -> ~str; // FIXME #4850: this should consume self.\n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n@@ -2190,6 +2157,43 @@ impl OwnedStr for ~str {\n             raw::set_len(self, new_len);\n         }\n     }\n+    /**\n+     * Remove the final character from a string and return it\n+     *\n+     * # Failure\n+     *\n+     * If the string does not contain any characters\n+     */\n+    fn pop_char(&mut self) -> char {\n+        let end = self.len();\n+        assert!(end > 0u);\n+        let CharRange {ch, next} = self.char_range_at_reverse(end);\n+        unsafe { raw::set_len(self, next); }\n+        return ch;\n+    }\n+\n+    /**\n+     * Remove the first character from a string and return it\n+     *\n+     * # Failure\n+     *\n+     * If the string does not contain any characters\n+     */\n+    fn shift_char(&mut self) -> char {\n+        let CharRange {ch, next} = self.char_range_at(0u);\n+        *self = unsafe { raw::slice_bytes_owned(*self, next, self.len()) };\n+        return ch;\n+    }\n+\n+    /// Prepend a char to a string\n+    fn unshift_char(&mut self, ch: char) {\n+        // This could be more efficient.\n+        let mut new_str = ~\"\";\n+        new_str.push_char(ch);\n+        new_str.push_str(*self);\n+        *self = new_str;\n+    }\n+\n     /// Concatenate two strings together.\n     #[inline]\n     fn append(&self, rhs: &str) -> ~str {\n@@ -2421,15 +2425,15 @@ mod tests {\n     #[test]\n     fn test_pop_char() {\n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let cc = pop_char(&mut data);\n+        let cc = data.pop_char();\n         assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n         assert_eq!('\u534e', cc);\n     }\n \n     #[test]\n     fn test_pop_char_2() {\n         let mut data2 = ~\"\u534e\";\n-        let cc2 = pop_char(&mut data2);\n+        let cc2 = data2.pop_char();\n         assert_eq!(~\"\", data2);\n         assert_eq!('\u534e', cc2);\n     }\n@@ -2439,7 +2443,29 @@ mod tests {\n     #[ignore(cfg(windows))]\n     fn test_pop_char_fail() {\n         let mut data = ~\"\";\n-        let _cc3 = pop_char(&mut data);\n+        let _cc3 = data.pop_char();\n+    }\n+\n+    #[test]\n+    fn test_push_char() {\n+        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+        data.push_char('\u534e');\n+        assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", data);\n+    }\n+\n+    #[test]\n+    fn test_shift_char() {\n+        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+        let cc = data.shift_char();\n+        assert_eq!(~\"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n+        assert_eq!('\u0e1b', cc);\n+    }\n+\n+    #[test]\n+    fn test_unshift_char() {\n+        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+        data.unshift_char('\u534e');\n+        assert_eq!(~\"\u534e\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n     }\n \n     #[test]"}, {"sha": "477f06a2be1958121da369f5c6dd96040d75ce5a", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ba4a4778cc17c64c33a891a0d2565a1fb04ddffc/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba4a4778cc17c64c33a891a0d2565a1fb04ddffc/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=ba4a4778cc17c64c33a891a0d2565a1fb04ddffc", "patch": "@@ -33,12 +33,12 @@ pub fn main() {\n     assert!((!str::is_utf8(~[0xc0_u8, 0x10_u8])));\n \n     let mut stack = ~\"a\u00d7c\u20ac\";\n-    assert_eq!(str::pop_char(&mut stack), '\u20ac');\n-    assert_eq!(str::pop_char(&mut stack), 'c');\n+    assert_eq!(stack.pop_char(), '\u20ac');\n+    assert_eq!(stack.pop_char(), 'c');\n     stack.push_char('u');\n     assert!(stack == ~\"a\u00d7u\");\n-    assert_eq!(str::shift_char(&mut stack), 'a');\n-    assert_eq!(str::shift_char(&mut stack), '\u00d7');\n-    str::unshift_char(&mut stack, '\u00df');\n+    assert_eq!(stack.shift_char(), 'a');\n+    assert_eq!(stack.shift_char(), '\u00d7');\n+    stack.unshift_char('\u00df');\n     assert!(stack == ~\"\u00dfu\");\n }"}]}