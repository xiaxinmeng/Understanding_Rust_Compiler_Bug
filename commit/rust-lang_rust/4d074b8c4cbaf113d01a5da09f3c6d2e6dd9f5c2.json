{"sha": "4d074b8c4cbaf113d01a5da09f3c6d2e6dd9f5c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMDc0YjhjNGNiYWYxMTNkMDFhNWRhMDlmM2M2ZDJlNmRkOWY1YzI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-01-26T15:11:41Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-01-26T15:17:54Z"}, "message": "Avoid redundant work for drop-glue translation items in trans::collector", "tree": {"sha": "e2db059d77c2b5969edc29c66138b73d2df1f00f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2db059d77c2b5969edc29c66138b73d2df1f00f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d074b8c4cbaf113d01a5da09f3c6d2e6dd9f5c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d074b8c4cbaf113d01a5da09f3c6d2e6dd9f5c2", "html_url": "https://github.com/rust-lang/rust/commit/4d074b8c4cbaf113d01a5da09f3c6d2e6dd9f5c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d074b8c4cbaf113d01a5da09f3c6d2e6dd9f5c2/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e969808e291cb85c6870972264b29708e33a531", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e969808e291cb85c6870972264b29708e33a531", "html_url": "https://github.com/rust-lang/rust/commit/9e969808e291cb85c6870972264b29708e33a531"}], "stats": {"total": 244, "additions": 109, "deletions": 135}, "files": [{"sha": "6ec73788598485566d1c1d0eb9e8267d308cdc5e", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 109, "deletions": 135, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/4d074b8c4cbaf113d01a5da09f3c6d2e6dd9f5c2/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d074b8c4cbaf113d01a5da09f3c6d2e6dd9f5c2/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=4d074b8c4cbaf113d01a5da09f3c6d2e6dd9f5c2", "patch": "@@ -350,14 +350,14 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     let recursion_depth_reset;\n \n     match starting_point {\n-        TransItem::DropGlue(_) |\n+        TransItem::DropGlue(t) => {\n+            find_drop_glue_neighbors(ccx, t, &mut neighbors);\n+            recursion_depth_reset = None;\n+        }\n         TransItem::Static(_) => {\n             recursion_depth_reset = None;\n         }\n-        TransItem::Fn {\n-            def_id,\n-            substs: ref param_substs\n-        } => {\n+        TransItem::Fn { def_id, substs: ref param_substs } => {\n             // Keep track of the monomorphization recursion depth\n             recursion_depth_reset = Some(check_recursion_limit(ccx,\n                                                                def_id,\n@@ -531,11 +531,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                       self.param_substs,\n                                                       &ty);\n             let ty = self.ccx.tcx().erase_regions(&ty);\n-\n-            create_drop_glue_trans_items(self.ccx,\n-                                         ty,\n-                                         self.param_substs,\n-                                         &mut self.output);\n+            let ty = glue::get_drop_glue_type(self.ccx, ty);\n+            self.output.push(TransItem::DropGlue(ty));\n         }\n \n         self.super_lvalue(lvalue, context);\n@@ -636,145 +633,124 @@ fn can_have_local_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     def_id.is_local() || ccx.sess().cstore.is_item_mir_available(def_id)\n }\n \n-fn create_drop_glue_trans_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                          mono_ty: ty::Ty<'tcx>,\n-                                          param_substs: &'tcx Substs<'tcx>,\n-                                          output: &mut Vec<TransItem<'tcx>>)\n+fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                      ty: ty::Ty<'tcx>,\n+                                      output: &mut Vec<TransItem<'tcx>>)\n {\n-    visit_types_of_owned_components(ccx,\n-                                    mono_ty,\n-                                    &mut FnvHashSet(),\n-                                    &mut |ty| {\n-        debug!(\"create_drop_glue_trans_items: {}\", type_to_string(ccx, ty));\n-        // Add a translation item for the drop glue, if even this type does not\n-        // need to be dropped (in which case it has been mapped to i8)\n-        output.push(TransItem::DropGlue(ty));\n-\n-        if glue::type_needs_drop(ccx.tcx(), ty) {\n-\n-            // Make sure the exchange_free_fn() lang-item gets translated if\n-            // there is a boxed value.\n-            if let ty::TyBox(_) = ty.sty {\n-\n-                let exchange_free_fn_def_id = ccx.tcx()\n-                                                 .lang_items\n-                                                 .require(ExchangeFreeFnLangItem)\n-                                                 .expect(\"Could not find ExchangeFreeFnLangItem\");\n-\n-                assert!(can_have_local_instance(ccx, exchange_free_fn_def_id));\n-                let exchange_free_fn_trans_item =\n-                    create_fn_trans_item(ccx,\n-                                         exchange_free_fn_def_id,\n-                                         &Substs::trans_empty(),\n-                                         param_substs);\n-\n-                output.push(exchange_free_fn_trans_item);\n-            }\n-\n-            // If the type implements Drop, also add a translation item for the\n-            // monomorphized Drop::drop() implementation.\n-            let destructor_did = match ty.sty {\n-                ty::TyStruct(def, _) |\n-                ty::TyEnum(def, _)   => def.destructor(),\n-                _ => None\n-            };\n-\n-            if let Some(destructor_did) = destructor_did {\n-                use rustc::middle::ty::ToPolyTraitRef;\n+    debug!(\"find_drop_glue_neighbors: {}\", type_to_string(ccx, ty));\n+\n+    // Make sure the exchange_free_fn() lang-item gets translated if\n+    // there is a boxed value.\n+    if let ty::TyBox(_) = ty.sty {\n+        let exchange_free_fn_def_id = ccx.tcx()\n+                                         .lang_items\n+                                         .require(ExchangeFreeFnLangItem)\n+                                         .expect(\"Could not find ExchangeFreeFnLangItem\");\n+\n+        assert!(can_have_local_instance(ccx, exchange_free_fn_def_id));\n+        let exchange_free_fn_trans_item =\n+            create_fn_trans_item(ccx,\n+                                 exchange_free_fn_def_id,\n+                                 &Substs::trans_empty(),\n+                                 &Substs::trans_empty());\n+\n+        output.push(exchange_free_fn_trans_item);\n+    }\n \n-                let drop_trait_def_id = ccx.tcx()\n-                                           .lang_items\n-                                           .drop_trait()\n-                                           .unwrap();\n+    // If the type implements Drop, also add a translation item for the\n+    // monomorphized Drop::drop() implementation.\n+    let destructor_did = match ty.sty {\n+        ty::TyStruct(def, _) |\n+        ty::TyEnum(def, _)   => def.destructor(),\n+        _ => None\n+    };\n \n-                let self_type_substs = ccx.tcx().mk_substs(\n-                    Substs::trans_empty().with_self_ty(ty));\n+    if let Some(destructor_did) = destructor_did {\n+        use rustc::middle::ty::ToPolyTraitRef;\n \n-                let trait_ref = ty::TraitRef {\n-                    def_id: drop_trait_def_id,\n-                    substs: self_type_substs,\n-                }.to_poly_trait_ref();\n+        let drop_trait_def_id = ccx.tcx()\n+                                   .lang_items\n+                                   .drop_trait()\n+                                   .unwrap();\n \n-                let substs = match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n-                    traits::VtableImpl(data) => data.substs,\n-                    _ => unreachable!()\n-                };\n-\n-                if can_have_local_instance(ccx, destructor_did) {\n-                    let trans_item = create_fn_trans_item(ccx,\n-                                                          destructor_did,\n-                                                          ccx.tcx().mk_substs(substs),\n-                                                          param_substs);\n-                    output.push(trans_item);\n-                }\n-            }\n+        let self_type_substs = ccx.tcx().mk_substs(\n+            Substs::trans_empty().with_self_ty(ty));\n \n-            true\n-        } else {\n-            false\n-        }\n-    });\n+        let trait_ref = ty::TraitRef {\n+            def_id: drop_trait_def_id,\n+            substs: self_type_substs,\n+        }.to_poly_trait_ref();\n \n-    fn visit_types_of_owned_components<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n-                                                    ty: ty::Ty<'tcx>,\n-                                                    visited: &mut FnvHashSet<ty::Ty<'tcx>>,\n-                                                    mut f: &mut F)\n-        where F: FnMut(ty::Ty<'tcx>) -> bool\n-    {\n-        let ty = glue::get_drop_glue_type(ccx, ty);\n+        let substs = match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+            traits::VtableImpl(data) => data.substs,\n+            _ => unreachable!()\n+        };\n \n-        if !visited.insert(ty) {\n-            return;\n+        if can_have_local_instance(ccx, destructor_did) {\n+            let trans_item = create_fn_trans_item(ccx,\n+                                                  destructor_did,\n+                                                  ccx.tcx().mk_substs(substs),\n+                                                  &Substs::trans_empty());\n+            output.push(trans_item);\n         }\n+    }\n \n-        if !f(ty) {\n-            // Don't recurse further\n-            return;\n+    // Finally add the types of nested values\n+    match ty.sty {\n+        ty::TyBool       |\n+        ty::TyChar       |\n+        ty::TyInt(_)     |\n+        ty::TyUint(_)    |\n+        ty::TyStr        |\n+        ty::TyFloat(_)   |\n+        ty::TyRawPtr(_)  |\n+        ty::TyRef(..)    |\n+        ty::TyBareFn(..) |\n+        ty::TySlice(_)   |\n+        ty::TyTrait(_)   => {\n+            /* nothing to do */\n         }\n-\n-        match ty.sty {\n-            ty::TyBool       |\n-            ty::TyChar       |\n-            ty::TyInt(_)     |\n-            ty::TyUint(_)    |\n-            ty::TyStr        |\n-            ty::TyFloat(_)   |\n-            ty::TyRawPtr(_)  |\n-            ty::TyRef(..)    |\n-            ty::TyBareFn(..) |\n-            ty::TySlice(_)   |\n-            ty::TyTrait(_)   => {\n-                /* nothing to do */\n-            }\n-            ty::TyStruct(ref adt_def, substs) |\n-            ty::TyEnum(ref adt_def, substs) => {\n-                for field in adt_def.all_fields() {\n-                    let field_type = monomorphize::apply_param_substs(ccx.tcx(),\n-                                                                      substs,\n-                                                                      &field.unsubst_ty());\n-                    visit_types_of_owned_components(ccx, field_type, visited, f);\n+        ty::TyStruct(ref adt_def, substs) |\n+        ty::TyEnum(ref adt_def, substs) => {\n+            for field in adt_def.all_fields() {\n+                let field_type = monomorphize::apply_param_substs(ccx.tcx(),\n+                                                                  substs,\n+                                                                  &field.unsubst_ty());\n+                let field_type = glue::get_drop_glue_type(ccx, field_type);\n+\n+                if glue::type_needs_drop(ccx.tcx(), field_type) {\n+                    output.push(TransItem::DropGlue(field_type));\n                 }\n             }\n-            ty::TyClosure(_, ref substs) => {\n-                for upvar_ty in &substs.upvar_tys {\n-                    visit_types_of_owned_components(ccx, upvar_ty, visited, f);\n+        }\n+        ty::TyClosure(_, ref substs) => {\n+            for upvar_ty in &substs.upvar_tys {\n+                let upvar_ty = glue::get_drop_glue_type(ccx, upvar_ty);\n+                if glue::type_needs_drop(ccx.tcx(), upvar_ty) {\n+                    output.push(TransItem::DropGlue(upvar_ty));\n                 }\n             }\n-            ty::TyBox(inner_type)      |\n-            ty::TyArray(inner_type, _) => {\n-                visit_types_of_owned_components(ccx, inner_type, visited, f);\n+        }\n+        ty::TyBox(inner_type)      |\n+        ty::TyArray(inner_type, _) => {\n+            let inner_type = glue::get_drop_glue_type(ccx, inner_type);\n+            if glue::type_needs_drop(ccx.tcx(), inner_type) {\n+                output.push(TransItem::DropGlue(inner_type));\n             }\n-            ty::TyTuple(ref args) => {\n-                for arg in args {\n-                    visit_types_of_owned_components(ccx, arg, visited, f);\n+        }\n+        ty::TyTuple(ref args) => {\n+            for arg in args {\n+                let arg = glue::get_drop_glue_type(ccx, arg);\n+                if glue::type_needs_drop(ccx.tcx(), arg) {\n+                    output.push(TransItem::DropGlue(arg));\n                 }\n             }\n-            ty::TyProjection(_) |\n-            ty::TyParam(_)      |\n-            ty::TyInfer(_)      |\n-            ty::TyError         => {\n-                ccx.sess().bug(\"encountered unexpected type\");\n-            }\n+        }\n+        ty::TyProjection(_) |\n+        ty::TyParam(_)      |\n+        ty::TyInfer(_)      |\n+        ty::TyError         => {\n+            ccx.sess().bug(\"encountered unexpected type\");\n         }\n     }\n }\n@@ -1086,10 +1062,8 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                                                 self.ccx.tcx().map.local_def_id(item.id),\n                                                 None));\n \n-                        create_drop_glue_trans_items(self.ccx,\n-                                                     ty,\n-                                                     self.trans_empty_substs,\n-                                                     self.output);\n+                        let ty = glue::get_drop_glue_type(self.ccx, ty);\n+                        self.output.push(TransItem::DropGlue(ty));\n                     }\n                 }\n             }"}]}