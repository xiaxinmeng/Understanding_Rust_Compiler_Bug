{"sha": "aea537779e01359cf8da6944218362d44bfaee83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYTUzNzc3OWUwMTM1OWNmOGRhNjk0NDIxODM2MmQ0NGJmYWVlODM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-26T12:06:02Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-26T12:06:02Z"}, "message": "Remove all uses of tuples from the compiler and stdlib", "tree": {"sha": "235edf688d4fb4928ff766c063dcac779548f34d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/235edf688d4fb4928ff766c063dcac779548f34d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aea537779e01359cf8da6944218362d44bfaee83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aea537779e01359cf8da6944218362d44bfaee83", "html_url": "https://github.com/rust-lang/rust/commit/aea537779e01359cf8da6944218362d44bfaee83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aea537779e01359cf8da6944218362d44bfaee83/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e123366bffa69ee3877335b9ca979b0cc301d07c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e123366bffa69ee3877335b9ca979b0cc301d07c", "html_url": "https://github.com/rust-lang/rust/commit/e123366bffa69ee3877335b9ca979b0cc301d07c"}], "stats": {"total": 1482, "additions": 759, "deletions": 723}, "files": [{"sha": "9c26713a0d29bfc8ed504c53a76c3378a6bb1077", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -128,7 +128,7 @@ fn default_native_lib_naming(session::session sess, bool static) ->\n fn find_library_crate(&session::session sess, &ast::ident ident,\n                       &(@ast::meta_item)[] metas,\n                       &str[] library_search_paths)\n-        -> option::t[tup(str, @u8[])] {\n+        -> option::t[rec(str ident, @u8[] data)] {\n \n     attr::require_unique_names(sess, metas);\n \n@@ -161,8 +161,8 @@ fn find_library_crate(&session::session sess, &ast::ident ident,\n \n fn find_library_crate_aux(&rec(str prefix, str suffix) nn, str crate_name,\n                           &(@ast::meta_item)[] metas,\n-                          &str[] library_search_paths) ->\n-                          option::t[tup(str, @u8[])] {\n+                          &str[] library_search_paths)\n+    -> option::t[rec(str ident, @u8[] data)] {\n     let str prefix = nn.prefix + crate_name;\n     // FIXME: we could probably use a 'glob' function in std::fs but it will\n     // be much easier to write once the unsafe module knows more about FFI\n@@ -188,7 +188,7 @@ fn find_library_crate_aux(&rec(str prefix, str suffix) nn, str crate_name,\n                         cont;\n                     }\n                     log #fmt(\"found %s with matching metadata\", path);\n-                    ret some(tup(path, cvec));\n+                    ret some(rec(ident=path, data=cvec));\n                 }\n                 case (_) { }\n             }\n@@ -219,7 +219,8 @@ fn get_metadata_section(str filename) -> option::t[@u8[]] {\n \n fn load_library_crate(&session::session sess, span span,\n                       &ast::ident ident, &(@ast::meta_item)[] metas,\n-                      &str[] library_search_paths) -> tup(str, @u8[]) {\n+                      &str[] library_search_paths)\n+    -> rec(str ident, @u8[] data) {\n \n     alt (find_library_crate(sess, ident, metas, library_search_paths)) {\n         case (some(?t)) {\n@@ -237,8 +238,8 @@ fn resolve_crate(env e, ast::ident ident, (@ast::meta_item)[] metas,\n         auto cinfo = load_library_crate(e.sess, span, ident, metas,\n                                         e.library_search_paths);\n \n-        auto cfilename = cinfo._0;\n-        auto cdata = cinfo._1;\n+        auto cfilename = cinfo.ident;\n+        auto cdata = cinfo.data;\n \n         // Claim this crate number and cache it\n         auto cnum = e.next_crate_num;\n@@ -268,8 +269,8 @@ fn resolve_crate_deps(env e, &@u8[] cdata) -> cstore::cnum_map {\n     // numbers\n     auto cnum_map = new_int_hash[ast::crate_num]();\n     for (decoder::crate_dep dep in decoder::get_crate_deps(cdata)) {\n-        auto extrn_cnum = dep._0;\n-        auto cname = dep._1;\n+        auto extrn_cnum = dep.cnum;\n+        auto cname = dep.ident;\n         log #fmt(\"resolving dep %s\", cname);\n         if (e.crate_cache.contains_key(cname)) {\n             log \"already have it\";"}, {"sha": "3519c4ef43287b46802b4d9a94a5dc4536e98645", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -12,17 +12,13 @@ export get_tag_variants;\n export get_type;\n \n fn get_symbol(&cstore::cstore cstore, ast::def_id def) -> str {\n-    auto cnum = def._0;\n-    auto node_id = def._1;\n-    auto cdata = cstore::get_crate_data(cstore, cnum).data;\n-    ret decoder::get_symbol(cdata, node_id);\n+    auto cdata = cstore::get_crate_data(cstore, def.crate).data;\n+    ret decoder::get_symbol(cdata, def.node);\n }\n \n fn get_type_param_count(&cstore::cstore cstore, &ast::def_id def) -> uint {\n-    auto cnum = def._0;\n-    auto node_id = def._1;\n-    auto cdata = cstore::get_crate_data(cstore, cnum).data;\n-    ret decoder::get_type_param_count(cdata, node_id);\n+    auto cdata = cstore::get_crate_data(cstore, def.crate).data;\n+    ret decoder::get_type_param_count(cdata, def.node);\n }\n \n fn lookup_defs(&cstore::cstore cstore, ast::crate_num cnum,\n@@ -33,15 +29,15 @@ fn lookup_defs(&cstore::cstore cstore, ast::crate_num cnum,\n \n fn get_tag_variants(ty::ctxt tcx, ast::def_id def) -> ty::variant_info[] {\n     auto cstore = tcx.sess.get_cstore();\n-    auto cnum = def._0;\n+    auto cnum = def.crate;\n     auto cdata = cstore::get_crate_data(cstore, cnum).data;\n     auto resolver = bind translate_def_id(tcx.sess, cnum, _);\n     ret decoder::get_tag_variants(cdata, def, tcx, resolver)\n }\n \n fn get_type(ty::ctxt tcx, ast::def_id def) -> ty::ty_param_count_and_ty {\n     auto cstore = tcx.sess.get_cstore();\n-    auto cnum = def._0;\n+    auto cnum = def.crate;\n     auto cdata = cstore::get_crate_data(cstore, cnum).data;\n     auto resolver = bind translate_def_id(tcx.sess, cnum, _);\n     decoder::get_type(cdata, def, tcx, resolver)\n@@ -56,8 +52,8 @@ fn translate_def_id(&session::session sess,\n                     ast::crate_num searched_crate,\n                     &ast::def_id def_id) -> ast::def_id {\n \n-    auto ext_cnum = def_id._0;\n-    auto node_id = def_id._1;\n+    auto ext_cnum = def_id.crate;\n+    auto node_id = def_id.node;\n \n     assert searched_crate != ast::local_crate;\n     assert ext_cnum != ast::local_crate;\n@@ -72,7 +68,7 @@ fn translate_def_id(&session::session sess,\n         }\n     };\n \n-    ret tup(local_cnum, node_id);\n+    ret rec(crate=local_cnum, node=node_id);\n }\n \n // Local Variables:"}, {"sha": "875eeba6ce4e759d865d2209b2758ac3d4560778", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -78,8 +78,9 @@ fn have_crate_data(&cstore cstore, ast::crate_num cnum) -> bool {\n     ret p(cstore).metas.contains_key(cnum);\n }\n \n-iter iter_crate_data(&cstore cstore) -> @tup(ast::crate_num, crate_metadata) {\n-    for each (@tup(ast::crate_num, crate_metadata) kv\n+iter iter_crate_data(&cstore cstore)\n+    -> @rec(ast::crate_num key, crate_metadata val) {\n+    for each (@rec(ast::crate_num key, crate_metadata val) kv\n               in p(cstore).metas.items()) {\n         put kv;\n     }"}, {"sha": "90176a4c3e9be8b3d4fe1383b918668768fcdf22", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -102,8 +102,8 @@ fn item_type(&ebmlivec::doc item, ast::crate_num this_cnum,\n \n         // This item was defined in the crate we're searching if it's has the\n         // local crate number, otherwise we need to search a different crate\n-        if (external_def_id._0 == ast::local_crate) {\n-            ret tup(this_cnum, external_def_id._1);\n+        if (external_def_id.crate == ast::local_crate) {\n+            ret rec(crate=this_cnum, node=external_def_id.node);\n         } else {\n             ret extres(external_def_id);\n         }\n@@ -118,7 +118,7 @@ fn item_ty_param_count(&ebmlivec::doc item) -> uint {\n     let uint ty_param_count = 0u;\n     auto tp = tag_items_data_item_ty_param_count;\n     for each (ebmlivec::doc p in ebmlivec::tagged_docs(item, tp)) {\n-        ty_param_count = ebmlivec::vint_at(ebmlivec::doc_data(p), 0u)._0;\n+        ty_param_count = ebmlivec::vint_at(ebmlivec::doc_data(p), 0u).val;\n     }\n     ret ty_param_count;\n }\n@@ -129,7 +129,7 @@ fn tag_variant_ids(&ebmlivec::doc item,\n     auto v = tag_items_data_item_variant;\n     for each (ebmlivec::doc p in ebmlivec::tagged_docs(item, v)) {\n         auto ext = parse_def_id(ebmlivec::doc_data(p));\n-        ids += ~[tup(this_cnum, ext._1)];\n+        ids += ~[rec(crate=this_cnum, node=ext.node)];\n     }\n     ret ids;\n }\n@@ -162,9 +162,9 @@ fn lookup_defs(&@u8[] data, ast::crate_num cnum, &ast::ident[] path)\n // FIXME doesn't yet handle re-exported externals\n fn lookup_def(ast::crate_num cnum, @u8[] data, &ast::def_id did_)\n         -> ast::def {\n-    auto item = lookup_item(did_._1, data);\n+    auto item = lookup_item(did_.node, data);\n     auto kind_ch = item_kind(item);\n-    auto did = tup(cnum, did_._1);\n+    auto did = rec(crate=cnum, node=did_.node);\n     auto def =\n         alt (kind_ch as char) {\n             case ('c') { ast::def_const(did) }\n@@ -179,7 +179,7 @@ fn lookup_def(ast::crate_num cnum, @u8[] data, &ast::def_id did_)\n             case ('n') { ast::def_native_mod(did) }\n             case ('v') {\n                 auto tid = variant_tag_id(item);\n-                tid = tup(cnum, tid._1);\n+                tid = rec(crate=cnum, node=tid.node);\n                 ast::def_variant(tid, did)\n             }\n         };\n@@ -188,8 +188,8 @@ fn lookup_def(ast::crate_num cnum, @u8[] data, &ast::def_id did_)\n \n fn get_type(@u8[] data, ast::def_id def, &ty::ctxt tcx,\n             &external_resolver extres) -> ty::ty_param_count_and_ty {\n-    auto this_cnum = def._0;\n-    auto node_id = def._1;\n+    auto this_cnum = def.crate;\n+    auto node_id = def.node;\n     auto item = lookup_item(node_id, data);\n     auto t = item_type(item, this_cnum, tcx, extres);\n     auto tp_count;\n@@ -198,7 +198,7 @@ fn get_type(@u8[] data, ast::def_id def, &ty::ctxt tcx,\n     if (has_ty_params) {\n         tp_count = item_ty_param_count(item);\n     } else { tp_count = 0u; }\n-    ret tup(tp_count, t);\n+    ret rec(count=tp_count, ty=t);\n }\n \n fn get_type_param_count(@u8[] data, ast::node_id id) -> uint {\n@@ -212,15 +212,15 @@ fn get_symbol(@u8[] data, ast::node_id id) -> str {\n fn get_tag_variants(&@u8[] data, ast::def_id def,\n                     &ty::ctxt tcx,\n                     &external_resolver extres) -> ty::variant_info[] {\n-    auto external_crate_id = def._0;\n+    auto external_crate_id = def.crate;\n     auto data = cstore::get_crate_data(tcx.sess.get_cstore(),\n                                        external_crate_id).data;\n     auto items = ebmlivec::get_doc(ebmlivec::new_doc(data), tag_items);\n-    auto item = find_item(def._1, items);\n+    auto item = find_item(def.node, items);\n     let ty::variant_info[] infos = ~[];\n     auto variant_ids = tag_variant_ids(item, external_crate_id);\n     for (ast::def_id did in variant_ids) {\n-        auto item = find_item(did._1, items);\n+        auto item = find_item(did.node, items);\n         auto ctor_ty = item_type(item, external_crate_id, tcx, extres);\n         let ty::t[] arg_tys = ~[];\n         alt (ty::struct(tcx, ctor_ty)) {\n@@ -252,17 +252,17 @@ fn kind_has_type_params(u8 kind_ch) -> bool {\n         };\n }\n \n-fn read_path(&ebmlivec::doc d) -> tup(str, uint) {\n+fn read_path(&ebmlivec::doc d) -> rec(str path, uint pos) {\n     auto desc = ebmlivec::doc_data(d);\n     auto pos = ebmlivec::be_uint_from_bytes(@desc, 0u, 4u);\n     auto pathbytes = ivec::slice[u8](desc, 4u, ivec::len[u8](desc));\n     auto path = str::unsafe_from_bytes_ivec(pathbytes);\n-    ret tup(path, pos);\n+    ret rec(path=path, pos=pos);\n }\n \n fn describe_def(&ebmlivec::doc items, ast::def_id id) -> str {\n-    if (id._0 != 0) { ret \"external\"; }\n-    ret item_kind_to_str(item_kind(find_item(id._1, items)));\n+    if (id.crate != ast::local_crate) { ret \"external\"; }\n+    ret item_kind_to_str(item_kind(find_item(id.node, items)));\n }\n \n fn item_kind_to_str(u8 kind) -> str {\n@@ -349,7 +349,7 @@ fn get_crate_attributes(@u8[] data) -> ast::attribute[] {\n     ret get_attributes(ebmlivec::new_doc(data));\n }\n \n-type crate_dep = tup(ast::crate_num, str);\n+type crate_dep = rec(ast::crate_num cnum, str ident);\n \n fn get_crate_deps(@u8[] data) -> crate_dep[] {\n     let crate_dep[] deps = ~[];\n@@ -360,7 +360,7 @@ fn get_crate_deps(@u8[] data) -> crate_dep[] {\n               ebmlivec::tagged_docs(depsdoc, tag_crate_dep)) {\n         auto depname =\n             str::unsafe_from_bytes_ivec(ebmlivec::doc_data(depdoc));\n-        deps += ~[tup(crate_num, depname)];\n+        deps += ~[rec(cnum=crate_num, ident=depname)];\n         crate_num += 1;\n     }\n     ret deps;\n@@ -370,7 +370,7 @@ fn list_crate_deps(@u8[] data, ioivec::writer out) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n     for (crate_dep dep in get_crate_deps(data)) {\n-        out.write_str(#fmt(\"%d %s\\n\", dep._0, dep._1));\n+        out.write_str(#fmt(\"%d %s\\n\", dep.cnum, dep.ident));\n     }\n \n     out.write_str(\"\\n\");\n@@ -387,10 +387,10 @@ fn list_crate_items(&@u8[] bytes, &ebmlivec::doc md, ioivec::writer out) {\n         auto et = tag_index_buckets_bucket_elt;\n         for each (ebmlivec::doc elt in ebmlivec::tagged_docs(bucket, et)) {\n             auto data = read_path(elt);\n-            auto def = ebmlivec::doc_at(bytes, data._1);\n+            auto def = ebmlivec::doc_at(bytes, data.pos);\n             auto did_doc = ebmlivec::get_doc(def, tag_def_id);\n             auto did = parse_def_id(ebmlivec::doc_data(did_doc));\n-            out.write_str(#fmt(\"%s (%s)\\n\", data._0,\n+            out.write_str(#fmt(\"%s (%s)\\n\", data.path,\n                                describe_def(items, did)));\n         }\n     }"}, {"sha": "042ec6a9932c87124991b4c33733100a2319bd6f", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -37,9 +37,11 @@ fn encode_def_id(&ebmlivec::writer ebml_w, &def_id id) {\n     ebmlivec::end_tag(ebml_w);\n }\n \n+type entry[T] = rec(T val, uint pos);\n+\n fn encode_tag_variant_paths(&ebmlivec::writer ebml_w, &variant[] variants,\n                             &str[] path,\n-                            &mutable (tup(str, uint))[] index) {\n+                            &mutable (entry[str])[] index) {\n     for (variant variant in variants) {\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n@@ -50,14 +52,15 @@ fn encode_tag_variant_paths(&ebmlivec::writer ebml_w, &variant[] variants,\n }\n \n fn add_to_index(&ebmlivec::writer ebml_w, &str[] path,\n-                &mutable (tup(str, uint))[] index, &str name) {\n+                &mutable (entry[str])[] index, &str name) {\n     auto full_path = path + ~[name];\n-    index += ~[tup(str::connect_ivec(full_path, \"::\"), ebml_w.writer.tell())];\n+    index += ~[rec(val=str::connect_ivec(full_path, \"::\"),\n+                   pos=ebml_w.writer.tell())];\n }\n \n-fn encode_native_module_item_paths(&ebmlivec::writer ebml_w,\n-                                   &native_mod nmod, &str[] path,\n-                                   &mutable (tup(str, uint))[] index) {\n+fn encode_native_module_item_paths\n+    (&ebmlivec::writer ebml_w, &native_mod nmod, &str[] path,\n+     &mutable (entry[str])[] index) {\n     for (@native_item nitem in nmod.items) {\n         add_to_index(ebml_w, path, index, nitem.ident);\n         ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n@@ -69,7 +72,7 @@ fn encode_native_module_item_paths(&ebmlivec::writer ebml_w,\n \n fn encode_module_item_paths(&ebmlivec::writer ebml_w, &_mod module,\n                             &str[] path,\n-                            &mutable (tup(str, uint))[] index) {\n+                            &mutable (entry[str])[] index) {\n     for (@item it in module.items) {\n         if (!is_exported(it.ident, module)) { cont; }\n         alt (it.node) {\n@@ -149,8 +152,8 @@ fn encode_module_item_paths(&ebmlivec::writer ebml_w, &_mod module,\n }\n \n fn encode_item_paths(&ebmlivec::writer ebml_w, &@crate crate)\n-        -> (tup(str, uint))[] {\n-    let (tup(str, uint))[] index = ~[];\n+        -> (entry[str])[] {\n+    let (entry[str])[] index = ~[];\n     let str[] path = ~[];\n     ebmlivec::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n@@ -166,7 +169,7 @@ fn encode_kind(&ebmlivec::writer ebml_w, u8 c) {\n     ebmlivec::end_tag(ebml_w);\n }\n \n-fn def_to_str(&def_id did) -> str { ret #fmt(\"%d:%d\", did._0, did._1); }\n+fn def_to_str(&def_id did) -> str { ret #fmt(\"%d:%d\", did.crate, did.node); }\n \n fn encode_type_param_count(&ebmlivec::writer ebml_w, &ty_param[] tps) {\n     ebmlivec::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n@@ -212,10 +215,10 @@ fn encode_tag_id(&ebmlivec::writer ebml_w, &def_id id) {\n \n fn encode_tag_variant_info(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n                            node_id id, &variant[] variants,\n-                           &mutable (tup(int, uint))[] index,\n+                           &mutable (entry[int])[] index,\n                            &ty_param[] ty_params) {\n     for (variant variant in variants) {\n-        index += ~[tup(variant.node.id, ebml_w.writer.tell())];\n+        index += ~[rec(val=variant.node.id, pos=ebml_w.writer.tell())];\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_kind(ebml_w, 'v' as u8);\n@@ -232,7 +235,7 @@ fn encode_tag_variant_info(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n }\n \n fn encode_info_for_item(@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n-                        @item item, &mutable (tup(int, uint))[] index) {\n+                        @item item, &mutable (entry[int])[] index) {\n     alt (item.node) {\n         case (item_const(_, _)) {\n             ebmlivec::start_tag(ebml_w, tag_items_data_item);\n@@ -301,7 +304,7 @@ fn encode_info_for_item(@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n             encode_symbol(ecx, ebml_w, item.id);\n             ebmlivec::end_tag(ebml_w);\n \n-            index += ~[tup(ctor_id, ebml_w.writer.tell())];\n+            index += ~[rec(val=ctor_id, pos=ebml_w.writer.tell())];\n             ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'f' as u8);\n@@ -320,7 +323,7 @@ fn encode_info_for_item(@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n             encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n             ebmlivec::end_tag(ebml_w);\n \n-            index += ~[tup(ctor_id, ebml_w.writer.tell())];\n+            index += ~[rec(val=ctor_id, pos=ebml_w.writer.tell())];\n             ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'f' as u8);\n@@ -355,18 +358,18 @@ fn encode_info_for_native_item(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n }\n \n fn encode_info_for_items(&@encode_ctxt ecx, &ebmlivec::writer ebml_w)\n-        -> (tup(int, uint))[] {\n-    let (tup(int, uint))[] index = ~[];\n+        -> (entry[int])[] {\n+    let (entry[int])[] index = ~[];\n     ebmlivec::start_tag(ebml_w, tag_items_data);\n-    for each (@tup(node_id, middle::ast_map::ast_node) kvp in\n-              ecx.ccx.ast_map.items()) {\n-        alt (kvp._1) {\n+    for each (@rec(node_id key, middle::ast_map::ast_node val) kvp\n+              in ecx.ccx.ast_map.items()) {\n+        alt (kvp.val) {\n             case (middle::ast_map::node_item(?i)) {\n-                index += ~[tup(kvp._0, ebml_w.writer.tell())];\n+                index += ~[rec(val=kvp.key, pos=ebml_w.writer.tell())];\n                 encode_info_for_item(ecx, ebml_w, i, index);\n             }\n             case (middle::ast_map::node_native_item(?i)) {\n-                index += ~[tup(kvp._0, ebml_w.writer.tell())];\n+                index += ~[rec(val=kvp.key, pos=ebml_w.writer.tell())];\n                 encode_info_for_native_item(ecx, ebml_w, i);\n             }\n             case (_) {}\n@@ -379,35 +382,35 @@ fn encode_info_for_items(&@encode_ctxt ecx, &ebmlivec::writer ebml_w)\n \n // Path and definition ID indexing\n \n-fn create_index[T](&(tup(T, uint))[] index, fn(&T) -> uint  hash_fn)\n-        -> (@(tup(T, uint))[])[] {\n-    let (@mutable (tup(T,uint))[])[] buckets = ~[];\n+fn create_index[T](&(entry[T])[] index, fn(&T) -> uint  hash_fn)\n+        -> (@(entry[T])[])[] {\n+    let (@mutable (entry[T])[])[] buckets = ~[];\n     for each (uint i in uint::range(0u, 256u)) { buckets += ~[@mutable ~[]]; }\n-    for (tup(T, uint) elt in index) {\n-        auto h = hash_fn(elt._0);\n+    for (entry[T] elt in index) {\n+        auto h = hash_fn(elt.val);\n         *(buckets.(h % 256u)) += ~[elt];\n     }\n \n     auto buckets_frozen = ~[];\n-    for (@mutable (tup(T, uint))[] bucket in buckets) {\n+    for (@mutable (entry[T])[] bucket in buckets) {\n         buckets_frozen += ~[@*bucket];\n     }\n     ret buckets_frozen;\n }\n \n-fn encode_index[T](&ebmlivec::writer ebml_w, &(@(tup(T, uint))[])[] buckets,\n+fn encode_index[T](&ebmlivec::writer ebml_w, &(@(entry[T])[])[] buckets,\n                    fn(&ioivec::writer, &T)  write_fn) {\n     auto writer = ioivec::new_writer_(ebml_w.writer);\n     ebmlivec::start_tag(ebml_w, tag_index);\n     let uint[] bucket_locs = ~[];\n     ebmlivec::start_tag(ebml_w, tag_index_buckets);\n-    for (@(tup(T, uint))[] bucket in buckets) {\n+    for (@(entry[T])[] bucket in buckets) {\n         bucket_locs += ~[ebml_w.writer.tell()];\n         ebmlivec::start_tag(ebml_w, tag_index_buckets_bucket);\n-        for (tup(T, uint) elt in *bucket) {\n+        for (entry[T] elt in *bucket) {\n             ebmlivec::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n-            writer.write_be_uint(elt._1, 4u);\n-            write_fn(writer, elt._0);\n+            writer.write_be_uint(elt.pos, 4u);\n+            write_fn(writer, elt.val);\n             ebmlivec::end_tag(ebml_w);\n         }\n         ebmlivec::end_tag(ebml_w);\n@@ -527,28 +530,28 @@ fn synthesize_crate_attrs(&@encode_ctxt ecx,\n fn encode_crate_deps(&ebmlivec::writer ebml_w, &cstore::cstore cstore) {\n \n     fn get_ordered_names(&cstore::cstore cstore) -> str[] {\n-        type hashkv = @tup(crate_num, cstore::crate_metadata);\n-        type numname = tup(crate_num, str);\n+        type hashkv = @rec(crate_num key, cstore::crate_metadata val);\n+        type numname = rec(crate_num crate, str ident);\n \n         // Pull the cnums and names out of cstore\n         let numname[mutable] pairs = ~[mutable];\n         for each (hashkv hashkv in cstore::iter_crate_data(cstore)) {\n-            pairs += ~[mutable tup(hashkv._0, hashkv._1.name)];\n+            pairs += ~[mutable rec(crate=hashkv.key, ident=hashkv.val.name)];\n         }\n \n         // Sort by cnum\n-        fn lteq(&numname kv1, &numname kv2) -> bool { kv1._0 <= kv2._0 }\n+        fn lteq(&numname kv1, &numname kv2) -> bool { kv1.crate <= kv2.crate }\n         std::sort::ivector::quick_sort(lteq, pairs);\n \n         // Sanity-check the crate numbers\n         auto expected_cnum = 1;\n         for (numname n in pairs) {\n-            assert n._0 == expected_cnum;\n+            assert n.crate == expected_cnum;\n             expected_cnum += 1;\n         }\n \n         // Return just the names\n-        fn name(&numname kv) -> str { kv._1 }\n+        fn name(&numname kv) -> str { kv.ident }\n         // mutable -> immutable hack for ivec::map\n         auto immpairs = ivec::slice(pairs, 0u, ivec::len(pairs));\n         ret ivec::map(name, immpairs);"}, {"sha": "e4a79e08add27c3709e3b4c16c0e1db6e1287963", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -249,13 +249,13 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         }\n         case ('F') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_fn, func._0, func._1, func._2,\n-                          func._3);\n+            ret ty::mk_fn(st.tcx, ast::proto_fn, func.args, func.ty, func.cf,\n+                          func.cs);\n         }\n         case ('W') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_iter, func._0, func._1, func._2,\n-                          func._3);\n+            ret ty::mk_fn(st.tcx, ast::proto_iter, func.args, func.ty,\n+                          func.cf, func.cs);\n         }\n         case ('N') {\n             auto abi;\n@@ -267,7 +267,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n                 case ('s') { abi = ast::native_abi_x86stdcall; }\n             }\n             auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_native_fn(st.tcx, abi, func._0, func._1);\n+            ret ty::mk_native_fn(st.tcx, abi, func.args, func.ty);\n         }\n         case ('O') {\n             assert (next(st) as char == '[');\n@@ -286,10 +286,10 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n                 methods +=\n                     ~[rec(proto=proto,\n                           ident=name,\n-                          inputs=func._0,\n-                          output=func._1,\n-                          cf=func._2,\n-                          constrs=func._3)];\n+                          inputs=func.args,\n+                          output=func.ty,\n+                          cf=func.cf,\n+                          constrs=func.cs)];\n             }\n             st.pos += 1u;\n             ret ty::mk_obj(st.tcx, methods);\n@@ -314,12 +314,13 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n             assert (next(st) as char == ':');\n             auto len = parse_hex(st);\n             assert (next(st) as char == '#');\n-            alt (st.tcx.rcache.find(tup(st.crate, pos, len))) {\n+            alt (st.tcx.rcache.find(rec(cnum=st.crate, pos=pos, len=len))) {\n                 case (some(?tt)) { ret tt; }\n                 case (none) {\n                     auto ps = @rec(pos=pos, len=len with *st);\n                     auto tt = parse_ty(ps, sd);\n-                    st.tcx.rcache.insert(tup(st.crate, pos, len), tt);\n+                    st.tcx.rcache.insert(rec(cnum=st.crate, pos=pos, len=len),\n+                                         tt);\n                     ret tt;\n                 }\n             }\n@@ -385,7 +386,7 @@ fn parse_hex(@pstate st) -> uint {\n }\n \n fn parse_ty_fn(@pstate st, str_def sd) ->\n-   tup(ty::arg[], ty::t, ast::controlflow, (@ty::constr)[]) {\n+    rec(ty::arg[] args, ty::t ty, ast::controlflow cf, (@ty::constr)[] cs) {\n     assert (next(st) as char == '[');\n     let ty::arg[] inputs = ~[];\n     while (peek(st) as char != ']') {\n@@ -404,9 +405,12 @@ fn parse_ty_fn(@pstate st, str_def sd) ->\n     auto cs = parse_constrs(st, sd);\n     alt (parse_ty_or_bang(st, sd)) {\n         case (a_bang) {\n-            ret tup(inputs, ty::mk_bot(st.tcx), ast::noreturn, cs);\n+            ret rec(args=inputs, ty=ty::mk_bot(st.tcx),\n+                    cf=ast::noreturn, cs=cs);\n+        }\n+        case (a_ty(?t)) {\n+          ret rec(args=inputs, ty=t, cf=ast::return, cs=cs);\n         }\n-        case (a_ty(?t)) { ret tup(inputs, t, ast::return, cs); }\n     }\n }\n \n@@ -431,8 +435,8 @@ fn parse_def_id(&u8[] buf) -> ast::def_id {\n     for (u8 b in def_part) { def_part_vec += [b]; }\n \n     auto crate_num = uint::parse_buf(crate_part_vec, 10u) as int;\n-    auto def_id = uint::parse_buf(def_part_vec, 10u) as int;\n-    ret tup(crate_num, def_id);\n+    auto def_num = uint::parse_buf(def_part_vec, 10u) as int;\n+    ret rec(crate=crate_num, node=def_num);\n }\n \n //"}, {"sha": "632b18d26b139caca83636d139861eab92f08916", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -154,7 +154,7 @@ fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n     auto fty = ty::expr_ty(cx.tcx, f);\n     auto arg_ts = fty_args(cx, fty);\n     let node_id[] roots = ~[];\n-    let tup(uint, node_id)[] mut_roots = ~[];\n+    let rec(uint arg, node_id node)[] mut_roots = ~[];\n     let ty::t[] unsafe_ts = ~[];\n     let uint[] unsafe_t_offsets = ~[];\n     auto i = 0u;\n@@ -164,7 +164,7 @@ fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n             auto root = expr_root(cx, arg, false);\n             if (arg_t.mode == ty::mo_alias(true)) {\n                 alt (path_def_id(cx, arg)) {\n-                  some(?did) { mut_roots += ~[tup(i, did._1)]; }\n+                  some(?did) { mut_roots += ~[rec(arg=i, node=did.node)]; }\n                   _ {\n                     if (!mut_field(root.ds)) {\n                         auto m = \"passing a temporary value or \\\n@@ -175,7 +175,7 @@ fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n                 }\n             }\n             alt (path_def_id(cx, root.ex)) {\n-              some(?did) { roots += ~[did._1]; }\n+              some(?did) { roots += ~[did.node]; }\n               _ { }\n             }\n             alt (inner_mut(root.ds)) {\n@@ -221,11 +221,11 @@ fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n     }\n     // Ensure we're not passing a root by mutable alias.\n \n-    for (tup(uint, node_id) root in mut_roots) {\n+    for (rec(uint arg, node_id node) root in mut_roots) {\n         auto mut_alias_to_root = false;\n         auto mut_alias_to_root_count = 0u;\n         for (node_id r in roots) {\n-            if root._1 == r {\n+            if root.node == r {\n                 mut_alias_to_root_count += 1u;\n                 if mut_alias_to_root_count > 1u {\n                     mut_alias_to_root = true;\n@@ -235,7 +235,7 @@ fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n         }\n \n         if (mut_alias_to_root) {\n-            cx.tcx.sess.span_err(args.(root._0).span,\n+            cx.tcx.sess.span_err(args.(root.arg).span,\n                                  \"passing a mutable alias to a \\\n                  variable that roots another alias\");\n         }\n@@ -257,7 +257,7 @@ fn check_tail_call(&ctx cx, &@ast::expr call) {\n             alt (args.(i).node) {\n                 case (ast::expr_path(_)) {\n                     auto def = cx.tcx.def_map.get(args.(i).id);\n-                    auto dnum = ast::def_id_of_def(def)._1;\n+                    auto dnum = ast::def_id_of_def(def).node;\n                     alt (cx.local_map.find(dnum)) {\n                         case (some(arg(ast::alias(?mut)))) {\n                             if (mut_a && !mut) {\n@@ -286,7 +286,7 @@ fn check_alt(&ctx cx, &@ast::expr input, &ast::arm[] arms, &scope sc,\n     visit::visit_expr(input, sc, v);\n     auto root = expr_root(cx, input, true);\n     auto roots = alt (path_def_id(cx, root.ex)) {\n-      some(?did) { ~[did._1] }\n+      some(?did) { ~[did.node] }\n       _ { ~[] }\n     };\n     let ty::t[] forbidden_tp =\n@@ -350,7 +350,7 @@ fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::blk blk,\n     auto defnum = local.node.id;\n     auto root = expr_root(cx, seq, false);\n     auto root_def = alt (path_def_id(cx, root.ex)) {\n-      some(?did) { ~[did._1] }\n+      some(?did) { ~[did.node] }\n       _ { ~[] }\n     };\n     auto unsafe = alt (inner_mut(root.ds)) { some(?t) { ~[t] } _ { ~[] } };\n@@ -381,7 +381,7 @@ fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::node_id id,\n              bool assign, &scope sc) {\n     auto def = cx.tcx.def_map.get(id);\n     if (!def_is_local(def, true)) { ret; }\n-    auto my_defnum = ast::def_id_of_def(def)._1;\n+    auto my_defnum = ast::def_id_of_def(def).node;\n     auto var_t = ty::expr_ty(cx.tcx, ex);\n     for (restrict r in *sc) {\n         // excludes variables introduced since the alias was made\n@@ -400,7 +400,7 @@ fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::node_id id,\n fn check_lval(&@ctx cx, &@ast::expr dest, &scope sc, &vt[scope] v) {\n     alt (dest.node) {\n         case (ast::expr_path(?p)) {\n-            auto dnum = ast::def_id_of_def(cx.tcx.def_map.get(dest.id))._1;\n+            auto dnum = ast::def_id_of_def(cx.tcx.def_map.get(dest.id)).node;\n             if (is_immutable_alias(cx, sc, dnum)) {\n                 cx.tcx.sess.span_err(dest.span,\n                                      \"assigning to immutable alias\");\n@@ -488,15 +488,15 @@ fn test_scope(&ctx cx, &scope sc, &restrict r, &ast::path p) {\n         auto msg =\n             alt (prob) {\n                 case (overwritten(?sp, ?wpt)) {\n-                    tup(sp, \"overwriting \" + ast::path_name(wpt))\n+                    rec(span=sp, msg=\"overwriting \" + ast::path_name(wpt))\n                 }\n                 case (val_taken(?sp, ?vpt)) {\n-                    tup(sp, \"taking the value of \" + ast::path_name(vpt))\n+                    rec(span=sp, msg=\"taking the value of \" +\n+                        ast::path_name(vpt))\n                 }\n             };\n-        cx.tcx.sess.span_err(msg._0,\n-                             msg._1 + \" will invalidate alias \" +\n-                                 ast::path_name(p) + \", which is still used\");\n+        cx.tcx.sess.span_err(msg.span, msg.msg + \" will invalidate alias \" +\n+                             ast::path_name(p) + \", which is still used\");\n     }\n }\n "}, {"sha": "3e47cd0cec0182c0ea99189d9ef16f7b221ef6f2", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -91,23 +91,23 @@ fn new_smallintmap_adapter[K, V](fn(&K) -> uint key_idx,\n \n         fn rehash() { fail }\n \n-        iter items() -> @tup(K, V) {\n+        iter items() -> @rec(K key, V val) {\n             auto idx = 0u;\n             for (option::t[V] item in map.v) {\n                 alt (item) {\n                     case (option::some(?elt)) {\n                         auto value = elt;\n                         auto key = idx_key(idx);\n-                        put @tup(key, value);\n+                        put @rec(key=key, val=value);\n                     }\n                     case (option::none) { }\n                 }\n                 idx += 1u;\n             }\n         }\n         iter keys() -> K {\n-            for each (@tup(K, V) p in self.items()) {\n-                put p._0;\n+            for each (@rec(K key, V val) p in self.items()) {\n+                put p.key;\n             }\n         }\n     }"}, {"sha": "5d17bea86eab8df79d4afe8651fc47747b8c4d01", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -96,7 +96,7 @@ fn collect_freevars(&resolve::def_map def_map, &session::session sess,\n     auto defs = new_int_hash();\n     for (ast::node_id ref_id_ in e.refs) {\n         auto ref_id = ref_id_;\n-        auto def_id = ast::def_id_of_def(def_map.get(ref_id))._1;\n+        auto def_id = ast::def_id_of_def(def_map.get(ref_id)).node;\n         if !decls.contains_key(def_id) {\n             uses += ~[ref_id];\n             set_add(defs, def_id);\n@@ -172,7 +172,7 @@ fn def_lookup(&ty::ctxt tcx, ast::node_id f, ast::node_id id) ->\n       none { ret none; }\n       some(?d) {\n         auto did = ast::def_id_of_def(d);\n-        if is_freevar_of(tcx, did._1, f) {\n+        if is_freevar_of(tcx, did.node, f) {\n             ret some(ast::def_upvar(did, @d));\n         } else { ret some(d); }\n       }"}, {"sha": "eb9a52c2d53f00d12c9212f7ac8a65e2afb37699", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -66,23 +66,24 @@ tag import_state {\n              option::t[def]); /* module */\n }\n \n-type ext_hash = hashmap[tup(def_id, str, namespace), def];\n+type ext_hash = hashmap[rec(def_id did, str ident, namespace ns), def];\n \n fn new_ext_hash() -> ext_hash {\n-    fn hash(&tup(def_id, str, namespace) v) -> uint {\n-        ret str::hash(v._1) + util::common::hash_def(v._0) +\n-                alt (v._2) {\n+    type key = rec(def_id did, str ident, namespace ns);\n+    fn hash(&key v) -> uint {\n+        ret str::hash(v.ident) + util::common::hash_def(v.did) +\n+                alt (v.ns) {\n                     case (ns_value) { 1u }\n                     case (ns_type) { 2u }\n                     case (ns_module) { 3u }\n                 };\n     }\n-    fn eq(&tup(def_id, str, namespace) v1, &tup(def_id, str, namespace) v2) ->\n+    fn eq(&key v1, &key v2) ->\n        bool {\n-        ret util::common::def_eq(v1._0, v2._0) && str::eq(v1._1, v2._1) &&\n-                v1._2 == v2._2;\n+        ret util::common::def_eq(v1.did, v2.did) &&\n+            str::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n     }\n-    ret std::map::mk_hashmap[tup(def_id, str, namespace), def](hash, eq);\n+    ret std::map::mk_hashmap[key, def](hash, eq);\n }\n \n tag mod_index_entry {\n@@ -95,7 +96,7 @@ tag mod_index_entry {\n type mod_index = hashmap[ident, list[mod_index_entry]];\n \n // A tuple of an imported def and the import stmt that brung it\n-type glob_imp_def = tup(def, @ast::view_item);\n+type glob_imp_def = rec(def def, @ast::view_item item);\n \n type indexed_mod =\n     rec(option::t[ast::_mod] m,\n@@ -117,7 +118,7 @@ type env =\n         hashmap[ast::node_id, @indexed_mod] mod_map,\n         hashmap[def_id, ident[]] ext_map,\n         ext_hash ext_cache,\n-        mutable tup(str, scope)[] reported,\n+        mutable rec(str ident, scope sc)[] reported,\n         session sess);\n \n \n@@ -226,7 +227,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n                 auto imp = follow_import(*e, sc, path, vi.span);\n                 if (option::is_some(imp)) {\n                     find_mod(e, sc).glob_imports +=\n-                        ~[tup(option::get(imp), vi)];\n+                        ~[rec(def=option::get(imp), item=vi)];\n                 }\n             }\n             case (_) { }\n@@ -235,8 +236,9 @@ fn map_crate(&@env e, &@ast::crate c) {\n }\n \n fn resolve_imports(&env e) {\n-    for each (@tup(ast::node_id, import_state) it in e.imports.items()) {\n-        alt (it._1) {\n+    for each (@rec(ast::node_id key, import_state val) it\n+              in e.imports.items()) {\n+        alt (it.val) {\n             case (todo(?item, ?sc)) { resolve_import(e, item, sc); }\n             case (resolved(_, _, _)) { }\n         }\n@@ -437,7 +439,7 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc_in) {\n             name = _name;\n         }\n     }\n-    e.imports.insert(defid._1, resolving(it.span));\n+    e.imports.insert(defid.node, resolving(it.span));\n     auto n_idents = ivec::len(ids);\n     auto end_id = ids.(n_idents - 1u);\n     // Ignore the current scope if this import would shadow itself.\n@@ -448,15 +450,15 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc_in) {\n                  lookup_in_scope(e, sc, it.span, end_id, ns_value),\n                  lookup_in_scope(e, sc, it.span, end_id, ns_type),\n                  lookup_in_scope(e, sc, it.span, end_id, ns_module));\n-        remove_if_unresolved(e.imports, defid._1);\n+        remove_if_unresolved(e.imports, defid.node);\n     } else {\n         auto dcur = alt(lookup_in_scope(e, sc, it.span, ids.(0), ns_module)) {\n             case (some(?dcur)) {\n                 dcur\n             }\n             case (none) {\n                 unresolved_err(e, sc, it.span, ids.(0), ns_name(ns_module));\n-                remove_if_unresolved(e.imports, defid._1);\n+                remove_if_unresolved(e.imports, defid.node);\n                 ret () // FIXME (issue #521)\n             }\n         };\n@@ -470,7 +472,7 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc_in) {\n                                        outside),\n                          lookup_in_mod(e, dcur, it.span, end_id, ns_module,\n                                        outside));\n-                remove_if_unresolved(e.imports, defid._1);\n+                remove_if_unresolved(e.imports, defid.node);\n                 break;\n             } else {\n                 dcur = alt (lookup_in_mod(e, dcur, it.span, ids.(i),\n@@ -481,7 +483,7 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc_in) {\n                     case (none) {\n                         unresolved_err(e, sc, it.span, ids.(i),\n                                        ns_name(ns_module));\n-                        remove_if_unresolved(e.imports, defid._1);\n+                        remove_if_unresolved(e.imports, defid.node);\n                         ret () // FIXME (issue #521)\n                     }\n                 };\n@@ -495,7 +497,7 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc_in) {\n         if is_none(val) && is_none(typ) && is_none(md) {\n             unresolved_err(e, sc, sp, name, \"import\");\n         } else {\n-            e.imports.insert(defid._1, resolved(val, typ, md));\n+            e.imports.insert(defid.node, resolved(val, typ, md));\n         }\n     }\n     fn remove_if_unresolved(hashmap[ast::node_id, import_state] imports,\n@@ -542,10 +544,10 @@ fn unresolved_err(&env e, &scopes sc, &span sp, &ident name, &str kind) {\n         fail;\n     }\n     auto err_scope = find_fn_or_mod_scope(sc);\n-    for (tup(str, scope) rs in e.reported) {\n-        if str::eq(rs._0, name) && err_scope == rs._1 { ret; }\n+    for (rec(str ident, scope sc) rs in e.reported) {\n+        if str::eq(rs.ident, name) && err_scope == rs.sc { ret; }\n     }\n-    e.reported += ~[tup(name, err_scope)];\n+    e.reported += ~[rec(ident=name, sc=err_scope)];\n     e.sess.span_err(sp, mk_unresolved_msg(name, kind));\n }\n \n@@ -899,25 +901,26 @@ fn lookup_in_mod_strict(&env e, &scopes sc, def m, &span sp, &ident name,\n fn lookup_in_mod(&env e, &def m, &span sp, &ident name, namespace ns,\n                  dir dr) -> option::t[def] {\n     auto defid = ast::def_id_of_def(m);\n-    if (defid._0 != ast::local_crate) {\n+    if (defid.crate != ast::local_crate) {\n         // examining a module in an external crate\n \n-        auto cached = e.ext_cache.find(tup(defid, name, ns));\n+        auto cached = e.ext_cache.find(rec(did=defid, ident=name, ns=ns));\n         if (!is_none(cached)) { ret cached; }\n         auto path = ~[name];\n-        if (defid._1 != -1) { path = e.ext_map.get(defid) + path; }\n-        auto fnd = lookup_external(e, defid._0, path, ns);\n+        if (defid.node != -1) { path = e.ext_map.get(defid) + path; }\n+        auto fnd = lookup_external(e, defid.crate, path, ns);\n         if (!is_none(fnd)) {\n-            e.ext_cache.insert(tup(defid, name, ns), option::get(fnd));\n+            e.ext_cache.insert(rec(did=defid, ident=name, ns=ns),\n+                               option::get(fnd));\n         }\n         ret fnd;\n     }\n     alt (m) {\n         case (ast::def_mod(?defid)) {\n-            ret lookup_in_local_mod(e, defid._1, sp, name, ns, dr);\n+            ret lookup_in_local_mod(e, defid.node, sp, name, ns, dr);\n         }\n         case (ast::def_native_mod(?defid)) {\n-            ret lookup_in_local_native_mod(e, defid._1, sp, name, ns);\n+            ret lookup_in_local_native_mod(e, defid.node, sp, name, ns);\n         }\n     }\n }\n@@ -927,7 +930,7 @@ fn found_view_item(&env e, @ast::view_item vi, namespace ns) ->\n     alt (vi.node) {\n         case (ast::view_item_use(_, _, ?id)) {\n             auto cnum = cstore::get_use_stmt_cnum(e.cstore, id);\n-            ret some(ast::def_mod(tup(cnum, -1)));\n+            ret some(ast::def_mod(rec(crate=cnum, node=-1)));\n         }\n         case (ast::view_item_import(_, _, ?id)) {\n             ret lookup_import(e, local_def(id), ns);\n@@ -940,7 +943,7 @@ fn found_view_item(&env e, @ast::view_item vi, namespace ns) ->\n }\n \n fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n-    alt (e.imports.get(defid._1)) {\n+    alt (e.imports.get(defid.node)) {\n         case (todo(?item, ?sc)) {\n             resolve_import(e, item, sc);\n             ret lookup_import(e, defid, ns);\n@@ -1002,9 +1005,9 @@ fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, &ident id,\n         fn lookup_in_mod_(&env e, &glob_imp_def def, &span sp,\n                           &ident name, namespace ns,\n                           dir dr) -> option::t[glob_imp_def] {\n-            alt (lookup_in_mod(e, def._0, sp, name, ns, dr)) {\n+            alt (lookup_in_mod(e, def.def, sp, name, ns, dr)) {\n                 case (option::some(?d)) {\n-                    option::some(tup(d, def._1))\n+                    option::some(rec(def=d, item=def.item))\n                 }\n                 case (option::none) {\n                     option::none\n@@ -1016,12 +1019,12 @@ fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, &ident id,\n             ivec::filter_map(bind lookup_in_mod_(e, _, sp, id, ns, dr),\n                              { info.glob_imports });\n         if (ivec::len(matches) == 0u) {\n-            ret none[def];\n+            ret none;\n         } else if (ivec::len(matches) == 1u) {\n-            ret some[def](matches.(0)._0);\n+            ret some(matches.(0).def);\n         } else {\n             for (glob_imp_def match in matches) {\n-                auto sp = match._1.span;\n+                auto sp = match.item.span;\n                 e.sess.span_note(sp, #fmt(\"'%s' is imported here\", id));\n             }\n             e.sess.span_fatal(sp,\n@@ -1194,10 +1197,11 @@ fn check_for_collisions(&@env e, &ast::crate c) {\n     // Module indices make checking those relatively simple -- just check each\n     // name for multiple entities in the same namespace.\n \n-    for each (@tup(ast::node_id, @indexed_mod) m in e.mod_map.items()) {\n-        for each (@tup(ident, list[mod_index_entry]) name in\n-                 m._1.index.items()) {\n-            check_mod_name(*e, name._0, name._1);\n+    for each (@rec(ast::node_id key, @indexed_mod val) m\n+              in e.mod_map.items()) {\n+        for each (@rec(ident key, list[mod_index_entry] val) name\n+                  in m.val.index.items()) {\n+            check_mod_name(*e, name.key, name.val);\n         }\n     }\n     // Other scopes have to be checked the hard way."}, {"sha": "4331e2c569a4889c7c143911f7de38bb355ef8ac", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 106, "deletions": 104, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -313,18 +313,18 @@ fn type_of_arg(@local_ctxt cx, &span sp, &ty::arg arg) -> TypeRef {\n \n fn type_of_ty_param_count_and_ty(@local_ctxt lcx, &span sp,\n                                  &ty::ty_param_count_and_ty tpt) -> TypeRef {\n-    alt (ty::struct(lcx.ccx.tcx, tpt._1)) {\n+    alt (ty::struct(lcx.ccx.tcx, tpt.ty)) {\n         case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n             auto llfnty =\n-                type_of_fn(lcx.ccx, sp, proto, inputs, output, tpt._0);\n+                type_of_fn(lcx.ccx, sp, proto, inputs, output, tpt.count);\n             ret T_fn_pair(*lcx.ccx, llfnty);\n         }\n         case (_) {\n             // fall through\n \n         }\n     }\n-    ret type_of(lcx.ccx, sp, tpt._1);\n+    ret type_of(lcx.ccx, sp, tpt.ty);\n }\n \n fn type_of_or_i8(&@block_ctxt bcx, ty::t typ) -> TypeRef {\n@@ -365,7 +365,7 @@ fn log_fn_time(&@crate_ctxt ccx, str name, &time::timeval start,\n                &time::timeval end) {\n     auto elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.usec as int) - (start.usec as int)) / 1000;\n-    *ccx.stats.fn_times += ~[tup(name, elapsed)];\n+    *ccx.stats.fn_times += ~[rec(ident=name, time=elapsed)];\n }\n \n \n@@ -911,7 +911,8 @@ fn field_of_tydesc(&@block_ctxt cx, &ty::t t, bool escapes, int field) ->\n // each of the ty params it uses (from the current frame) and a vector of the\n // indices of the ty params present in the type. This is used solely for\n // constructing derived tydescs.\n-fn linearize_ty_params(&@block_ctxt cx, &ty::t t) -> tup(uint[], ValueRef[]) {\n+fn linearize_ty_params(&@block_ctxt cx, &ty::t t)\n+    -> rec(uint[] params, ValueRef[] descs) {\n     let ValueRef[] param_vals = ~[];\n     let uint[] param_defs = ~[];\n     type rr = rec(@block_ctxt cx,\n@@ -934,7 +935,7 @@ fn linearize_ty_params(&@block_ctxt cx, &ty::t t) -> tup(uint[], ValueRef[]) {\n     auto x = @rec(cx=cx, mutable vals=param_vals, mutable defs=param_defs);\n     auto f = bind linearizer(x, _);\n     ty::walk_ty(cx.fcx.lcx.ccx.tcx, f, t);\n-    ret tup(x.defs, x.vals);\n+    ret rec(params=x.defs, descs=x.vals);\n }\n \n fn trans_stack_local_derived_tydesc(&@block_ctxt cx, ValueRef llsz,\n@@ -971,9 +972,9 @@ fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n     auto bcx = new_raw_block_ctxt(cx.fcx, cx.fcx.llderivedtydescs);\n     let uint n_params = ty::count_ty_params(bcx.fcx.lcx.ccx.tcx, t);\n     auto tys = linearize_ty_params(bcx, t);\n-    assert (n_params == std::ivec::len[uint](tys._0));\n-    assert (n_params == std::ivec::len[ValueRef](tys._1));\n-    auto root_ti = get_static_tydesc(bcx, t, tys._0);\n+    assert (n_params == std::ivec::len[uint](tys.params));\n+    assert (n_params == std::ivec::len[ValueRef](tys.descs));\n+    auto root_ti = get_static_tydesc(bcx, t, tys.params);\n     static_ti = some[@tydesc_info](root_ti);\n     lazily_emit_all_tydesc_glue(cx, static_ti);\n     auto root = root_ti.tydesc;\n@@ -992,7 +993,7 @@ fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n         auto tdp = bcx.build.GEP(tydescs, ~[C_int(0), C_int(i)]);\n         bcx.build.Store(root, tdp);\n         i += 1;\n-        for (ValueRef td in tys._1) {\n+        for (ValueRef td in tys.descs) {\n             auto tdp = bcx.build.GEP(tydescs, ~[C_int(0), C_int(i)]);\n             bcx.build.Store(td, tdp);\n             i += 1;\n@@ -1011,7 +1012,7 @@ fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n             alloca(bcx,\n                    T_array(T_ptr(bcx.fcx.lcx.ccx.tydesc_type), n_params));\n         auto i = 0;\n-        for (ValueRef td in tys._1) {\n+        for (ValueRef td in tys.descs) {\n             auto tdp = bcx.build.GEP(llparamtydescs, ~[C_int(0), C_int(i)]);\n             bcx.build.Store(td, tdp);\n             i += 1;\n@@ -1211,10 +1212,11 @@ fn make_generic_glue(&@local_ctxt cx, &span sp, &ty::t t, ValueRef llfn,\n }\n \n fn emit_tydescs(&@crate_ctxt ccx) {\n-    for each (@tup(ty::t, @tydesc_info) pair in ccx.tydescs.items()) {\n+    for each (@rec(ty::t key, @tydesc_info val) pair\n+              in ccx.tydescs.items()) {\n         auto glue_fn_ty = T_ptr(T_glue_fn(*ccx));\n         auto cmp_fn_ty = T_ptr(T_cmp_glue_fn(*ccx));\n-        auto ti = pair._1;\n+        auto ti = pair.val;\n         auto copy_glue =\n             alt ({ ti.copy_glue }) {\n                 case (none) {\n@@ -1478,8 +1480,8 @@ fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n     auto val = GEP_tup_like(cx, tup_ty, rs, ~[0, 1]);\n     cx = val.bcx;\n     // Find and call the actual destructor.\n-    auto dtor_pair = if (did._0 == ast::local_crate) {\n-        alt (ccx.fn_pairs.find(did._1)) {\n+    auto dtor_pair = if (did.crate == ast::local_crate) {\n+        alt (ccx.fn_pairs.find(did.node)) {\n             case (some(?x)) { x }\n             case (_) { ccx.tcx.sess.bug(\"internal error in trans_res_drop\") }\n         }\n@@ -1620,14 +1622,12 @@ fn make_cmp_glue(&@block_ctxt cx, ValueRef lhs0, ValueRef rhs0, &ty::t t,\n             auto bcx;\n             if (ty::sequence_is_interior(cx.fcx.lcx.ccx.tcx, t)) {\n                 auto st = ty::sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n-                auto lad =\n-                    ivec::get_len_and_data(scx, lhs, st);\n-                bcx = lad._2;\n-                lhs_fill = lad._0;\n-                lad =\n-                    ivec::get_len_and_data(bcx, rhs, st);\n-                bcx = lad._2;\n-                rhs_fill = lad._0;\n+                auto lad = ivec::get_len_and_data(scx, lhs, st);\n+                bcx = lad.bcx;\n+                lhs_fill = lad.len;\n+                lad = ivec::get_len_and_data(bcx, rhs, st);\n+                bcx = lad.bcx;\n+                rhs_fill = lad.len;\n             } else {\n                 lhs_fill = vec_fill(scx, lhs);\n                 rhs_fill = vec_fill(scx, rhs);\n@@ -1914,13 +1914,13 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n         auto unit_sz = rs.val;\n         bcx = rs.bcx;\n         auto a_len_and_data = ivec::get_len_and_data(bcx, av, unit_ty);\n-        auto a_len = a_len_and_data._0;\n-        auto a_elem = a_len_and_data._1;\n-        bcx = a_len_and_data._2;\n+        auto a_len = a_len_and_data.len;\n+        auto a_elem = a_len_and_data.data;\n+        bcx = a_len_and_data.bcx;\n         auto b_len_and_data = ivec::get_len_and_data(bcx, bv, unit_ty);\n-        auto b_len = b_len_and_data._0;\n-        auto b_elem = b_len_and_data._1;\n-        bcx = b_len_and_data._2;\n+        auto b_len = b_len_and_data.len;\n+        auto b_elem = b_len_and_data.data;\n+        bcx = b_len_and_data.bcx;\n         // Calculate the last pointer address we want to handle.\n         // TODO: Optimize this when the size of the unit type is statically\n         // known to not use pointer casts, which tend to confuse LLVM.\n@@ -2190,9 +2190,9 @@ fn iter_sequence(@block_ctxt cx, ValueRef v, &ty::t t, &val_and_ty_fn f) ->\n             bcx = cx;\n         } else {\n             auto len_and_data_rslt = ivec::get_len_and_data(cx, v, elt_ty);\n-            len = len_and_data_rslt._0;\n-            p0 = len_and_data_rslt._1;\n-            bcx = len_and_data_rslt._2;\n+            len = len_and_data_rslt.len;\n+            p0 = len_and_data_rslt.data;\n+            bcx = len_and_data_rslt.bcx;\n         }\n \n         auto llunit_ty = type_of_or_i8(cx, elt_ty);\n@@ -2881,7 +2881,7 @@ mod ivec {\n     // Returns the length of an interior vector and a pointer to its first\n     // element, in that order.\n     fn get_len_and_data(&@block_ctxt bcx, ValueRef orig_v, ty::t unit_ty)\n-            -> tup(ValueRef, ValueRef, @block_ctxt) {\n+            -> rec(ValueRef len, ValueRef data, @block_ctxt bcx) {\n         // If this interior vector has dynamic size, we can't assume anything\n         // about the LLVM type of the value passed in, so we cast it to an\n         // opaque vector type.\n@@ -2953,7 +2953,7 @@ mod ivec {\n                               ~[stack_elem, zero_elem, heap_elem],\n                               ~[bcx.llbb, zero_len_cx.llbb,\n                                 nonzero_len_cx.llbb]);\n-        ret tup(len, elem, next_cx);\n+        ret rec(len=len, data=elem, bcx=next_cx);\n     }\n \n     // Returns a tuple consisting of a pointer to the newly-reserved space and\n@@ -3131,9 +3131,9 @@ mod ivec {\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, none);\n         auto rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n-        auto rhs_len = rhs_len_and_data._0;\n-        auto rhs_data = rhs_len_and_data._1;\n-        bcx = rhs_len_and_data._2;\n+        auto rhs_len = rhs_len_and_data.len;\n+        auto rhs_data = rhs_len_and_data.data;\n+        bcx = rhs_len_and_data.bcx;\n         rs = reserve_space(bcx, llunitty, lhs, rhs_len);\n         auto lhs_data = rs.val;\n         bcx = rs.bcx;\n@@ -3244,13 +3244,13 @@ mod ivec {\n         auto llunitty = type_of_or_i8(bcx, unit_ty);\n         auto llheappartty = T_ivec_heap_part(llunitty);\n         auto lhs_len_and_data = get_len_and_data(bcx, lhs, unit_ty);\n-        auto lhs_len = lhs_len_and_data._0;\n-        auto lhs_data = lhs_len_and_data._1;\n-        bcx = lhs_len_and_data._2;\n+        auto lhs_len = lhs_len_and_data.len;\n+        auto lhs_data = lhs_len_and_data.data;\n+        bcx = lhs_len_and_data.bcx;\n         auto rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n-        auto rhs_len = rhs_len_and_data._0;\n-        auto rhs_data = rhs_len_and_data._1;\n-        bcx = rhs_len_and_data._2;\n+        auto rhs_len = rhs_len_and_data.len;\n+        auto rhs_data = rhs_len_and_data.data;\n+        bcx = rhs_len_and_data.bcx;\n         auto lllen = bcx.build.Add(lhs_len, rhs_len);\n         // We have three cases to handle here:\n         // (1) Length is zero ([] + []).\n@@ -4053,10 +4053,10 @@ fn trans_external_path(&@block_ctxt cx, &ast::def_id did,\n fn lval_generic_fn(&@block_ctxt cx, &ty::ty_param_count_and_ty tpt,\n                    &ast::def_id fn_id, ast::node_id id) -> lval_result {\n     auto lv;\n-    if (fn_id._0 == ast::local_crate) {\n+    if (fn_id.crate == ast::local_crate) {\n         // Internal reference.\n-        assert (cx.fcx.lcx.ccx.fn_pairs.contains_key(fn_id._1));\n-        lv = lval_val(cx, cx.fcx.lcx.ccx.fn_pairs.get(fn_id._1));\n+        assert (cx.fcx.lcx.ccx.fn_pairs.contains_key(fn_id.node));\n+        lv = lval_val(cx, cx.fcx.lcx.ccx.fn_pairs.get(fn_id.node));\n     } else {\n         // External reference.\n         lv = lval_val(cx, trans_external_path(cx, fn_id, tpt));\n@@ -4075,7 +4075,7 @@ fn lval_generic_fn(&@block_ctxt cx, &ty::ty_param_count_and_ty tpt,\n             bcx = td.bcx;\n             tydescs += ~[td.val];\n         }\n-        auto gen = rec(item_type=tpt._1, static_tis=tis, tydescs=tydescs);\n+        auto gen = rec(item_type=tpt.ty, static_tis=tis, tydescs=tydescs);\n         lv = rec(res=rslt(bcx, lv.res.val), generic=some[generic_info](gen)\n                  with lv);\n     }\n@@ -4084,19 +4084,18 @@ fn lval_generic_fn(&@block_ctxt cx, &ty::ty_param_count_and_ty tpt,\n \n fn lookup_discriminant(&@local_ctxt lcx, &ast::def_id tid, &ast::def_id vid)\n    -> ValueRef {\n-    alt (lcx.ccx.discrims.find(vid._1)) {\n+    alt (lcx.ccx.discrims.find(vid.node)) {\n         case (none) {\n             // It's an external discriminant that we haven't seen yet.\n-\n-            assert (vid._0 != ast::local_crate);\n+            assert (vid.crate != ast::local_crate);\n             auto sym = csearch::get_symbol(lcx.ccx.sess.get_cstore(), vid);\n             auto gvar =\n                 llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), str::buf(sym));\n             llvm::LLVMSetLinkage(gvar,\n                                  lib::llvm::LLVMExternalLinkage as\n                                      llvm::Linkage);\n             llvm::LLVMSetGlobalConstant(gvar, True);\n-            lcx.ccx.discrims.insert(vid._1, gvar);\n+            lcx.ccx.discrims.insert(vid.node, gvar);\n             ret gvar;\n         }\n         case (some(?llval)) { ret llval; }\n@@ -4107,43 +4106,43 @@ fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n     auto ccx = cx.fcx.lcx.ccx;\n     alt (cx.fcx.lcx.ccx.tcx.def_map.find(id)) {\n         case (some(ast::def_arg(?did))) {\n-            alt (cx.fcx.llargs.find(did._1)) {\n+            alt (cx.fcx.llargs.find(did.node)) {\n                 case (none) {\n-                    assert (cx.fcx.llupvars.contains_key(did._1));\n-                    ret lval_mem(cx, cx.fcx.llupvars.get(did._1));\n+                    assert (cx.fcx.llupvars.contains_key(did.node));\n+                    ret lval_mem(cx, cx.fcx.llupvars.get(did.node));\n                 }\n                 case (some(?llval)) { ret lval_mem(cx, llval); }\n             }\n         }\n         case (some(ast::def_local(?did))) {\n-            alt (cx.fcx.lllocals.find(did._1)) {\n+            alt (cx.fcx.lllocals.find(did.node)) {\n                 case (none) {\n-                    assert (cx.fcx.llupvars.contains_key(did._1));\n-                    ret lval_mem(cx, cx.fcx.llupvars.get(did._1));\n+                    assert (cx.fcx.llupvars.contains_key(did.node));\n+                    ret lval_mem(cx, cx.fcx.llupvars.get(did.node));\n                 }\n                 case (some(?llval)) { ret lval_mem(cx, llval); }\n             }\n         }\n         case (some(ast::def_binding(?did))) {\n-            alt (cx.fcx.lllocals.find(did._1)) {\n+            alt (cx.fcx.lllocals.find(did.node)) {\n                 case (none) {\n-                    assert (cx.fcx.llupvars.contains_key(did._1));\n-                    ret lval_mem(cx, cx.fcx.llupvars.get(did._1));\n+                    assert (cx.fcx.llupvars.contains_key(did.node));\n+                    ret lval_mem(cx, cx.fcx.llupvars.get(did.node));\n                 }\n                 case (some(?llval)) { ret lval_mem(cx, llval); }\n             }\n         }\n         case (some(ast::def_obj_field(?did))) {\n-            assert (cx.fcx.llobjfields.contains_key(did._1));\n-            ret lval_mem(cx, cx.fcx.llobjfields.get(did._1));\n+            assert (cx.fcx.llobjfields.contains_key(did.node));\n+            ret lval_mem(cx, cx.fcx.llobjfields.get(did.node));\n         }\n         case (some(ast::def_fn(?did, _))) {\n             auto tyt = ty::lookup_item_type(ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, id);\n         }\n         case (some(ast::def_variant(?tid, ?vid))) {\n             auto v_tyt = ty::lookup_item_type(ccx.tcx, vid);\n-            alt (ty::struct(ccx.tcx, v_tyt._1)) {\n+            alt (ty::struct(ccx.tcx, v_tyt.ty)) {\n                 case (ty::ty_fn(_, _, _, _, _)) {\n                     // N-ary variant.\n \n@@ -4172,14 +4171,14 @@ fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n             }\n         }\n         case (some(ast::def_const(?did))) {\n-          if (did._0 == ast::local_crate) {\n-              assert (ccx.consts.contains_key(did._1));\n-              ret lval_mem(cx, ccx.consts.get(did._1));\n+          if (did.crate == ast::local_crate) {\n+              assert (ccx.consts.contains_key(did.node));\n+              ret lval_mem(cx, ccx.consts.get(did.node));\n           } else {\n               auto tp = ty::node_id_to_monotype(ccx.tcx, id);\n               ret lval_val(cx, load_if_immediate\n                            (cx, trans_external_path\n-                            (cx, did, tup(0u, tp)), tp));\n+                            (cx, did, rec(count=0u, ty=tp)), tp));\n           }\n         }\n         case (some(ast::def_native_fn(?did))) {\n@@ -4274,12 +4273,12 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base, &@ast::expr idx,\n     auto interior_len_and_data;\n     if (is_interior) {\n         auto rslt = ivec::get_len_and_data(bcx, v, unit_ty);\n-        interior_len_and_data = some(tup(rslt._0, rslt._1));\n-        bcx = rslt._2;\n+        interior_len_and_data = some(rec(len=rslt.len, data=rslt.data));\n+        bcx = rslt.bcx;\n     } else { interior_len_and_data = none; }\n     auto lim;\n     alt (interior_len_and_data) {\n-        case (some(?lad)) { lim = lad._0; }\n+        case (some(?lad)) { lim = lad.len; }\n         case (none) {\n             lim = bcx.build.GEP(v, ~[C_int(0), C_int(abi::vec_elt_fill)]);\n             lim = bcx.build.Load(lim);\n@@ -4294,7 +4293,7 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base, &@ast::expr idx,\n     trans_fail(fail_cx, some[span](sp), \"bounds check\");\n     auto body;\n     alt (interior_len_and_data) {\n-        case (some(?lad)) { body = lad._1; }\n+        case (some(?lad)) { body = lad.data; }\n         case (none) {\n             body =\n                 next_cx.build.GEP(v,\n@@ -4907,7 +4906,7 @@ fn trans_arg_expr(&@block_ctxt cx, &ty::arg arg, TypeRef lldestty0,\n fn trans_args(&@block_ctxt cx, ValueRef llenv, &option::t[ValueRef] llobj,\n               &option::t[generic_info] gen, &option::t[ValueRef] lliterbody,\n               &(@ast::expr)[] es, &ty::t fn_ty)\n-        -> tup(@block_ctxt, ValueRef[], ValueRef) {\n+        -> rec(@block_ctxt bcx, ValueRef[] args, ValueRef retslot) {\n     let ty::arg[] args = ty::ty_fn_args(cx.fcx.lcx.ccx.tcx, fn_ty);\n     let ValueRef[] llargs = ~[];\n     let ValueRef[] lltydescs = ~[];\n@@ -4919,7 +4918,7 @@ fn trans_args(&@block_ctxt cx, ValueRef llenv, &option::t[ValueRef] llobj,\n     if (bcx.build.is_terminated()) {\n         // This means an earlier arg was divergent.\n         // So this arg can't be evaluated.\n-        ret tup(bcx, ~[], C_nil());\n+        ret rec(bcx=bcx, args=~[], retslot=C_nil());\n     }\n \n     auto retty = ty::ty_fn_ret(cx.fcx.lcx.ccx.tcx, fn_ty);\n@@ -4994,7 +4993,7 @@ fn trans_args(&@block_ctxt cx, ValueRef llenv, &option::t[ValueRef] llobj,\n         llargs += ~[r.val];\n         i += 1u;\n     }\n-    ret tup(bcx, llargs, llretslot);\n+    ret rec(bcx=bcx, args=llargs, retslot=llretslot);\n }\n \n fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n@@ -5045,9 +5044,9 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n     auto args_res =\n         trans_args(bcx, llenv, f_res.llobj, f_res.generic,\n                    lliterbody, args, fn_ty);\n-    bcx = args_res._0;\n-    auto llargs = args_res._1;\n-    auto llretslot = args_res._2;\n+    bcx = args_res.bcx;\n+    auto llargs = args_res.args;\n+    auto llretslot = args_res.retslot;\n     /*\n     log \"calling: \" + val_str(cx.fcx.lcx.ccx.tn, faddr);\n \n@@ -6416,11 +6415,12 @@ fn new_local_ctxt(&@crate_ctxt ccx) -> @local_ctxt {\n // Creates the standard quartet of basic blocks: static allocas, copy args,\n // derived tydescs, and dynamic allocas.\n fn mk_standard_basic_blocks(ValueRef llfn) ->\n-   tup(BasicBlockRef, BasicBlockRef, BasicBlockRef, BasicBlockRef) {\n-    ret tup(llvm::LLVMAppendBasicBlock(llfn, str::buf(\"static_allocas\")),\n-            llvm::LLVMAppendBasicBlock(llfn, str::buf(\"copy_args\")),\n-            llvm::LLVMAppendBasicBlock(llfn, str::buf(\"derived_tydescs\")),\n-            llvm::LLVMAppendBasicBlock(llfn, str::buf(\"dynamic_allocas\")));\n+    rec(BasicBlockRef sa, BasicBlockRef ca,\n+        BasicBlockRef dt, BasicBlockRef da) {\n+    ret rec(sa=llvm::LLVMAppendBasicBlock(llfn, str::buf(\"static_allocas\")),\n+            ca=llvm::LLVMAppendBasicBlock(llfn, str::buf(\"copy_args\")),\n+            dt=llvm::LLVMAppendBasicBlock(llfn, str::buf(\"derived_tydescs\")),\n+            da=llvm::LLVMAppendBasicBlock(llfn, str::buf(\"dynamic_allocas\")));\n }\n \n \n@@ -6446,11 +6446,11 @@ fn new_fn_ctxt(@local_ctxt cx, &span sp, ValueRef llfndecl) -> @fn_ctxt {\n              lltaskptr=lltaskptr,\n              llenv=llenv,\n              llretptr=llretptr,\n-             mutable llstaticallocas=llbbs._0,\n-             mutable llcopyargs=llbbs._1,\n-             mutable llderivedtydescs_first=llbbs._2,\n-             mutable llderivedtydescs=llbbs._2,\n-             mutable lldynamicallocas=llbbs._3,\n+             mutable llstaticallocas=llbbs.sa,\n+             mutable llcopyargs=llbbs.ca,\n+             mutable llderivedtydescs_first=llbbs.dt,\n+             mutable llderivedtydescs=llbbs.dt,\n+             mutable lldynamicallocas=llbbs.da,\n              mutable llself=none[val_self_pair],\n              mutable lliterbody=none[ValueRef],\n              llargs=llargs,\n@@ -7788,8 +7788,8 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, &str[] path, str name,\n     fn trans_simple_native_abi(&@block_ctxt bcx, str name,\n                                &mutable ValueRef[] call_args,\n                                ty::t fn_type, uint first_arg_n,\n-                               bool uses_retptr, uint cc) ->\n-       tup(ValueRef, ValueRef) {\n+                               bool uses_retptr, uint cc)\n+        -> rec(ValueRef val, ValueRef rptr) {\n         let TypeRef[] call_arg_tys = ~[];\n         for (ValueRef arg in call_args) { call_arg_tys += ~[val_ty(arg)]; }\n \n@@ -7812,13 +7812,13 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, &str[] path, str name,\n             bcx.build.CallWithConv(llnativefn, call_args, cc)\n         };\n         auto rptr = bcx.fcx.llretptr;\n-        ret tup(r, rptr);\n+        ret rec(val=r, rptr=rptr);\n     }\n \n     auto args = ty::ty_fn_args(ccx.tcx, fn_type);\n     // Build up the list of arguments.\n \n-    let (tup(ValueRef, ty::t))[] drop_args = ~[];\n+    let (rec(ValueRef val, ty::t ty))[] drop_args = ~[];\n     auto i = arg_n;\n     for (ty::arg arg in args) {\n         auto llarg = llvm::LLVMGetParam(fcx.llfn, i);\n@@ -7829,7 +7829,9 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, &str[] path, str name,\n         } else {\n             call_args += ~[llarg];\n         }\n-        if (arg.mode == ty::mo_val) { drop_args += ~[tup(llarg, arg.ty)]; }\n+        if (arg.mode == ty::mo_val) {\n+            drop_args += ~[rec(val=llarg, ty=arg.ty)];\n+        }\n         i += 1u;\n     }\n     auto r;\n@@ -7840,25 +7842,25 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, &str[] path, str name,\n                 trans_simple_native_abi(bcx, name, call_args, fn_type, arg_n,\n                                         uses_retptr,\n                                         lib::llvm::LLVMCCallConv);\n-            r = result._0;\n-            rptr = result._1;\n+            r = result.val;\n+            rptr = result.rptr;\n         }\n         case (ast::native_abi_rust_intrinsic) {\n             auto external_name = \"rust_intrinsic_\" + name;\n             auto result =\n                 trans_simple_native_abi(bcx, external_name, call_args,\n                                         fn_type, arg_n, uses_retptr,\n                                         lib::llvm::LLVMCCallConv);\n-            r = result._0;\n-            rptr = result._1;\n+            r = result.val;\n+            rptr = result.rptr;\n         }\n         case (ast::native_abi_x86stdcall) {\n             auto result =\n                 trans_simple_native_abi(bcx, name, call_args, fn_type, arg_n,\n                                         uses_retptr,\n                                         lib::llvm::LLVMX86StdcallCallConv);\n-            r = result._0;\n-            rptr = result._1;\n+            r = result.val;\n+            rptr = result.rptr;\n         }\n         case (_) {\n             r =\n@@ -7874,8 +7876,8 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, &str[] path, str name,\n \n     if (!rty_is_nil && !uses_retptr) { bcx.build.Store(r, rptr); }\n \n-    for (tup(ValueRef, ty::t) d in drop_args) {\n-        bcx = drop_ty(bcx, d._0, d._1).bcx;\n+    for (rec(ValueRef val, ty::t ty) d in drop_args) {\n+        bcx = drop_ty(bcx, d.val, d.ty).bcx;\n     }\n     bcx.build.RetVoid();\n     finish_fn(fcx, lltop);\n@@ -8130,8 +8132,8 @@ fn create_module_map(&@crate_ctxt ccx) -> ValueRef {\n                          lib::llvm::LLVMInternalLinkage as\n                          llvm::Linkage);\n     let ValueRef[] elts = ~[];\n-    for each (@tup(str, ValueRef) item in ccx.module_data.items()) {\n-        auto elt = C_struct(~[p2i(C_cstr(ccx, item._0)), p2i(item._1)]);\n+    for each (@rec(str key, ValueRef val) item in ccx.module_data.items()) {\n+        auto elt = C_struct(~[p2i(C_cstr(ccx, item.key)), p2i(item.val)]);\n         elts += ~[elt];\n     }\n     auto term = C_struct(~[C_int(0), C_int(0)]);\n@@ -8271,8 +8273,8 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n         log_err #fmt(\"n_null_glues: %u\", ccx.stats.n_null_glues);\n         log_err #fmt(\"n_real_glues: %u\", ccx.stats.n_real_glues);\n \n-        for (tup(str,int) timing in *ccx.stats.fn_times) {\n-            log_err #fmt(\"time: %s took %d ms\", timing._0, timing._1);\n+        for (rec(str ident, int time) timing in *ccx.stats.fn_times) {\n+            log_err #fmt(\"time: %s took %d ms\", timing.ident, timing.time);\n         }\n     }\n     ret llmod;"}, {"sha": "f88ec69c09baf59259aa0c56c46207a936f03be4", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -23,7 +23,7 @@ import trans_common::*;\n // An option identifying a branch (either a literal or a tag variant)\n tag opt {\n     lit(@ast::lit);\n-    var(uint /* variant id */, tup(def_id, def_id) /* variant def ids */);\n+    var(uint /* variant id */, rec(def_id tg, def_id var) /* variant dids */);\n }\n fn opt_eq(&opt a, &opt b) -> bool {\n     alt (a) {\n@@ -44,16 +44,16 @@ fn trans_opt(&@block_ctxt bcx, &opt o) -> result {\n \n fn variant_opt(&@crate_ctxt ccx, ast::node_id pat_id) -> opt {\n     auto vdef = ast::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n-    auto variants = ty::tag_variants(ccx.tcx, vdef._0);\n+    auto variants = ty::tag_variants(ccx.tcx, vdef.tg);\n     auto i = 0u;\n     for (ty::variant_info v in variants) {\n-        if (vdef._1 == v.id) { ret var(i, vdef); }\n+        if (vdef.var == v.id) { ret var(i, vdef); }\n         i += 1u;\n     }\n     fail;\n }\n \n-type bind_map = tup(ast::ident, ValueRef)[];\n+type bind_map = rec(ast::ident ident, ValueRef val)[];\n type match_branch = @rec((@ast::pat)[] pats,\n                          BasicBlockRef body,\n                          mutable bind_map bound);\n@@ -72,7 +72,7 @@ fn matches_always(&@ast::pat p) -> bool {\n fn bind_for_pat(&@ast::pat p, &match_branch br, ValueRef val) {\n     alt p.node {\n         ast::pat_bind(?name) {\n-            br.bound += ~[tup(name, val)];\n+            br.bound += ~[rec(ident=name, val=val)];\n         }\n         _ {}\n     }\n@@ -184,29 +184,29 @@ fn get_options(&@crate_ctxt ccx, &match m, uint col) -> opt[] {\n }\n \n fn extract_variant_args(@block_ctxt bcx, ast::node_id pat_id,\n-                        &tup(def_id, def_id) vdefs, ValueRef val)\n-    -> tup(ValueRef[], @block_ctxt) {\n+                        &rec(def_id tg, def_id var) vdefs, ValueRef val)\n+    -> rec(ValueRef[] vals, @block_ctxt bcx) {\n     auto ccx = bcx.fcx.lcx.ccx;\n     auto ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n     auto blobptr = val;\n-    auto variants = ty::tag_variants(ccx.tcx, vdefs._0);\n+    auto variants = ty::tag_variants(ccx.tcx, vdefs.tg);\n     auto args = ~[];\n     auto size = ivec::len(ty::tag_variant_with_id\n-                          (ccx.tcx, vdefs._0, vdefs._1).args);\n+                          (ccx.tcx, vdefs.tg, vdefs.var).args);\n     if (size > 0u && ivec::len(variants) != 1u) {\n         auto tagptr = bcx.build.PointerCast\n             (val, trans_common::T_opaque_tag_ptr(ccx.tn));\n         blobptr = bcx.build.GEP(tagptr, ~[C_int(0), C_int(1)]);\n     }\n     auto i = 0u;\n     while (i < size) {\n-        auto r = trans::GEP_tag(bcx, blobptr, vdefs._0, vdefs._1,\n+        auto r = trans::GEP_tag(bcx, blobptr, vdefs.tg, vdefs.var,\n                                 ty_param_substs, i as int);\n         bcx = r.bcx;\n         args += ~[r.val];\n         i += 1u;\n     }\n-    ret tup(args, bcx);\n+    ret rec(vals=args, bcx=bcx);\n }\n \n fn collect_record_fields(&match m, uint col) -> ast::ident[] {\n@@ -305,7 +305,7 @@ fn compile_submatch(@block_ctxt bcx, &match m, ValueRef[] vals, &mk_fail f,\n     if (ivec::len(opts) > 0u) {\n         alt (opts.(0)) {\n             var(_, ?vdef) {\n-                if (ivec::len(ty::tag_variants(ccx.tcx, vdef._0)) == 1u) {\n+                if (ivec::len(ty::tag_variants(ccx.tcx, vdef.tg)) == 1u) {\n                     kind = single;\n                 } else {\n                     auto tagptr = bcx.build.PointerCast\n@@ -359,9 +359,9 @@ fn compile_submatch(@block_ctxt bcx, &match m, ValueRef[] vals, &mk_fail f,\n         alt opt {\n              var(_, ?vdef) {\n                  auto args = extract_variant_args(opt_cx, pat_id, vdef, val);\n-                 size = ivec::len(args._0);\n-                 unpacked = args._0;\n-                 opt_cx = args._1;\n+                 size = ivec::len(args.vals);\n+                 unpacked = args.vals;\n+                 opt_cx = args.bcx;\n              }\n              lit(_) { }\n         }\n@@ -380,21 +380,23 @@ fn compile_submatch(@block_ctxt bcx, &match m, ValueRef[] vals, &mk_fail f,\n // Returns false for unreachable blocks\n fn make_phi_bindings(&@block_ctxt bcx, &exit_node[] map,\n                      &ast::pat_id_map ids) -> bool {\n-    fn assoc(str key, &tup(str, ValueRef)[] list) -> option::t[ValueRef] {\n-        for (tup(str, ValueRef) elt in list) {\n-            if (str::eq(elt._0, key)) { ret some(elt._1); }\n+    fn assoc(str key, &bind_map list)\n+        -> option::t[ValueRef] {\n+        for (rec(ast::ident ident, ValueRef val) elt in list) {\n+            if (str::eq(elt.ident, key)) { ret some(elt.val); }\n         }\n         ret none;\n     }\n \n     auto our_block = bcx.llbb as uint;\n     auto success = true;\n-    for each (@tup(ast::ident, ast::node_id) item in ids.items()) {\n+    for each (@rec(ast::ident key, ast::node_id val) item\n+              in ids.items()) {\n         auto llbbs = ~[];\n         auto vals = ~[];\n         for (exit_node ex in map) {\n             if (ex.to as uint == our_block) {\n-                alt (assoc(item._0, ex.bound)) {\n+                alt (assoc(item.key, ex.bound)) {\n                     some(?val) {\n                         llbbs += ~[ex.from];\n                         vals += ~[val];\n@@ -405,7 +407,7 @@ fn make_phi_bindings(&@block_ctxt bcx, &exit_node[] map,\n         }\n         if (ivec::len(vals) > 0u) {\n             auto phi = bcx.build.Phi(val_ty(vals.(0)), vals, llbbs);\n-            bcx.fcx.lllocals.insert(item._1, phi);\n+            bcx.fcx.lllocals.insert(item.val, phi);\n         } else { success = false; }\n     }\n     ret success;"}, {"sha": "5df95fd0a107a633246fe85b574271ac7a411554", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -101,7 +101,7 @@ type stats =\n         mutable uint n_glues_created,\n         mutable uint n_null_glues,\n         mutable uint n_real_glues,\n-        @mutable (tup(str,int)[]) fn_times);\n+        @mutable (rec(str ident, int time)[]) fn_times);\n \n // Crate context.  Every crate we compile has one of these.\n type crate_ctxt ="}, {"sha": "331b7d9f14846132090a481dd7ac6b29103f2357", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -234,7 +234,7 @@ fn malloc(&@block_ctxt bcx, ValueRef lldest, heap heap,\n // If the supplied destination is an alias, spills to a temporary. Returns the\n // new destination.\n fn spill_alias(&@block_ctxt cx, &dest dest, ty::t t)\n-        -> tup(@block_ctxt, dest) {\n+        -> rec(@block_ctxt bcx, dest dest) {\n     auto bcx = cx;\n     alt (dest) {\n       dst_alias(?box) {\n@@ -243,22 +243,22 @@ fn spill_alias(&@block_ctxt cx, &dest dest, ty::t t)\n         auto r = trans::alloc_ty(cx, t);\n         bcx = r.bcx; auto llptr = r.val;\n         *box = some(llptr);\n-        ret tup(bcx, dst_move(llptr));\n+        ret rec(bcx=bcx, dest=dst_move(llptr));\n       }\n-      _ { ret tup(bcx, dest); }\n+      _ { ret rec(bcx=bcx, dest=dest); }\n     }\n }\n \n-fn mk_temp(&@block_ctxt cx, ty::t t) -> tup(@block_ctxt, dest) {\n+fn mk_temp(&@block_ctxt cx, ty::t t) -> rec(@block_ctxt bcx, dest dest) {\n     auto bcx = cx;\n-    if ty::type_is_nil(bcx_tcx(bcx), t) { ret tup(bcx, dst_nil); }\n+    if ty::type_is_nil(bcx_tcx(bcx), t) { ret rec(bcx=bcx, dest=dst_nil); }\n     if trans::type_is_immediate(bcx_ccx(bcx), t) {\n-        ret tup(bcx, dst_imm(@mutable none));\n+        ret rec(bcx=bcx, dest=dst_imm(@mutable none));\n     }\n \n     auto r = trans::alloc_ty(cx, t);\n     bcx = r.bcx; auto llptr = r.val;\n-    ret tup(bcx, dst_copy(llptr));\n+    ret rec(bcx=bcx, dest=dst_copy(llptr));\n }\n \n \n@@ -269,7 +269,7 @@ fn trans_lit(&@block_ctxt cx, &dest dest, &ast::lit lit) -> @block_ctxt {\n     alt (lit.node) {\n       ast::lit_str(?s, ast::sk_unique) {\n         auto r = trans_lit_str_common(bcx_ccx(bcx), s, dest_is_alias(dest));\n-        auto llstackpart = r._0; auto llheappartopt = r._1;\n+        auto llstackpart = r.stack; auto llheappartopt = r.heap;\n         bcx = store_ptr(bcx, dest, llstackpart);\n         alt (llheappartopt) {\n           none { /* no-op */ }\n@@ -336,27 +336,27 @@ fn trans_log(&@block_ctxt cx, &span sp, int level, &@ast::expr expr)\n \n     tag upcall_style { us_imm; us_imm_i32_zext; us_alias; us_alias_istr; }\n     fn get_upcall(&@crate_ctxt ccx, &span sp, ty::t t)\n-            -> tup(ValueRef, upcall_style) {\n+            -> rec(ValueRef val, upcall_style st) {\n         alt (ty::struct(ccx_tcx(ccx), t)) {\n           ty::ty_machine(ast::ty_f32) {\n-            ret tup(ccx.upcalls.log_float, us_imm);\n+            ret rec(val=ccx.upcalls.log_float, st=us_imm);\n           }\n           ty::ty_machine(ast::ty_f64) | ty::ty_float {\n             // TODO: We have to spill due to legacy calling conventions that\n             // should probably be modernized.\n-            ret tup(ccx.upcalls.log_double, us_alias);\n+            ret rec(val=ccx.upcalls.log_double, st=us_alias);\n           }\n           ty::ty_bool | ty::ty_machine(ast::ty_i8) |\n                 ty::ty_machine(ast::ty_i16) | ty::ty_machine(ast::ty_u8) |\n                 ty::ty_machine(ast::ty_u16) {\n-            ret tup(ccx.upcalls.log_int, us_imm_i32_zext);\n+            ret rec(val=ccx.upcalls.log_int, st=us_imm_i32_zext);\n           }\n           ty::ty_int | ty::ty_machine(ast::ty_i32) |\n                 ty::ty_machine(ast::ty_u32) {\n-            ret tup(ccx.upcalls.log_int, us_imm);\n+            ret rec(val=ccx.upcalls.log_int, st=us_imm);\n           }\n           ty::ty_istr {\n-            ret tup(ccx.upcalls.log_istr, us_alias_istr);\n+            ret rec(val=ccx.upcalls.log_istr, st=us_alias_istr);\n           }\n           _ {\n             ccx.sess.span_unimpl(sp, \"logging for values of type \" +\n@@ -379,7 +379,7 @@ fn trans_log(&@block_ctxt cx, &span sp, int level, &@ast::expr expr)\n \n     auto expr_t = ty::expr_ty(bcx_tcx(log_bcx), expr);\n     auto r = get_upcall(bcx_ccx(bcx), sp, expr_t);\n-    auto llupcall = r._0; auto style = r._1;\n+    auto llupcall = r.val; auto style = r.st;\n \n     auto arg_dest;\n     alt (style) {\n@@ -415,7 +415,7 @@ fn trans_path(&@block_ctxt bcx, &dest dest, &ast::path path, ast::node_id id)\n         -> @block_ctxt {\n     alt (bcx_tcx(bcx).def_map.get(id)) {\n       ast::def_local(?def_id) {\n-        alt (bcx_fcx(bcx).lllocals.find(def_id._1)) {\n+        alt (bcx_fcx(bcx).lllocals.find(def_id.node)) {\n           none { bcx_ccx(bcx).sess.unimpl(\"upvar in trans_path\"); }\n           some(?llptr) {\n             // TODO: Copy hooks.\n@@ -481,7 +481,7 @@ fn trans_block(&@block_ctxt cx, &dest dest, &ast::blk blk)\n // If |expand| is true, we never spill to the heap. This should be used\n // whenever the destination size isn't fixed.\n fn trans_lit_str_common(&@crate_ctxt ccx, &str s, bool expand)\n-        -> tup(ValueRef, option[ValueRef]) {\n+        -> rec(ValueRef stack, option[ValueRef] heap) {\n     auto llstackpart; auto llheappartopt;\n \n     auto len = str::byte_len(s);\n@@ -515,8 +515,8 @@ fn trans_lit_str_common(&@crate_ctxt ccx, &str s, bool expand)\n                                       llheappart));\n     }\n \n-    ret tup(mk_const(ccx, \"const_istr_stack\", false, llstackpart),\n-            llheappartopt);\n+    ret rec(stack=mk_const(ccx, \"const_istr_stack\", false, llstackpart),\n+            heap=llheappartopt);\n }\n \n // As above, we don't use destination-passing style here."}, {"sha": "2105fd8728738c06cc7a0ce0b8bc89f0748d170b", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -39,7 +39,7 @@ import tc = middle::trans_common;\n // TODO: We can optimize this in the cases in which we statically know the\n // vector must be on the stack.\n fn get_len_and_data(&@block_ctxt cx, ty::t t, ValueRef llvecptr)\n-        -> tup(@block_ctxt, ValueRef, ValueRef) {\n+        -> rec(@block_ctxt bcx, ValueRef len, ValueRef data) {\n     auto bcx = cx;\n \n     // If this interior vector has dynamic size, we can't assume anything\n@@ -115,7 +115,7 @@ fn get_len_and_data(&@block_ctxt cx, ty::t t, ValueRef llvecptr)\n                           ~[stack_elem, zero_elem, heap_elem],\n                           ~[bcx.llbb, zero_len_cx.llbb,\n                             nonzero_len_cx.llbb]);\n-    ret tup(next_cx, len, elem);\n+    ret rec(bcx=next_cx, len=len, data=elem);\n }\n \n fn trans_concat(&@block_ctxt cx, &dest in_dest, &span sp, ty::t t,\n@@ -139,15 +139,15 @@ fn trans_concat(&@block_ctxt cx, &dest in_dest, &span sp, ty::t t,\n     auto llrhsptr = trans_dps::dest_ptr(rhs_tmp);\n \n     auto r0 = get_len_and_data(bcx, t, lllhsptr);\n-    bcx = r0._0; auto lllhslen = r0._1; auto lllhsdata = r0._2;\n+    bcx = r0.bcx; auto lllhslen = r0.len; auto lllhsdata = r0.data;\n     r0 = get_len_and_data(bcx, t, llrhsptr);\n-    bcx = r0._0; auto llrhslen = r0._1; auto llrhsdata = r0._2;\n+    bcx = r0.bcx; auto llrhslen = r0.len; auto llrhsdata = r0.data;\n \n     if skip_null { lllhslen = bcx.build.Sub(lllhslen, C_int(1)); }\n \n     // Allocate the destination.\n     auto r1 = trans_dps::spill_alias(bcx, in_dest, t);\n-    bcx = r1._0; auto dest = r1._1;\n+    bcx = r1.bcx; auto dest = r1.dest;\n \n     auto unit_t = ty::sequence_element_type(bcx_tcx(bcx), t);\n     auto unit_sz = trans_dps::size_of(bcx_ccx(bcx), sp, unit_t);"}, {"sha": "6a527d50eb6d8e9a73f2b29231d7e68326c36dc5", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -55,7 +55,7 @@ tag oper_type {\n \n /* logging funs */\n fn def_id_to_str(def_id d) -> str {\n-    ret int::str(d._0) + \",\" + int::str(d._1);\n+    ret int::str(d.crate) + \",\" + int::str(d.node);\n }\n \n fn comma_str(&(@constr_arg_use)[] args) -> str {\n@@ -65,7 +65,7 @@ fn comma_str(&(@constr_arg_use)[] args) -> str {\n         if (comma) { rslt += \", \"; } else { comma = true; }\n         alt (a.node) {\n             case (carg_base) { rslt += \"*\"; }\n-            case (carg_ident(?i)) { rslt += i._0; }\n+            case (carg_ident(?i)) { rslt += i.ident; }\n             case (carg_lit(?l)) { rslt += lit_to_str(l); }\n         }\n     }\n@@ -503,7 +503,7 @@ fn node_id_to_def(&crate_ctxt ccx, node_id id) -> option::t[def] {\n fn norm_a_constraint(def_id id, &constraint c) -> norm_constraint[] {\n     alt (c) {\n         case (cinit(?n, ?sp, ?i)) {\n-            ret ~[rec(bit_num=n, c=respan(sp, ninit(id._1, i)))];\n+            ret ~[rec(bit_num=n, c=respan(sp, ninit(id.node, i)))];\n         }\n         case (cpred(?p, ?descs)) {\n             let norm_constraint[] rslt = ~[];\n@@ -522,8 +522,9 @@ fn norm_a_constraint(def_id id, &constraint c) -> norm_constraint[] {\n // non-exhaustive match in trans.\n fn constraints(&fn_ctxt fcx) -> norm_constraint[] {\n     let norm_constraint[] rslt = ~[];\n-    for each (@tup(def_id, constraint) p in fcx.enclosing.constrs.items()) {\n-        rslt += norm_a_constraint(p._0, p._1);\n+    for each (@rec(def_id key, constraint val) p\n+              in fcx.enclosing.constrs.items()) {\n+        rslt += norm_a_constraint(p.key, p.val);\n     }\n     ret rslt;\n }\n@@ -535,11 +536,11 @@ fn match_args(&fn_ctxt fcx, &(@mutable pred_args[]) occs,\n               &(@constr_arg_use)[] occ) ->\n    uint {\n     log \"match_args: looking at \" +\n-        constr_args_to_str(std::util::fst[ident, node_id], occ);\n+        constr_args_to_str(fn(&inst i) -> str { ret i.ident; }, occ);\n     for (pred_args pd in *occs) {\n         log \"match_args: candidate \" + pred_args_to_str(pd);\n         fn eq(&inst p, &inst q) -> bool {\n-            ret p._1 == q._1;\n+            ret p.node == q.node;\n         }\n         if (ty::args_eq(eq, pd.node.args, occ)) { ret pd.node.bit_num; }\n     }\n@@ -563,12 +564,14 @@ fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n         case (expr_path(?p)) {\n             alt (tcx.def_map.find(e.id)) {\n                 case (some(def_local(?l_id))) {\n-                    ret @respan(p.span, carg_ident(tup(p.node.idents.(0),\n-                                                       l_id._1)));\n+                    ret @respan(p.span,\n+                                carg_ident(rec(ident=p.node.idents.(0),\n+                                               node=l_id.node)));\n                 }\n                 case (some(def_arg(?a_id))) {\n-                    ret @respan(p.span, carg_ident(tup(p.node.idents.(0),\n-                                                       a_id._1)));\n+                    ret @respan(p.span,\n+                                carg_ident(rec(ident=p.node.idents.(0),\n+                                               node=a_id.node)));\n                 }\n                 case (_) {\n                     tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n@@ -625,7 +628,7 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> sp_constr {\n \n fn pred_args_to_str(&pred_args p) -> str {\n     \"<\" + uint::str(p.node.bit_num) + \", \" +\n-        constr_args_to_str(std::util::fst[ident, node_id],\n+        constr_args_to_str(fn(&inst i) -> str { ret i.ident; },\n                            p.node.args) + \">\"\n }\n \n@@ -664,7 +667,7 @@ fn pred_args_matches(&(constr_arg_general_[inst])[] pattern,\n             case (carg_ident(?p)) {\n                 alt (n) {\n                     case (carg_ident(?q)) {\n-                        if (p._1 != q._1) {\n+                        if (p.node != q.node) {\n                             ret false;\n                         }\n                     }\n@@ -702,13 +705,13 @@ fn find_instance_(&(constr_arg_general_[inst])[] pattern,\n     ret none;\n }\n \n-type inst = tup(ident, node_id);\n-type subst = tup(inst, inst)[];\n+type inst = rec(ident ident, node_id node);\n+type subst = rec(inst from, inst to)[];\n \n fn find_instances(&fn_ctxt fcx, &subst subst, &constraint c)\n-        -> (tup(uint, uint))[] {\n+        -> (rec(uint from, uint to))[] {\n \n-    let (tup(uint, uint))[] rslt = ~[];\n+    auto rslt = ~[];\n     if (ivec::len(subst) == 0u) {\n         ret rslt;\n     }\n@@ -722,7 +725,7 @@ fn find_instances(&fn_ctxt fcx, &subst subst, &constraint c)\n                     auto new = replace(subst, d);\n                     alt (find_instance_(new, *descs)) {\n                         case (some(?d1)) {\n-                            rslt += ~[tup(old_bit_num, d1)];\n+                            rslt += ~[rec(from=old_bit_num, to=d1)];\n                         }\n                         case (_) { }\n                     }\n@@ -734,9 +737,9 @@ fn find_instances(&fn_ctxt fcx, &subst subst, &constraint c)\n }\n \n fn find_in_subst(node_id id, &subst s) -> option::t[inst] {\n-    for (tup(inst, inst) p in s) {\n-        if (id == p._0._1) {\n-            ret some(p._1);\n+    for (rec(inst from, inst to) p in s) {\n+        if (id == p.from.node) {\n+            ret some(p.to);\n         }\n     }\n     ret none;\n@@ -750,7 +753,7 @@ fn insts_to_str(&(constr_arg_general_[inst])[] stuff) -> str {\n     auto rslt = \"<\";\n     for (constr_arg_general_[inst] i in stuff) {\n         rslt += \" \" + alt(i) {\n-            case (carg_ident(?p)) { p._0 }\n+            case (carg_ident(?p)) { p.ident }\n             case (carg_base) { \"*\" }\n             case (carg_lit(_)) { \"[lit]\" } } + \" \";\n     }\n@@ -763,7 +766,7 @@ fn replace(subst subst, pred_args d) -> (constr_arg_general_[inst])[] {\n     for (@constr_arg_use c in d.node.args) {\n         alt (c.node) {\n             case (carg_ident(?p)) {\n-                alt (find_in_subst(p._1, subst)) {\n+                alt (find_in_subst(p.node, subst)) {\n                     case (some(?new)) {\n                         rslt += ~[carg_ident(new)];\n                     }\n@@ -840,8 +843,8 @@ fn local_node_id_to_def_id(&fn_ctxt fcx, &node_id i) -> option::t[def_id] {\n fn local_node_id_to_local_def_id(&fn_ctxt fcx, &node_id i)\n     -> option::t[node_id] {\n     alt (local_node_id_to_def(fcx, i)) {\n-        case (some (def_local(?d_id))) { some(d_id._1) }\n-        case (some (def_arg(?a_id)))  { some(a_id._1) }\n+        case (some (def_local(?d_id))) { some(d_id.node) }\n+        case (some (def_arg(?a_id)))  { some(a_id.node) }\n         case (_)                      { none }\n     }\n }\n@@ -870,26 +873,25 @@ fn copy_in_poststate_two(&fn_ctxt fcx, &poststate src_post,\n     auto subst;\n     alt (ty) {\n         case (oper_swap) {\n-            subst = ~[tup(dest, src),\n-                     tup(src, dest)];\n+            subst = ~[rec(from=dest, to=src),\n+                      rec(from=src, to=dest)];\n         }\n         case (oper_assign_op) {\n             ret; // Don't do any propagation\n         }\n         case (_) {\n-            subst = ~[tup(src, dest)];\n+            subst = ~[rec(from=src, to=dest)];\n         }\n     }\n \n-    for each (@tup(def_id, constraint) p in\n+    for each (@rec(def_id key, constraint val) p in\n               fcx.enclosing.constrs.items()) {\n         // replace any occurrences of the src def_id with the\n         // dest def_id\n-        auto instances = find_instances(fcx, subst, p._1);\n-\n-        for (tup(uint,uint) p in instances) {\n-            if (promises_(p._0, src_post)) {\n-                set_in_poststate_(p._1, target_post);\n+        auto insts = find_instances(fcx, subst, p.val);\n+        for (rec(uint from, uint to) p in insts) {\n+            if (promises_(p.from, src_post)) {\n+                set_in_poststate_(p.to, target_post);\n             }\n         }\n     }\n@@ -1020,7 +1022,7 @@ fn args_mention[T](&(@constr_arg_use)[] args, fn(&(T)[], node_id) -> bool q,\n     for (@constr_arg_use a in args) {\n         alt (a.node) {\n             case (carg_ident(?p1)) {\n-                if (q(s, p1._1)) {\n+                if (q(s, p1.node)) {\n                     ret true;\n                 }\n             }\n@@ -1058,7 +1060,7 @@ fn do_nothing[T](&_fn f, &ty_param[] tp, &span sp, &fn_ident i,\n fn args_to_constr_args(&span sp, &arg[] args) -> (@constr_arg_use)[] {\n     let (@constr_arg_use)[] actuals = ~[];\n     for (arg a in args) {\n-        actuals += ~[@respan(sp, carg_ident(tup(a.ident, a.id)))];\n+        actuals += ~[@respan(sp, carg_ident(rec(ident=a.ident, node=a.id)))];\n     }\n     ret actuals;\n }"}, {"sha": "c9cf002d9498fddaed1aa5d902e989f51b5de842", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -213,7 +213,7 @@ fn clear_in_poststate_expr(&fn_ctxt fcx, &@expr e, &poststate t) {\n                     alt (local_node_id_to_def(fcx, e.id)) {\n                         case (some(def_local(?d_id))) {\n                             clear_in_poststate_(\n-                               bit_num(fcx,ninit(d_id._1, i)), t);\n+                               bit_num(fcx,ninit(d_id.node, i)), t);\n                         }\n                         case (some(_)) { /* ignore args (for now...) */ }\n                         case (_) {"}, {"sha": "79c4e595d5130efd3c947524b549d260cc1918eb", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -219,7 +219,7 @@ fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs, node_id larger_id,\n                     set_pre_and_post(fcx.ccx, larger_id, p.precondition,\n                                      p.postcondition);\n                     gen(fcx, larger_id,\n-                        ninit(d_id._1, path_to_ident(fcx.ccx.tcx, pth)));\n+                        ninit(d_id.node, path_to_ident(fcx.ccx.tcx, pth)));\n                 }\n                 case (_) { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n             }\n@@ -255,7 +255,7 @@ fn handle_update(&fn_ctxt fcx, &@expr parent,\n                     alt (df) {\n                         case (def_local(?d_id)) {\n                             auto i =\n-                                bit_num(fcx, ninit(d_id._1,\n+                                bit_num(fcx, ninit(d_id.node,\n                                         path_to_ident(fcx.ccx.tcx, p)));\n                             require_and_preserve(i, expr_pp(fcx.ccx, lhs));\n                         }\n@@ -274,11 +274,13 @@ fn handle_update(&fn_ctxt fcx, &@expr parent,\n                             alt (d1) {\n                                 case (some(?id1)) {\n                                     auto instlhs =\n-                                        tup(path_to_ident(fcx.ccx.tcx,\n-                                                          p), id);\n+                                        rec(ident=path_to_ident\n+                                            (fcx.ccx.tcx, p),\n+                                            node=id);\n                                     auto instrhs =\n-                                        tup(path_to_ident(fcx.ccx.tcx,\n-                                                          p1), id1);\n+                                        rec(ident=path_to_ident\n+                                            (fcx.ccx.tcx, p1),\n+                                            node=id1);\n                                     copy_in_poststate_two(fcx, tmp,\n                                         post, instlhs, instrhs, ty);\n                                 }\n@@ -343,8 +345,8 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                 case (def_local(?d_id)) {\n                     auto i =\n                         bit_num(fcx,\n-                          ninit(d_id._1, path_to_ident(fcx.ccx.tcx, p)));\n-                    use_var(fcx, d_id._1);\n+                          ninit(d_id.node, path_to_ident(fcx.ccx.tcx, p)));\n+                    use_var(fcx, d_id.node);\n                     require_and_preserve(i, rslt);\n                 }\n                 case (_) {/* nothing to check */ }\n@@ -603,10 +605,10 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n                             alt (an_init.expr.node) {\n                                 case (expr_path(?p)) {\n                                     copy_in_postcond(fcx, id,\n-                                      tup(alocal.node.ident,\n-                                          alocal.node.id),\n-                                      tup(path_to_ident(fcx.ccx.tcx, p),\n-                                          an_init.expr.id),\n+                                      rec(ident=alocal.node.ident,\n+                                          node=alocal.node.id),\n+                                      rec(ident=path_to_ident(fcx.ccx.tcx, p),\n+                                          node=an_init.expr.id),\n                                        op_to_oper_ty(an_init.op));\n                                 }\n                                 case (_) {}"}, {"sha": "ee7796453b971b51866a891341e755c3f080ac11", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -54,7 +54,7 @@ import util::common::log_stmt_err;\n import util::common::log_expr_err;\n \n fn seq_states(&fn_ctxt fcx, prestate pres, &(@expr)[] exprs) ->\n-   tup(bool, poststate) {\n+   rec(bool changed, poststate post) {\n     auto changed = false;\n     auto post = pres;\n     for (@expr e in exprs) {\n@@ -63,7 +63,7 @@ fn seq_states(&fn_ctxt fcx, prestate pres, &(@expr)[] exprs) ->\n         // log_err changed;\n         post = expr_poststate(fcx.ccx, e);\n     }\n-    ret tup(changed, post);\n+    ret rec(changed=changed, post=post);\n }\n \n fn find_pre_post_state_sub(&fn_ctxt fcx, &prestate pres, &@expr e,\n@@ -128,11 +128,13 @@ fn find_pre_post_state_two(&fn_ctxt fcx, &prestate pres, &@expr lhs,\n                             alt (d1) {\n                                 case (some(?id1)) {\n                                     auto instlhs =\n-                                        tup(path_to_ident(fcx.ccx.tcx,\n-                                                          p), id);\n+                                        rec(ident=path_to_ident\n+                                            (fcx.ccx.tcx, p),\n+                                            node=id);\n                                     auto instrhs =\n-                                        tup(path_to_ident(fcx.ccx.tcx,\n-                                                          p1), id1);\n+                                        rec(ident=path_to_ident\n+                                            (fcx.ccx.tcx, p1),\n+                                            node=id1);\n                                     copy_in_poststate_two(fcx, tmp,\n                                             post, instlhs, instrhs, ty);\n                                 }\n@@ -162,15 +164,15 @@ fn find_pre_post_state_call(&fn_ctxt fcx, &prestate pres, &@expr a,\n fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, node_id id,\n                              &(@expr)[] es, controlflow cf) -> bool {\n     auto rs = seq_states(fcx, pres, es);\n-    auto changed = rs._0 | set_prestate_ann(fcx.ccx, id, pres);\n+    auto changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n     /* if this is a failing call, it sets everything as initialized */\n     alt (cf) {\n         case (noreturn) {\n             changed |= set_poststate_ann\n                 (fcx.ccx, id, false_postcond(num_constraints(fcx.enclosing)));\n         }\n         case (_) {\n-            changed |= set_poststate_ann(fcx.ccx, id, rs._1);\n+            changed |= set_poststate_ann(fcx.ccx, id, rs.post);\n         }\n     }\n     ret changed;\n@@ -208,7 +210,7 @@ fn gen_if_local(&fn_ctxt fcx, &poststate p, &@expr e) -> bool {\n         case (expr_path(?pth)) {\n             alt (node_id_to_def(fcx.ccx, e.id)) {\n                 case (some(def_local(?loc))) {\n-                    ret set_in_poststate_ident(fcx, loc._1,\n+                    ret set_in_poststate_ident(fcx, loc.node,\n                            path_to_ident(fcx.ccx.tcx, pth), p);\n                 }\n             case (_) { ret false; }\n@@ -612,15 +614,16 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n                                 case (expr_path(?p)) {\n \n                                     auto instlhs =\n-                                        tup(alocal.node.ident,\n-                                            alocal.node.id);\n+                                        rec(ident=alocal.node.ident,\n+                                            node=alocal.node.id);\n                                     auto rhs_d = local_node_id_to_local_def_id\n                                         (fcx, an_init.expr.id);\n                                     alt (rhs_d) {\n                                         case (some(?rhsid)) {\n                                             auto instrhs =\n-                                                tup(path_to_ident(fcx.ccx.tcx,\n-                                                                  p), rhsid);\n+                                                rec(ident=path_to_ident\n+                                                    (fcx.ccx.tcx, p),\n+                                                    node=rhsid);\n                                             copy_in_poststate(fcx, post,\n                                                instlhs, instrhs,\n                                                op_to_oper_ty(an_init.op));"}, {"sha": "fcd5d6a8b5d37a980b13e1e1088aa0de50652a4b", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -204,7 +204,7 @@ type mt = rec(t ty, ast::mutability mut);\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-type creader_cache = hashmap[tup(int, uint, uint), ty::t];\n+type creader_cache = hashmap[rec(int cnum, uint pos, uint len), ty::t];\n \n type ctxt =\n     @rec(@type_store ts,\n@@ -304,7 +304,7 @@ tag type_err {\n     terr_constr_mismatch(@type_constr, @type_constr);\n }\n \n-type ty_param_count_and_ty = tup(uint, t);\n+type ty_param_count_and_ty = rec(uint count, t ty);\n \n type type_cache = hashmap[ast::def_id, ty_param_count_and_ty];\n \n@@ -354,7 +354,7 @@ const uint idx_first_others = 21u;\n \n type type_store = interner::interner[@raw_t];\n \n-type ty_param_substs_opt_and_ty = tup(option::t[ty::t[]], ty::t);\n+type ty_param_substs_opt_and_ty = rec(option::t[ty::t[]] substs, ty::t ty);\n \n type node_type_table =\n     @smallintmap::smallintmap[ty::ty_param_substs_opt_and_ty];\n@@ -385,12 +385,13 @@ fn populate_type_store(&ctxt cx) {\n }\n \n fn mk_rcache() -> creader_cache {\n-    fn hash_cache_entry(&tup(int, uint, uint) k) -> uint {\n-        ret (k._0 as uint) + k._1 + k._2;\n+    type val = rec(int cnum, uint pos, uint len);\n+    fn hash_cache_entry(&val k) -> uint {\n+        ret (k.cnum as uint) + k.pos + k.len;\n     }\n-    fn eq_cache_entries(&tup(int, uint, uint) a, &tup(int, uint, uint) b) ->\n+    fn eq_cache_entries(&val a, &val b) ->\n        bool {\n-        ret a._0 == b._0 && a._1 == b._1 && a._2 == b._2;\n+        ret a.cnum == b.cnum && a.pos == b.pos && a.len == b.len;\n     }\n     ret map::mk_hashmap(hash_cache_entry, eq_cache_entries);\n }\n@@ -1300,8 +1301,8 @@ fn hash_type_structure(&sty st) -> uint {\n     }\n     fn hash_def(uint id, ast::def_id did) -> uint {\n         auto h = id;\n-        h += h << 5u + (did._0 as uint);\n-        h += h << 5u + (did._1 as uint);\n+        h += h << 5u + (did.crate as uint);\n+        h += h << 5u + (did.node as uint);\n         ret h;\n     }\n     fn hash_subty(uint id, &t subty) -> uint {\n@@ -1505,7 +1506,7 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         ret true;\n     }\n     fn equal_def(&ast::def_id did_a, &ast::def_id did_b) -> bool {\n-        ret did_a._0 == did_b._0 && did_a._1 == did_b._1;\n+        ret did_a.crate == did_b.crate && did_a.node == did_b.node;\n     }\n     alt (a) {\n         case (ty_nil) {\n@@ -1708,7 +1709,7 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_native(?a_id)) {\n             alt (b) {\n                 case (ty_native(?b_id)) {\n-                    ret a_id._0 == b_id._0 && a_id._1 == b_id._1;\n+                    ret a_id.crate == b_id.crate && a_id.node == b_id.node;\n                 }\n                 case (_) { ret false; } }\n         }\n@@ -1766,29 +1767,28 @@ fn node_id_to_ty_param_substs_opt_and_ty(&ctxt cx, &ast::node_id id) ->\n }\n \n fn node_id_to_type(&ctxt cx, &ast::node_id id) -> t {\n-    ret node_id_to_ty_param_substs_opt_and_ty(cx, id)._1;\n+    ret node_id_to_ty_param_substs_opt_and_ty(cx, id).ty;\n }\n \n fn node_id_to_type_params(&ctxt cx, &ast::node_id id) -> t[] {\n-    alt (node_id_to_ty_param_substs_opt_and_ty(cx, id)._0) {\n+    alt (node_id_to_ty_param_substs_opt_and_ty(cx, id).substs) {\n         case (none)       { ret ~[]; }\n         case (some(?tps)) { ret tps; }\n     }\n }\n \n fn node_id_has_type_params(&ctxt cx, &ast::node_id id) -> bool {\n     auto tpt = node_id_to_ty_param_substs_opt_and_ty(cx, id);\n-    ret !option::is_none[t[]](tpt._0);\n+    ret !option::is_none[t[]](tpt.substs);\n }\n \n \n // Returns a type with type parameter substitutions performed if applicable.\n-fn ty_param_substs_opt_and_ty_to_monotype(&ctxt cx,\n-                                          &ty_param_substs_opt_and_ty tpot) ->\n-   t {\n-    alt (tpot._0) {\n-        case (none) { ret tpot._1; }\n-        case (some(?tps)) { ret substitute_type_params(cx, tps, tpot._1); }\n+fn ty_param_substs_opt_and_ty_to_monotype\n+    (&ctxt cx, &ty_param_substs_opt_and_ty tpot) -> t {\n+    alt (tpot.substs) {\n+        case (none) { ret tpot.ty; }\n+        case (some(?tps)) { ret substitute_type_params(cx, tps, tpot.ty); }\n     }\n }\n \n@@ -1896,9 +1896,10 @@ fn expr_ty(&ctxt cx, &@ast::expr expr) -> t {\n     ret node_id_to_monotype(cx, expr.id);\n }\n \n-fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr) -> tup(t[], t) {\n-    ret tup(node_id_to_type_params(cx, expr.id),\n-            node_id_to_type(cx, expr.id));\n+fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr)\n+    -> rec(t[] params, t ty) {\n+    ret rec(params=node_id_to_type_params(cx, expr.id),\n+            ty=node_id_to_type(cx, expr.id));\n }\n \n fn expr_has_ty_params(&ctxt cx, &@ast::expr expr) -> bool {\n@@ -2409,7 +2410,8 @@ mod unify {\n             case (ty::ty_native(?ex_id)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty_native(?act_id)) {\n-                        if (ex_id._0 == act_id._0 && ex_id._1 == act_id._1) {\n+                        if (ex_id.crate == act_id.crate &&\n+                            ex_id.node == act_id.node) {\n                             ret ures_ok(actual);\n                         } else {\n                             ret ures_err(terr_mismatch);\n@@ -2422,8 +2424,8 @@ mod unify {\n             case (ty::ty_tag(?expected_id, ?expected_tps)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty::ty_tag(?actual_id, ?actual_tps)) {\n-                        if (expected_id._0 != actual_id._0 ||\n-                                expected_id._1 != actual_id._1) {\n+                        if (expected_id.crate != actual_id.crate ||\n+                            expected_id.node != actual_id.node) {\n                             ret ures_err(terr_mismatch);\n                         }\n                         // TODO: factor this cruft out, see the TODO in the\n@@ -2551,7 +2553,8 @@ mod unify {\n             case (ty::ty_res(?ex_id, ?ex_inner, ?ex_tps)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty::ty_res(?act_id, ?act_inner, ?act_tps)) {\n-                        if (ex_id._0 != act_id._0 || ex_id._1 != act_id._1) {\n+                        if (ex_id.crate != act_id.crate ||\n+                            ex_id.node != act_id.node) {\n                             ret ures_err(terr_mismatch);\n                         }\n                         auto result = unify_step(cx, ex_inner, act_inner);\n@@ -2883,7 +2886,7 @@ fn type_err_to_str(&ty::type_err err) -> str {\n // Converts type parameters in a type to type variables and returns the\n // resulting type along with a list of type variable IDs.\n fn bind_params_in_type(&span sp, &ctxt cx, fn() -> int  next_ty_var, t typ,\n-                       uint ty_param_count) -> tup(int[], t) {\n+                       uint ty_param_count) -> rec(int[] ids, t ty) {\n     let @mutable int[] param_var_ids = @mutable ~[];\n     auto i = 0u;\n     while (i < ty_param_count) {\n@@ -2902,7 +2905,7 @@ fn bind_params_in_type(&span sp, &ctxt cx, fn() -> int  next_ty_var, t typ,\n     auto new_typ =\n         fold_ty(cx, fm_param(bind binder(sp, cx, param_var_ids,\n                                          next_ty_var, _)), typ);\n-    ret tup(*param_var_ids, new_typ);\n+    ret rec(ids=*param_var_ids, ty=new_typ);\n }\n \n \n@@ -2940,8 +2943,10 @@ fn def_has_ty_params(&ast::def def) -> bool {\n type variant_info = rec(ty::t[] args, ty::t ctor_ty, ast::def_id id);\n \n fn tag_variants(&ctxt cx, &ast::def_id id) -> variant_info[] {\n-    if (ast::local_crate != id._0) { ret csearch::get_tag_variants(cx, id); }\n-    auto item = alt (cx.items.find(id._1)) {\n+    if (ast::local_crate != id.crate) {\n+        ret csearch::get_tag_variants(cx, id);\n+    }\n+    auto item = alt (cx.items.find(id.node)) {\n         case (some(?i)) { i }\n         case (none) {\n             cx.sess.bug(\"expected to find cached node_item\")\n@@ -2992,7 +2997,7 @@ fn tag_variant_with_id(&ctxt cx, &ast::def_id tag_id, &ast::def_id variant_id)\n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n fn lookup_item_type(ctxt cx, ast::def_id did) -> ty_param_count_and_ty {\n-    if (did._0 == ast::local_crate) {\n+    if (did.crate == ast::local_crate) {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already; we simply return it.\n "}, {"sha": "3fac0bfbf56679ac4dd6f2ffc8ec9546c559e33e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 70, "deletions": 82, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -101,20 +101,22 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn) ->\n    ty_param_count_and_ty {\n     alt (defn) {\n         case (ast::def_arg(?id)) {\n-            assert (fcx.locals.contains_key(id._1));\n+            assert (fcx.locals.contains_key(id.node));\n             auto typ = ty::mk_var(fcx.ccx.tcx,\n-                                  lookup_local(fcx, sp, id._1));\n-            ret tup(0u, typ);\n+                                  lookup_local(fcx, sp, id.node));\n+            ret rec(count=0u, ty=typ);\n         }\n         case (ast::def_local(?id)) {\n-            assert (fcx.locals.contains_key(id._1));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id._1));\n-            ret tup(0u, typ);\n+            assert (fcx.locals.contains_key(id.node));\n+            auto typ = ty::mk_var(fcx.ccx.tcx,\n+                                  lookup_local(fcx, sp, id.node));\n+            ret rec(count=0u, ty=typ);\n         }\n         case (ast::def_obj_field(?id)) {\n-            assert (fcx.locals.contains_key(id._1));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id._1));\n-            ret tup(0u, typ);\n+            assert (fcx.locals.contains_key(id.node));\n+            auto typ = ty::mk_var(fcx.ccx.tcx,\n+                                  lookup_local(fcx, sp, id.node));\n+            ret rec(count=0u, ty=typ);\n         }\n         case (ast::def_fn(?id, _)) {\n             ret ty::lookup_item_type(fcx.ccx.tcx, id);\n@@ -129,15 +131,16 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn) ->\n             ret ty::lookup_item_type(fcx.ccx.tcx, vid);\n         }\n         case (ast::def_binding(?id)) {\n-            assert (fcx.locals.contains_key(id._1));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id._1));\n-            ret tup(0u, typ);\n+            assert (fcx.locals.contains_key(id.node));\n+            auto typ = ty::mk_var(fcx.ccx.tcx,\n+                                  lookup_local(fcx, sp, id.node));\n+            ret rec(count=0u, ty=typ);\n         }\n         case (ast::def_mod(_)) {\n             // Hopefully part of a path.\n             // TODO: return a type that's more poisonous, perhaps?\n \n-            ret tup(0u, ty::mk_nil(fcx.ccx.tcx));\n+            ret rec(count=0u, ty=ty::mk_nil(fcx.ccx.tcx));\n         }\n         case (ast::def_ty(_)) {\n             fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n@@ -155,11 +158,11 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn) ->\n // number of type parameters and type.\n fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n                     &span sp) -> ty_param_substs_opt_and_ty {\n-    auto ty_param_count = tpt._0;\n+    auto ty_param_count = tpt.count;\n     auto bind_result =\n-        bind_params_in_type(sp, fcx.ccx.tcx, bind next_ty_var_id(fcx), tpt._1,\n+        bind_params_in_type(sp, fcx.ccx.tcx, bind next_ty_var_id(fcx), tpt.ty,\n                             ty_param_count);\n-    auto ty_param_vars = bind_result._0;\n+    auto ty_param_vars = bind_result.ids;\n     auto ty_substs_opt;\n     auto ty_substs_len = ivec::len[@ast::ty](pth.node.types);\n     if (ty_substs_len > 0u) {\n@@ -201,7 +204,7 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n         }\n         ty_substs_opt = some[ty::t[]](ty_substs);\n     }\n-    ret tup(ty_substs_opt, tpt._1);\n+    ret rec(substs=ty_substs_opt, ty=tpt.ty);\n }\n \n fn ast_mode_to_mode(ast::mode mode) -> ty::mode {\n@@ -275,7 +278,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         // \"foo = int\" like OCaml?\n \n         auto params_opt_and_ty = getter(id);\n-        if (params_opt_and_ty._0 == 0u) { ret params_opt_and_ty._1; }\n+        if (params_opt_and_ty.count == 0u) { ret params_opt_and_ty.ty; }\n         // The typedef is type-parametric. Do the type substitution.\n         //\n \n@@ -284,14 +287,14 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             param_bindings += ~[ast_ty_to_ty(tcx, getter, ast_ty)];\n         }\n         if (ivec::len(param_bindings) !=\n-                ty::count_ty_params(tcx, params_opt_and_ty._1)) {\n+            ty::count_ty_params(tcx, params_opt_and_ty.ty)) {\n             tcx.sess.span_fatal(sp,\n                                 \"Wrong number of type arguments for a \\\n                                 polymorphic tag\");\n         }\n         auto typ =\n             ty::substitute_type_params(tcx, param_bindings,\n-                                       params_opt_and_ty._1);\n+                                       params_opt_and_ty.ty);\n         ret typ;\n     }\n     auto typ;\n@@ -357,7 +360,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n                     typ = instantiate(tcx, ast_ty.span, getter, id,\n                                       path.node.types);\n                 }\n-                case (some(ast::def_native_ty(?id))) { typ = getter(id)._1; }\n+                case (some(ast::def_native_ty(?id))) { typ = getter(id).ty; }\n                 case (some(ast::def_ty_arg(?id))) {\n                     typ = ty::mk_param(tcx, id);\n                 }\n@@ -434,8 +437,8 @@ mod write {\n     // Writes a type parameter count and type pair into the node type table.\n     fn ty(&ty::ctxt tcx, ast::node_id node_id,\n           &ty_param_substs_opt_and_ty tpot) {\n-        assert (!ty::type_contains_vars(tcx, tpot._1));\n-        ret inner(tcx.node_types, node_id, tpot);\n+        assert (!ty::type_contains_vars(tcx, tpot.ty));\n+        inner(tcx.node_types, node_id, tpot);\n     }\n \n     // Writes a type parameter count and type pair into the node type table.\n@@ -444,30 +447,30 @@ mod write {\n     fn ty_fixup(@fn_ctxt fcx, ast::node_id node_id,\n                 &ty_param_substs_opt_and_ty tpot) {\n         inner(fcx.ccx.tcx.node_types, node_id, tpot);\n-        if (ty::type_contains_vars(fcx.ccx.tcx, tpot._1)) {\n+        if (ty::type_contains_vars(fcx.ccx.tcx, tpot.ty)) {\n             fcx.fixups += ~[node_id];\n         }\n     }\n \n     // Writes a type with no type parameters into the node type table.\n     fn ty_only(&ty::ctxt tcx, ast::node_id node_id, ty::t typ) {\n-        ret ty(tcx, node_id, tup(none[ty::t[]], typ));\n+        ty(tcx, node_id, rec(substs=none[ty::t[]], ty=typ));\n     }\n \n     // Writes a type with no type parameters into the node type table. This\n     // function allows for the possibility of type variables.\n     fn ty_only_fixup(@fn_ctxt fcx, ast::node_id node_id, ty::t typ) {\n-        ret ty_fixup(fcx, node_id, tup(none[ty::t[]], typ));\n+        ret ty_fixup(fcx, node_id, rec(substs=none[ty::t[]], ty=typ));\n     }\n \n     // Writes a nil type into the node type table.\n     fn nil_ty(&ty::ctxt tcx, ast::node_id node_id) {\n-        ret ty(tcx, node_id, tup(none[ty::t[]], ty::mk_nil(tcx)));\n+        ret ty(tcx, node_id, rec(substs=none[ty::t[]], ty=ty::mk_nil(tcx)));\n     }\n \n     // Writes the bottom type into the node type table.\n     fn bot_ty(&ty::ctxt tcx, ast::node_id node_id) {\n-        ret ty(tcx, node_id, tup(none[ty::t[]], ty::mk_bot(tcx)));\n+        ret ty(tcx, node_id, rec(substs=none[ty::t[]], ty=ty::mk_bot(tcx)));\n     }\n }\n \n@@ -515,7 +518,7 @@ mod collect {\n             ty::mk_fn(cx.tcx, proto, input_tys, output_ty, decl.cf,\n                       out_constrs);\n         auto ty_param_count = ivec::len[ast::ty_param](ty_params);\n-        auto tpt = tup(ty_param_count, t_fn);\n+        auto tpt = rec(count=ty_param_count, ty=t_fn);\n         alt (def_id) {\n             case (some(?did)) { cx.tcx.tcache.insert(did, tpt); }\n             case (_) { }\n@@ -534,16 +537,16 @@ mod collect {\n \n         auto t_fn = ty::mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n         auto ty_param_count = ivec::len[ast::ty_param](ty_params);\n-        auto tpt = tup(ty_param_count, t_fn);\n+        auto tpt = rec(count=ty_param_count, ty=t_fn);\n         cx.tcx.tcache.insert(def_id, tpt);\n         ret tpt;\n     }\n     fn getter(@ctxt cx, &ast::def_id id) -> ty::ty_param_count_and_ty {\n-        if (id._0 != ast::local_crate) {\n+        if (id.crate != ast::local_crate) {\n             // This is a type we need to load in from the crate reader.\n             ret csearch::get_type(cx.tcx, id);\n         }\n-        auto it = cx.tcx.items.find(id._1);\n+        auto it = cx.tcx.items.find(id.node);\n         auto tpt;\n         alt (it) {\n             case (some(ast_map::node_item(?item))) {\n@@ -555,7 +558,7 @@ mod collect {\n             }\n             case (_) {\n                 cx.tcx.sess.fatal(\"internal error \" +\n-                                  std::int::str(id._1));\n+                                  std::int::str(id.node));\n             }\n         }\n         ret tpt;\n@@ -600,7 +603,7 @@ mod collect {\n         auto methods = get_obj_method_types(cx, ob);\n         auto t_obj = ty::mk_obj(cx.tcx, ty::sort_methods(methods));\n         t_obj = ty::rename(cx.tcx, t_obj, id);\n-        ret tup(ivec::len(ty_params), t_obj);\n+        ret rec(count=ivec::len(ty_params), ty=t_obj);\n     }\n     fn ty_of_obj_ctor(@ctxt cx, &ast::ident id, &ast::_obj ob,\n                       ast::node_id ctor_id, &ast::ty_param[] ty_params) ->\n@@ -614,9 +617,9 @@ mod collect {\n             t_inputs += ~[rec(mode=ty::mo_alias(false), ty=t_field)];\n         }\n \n-        auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1,\n+        auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj.ty,\n                               ast::return, ~[]);\n-        auto tpt = tup(t_obj._0, t_fn);\n+        auto tpt = rec(count=t_obj.count, ty=t_fn);\n         cx.tcx.tcache.insert(local_def(ctor_id), tpt);\n         ret tpt;\n     }\n@@ -626,7 +629,7 @@ mod collect {\n         alt (it.node) {\n             case (ast::item_const(?t, _)) {\n                 auto typ = convert(t);\n-                auto tpt = tup(0u, typ);\n+                auto tpt = rec(count=0u, ty=typ);\n                 cx.tcx.tcache.insert(local_def(it.id), tpt);\n                 ret tpt;\n             }\n@@ -650,13 +653,14 @@ mod collect {\n \n                 auto typ = convert(t);\n                 auto ty_param_count = ivec::len[ast::ty_param](tps);\n-                auto tpt = tup(ty_param_count, typ);\n+                auto tpt = rec(count=ty_param_count, ty=typ);\n                 cx.tcx.tcache.insert(local_def(it.id), tpt);\n                 ret tpt;\n             }\n             case (ast::item_res(?f, _, ?tps, _)) {\n                 auto t_arg = ty_of_arg(cx, f.decl.inputs.(0));\n-                auto t_res = tup(ivec::len(tps), ty::mk_res\n+                auto t_res = rec(count=ivec::len(tps),\n+                                 ty=ty::mk_res\n                                  (cx.tcx, local_def(it.id), t_arg.ty,\n                                   mk_ty_params(cx, ivec::len(tps))));\n                 cx.tcx.tcache.insert(local_def(it.id), t_res);\n@@ -669,7 +673,7 @@ mod collect {\n \n                 let ty::t[] subtys = mk_ty_params(cx, ty_param_count);\n                 auto t = ty::mk_tag(cx.tcx, local_def(it.id), subtys);\n-                auto tpt = tup(ty_param_count, t);\n+                auto tpt = rec(count=ty_param_count, ty=t);\n                 cx.tcx.tcache.insert(local_def(it.id), tpt);\n                 ret tpt;\n             }\n@@ -693,7 +697,7 @@ mod collect {\n                     case (none) { }\n                 }\n                 auto t = ty::mk_native(cx.tcx, ast::local_def(it.id));\n-                auto tpt = tup(0u, t);\n+                auto tpt = rec(count=0u, ty=t);\n                 cx.tcx.tcache.insert(local_def(it.id), tpt);\n                 ret tpt;\n             }\n@@ -728,7 +732,7 @@ mod collect {\n                 result_ty = ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t,\n                                       ast::return, ~[]);\n             }\n-            auto tpt = tup(ty_param_count, result_ty);\n+            auto tpt = rec(count=ty_param_count, ty=result_ty);\n             cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n         }\n@@ -755,7 +759,7 @@ mod collect {\n             }\n             case (ast::item_tag(?variants, ?ty_params)) {\n                 auto tpt = ty_of_item(cx, it);\n-                write::ty_only(cx.tcx, it.id, tpt._1);\n+                write::ty_only(cx.tcx, it.id, tpt.ty);\n                 get_tag_variant_types(cx, local_def(it.id), variants,\n                                       ty_params);\n             }\n@@ -767,7 +771,7 @@ mod collect {\n \n                 auto tpt =\n                     ty_of_obj_ctor(cx, it.ident, object, ctor_id, ty_params);\n-                write::ty_only(cx.tcx, ctor_id, tpt._1);\n+                write::ty_only(cx.tcx, ctor_id, tpt.ty);\n                 // Write the methods into the type table.\n                 //\n                 // FIXME: Inefficient; this ends up calling\n@@ -787,7 +791,7 @@ mod collect {\n                 // FIXME: We want to use uint::range() here, but that causes\n                 // an assertion in trans.\n \n-                auto args = ty::ty_fn_args(cx.tcx, tpt._1);\n+                auto args = ty::ty_fn_args(cx.tcx, tpt.ty);\n                 i = 0u;\n                 while (i < ivec::len[ty::arg](args)) {\n                     auto fld = object.fields.(i);\n@@ -816,7 +820,7 @@ mod collect {\n                 write::ty_only(cx.tcx, it.id, t_res);\n                 write::ty_only(cx.tcx, ctor_id, t_ctor);\n                 cx.tcx.tcache.insert(local_def(ctor_id),\n-                                     tup(ivec::len(tps), t_ctor));\n+                                     rec(count=ivec::len(tps), ty=t_ctor));\n                 write::ty_only(cx.tcx, dtor_id, t_dtor);\n             }\n             case (_) {\n@@ -825,7 +829,7 @@ mod collect {\n                 // it into the node type table.\n \n                 auto tpt = ty_of_item(cx, it);\n-                write::ty_only(cx.tcx, it.id, tpt._1);\n+                write::ty_only(cx.tcx, it.id, tpt.ty);\n             }\n         }\n     }\n@@ -843,7 +847,7 @@ mod collect {\n \n             }\n             case (ast::native_item_fn(_, _, _)) {\n-                write::ty_only(cx.tcx, i.id, tpt._1);\n+                write::ty_only(cx.tcx, i.id, tpt.ty);\n             }\n         }\n     }\n@@ -927,16 +931,16 @@ fn resolve_type_vars_if_possible(&@fn_ctxt fcx, ty::t typ) -> ty::t {\n \n // Demands - procedures that require that two types unify and emit an error\n // message if they don't.\n-type ty_param_substs_and_ty = tup(ty::t[], ty::t);\n+type ty_param_substs_and_ty = rec(ty::t[] substs, ty::t ty);\n \n mod demand {\n     fn simple(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual) ->\n        ty::t {\n-        ret full(fcx, sp, expected, actual, ~[], NO_AUTODEREF)._1;\n+        ret full(fcx, sp, expected, actual, ~[], NO_AUTODEREF).ty;\n     }\n     fn autoderef(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual,\n                  autoderef_kind adk) -> ty::t {\n-        ret full(fcx, sp, expected, actual, ~[], adk)._1;\n+        ret full(fcx, sp, expected, actual, ~[], adk).ty;\n     }\n \n     // Requires that the two types unify, and prints an error message if they\n@@ -972,8 +976,8 @@ mod demand {\n                 auto tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n                 result_ty_param_substs += ~[tp_subst];\n             }\n-            ret tup(result_ty_param_substs,\n-                    add_boxes(fcx.ccx, implicit_boxes, result_ty));\n+            ret rec(substs=result_ty_param_substs,\n+                    ty=add_boxes(fcx.ccx, implicit_boxes, result_ty));\n         }\n \n         alt (unify::simple(fcx, expected_1, actual_1)) {\n@@ -1013,7 +1017,7 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n                      &ty::t[] tag_ty_params) -> ty::t[] {\n     let ty::t[] result = ~[];\n     auto tpt = ty::lookup_item_type(ccx.tcx, vid);\n-    alt (ty::struct(ccx.tcx, tpt._1)) {\n+    alt (ty::struct(ccx.tcx, tpt.ty)) {\n         case (ty::ty_fn(_, ?ins, _, _, _)) {\n \n             // N-ary variant.\n@@ -1063,15 +1067,15 @@ mod writeback {\n         auto fcx = wbcx.fcx;\n         auto tpot = ty::node_id_to_ty_param_substs_opt_and_ty\n             (fcx.ccx.tcx, id);\n-        auto new_ty = alt (resolve_type_vars_in_type(fcx, sp, tpot._1)) {\n+        auto new_ty = alt (resolve_type_vars_in_type(fcx, sp, tpot.ty)) {\n             case (some(?t)) { t }\n             case (none) {\n                 wbcx.success = false;\n                 ret\n             }\n         };\n         auto new_substs_opt;\n-        alt (tpot._0) {\n+        alt (tpot.substs) {\n             case (none[ty::t[]]) { new_substs_opt = none[ty::t[]]; }\n             case (some[ty::t[]](?substs)) {\n                 let ty::t[] new_substs = ~[];\n@@ -1089,7 +1093,7 @@ mod writeback {\n                 new_substs_opt = some[ty::t[]](new_substs);\n             }\n         }\n-        write::ty(fcx.ccx.tcx, id, tup(new_substs_opt, new_ty));\n+        write::ty(fcx.ccx.tcx, id, rec(substs=new_substs_opt, ty=new_ty));\n     }\n \n     type wb_ctxt = rec(@fn_ctxt fcx,\n@@ -1291,23 +1295,6 @@ fn gather_locals(&@crate_ctxt ccx, &ast::_fn f,\n             next_var_id=*nvi);\n }\n \n-\n-// AST fragment utilities\n-fn replace_expr_type(&@fn_ctxt fcx, &@ast::expr expr,\n-                     &tup(ty::t[], ty::t) new_tyt) {\n-    auto new_tps;\n-    if (ty::expr_has_ty_params(fcx.ccx.tcx, expr)) {\n-        new_tps = some[ty::t[]](new_tyt._0);\n-    } else { new_tps = none; }\n-    write::ty_fixup(fcx, expr.id, tup(new_tps, new_tyt._1));\n-}\n-\n-// FIXME remove once std::ivec::find makes it into a snapshot\n-fn ivec_find[T](fn(&T) -> bool  f, &T[] v) -> option::t[T] {\n-    for (T elt in v) { if (f(elt)) { ret some[T](elt); } }\n-    ret none;\n-}\n-\n // AST fragment checking\n fn check_lit(@crate_ctxt ccx, &@ast::lit lit) -> ty::t {\n     alt (lit.node) {\n@@ -1353,7 +1340,7 @@ fn check_pat(&@fn_ctxt fcx, &ast::pat_id_map map, &@ast::pat pat,\n             // Typecheck the path.\n             auto v_def = lookup_def(fcx, path.span, pat.id);\n             auto v_def_ids = ast::variant_def_ids(v_def);\n-            auto tag_tpt = ty::lookup_item_type(fcx.ccx.tcx, v_def_ids._0);\n+            auto tag_tpt = ty::lookup_item_type(fcx.ccx.tcx, v_def_ids.tg);\n             auto path_tpot = instantiate_path(fcx, path, tag_tpt, pat.span);\n             // Take the tag type params out of `expected`.\n \n@@ -1368,11 +1355,12 @@ fn check_pat(&@fn_ctxt fcx, &ast::pat_id_map map, &@ast::pat pat,\n                 auto path_tpt =\n                     demand::full(fcx, pat.span, expected, ctor_ty,\n                                  expected_tps, NO_AUTODEREF);\n-                path_tpot = tup(some[ty::t[]](path_tpt._0), path_tpt._1);\n+                path_tpot = rec(substs=some[ty::t[]](path_tpt.substs),\n+                                ty=path_tpt.ty);\n                 // Get the number of arguments in this tag variant.\n \n                 auto arg_types =\n-                    variant_arg_types(fcx.ccx, pat.span, v_def_ids._1,\n+                    variant_arg_types(fcx.ccx, pat.span, v_def_ids.var,\n                                       expected_tps);\n                 auto subpats_len = std::ivec::len[@ast::pat](subpats);\n                 if (std::ivec::len[ty::t](arg_types) > 0u) {\n@@ -1453,7 +1441,7 @@ fn check_pat(&@fn_ctxt fcx, &ast::pat_id_map map, &@ast::pat pat,\n                 ret str::eq(name, f.ident);\n             }\n             for (ast::field_pat f in fields) {\n-                alt (ivec_find(bind matches(f.ident, _), ex_fields)) {\n+                alt (ivec::find(bind matches(f.ident, _), ex_fields)) {\n                     some(?field) {\n                         check_pat(fcx, map, f.pat, field.mt.ty);\n                     }\n@@ -1812,7 +1800,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                           \"this kind of value does not \\\n                                            take type parameters\");\n             }\n-            write::ty_only_fixup(fcx, id, tpt._1);\n+            write::ty_only_fixup(fcx, id, tpt.ty);\n         }\n         case (ast::expr_mac(_)) {\n             fcx.ccx.tcx.sess.bug(\"unexpanded macro\");\n@@ -2027,7 +2015,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto ty_of_arg = bind collect::ty_of_arg(cx, _);\n             auto fty =\n                 collect::ty_of_fn_decl(cx, convert, ty_of_arg, f.decl,\n-                                       f.proto, ~[], none)._1;\n+                                       f.proto, ~[], none).ty;\n             write::ty_only_fixup(fcx, id, fty);\n             check_fn(fcx.ccx, f, id);\n         }\n@@ -2128,11 +2116,11 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                     this_obj_sty =\n                                         some(structure_of(fcx,\n                                                           expr.span,\n-                                                          tpt._1));\n+                                                          tpt.ty));\n                                 }\n                                 case (none) {\n                                     fcx.ccx.tcx.sess.bug(\n-                                        \"didn't find \" + int::str(did._1) +\n+                                        \"didn't find \" + int::str(did.node) +\n                                         \" in type cache\");\n                                 }\n                             }"}, {"sha": "feba6b006c60e11a0ba22040842c139ae0e07840", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -26,11 +26,11 @@ fn path_name_i(&ident[] idents) -> str { str::connect_ivec(idents, \"::\") }\n \n type crate_num = int;\n type node_id = int;\n-type def_id = tup(crate_num, node_id);\n+type def_id = rec(crate_num crate, node_id node);\n \n const crate_num local_crate = 0;\n fn local_def(node_id id) -> def_id {\n-    ret tup(local_crate, id);\n+    ret rec(crate=local_crate, node=id);\n }\n \n type ty_param = ident;\n@@ -59,9 +59,11 @@ tag def {\n     def_upvar(def_id, @def);\n }\n \n-fn variant_def_ids(&def d) -> tup(def_id, def_id) {\n+fn variant_def_ids(&def d) -> rec(def_id tg, def_id var) {\n     alt (d) {\n-        case (def_variant(?tag_id, ?var_id)) { ret tup(tag_id, var_id); }\n+        case (def_variant(?tag_id, ?var_id)) {\n+          ret rec(tg=tag_id, var=var_id);\n+        }\n     }\n }\n "}, {"sha": "ac970c649618ae3eadc60d82655fed08e8211436", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -8,8 +8,9 @@ import codemap;\n \n type syntax_expander =\n     fn(&ext_ctxt, span, &(@ast::expr)[], option::t[str]) -> @ast::expr;\n+type macro_def = rec(str ident, syntax_extension ext);\n type macro_definer = fn(&ext_ctxt, span, &(@ast::expr)[],\n-                        option::t[str]) -> tup(str, syntax_extension);\n+                        option::t[str]) -> macro_def;\n \n tag syntax_extension {\n     normal(syntax_expander);"}, {"sha": "3cff1cba5e2613090aeb3bd1f2bbd01b9781d04a", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -38,8 +38,8 @@ fn expand_expr(&hashmap[str, base::syntax_extension] exts,\n                         case (some(base::macro_defining(?ext))) {\n                             auto named_extension\n                                 = ext(ext_cx, pth.span, args, body);\n-                            exts.insert(named_extension._0,\n-                                        named_extension._1);\n+                            exts.insert(named_extension.ident,\n+                                        named_extension.ext);\n                             ast::expr_tup(~[])\n                         }\n                     }"}, {"sha": "b69b27f5ef425c5544b06bdc08e9d134787f10d0", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -80,11 +80,12 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n         ret @rec(id=cx.next_id(), node=callexpr, span=sp);\n     }\n     fn make_rec_expr(&ext_ctxt cx, span sp,\n-                     vec[tup(ast::ident, @ast::expr)] fields) -> @ast::expr {\n+                     vec[rec(ast::ident ident, @ast::expr ex)] fields)\n+        -> @ast::expr {\n         let ast::field[] astfields = ~[];\n-        for (tup(ast::ident, @ast::expr) field in fields) {\n-            auto ident = field._0;\n-            auto val = field._1;\n+        for (rec(ast::ident ident, @ast::expr ex) field in fields) {\n+            auto ident = field.ident;\n+            auto val = field.ex;\n             auto astfield =\n                 rec(node=rec(mut=ast::imm, ident=ident, expr=val), span=sp);\n             astfields += ~[astfield];\n@@ -173,10 +174,10 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n                          @ast::expr width_expr, @ast::expr precision_expr,\n                          @ast::expr ty_expr) -> @ast::expr {\n             ret make_rec_expr(cx, sp,\n-                              [tup(\"flags\", flags_expr),\n-                               tup(\"width\", width_expr),\n-                               tup(\"precision\", precision_expr),\n-                               tup(\"ty\", ty_expr)]);\n+                              [rec(ident=\"flags\", ex=flags_expr),\n+                               rec(ident=\"width\", ex=width_expr),\n+                               rec(ident=\"precision\", ex=precision_expr),\n+                               rec(ident=\"ty\", ex=ty_expr)]);\n         }\n         auto rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         auto rt_conv_width = make_count(cx, sp, cnv.width);"}, {"sha": "95cbb069c25c4ac99b54557d9ebad3b84ac20f75", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -191,10 +191,11 @@ selectors. */\n fn use_selectors_to_bind(&binders b, @expr e) -> option::t[bindings] {\n     auto res = new_str_hash[arb_depth[matchable]]();\n     let bool never_mind = false;\n-    for each(@tup(ident, selector) pair in b.real_binders.items()) {\n-        alt (pair._1(match_expr(e))) {\n+    for each(@rec(ident key, selector val) pair\n+             in b.real_binders.items()) {\n+        alt (pair.val(match_expr(e))) {\n           case (none) { never_mind = true; }\n-          case (some(?mtc)) { res.insert(pair._0, mtc); }\n+          case (some(?mtc)) { res.insert(pair.key, mtc); }\n         }\n     }\n     if (never_mind) { ret none; } //HACK: `ret` doesn't work in `for each`\n@@ -274,9 +275,7 @@ iter free_vars(&bindings b, @expr e) -> ident {\n     auto f = make_fold(f_pre);\n     f.fold_expr(e); // ignore result\n     dummy_out(f);\n-    for each(@tup(ast::ident, ()) it in idents.items()) {\n-        put it._0;\n-    }\n+    for each(ident id in idents.keys()) { put id; }\n }\n \n \n@@ -546,7 +545,7 @@ fn p_t_s_r_actual_vector(&ext_ctxt cx, (@expr)[] elts, &selector s,\n }\n \n fn add_new_extension(&ext_ctxt cx, span sp, &(@expr)[] args,\n-                     option::t[str] body) -> tup(str, syntax_extension) {\n+                     option::t[str] body) -> base::macro_def {\n     let option::t[str] macro_name = none;\n     let (clause)[] clauses = ~[];\n     for (@expr arg in args) {\n@@ -596,14 +595,13 @@ fn add_new_extension(&ext_ctxt cx, span sp, &(@expr)[] args,\n \n     auto ext = bind generic_extension(_,_,_,_,clauses);\n \n-    ret tup(alt (macro_name) {\n+    ret rec(ident=alt (macro_name) {\n       case (some(?id)) { id }\n       case (none) {\n         cx.span_fatal(sp, \"macro definition must have \"\n                       + \"at least one clause\")\n       }\n-    },\n-            normal(ext));\n+    }, ext=normal(ext));\n \n \n     fn generic_extension(&ext_ctxt cx, span sp, &(@expr)[] args,\n@@ -620,9 +618,9 @@ fn add_new_extension(&ext_ctxt cx, span sp, &(@expr)[] args,\n                 alt (use_selectors_to_bind(c.params.(i), args.(i))) {\n                   case (some(?new_bindings)) {\n                     /* ick; I wish macros just took one expr */\n-                    for each (@tup(ident,arb_depth[matchable]) it\n+                    for each (@rec(ident key, arb_depth[matchable] val) it\n                               in new_bindings.items()) {\n-                        bdgs.insert(it._0, it._1);\n+                        bdgs.insert(it.key, it.val);\n                     }\n                   }\n                   case (none) { abort = true; }"}, {"sha": "6f551b929436ba187f99da37107c19242c52c712", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -60,8 +60,8 @@ fn eval_crate_directive(ctx cx, @ast::crate_directive cdir, str prefix,\n                 new_parser_from_file(cx.sess, cx.cfg, full_path, cx.chpos,\n                                      cx.byte_pos);\n             auto inner_attrs = parse_inner_attrs_and_next(p0);\n-            auto mod_attrs = attrs + inner_attrs._0;\n-            auto first_item_outer_attrs = inner_attrs._1;\n+            auto mod_attrs = attrs + inner_attrs.inner;\n+            auto first_item_outer_attrs = inner_attrs.next;\n             auto m0 = parse_mod_items(p0, token::EOF, first_item_outer_attrs);\n \n             auto i = syntax::parse::parser::mk_item"}, {"sha": "07a079232752e315526353cbbbf592be7bc131b3", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -57,8 +57,8 @@ fn new_reader(&codemap::codemap cm, str src, codemap::filemap filemap,\n         fn init() {\n             if (pos < len) {\n                 auto next = str::char_range_at(src, pos);\n-                pos = next._1;\n-                ch = next._0;\n+                pos = next.next;\n+                ch = next.ch;\n             }\n         }\n         fn bump() {\n@@ -70,8 +70,8 @@ fn new_reader(&codemap::codemap cm, str src, codemap::filemap filemap,\n                     col = 0u;\n                 }\n                 auto next = str::char_range_at(src, pos);\n-                pos = next._1;\n-                ch = next._0;\n+                pos = next.next;\n+                ch = next.ch;\n             } else { ch = -1 as char; }\n         }\n         fn get_interner() -> @interner::interner[str] { ret itr; }\n@@ -338,13 +338,13 @@ fn scan_numeric_escape(&reader rdr, uint n_hex_digits) -> char {\n     ret accum_int as char;\n }\n \n-fn next_token(&reader rdr) -> tup(token::token, uint, uint) {\n+fn next_token(&reader rdr) -> rec(token::token tok, uint chpos, uint bpos) {\n     consume_whitespace_and_comments(rdr);\n     auto start_chpos = rdr.get_chpos();\n     auto start_bpos = rdr.get_byte_pos();\n     auto tok = if rdr.is_eof() { token::EOF }\n                else { next_token_inner(rdr) };\n-    ret tup(tok, start_chpos, start_bpos);\n+    ret rec(tok=tok, chpos=start_chpos, bpos=start_bpos);\n }\n \n fn next_token_inner(&reader rdr) -> token::token {\n@@ -768,10 +768,10 @@ fn gather_comments_and_literals(&codemap::codemap cm, str path,\n             break;\n         }\n         auto tok = next_token(rdr);\n-        if (is_lit(tok._0)) {\n-            literals += ~[rec(lit=rdr.get_str_from(tok._2), pos=tok._1)];\n+        if (is_lit(tok.tok)) {\n+            literals += ~[rec(lit=rdr.get_str_from(tok.bpos), pos=tok.chpos)];\n         }\n-        log \"tok: \" + token::to_str(rdr, tok._0);\n+        log \"tok: \" + token::to_str(rdr, tok.tok);\n         first_read = false;\n     }\n     ret rec(cmnts=comments, lits=literals);"}, {"sha": "43f8a62b23d39544db71fdcdbad21d83f257be40", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -81,7 +81,7 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n                      mutable token::token tok,\n                      mutable span tok_span,\n                      mutable span last_tok_span,\n-                     mutable tup(token::token, span)[] buffer,\n+                     mutable rec(token::token tok, span span)[] buffer,\n                      mutable restriction restr,\n                      lexer::reader rdr,\n                      @op_spec[] precs,\n@@ -91,21 +91,21 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n             last_tok_span = tok_span;\n             if ivec::len(buffer) == 0u {\n                 auto next = lexer::next_token(rdr);\n-                tok = next._0;\n-                tok_span = rec(lo=next._1, hi=rdr.get_chpos());\n+                tok = next.tok;\n+                tok_span = rec(lo=next.chpos, hi=rdr.get_chpos());\n             } else {\n                 auto next = ivec::pop(buffer);\n-                tok = next._0;\n-                tok_span = next._1;\n+                tok = next.tok;\n+                tok_span = next.span;\n             }\n         }\n         fn look_ahead(uint distance) -> token::token {\n             while ivec::len(buffer) < distance {\n                 auto next = lexer::next_token(rdr);\n-                auto sp = rec(lo=next._1, hi=rdr.get_chpos());\n-                buffer = ~[tup(next._0, sp)] + buffer;\n+                auto sp = rec(lo=next.chpos, hi=rdr.get_chpos());\n+                buffer = ~[rec(tok=next.tok, span=sp)] + buffer;\n             }\n-            ret buffer.(distance-1u)._0;\n+            ret buffer.(distance-1u).tok;\n         }\n         fn fatal(str m) -> ! {\n             codemap::emit_error(some(self.get_span()), m, sess.cm);\n@@ -137,8 +137,8 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n     }\n \n     auto tok0 = lexer::next_token(rdr);\n-    auto span0 = rec(lo=tok0._1, hi=rdr.get_chpos());\n-    ret stdio_parser(sess, cfg, ftype, tok0._0,\n+    auto span0 = rec(lo=tok0.chpos, hi=rdr.get_chpos());\n+    ret stdio_parser(sess, cfg, ftype, tok0.tok,\n                      span0, span0, ~[], UNRESTRICTED, rdr,\n                      prec_table(), bad_expr_word_table());\n }\n@@ -1307,9 +1307,10 @@ fn parse_assign_expr(&parser p) -> @ast::expr {\n     ret lhs;\n }\n \n-fn parse_if_expr_1(&parser p) -> tup(@ast::expr,\n-                                     ast::blk, option::t[@ast::expr],\n-                                     uint, uint) {\n+fn parse_if_expr_1(&parser p) -> rec(@ast::expr cond,\n+                                     ast::blk then,\n+                                     option::t[@ast::expr] els,\n+                                     uint lo, uint hi) {\n     auto lo = p.get_last_lo_pos();\n     auto cond = parse_expr(p);\n     auto thn = parse_block(p);\n@@ -1320,17 +1321,18 @@ fn parse_if_expr_1(&parser p) -> tup(@ast::expr,\n         els = some(elexpr);\n         hi = elexpr.span.hi;\n     }\n-    ret tup(cond, thn, els, lo, hi);\n+    ret rec(cond=cond, then=thn, els=els, lo=lo, hi=hi);\n }\n \n fn parse_if_expr(&parser p) -> @ast::expr {\n     if (eat_word(p, \"check\")) {\n             auto q = parse_if_expr_1(p);\n-            ret mk_expr(p, q._3, q._4, ast::expr_if_check(q._0, q._1, q._2));\n+            ret mk_expr(p, q.lo, q.hi,\n+                        ast::expr_if_check(q.cond, q.then, q.els));\n     }\n     else {\n         auto q = parse_if_expr_1(p);\n-        ret mk_expr(p, q._3, q._4, ast::expr_if(q._0, q._1, q._2));\n+        ret mk_expr(p, q.lo, q.hi, ast::expr_if(q.cond, q.then, q.els));\n     }\n }\n \n@@ -1894,10 +1896,10 @@ fn parse_fn(&parser p, ast::proto proto, ast::purity purity) -> ast::_fn {\n     ret rec(decl=decl, proto=proto, body=body);\n }\n \n-fn parse_fn_header(&parser p) -> tup(ast::ident, ast::ty_param[]) {\n+fn parse_fn_header(&parser p) -> rec(ast::ident ident, ast::ty_param[] tps) {\n     auto id = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n-    ret tup(id, ty_params);\n+    ret rec(ident=id, tps=ty_params);\n }\n \n fn mk_item(&parser p, uint lo, uint hi, &ast::ident ident, &ast::item_ node,\n@@ -1914,7 +1916,8 @@ fn parse_item_fn_or_iter(&parser p, ast::purity purity, ast::proto proto,\n     auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n     auto f = parse_fn(p, proto, purity);\n-    ret mk_item(p, lo, f.body.span.hi, t._0, ast::item_fn(f, t._1), attrs);\n+    ret mk_item(p, lo, f.body.span.hi, t.ident,\n+                ast::item_fn(f, t.tps), attrs);\n }\n \n fn parse_obj_field(&parser p) -> ast::obj_field {\n@@ -2045,23 +2048,23 @@ fn parse_item_mod(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     auto id = parse_ident(p);\n     expect(p, token::LBRACE);\n     auto inner_attrs = parse_inner_attrs_and_next(p);\n-    auto first_item_outer_attrs = inner_attrs._1;\n+    auto first_item_outer_attrs = inner_attrs.next;\n     auto m = parse_mod_items(p, token::RBRACE, first_item_outer_attrs);\n     auto hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n-    ret mk_item(p, lo, hi, id, ast::item_mod(m), attrs + inner_attrs._0);\n+    ret mk_item(p, lo, hi, id, ast::item_mod(m), attrs + inner_attrs.inner);\n }\n \n fn parse_item_native_type(&parser p, &ast::attribute[] attrs)\n         -> @ast::native_item {\n     auto t = parse_type_decl(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    ret @rec(ident=t._1,\n+    ret @rec(ident=t.ident,\n              attrs=attrs,\n              node=ast::native_item_ty,\n              id=p.get_id(),\n-             span=rec(lo=t._0, hi=hi));\n+             span=rec(lo=t.lo, hi=hi));\n }\n \n fn parse_item_native_fn(&parser p, &ast::attribute[] attrs)\n@@ -2076,9 +2079,9 @@ fn parse_item_native_fn(&parser p, &ast::attribute[] attrs)\n     }\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    ret @rec(ident=t._0,\n+    ret @rec(ident=t.ident,\n              attrs=attrs,\n-             node=ast::native_item_fn(link_name, decl, t._1),\n+             node=ast::native_item_fn(link_name, decl, t.tps),\n              id=p.get_id(),\n              span=rec(lo=lo, hi=hi));\n }\n@@ -2142,19 +2145,19 @@ fn parse_item_native_mod(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     }\n     expect(p, token::LBRACE);\n     auto more_attrs = parse_inner_attrs_and_next(p);\n-    auto inner_attrs = more_attrs._0;\n-    auto first_item_outer_attrs = more_attrs._1;\n+    auto inner_attrs = more_attrs.inner;\n+    auto first_item_outer_attrs = more_attrs.next;\n     auto m = parse_native_mod_items(p, native_name, abi,\n                                     first_item_outer_attrs);\n     auto hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n     ret mk_item(p, lo, hi, id, ast::item_native_mod(m), attrs + inner_attrs);\n }\n \n-fn parse_type_decl(&parser p) -> tup(uint, ast::ident) {\n+fn parse_type_decl(&parser p) -> rec(uint lo, ast::ident ident) {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n-    ret tup(lo, id);\n+    ret rec(lo=lo, ident=id);\n }\n \n fn parse_item_type(&parser p, &ast::attribute[] attrs) -> @ast::item {\n@@ -2164,7 +2167,7 @@ fn parse_item_type(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     auto ty = parse_ty(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    ret mk_item(p, t._0, hi, t._1, ast::item_ty(ty, tps), attrs);\n+    ret mk_item(p, t.lo, hi, t.ident, ast::item_ty(ty, tps), attrs);\n }\n \n fn parse_item_tag(&parser p, &ast::attribute[] attrs) -> @ast::item {\n@@ -2330,8 +2333,8 @@ fn parse_attribute_naked(&parser p, ast::attr_style style,\n // next item (since we can't know whether the attribute is an inner attribute\n // of the containing item or an outer attribute of the first contained item\n // until we see the semi).\n-fn parse_inner_attrs_and_next(&parser p) -> tup(ast::attribute[],\n-                                                ast::attribute[]) {\n+fn parse_inner_attrs_and_next(&parser p) -> rec(ast::attribute[] inner,\n+                                                ast::attribute[] next) {\n     let ast::attribute[] inner_attrs = ~[];\n     let ast::attribute[] next_outer_attrs = ~[];\n     while (p.peek() == token::POUND) {\n@@ -2349,7 +2352,7 @@ fn parse_inner_attrs_and_next(&parser p) -> tup(ast::attribute[],\n             break;\n         }\n     }\n-    ret tup(inner_attrs, next_outer_attrs);\n+    ret rec(inner=inner_attrs, next=next_outer_attrs);\n }\n \n fn parse_meta_item(&parser p) -> @ast::meta_item {\n@@ -2527,12 +2530,12 @@ fn parse_crate_mod(&parser p, &ast::crate_cfg cfg, parse_sess sess)\n     -> @ast::crate {\n     auto lo = p.get_lo_pos();\n     auto crate_attrs = parse_inner_attrs_and_next(p);\n-    auto first_item_outer_attrs = crate_attrs._1;\n+    auto first_item_outer_attrs = crate_attrs.next;\n     auto m = parse_mod_items(p, token::EOF,\n                              first_item_outer_attrs);\n     ret @spanned(lo, p.get_lo_pos(), rec(directives=~[],\n                                          module=m,\n-                                         attrs=crate_attrs._0,\n+                                         attrs=crate_attrs.inner,\n                                          config=p.get_cfg()));\n }\n \n@@ -2585,8 +2588,8 @@ fn parse_crate_directive(&parser p, &ast::attribute[] first_outer_attr)\n                  token::LBRACE) {\n                 p.bump();\n                 auto inner_attrs = parse_inner_attrs_and_next(p);\n-                auto mod_attrs = outer_attrs + inner_attrs._0;\n-                auto next_outer_attr = inner_attrs._1;\n+                auto mod_attrs = outer_attrs + inner_attrs.inner;\n+                auto next_outer_attr = inner_attrs.next;\n                 auto cdirs = parse_crate_directives(p, token::RBRACE,\n                                                     next_outer_attr);\n                 auto hi = p.get_hi_pos();\n@@ -2636,8 +2639,8 @@ fn parse_crate_from_crate_file(&str input, &ast::crate_cfg cfg,\n     auto lo = p.get_lo_pos();\n     auto prefix = std::fs::dirname(p.get_filemap().name);\n     auto leading_attrs = parse_inner_attrs_and_next(p);\n-    auto crate_attrs = leading_attrs._0;\n-    auto first_cdir_attr = leading_attrs._1;\n+    auto crate_attrs = leading_attrs.inner;\n+    auto first_cdir_attr = leading_attrs.next;\n     auto cdirs = parse_crate_directives(p, token::EOF, first_cdir_attr);\n     let str[] deps = ~[];\n     auto cx = @rec(p=p,"}, {"sha": "3ffef690334e0c9f077a62b9e7e7bb5348b6dd6f", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -31,13 +31,13 @@ import print::pp::mk_printer;\n type flag = hashmap[str, ()];\n \n fn def_eq(&ast::def_id a, &ast::def_id b) -> bool {\n-    ret a._0 == b._0 && a._1 == b._1;\n+    ret a.crate == b.crate && a.node == b.node;\n }\n \n fn hash_def(&ast::def_id d) -> uint {\n     auto h = 5381u;\n-    h = (h << 5u) + h ^ (d._0 as uint);\n-    h = (h << 5u) + h ^ (d._1 as uint);\n+    h = (h << 5u) + h ^ (d.crate as uint);\n+    h = (h << 5u) + h ^ (d.node as uint);\n     ret h;\n }\n "}, {"sha": "41209a11602eae3c4bd2f7c28c1913a1f8ef422c", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -116,7 +116,7 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         case (ty_tag(?id, ?tps)) {\n             // The user should never see this if the cname is set properly!\n \n-            s += \"<tag#\" + int::str(id._0) + \":\" + int::str(id._1) + \">\";\n+            s += \"<tag#\" + int::str(id.crate) + \":\" + int::str(id.node) + \">\";\n             if (ivec::len[t](tps) > 0u) {\n                 let str[] strs = ~[];\n                 for (t typ in tps) { strs += ~[ty_to_str(cx, typ)]; }\n@@ -136,7 +136,8 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             s += \"obj {\\n\\t\" + str::connect_ivec(strs, \"\\n\\t\") + \"\\n}\";\n         }\n         case (ty_res(?id, _, _)) {\n-            s += \"<resource#\" + int::str(id._0) + \":\" + int::str(id._1) + \">\";\n+            s += \"<resource#\" + int::str(id.node) + \":\" +\n+                int::str(id.crate) + \">\";\n         }\n         case (ty_var(?v)) { s += \"<T\" + int::str(v) + \">\"; }\n         case (ty_param(?id)) {"}, {"sha": "c61d2a27dab4a219b2faf143c158ce4412865a35", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -17,21 +17,25 @@ type ebml_state = rec(ebml_tag ebml_tag, uint tag_pos, uint data_pos);\n // ebml reading\n type doc = rec(vec[u8] data, uint start, uint end);\n \n-fn vint_at(vec[u8] data, uint start) -> tup(uint, uint) {\n+fn vint_at(vec[u8] data, uint start) -> rec(uint val, uint next) {\n     auto a = data.(start);\n-    if (a & 0x80u8 != 0u8) { ret tup(a & 0x7fu8 as uint, start + 1u); }\n+    if (a & 0x80u8 != 0u8) {\n+        ret rec(val=a & 0x7fu8 as uint, next=start + 1u);\n+    }\n     if (a & 0x40u8 != 0u8) {\n-        ret tup((a & 0x3fu8 as uint) << 8u | (data.(start + 1u) as uint),\n-                start + 2u);\n+        ret rec(val=(a & 0x3fu8 as uint) << 8u | (data.(start + 1u) as uint),\n+                next=start + 2u);\n     } else if (a & 0x20u8 != 0u8) {\n-        ret tup((a & 0x1fu8 as uint) << 16u |\n+        ret rec(val=(a & 0x1fu8 as uint) << 16u |\n                     (data.(start + 1u) as uint) << 8u |\n-                    (data.(start + 2u) as uint), start + 3u);\n+                    (data.(start + 2u) as uint),\n+                next=start + 3u);\n     } else if (a & 0x10u8 != 0u8) {\n-        ret tup((a & 0x0fu8 as uint) << 24u |\n+        ret rec(val=(a & 0x0fu8 as uint) << 24u |\n                     (data.(start + 1u) as uint) << 16u |\n                     (data.(start + 2u) as uint) << 8u |\n-                    (data.(start + 3u) as uint), start + 4u);\n+                    (data.(start + 3u) as uint),\n+                next=start + 4u);\n     } else { log_err \"vint too big\"; fail; }\n }\n \n@@ -41,19 +45,19 @@ fn new_doc(vec[u8] data) -> doc {\n \n fn doc_at(vec[u8] data, uint start) -> doc {\n     auto elt_tag = vint_at(data, start);\n-    auto elt_size = vint_at(data, elt_tag._1);\n-    auto end = elt_size._1 + elt_size._0;\n-    ret rec(data=data, start=elt_size._1, end=end);\n+    auto elt_size = vint_at(data, elt_tag.next);\n+    auto end = elt_size.next + elt_size.val;\n+    ret rec(data=data, start=elt_size.next, end=end);\n }\n \n fn maybe_get_doc(doc d, uint tg) -> option::t[doc] {\n     auto pos = d.start;\n     while (pos < d.end) {\n         auto elt_tag = vint_at(d.data, pos);\n-        auto elt_size = vint_at(d.data, elt_tag._1);\n-        pos = elt_size._1 + elt_size._0;\n-        if (elt_tag._0 == tg) {\n-            ret some[doc](rec(data=d.data, start=elt_size._1, end=pos));\n+        auto elt_size = vint_at(d.data, elt_tag.next);\n+        pos = elt_size.next + elt_size.val;\n+        if (elt_tag.val == tg) {\n+            ret some[doc](rec(data=d.data, start=elt_size.next, end=pos));\n         }\n     }\n     ret none[doc];\n@@ -69,24 +73,25 @@ fn get_doc(doc d, uint tg) -> doc {\n     }\n }\n \n-iter docs(doc d) -> tup(uint, doc) {\n+iter docs(doc d) -> rec(uint tag, doc doc) {\n     auto pos = d.start;\n     while (pos < d.end) {\n         auto elt_tag = vint_at(d.data, pos);\n-        auto elt_size = vint_at(d.data, elt_tag._1);\n-        pos = elt_size._1 + elt_size._0;\n-        put tup(elt_tag._0, rec(data=d.data, start=elt_size._1, end=pos));\n+        auto elt_size = vint_at(d.data, elt_tag.next);\n+        pos = elt_size.next + elt_size.val;\n+        put rec(tag=elt_tag.val,\n+                doc=rec(data=d.data, start=elt_size.next, end=pos));\n     }\n }\n \n iter tagged_docs(doc d, uint tg) -> doc {\n     auto pos = d.start;\n     while (pos < d.end) {\n         auto elt_tag = vint_at(d.data, pos);\n-        auto elt_size = vint_at(d.data, elt_tag._1);\n-        pos = elt_size._1 + elt_size._0;\n-        if (elt_tag._0 == tg) {\n-            put rec(data=d.data, start=elt_size._1, end=pos);\n+        auto elt_size = vint_at(d.data, elt_tag.next);\n+        pos = elt_size.next + elt_size.val;\n+        if (elt_tag.val == tg) {\n+            put rec(data=d.data, start=elt_size.next, end=pos);\n         }\n     }\n }"}, {"sha": "92b33bd586b99d8f7c98b8332b55e43fff7913fe", "filename": "src/lib/ebmlivec.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Febmlivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Febmlivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febmlivec.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -17,21 +17,25 @@ type ebml_state = rec(ebml_tag ebml_tag, uint tag_pos, uint data_pos);\n // ebml reading\n type doc = rec(@u8[] data, uint start, uint end);\n \n-fn vint_at(&u8[] data, uint start) -> tup(uint, uint) {\n+fn vint_at(&u8[] data, uint start) -> rec(uint val, uint next) {\n     auto a = data.(start);\n-    if (a & 0x80u8 != 0u8) { ret tup(a & 0x7fu8 as uint, start + 1u); }\n+    if (a & 0x80u8 != 0u8) {\n+        ret rec(val=a & 0x7fu8 as uint, next=start + 1u);\n+    }\n     if (a & 0x40u8 != 0u8) {\n-        ret tup((a & 0x3fu8 as uint) << 8u | (data.(start + 1u) as uint),\n-                start + 2u);\n+        ret rec(val=(a & 0x3fu8 as uint) << 8u | (data.(start + 1u) as uint),\n+                next=start + 2u);\n     } else if (a & 0x20u8 != 0u8) {\n-        ret tup((a & 0x1fu8 as uint) << 16u |\n+        ret rec(val=(a & 0x1fu8 as uint) << 16u |\n                     (data.(start + 1u) as uint) << 8u |\n-                    (data.(start + 2u) as uint), start + 3u);\n+                    (data.(start + 2u) as uint),\n+                next=start + 3u);\n     } else if (a & 0x10u8 != 0u8) {\n-        ret tup((a & 0x0fu8 as uint) << 24u |\n+        ret rec(val=(a & 0x0fu8 as uint) << 24u |\n                     (data.(start + 1u) as uint) << 16u |\n                     (data.(start + 2u) as uint) << 8u |\n-                    (data.(start + 3u) as uint), start + 4u);\n+                    (data.(start + 3u) as uint),\n+                next=start + 4u);\n     } else { log_err \"vint too big\"; fail; }\n }\n \n@@ -41,19 +45,19 @@ fn new_doc(&@u8[] data) -> doc {\n \n fn doc_at(&@u8[] data, uint start) -> doc {\n     auto elt_tag = vint_at(*data, start);\n-    auto elt_size = vint_at(*data, elt_tag._1);\n-    auto end = elt_size._1 + elt_size._0;\n-    ret rec(data=data, start=elt_size._1, end=end);\n+    auto elt_size = vint_at(*data, elt_tag.next);\n+    auto end = elt_size.next + elt_size.val;\n+    ret rec(data=data, start=elt_size.next, end=end);\n }\n \n fn maybe_get_doc(doc d, uint tg) -> option::t[doc] {\n     auto pos = d.start;\n     while (pos < d.end) {\n         auto elt_tag = vint_at(*d.data, pos);\n-        auto elt_size = vint_at(*d.data, elt_tag._1);\n-        pos = elt_size._1 + elt_size._0;\n-        if (elt_tag._0 == tg) {\n-            ret some[doc](rec(data=d.data, start=elt_size._1, end=pos));\n+        auto elt_size = vint_at(*d.data, elt_tag.next);\n+        pos = elt_size.next + elt_size.val;\n+        if (elt_tag.val == tg) {\n+            ret some[doc](rec(data=d.data, start=elt_size.next, end=pos));\n         }\n     }\n     ret none[doc];\n@@ -69,24 +73,25 @@ fn get_doc(doc d, uint tg) -> doc {\n     }\n }\n \n-iter docs(doc d) -> tup(uint, doc) {\n+iter docs(doc d) -> rec(uint tag, doc doc) {\n     auto pos = d.start;\n     while (pos < d.end) {\n         auto elt_tag = vint_at(*d.data, pos);\n-        auto elt_size = vint_at(*d.data, elt_tag._1);\n-        pos = elt_size._1 + elt_size._0;\n-        put tup(elt_tag._0, rec(data=d.data, start=elt_size._1, end=pos));\n+        auto elt_size = vint_at(*d.data, elt_tag.next);\n+        pos = elt_size.next + elt_size.val;\n+        put rec(tag=elt_tag.val,\n+                doc=rec(data=d.data, start=elt_size.next, end=pos));\n     }\n }\n \n iter tagged_docs(doc d, uint tg) -> doc {\n     auto pos = d.start;\n     while (pos < d.end) {\n         auto elt_tag = vint_at(*d.data, pos);\n-        auto elt_size = vint_at(*d.data, elt_tag._1);\n-        pos = elt_size._1 + elt_size._0;\n-        if (elt_tag._0 == tg) {\n-            put rec(data=d.data, start=elt_size._1, end=pos);\n+        auto elt_size = vint_at(*d.data, elt_tag.next);\n+        pos = elt_size.next + elt_size.val;\n+        if (elt_tag.val == tg) {\n+            put rec(data=d.data, start=elt_size.next, end=pos);\n         }\n     }\n }"}, {"sha": "c62a8e79fec1acd752e1ce0b1eae1de2a90ef307", "filename": "src/lib/either.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -38,7 +38,8 @@ fn rights[T, U](&(t[T, U])[] eithers) -> U[] {\n     ret result;\n }\n \n-fn partition[T, U](&(t[T, U])[] eithers) -> tup(T[], U[]) {\n+fn partition[T, U](&(t[T, U])[] eithers)\n+    -> rec(T[] lefts, U[] rights) {\n     let T[] lefts = ~[];\n     let U[] rights = ~[];\n     for (t[T, U] elt in eithers) {\n@@ -47,7 +48,7 @@ fn partition[T, U](&(t[T, U])[] eithers) -> tup(T[], U[]) {\n             case (right(?r)) { rights += ~[r] }\n         }\n     }\n-    ret tup(lefts, rights);\n+    ret rec(lefts=lefts, rights=rights);\n }\n //\n // Local Variables:"}, {"sha": "ca1d82608712d7d95e6ed7e5a373996efaed6b66", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -96,66 +96,71 @@ mod ct {\n                 } else {\n                     buf = flush_buf(buf, pieces);\n                     auto rs = parse_conversion(s, i, lim, error);\n-                    pieces += [rs._0];\n-                    i = rs._1;\n+                    pieces += [rs.piece];\n+                    i = rs.next;\n                 }\n             } else { buf += curr; i += 1u; }\n         }\n         buf = flush_buf(buf, pieces);\n         ret pieces;\n     }\n-    fn peek_num(str s, uint i, uint lim) -> option::t[tup(uint, uint)] {\n-        if (i >= lim) { ret none[tup(uint, uint)]; }\n+    fn peek_num(str s, uint i, uint lim)\n+        -> option::t[rec(uint num, uint next)] {\n+        if (i >= lim) { ret none; }\n         auto c = s.(i);\n         if (!('0' as u8 <= c && c <= '9' as u8)) {\n-            ret option::none[tup(uint, uint)];\n+            ret option::none;\n         }\n         auto n = c - ('0' as u8) as uint;\n         ret alt (peek_num(s, i + 1u, lim)) {\n-                case (none) { some[tup(uint, uint)](tup(n, i + 1u)) }\n+                case (none) { some(rec(num=n, next=i + 1u)) }\n                 case (some(?next)) {\n-                    auto m = next._0;\n-                    auto j = next._1;\n-                    some[tup(uint, uint)](tup(n * 10u + m, j))\n+                    auto m = next.num;\n+                    auto j = next.next;\n+                    some(rec(num=n * 10u + m, next=j))\n                 }\n             };\n     }\n-    fn parse_conversion(str s, uint i, uint lim, error_fn error) ->\n-       tup(piece, uint) {\n+    fn parse_conversion(str s, uint i, uint lim, error_fn error)\n+        -> rec(piece piece, uint next) {\n         auto parm = parse_parameter(s, i, lim);\n-        auto flags = parse_flags(s, parm._1, lim);\n-        auto width = parse_count(s, flags._1, lim);\n-        auto prec = parse_precision(s, width._1, lim);\n-        auto ty = parse_type(s, prec._1, lim, error);\n-        ret tup(piece_conv(rec(param=parm._0,\n-                               flags=flags._0,\n-                               width=width._0,\n-                               precision=prec._0,\n-                               ty=ty._0)), ty._1);\n+        auto flags = parse_flags(s, parm.next, lim);\n+        auto width = parse_count(s, flags.next, lim);\n+        auto prec = parse_precision(s, width.next, lim);\n+        auto ty = parse_type(s, prec.next, lim, error);\n+        ret rec(piece=piece_conv(rec(param=parm.param,\n+                                     flags=flags.flags,\n+                                     width=width.count,\n+                                     precision=prec.count,\n+                                     ty=ty.ty)),\n+                next=ty.next);\n     }\n-    fn parse_parameter(str s, uint i, uint lim) -> tup(option::t[int], uint) {\n-        if (i >= lim) { ret tup(none[int], i); }\n+    fn parse_parameter(str s, uint i, uint lim)\n+        -> rec(option::t[int] param, uint next) {\n+        if (i >= lim) { ret rec(param=none, next=i); }\n         auto num = peek_num(s, i, lim);\n         ret alt (num) {\n-                case (none) { tup(none[int], i) }\n+                case (none) { rec(param=none, next=i) }\n                 case (some(?t)) {\n-                    auto n = t._0;\n-                    auto j = t._1;\n+                    auto n = t.num;\n+                    auto j = t.next;\n                     if (j < lim && s.(j) == '$' as u8) {\n-                        tup(some[int](n as int), j + 1u)\n-                    } else { tup(none[int], i) }\n+                        rec(param=some(n as int), next=j + 1u)\n+                    } else { rec(param=none, next=i) }\n                 }\n             };\n     }\n-    fn parse_flags(str s, uint i, uint lim) -> tup(vec[flag], uint) {\n+    fn parse_flags(str s, uint i, uint lim)\n+        -> rec(vec[flag] flags, uint next) {\n         let vec[flag] noflags = [];\n-        if (i >= lim) { ret tup(noflags, i); }\n-        fn more_(flag f, str s, uint i, uint lim) -> tup(vec[flag], uint) {\n+        if (i >= lim) { ret rec(flags=noflags, next=i); }\n+        fn more_(flag f, str s, uint i, uint lim)\n+            -> rec(vec[flag] flags, uint next) {\n             auto next = parse_flags(s, i + 1u, lim);\n-            auto rest = next._0;\n-            auto j = next._1;\n+            auto rest = next.flags;\n+            auto j = next.next;\n             let vec[flag] curr = [f];\n-            ret tup(curr + rest, j);\n+            ret rec(flags=curr + rest, next=j);\n         }\n         auto more = bind more_(_, s, i, lim);\n         auto f = s.(i);\n@@ -169,41 +174,46 @@ mod ct {\n                 more(flag_sign_always)\n             } else if (f == '#' as u8) {\n                 more(flag_alternate)\n-            } else { tup(noflags, i) };\n+            } else { rec(flags=noflags, next=i) };\n     }\n-    fn parse_count(str s, uint i, uint lim) -> tup(count, uint) {\n+    fn parse_count(str s, uint i, uint lim)\n+        -> rec(count count, uint next) {\n         ret if (i >= lim) {\n-                tup(count_implied, i)\n+                rec(count=count_implied, next=i)\n             } else if (s.(i) == '*' as u8) {\n                 auto param = parse_parameter(s, i + 1u, lim);\n-                auto j = param._1;\n-                alt (param._0) {\n-                    case (none) { tup(count_is_next_param, j) }\n-                    case (some(?n)) { tup(count_is_param(n), j) }\n+                auto j = param.next;\n+                alt (param.param) {\n+                    case (none) { rec(count=count_is_next_param, next=j) }\n+                    case (some(?n)) { rec(count=count_is_param(n), next=j) }\n                 }\n             } else {\n                 auto num = peek_num(s, i, lim);\n                 alt (num) {\n-                    case (none) { tup(count_implied, i) }\n-                    case (some(?num)) { tup(count_is(num._0 as int), num._1) }\n+                    case (none) { rec(count=count_implied, next=i) }\n+                    case (some(?num)) { rec(count=count_is(num.num as int),\n+                                            next=num.next) }\n                 }\n             };\n     }\n-    fn parse_precision(str s, uint i, uint lim) -> tup(count, uint) {\n+    fn parse_precision(str s, uint i, uint lim)\n+        -> rec(count count, uint next) {\n         ret if (i >= lim) {\n-                tup(count_implied, i)\n+                rec(count=count_implied, next=i)\n             } else if (s.(i) == '.' as u8) {\n                 auto count = parse_count(s, i + 1u, lim);\n \n                 // If there were no digits specified, i.e. the precision\n                 // was \".\", then the precision is 0\n-                alt (count._0) {\n-                    case (count_implied) { tup(count_is(0), count._1) }\n+                alt (count.count) {\n+                    case (count_implied) { rec(count=count_is(0),\n+                                               next=count.next) }\n                     case (_) { count }\n                 }\n-            } else { tup(count_implied, i) };\n+            } else { rec(count=count_implied, next=i) };\n     }\n-    fn parse_type(str s, uint i, uint lim, error_fn error) -> tup(ty, uint) {\n+    fn parse_type(str s, uint i, uint lim, error_fn error)\n+        -> rec(ty ty, uint next) {\n         if (i >= lim) { error(\"missing type in conversion\"); }\n         auto tstr = str::substr(s, i, 1u);\n         auto t =\n@@ -229,7 +239,7 @@ mod ct {\n             } else if (str::eq(tstr, \"o\")) {\n                 ty_octal\n             } else { error(\"unknown type in conversion: \" + tstr) };\n-        ret tup(t, i + 1u);\n+        ret rec(ty=t, next=i + 1u);\n     }\n }\n "}, {"sha": "f5e29a3c1bce0257a9ba876cf5487dca617c6512", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -165,8 +165,8 @@ fn getopts_ivec(&str[] args, &opt[] opts) -> result {\n                 names = ~[];\n                 while (j < curlen) {\n                     auto range = str::char_range_at(cur, j);\n-                    names += ~[short(range._0)];\n-                    j = range._1;\n+                    names += ~[short(range.ch)];\n+                    j = range.next;\n                 }\n             }\n             auto name_pos = 0u;"}, {"sha": "78869c56a1d474296a98ad57fa3448b914449bfd", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -257,29 +257,29 @@ fn find[T](fn(&T) -> bool  f, &T[] v) -> option::t[T] {\n     ret none[T];\n }\n \n-fn unzip[T, U](&tup(T, U)[] v) -> tup(T[], U[]) {\n-    auto sz = len[tup(T, U)](v);\n+fn unzip[T, U](&rec(T _0, U _1)[] v) -> rec(T[] _0, U[] _1) {\n+    auto sz = len(v);\n     if (sz == 0u) {\n-        ret tup(~[], ~[]);\n+        ret rec(_0=~[], _1=~[]);\n     } else {\n-        auto rest = slice[tup(T, U)](v, 1u, sz);\n-        auto tl = unzip[T, U](rest);\n+        auto rest = slice(v, 1u, sz);\n+        auto tl = unzip(rest);\n         auto a = ~[v.(0)._0];\n         auto b = ~[v.(0)._1];\n-        ret tup(a + tl._0, b + tl._1);\n+        ret rec(_0=a + tl._0, _1=b + tl._1);\n     }\n }\n \n \n // FIXME make the lengths being equal a constraint\n-fn zip[T, U](&T[] v, &U[] u) -> tup(T, U)[] {\n-    auto sz = len[T](v);\n-    assert (sz == len[U](u));\n+fn zip[T, U](&T[] v, &U[] u) -> rec(T _0, U _1)[] {\n+    auto sz = len(v);\n+    assert (sz == len(u));\n     if (sz == 0u) {\n         ret ~[];\n     } else {\n-        auto rest = zip[T, U](slice[T](v, 1u, sz), slice[U](u, 1u, sz));\n-        ret ~[tup(v.(0), u.(0))] + rest;\n+        auto rest = zip(slice(v, 1u, sz), slice(u, 1u, sz));\n+        ret ~[rec(_0=v.(0), _1=u.(0))] + rest;\n     }\n }\n "}, {"sha": "3313923fe9e1b65891d24649a54299bd6f026ba9", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -66,10 +66,10 @@ fn target_os() -> str { ret \"linux\"; }\n \n fn dylib_filename(str base) -> str { ret \"lib\" + base + \".so\"; }\n \n-fn pipe() -> tup(int, int) {\n-    auto fds = tup(mutable 0, 0);\n-    assert (os::libc::pipe(ptr::addr_of(fds._0)) == 0);\n-    ret tup(fds._0, fds._1);\n+fn pipe() -> rec(int in, int out) {\n+    auto fds = rec(mutable in=0, mutable out=0);\n+    assert (os::libc::pipe(ptr::addr_of(fds.in)) == 0);\n+    ret rec(in=fds.in, out=fds.out);\n }\n \n fn fd_FILE(int fd) -> libc::FILE { ret libc::fdopen(fd, str::buf(\"r\")); }"}, {"sha": "f1cf8d694c77f378f5f1d6066feab848d5dad74a", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -63,10 +63,10 @@ fn target_os() -> str { ret \"macos\"; }\n \n fn dylib_filename(str base) -> str { ret \"lib\" + base + \".dylib\"; }\n \n-fn pipe() -> tup(int, int) {\n-    auto fds = tup(mutable 0, 0);\n-    assert (os::libc::pipe(ptr::addr_of(fds._0)) == 0);\n-    ret tup(fds._0, fds._1);\n+fn pipe() -> rec(int in, int out) {\n+    auto fds = rec(mutable in=0, mutable out=0);\n+    assert (os::libc::pipe(ptr::addr_of(fds.in)) == 0);\n+    ret rec(in=fds.in, out=fds.out);\n }\n \n fn fd_FILE(int fd) -> libc::FILE { ret libc::fdopen(fd, str::buf(\"r\")); }"}, {"sha": "195f180a61f1273d0ac6be576693b394167d4a77", "filename": "src/lib/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -14,7 +14,7 @@ type hashmap[K, V] =\n         fn find(&K) -> option::t[V] ;\n         fn remove(&K) -> option::t[V] ;\n         fn rehash() ;\n-        iter items() -> @tup(K, V) ;\n+        iter items() -> @rec(K key, V val);\n         iter keys() -> K ;\n     };\n type hashset[K] = hashmap[K, ()];\n@@ -185,10 +185,10 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n             rehash[K, V](hasher, eqer, bkts, nbkts, newbkts, nbkts);\n             bkts = newbkts;\n         }\n-        iter items() -> @tup(K, V) {\n+        iter items() -> @rec(K key, V val) {\n             for (bucket[K, V] b in bkts) {\n                 alt (b) {\n-                    case (some(?k, ?v)) { put @tup(k, v); }\n+                    case (some(?k, ?v)) { put @rec(key=k, val=v); }\n                     case (_) { }\n                 }\n             }"}, {"sha": "ea1210abe7851cf727a3432348a0663515fc51fc", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -44,11 +44,11 @@ type program =\n fn start_program(str prog, vec[str] args) -> @program {\n     auto pipe_input = os::pipe();\n     auto pipe_output = os::pipe();\n-    auto pid = spawn_process(prog, args, pipe_input._0, pipe_output._1, 0);\n+    auto pid = spawn_process(prog, args, pipe_input.in, pipe_output.out, 0);\n \n     if (pid == -1) { fail; }\n-    os::libc::close(pipe_input._0);\n-    os::libc::close(pipe_output._1);\n+    os::libc::close(pipe_input.in);\n+    os::libc::close(pipe_output.out);\n     obj new_program(int pid,\n                     mutable int in_fd,\n                     os::libc::FILE out_file,\n@@ -80,7 +80,7 @@ fn start_program(str prog, vec[str] args) -> @program {\n              os::libc::fclose(out_file);\n          }\n     }\n-    ret @new_program(pid, pipe_input._1, os::fd_FILE(pipe_output._0), false);\n+    ret @new_program(pid, pipe_input.out, os::fd_FILE(pipe_output.in), false);\n }\n \n fn program_output(str prog, vec[str] args) -> rec(int status, str out) {"}, {"sha": "265f623765145c71cc952be7bdec6523ef628e0c", "filename": "src/lib/str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -262,11 +262,11 @@ fn utf8_char_width(u8 b) -> uint {\n     ret 6u;\n }\n \n-fn char_range_at(str s, uint i) -> tup(char, uint) {\n+fn char_range_at(str s, uint i) -> rec(char ch, uint next) {\n     auto b0 = s.(i);\n     auto w = utf8_char_width(b0);\n     assert (w != 0u);\n-    if (w == 1u) { ret tup(b0 as char, i + 1u); }\n+    if (w == 1u) { ret rec(ch=b0 as char, next=i + 1u); }\n     auto val = 0u;\n     auto end = i + w;\n     i += 1u;\n@@ -282,10 +282,10 @@ fn char_range_at(str s, uint i) -> tup(char, uint) {\n     // a second (as uint) to get it to the right position.\n \n     val += (b0 << (w + 1u as u8) as uint) << (w - 1u) * 6u - w - 1u;\n-    ret tup(val as char, i);\n+    ret rec(ch=val as char, next=i);\n }\n \n-fn char_at(str s, uint i) -> char { ret char_range_at(s, i)._0; }\n+fn char_at(str s, uint i) -> char { ret char_range_at(s, i).ch; }\n \n fn char_len(str s) -> uint {\n     auto i = 0u;\n@@ -307,8 +307,8 @@ fn to_chars(str s) -> vec[char] {\n     auto len = byte_len(s);\n     while (i < len) {\n         auto cur = char_range_at(s, i);\n-        vec::push[char](buf, cur._0);\n-        i = cur._1;\n+        vec::push[char](buf, cur.ch);\n+        i = cur.next;\n     }\n     ret buf;\n }\n@@ -326,8 +326,8 @@ fn pop_char(&mutable str s) -> char {\n \n fn shift_char(&mutable str s) -> char {\n     auto r = char_range_at(s, 0u);\n-    s = substr(s, r._1, byte_len(s) - r._1);\n-    ret r._0;\n+    s = substr(s, r.next, byte_len(s) - r.next);\n+    ret r.ch;\n }\n \n fn unshift_char(&mutable str s, char ch) {"}, {"sha": "03832aab0d1a0b879abde66afe4feec17afb90c3", "filename": "src/lib/util.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -15,10 +15,6 @@ fn rational_leq(&rational x, &rational y) -> bool {\n     ret x.num * y.den <= y.num * x.den;\n }\n \n-fn fst[T, U](&tup(T, U) x) -> T { ret x._0; }\n-\n-fn snd[T, U](&tup(T, U) x) -> U { ret x._1; }\n-\n fn orb(&bool a, &bool b) -> bool { ret a || b; }\n // Local Variables:\n // mode: rust;"}, {"sha": "432098f970b4aa197c1bfc989e452846fdff7ac1", "filename": "src/lib/vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -266,29 +266,29 @@ fn foldl[T, U](fn(&U, &T) -> U  p, &U z, &vec[T] v) -> U {\n     }\n }\n \n-fn unzip[T, U](&vec[tup(T, U)] v) -> tup(vec[T], vec[U]) {\n-    auto sz = len[tup(T, U)](v);\n+fn unzip[T, U](&vec[rec(T _0, U _1)] v) -> rec(vec[T] _0, vec[U] _1) {\n+    auto sz = len(v);\n     if (sz == 0u) {\n-        ret tup(alloc[T](0u), alloc[U](0u));\n+        ret rec(_0=alloc[T](0u), _1=alloc[U](0u));\n     } else {\n-        auto rest = slice[tup(T, U)](v, 1u, sz);\n+        auto rest = slice(v, 1u, sz);\n         auto tl = unzip[T, U](rest);\n         auto a = [v.(0)._0];\n         auto b = [v.(0)._1];\n-        ret tup(a + tl._0, b + tl._1);\n+        ret rec(_0=a + tl._0, _1=b + tl._1);\n     }\n }\n \n \n // FIXME make the lengths being equal a constraint\n-fn zip[T, U](&vec[T] v, &vec[U] u) -> vec[tup(T, U)] {\n-    auto sz = len[T](v);\n-    assert (sz == len[U](u));\n+fn zip[T, U](&vec[T] v, &vec[U] u) -> vec[rec(T _0, U _1)] {\n+    auto sz = len(v);\n+    assert (sz == len(u));\n     if (sz == 0u) {\n-        ret alloc[tup(T, U)](0u);\n+        ret alloc(0u);\n     } else {\n-        auto rest = zip[T, U](slice[T](v, 1u, sz), slice[U](u, 1u, sz));\n-        vec::push(rest, tup(v.(0), u.(0)));\n+        auto rest = zip(slice(v, 1u, sz), slice(u, 1u, sz));\n+        vec::push(rest, rec(_0=v.(0), _1=u.(0)));\n         ret rest;\n     }\n }"}, {"sha": "ca58d5e90976cab6288141959c2303f4d189595b", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea537779e01359cf8da6944218362d44bfaee83/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=aea537779e01359cf8da6944218362d44bfaee83", "patch": "@@ -59,11 +59,11 @@ fn target_os() -> str { ret \"win32\"; }\n \n fn dylib_filename(str base) -> str { ret base + \".dll\"; }\n \n-fn pipe() -> tup(int, int) {\n-    auto fds = tup(mutable 0, 0);\n-    assert (os::libc::_pipe(ptr::addr_of(fds._0), 1024u,\n+fn pipe() -> rec(int in, int out) {\n+    auto fds = rec(mutable int=0, mutable out=0);\n+    assert (os::libc::_pipe(ptr::addr_of(fds.in), 1024u,\n                             libc_constants::O_BINARY()) == 0);\n-    ret tup(fds._0, fds._1);\n+    ret rec(in=fds.in, out=fds.out);\n }\n \n fn fd_FILE(int fd) -> libc::FILE { ret libc::_fdopen(fd, str::buf(\"r\")); }"}]}