{"sha": "a42a3429fe357fc5a455e96d65cda7465d0be860", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MmEzNDI5ZmUzNTdmYzVhNDU1ZTk2ZDY1Y2RhNzQ2NWQwYmU4NjA=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-18T18:50:07Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:03:32Z"}, "message": "Move param_env onto SharedCrateContext, and move functions which need the ParamEnv onto it.", "tree": {"sha": "d68aeb3a9020149c998f574569b86ec4bff8b847", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d68aeb3a9020149c998f574569b86ec4bff8b847"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a42a3429fe357fc5a455e96d65cda7465d0be860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a42a3429fe357fc5a455e96d65cda7465d0be860", "html_url": "https://github.com/rust-lang/rust/commit/a42a3429fe357fc5a455e96d65cda7465d0be860", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a42a3429fe357fc5a455e96d65cda7465d0be860/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b9a0efef470fd061c70592892f6e40844415344", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b9a0efef470fd061c70592892f6e40844415344", "html_url": "https://github.com/rust-lang/rust/commit/2b9a0efef470fd061c70592892f6e40844415344"}], "stats": {"total": 226, "additions": 107, "deletions": 119}, "files": [{"sha": "0f876eadd73c0d0c5a13f7f2967222c5e36a3dcf", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -420,7 +420,7 @@ impl FnType {\n         let ret_ty = sig.output();\n         let mut ret = arg_of(ret_ty, true);\n \n-        if !type_is_fat_ptr(ccx.tcx(), ret_ty) {\n+        if !type_is_fat_ptr(ccx, ret_ty) {\n             // The `noalias` attribute on the return value is useful to a\n             // function ptr caller.\n             if let ty::TyBox(_) = ret_ty.sty {\n@@ -485,7 +485,7 @@ impl FnType {\n         for ty in inputs.iter().chain(extra_args.iter()) {\n             let mut arg = arg_of(ty, false);\n \n-            if type_is_fat_ptr(ccx.tcx(), ty) {\n+            if type_is_fat_ptr(ccx, ty) {\n                 let original_tys = arg.original_ty.field_types();\n                 let sizing_tys = arg.ty.field_types();\n                 assert_eq!((original_tys.len(), sizing_tys.len()), (2, 2));\n@@ -558,7 +558,7 @@ impl FnType {\n             };\n             // Fat pointers are returned by-value.\n             if !self.ret.is_ignore() {\n-                if !type_is_fat_ptr(ccx.tcx(), sig.output()) {\n+                if !type_is_fat_ptr(ccx, sig.output()) {\n                     fixup(&mut self.ret);\n                 }\n             }"}, {"sha": "a59e2fe506f48da9172a689d5648985c7065433a", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -293,7 +293,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>\n                              sizing: bool, dst: bool) -> Vec<Type> {\n     let fields = variant.field_index_by_increasing_offset().map(|i| fields[i as usize]);\n     if sizing {\n-        fields.filter(|ty| !dst || type_is_sized(cx.tcx(), *ty))\n+        fields.filter(|ty| !dst || cx.shared().type_is_sized(*ty))\n             .map(|ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n         fields.map(|ty| type_of::in_memory_type_of(cx, ty)).collect()\n@@ -586,7 +586,8 @@ fn struct_field_ptr<'a, 'tcx>(\n     //   * First field - Always aligned properly\n     //   * Packed struct - There is no alignment padding\n     //   * Field is sized - pointer is properly aligned already\n-    if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed || type_is_sized(bcx.tcx(), fty) {\n+    if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n+        bcx.ccx().shared().type_is_sized(fty) {\n         return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n     }\n "}, {"sha": "35507c6e6ab7cf4add31203ddc5760bb4c40614e", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -232,7 +232,7 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(common::type_is_sized(bcx.tcx(), a));\n+            assert!(bcx.ccx().shared().type_is_sized(a));\n             let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), b).ptr_to();\n             (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx(), a, b, None))\n         }\n@@ -252,7 +252,7 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         (&ty::TyRef(..), &ty::TyRef(..)) |\n         (&ty::TyRef(..), &ty::TyRawPtr(..)) |\n         (&ty::TyRawPtr(..), &ty::TyRawPtr(..)) => {\n-            let (base, info) = if common::type_is_fat_ptr(bcx.tcx(), src_ty) {\n+            let (base, info) = if common::type_is_fat_ptr(bcx.ccx(), src_ty) {\n                 // fat-ptr to fat-ptr unsize preserves the vtable\n                 // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n                 // So we need to pointercast the base to ensure\n@@ -412,8 +412,7 @@ pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> V\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n         b.load_range_assert(ptr, 0, 0x10FFFF + 1, llvm::False)\n-    } else if (t.is_region_ptr() || t.is_unique()) &&\n-              !common::type_is_fat_ptr(ccx.tcx(), t) {\n+    } else if (t.is_region_ptr() || t.is_unique()) && !common::type_is_fat_ptr(ccx, t) {\n         b.load_nonnull(ptr)\n     } else {\n         b.load(ptr)\n@@ -425,7 +424,7 @@ pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> V\n pub fn store_ty<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n-    if common::type_is_fat_ptr(cx.tcx(), t) {\n+    if common::type_is_fat_ptr(cx.ccx(), t) {\n         let lladdr = cx.extract_value(v, abi::FAT_PTR_ADDR);\n         let llextra = cx.extract_value(v, abi::FAT_PTR_EXTRA);\n         store_fat_ptr(cx, lladdr, llextra, dst, t);\n@@ -538,7 +537,7 @@ pub fn memcpy_ty<'a, 'tcx>(\n         let llsz = llsize_of(ccx, llty);\n         let llalign = type_of::align_of(ccx, t);\n         call_memcpy(bcx, dst, src, llsz, llalign as u32);\n-    } else if common::type_is_fat_ptr(bcx.tcx(), t) {\n+    } else if common::type_is_fat_ptr(bcx.ccx(), t) {\n         let (data, extra) = load_fat_ptr(bcx, src, t);\n         store_fat_ptr(bcx, data, extra, dst, t);\n     } else {\n@@ -639,7 +638,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let lldestptr = adt::trans_field_ptr(&bcx, sig.output(), dest_val, Disr::from(disr), i);\n             let arg = &fcx.fn_ty.args[arg_idx];\n             arg_idx += 1;\n-            if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n+            if common::type_is_fat_ptr(bcx.ccx(), arg_ty) {\n                 let meta = &fcx.fn_ty.args[arg_idx];\n                 arg_idx += 1;\n                 arg.store_fn_arg(&bcx, &mut llarg_idx, get_dataptr(&bcx, lldestptr));"}, {"sha": "7b655bbd60675a44cb3da94ccf7d6495ba1b6505", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -86,7 +86,7 @@ impl PartialEq for UnwindKind {\n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n     pub fn schedule_drop_mem(&self, val: ValueRef, ty: Ty<'tcx>) -> CleanupScope<'tcx> {\n-        if !self.type_needs_drop(ty) { return CleanupScope::noop(); }\n+        if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n         let drop = DropValue {\n             val: val,\n             ty: ty,\n@@ -106,7 +106,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     pub fn schedule_drop_adt_contents(&self, val: ValueRef, ty: Ty<'tcx>) -> CleanupScope<'tcx> {\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n-        if !self.type_needs_drop(ty) { return CleanupScope::noop(); }\n+        if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n \n         let drop = DropValue {\n             val: val,"}, {"sha": "d8c212745376d69225bd2ff424dd1c15f4731f62", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -208,7 +208,7 @@ use syntax::abi::Abi;\n use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n-use common::{fulfill_obligation, type_is_sized};\n+use common::fulfill_obligation;\n use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -337,7 +337,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         TransItem::Static(node_id) => {\n             let def_id = scx.tcx().map.local_def_id(node_id);\n             let ty = scx.tcx().item_type(def_id);\n-            let ty = glue::get_drop_glue_type(scx.tcx(), ty);\n+            let ty = glue::get_drop_glue_type(scx, ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n \n             recursion_depth_reset = None;\n@@ -542,7 +542,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                       self.param_substs,\n                                                       &ty);\n             assert!(ty.is_normalized_for_trans());\n-            let ty = glue::get_drop_glue_type(self.scx.tcx(), ty);\n+            let ty = glue::get_drop_glue_type(self.scx, ty);\n             self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n         }\n \n@@ -678,7 +678,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                             let operand_ty = monomorphize::apply_param_substs(self.scx,\n                                                                               self.param_substs,\n                                                                               &mt.ty);\n-                            let ty = glue::get_drop_glue_type(tcx, operand_ty);\n+                            let ty = glue::get_drop_glue_type(self.scx, operand_ty);\n                             self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                         } else {\n                             bug!(\"Has the drop_in_place() intrinsic's signature changed?\")\n@@ -804,33 +804,33 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 let field_type = monomorphize::apply_param_substs(scx,\n                                                                   substs,\n                                                                   &field_type);\n-                let field_type = glue::get_drop_glue_type(scx.tcx(), field_type);\n+                let field_type = glue::get_drop_glue_type(scx, field_type);\n \n-                if glue::type_needs_drop(scx.tcx(), field_type) {\n+                if scx.type_needs_drop(field_type) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(field_type)));\n                 }\n             }\n         }\n         ty::TyClosure(def_id, substs) => {\n             for upvar_ty in substs.upvar_tys(def_id, scx.tcx()) {\n-                let upvar_ty = glue::get_drop_glue_type(scx.tcx(), upvar_ty);\n-                if glue::type_needs_drop(scx.tcx(), upvar_ty) {\n+                let upvar_ty = glue::get_drop_glue_type(scx, upvar_ty);\n+                if scx.type_needs_drop(upvar_ty) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(upvar_ty)));\n                 }\n             }\n         }\n         ty::TyBox(inner_type)      |\n         ty::TySlice(inner_type)    |\n         ty::TyArray(inner_type, _) => {\n-            let inner_type = glue::get_drop_glue_type(scx.tcx(), inner_type);\n-            if glue::type_needs_drop(scx.tcx(), inner_type) {\n+            let inner_type = glue::get_drop_glue_type(scx, inner_type);\n+            if scx.type_needs_drop(inner_type) {\n                 output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n             }\n         }\n         ty::TyTuple(args) => {\n             for arg in args {\n-                let arg = glue::get_drop_glue_type(scx.tcx(), arg);\n-                if glue::type_needs_drop(scx.tcx(), arg) {\n+                let arg = glue::get_drop_glue_type(scx, arg);\n+                if scx.type_needs_drop(arg) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(arg)));\n                 }\n             }\n@@ -969,7 +969,7 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             let (inner_source, inner_target) = (a, b);\n \n-            if !type_is_sized(scx.tcx(), inner_source) {\n+            if !scx.type_is_sized(inner_source) {\n                 (inner_source, inner_target)\n             } else {\n                 scx.tcx().struct_lockstep_tails(inner_source, inner_target)\n@@ -1051,7 +1051,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n             output.extend(methods);\n         }\n         // Also add the destructor\n-        let dg_type = glue::get_drop_glue_type(scx.tcx(), impl_ty);\n+        let dg_type = glue::get_drop_glue_type(scx, impl_ty);\n         output.push(TransItem::DropGlue(DropGlueKind::Ty(dg_type)));\n     }\n }\n@@ -1097,7 +1097,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                                def_id_to_string(self.scx.tcx(), def_id));\n \n                         let ty = self.scx.tcx().item_type(def_id);\n-                        let ty = glue::get_drop_glue_type(self.scx.tcx(), ty);\n+                        let ty = glue::get_drop_glue_type(self.scx, ty);\n                         self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                     }\n                 }"}, {"sha": "528ecf2a426656b554d131591cd226b4bb1a6fd9", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -48,21 +48,16 @@ use std::ffi::CString;\n \n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n \n pub use context::{CrateContext, SharedCrateContext};\n \n-/// Is the type's representation size known at compile time?\n-pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_sized(tcx, &tcx.empty_parameter_environment(), DUMMY_SP)\n-}\n-\n-pub fn type_is_fat_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n         ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n         ty::TyBox(ty) => {\n-            !type_is_sized(tcx, ty)\n+            !ccx.shared().type_is_sized(ty)\n         }\n         _ => {\n             false\n@@ -74,14 +69,13 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     use machine::llsize_of_alloc;\n     use type_of::sizing_type_of;\n \n-    let tcx = ccx.tcx();\n     let simple = ty.is_scalar() ||\n         ty.is_unique() || ty.is_region_ptr() ||\n         ty.is_simd();\n-    if simple && !type_is_fat_ptr(tcx, ty) {\n+    if simple && !type_is_fat_ptr(ccx, ty) {\n         return true;\n     }\n-    if !type_is_sized(tcx, ty) {\n+    if !ccx.shared().type_is_sized(ty) {\n         return false;\n     }\n     match ty.sty {\n@@ -239,9 +233,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // section of the executable we're generating.\n     pub llfn: ValueRef,\n \n-    // always an empty parameter-environment NOTE: @jroesch another use of ParamEnv\n-    param_env: ty::ParameterEnvironment<'tcx>,\n-\n     // A pointer to where to store the return value. If the return type is\n     // immediate, this points to an alloca in the function. Otherwise, it's a\n     // pointer to the hidden first parameter of the function. After function\n@@ -289,7 +280,6 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         let mut fcx = FunctionContext {\n             llfn: llfndecl,\n             llretslotptr: None,\n-            param_env: ccx.tcx().empty_parameter_environment(),\n             alloca_insert_pt: None,\n             fn_ty: fn_ty,\n             param_substs: param_substs,\n@@ -358,12 +348,6 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n                                          value)\n     }\n \n-    /// This is the same as `common::type_needs_drop`, except that it\n-    /// may use or update caches within this `FunctionContext`.\n-    pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        self.ccx.tcx().type_needs_drop_given_env(ty, &self.param_env)\n-    }\n-\n     pub fn eh_personality(&self) -> ValueRef {\n         // The exception handling personality function.\n         //"}, {"sha": "d9fc21dd79f65ffc14968b69b45660dcbd6ff9dc", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -40,6 +40,7 @@ use std::rc::Rc;\n use std::str;\n use syntax::ast;\n use syntax::symbol::InternedString;\n+use syntax_pos::DUMMY_SP;\n use abi::FnType;\n \n pub struct Stats {\n@@ -67,6 +68,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     exported_symbols: NodeSet,\n     link_meta: LinkMeta,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParameterEnvironment<'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n \n@@ -454,6 +456,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             export_map: export_map,\n             exported_symbols: exported_symbols,\n             link_meta: link_meta,\n+            param_env: tcx.empty_parameter_environment(),\n             tcx: tcx,\n             stats: Stats {\n                 n_glues_created: Cell::new(0),\n@@ -474,6 +477,14 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         }\n     }\n \n+    pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        self.tcx.type_needs_drop_given_env(ty, &self.param_env)\n+    }\n+\n+    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+        ty.is_sized(self.tcx, &self.param_env, DUMMY_SP)\n+    }\n+\n     pub fn metadata_llmod(&self) -> ModuleRef {\n         self.metadata_llmod\n     }"}, {"sha": "1176de4010a172131489413c4320ebb686db51b7", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -19,7 +19,7 @@ use llvm::{ValueRef, get_param};\n use middle::lang_items::ExchangeFreeFnLangItem;\n use rustc::ty::subst::{Substs};\n use rustc::traits;\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, AdtKind, Ty, TypeFoldable};\n use adt;\n use base::*;\n use callee::Callee;\n@@ -63,7 +63,7 @@ pub fn trans_exchange_free_dyn<'a, 'tcx>(\n pub fn trans_exchange_free_ty<'a, 'tcx>(\n     bcx: &BlockAndBuilder<'a, 'tcx>, ptr: ValueRef, content_ty: Ty<'tcx>\n ) {\n-    assert!(type_is_sized(bcx.ccx().tcx(), content_ty));\n+    assert!(bcx.ccx().shared().type_is_sized(content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n \n@@ -75,18 +75,14 @@ pub fn trans_exchange_free_ty<'a, 'tcx>(\n     }\n }\n \n-pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    tcx.type_needs_drop_given_env(ty, &tcx.empty_parameter_environment())\n-}\n-\n-pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n+pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n     assert!(t.is_normalized_for_trans());\n \n-    let t = tcx.erase_regions(&t);\n+    let t = scx.tcx().erase_regions(&t);\n \n     // Even if there is no dtor for t, there might be one deeper down and we\n     // might need to pass in the vtable ptr.\n-    if !type_is_sized(tcx, t) {\n+    if !scx.type_is_sized(t) {\n         return t;\n     }\n \n@@ -99,17 +95,16 @@ pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, t: Ty<'tcx>) ->\n     // returned `tcx.types.i8` does not appear unsound. The impact on\n     // code quality is unknown at this time.)\n \n-    if !type_needs_drop(tcx, t) {\n-        return tcx.types.i8;\n+    if !scx.type_needs_drop(t) {\n+        return scx.tcx().types.i8;\n     }\n     match t.sty {\n-        ty::TyBox(typ) if !type_needs_drop(tcx, typ)\n-                         && type_is_sized(tcx, typ) => {\n-            tcx.infer_ctxt(None, None, traits::Reveal::All).enter(|infcx| {\n+        ty::TyBox(typ) if !scx.type_needs_drop(typ) && scx.type_is_sized(typ) => {\n+            scx.tcx().infer_ctxt(None, None, traits::Reveal::All).enter(|infcx| {\n                 let layout = t.layout(&infcx).unwrap();\n-                if layout.size(&tcx.data_layout).bytes() == 0 {\n+                if layout.size(&scx.tcx().data_layout).bytes() == 0 {\n                     // `Box<ZeroSizeType>` does not allocate.\n-                    tcx.types.i8\n+                    scx.tcx().types.i8\n                 } else {\n                     t\n                 }\n@@ -132,15 +127,15 @@ pub fn call_drop_glue<'a, 'tcx>(\n ) {\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"call_drop_glue(t={:?}, skip_dtor={})\", t, skip_dtor);\n-    if bcx.fcx().type_needs_drop(t) {\n+    if bcx.ccx().shared().type_needs_drop(t) {\n         let ccx = bcx.ccx();\n         let g = if skip_dtor {\n             DropGlueKind::TyContents(t)\n         } else {\n             DropGlueKind::Ty(t)\n         };\n         let glue = get_drop_glue_core(ccx, g);\n-        let glue_type = get_drop_glue_type(ccx.tcx(), t);\n+        let glue_type = get_drop_glue_type(ccx.shared(), t);\n         let ptr = if glue_type != t {\n             bcx.pointercast(v, type_of(ccx, glue_type).ptr_to())\n         } else {\n@@ -184,7 +179,7 @@ impl<'tcx> DropGlueKind<'tcx> {\n }\n \n fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'tcx>) -> ValueRef {\n-    let g = g.map_ty(|t| get_drop_glue_type(ccx.tcx(), t));\n+    let g = g.map_ty(|t| get_drop_glue_type(ccx.shared(), t));\n     match ccx.drop_glues().borrow().get(&g) {\n         Some(&(glue, _)) => glue,\n         None => {\n@@ -197,8 +192,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'t\n }\n \n pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'tcx>) {\n-    let tcx = ccx.tcx();\n-    assert_eq!(g.ty(), get_drop_glue_type(tcx, g.ty()));\n+    assert_eq!(g.ty(), get_drop_glue_type(ccx.shared(), g.ty()));\n     let (llfn, fn_ty) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n \n     let fcx = FunctionContext::new(ccx, llfn, fn_ty, None, false);\n@@ -243,7 +237,7 @@ fn trans_custom_dtor<'a, 'tcx>(mut bcx: BlockAndBuilder<'a, 'tcx>,\n     };\n \n     let (sized_args, unsized_args);\n-    let args: &[ValueRef] = if type_is_sized(tcx, t) {\n+    let args: &[ValueRef] = if bcx.ccx().shared().type_is_sized(t) {\n         sized_args = [v0];\n         &sized_args\n     } else {\n@@ -284,7 +278,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                                        -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n-    if type_is_sized(bcx.tcx(), t) {\n+    if bcx.ccx().shared().type_is_sized(t) {\n         let sizing_type = sizing_type_of(bcx.ccx(), t);\n         let size = llsize_of_alloc(bcx.ccx(), sizing_type);\n         let align = align_of(bcx.ccx(), t);\n@@ -405,7 +399,7 @@ fn make_drop_glue<'a, 'tcx>(bcx: BlockAndBuilder<'a, 'tcx>,\n             // special. It may move to library and have Drop impl. As\n             // a safe-guard, assert TyBox not used with TyContents.\n             assert!(!skip_dtor);\n-            if !type_is_sized(bcx.tcx(), content_ty) {\n+            if !bcx.ccx().shared().type_is_sized(content_ty) {\n                 let llval = get_dataptr(&bcx, v0);\n                 let llbox = bcx.load(llval);\n                 drop_ty(&bcx, v0, content_ty);\n@@ -458,7 +452,7 @@ fn make_drop_glue<'a, 'tcx>(bcx: BlockAndBuilder<'a, 'tcx>,\n             bcx\n         }\n         _ => {\n-            if bcx.fcx().type_needs_drop(t) {\n+            if bcx.ccx().shared().type_needs_drop(t) {\n                 drop_structural_ty(bcx, v0, t)\n             } else {\n                 bcx\n@@ -485,7 +479,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n         }\n     }\n \n-    let value = if type_is_sized(cx.tcx(), t) {\n+    let value = if cx.ccx().shared().type_is_sized(t) {\n         adt::MaybeSizedValue::sized(av)\n     } else {\n         // FIXME(#36457) -- we should pass unsized values as two arguments\n@@ -525,7 +519,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                 for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n                     let llfld_a = adt::trans_field_ptr(&cx, t, value, Disr::from(discr), i);\n \n-                    let val = if type_is_sized(cx.tcx(), field_ty) {\n+                    let val = if cx.ccx().shared().type_is_sized(field_ty) {\n                         llfld_a\n                     } else {\n                         // FIXME(#36457) -- we should pass unsized values as two arguments"}, {"sha": "fd5048f8c5938bc5864dff3ca8d8d11332a6a767", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -143,7 +143,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n-            if !type_is_sized(tcx, tp_ty) {\n+            if !bcx.ccx().shared().type_is_sized(tp_ty) {\n                 let (llsize, _) =\n                     glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llsize\n@@ -158,7 +158,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n-            if !type_is_sized(tcx, tp_ty) {\n+            if !bcx.ccx().shared().type_is_sized(tp_ty) {\n                 let (_, llalign) =\n                     glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llalign\n@@ -197,7 +197,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n \n-            C_bool(ccx, bcx.fcx().type_needs_drop(tp_ty))\n+            C_bool(ccx, bcx.ccx().shared().type_needs_drop(tp_ty))\n         }\n         \"offset\" => {\n             let ptr = llargs[0];\n@@ -243,7 +243,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         },\n         \"volatile_store\" => {\n             let tp_ty = substs.type_at(0);\n-            if type_is_fat_ptr(bcx.tcx(), tp_ty) {\n+            if type_is_fat_ptr(bcx.ccx(), tp_ty) {\n                 bcx.volatile_store(llargs[1], get_dataptr(bcx, llargs[0]));\n                 bcx.volatile_store(llargs[2], get_meta(bcx, llargs[0]));\n             } else {\n@@ -551,7 +551,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                         // This assumes the type is \"simple\", i.e. no\n                         // destructors, and the contents are SIMD\n                         // etc.\n-                        assert!(!bcx.fcx().type_needs_drop(arg_type));\n+                        assert!(!bcx.ccx().shared().type_needs_drop(arg_type));\n                         let arg = adt::MaybeSizedValue::sized(llarg);\n                         (0..contents.len())\n                             .map(|i| {"}, {"sha": "38e21bdefb2c8b5f48edbe0aa822a381638cb398", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -17,7 +17,6 @@ use rustc::mir::{self, Location, TerminatorKind};\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n use common::{self, BlockAndBuilder};\n-use glue;\n use super::rvalue;\n \n pub fn lvalue_locals<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, mir: &mir::Mir<'tcx>) -> BitVector {\n@@ -37,7 +36,7 @@ pub fn lvalue_locals<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, mir: &mir::Mir<'\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n             assert!(common::type_is_immediate(bcx.ccx(), ty) ||\n-                    common::type_is_fat_ptr(bcx.tcx(), ty));\n+                    common::type_is_fat_ptr(bcx.ccx(), ty));\n         } else if common::type_is_imm_pair(bcx.ccx(), ty) {\n             // We allow pairs and uses of any of their 2 fields.\n         } else {\n@@ -172,7 +171,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     let ty = self.bcx.fcx().monomorphize(&ty.to_ty(self.bcx.tcx()));\n \n                     // Only need the lvalue if we're actually dropping it.\n-                    if glue::type_needs_drop(self.bcx.tcx(), ty) {\n+                    if self.bcx.ccx().shared().type_needs_drop(ty) {\n                         self.mark_as_lvalue(index);\n                     }\n                 }"}, {"sha": "2ccf92a743eac3f41368e1587af51881bfdc27e0", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -245,15 +245,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let ty = bcx.fcx().monomorphize(&ty);\n \n                 // Double check for necessity to drop\n-                if !glue::type_needs_drop(bcx.tcx(), ty) {\n+                if !bcx.ccx().shared().type_needs_drop(ty) {\n                     funclet_br(self, bcx, target);\n                     return;\n                 }\n \n                 let lvalue = self.trans_lvalue(&bcx, location);\n                 let drop_fn = glue::get_drop_glue(bcx.ccx(), ty);\n-                let drop_ty = glue::get_drop_glue_type(bcx.tcx(), ty);\n-                let is_sized = common::type_is_sized(bcx.tcx(), ty);\n+                let drop_ty = glue::get_drop_glue_type(bcx.ccx().shared(), ty);\n+                let is_sized = bcx.ccx().shared().type_is_sized(ty);\n                 let llvalue = if is_sized {\n                     if drop_ty != ty {\n                         bcx.pointercast(lvalue.llval, type_of::type_of(bcx.ccx(), drop_ty).ptr_to())\n@@ -461,7 +461,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n \n                     // Double check for necessity to drop\n-                    if !glue::type_needs_drop(bcx.tcx(), ty) {\n+                    if !bcx.ccx().shared().type_needs_drop(ty) {\n                         funclet_br(self, bcx, target);\n                         return;\n                     }\n@@ -474,8 +474,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n \n                     let drop_fn = glue::get_drop_glue(bcx.ccx(), ty);\n-                    let drop_ty = glue::get_drop_glue_type(bcx.tcx(), ty);\n-                    let is_sized = common::type_is_sized(bcx.tcx(), ty);\n+                    let drop_ty = glue::get_drop_glue_type(bcx.ccx().shared(), ty);\n+                    let is_sized = bcx.ccx().shared().type_is_sized(ty);\n                     let llvalue = if is_sized {\n                         if drop_ty != ty {\n                             bcx.pointercast(llval, type_of::type_of(bcx.ccx(), drop_ty).ptr_to())\n@@ -678,7 +678,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                       callee: &mut CalleeData) {\n         if let Pair(a, b) = op.val {\n             // Treat the values in a fat pointer separately.\n-            if common::type_is_fat_ptr(bcx.tcx(), op.ty) {\n+            if common::type_is_fat_ptr(bcx.ccx(), op.ty) {\n                 let (ptr, meta) = (a, b);\n                 if *next_idx == 0 {\n                     if let Virtual(idx) = *callee {\n@@ -766,7 +766,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let base = adt::MaybeSizedValue::sized(llval);\n                 for (n, &ty) in arg_types.iter().enumerate() {\n                     let ptr = adt::trans_field_ptr(bcx, tuple.ty, base, Disr(0), n);\n-                    let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n+                    let val = if common::type_is_fat_ptr(bcx.ccx(), ty) {\n                         let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, ty);\n                         Pair(lldata, llextra)\n                     } else {"}, {"sha": "9628ed254066c3ec8702892d3935b470acb38198", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -25,7 +25,7 @@ use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr, machine};\n use callee::Callee;\n-use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty, type_is_sized};\n+use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n use common::{const_to_opt_int, const_to_opt_uint};\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     .projection_ty(tcx, &projection.elem);\n                 let base = tr_base.to_const(span);\n                 let projected_ty = self.monomorphize(&projected_ty).to_ty(tcx);\n-                let is_sized = common::type_is_sized(tcx, projected_ty);\n+                let is_sized = self.ccx.shared().type_is_sized(projected_ty);\n \n                 let (projected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => {\n@@ -598,11 +598,11 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::CastKind::Unsize => {\n                         // unsize targets other than to a fat pointer currently\n                         // can't be in constants.\n-                        assert!(common::type_is_fat_ptr(tcx, cast_ty));\n+                        assert!(common::type_is_fat_ptr(self.ccx, cast_ty));\n \n                         let pointee_ty = operand.ty.builtin_deref(true, ty::NoPreference)\n                             .expect(\"consts: unsizing got non-pointer type\").ty;\n-                        let (base, old_info) = if !common::type_is_sized(tcx, pointee_ty) {\n+                        let (base, old_info) = if !self.ccx.shared().type_is_sized(pointee_ty) {\n                             // Normally, the source is a thin pointer and we are\n                             // adding extra info to make a fat pointer. The exception\n                             // is when we are upcasting an existing object fat pointer\n@@ -685,9 +685,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::CastKind::Misc => { // Casts from a fat-ptr.\n                         let ll_cast_ty = type_of::immediate_type_of(self.ccx, cast_ty);\n                         let ll_from_ty = type_of::immediate_type_of(self.ccx, operand.ty);\n-                        if common::type_is_fat_ptr(tcx, operand.ty) {\n+                        if common::type_is_fat_ptr(self.ccx, operand.ty) {\n                             let (data_ptr, meta_ptr) = operand.get_fat_ptr();\n-                            if common::type_is_fat_ptr(tcx, cast_ty) {\n+                            if common::type_is_fat_ptr(self.ccx, cast_ty) {\n                                 let ll_cft = ll_cast_ty.field_types();\n                                 let ll_fft = ll_from_ty.field_types();\n                                 let data_cast = consts::ptrcast(data_ptr, ll_cft[0]);\n@@ -716,7 +716,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let base = match tr_lvalue.base {\n                     Base::Value(llval) => {\n                         // FIXME: may be wrong for &*(&simd_vec as &fmt::Debug)\n-                        let align = if type_is_sized(self.ccx.tcx(), ty) {\n+                        let align = if self.ccx.shared().type_is_sized(ty) {\n                             type_of::align_of(self.ccx, ty)\n                         } else {\n                             self.ccx.tcx().data_layout.pointer_align.abi() as machine::llalign\n@@ -731,7 +731,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     Base::Static(llval) => llval\n                 };\n \n-                let ptr = if common::type_is_sized(tcx, ty) {\n+                let ptr = if self.ccx.shared().type_is_sized(ty) {\n                     base\n                 } else {\n                     C_struct(self.ccx, &[base, tr_lvalue.llextra], false)"}, {"sha": "1582dc9a6aa1e9233bd52a48b932106be7239529", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             LvalueTy::Downcast { adt_def: _, substs: _, variant_index: v } => v,\n                         };\n                         let discr = discr as u64;\n-                        let is_sized = common::type_is_sized(tcx, projected_ty.to_ty(tcx));\n+                        let is_sized = self.ccx().shared().type_is_sized(projected_ty.to_ty(tcx));\n                         let base = if is_sized {\n                             adt::MaybeSizedValue::sized(tr_base.llval)\n                         } else {"}, {"sha": "6fbbaa7bc7661377382d18d084b11ab7e4bd2d5c", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -374,7 +374,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 let dst = bcx.struct_gep(lltemp, i);\n                 let arg = &fcx.fn_ty.args[idx];\n                 idx += 1;\n-                if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n+                if common::type_is_fat_ptr(bcx.ccx(), tupled_arg_ty) {\n                     // We pass fat pointers as two words, but inside the tuple\n                     // they are the two sub-fields of a single aggregate field.\n                     let meta = &fcx.fn_ty.args[idx];\n@@ -429,7 +429,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             }\n             let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n             llarg_idx += 1;\n-            let val = if common::type_is_fat_ptr(tcx, arg_ty) {\n+            let val = if common::type_is_fat_ptr(bcx.ccx(), arg_ty) {\n                 let meta = &fcx.fn_ty.args[idx];\n                 idx += 1;\n                 assert_eq!((meta.cast, meta.pad), (None, None));\n@@ -446,7 +446,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n         } else {\n             let lltemp = base::alloc_ty(&bcx, arg_ty, &format!(\"arg{}\", arg_index));\n-            if common::type_is_fat_ptr(tcx, arg_ty) {\n+            if common::type_is_fat_ptr(bcx.ccx(), arg_ty) {\n                 // we pass fat pointers as two words, but we want to\n                 // represent them internally as a pointer to two words,\n                 // so make an alloca to store them in."}, {"sha": "20364d6320c65ec36a3fb6ea68c71132fb1fd232", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     {\n         debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n \n-        let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n+        let val = if common::type_is_fat_ptr(bcx.ccx(), ty) {\n             let (lldata, llextra) = base::load_fat_ptr(bcx, llval, ty);\n             OperandValue::Pair(lldata, llextra)\n         } else if common::type_is_imm_pair(bcx.ccx(), ty) {"}, {"sha": "d7a4adb1dd4d1a0cefbd8f07173e479ad9d5d4ce", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref source, cast_ty) => {\n                 let cast_ty = bcx.fcx().monomorphize(&cast_ty);\n \n-                if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n+                if common::type_is_fat_ptr(bcx.ccx(), cast_ty) {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n@@ -208,7 +208,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::CastKind::Unsize => {\n                         // unsize targets other than to a fat pointer currently\n                         // can't be operands.\n-                        assert!(common::type_is_fat_ptr(bcx.tcx(), cast_ty));\n+                        assert!(common::type_is_fat_ptr(bcx.ccx(), cast_ty));\n \n                         match operand.val {\n                             OperandValue::Pair(lldata, llextra) => {\n@@ -234,11 +234,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    mir::CastKind::Misc if common::type_is_fat_ptr(bcx.tcx(), operand.ty) => {\n+                    mir::CastKind::Misc if common::type_is_fat_ptr(bcx.ccx(), operand.ty) => {\n                         let ll_cast_ty = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n                         let ll_from_ty = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n                         if let OperandValue::Pair(data_ptr, meta_ptr) = operand.val {\n-                            if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n+                            if common::type_is_fat_ptr(bcx.ccx(), cast_ty) {\n                                 let ll_cft = ll_cast_ty.field_types();\n                                 let ll_fft = ll_from_ty.field_types();\n                                 let data_cast = bcx.pointercast(data_ptr, ll_cft[0]);\n@@ -358,7 +358,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Note: lvalues are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                let operand = if common::type_is_sized(bcx.tcx(), ty) {\n+                let operand = if bcx.ccx().shared().type_is_sized(ty) {\n                     OperandRef {\n                         val: OperandValue::Immediate(tr_lvalue.llval),\n                         ty: ref_ty,\n@@ -385,7 +385,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs = self.trans_operand(&bcx, lhs);\n                 let rhs = self.trans_operand(&bcx, rhs);\n-                let llresult = if common::type_is_fat_ptr(bcx.tcx(), lhs.ty) {\n+                let llresult = if common::type_is_fat_ptr(bcx.ccx(), lhs.ty) {\n                     match (lhs.val, rhs.val) {\n                         (OperandValue::Pair(lhs_addr, lhs_extra),\n                          OperandValue::Pair(rhs_addr, rhs_extra)) => {"}, {"sha": "527bee832956a7c25d2e76d04a21abc8b1ff2aa0", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -184,7 +184,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                            linkage: llvm::Linkage,\n                            symbol_name: &str) {\n         let tcx = ccx.tcx();\n-        assert_eq!(dg.ty(), glue::get_drop_glue_type(tcx, dg.ty()));\n+        assert_eq!(dg.ty(), glue::get_drop_glue_type(ccx.shared(), dg.ty()));\n         let t = dg.ty();\n \n         let sig = tcx.mk_fn_sig(iter::once(tcx.mk_mut_ptr(tcx.types.i8)), tcx.mk_nil(), false);"}, {"sha": "469214b466e1ae7b9c3ffeffaa5857703b4c63b2", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42a3429fe357fc5a455e96d65cda7465d0be860/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=a42a3429fe357fc5a455e96d65cda7465d0be860", "patch": "@@ -39,7 +39,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     let _recursion_lock = cx.enter_type_of(t);\n \n     let llsizingty = match t.sty {\n-        _ if !type_is_sized(cx.tcx(), t) => {\n+        _ if !cx.shared().type_is_sized(t) => {\n             Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, t)], false)\n         }\n \n@@ -53,7 +53,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::TyBox(ty) |\n         ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n         ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n-            if type_is_sized(cx.tcx(), ty) {\n+            if cx.shared().type_is_sized(ty) {\n                 Type::i8p(cx)\n             } else {\n                 Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, ty)], false)\n@@ -102,7 +102,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n     // FIXME(eddyb) Temporary sanity check for ty::layout.\n     let layout = cx.layout_of(t);\n-    if !type_is_sized(cx.tcx(), t) {\n+    if !cx.shared().type_is_sized(t) {\n         if !layout.is_unsized() {\n             bug!(\"layout should be unsized for type `{}` / {:#?}\",\n                  t, layout);\n@@ -133,7 +133,7 @@ pub fn fat_ptr_base_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) ->\n     match ty.sty {\n         ty::TyBox(t) |\n         ty::TyRef(_, ty::TypeAndMut { ty: t, .. }) |\n-        ty::TyRawPtr(ty::TypeAndMut { ty: t, .. }) if !type_is_sized(ccx.tcx(), t) => {\n+        ty::TyRawPtr(ty::TypeAndMut { ty: t, .. }) if !ccx.shared().type_is_sized(t) => {\n             in_memory_type_of(ccx, t).ptr_to()\n         }\n         _ => bug!(\"expected fat ptr ty but got {:?}\", ty)\n@@ -170,7 +170,7 @@ pub fn immediate_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n /// is too large for it to be placed in SSA value (by our rules).\n /// For the raw type without far pointer indirection, see `in_memory_type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n-    let ty = if !type_is_sized(cx.tcx(), ty) {\n+    let ty = if !cx.shared().type_is_sized(ty) {\n         cx.tcx().mk_imm_ptr(ty)\n     } else {\n         ty\n@@ -230,7 +230,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyBox(ty) |\n       ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n       ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n-          if !type_is_sized(cx.tcx(), ty) {\n+          if !cx.shared().type_is_sized(ty) {\n               if let ty::TyStr = ty.sty {\n                   // This means we get a nicer name in the output (str is always\n                   // unsized)."}]}