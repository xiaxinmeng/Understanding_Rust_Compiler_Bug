{"sha": "f1cc7d6c142247de355d65d87578ccd1469b1304", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxY2M3ZDZjMTQyMjQ3ZGUzNTVkNjVkODc1NzhjY2QxNDY5YjEzMDQ=", "commit": {"author": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-08-07T20:55:20Z"}, "committer": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-08-07T22:04:44Z"}, "message": "Revised core::ops::range::* docs\n\nPart of #29365.\n* Strenghtened summary/explanation split, making phrasings more parallel\n* Added links throughout\n* Fixed some example formatting & removed extraneous `fn main()`s (or hid\n  then when needed because of `#![features]`.\n* Emphasized note on `RangeFrom`'s `Iterator` implementation\n* Added summary sentences to (unstable) `contains` methods", "tree": {"sha": "c988bfee7edab6307aabc8504a03a27d1b097b0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c988bfee7edab6307aabc8504a03a27d1b097b0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1cc7d6c142247de355d65d87578ccd1469b1304", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1cc7d6c142247de355d65d87578ccd1469b1304", "html_url": "https://github.com/rust-lang/rust/commit/f1cc7d6c142247de355d65d87578ccd1469b1304", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1cc7d6c142247de355d65d87578ccd1469b1304/comments", "author": null, "committer": null, "parents": [{"sha": "5414c856891da94e0389aace71b514c6338343a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5414c856891da94e0389aace71b514c6338343a6", "html_url": "https://github.com/rust-lang/rust/commit/5414c856891da94e0389aace71b514c6338343a6"}], "stats": {"total": 215, "additions": 120, "deletions": 95}, "files": [{"sha": "6a405cfdb980946af00cc866d49671f0f96d8187", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 120, "deletions": 95, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/f1cc7d6c142247de355d65d87578ccd1469b1304/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1cc7d6c142247de355d65d87578ccd1469b1304/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=f1cc7d6c142247de355d65d87578ccd1469b1304", "patch": "@@ -10,10 +10,10 @@\n \n use fmt;\n \n-/// An unbounded range. Use `..` (two dots) for its shorthand.\n+/// An unbounded range (`..`).\n ///\n-/// Its primary use case is slicing index. It cannot serve as an iterator\n-/// because it doesn't have a starting point.\n+/// `RangeFull` is primarily used as a [slicing index], it's shorthand is `..`.\n+/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n ///\n@@ -23,16 +23,16 @@ use fmt;\n /// assert_eq!((..), std::ops::RangeFull);\n /// ```\n ///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n-/// `for` loop directly. This won't compile:\n+/// It does not have an [`IntoIterator`] implementation, so you can't use it in\n+/// a `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n /// for i in .. {\n ///    // ...\n /// }\n /// ```\n ///\n-/// Used as a slicing index, `RangeFull` produces the full array as a slice.\n+/// Used as a [slicing index], `RangeFull` produces the full array as a slice.\n ///\n /// ```\n /// let arr = [0, 1, 2, 3];\n@@ -41,6 +41,10 @@ use fmt;\n /// assert_eq!(arr[1.. ], [  1,2,3]);\n /// assert_eq!(arr[1..3], [  1,2  ]);\n /// ```\n+///\n+/// [`IntoIterator`]: ../iter/trait.Iterator.html\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n+/// [slicing index]: ../slice/trait.SliceIndex.html\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFull;\n@@ -52,24 +56,23 @@ impl fmt::Debug for RangeFull {\n     }\n }\n \n-/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.\n-/// Use `start..end` (two dots) for its shorthand.\n+/// A (half-open) range bounded inclusively below and exclusively above\n+/// (`start..end`).\n ///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// The `Range` `start..end` contains all values with `x >= start` and\n+/// `x < end`.\n ///\n /// # Examples\n ///\n /// ```\n-/// fn main() {\n-///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n-///     assert_eq!(3+4+5, (3..6).sum());\n-///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ .. ], [0,1,2,3]);\n-///     assert_eq!(arr[ ..3], [0,1,2  ]);\n-///     assert_eq!(arr[1.. ], [  1,2,3]);\n-///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n-/// }\n+/// assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n+/// assert_eq!(3 + 4 + 5, (3..6).sum());\n+///\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);\n+/// assert_eq!(arr[1.. ], [  1,2,3]);\n+/// assert_eq!(arr[1..3], [  1,2  ]);  // Range\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -91,49 +94,51 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> Range<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!( ! (3..5).contains(2));\n-    ///     assert!(   (3..5).contains(3));\n-    ///     assert!(   (3..5).contains(4));\n-    ///     assert!( ! (3..5).contains(5));\n     ///\n-    ///     assert!( ! (3..3).contains(3));\n-    ///     assert!( ! (3..2).contains(3));\n-    /// }\n+    /// # fn main() {\n+    /// assert!(!(3..5).contains(2));\n+    /// assert!( (3..5).contains(3));\n+    /// assert!( (3..5).contains(4));\n+    /// assert!(!(3..5).contains(5));\n+    ///\n+    /// assert!(!(3..3).contains(3));\n+    /// assert!(!(3..2).contains(3));\n+    /// # }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (self.start <= item) && (item < self.end)\n     }\n }\n \n-/// A range which is only bounded below: { x | start <= x }.\n-/// Use `start..` for its shorthand.\n+/// A range only bounded inclusively below (`start..`).\n ///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// The `RangeFrom` `start..` contains all values with `x >= start`.\n ///\n-/// Note: Currently, no overflow checking is done for the iterator\n+/// *Note*: Currently, no overflow checking is done for the [`Iterator`]\n /// implementation; if you use an integer range and the integer overflows, it\n-/// might panic in debug mode or create an endless loop in release mode. This\n-/// overflow behavior might change in the future.\n+/// might panic in debug mode or create an endless loop in release mode. **This\n+/// overflow behavior might change in the future.**\n ///\n /// # Examples\n ///\n /// ```\n-/// fn main() {\n-///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n-///     assert_eq!(2+3+4, (2..).take(3).sum());\n-///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ .. ], [0,1,2,3]);\n-///     assert_eq!(arr[ ..3], [0,1,2  ]);\n-///     assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n-///     assert_eq!(arr[1..3], [  1,2  ]);\n-/// }\n+/// assert_eq!((2..), std::ops::RangeFrom { start: 2 });\n+/// assert_eq!(2 + 3 + 4, (2..).take(3).sum());\n+///\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);\n+/// assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n+/// assert_eq!(arr[1..3], [  1,2  ]);\n /// ```\n+///\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n@@ -151,46 +156,47 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!( ! (3..).contains(2));\n-    ///     assert!(   (3..).contains(3));\n-    ///     assert!(   (3..).contains(1_000_000_000));\n-    /// }\n+    ///\n+    /// # fn main() {\n+    /// assert!(!(3..).contains(2));\n+    /// assert!( (3..).contains(3));\n+    /// assert!( (3..).contains(1_000_000_000));\n+    /// # }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (self.start <= item)\n     }\n }\n \n-/// A range which is only bounded above: { x | x < end }.\n-/// Use `..end` (two dots) for its shorthand.\n-///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// A range only bounded exclusively above (`..end`).\n ///\n-/// It cannot serve as an iterator because it doesn't have a starting point.\n+/// The `RangeTo` `..end` contains all values with `x < end`.\n+/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n ///\n-/// The `..{integer}` syntax is a `RangeTo`:\n+/// The `..end` syntax is a `RangeTo`:\n ///\n /// ```\n-/// assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n+/// assert_eq!((..5), std::ops::RangeTo { end: 5 });\n /// ```\n ///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n-/// `for` loop directly. This won't compile:\n+/// It does not have an [`IntoIterator`] implementation, so you can't use it in\n+/// a `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n /// for i in ..5 {\n ///     // ...\n /// }\n /// ```\n ///\n-/// When used as a slicing index, `RangeTo` produces a slice of all array\n+/// When used as a [slicing index], `RangeTo` produces a slice of all array\n /// elements before the index indicated by `end`.\n ///\n /// ```\n@@ -200,6 +206,10 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n /// assert_eq!(arr[1.. ], [  1,2,3]);\n /// assert_eq!(arr[1..3], [  1,2  ]);\n /// ```\n+///\n+/// [`IntoIterator`]: ../iter/trait.Iterator.html\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n+/// [slicing index]: ../slice/trait.SliceIndex.html\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n@@ -217,38 +227,42 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!(   (..5).contains(-1_000_000_000));\n-    ///     assert!(   (..5).contains(4));\n-    ///     assert!( ! (..5).contains(5));\n-    /// }\n+    ///\n+    /// # fn main() {\n+    /// assert!( (..5).contains(-1_000_000_000));\n+    /// assert!( (..5).contains(4));\n+    /// assert!(!(..5).contains(5));\n+    /// # }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (item < self.end)\n     }\n }\n \n-/// An inclusive range which is bounded at both ends: { x | start <= x <= end }.\n-/// Use `start...end` (three dots) for its shorthand.\n+/// An range bounded inclusively below and above (`start...end`).\n ///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// The `RangeInclusive` `start...end` contains all values with `x >= start`\n+/// and `x <= end`.\n ///\n /// # Examples\n ///\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n-/// fn main() {\n-///     assert_eq!((3...5), std::ops::RangeInclusive{ start: 3, end: 5 });\n-///     assert_eq!(3+4+5, (3...5).sum());\n ///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ ...2], [0,1,2  ]);\n-///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n-/// }\n+/// # fn main() {\n+/// assert_eq!((3...5), std::ops::RangeInclusive { start: 3, end: 5 });\n+/// assert_eq!(3 + 4 + 5, (3...5).sum());\n+///\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ ...2], [0,1,2  ]);\n+/// assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n+/// # }\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n@@ -274,43 +288,44 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n-    /// fn main() {\n-    ///     assert!( ! (3...5).contains(2));\n-    ///     assert!(   (3...5).contains(3));\n-    ///     assert!(   (3...5).contains(4));\n-    ///     assert!(   (3...5).contains(5));\n-    ///     assert!( ! (3...5).contains(6));\n     ///\n-    ///     assert!(   (3...3).contains(3));\n-    ///     assert!( ! (3...2).contains(3));\n-    /// }\n+    /// # fn main() {\n+    /// assert!(!(3...5).contains(2));\n+    /// assert!( (3...5).contains(3));\n+    /// assert!( (3...5).contains(4));\n+    /// assert!( (3...5).contains(5));\n+    /// assert!(!(3...5).contains(6));\n+    ///\n+    /// assert!( (3...3).contains(3));\n+    /// assert!(!(3...2).contains(3));\n+    /// # }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         self.start <= item && item <= self.end\n     }\n }\n \n-/// An inclusive range which is only bounded above: { x | x <= end }.\n-/// Use `...end` (three dots) for its shorthand.\n-///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// A range only bounded inclusively above (`...end`).\n ///\n-/// It cannot serve as an iterator because it doesn't have a starting point.\n+/// The `RangeToInclusive` `...end` contains all values with `x <= end`.\n+/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n ///\n-/// The `...{integer}` syntax is a `RangeToInclusive`:\n+/// The `...end` syntax is a `RangeToInclusive`:\n ///\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n /// assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n /// ```\n ///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// It does not have an [`IntoIterator`] implementation, so you can't use it in a\n /// `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n@@ -320,15 +335,22 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// }\n /// ```\n ///\n-/// When used as a slicing index, `RangeToInclusive` produces a slice of all\n+/// When used as a [slicing index], `RangeToInclusive` produces a slice of all\n /// array elements up to and including the index indicated by `end`.\n ///\n /// ```\n /// #![feature(inclusive_range_syntax)]\n+///\n+/// # fn main() {\n /// let arr = [0, 1, 2, 3];\n /// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n /// assert_eq!(arr[1...2], [  1,2  ]);\n+/// # }\n /// ```\n+///\n+/// [`IntoIterator`]: ../iter/trait.Iterator.html\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n+/// [slicing index]: ../slice/trait.SliceIndex.html\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub struct RangeToInclusive<Idx> {\n@@ -348,15 +370,18 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n-    /// fn main() {\n-    ///     assert!(   (...5).contains(-1_000_000_000));\n-    ///     assert!(   (...5).contains(5));\n-    ///     assert!( ! (...5).contains(6));\n-    /// }\n+    ///\n+    /// # fn main() {\n+    /// assert!( (...5).contains(-1_000_000_000));\n+    /// assert!( (...5).contains(5));\n+    /// assert!(!(...5).contains(6));\n+    /// # }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (item <= self.end)"}]}