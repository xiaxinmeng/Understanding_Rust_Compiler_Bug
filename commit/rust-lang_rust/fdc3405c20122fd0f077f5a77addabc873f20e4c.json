{"sha": "fdc3405c20122fd0f077f5a77addabc873f20e4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkYzM0MDVjMjAxMjJmZDBmMDc3ZjVhNzdhZGRhYmM4NzNmMjBlNGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-18T14:08:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-18T14:08:39Z"}, "message": "Auto merge of #72412 - VFLashM:issue-72408-nested-closures-exponential, r=tmandry\n\nIssue 72408 nested closures exponential\n\nThis fixes #72408.\n\nNested closures were resulting in exponential compilation time.\n\nThis PR is enhancing asymptotic complexity, but also increasing the constant, so I would love to see perf run results.", "tree": {"sha": "c30aefcbafb5ea856c9e5b37c7da1cfb9a9387dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c30aefcbafb5ea856c9e5b37c7da1cfb9a9387dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdc3405c20122fd0f077f5a77addabc873f20e4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdc3405c20122fd0f077f5a77addabc873f20e4c", "html_url": "https://github.com/rust-lang/rust/commit/fdc3405c20122fd0f077f5a77addabc873f20e4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdc3405c20122fd0f077f5a77addabc873f20e4c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c69266c0697b0c0b34abea62cba1a1d3c59c90c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c69266c0697b0c0b34abea62cba1a1d3c59c90c", "html_url": "https://github.com/rust-lang/rust/commit/2c69266c0697b0c0b34abea62cba1a1d3c59c90c"}, {"sha": "3ccb1c37e6f37070b090b63acb3751438c152ed4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ccb1c37e6f37070b090b63acb3751438c152ed4", "html_url": "https://github.com/rust-lang/rust/commit/3ccb1c37e6f37070b090b63acb3751438c152ed4"}], "stats": {"total": 422, "additions": 342, "deletions": 80}, "files": [{"sha": "7b9edca3cec133a236679757b70919d58eae5984", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -3605,6 +3605,7 @@ dependencies = [\n name = \"rustc_infer\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arrayvec\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -3744,6 +3745,7 @@ dependencies = [\n name = \"rustc_middle\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arrayvec\",\n  \"bitflags\",\n  \"chalk-ir\",\n  \"measureme\","}, {"sha": "a8c1a370cef821eeefab90a84eedd6c6dfd280fb", "filename": "compiler/rustc_infer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2FCargo.toml?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -21,4 +21,5 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+arrayvec = { version = \"0.5.1\", default-features = false }\n rustc_ast = { path = \"../rustc_ast\" }"}, {"sha": "5bd6c667fd7f63144416b354f4323c06711f7ee2", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -31,6 +31,9 @@ use super::unify_key::replace_if_possible;\n use super::unify_key::{ConstVarValue, ConstVariableValue};\n use super::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use super::{InferCtxt, MiscVariable, TypeTrace};\n+use arrayvec::ArrayVec;\n+use rustc_data_structures::fx::FxHashMap;\n+use std::hash::Hash;\n \n use crate::traits::{Obligation, PredicateObligations};\n \n@@ -44,6 +47,63 @@ use rustc_middle::ty::{self, InferConst, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{IntType, UintType};\n use rustc_span::DUMMY_SP;\n \n+/// Small-storage-optimized implementation of a map\n+/// made specifically for caching results.\n+///\n+/// Stores elements in a small array up to a certain length\n+/// and switches to `HashMap` when that length is exceeded.\n+enum MiniMap<K, V> {\n+    Array(ArrayVec<[(K, V); 8]>),\n+    Map(FxHashMap<K, V>),\n+}\n+\n+impl<K: Eq + Hash, V> MiniMap<K, V> {\n+    /// Creates an empty `MiniMap`.\n+    pub fn new() -> Self {\n+        MiniMap::Array(ArrayVec::new())\n+    }\n+\n+    /// Inserts or updates value in the map.\n+    pub fn insert(&mut self, key: K, value: V) {\n+        match self {\n+            MiniMap::Array(array) => {\n+                for pair in array.iter_mut() {\n+                    if pair.0 == key {\n+                        pair.1 = value;\n+                        return;\n+                    }\n+                }\n+                if let Err(error) = array.try_push((key, value)) {\n+                    let mut map: FxHashMap<K, V> = array.drain(..).collect();\n+                    let (key, value) = error.element();\n+                    map.insert(key, value);\n+                    *self = MiniMap::Map(map);\n+                }\n+            }\n+            MiniMap::Map(map) => {\n+                map.insert(key, value);\n+            }\n+        }\n+    }\n+\n+    /// Return value by key if any.\n+    pub fn get(&self, key: &K) -> Option<&V> {\n+        match self {\n+            MiniMap::Array(array) => {\n+                for pair in array {\n+                    if pair.0 == *key {\n+                        return Some(&pair.1);\n+                    }\n+                }\n+                return None;\n+            }\n+            MiniMap::Map(map) => {\n+                return map.get(key);\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct CombineFields<'infcx, 'tcx> {\n     pub infcx: &'infcx InferCtxt<'infcx, 'tcx>,\n@@ -379,6 +439,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             needs_wf: false,\n             root_ty: ty,\n             param_env: self.param_env,\n+            cache: MiniMap::new(),\n         };\n \n         let ty = match generalize.relate(ty, ty) {\n@@ -438,6 +499,8 @@ struct Generalizer<'cx, 'tcx> {\n     root_ty: Ty<'tcx>,\n \n     param_env: ty::ParamEnv<'tcx>,\n+\n+    cache: MiniMap<Ty<'tcx>, RelateResult<'tcx, Ty<'tcx>>>,\n }\n \n /// Result from a generalization operation. This includes\n@@ -535,13 +598,16 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         assert_eq!(t, t2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n \n+        if let Some(result) = self.cache.get(&t) {\n+            return result.clone();\n+        }\n         debug!(\"generalize: t={:?}\", t);\n \n         // Check to see whether the type we are generalizing references\n         // any other type variable related to `vid` via\n         // subtyping. This is basically our \"occurs check\", preventing\n         // us from creating infinitely sized types.\n-        match *t.kind() {\n+        let result = match *t.kind() {\n             ty::Infer(ty::TyVar(vid)) => {\n                 let vid = self.infcx.inner.borrow_mut().type_variables().root_var(vid);\n                 let sub_vid = self.infcx.inner.borrow_mut().type_variables().sub_root_var(vid);\n@@ -598,7 +664,10 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 Ok(t)\n             }\n             _ => relate::super_relate_tys(self, t, t),\n-        }\n+        };\n+\n+        self.cache.insert(t, result.clone());\n+        return result;\n     }\n \n     fn regions("}, {"sha": "e06bfb5958086f9ddc414b9fdc7ba4dba4501e46", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -3,6 +3,7 @@ use crate::infer::{GenericKind, VerifyBound};\n use rustc_data_structures::captures::Captures;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n+use rustc_middle::ty::walk::MiniSet;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n@@ -31,16 +32,23 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     /// Returns a \"verify bound\" that encodes what we know about\n     /// `generic` and the regions it outlives.\n     pub fn generic_bound(&self, generic: GenericKind<'tcx>) -> VerifyBound<'tcx> {\n+        let mut visited = MiniSet::new();\n         match generic {\n             GenericKind::Param(param_ty) => self.param_bound(param_ty),\n-            GenericKind::Projection(projection_ty) => self.projection_bound(projection_ty),\n+            GenericKind::Projection(projection_ty) => {\n+                self.projection_bound(projection_ty, &mut visited)\n+            }\n         }\n     }\n \n-    fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+    fn type_bound(\n+        &self,\n+        ty: Ty<'tcx>,\n+        visited: &mut MiniSet<GenericArg<'tcx>>,\n+    ) -> VerifyBound<'tcx> {\n         match *ty.kind() {\n             ty::Param(p) => self.param_bound(p),\n-            ty::Projection(data) => self.projection_bound(data),\n+            ty::Projection(data) => self.projection_bound(data, visited),\n             ty::FnDef(_, substs) => {\n                 // HACK(eddyb) ignore lifetimes found shallowly in `substs`.\n                 // This is inconsistent with `ty::Adt` (including all substs),\n@@ -50,9 +58,9 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                 let mut bounds = substs\n                     .iter()\n                     .filter_map(|child| match child.unpack() {\n-                        GenericArgKind::Type(ty) => Some(self.type_bound(ty)),\n+                        GenericArgKind::Type(ty) => Some(self.type_bound(ty, visited)),\n                         GenericArgKind::Lifetime(_) => None,\n-                        GenericArgKind::Const(_) => Some(self.recursive_bound(child)),\n+                        GenericArgKind::Const(_) => Some(self.recursive_bound(child, visited)),\n                     })\n                     .filter(|bound| {\n                         // Remove bounds that must hold, since they are not interesting.\n@@ -66,7 +74,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                     ),\n                 }\n             }\n-            _ => self.recursive_bound(ty.into()),\n+            _ => self.recursive_bound(ty.into(), visited),\n         }\n     }\n \n@@ -137,7 +145,11 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         self.declared_projection_bounds_from_trait(projection_ty)\n     }\n \n-    pub fn projection_bound(&self, projection_ty: ty::ProjectionTy<'tcx>) -> VerifyBound<'tcx> {\n+    pub fn projection_bound(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        visited: &mut MiniSet<GenericArg<'tcx>>,\n+    ) -> VerifyBound<'tcx> {\n         debug!(\"projection_bound(projection_ty={:?})\", projection_ty);\n \n         let projection_ty_as_ty =\n@@ -166,21 +178,25 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n \n         // see the extensive comment in projection_must_outlive\n         let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-        let recursive_bound = self.recursive_bound(ty.into());\n+        let recursive_bound = self.recursive_bound(ty.into(), visited);\n \n         VerifyBound::AnyBound(env_bounds.chain(trait_bounds).collect()).or(recursive_bound)\n     }\n \n-    fn recursive_bound(&self, parent: GenericArg<'tcx>) -> VerifyBound<'tcx> {\n+    fn recursive_bound(\n+        &self,\n+        parent: GenericArg<'tcx>,\n+        visited: &mut MiniSet<GenericArg<'tcx>>,\n+    ) -> VerifyBound<'tcx> {\n         let mut bounds = parent\n-            .walk_shallow()\n+            .walk_shallow(visited)\n             .filter_map(|child| match child.unpack() {\n-                GenericArgKind::Type(ty) => Some(self.type_bound(ty)),\n+                GenericArgKind::Type(ty) => Some(self.type_bound(ty, visited)),\n                 GenericArgKind::Lifetime(lt) => {\n                     // Ignore late-bound regions.\n                     if !lt.is_late_bound() { Some(VerifyBound::OutlivedBy(lt)) } else { None }\n                 }\n-                GenericArgKind::Const(_) => Some(self.recursive_bound(child)),\n+                GenericArgKind::Const(_) => Some(self.recursive_bound(child, visited)),\n             })\n             .filter(|bound| {\n                 // Remove bounds that must hold, since they are not interesting."}, {"sha": "1d84ddad7f52dd0cdd39d2b1c496925f9375557d", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -28,5 +28,6 @@ rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n chalk-ir = \"0.21.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+arrayvec = { version = \"0.5.1\", default-features = false }\n measureme = \"0.7.1\"\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "01649f44c8861f4b6403e9b75f274c13107e5ca4", "filename": "compiler/rustc_middle/src/ty/outlives.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -3,6 +3,7 @@\n // RFC for reference.\n \n use crate::ty::subst::{GenericArg, GenericArgKind};\n+use crate::ty::walk::MiniSet;\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use smallvec::SmallVec;\n \n@@ -50,12 +51,18 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Push onto `out` all the things that must outlive `'a` for the condition\n     /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n     pub fn push_outlives_components(self, ty0: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n-        compute_components(self, ty0, out);\n+        let mut visited = MiniSet::new();\n+        compute_components(self, ty0, out, &mut visited);\n         debug!(\"components({:?}) = {:?}\", ty0, out);\n     }\n }\n \n-fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n+fn compute_components(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    out: &mut SmallVec<[Component<'tcx>; 4]>,\n+    visited: &mut MiniSet<GenericArg<'tcx>>,\n+) {\n     // Descend through the types, looking for the various \"base\"\n     // components and collecting them into `out`. This is not written\n     // with `collect()` because of the need to sometimes skip subtrees\n@@ -73,31 +80,31 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                 for child in substs {\n                     match child.unpack() {\n                         GenericArgKind::Type(ty) => {\n-                            compute_components(tcx, ty, out);\n+                            compute_components(tcx, ty, out, visited);\n                         }\n                         GenericArgKind::Lifetime(_) => {}\n                         GenericArgKind::Const(_) => {\n-                            compute_components_recursive(tcx, child, out);\n+                            compute_components_recursive(tcx, child, out, visited);\n                         }\n                     }\n                 }\n             }\n \n             ty::Array(element, _) => {\n                 // Don't look into the len const as it doesn't affect regions\n-                compute_components(tcx, element, out);\n+                compute_components(tcx, element, out, visited);\n             }\n \n             ty::Closure(_, ref substs) => {\n                 for upvar_ty in substs.as_closure().upvar_tys() {\n-                    compute_components(tcx, upvar_ty, out);\n+                    compute_components(tcx, upvar_ty, out, visited);\n                 }\n             }\n \n             ty::Generator(_, ref substs, _) => {\n                 // Same as the closure case\n                 for upvar_ty in substs.as_generator().upvar_tys() {\n-                    compute_components(tcx, upvar_ty, out);\n+                    compute_components(tcx, upvar_ty, out, visited);\n                 }\n \n                 // We ignore regions in the generator interior as we don't\n@@ -135,7 +142,8 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                     // OutlivesProjectionComponents.  Continue walking\n                     // through and constrain Pi.\n                     let mut subcomponents = smallvec![];\n-                    compute_components_recursive(tcx, ty.into(), &mut subcomponents);\n+                    let mut subvisited = MiniSet::new();\n+                    compute_components_recursive(tcx, ty.into(), &mut subcomponents, &mut subvisited);\n                     out.push(Component::EscapingProjection(subcomponents.into_iter().collect()));\n                 }\n             }\n@@ -177,7 +185,7 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                 // the \"bound regions list\".  In our representation, no such\n                 // list is maintained explicitly, because bound regions\n                 // themselves can be readily identified.\n-                compute_components_recursive(tcx, ty.into(), out);\n+                compute_components_recursive(tcx, ty.into(), out, visited);\n             }\n         }\n }\n@@ -186,11 +194,12 @@ fn compute_components_recursive(\n     tcx: TyCtxt<'tcx>,\n     parent: GenericArg<'tcx>,\n     out: &mut SmallVec<[Component<'tcx>; 4]>,\n+    visited: &mut MiniSet<GenericArg<'tcx>>,\n ) {\n-    for child in parent.walk_shallow() {\n+    for child in parent.walk_shallow(visited) {\n         match child.unpack() {\n             GenericArgKind::Type(ty) => {\n-                compute_components(tcx, ty, out);\n+                compute_components(tcx, ty, out, visited);\n             }\n             GenericArgKind::Lifetime(lt) => {\n                 // Ignore late-bound regions.\n@@ -199,7 +208,7 @@ fn compute_components_recursive(\n                 }\n             }\n             GenericArgKind::Const(_) => {\n-                compute_components_recursive(tcx, child, out);\n+                compute_components_recursive(tcx, child, out, visited);\n             }\n         }\n     }"}, {"sha": "f315292dab546adb4b8214e518414972bfca226a", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -4,6 +4,7 @@ use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n+use rustc_middle::ty::walk::MiniSet;\n \n // `pretty` is a separate module only for organization.\n mod pretty;\n@@ -263,21 +264,33 @@ pub trait Printer<'tcx>: Sized {\n /// function tries to find a \"characteristic `DefId`\" for a\n /// type. It's just a heuristic so it makes some questionable\n /// decisions and we may want to adjust it later.\n-pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n+///\n+/// Visited set is needed to avoid full iteration over\n+/// deeply nested tuples that have no DefId.\n+fn characteristic_def_id_of_type_cached<'a>(\n+    ty: Ty<'a>,\n+    visited: &mut MiniSet<Ty<'a>>,\n+) -> Option<DefId> {\n     match *ty.kind() {\n         ty::Adt(adt_def, _) => Some(adt_def.did),\n \n         ty::Dynamic(data, ..) => data.principal_def_id(),\n \n-        ty::Array(subty, _) | ty::Slice(subty) => characteristic_def_id_of_type(subty),\n+        ty::Array(subty, _) | ty::Slice(subty) => {\n+            characteristic_def_id_of_type_cached(subty, visited)\n+        }\n \n-        ty::RawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n+        ty::RawPtr(mt) => characteristic_def_id_of_type_cached(mt.ty, visited),\n \n-        ty::Ref(_, ty, _) => characteristic_def_id_of_type(ty),\n+        ty::Ref(_, ty, _) => characteristic_def_id_of_type_cached(ty, visited),\n \n-        ty::Tuple(ref tys) => {\n-            tys.iter().find_map(|ty| characteristic_def_id_of_type(ty.expect_ty()))\n-        }\n+        ty::Tuple(ref tys) => tys.iter().find_map(|ty| {\n+            let ty = ty.expect_ty();\n+            if visited.insert(ty) {\n+                return characteristic_def_id_of_type_cached(ty, visited);\n+            }\n+            return None;\n+        }),\n \n         ty::FnDef(def_id, _)\n         | ty::Closure(def_id, _)\n@@ -302,6 +315,9 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n         | ty::Float(_) => None,\n     }\n }\n+pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n+    characteristic_def_id_of_type_cached(ty, &mut MiniSet::new())\n+}\n \n impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::RegionKind {\n     type Output = P::Region;"}, {"sha": "f0bae48cc1221798ef8bea519e8c91117a03e936", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -1264,6 +1264,7 @@ pub struct FmtPrinterData<'a, 'tcx, F> {\n     used_region_names: FxHashSet<Symbol>,\n     region_index: usize,\n     binder_depth: usize,\n+    printed_type_count: usize,\n \n     pub region_highlight_mode: RegionHighlightMode,\n \n@@ -1294,6 +1295,7 @@ impl<F> FmtPrinter<'a, 'tcx, F> {\n             used_region_names: Default::default(),\n             region_index: 0,\n             binder_depth: 0,\n+            printed_type_count: 0,\n             region_highlight_mode: RegionHighlightMode::default(),\n             name_resolver: None,\n         }))\n@@ -1411,8 +1413,14 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         self.pretty_print_region(region)\n     }\n \n-    fn print_type(self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n-        self.pretty_print_type(ty)\n+    fn print_type(mut self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n+        if self.tcx.sess.type_length_limit().value_within_limit(self.printed_type_count) {\n+            self.printed_type_count += 1;\n+            self.pretty_print_type(ty)\n+        } else {\n+            write!(self, \"...\")?;\n+            Ok(self)\n+        }\n     }\n \n     fn print_dyn_existential("}, {"sha": "7afa6e6cc056d4f948e5dc0f8e4a9ca7a9fde3ba", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 72, "deletions": 8, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -3,7 +3,50 @@\n \n use crate::ty;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n+use arrayvec::ArrayVec;\n+use rustc_data_structures::fx::FxHashSet;\n use smallvec::{self, SmallVec};\n+use std::hash::Hash;\n+\n+/// Small-storage-optimized implementation of a set\n+/// made specifically for walking type tree.\n+///\n+/// Stores elements in a small array up to a certain length\n+/// and switches to `HashSet` when that length is exceeded.\n+pub enum MiniSet<T> {\n+    Array(ArrayVec<[T; 8]>),\n+    Set(FxHashSet<T>),\n+}\n+\n+impl<T: Eq + Hash + Copy> MiniSet<T> {\n+    /// Creates an empty `MiniSet`.\n+    pub fn new() -> Self {\n+        MiniSet::Array(ArrayVec::new())\n+    }\n+\n+    /// Adds a value to the set.\n+    ///\n+    /// If the set did not have this value present, true is returned.\n+    ///\n+    /// If the set did have this value present, false is returned.\n+    pub fn insert(&mut self, elem: T) -> bool {\n+        match self {\n+            MiniSet::Array(array) => {\n+                if array.iter().any(|e| *e == elem) {\n+                    false\n+                } else {\n+                    if array.try_push(elem).is_err() {\n+                        let mut set: FxHashSet<T> = array.iter().copied().collect();\n+                        set.insert(elem);\n+                        *self = MiniSet::Set(set);\n+                    }\n+                    true\n+                }\n+            }\n+            MiniSet::Set(set) => set.insert(elem),\n+        }\n+    }\n+}\n \n // The TypeWalker's stack is hot enough that it's worth going to some effort to\n // avoid heap allocations.\n@@ -12,11 +55,20 @@ type TypeWalkerStack<'tcx> = SmallVec<[GenericArg<'tcx>; 8]>;\n pub struct TypeWalker<'tcx> {\n     stack: TypeWalkerStack<'tcx>,\n     last_subtree: usize,\n+    visited: MiniSet<GenericArg<'tcx>>,\n }\n \n+/// An iterator for walking the type tree.\n+///\n+/// It's very easy to produce a deeply\n+/// nested type tree with a lot of\n+/// identical subtrees. In order to work efficiently\n+/// in this situation walker only visits each type once.\n+/// It maintains a set of visited types and\n+/// skips any types that are already there.\n impl<'tcx> TypeWalker<'tcx> {\n-    pub fn new(root: GenericArg<'tcx>) -> TypeWalker<'tcx> {\n-        TypeWalker { stack: smallvec![root], last_subtree: 1 }\n+    pub fn new(root: GenericArg<'tcx>) -> Self {\n+        Self { stack: smallvec![root], last_subtree: 1, visited: MiniSet::new() }\n     }\n \n     /// Skips the subtree corresponding to the last type\n@@ -41,11 +93,15 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n \n     fn next(&mut self) -> Option<GenericArg<'tcx>> {\n         debug!(\"next(): stack={:?}\", self.stack);\n-        let next = self.stack.pop()?;\n-        self.last_subtree = self.stack.len();\n-        push_inner(&mut self.stack, next);\n-        debug!(\"next: stack={:?}\", self.stack);\n-        Some(next)\n+        loop {\n+            let next = self.stack.pop()?;\n+            self.last_subtree = self.stack.len();\n+            if self.visited.insert(next) {\n+                push_inner(&mut self.stack, next);\n+                debug!(\"next: stack={:?}\", self.stack);\n+                return Some(next);\n+            }\n+        }\n     }\n }\n \n@@ -67,9 +123,17 @@ impl GenericArg<'tcx> {\n     /// Iterator that walks the immediate children of `self`. Hence\n     /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n     /// (but not `i32`, like `walk`).\n-    pub fn walk_shallow(self) -> impl Iterator<Item = GenericArg<'tcx>> {\n+    ///\n+    /// Iterator only walks items once.\n+    /// It accepts visited set, updates it with all visited types\n+    /// and skips any types that are already there.\n+    pub fn walk_shallow(\n+        self,\n+        visited: &mut MiniSet<GenericArg<'tcx>>,\n+    ) -> impl Iterator<Item = GenericArg<'tcx>> {\n         let mut stack = SmallVec::new();\n         push_inner(&mut stack, self);\n+        stack.retain(|a| visited.insert(*a));\n         stack.into_iter()\n     }\n }"}, {"sha": "0dbb4b1015e79ab5f1eb984fdac0f82dafc2a291", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -418,6 +418,29 @@ fn record_accesses<'a, 'tcx: 'a>(\n     inlining_map.lock_mut().record_accesses(caller, &accesses);\n }\n \n+// Shrinks string by keeping prefix and suffix of given sizes.\n+fn shrink(s: String, before: usize, after: usize) -> String {\n+    // An iterator of all byte positions including the end of the string.\n+    let positions = || s.char_indices().map(|(i, _)| i).chain(iter::once(s.len()));\n+\n+    let shrunk = format!(\n+        \"{before}...{after}\",\n+        before = &s[..positions().nth(before).unwrap_or(s.len())],\n+        after = &s[positions().rev().nth(after).unwrap_or(0)..],\n+    );\n+\n+    // Only use the shrunk version if it's really shorter.\n+    // This also avoids the case where before and after slices overlap.\n+    if shrunk.len() < s.len() { shrunk } else { s }\n+}\n+\n+// Format instance name that is already known to be too long for rustc.\n+// Show only the first and last 32 characters to avoid blasting\n+// the user's terminal with thousands of lines of type-name.\n+fn shrunk_instance_name(instance: &Instance<'tcx>) -> String {\n+    shrink(instance.to_string(), 32, 32)\n+}\n+\n fn check_recursion_limit<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n@@ -440,7 +463,10 @@ fn check_recursion_limit<'tcx>(\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n     if !tcx.sess.recursion_limit().value_within_limit(adjusted_recursion_depth) {\n-        let error = format!(\"reached the recursion limit while instantiating `{}`\", instance);\n+        let error = format!(\n+            \"reached the recursion limit while instantiating `{}`\",\n+            shrunk_instance_name(&instance),\n+        );\n         let mut err = tcx.sess.struct_span_fatal(span, &error);\n         err.span_note(\n             tcx.def_span(def_id),\n@@ -474,26 +500,9 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     //\n     // Bail out in these cases to avoid that bad user experience.\n     if !tcx.sess.type_length_limit().value_within_limit(type_length) {\n-        // The instance name is already known to be too long for rustc.\n-        // Show only the first and last 32 characters to avoid blasting\n-        // the user's terminal with thousands of lines of type-name.\n-        let shrink = |s: String, before: usize, after: usize| {\n-            // An iterator of all byte positions including the end of the string.\n-            let positions = || s.char_indices().map(|(i, _)| i).chain(iter::once(s.len()));\n-\n-            let shrunk = format!(\n-                \"{before}...{after}\",\n-                before = &s[..positions().nth(before).unwrap_or(s.len())],\n-                after = &s[positions().rev().nth(after).unwrap_or(0)..],\n-            );\n-\n-            // Only use the shrunk version if it's really shorter.\n-            // This also avoids the case where before and after slices overlap.\n-            if shrunk.len() < s.len() { shrunk } else { s }\n-        };\n         let msg = format!(\n             \"reached the type-length limit while instantiating `{}`\",\n-            shrink(instance.to_string(), 32, 32)\n+            shrunk_instance_name(&instance),\n         );\n         let mut diag = tcx.sess.struct_span_fatal(tcx.def_span(instance.def_id()), &msg);\n         diag.note(&format!("}, {"sha": "2d6ba936572d58385393c043f808eb67f4958c6d", "filename": "src/test/ui/closures/issue-72408-nested-closures-exponential.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fclosures%2Fissue-72408-nested-closures-exponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fclosures%2Fissue-72408-nested-closures-exponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-72408-nested-closures-exponential.rs?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -0,0 +1,59 @@\n+// build-pass\n+\n+// Closures include captured types twice in a type tree.\n+//\n+// Wrapping one closure with another leads to doubling\n+// the amount of types in the type tree.\n+//\n+// This test ensures that rust can handle\n+// deeply nested type trees with a lot\n+// of duplicated subtrees.\n+\n+fn dup(f: impl Fn(i32) -> i32) -> impl Fn(i32) -> i32 {\n+    move |a| f(a * 2)\n+}\n+\n+fn main() {\n+    let f = |a| a;\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    // Compiler dies around here if it tries\n+    // to walk the tree exhaustively.\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    println!(\"Type size was at least {}\", f(1));\n+}"}, {"sha": "d27d14842ce99f1f61c6cdc35a6f515722c9d3a3", "filename": "src/test/ui/infinite/infinite-instantiation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.stderr?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -1,4 +1,4 @@\n-error: reached the recursion limit while instantiating `function::<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<usize>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+error: reached the recursion limit while instantiating `function::<Option<Option<Option<...>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n   --> $DIR/infinite-instantiation.rs:21:9\n    |\n LL |         function(counter - 1, t.to_option());"}, {"sha": "89137538425bfbdb948e30b78ccc7572e366aee5", "filename": "src/test/ui/issues/issue-22638.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-22638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-22638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22638.rs?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -51,9 +51,9 @@ struct D (Box<A>);\n \n impl D {\n     pub fn matches<F: Fn()>(&self, f: &F) {\n-        //~^ ERROR reached the type-length limit while instantiating `D::matches::<[closure\n         let &D(ref a) = self;\n         a.matches(f)\n+        //~^ ERROR reached the recursion limit while instantiating `A::matches::<[closure\n     }\n }\n "}, {"sha": "c4255b95b704e4016bc4dc93f6a4e3356e82077a", "filename": "src/test/ui/issues/issue-22638.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -1,10 +1,14 @@\n-error: reached the type-length limit while instantiating `D::matches::$CLOSURE`\n-  --> $DIR/issue-22638.rs:53:5\n+error: reached the recursion limit while instantiating `A::matches::$CLOSURE`\n+  --> $DIR/issue-22638.rs:55:9\n+   |\n+LL |         a.matches(f)\n+   |         ^^^^^^^^^^^^\n+   |\n+note: `A::matches` defined here\n+  --> $DIR/issue-22638.rs:14:5\n    |\n LL |     pub fn matches<F: Fn()>(&self, f: &F) {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: consider adding a `#![type_length_limit=\"30408681\"]` attribute to your crate\n \n error: aborting due to previous error\n "}, {"sha": "d3d5863ddb3c9b6d1c757b7bb4f64c12889f7451", "filename": "src/test/ui/issues/issue-37311-type-length-limit/issue-37311.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.rs?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -12,8 +12,8 @@ trait Foo {\n \n impl<T> Foo for T {\n     #[allow(unconditional_recursion)]\n-    fn recurse(&self) { //~ ERROR reached the type-length limit\n-        (self, self).recurse();\n+    fn recurse(&self) {\n+        (self, self).recurse(); //~ ERROR reached the recursion limit\n     }\n }\n "}, {"sha": "a94f190d6b25d2f566c5ec45b37ceba07946b5d4", "filename": "src/test/ui/issues/issue-37311-type-length-limit/issue-37311.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.stderr?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -1,10 +1,14 @@\n-error: reached the type-length limit while instantiating `<(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(...))))))))))))))) as Foo>::recurse`\n+error: reached the recursion limit while instantiating `<(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(.....), ...), ...) as Foo>::recurse`\n+  --> $DIR/issue-37311.rs:16:9\n+   |\n+LL |         (self, self).recurse();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `<T as Foo>::recurse` defined here\n   --> $DIR/issue-37311.rs:15:5\n    |\n LL |     fn recurse(&self) {\n    |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: consider adding a `#![type_length_limit=\"2097149\"]` attribute to your crate\n \n error: aborting due to previous error\n "}, {"sha": "f3e73399b57ce7445ca61bdfca2f7f52239e4874", "filename": "src/test/ui/issues/issue-67552.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -1,4 +1,4 @@\n-error: reached the recursion limit while instantiating `rec::<&mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut Empty>`\n+error: reached the recursion limit while instantiating `rec::<&mut &mut &mut &mut &mut &... &mut &mut &mut &mut &mut Empty>`\n   --> $DIR/issue-67552.rs:27:9\n    |\n LL |         rec(identity(&mut it))"}, {"sha": "279e3ffbb4a41772ea53b7171172aa490fa3666a", "filename": "src/test/ui/issues/issue-8727.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-8727.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Fissues%2Fissue-8727.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8727.stderr?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -9,7 +9,7 @@ LL |     generic::<Option<T>>();\n    = note: `#[warn(unconditional_recursion)]` on by default\n    = help: a `loop` may express intention better if this is on purpose\n \n-error: reached the recursion limit while instantiating `generic::<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<Option<i32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+error: reached the recursion limit while instantiating `generic::<Option<Option<Option<O...>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n   --> $DIR/issue-8727.rs:7:5\n    |\n LL |     generic::<Option<T>>();"}, {"sha": "4d77b3d295c00bc203843fe98a6ecf64d669367b", "filename": "src/test/ui/recursion/issue-38591-non-regular-dropck-recursion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -1,4 +1,4 @@\n-error: reached the recursion limit while instantiating `drop_in_place::<S<fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(u32))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))>> - shim(Some(S<fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(u32))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))>))`\n+error: reached the recursion limit while instantiating `drop_in_place::<S<fn(fn(fn(fn(fn...)))))))))))))))))))))))))))))>))`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {"}, {"sha": "085bf82ef8b9351773b4bafd488a96476dcfb256", "filename": "src/test/ui/recursion/recursion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -1,4 +1,4 @@\n-error: reached the recursion limit while instantiating `test::<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Nil>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+error: reached the recursion limit while instantiating `test::<Cons<Cons<Cons<Cons<Cons<...>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n   --> $DIR/recursion.rs:17:11\n    |\n LL |     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}"}, {"sha": "921cded5037b67c3dcec87b9e8ababb67014e488", "filename": "src/test/ui/type_length_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Ftype_length_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Ftype_length_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype_length_limit.rs?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -4,7 +4,7 @@\n // Test that the type length limit can be changed.\n \n #![allow(dead_code)]\n-#![type_length_limit=\"256\"]\n+#![type_length_limit=\"4\"]\n \n macro_rules! link {\n     ($id:ident, $t:ty) => {"}, {"sha": "cf3d64d734ba0de7c28f986d1f75e1087e45dd4c", "filename": "src/test/ui/type_length_limit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdc3405c20122fd0f077f5a77addabc873f20e4c/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype_length_limit.stderr?ref=fdc3405c20122fd0f077f5a77addabc873f20e4c", "patch": "@@ -1,10 +1,10 @@\n-error: reached the type-length limit while instantiating `std::mem::drop::<Option<((((((G,... G), (G, G, G), (G, G, G))))))>>`\n+error: reached the type-length limit while instantiating `std::mem::drop::<Option<((((...,....., ...), ..., ...), ..., ...)>>`\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n LL | pub fn drop<T>(_x: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: consider adding a `#![type_length_limit=\"1094\"]` attribute to your crate\n+   = note: consider adding a `#![type_length_limit=\"8\"]` attribute to your crate\n \n error: aborting due to previous error\n "}]}