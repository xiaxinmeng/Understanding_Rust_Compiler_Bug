{"sha": "f102616aaea2894508f8f078cfb20ceef5411d12", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMDI2MTZhYWVhMjg5NDUwOGY4ZjA3OGNmYjIwY2VlZjU0MTFkMTI=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-03T20:45:03Z"}, "committer": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-03T20:45:03Z"}, "message": "allow modifications of vars from outer scope inside extracted function\n\nIt currently allows only directly setting variable.\nNo `&mut` references or methods.", "tree": {"sha": "fe2f951fd8fe9d3ed9aa7e92db9f467a8bb7fc66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe2f951fd8fe9d3ed9aa7e92db9f467a8bb7fc66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f102616aaea2894508f8f078cfb20ceef5411d12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f102616aaea2894508f8f078cfb20ceef5411d12", "html_url": "https://github.com/rust-lang/rust/commit/f102616aaea2894508f8f078cfb20ceef5411d12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f102616aaea2894508f8f078cfb20ceef5411d12/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82787febdee3e7dfe5a96c94aee03cd726f642f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/82787febdee3e7dfe5a96c94aee03cd726f642f9", "html_url": "https://github.com/rust-lang/rust/commit/82787febdee3e7dfe5a96c94aee03cd726f642f9"}], "stats": {"total": 383, "additions": 337, "deletions": 46}, "files": [{"sha": "ffa8bd77dc60593aba9ae7e490ea0f2f31af63b7", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "modified", "additions": 336, "deletions": 45, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/f102616aaea2894508f8f078cfb20ceef5411d12/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f102616aaea2894508f8f078cfb20ceef5411d12/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=f102616aaea2894508f8f078cfb20ceef5411d12", "patch": "@@ -2,19 +2,20 @@ use either::Either;\n use hir::{HirDisplay, Local};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n-    search::SearchScope,\n+    search::{ReferenceAccess, SearchScope},\n };\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n+    algo::SyntaxRewriter,\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n-        AstNode, NameOwner,\n+        AstNode,\n     },\n     Direction, SyntaxElement,\n     SyntaxKind::{self, BLOCK_EXPR, BREAK_EXPR, COMMENT, PATH_EXPR, RETURN_EXPR},\n-    SyntaxNode, TextRange,\n+    SyntaxNode, TextRange, T,\n };\n use test_utils::mark;\n \n@@ -88,16 +89,16 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     let mut self_param = None;\n     let param_pats: Vec<_> = vars_used_in_body\n         .iter()\n-        .map(|node| node.source(ctx.db()))\n-        .filter(|src| {\n+        .map(|node| (node, node.source(ctx.db())))\n+        .filter(|(_, src)| {\n             src.file_id.original_file(ctx.db()) == ctx.frange.file_id\n                 && !body.contains_node(&either_syntax(&src.value))\n         })\n-        .filter_map(|src| match src.value {\n-            Either::Left(pat) => Some(pat),\n+        .filter_map(|(&node, src)| match src.value {\n+            Either::Left(_) => Some(node),\n             Either::Right(it) => {\n                 // we filter self param, as there can only be one\n-                self_param = Some(it);\n+                self_param = Some((node, it));\n                 None\n             }\n         })\n@@ -109,7 +110,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n \n     let vars_defined_in_body = vars_defined_in_body(&body, ctx);\n \n-    let vars_in_body_used_afterwards: Vec<_> = vars_defined_in_body\n+    let vars_defined_in_body_and_outlive: Vec<_> = vars_defined_in_body\n         .iter()\n         .copied()\n         .filter(|node| {\n@@ -123,20 +124,27 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         })\n         .collect();\n \n-    let params = param_pats\n+    let params: Vec<_> = param_pats\n         .into_iter()\n-        .map(|pat| {\n-            let name = pat.name().unwrap().to_string();\n-\n-            let ty = ctx\n-                .sema\n-                .type_of_pat(&pat.into())\n-                .and_then(|ty| ty.display_source_code(ctx.db(), module.into()).ok())\n-                .unwrap_or_else(|| \"()\".to_string());\n+        .map(|node| {\n+            let usages = Definition::Local(node)\n+                .usages(&ctx.sema)\n+                .in_scope(SearchScope::single_file(ctx.frange.file_id))\n+                .all();\n \n-            Param { name, ty }\n+            let has_usages_afterwards = usages\n+                .iter()\n+                .flat_map(|(_, rs)| rs.iter())\n+                .any(|reference| body.preceedes_range(reference.range));\n+            let has_mut_inside_body = usages\n+                .iter()\n+                .flat_map(|(_, rs)| rs.iter())\n+                .filter(|reference| body.contains_range(reference.range))\n+                .any(|reference| reference.access == Some(ReferenceAccess::Write));\n+\n+            Param { node, has_usages_afterwards, has_mut_inside_body, is_copy: true }\n         })\n-        .collect::<Vec<_>>();\n+        .collect();\n \n     let expr = body.tail_expr();\n     let ret_ty = match expr {\n@@ -145,7 +153,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     };\n \n     let has_unit_ret = ret_ty.as_ref().map_or(true, |it| it.is_unit());\n-    if stdx::never!(!vars_in_body_used_afterwards.is_empty() && !has_unit_ret) {\n+    if stdx::never!(!vars_defined_in_body_and_outlive.is_empty() && !has_unit_ret) {\n         // We should not have variables that outlive body if we have expression block\n         return None;\n     }\n@@ -162,11 +170,11 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         move |builder| {\n             let fun = Function {\n                 name: \"fun_name\".to_string(),\n-                self_param,\n+                self_param: self_param.map(|(_, pat)| pat),\n                 params,\n                 ret_ty,\n                 body,\n-                vars_in_body_used_afterwards,\n+                vars_defined_in_body_and_outlive,\n             };\n \n             builder.replace(target_range, format_replacement(ctx, &fun));\n@@ -183,17 +191,13 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n fn format_replacement(ctx: &AssistContext, fun: &Function) -> String {\n     let mut buf = String::new();\n \n-    match fun.vars_in_body_used_afterwards.len() {\n-        0 => {}\n-        1 => format_to!(\n-            buf,\n-            \"let {} = \",\n-            fun.vars_in_body_used_afterwards[0].name(ctx.db()).unwrap()\n-        ),\n-        _ => {\n+    match fun.vars_defined_in_body_and_outlive.as_slice() {\n+        [] => {}\n+        [var] => format_to!(buf, \"let {} = \", var.name(ctx.db()).unwrap()),\n+        [v0, vs @ ..] => {\n             buf.push_str(\"let (\");\n-            format_to!(buf, \"{}\", fun.vars_in_body_used_afterwards[0].name(ctx.db()).unwrap());\n-            for local in fun.vars_in_body_used_afterwards.iter().skip(1) {\n+            format_to!(buf, \"{}\", v0.name(ctx.db()).unwrap());\n+            for local in vs {\n                 format_to!(buf, \", {}\", local.name(ctx.db()).unwrap());\n             }\n             buf.push_str(\") = \");\n@@ -207,10 +211,10 @@ fn format_replacement(ctx: &AssistContext, fun: &Function) -> String {\n     {\n         let mut it = fun.params.iter();\n         if let Some(param) = it.next() {\n-            format_to!(buf, \"{}\", param.name);\n+            format_to!(buf, \"{}{}\", param.value_prefix(), param.node.name(ctx.db()).unwrap());\n         }\n         for param in it {\n-            format_to!(buf, \", {}\", param.name);\n+            format_to!(buf, \", {}{}\", param.value_prefix(), param.node.name(ctx.db()).unwrap());\n         }\n     }\n     format_to!(buf, \")\");\n@@ -228,7 +232,7 @@ struct Function {\n     params: Vec<Param>,\n     ret_ty: Option<hir::Type>,\n     body: FunctionBody,\n-    vars_in_body_used_afterwards: Vec<Local>,\n+    vars_defined_in_body_and_outlive: Vec<Local>,\n }\n \n impl Function {\n@@ -242,8 +246,60 @@ impl Function {\n \n #[derive(Debug)]\n struct Param {\n-    name: String,\n-    ty: String,\n+    node: Local,\n+    has_usages_afterwards: bool,\n+    has_mut_inside_body: bool,\n+    is_copy: bool,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ParamKind {\n+    Value,\n+    MutValue,\n+    SharedRef,\n+    MutRef,\n+}\n+\n+impl ParamKind {\n+    fn is_ref(&self) -> bool {\n+        matches!(self, ParamKind::SharedRef | ParamKind::MutRef)\n+    }\n+}\n+\n+impl Param {\n+    fn kind(&self) -> ParamKind {\n+        match (self.has_usages_afterwards, self.has_mut_inside_body, self.is_copy) {\n+            (true, true, _) => ParamKind::MutRef,\n+            (true, false, false) => ParamKind::SharedRef,\n+            (false, true, _) => ParamKind::MutValue,\n+            (true, false, true) | (false, false, _) => ParamKind::Value,\n+        }\n+    }\n+\n+    fn value_prefix(&self) -> &'static str {\n+        match self.kind() {\n+            ParamKind::Value => \"\",\n+            ParamKind::MutValue => \"\",\n+            ParamKind::SharedRef => \"&\",\n+            ParamKind::MutRef => \"&mut \",\n+        }\n+    }\n+\n+    fn type_prefix(&self) -> &'static str {\n+        match self.kind() {\n+            ParamKind::Value => \"\",\n+            ParamKind::MutValue => \"\",\n+            ParamKind::SharedRef => \"&\",\n+            ParamKind::MutRef => \"&mut \",\n+        }\n+    }\n+\n+    fn mut_pattern(&self) -> &'static str {\n+        match self.kind() {\n+            ParamKind::MutValue => \"mut \",\n+            _ => \"\",\n+        }\n+    }\n }\n \n fn format_function(\n@@ -259,10 +315,24 @@ fn format_function(\n         if let Some(self_param) = &fun.self_param {\n             format_to!(fn_def, \"{}\", self_param);\n         } else if let Some(param) = it.next() {\n-            format_to!(fn_def, \"{}: {}\", param.name, param.ty);\n+            format_to!(\n+                fn_def,\n+                \"{}{}: {}{}\",\n+                param.mut_pattern(),\n+                param.node.name(ctx.db()).unwrap(),\n+                param.type_prefix(),\n+                format_type(&param.node.ty(ctx.db()), ctx, module)\n+            );\n         }\n         for param in it {\n-            format_to!(fn_def, \", {}: {}\", param.name, param.ty);\n+            format_to!(\n+                fn_def,\n+                \", {}{}: {}{}\",\n+                param.mut_pattern(),\n+                param.node.name(ctx.db()).unwrap(),\n+                param.type_prefix(),\n+                format_type(&param.node.ty(ctx.db()), ctx, module)\n+            );\n         }\n     }\n \n@@ -272,7 +342,7 @@ fn format_function(\n             format_to!(fn_def, \" -> {}\", format_type(ty, ctx, module));\n         }\n     } else {\n-        match fun.vars_in_body_used_afterwards.as_slice() {\n+        match fun.vars_defined_in_body_and_outlive.as_slice() {\n             [] => {}\n             [var] => {\n                 format_to!(fn_def, \" -> {}\", format_type(&var.ty(ctx.db()), ctx, module));\n@@ -292,21 +362,29 @@ fn format_function(\n         FunctionBody::Expr(expr) => {\n             fn_def.push('\\n');\n             let expr = expr.indent(indent);\n-            format_to!(fn_def, \"{}{}\", indent + 1, expr.syntax());\n+            let expr = fix_param_usages(ctx, &fun.params, expr.syntax());\n+            format_to!(fn_def, \"{}{}\", indent + 1, expr);\n             fn_def.push('\\n');\n         }\n         FunctionBody::Span { elements, leading_indent } => {\n             format_to!(fn_def, \"{}\", leading_indent);\n-            for e in elements {\n-                format_to!(fn_def, \"{}\", e);\n+            for element in elements {\n+                match element {\n+                    syntax::NodeOrToken::Node(node) => {\n+                        format_to!(fn_def, \"{}\", fix_param_usages(ctx, &fun.params, node));\n+                    }\n+                    syntax::NodeOrToken::Token(token) => {\n+                        format_to!(fn_def, \"{}\", token);\n+                    }\n+                }\n             }\n             if !fn_def.ends_with('\\n') {\n                 fn_def.push('\\n');\n             }\n         }\n     }\n \n-    match fun.vars_in_body_used_afterwards.as_slice() {\n+    match fun.vars_defined_in_body_and_outlive.as_slice() {\n         [] => {}\n         [var] => format_to!(fn_def, \"{}{}\\n\", indent + 1, var.name(ctx.db()).unwrap()),\n         [v0, vs @ ..] => {\n@@ -327,6 +405,61 @@ fn format_type(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> Stri\n     ty.display_source_code(ctx.db(), module.into()).ok().unwrap_or_else(|| \"()\".to_string())\n }\n \n+fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode) -> SyntaxNode {\n+    let mut rewriter = SyntaxRewriter::default();\n+    for param in params {\n+        if !param.kind().is_ref() {\n+            continue;\n+        }\n+\n+        let usages = Definition::Local(param.node)\n+            .usages(&ctx.sema)\n+            .in_scope(SearchScope::single_file(ctx.frange.file_id))\n+            .all();\n+        let usages = usages\n+            .iter()\n+            .flat_map(|(_, rs)| rs.iter())\n+            .filter(|reference| syntax.text_range().contains_range(reference.range));\n+        for reference in usages {\n+            let token = match syntax.token_at_offset(reference.range.start()).right_biased() {\n+                Some(a) => a,\n+                None => {\n+                    stdx::never!(false, \"cannot find token at variable usage: {:?}\", reference);\n+                    continue;\n+                }\n+            };\n+            let path = match token.ancestors().find_map(ast::Expr::cast) {\n+                Some(n) => n,\n+                None => {\n+                    stdx::never!(false, \"cannot find path parent of variable usage: {:?}\", token);\n+                    continue;\n+                }\n+            };\n+            stdx::always!(matches!(path, ast::Expr::PathExpr(_)));\n+            match path.syntax().ancestors().skip(1).find_map(ast::Expr::cast) {\n+                Some(ast::Expr::MethodCallExpr(_)) => {\n+                    // do nothing\n+                }\n+                Some(ast::Expr::RefExpr(node))\n+                    if param.kind() == ParamKind::MutRef && node.mut_token().is_some() =>\n+                {\n+                    rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n+                }\n+                Some(ast::Expr::RefExpr(node))\n+                    if param.kind() == ParamKind::SharedRef && node.mut_token().is_none() =>\n+                {\n+                    rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n+                }\n+                Some(_) | None => {\n+                    rewriter.replace_ast(&path, &ast::make::expr_prefix(T![*], path.clone()));\n+                }\n+            };\n+        }\n+    }\n+\n+    rewriter.rewrite(syntax)\n+}\n+\n #[derive(Debug)]\n enum FunctionBody {\n     Expr(ast::Expr),\n@@ -1112,6 +1245,164 @@ fn $0fun_name(n: i32) -> (i32, i32) {\n     let k = n * n;\n     let m = k + 2;\n     (k, m)\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_var_from_outer_scope() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    $0n += 1;$0\n+    let m = n + 1;\n+}\",\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(&mut n);\n+    let m = n + 1;\n+}\n+\n+fn $0fun_name(n: &mut i32) {\n+    *n += 1;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_param_many_usages_stmt() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn bar(k: i32) {}\n+trait I: Copy {\n+    fn succ(&self) -> Self;\n+    fn inc(&mut self) -> Self { let v = self.succ(); *self = v; v }\n+}\n+impl I for i32 {\n+    fn succ(&self) -> Self { *self + 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    $0n += n;\n+    bar(n);\n+    bar(n+1);\n+    bar(n*n);\n+    bar(&n);\n+    n.inc();\n+    let v = &mut n;\n+    *v = v.succ();\n+    n.succ();$0\n+    let m = n + 1;\n+}\",\n+            r\"\n+fn bar(k: i32) {}\n+trait I: Copy {\n+    fn succ(&self) -> Self;\n+    fn inc(&mut self) -> Self { let v = self.succ(); *self = v; v }\n+}\n+impl I for i32 {\n+    fn succ(&self) -> Self { *self + 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(&mut n);\n+    let m = n + 1;\n+}\n+\n+fn $0fun_name(n: &mut i32) {\n+    *n += *n;\n+    bar(*n);\n+    bar(*n+1);\n+    bar(*n**n);\n+    bar(&*n);\n+    n.inc();\n+    let v = n;\n+    *v = v.succ();\n+    n.succ();\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_param_many_usages_expr() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn bar(k: i32) {}\n+trait I: Copy {\n+    fn succ(&self) -> Self;\n+    fn inc(&mut self) -> Self { let v = self.succ(); *self = v; v }\n+}\n+impl I for i32 {\n+    fn succ(&self) -> Self { *self + 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    $0{\n+        n += n;\n+        bar(n);\n+        bar(n+1);\n+        bar(n*n);\n+        bar(&n);\n+        n.inc();\n+        let v = &mut n;\n+        *v = v.succ();\n+        n.succ();\n+    }$0\n+    let m = n + 1;\n+}\",\n+            r\"\n+fn bar(k: i32) {}\n+trait I: Copy {\n+    fn succ(&self) -> Self;\n+    fn inc(&mut self) -> Self { let v = self.succ(); *self = v; v }\n+}\n+impl I for i32 {\n+    fn succ(&self) -> Self { *self + 1 }\n+}\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(&mut n);\n+    let m = n + 1;\n+}\n+\n+fn $0fun_name(n: &mut i32) {\n+    {\n+        *n += *n;\n+        bar(*n);\n+        bar(*n+1);\n+        bar(*n**n);\n+        bar(&*n);\n+        n.inc();\n+        let v = n;\n+        *v = v.succ();\n+        n.succ();\n+    }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn mut_param_by_value() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    $0n += 1;$0\n+}\",\n+            r\"\n+fn foo() {\n+    let mut n = 1;\n+    fun_name(n);\n+}\n+\n+fn $0fun_name(mut n: i32) {\n+    n += 1;\n }\",\n         );\n     }"}, {"sha": "1da5a125ed376cdbb4df813fff3176b70f70a7b0", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f102616aaea2894508f8f078cfb20ceef5411d12/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f102616aaea2894508f8f078cfb20ceef5411d12/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=f102616aaea2894508f8f078cfb20ceef5411d12", "patch": "@@ -487,7 +487,7 @@ pub mod tokens {\n     use crate::{ast, AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken};\n \n     pub(super) static SOURCE_FILE: Lazy<Parse<SourceFile>> =\n-        Lazy::new(|| SourceFile::parse(\"const C: <()>::Item = (1 != 1, 2 == 2, !true)\\n;\\n\\n\"));\n+        Lazy::new(|| SourceFile::parse(\"const C: <()>::Item = (1 != 1, 2 == 2, !true, *p)\\n;\\n\\n\"));\n \n     pub fn single_space() -> SyntaxToken {\n         SOURCE_FILE"}]}