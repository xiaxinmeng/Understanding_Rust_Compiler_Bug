{"sha": "cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMDYxOTM4M2QyY2UwZjdiZDgyMmY4MmNmNDg3YzdmYTMzZDBiNzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-10T20:33:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-16T06:22:06Z"}, "message": "core: Inherit the std::fmt module\n\nThis commit moves all possible functionality from the standard library's string\nformatting utilities into the core library. This is a breaking change, due to a\nfew tweaks in the semantics of formatting:\n\n1. In order to break the dependency on the std::io module, a new trait,\n   FormatWriter was introduced in core::fmt. This is the trait which is used\n   (instead of Writer) to format data into a stream.\n2. The new FormatWriter trait has one method, write(), which takes some bytes\n   and can return an error, but the error contains very little information. The\n   intent for this trait is for an adaptor writer to be used around the standard\n   library's Writer trait.\n3. The fmt::write{,ln,_unsafe} methods no longer take &mut io::Writer, but\n   rather &mut FormatWriter. Since this trait is less common, all functions were\n   removed except fmt::write, and it is not intended to be invoked directly.\n\nThe main API-breaking change here is that the fmt::Formatter structure will no\nlonger expose its `buf` field. All previous code writing directly to `f.buf`\nusing writer methods or the `write!` macro will now instead use `f` directly.\n\nThe Formatter object itself implements the `Writer` trait itself for\nconvenience, although it does not implement the `FormatWriter` trait. The\nfallout of these changes will be in the following commits.\n\n[breaking-change]", "tree": {"sha": "d3b7cf19884affa54c0d22516d766007617e0893", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3b7cf19884affa54c0d22516d766007617e0893"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "html_url": "https://github.com/rust-lang/rust/commit/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba0a984a862f4f4246a3be014b9b244525bedd20", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba0a984a862f4f4246a3be014b9b244525bedd20", "html_url": "https://github.com/rust-lang/rust/commit/ba0a984a862f4f4246a3be014b9b244525bedd20"}], "stats": {"total": 2836, "additions": 1429, "deletions": 1407}, "files": [{"sha": "0a45712616d4310656b9e0e5a46b3c095e0b5c52", "filename": "src/libcore/fmt/mod.rs", "status": "added", "additions": 843, "deletions": 0, "changes": 843, "blob_url": "https://github.com/rust-lang/rust/blob/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "patch": "@@ -0,0 +1,843 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Utilities for formatting and printing strings\n+\n+#![allow(unused_variable)]\n+\n+use any;\n+use cast;\n+use cell::Cell;\n+use char::Char;\n+use container::Container;\n+use iter::{Iterator, range};\n+use kinds::Copy;\n+use option::{Option, Some, None};\n+use owned::Box;\n+use result;\n+use result::{Ok, Err};\n+use slice::{Vector, ImmutableVector};\n+use slice;\n+use str::StrSlice;\n+use str;\n+\n+pub use self::num::radix;\n+pub use self::num::Radix;\n+pub use self::num::RadixFmt;\n+\n+macro_rules! write(\n+    ($dst:expr, $($arg:tt)*) => ({\n+        let dst: &mut ::fmt::FormatWriter = $dst;\n+        format_args!(|args| { ::std::fmt::write(dst, args) }, $($arg)*)\n+    })\n+)\n+\n+mod num;\n+mod float;\n+pub mod rt;\n+\n+#[cfg(stage0)]\n+#[allow(missing_doc)]\n+pub mod parse {\n+    #[deriving(Eq)]\n+    pub enum Alignment {\n+        AlignLeft,\n+        AlignRight,\n+        AlignUnknown,\n+    }\n+\n+    pub enum PluralKeyword {\n+        Zero,\n+        One,\n+        Two,\n+        Few,\n+        Many,\n+    }\n+\n+    pub enum Flag {\n+        FlagSignPlus,\n+        FlagSignMinus,\n+        FlagAlternate,\n+        FlagSignAwareZeroPad,\n+    }\n+}\n+\n+pub type Result = result::Result<(), FormatError>;\n+\n+/// dox\n+pub enum FormatError {\n+    /// dox\n+    WriteError,\n+}\n+\n+/// dox\n+pub trait FormatWriter {\n+    /// dox\n+    fn write(&mut self, bytes: &[u8]) -> Result;\n+}\n+\n+/// A struct to represent both where to emit formatting strings to and how they\n+/// should be formatted. A mutable version of this is passed to all formatting\n+/// traits.\n+pub struct Formatter<'a> {\n+    /// Flags for formatting (packed version of rt::Flag)\n+    pub flags: uint,\n+    /// Character used as 'fill' whenever there is alignment\n+    pub fill: char,\n+    /// Boolean indication of whether the output should be left-aligned\n+    pub align: rt::Alignment,\n+    /// Optionally specified integer width that the output should be\n+    pub width: Option<uint>,\n+    /// Optionally specified precision for numeric types\n+    pub precision: Option<uint>,\n+\n+    /// dox\n+    #[cfg(stage0)]\n+    pub buf: &'a mut FormatWriter,\n+    #[cfg(not(stage0))]\n+    buf: &'a mut FormatWriter,\n+    curarg: slice::Items<'a, Argument<'a>>,\n+    args: &'a [Argument<'a>],\n+}\n+\n+enum CurrentlyFormatting<'a> {\n+    Nothing,\n+    RawString(&'a str),\n+    Number(uint),\n+}\n+\n+/// This struct represents the generic \"argument\" which is taken by the Xprintf\n+/// family of functions. It contains a function to format the given value. At\n+/// compile time it is ensured that the function and the value have the correct\n+/// types, and then this struct is used to canonicalize arguments to one type.\n+pub struct Argument<'a> {\n+    formatter: extern \"Rust\" fn(&any::Void, &mut Formatter) -> Result,\n+    value: &'a any::Void,\n+}\n+\n+impl<'a> Arguments<'a> {\n+    /// When using the format_args!() macro, this function is used to generate the\n+    /// Arguments structure. The compiler inserts an `unsafe` block to call this,\n+    /// which is valid because the compiler performs all necessary validation to\n+    /// ensure that the resulting call to format/write would be safe.\n+    #[doc(hidden)] #[inline]\n+    pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],\n+                          args: &'a [Argument<'a>]) -> Arguments<'a> {\n+        Arguments{ fmt: cast::transmute(fmt), args: args }\n+    }\n+}\n+\n+/// This structure represents a safely precompiled version of a format string\n+/// and its arguments. This cannot be generated at runtime because it cannot\n+/// safely be done so, so no constructors are given and the fields are private\n+/// to prevent modification.\n+///\n+/// The `format_args!` macro will safely create an instance of this structure\n+/// and pass it to a user-supplied function. The macro validates the format\n+/// string at compile-time so usage of the `write` and `format` functions can\n+/// be safely performed.\n+pub struct Arguments<'a> {\n+    fmt: &'a [rt::Piece<'a>],\n+    args: &'a [Argument<'a>],\n+}\n+\n+impl<'a> Show for Arguments<'a> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result {\n+        write(fmt.buf, self)\n+    }\n+}\n+\n+/// When a format is not otherwise specified, types are formatted by ascribing\n+/// to this trait. There is not an explicit way of selecting this trait to be\n+/// used for formatting, it is only if no other format is specified.\n+pub trait Show {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `b` character\n+pub trait Bool {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `c` character\n+pub trait Char {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `i` and `d` characters\n+pub trait Signed {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `u` character\n+pub trait Unsigned {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `o` character\n+pub trait Octal {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `t` character\n+pub trait Binary {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `x` character\n+pub trait LowerHex {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `X` character\n+pub trait UpperHex {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `s` character\n+pub trait String {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `p` character\n+pub trait Pointer {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `f` character\n+pub trait Float {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `e` character\n+pub trait LowerExp {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// Format trait for the `E` character\n+pub trait UpperExp {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+// FIXME #11938 - UFCS would make us able call the above methods\n+// directly Show::show(x, fmt).\n+macro_rules! uniform_fn_call_workaround {\n+    ($( $name: ident, $trait_: ident; )*) => {\n+        $(\n+            #[doc(hidden)]\n+            pub fn $name<T: $trait_>(x: &T, fmt: &mut Formatter) -> Result {\n+                x.fmt(fmt)\n+            }\n+            )*\n+    }\n+}\n+uniform_fn_call_workaround! {\n+    secret_show, Show;\n+    secret_bool, Bool;\n+    secret_char, Char;\n+    secret_signed, Signed;\n+    secret_unsigned, Unsigned;\n+    secret_octal, Octal;\n+    secret_binary, Binary;\n+    secret_lower_hex, LowerHex;\n+    secret_upper_hex, UpperHex;\n+    secret_string, String;\n+    secret_pointer, Pointer;\n+    secret_float, Float;\n+    secret_lower_exp, LowerExp;\n+    secret_upper_exp, UpperExp;\n+}\n+\n+/// The `write` function takes an output stream, a precompiled format string,\n+/// and a list of arguments. The arguments will be formatted according to the\n+/// specified format string into the output stream provided.\n+///\n+/// # Arguments\n+///\n+///   * output - the buffer to write output to\n+///   * args - the precompiled arguments generated by `format_args!`\n+pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result {\n+    let mut formatter = Formatter {\n+        flags: 0,\n+        width: None,\n+        precision: None,\n+        buf: output,\n+        align: rt::AlignUnknown,\n+        fill: ' ',\n+        args: args.args,\n+        curarg: args.args.iter(),\n+    };\n+    for piece in args.fmt.iter() {\n+        try!(formatter.run(piece, Nothing));\n+    }\n+    Ok(())\n+}\n+\n+impl<'a> Formatter<'a> {\n+\n+    // First up is the collection of functions used to execute a format string\n+    // at runtime. This consumes all of the compile-time statics generated by\n+    // the format! syntax extension.\n+\n+    fn run(&mut self, piece: &rt::Piece, cur: CurrentlyFormatting) -> Result {\n+        match *piece {\n+            rt::String(s) => self.buf.write(s.as_bytes()),\n+            rt::CurrentArgument(()) => {\n+                match cur {\n+                    Nothing => Ok(()),\n+                    Number(n) => secret_show(&radix(n, 10), self),\n+                    RawString(s) => self.buf.write(s.as_bytes()),\n+                }\n+            }\n+            rt::Argument(ref arg) => {\n+                // Fill in the format parameters into the formatter\n+                self.fill = arg.format.fill;\n+                self.align = arg.format.align;\n+                self.flags = arg.format.flags;\n+                self.width = self.getcount(&arg.format.width);\n+                self.precision = self.getcount(&arg.format.precision);\n+\n+                // Extract the correct argument\n+                let value = match arg.position {\n+                    rt::ArgumentNext => { *self.curarg.next().unwrap() }\n+                    rt::ArgumentIs(i) => self.args[i],\n+                };\n+\n+                // Then actually do some printing\n+                match arg.method {\n+                    None => (value.formatter)(value.value, self),\n+                    Some(ref method) => self.execute(*method, value)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {\n+        match *cnt {\n+            rt::CountIs(n) => { Some(n) }\n+            rt::CountImplied => { None }\n+            rt::CountIsParam(i) => {\n+                let v = self.args[i].value;\n+                unsafe { Some(*(v as *any::Void as *uint)) }\n+            }\n+            rt::CountIsNextParam => {\n+                let v = self.curarg.next().unwrap().value;\n+                unsafe { Some(*(v as *any::Void as *uint)) }\n+            }\n+        }\n+    }\n+\n+    fn execute(&mut self, method: &rt::Method, arg: Argument) -> Result {\n+        match *method {\n+            // Pluralization is selection upon a numeric value specified as the\n+            // parameter.\n+            rt::Plural(offset, ref selectors, ref default) => {\n+                // This is validated at compile-time to be a pointer to a\n+                // '&uint' value.\n+                let value: &uint = unsafe { cast::transmute(arg.value) };\n+                let value = *value;\n+\n+                // First, attempt to match against explicit values without the\n+                // offsetted value\n+                for s in selectors.iter() {\n+                    match s.selector {\n+                        rt::Literal(val) if value == val => {\n+                            return self.runplural(value, s.result);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+\n+                // Next, offset the value and attempt to match against the\n+                // keyword selectors.\n+                let value = value - match offset { Some(i) => i, None => 0 };\n+                for s in selectors.iter() {\n+                    let run = match s.selector {\n+                        rt::Keyword(rt::Zero) => value == 0,\n+                        rt::Keyword(rt::One) => value == 1,\n+                        rt::Keyword(rt::Two) => value == 2,\n+\n+                        // FIXME: Few/Many should have a user-specified boundary\n+                        //      One possible option would be in the function\n+                        //      pointer of the 'arg: Argument' struct.\n+                        rt::Keyword(rt::Few) => value < 8,\n+                        rt::Keyword(rt::Many) => value >= 8,\n+\n+                        rt::Literal(..) => false\n+                    };\n+                    if run {\n+                        return self.runplural(value, s.result);\n+                    }\n+                }\n+\n+                self.runplural(value, *default)\n+            }\n+\n+            // Select is just a matching against the string specified.\n+            rt::Select(ref selectors, ref default) => {\n+                // This is validated at compile-time to be a pointer to a\n+                // string slice,\n+                let value: & &str = unsafe { cast::transmute(arg.value) };\n+                let value = *value;\n+\n+                for s in selectors.iter() {\n+                    if s.selector == value {\n+                        for piece in s.result.iter() {\n+                            try!(self.run(piece, RawString(value)));\n+                        }\n+                        return Ok(());\n+                    }\n+                }\n+                for piece in default.iter() {\n+                    try!(self.run(piece, RawString(value)));\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) -> Result {\n+        for piece in pieces.iter() {\n+            try!(self.run(piece, Number(value)));\n+        }\n+        Ok(())\n+    }\n+\n+    // Helper methods used for padding and processing formatting arguments that\n+    // all formatting traits can use.\n+\n+    /// Performs the correct padding for an integer which has already been\n+    /// emitted into a byte-array. The byte-array should *not* contain the sign\n+    /// for the integer, that will be added by this method.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * is_positive - whether the original integer was positive or not.\n+    /// * prefix - if the '#' character (FlagAlternate) is provided, this\n+    ///   is the prefix to put in front of the number.\n+    /// * buf - the byte array that the number has been formatted into\n+    ///\n+    /// This function will correctly account for the flags provided as well as\n+    /// the minimum width. It will not take precision into account.\n+    pub fn pad_integral(&mut self, is_positive: bool, prefix: &str,\n+                        buf: &[u8]) -> Result {\n+        use fmt::rt::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n+\n+        let mut width = buf.len();\n+\n+        let mut sign = None;\n+        if !is_positive {\n+            sign = Some('-'); width += 1;\n+        } else if self.flags & (1 << (FlagSignPlus as uint)) != 0 {\n+            sign = Some('+'); width += 1;\n+        }\n+\n+        let mut prefixed = false;\n+        if self.flags & (1 << (FlagAlternate as uint)) != 0 {\n+            prefixed = true; width += prefix.len();\n+        }\n+\n+        // Writes the sign if it exists, and then the prefix if it was requested\n+        let write_prefix = |f: &mut Formatter| {\n+            for c in sign.move_iter() {\n+                let mut b = [0, ..4];\n+                let n = c.encode_utf8(b);\n+                try!(f.buf.write(b.slice_to(n)));\n+            }\n+            if prefixed { f.buf.write(prefix.as_bytes()) }\n+            else { Ok(()) }\n+        };\n+\n+        // The `width` field is more of a `min-width` parameter at this point.\n+        match self.width {\n+            // If there's no minimum length requirements then we can just\n+            // write the bytes.\n+            None => {\n+                try!(write_prefix(self)); self.buf.write(buf)\n+            }\n+            // Check if we're over the minimum width, if so then we can also\n+            // just write the bytes.\n+            Some(min) if width >= min => {\n+                try!(write_prefix(self)); self.buf.write(buf)\n+            }\n+            // The sign and prefix goes before the padding if the fill character\n+            // is zero\n+            Some(min) if self.flags & (1 << (FlagSignAwareZeroPad as uint)) != 0 => {\n+                self.fill = '0';\n+                try!(write_prefix(self));\n+                self.with_padding(min - width, rt::AlignRight, |f| f.buf.write(buf))\n+            }\n+            // Otherwise, the sign and prefix goes after the padding\n+            Some(min) => {\n+                self.with_padding(min - width, rt::AlignRight, |f| {\n+                    try!(write_prefix(f)); f.buf.write(buf)\n+                })\n+            }\n+        }\n+    }\n+\n+    /// This function takes a string slice and emits it to the internal buffer\n+    /// after applying the relevant formatting flags specified. The flags\n+    /// recognized for generic strings are:\n+    ///\n+    /// * width - the minimum width of what to emit\n+    /// * fill/align - what to emit and where to emit it if the string\n+    ///                provided needs to be padded\n+    /// * precision - the maximum length to emit, the string is truncated if it\n+    ///               is longer than this length\n+    ///\n+    /// Notably this function ignored the `flag` parameters\n+    pub fn pad(&mut self, s: &str) -> Result {\n+        // Make sure there's a fast path up front\n+        if self.width.is_none() && self.precision.is_none() {\n+            return self.buf.write(s.as_bytes());\n+        }\n+        // The `precision` field can be interpreted as a `max-width` for the\n+        // string being formatted\n+        match self.precision {\n+            Some(max) => {\n+                // If there's a maximum width and our string is longer than\n+                // that, then we must always have truncation. This is the only\n+                // case where the maximum length will matter.\n+                let char_len = s.char_len();\n+                if char_len >= max {\n+                    let nchars = ::cmp::min(max, char_len);\n+                    return self.buf.write(s.slice_chars(0, nchars).as_bytes());\n+                }\n+            }\n+            None => {}\n+        }\n+        // The `width` field is more of a `min-width` parameter at this point.\n+        match self.width {\n+            // If we're under the maximum length, and there's no minimum length\n+            // requirements, then we can just emit the string\n+            None => self.buf.write(s.as_bytes()),\n+            // If we're under the maximum width, check if we're over the minimum\n+            // width, if so it's as easy as just emitting the string.\n+            Some(width) if s.char_len() >= width => {\n+                self.buf.write(s.as_bytes())\n+            }\n+            // If we're under both the maximum and the minimum width, then fill\n+            // up the minimum width with the specified string + some alignment.\n+            Some(width) => {\n+                self.with_padding(width - s.len(), rt::AlignLeft, |me| {\n+                    me.buf.write(s.as_bytes())\n+                })\n+            }\n+        }\n+    }\n+\n+    /// Runs a callback, emitting the correct padding either before or\n+    /// afterwards depending on whether right or left alingment is requested.\n+    fn with_padding(&mut self,\n+                    padding: uint,\n+                    default: rt::Alignment,\n+                    f: |&mut Formatter| -> Result) -> Result {\n+        let align = match self.align {\n+            rt::AlignUnknown => default,\n+            rt::AlignLeft | rt::AlignRight => self.align\n+        };\n+        if align == rt::AlignLeft {\n+            try!(f(self));\n+        }\n+        let mut fill = [0u8, ..4];\n+        let len = self.fill.encode_utf8(fill);\n+        for _ in range(0, padding) {\n+            try!(self.buf.write(fill.slice_to(len)));\n+        }\n+        if align == rt::AlignRight {\n+            try!(f(self));\n+        }\n+        Ok(())\n+    }\n+\n+    /// Writes some data to the underlying buffer contained within this\n+    /// formatter.\n+    pub fn write(&mut self, data: &[u8]) -> Result {\n+        self.buf.write(data)\n+    }\n+\n+    /// Writes some formatted information into this instance\n+    pub fn write_fmt(&mut self, fmt: &Arguments) -> Result {\n+        write(self.buf, fmt)\n+    }\n+}\n+\n+/// This is a function which calls are emitted to by the compiler itself to\n+/// create the Argument structures that are passed into the `format` function.\n+#[doc(hidden)] #[inline]\n+pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n+                       t: &'a T) -> Argument<'a> {\n+    unsafe {\n+        Argument {\n+            formatter: cast::transmute(f),\n+            value: cast::transmute(t)\n+        }\n+    }\n+}\n+\n+/// When the compiler determines that the type of an argument *must* be a string\n+/// (such as for select), then it invokes this method.\n+#[doc(hidden)] #[inline]\n+pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n+    argument(secret_string, s)\n+}\n+\n+/// When the compiler determines that the type of an argument *must* be a uint\n+/// (such as for plural), then it invokes this method.\n+#[doc(hidden)] #[inline]\n+pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n+    argument(secret_unsigned, s)\n+}\n+\n+// Implementations of the core formatting traits\n+\n+impl<T: Show> Show for @T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n+}\n+impl<T: Show> Show for Box<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n+}\n+impl<'a, T: Show> Show for &'a T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n+}\n+\n+impl Bool for bool {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_string(&(if *self {\"true\"} else {\"false\"}), f)\n+    }\n+}\n+\n+impl<'a, T: str::Str> String for T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(self.as_slice())\n+    }\n+}\n+\n+impl Char for char {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        let mut utf8 = [0u8, ..4];\n+        let amt = self.encode_utf8(utf8);\n+        let s: &str = unsafe { cast::transmute(utf8.slice_to(amt)) };\n+        secret_string(&s, f)\n+    }\n+}\n+\n+impl<T> Pointer for *T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.flags |= 1 << (rt::FlagAlternate as uint);\n+        secret_lower_hex::<uint>(&(*self as uint), f)\n+    }\n+}\n+impl<T> Pointer for *mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_pointer::<*T>(&(*self as *T), f)\n+    }\n+}\n+impl<'a, T> Pointer for &'a T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_pointer::<*T>(&(&**self as *T), f)\n+    }\n+}\n+impl<'a, T> Pointer for &'a mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_pointer::<*T>(&(&**self as *T), f)\n+    }\n+}\n+\n+macro_rules! floating(($ty:ident) => {\n+    impl Float for $ty {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n+            use num::Signed;\n+\n+            let digits = match fmt.precision {\n+                Some(i) => float::DigExact(i),\n+                None => float::DigMax(6),\n+            };\n+            float::float_to_str_bytes_common(self.abs(),\n+                                             10,\n+                                             true,\n+                                             float::SignNeg,\n+                                             digits,\n+                                             float::ExpNone,\n+                                             false,\n+                                             |bytes| {\n+                fmt.pad_integral(*self >= 0.0, \"\", bytes)\n+            })\n+        }\n+    }\n+\n+    impl LowerExp for $ty {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n+            use num::Signed;\n+\n+            let digits = match fmt.precision {\n+                Some(i) => float::DigExact(i),\n+                None => float::DigMax(6),\n+            };\n+            float::float_to_str_bytes_common(self.abs(),\n+                                             10,\n+                                             true,\n+                                             float::SignNeg,\n+                                             digits,\n+                                             float::ExpDec,\n+                                             false,\n+                                             |bytes| {\n+                fmt.pad_integral(*self >= 0.0, \"\", bytes)\n+            })\n+        }\n+    }\n+\n+    impl UpperExp for $ty {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n+            use num::Signed;\n+\n+            let digits = match fmt.precision {\n+                Some(i) => float::DigExact(i),\n+                None => float::DigMax(6),\n+            };\n+            float::float_to_str_bytes_common(self.abs(),\n+                                             10,\n+                                             true,\n+                                             float::SignNeg,\n+                                             digits,\n+                                             float::ExpDec,\n+                                             true,\n+                                             |bytes| {\n+                fmt.pad_integral(*self >= 0.0, \"\", bytes)\n+            })\n+        }\n+    }\n+})\n+floating!(f32)\n+floating!(f64)\n+\n+// Implementation of Show for various core types\n+\n+macro_rules! delegate(($ty:ty to $other:ident) => {\n+    impl<'a> Show for $ty {\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            (concat_idents!(secret_, $other)(self, f))\n+        }\n+    }\n+})\n+delegate!(~str to string)\n+delegate!(&'a str to string)\n+delegate!(bool to bool)\n+delegate!(char to char)\n+delegate!(f32 to float)\n+delegate!(f64 to float)\n+\n+impl<T> Show for *T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n+}\n+impl<T> Show for *mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n+}\n+\n+macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n+\n+macro_rules! tuple (\n+    () => ();\n+    ( $($name:ident,)+ ) => (\n+        impl<$($name:Show),*> Show for ($($name,)*) {\n+            #[allow(uppercase_variables, dead_assignment)]\n+            fn fmt(&self, f: &mut Formatter) -> Result {\n+                try!(write!(f.buf, \"(\"));\n+                let ($(ref $name,)*) = *self;\n+                let mut n = 0;\n+                $(\n+                    if n > 0 {\n+                        try!(write!(f.buf, \", \"));\n+                    }\n+                    try!(write!(f.buf, \"{}\", *$name));\n+                    n += 1;\n+                )*\n+                if n == 1 {\n+                    try!(write!(f.buf, \",\"));\n+                }\n+                write!(f.buf, \")\")\n+            }\n+        }\n+        peel!($($name,)*)\n+    )\n+)\n+\n+tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n+\n+impl Show for Box<any::Any> {\n+    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"Box<Any>\") }\n+}\n+\n+impl<'a> Show for &'a any::Any {\n+    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n+}\n+\n+impl<'a, T: Show> Show for &'a [T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+            try!(write!(f.buf, \"[\"));\n+        }\n+        let mut is_first = true;\n+        for x in self.iter() {\n+            if is_first {\n+                is_first = false;\n+            } else {\n+                try!(write!(f.buf, \", \"));\n+            }\n+            try!(write!(f.buf, \"{}\", *x))\n+        }\n+        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+            try!(write!(f.buf, \"]\"));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, T: Show> Show for &'a mut [T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_show(&self.as_slice(), f)\n+    }\n+}\n+\n+impl<T: Show> Show for ~[T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_show(&self.as_slice(), f)\n+    }\n+}\n+\n+impl Show for () {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(\"()\")\n+    }\n+}\n+\n+impl<T: Copy + Show> Show for Cell<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        write!(f.buf, r\"Cell \\{ value: {} \\}\", self.get())\n+    }\n+}\n+\n+// If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n+// it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "12adcee2f0fc81e15d8ac12d04d319f9e6205447", "filename": "src/libcore/fmt/num.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "patch": "@@ -400,7 +400,6 @@ mod bench {\n         use super::test::Bencher;\n         use fmt::radix;\n         use rand::{XorShiftRng, Rng};\n-        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn format_bin(b: &mut Bencher) {\n@@ -437,7 +436,6 @@ mod bench {\n         use super::test::Bencher;\n         use fmt::radix;\n         use rand::{XorShiftRng, Rng};\n-        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn format_bin(b: &mut Bencher) {", "previous_filename": "src/libstd/fmt/num.rs"}, {"sha": "00c8661c8e3839c0a9c3386d6b37c264162364c4", "filename": "src/libcore/fmt/rt.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "previous_filename": "src/libstd/fmt/rt.rs"}, {"sha": "a126766b0dea68c41a82aedef3f7a29f3be81d9b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "patch": "@@ -117,6 +117,7 @@ pub mod result;\n pub mod slice;\n pub mod str;\n pub mod tuple;\n+pub mod fmt;\n \n // FIXME: this module should not exist. Once owned allocations are no longer a\n //        language type, this module can move outside to the owned allocation\n@@ -130,7 +131,9 @@ mod core {\n mod std {\n     pub use clone;\n     pub use cmp;\n+    pub use fmt;\n     pub use kinds;\n+    pub use option;\n \n     #[cfg(test)] pub use realstd::fmt;    // needed for fail!()\n     #[cfg(test)] pub use realstd::rt;     // needed for fail!()"}, {"sha": "a14bf49a21f4144d2a88b1c577d7966ed5fafab7", "filename": "src/libstd/fmt.rs", "status": "added", "additions": 583, "deletions": 0, "changes": 583, "blob_url": "https://github.com/rust-lang/rust/blob/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0619383d2ce0f7bd822f82cf487c7fa33d0b76/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=cf0619383d2ce0f7bd822f82cf487c7fa33d0b76", "patch": "@@ -0,0 +1,583 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Utilities for formatting and printing strings\n+\n+This module contains the runtime support for the `format!` syntax extension.\n+This macro is implemented in the compiler to emit calls to this module in order\n+to format arguments at runtime into strings and streams.\n+\n+The functions contained in this module should not normally be used in everyday\n+use cases of `format!`. The assumptions made by these functions are unsafe for\n+all inputs, and the compiler performs a large amount of validation on the\n+arguments to `format!` in order to ensure safety at runtime. While it is\n+possible to call these functions directly, it is not recommended to do so in the\n+general case.\n+\n+## Usage\n+\n+The `format!` macro is intended to be familiar to those coming from C's\n+printf/fprintf functions or Python's `str.format` function. In its current\n+revision, the `format!` macro returns a `~str` type which is the result of the\n+formatting. In the future it will also be able to pass in a stream to format\n+arguments directly while performing minimal allocations.\n+\n+Some examples of the `format!` extension are:\n+\n+```rust\n+format!(\"Hello\");                 // => \"Hello\".to_owned()\n+format!(\"Hello, {:s}!\", \"world\"); // => \"Hello, world!\".to_owned()\n+format!(\"The number is {:d}\", 1); // => \"The number is 1\".to_owned()\n+format!(\"{:?}\", ~[3, 4]);         // => \"~[3, 4]\".to_owned()\n+format!(\"{value}\", value=4);      // => \"4\".to_owned()\n+format!(\"{} {}\", 1, 2);           // => \"1 2\".to_owned()\n+```\n+\n+From these, you can see that the first argument is a format string. It is\n+required by the compiler for this to be a string literal; it cannot be a\n+variable passed in (in order to perform validity checking). The compiler will\n+then parse the format string and determine if the list of arguments provided is\n+suitable to pass to this format string.\n+\n+### Positional parameters\n+\n+Each formatting argument is allowed to specify which value argument it's\n+referencing, and if omitted it is assumed to be \"the next argument\". For\n+example, the format string `{} {} {}` would take three parameters, and they\n+would be formatted in the same order as they're given. The format string\n+`{2} {1} {0}`, however, would format arguments in reverse order.\n+\n+Things can get a little tricky once you start intermingling the two types of\n+positional specifiers. The \"next argument\" specifier can be thought of as an\n+iterator over the argument. Each time a \"next argument\" specifier is seen, the\n+iterator advances. This leads to behavior like this:\n+\n+```rust\n+format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\".to_owned()\n+```\n+\n+The internal iterator over the argument has not been advanced by the time the\n+first `{}` is seen, so it prints the first argument. Then upon reaching the\n+second `{}`, the iterator has advanced forward to the second argument.\n+Essentially, parameters which explicitly name their argument do not affect\n+parameters which do not name an argument in terms of positional specifiers.\n+\n+A format string is required to use all of its arguments, otherwise it is a\n+compile-time error. You may refer to the same argument more than once in the\n+format string, although it must always be referred to with the same type.\n+\n+### Named parameters\n+\n+Rust itself does not have a Python-like equivalent of named parameters to a\n+function, but the `format!` macro is a syntax extension which allows it to\n+leverage named parameters. Named parameters are listed at the end of the\n+argument list and have the syntax:\n+\n+```notrust\n+identifier '=' expression\n+```\n+\n+For example, the following `format!` expressions all use named argument:\n+\n+```rust\n+format!(\"{argument}\", argument = \"test\");       // => \"test\".to_owned()\n+format!(\"{name} {}\", 1, name = 2);              // => \"2 1\".to_owned()\n+format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3); // => \"a 3 ()\".to_owned()\n+```\n+\n+It is illegal to put positional parameters (those without names) after arguments\n+which have names. Like positional parameters, it is illegal to provided named\n+parameters that are unused by the format string.\n+\n+### Argument types\n+\n+Each argument's type is dictated by the format string. It is a requirement that\n+every argument is only ever referred to by one type. When specifying the format\n+of an argument, however, a string like `{}` indicates no type. This is allowed,\n+and if all references to one argument do not provide a type, then the format `?`\n+is used (the type's rust-representation is printed). For example, this is an\n+invalid format string:\n+\n+```notrust\n+{0:d} {0:s}\n+```\n+\n+Because the first argument is both referred to as an integer as well as a\n+string.\n+\n+Because formatting is done via traits, there is no requirement that the\n+`d` format actually takes an `int`, but rather it simply requires a type which\n+ascribes to the `Signed` formatting trait. There are various parameters which do\n+require a particular type, however. Namely if the syntax `{:.*s}` is used, then\n+the number of characters to print from the string precedes the actual string and\n+must have the type `uint`. Although a `uint` can be printed with `{:u}`, it is\n+illegal to reference an argument as such. For example, this is another invalid\n+format string:\n+\n+```notrust\n+{:.*s} {0:u}\n+```\n+\n+### Formatting traits\n+\n+When requesting that an argument be formatted with a particular type, you are\n+actually requesting that an argument ascribes to a particular trait. This allows\n+multiple actual types to be formatted via `{:d}` (like `i8` as well as `int`).\n+The current mapping of types to traits is:\n+\n+* `?` \u21d2 `Poly`\n+* `d` \u21d2 `Signed`\n+* `i` \u21d2 `Signed`\n+* `u` \u21d2 `Unsigned`\n+* `b` \u21d2 `Bool`\n+* `c` \u21d2 `Char`\n+* `o` \u21d2 `Octal`\n+* `x` \u21d2 `LowerHex`\n+* `X` \u21d2 `UpperHex`\n+* `s` \u21d2 `String`\n+* `p` \u21d2 `Pointer`\n+* `t` \u21d2 `Binary`\n+* `f` \u21d2 `Float`\n+* `e` \u21d2 `LowerExp`\n+* `E` \u21d2 `UpperExp`\n+* *nothing* \u21d2 `Show`\n+\n+What this means is that any type of argument which implements the\n+`std::fmt::Binary` trait can then be formatted with `{:t}`. Implementations are\n+provided for these traits for a number of primitive types by the standard\n+library as well. If no format is specified (as in `{}` or `{:6}`), then the\n+format trait used is the `Show` trait. This is one of the more commonly\n+implemented traits when formatting a custom type.\n+\n+When implementing a format trait for your own type, you will have to implement a\n+method of the signature:\n+\n+```rust\n+# use std;\n+# mod fmt { pub type Result = (); }\n+# struct T;\n+# trait SomeName<T> {\n+fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result;\n+# }\n+```\n+\n+Your type will be passed as `self` by-reference, and then the function should\n+emit output into the `f.buf` stream. It is up to each format trait\n+implementation to correctly adhere to the requested formatting parameters. The\n+values of these parameters will be listed in the fields of the `Formatter`\n+struct. In order to help with this, the `Formatter` struct also provides some\n+helper methods.\n+\n+Additionally, the return value of this function is `fmt::Result` which is a\n+typedef to `Result<(), IoError>` (also known as `IoError<()>`). Formatting\n+implementations should ensure that they return errors from `write!` correctly\n+(propagating errors upward).\n+\n+An example of implementing the formatting traits would look\n+like:\n+\n+```rust\n+use std::fmt;\n+use std::f64;\n+\n+struct Vector2D {\n+    x: int,\n+    y: int,\n+}\n+\n+impl fmt::Show for Vector2D {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // The `f` value implements the `Writer` trait, which is what the\n+        // write! macro is expecting. Note that this formatting ignores the\n+        // various flags provided to format strings.\n+        write!(f, \"({}, {})\", self.x, self.y)\n+    }\n+}\n+\n+// Different traits allow different forms of output of a type. The meaning of\n+// this format is to print the magnitude of a vector.\n+impl fmt::Binary for Vector2D {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let magnitude = (self.x * self.x + self.y * self.y) as f64;\n+        let magnitude = magnitude.sqrt();\n+\n+        // Respect the formatting flags by using the helper method\n+        // `pad_integral` on the Formatter object. See the method documentation\n+        // for details, and the function `pad` can be used to pad strings.\n+        let decimals = f.precision.unwrap_or(3);\n+        let string = f64::to_str_exact(magnitude, decimals);\n+        f.pad_integral(true, \"\", string.as_bytes())\n+    }\n+}\n+\n+fn main() {\n+    let myvector = Vector2D { x: 3, y: 4 };\n+\n+    println!(\"{}\", myvector);       // => \"(3, 4)\"\n+    println!(\"{:10.3t}\", myvector); // => \"     5.000\"\n+}\n+```\n+\n+### Related macros\n+\n+There are a number of related macros in the `format!` family. The ones that are\n+currently implemented are:\n+\n+```ignore\n+format!      // described above\n+write!       // first argument is a &mut io::Writer, the destination\n+writeln!     // same as write but appends a newline\n+print!       // the format string is printed to the standard output\n+println!     // same as print but appends a newline\n+format_args! // described below.\n+```\n+\n+\n+#### `write!`\n+\n+This and `writeln` are two macros which are used to emit the format string to a\n+specified stream. This is used to prevent intermediate allocations of format\n+strings and instead directly write the output. Under the hood, this function is\n+actually invoking the `write` function defined in this module. Example usage is:\n+\n+```rust\n+# #![allow(unused_must_use)]\n+use std::io;\n+\n+let mut w = io::MemWriter::new();\n+write!(&mut w as &mut io::Writer, \"Hello {}!\", \"world\");\n+```\n+\n+#### `print!`\n+\n+This and `println` emit their output to stdout. Similarly to the `write!` macro,\n+the goal of these macros is to avoid intermediate allocations when printing\n+output. Example usage is:\n+\n+```rust\n+print!(\"Hello {}!\", \"world\");\n+println!(\"I have a newline {}\", \"character at the end\");\n+```\n+\n+#### `format_args!`\n+This is a curious macro which is used to safely pass around\n+an opaque object describing the format string. This object\n+does not require any heap allocations to create, and it only\n+references information on the stack. Under the hood, all of\n+the related macros are implemented in terms of this. First\n+off, some example usage is:\n+\n+```\n+use std::fmt;\n+use std::io;\n+\n+# #[allow(unused_must_use)]\n+# fn main() {\n+format_args!(fmt::format, \"this returns {}\", \"~str\");\n+\n+let some_writer: &mut io::Writer = &mut io::stdout();\n+format_args!(|args| { fmt::write(some_writer, args) }, \"print with a {}\", \"closure\");\n+\n+fn my_fmt_fn(args: &fmt::Arguments) {\n+    fmt::write(&mut io::stdout(), args);\n+}\n+format_args!(my_fmt_fn, \"or a {} too\", \"function\");\n+# }\n+```\n+\n+The first argument of the `format_args!` macro is a function (or closure) which\n+takes one argument of type `&fmt::Arguments`. This structure can then be\n+passed to the `write` and `format` functions inside this module in order to\n+process the format string. The goal of this macro is to even further prevent\n+intermediate allocations when dealing formatting strings.\n+\n+For example, a logging library could use the standard formatting syntax, but it\n+would internally pass around this structure until it has been determined where\n+output should go to.\n+\n+It is unsafe to programmatically create an instance of `fmt::Arguments` because\n+the operations performed when executing a format string require the compile-time\n+checks provided by the compiler. The `format_args!` macro is the only method of\n+safely creating these structures, but they can be unsafely created with the\n+constructor provided.\n+\n+## Internationalization\n+\n+The formatting syntax supported by the `format!` extension supports\n+internationalization by providing \"methods\" which execute various different\n+outputs depending on the input. The syntax and methods provided are similar to\n+other internationalization systems, so again nothing should seem alien.\n+Currently two methods are supported by this extension: \"select\" and \"plural\".\n+\n+Each method will execute one of a number of clauses, and then the value of the\n+clause will become what's the result of the argument's format. Inside of the\n+cases, nested argument strings may be provided, but all formatting arguments\n+must not be done through implicit positional means. All arguments inside of each\n+case of a method must be explicitly selected by their name or their integer\n+position.\n+\n+Furthermore, whenever a case is running, the special character `#` can be used\n+to reference the string value of the argument which was selected upon. As an\n+example:\n+\n+```rust\n+format!(\"{0, select, other{#}}\", \"hello\"); // => \"hello\".to_owned()\n+```\n+\n+This example is the equivalent of `{0:s}` essentially.\n+\n+### Select\n+\n+The select method is a switch over a `&str` parameter, and the parameter *must*\n+be of the type `&str`. An example of the syntax is:\n+\n+```notrust\n+{0, select, male{...} female{...} other{...}}\n+```\n+\n+Breaking this down, the `0`-th argument is selected upon with the `select`\n+method, and then a number of cases follow. Each case is preceded by an\n+identifier which is the match-clause to execute the given arm. In this case,\n+there are two explicit cases, `male` and `female`. The case will be executed if\n+the string argument provided is an exact match to the case selected.\n+\n+The `other` case is also a required case for all `select` methods. This arm will\n+be executed if none of the other arms matched the word being selected over.\n+\n+### Plural\n+\n+The plural method is a switch statement over a `uint` parameter, and the\n+parameter *must* be a `uint`. A plural method in its full glory can be specified\n+as:\n+\n+```notrust\n+{0, plural, offset=1 =1{...} two{...} many{...} other{...}}\n+```\n+\n+To break this down, the first `0` indicates that this method is selecting over\n+the value of the first positional parameter to the format string. Next, the\n+`plural` method is being executed. An optionally-supplied `offset` is then given\n+which indicates a number to subtract from argument `0` when matching. This is\n+then followed by a list of cases.\n+\n+Each case is allowed to supply a specific value to match upon with the syntax\n+`=N`. This case is executed if the value at argument `0` matches N exactly,\n+without taking the offset into account. A case may also be specified by one of\n+five keywords: `zero`, `one`, `two`, `few`, and `many`. These cases are matched\n+on after argument `0` has the offset taken into account. Currently the\n+definitions of `many` and `few` are hardcoded, but they are in theory defined by\n+the current locale.\n+\n+Finally, all `plural` methods must have an `other` case supplied which will be\n+executed if none of the other cases match.\n+\n+## Syntax\n+\n+The syntax for the formatting language used is drawn from other languages, so it\n+should not be too alien. Arguments are formatted with python-like syntax,\n+meaning that arguments are surrounded by `{}` instead of the C-like `%`. The\n+actual grammar for the formatting syntax is:\n+\n+```notrust\n+format_string := <text> [ format <text> ] *\n+format := '{' [ argument ] [ ':' format_spec ] [ ',' function_spec ] '}'\n+argument := integer | identifier\n+\n+format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n+fill := character\n+align := '<' | '>'\n+sign := '+' | '-'\n+width := count\n+precision := count | '*'\n+type := identifier | ''\n+count := parameter | integer\n+parameter := integer '$'\n+\n+function_spec := plural | select\n+select := 'select' ',' ( identifier arm ) *\n+plural := 'plural' ',' [ 'offset:' integer ] ( selector arm ) *\n+selector := '=' integer | keyword\n+keyword := 'zero' | 'one' | 'two' | 'few' | 'many' | 'other'\n+arm := '{' format_string '}'\n+```\n+\n+## Formatting Parameters\n+\n+Each argument being formatted can be transformed by a number of formatting\n+parameters (corresponding to `format_spec` in the syntax above). These\n+parameters affect the string representation of what's being formatted. This\n+syntax draws heavily from Python's, so it may seem a bit familiar.\n+\n+### Fill/Alignment\n+\n+The fill character is provided normally in conjunction with the `width`\n+parameter. This indicates that if the value being formatted is smaller than\n+`width` some extra characters will be printed around it. The extra characters\n+are specified by `fill`, and the alignment can be one of two options:\n+\n+* `<` - the argument is left-aligned in `width` columns\n+* `>` - the argument is right-aligned in `width` columns\n+\n+### Sign/#/0\n+\n+These can all be interpreted as flags for a particular formatter.\n+\n+* '+' - This is intended for numeric types and indicates that the sign should\n+        always be printed. Positive signs are never printed by default, and the\n+        negative sign is only printed by default for the `Signed` trait. This\n+        flag indicates that the correct sign (+ or -) should always be printed.\n+* '-' - Currently not used\n+* '#' - This flag is indicates that the \"alternate\" form of printing should be\n+        used. By default, this only applies to the integer formatting traits and\n+        performs like:\n+    * `x` - precedes the argument with a \"0x\"\n+    * `X` - precedes the argument with a \"0x\"\n+    * `t` - precedes the argument with a \"0b\"\n+    * `o` - precedes the argument with a \"0o\"\n+* '0' - This is used to indicate for integer formats that the padding should\n+        both be done with a `0` character as well as be sign-aware. A format\n+        like `{:08d}` would yield `00000001` for the integer `1`, while the same\n+        format would yield `-0000001` for the integer `-1`. Notice that the\n+        negative version has one fewer zero than the positive version.\n+\n+### Width\n+\n+This is a parameter for the \"minimum width\" that the format should take up. If\n+the value's string does not fill up this many characters, then the padding\n+specified by fill/alignment will be used to take up the required space.\n+\n+The default fill/alignment for non-numerics is a space and left-aligned. The\n+defaults for numeric formatters is also a space but with right-alignment. If the\n+'0' flag is specified for numerics, then the implicit fill character is '0'.\n+\n+The value for the width can also be provided as a `uint` in the list of\n+parameters by using the `2$` syntax indicating that the second argument is a\n+`uint` specifying the width.\n+\n+### Precision\n+\n+For non-numeric types, this can be considered a \"maximum width\". If the\n+resulting string is longer than this width, then it is truncated down to this\n+many characters and only those are emitted.\n+\n+For integral types, this has no meaning currently.\n+\n+For floating-point types, this indicates how many digits after the decimal point\n+should be printed.\n+\n+## Escaping\n+\n+The literal characters `{`, `}`, or `#` may be included in a string by\n+preceding them with the `\\` character. Since `\\` is already an\n+escape character in Rust strings, a string literal using this escape\n+will look like `\"\\\\{\"`.\n+\n+*/\n+\n+use io::Writer;\n+use io;\n+use option::None;\n+use repr;\n+use result::{Ok, Err};\n+use str::{StrAllocating};\n+use str;\n+use slice::Vector;\n+\n+#[cfg(stage0)]\n+pub use core::fmt::parse;\n+\n+pub use core::fmt::{Formatter, Result, FormatWriter, Show, rt};\n+pub use core::fmt::{Show, Bool, Char, Signed, Unsigned, Octal, Binary};\n+pub use core::fmt::{LowerHex, UpperHex, String, Pointer};\n+pub use core::fmt::{Float, LowerExp, UpperExp};\n+pub use core::fmt::{FormatError, WriteError};\n+pub use core::fmt::{Argument, Arguments, write};\n+\n+#[doc(hidden)]\n+pub use core::fmt::{argument, argumentstr, argumentuint};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_show, secret_string, secret_unsigned};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_signed, secret_lower_hex, secret_upper_hex};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_bool, secret_char, secret_octal, secret_binary};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_bool, secret_char, secret_octal, secret_binary};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_float, secret_upper_exp, secret_lower_exp};\n+#[doc(hidden)]\n+pub use core::fmt::{secret_pointer};\n+\n+#[doc(hidden)]\n+pub fn secret_poly<T: Poly>(x: &T, fmt: &mut Formatter) -> Result {\n+    // FIXME #11938 - UFCS would make us able call the this method\n+    //                directly Poly::fmt(x, fmt).\n+    x.fmt(fmt)\n+}\n+\n+/// Format trait for the `?` character\n+pub trait Poly {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+/// The format function takes a precompiled format string and a list of\n+/// arguments, to return the resulting formatted string.\n+///\n+/// # Arguments\n+///\n+///   * args - a structure of arguments generated via the `format_args!` macro.\n+///            Because this structure can only be safely generated at\n+///            compile-time, this function is safe.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::fmt;\n+///\n+/// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n+/// assert_eq!(s, \"Hello, world!\".to_owned());\n+/// ```\n+pub fn format(args: &Arguments) -> ~str {\n+    let mut output = io::MemWriter::new();\n+    output.write_fmt(args).unwrap();\n+    str::from_utf8(output.unwrap().as_slice()).unwrap().to_owned()\n+}\n+\n+impl<T> Poly for T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match (f.width, f.precision) {\n+            (None, None) => {\n+                match repr::write_repr(f, self) {\n+                    Ok(()) => Ok(()),\n+                    Err(..) => Err(WriteError),\n+                }\n+            }\n+\n+            // If we have a specified width for formatting, then we have to make\n+            // this allocation of a new string\n+            _ => {\n+                let s = repr::repr_to_str(self);\n+                f.pad(s)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Writer for Formatter<'a> {\n+    fn write(&mut self, b: &[u8]) -> io::IoResult<()> {\n+        match (*self).write(b) {\n+            Ok(()) => Ok(()),\n+            Err(WriteError) => Err(io::standard_error(io::OtherIoError))\n+        }\n+    }\n+}"}, {"sha": "d4f12f590ae7516c0e064c2c7395f471d44facd1", "filename": "src/libstd/fmt/mod.rs", "status": "removed", "additions": 0, "deletions": 1405, "changes": 1405, "blob_url": "https://github.com/rust-lang/rust/blob/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=ba0a984a862f4f4246a3be014b9b244525bedd20", "patch": "@@ -1,1405 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Utilities for formatting and printing strings\n-\n-This module contains the runtime support for the `format!` syntax extension.\n-This macro is implemented in the compiler to emit calls to this module in order\n-to format arguments at runtime into strings and streams.\n-\n-The functions contained in this module should not normally be used in everyday\n-use cases of `format!`. The assumptions made by these functions are unsafe for\n-all inputs, and the compiler performs a large amount of validation on the\n-arguments to `format!` in order to ensure safety at runtime. While it is\n-possible to call these functions directly, it is not recommended to do so in the\n-general case.\n-\n-## Usage\n-\n-The `format!` macro is intended to be familiar to those coming from C's\n-printf/fprintf functions or Python's `str.format` function. In its current\n-revision, the `format!` macro returns a `~str` type which is the result of the\n-formatting. In the future it will also be able to pass in a stream to format\n-arguments directly while performing minimal allocations.\n-\n-Some examples of the `format!` extension are:\n-\n-```rust\n-format!(\"Hello\");                 // => \"Hello\".to_owned()\n-format!(\"Hello, {:s}!\", \"world\"); // => \"Hello, world!\".to_owned()\n-format!(\"The number is {:d}\", 1); // => \"The number is 1\".to_owned()\n-format!(\"{:?}\", ~[3, 4]);         // => \"~[3, 4]\".to_owned()\n-format!(\"{value}\", value=4);      // => \"4\".to_owned()\n-format!(\"{} {}\", 1, 2);           // => \"1 2\".to_owned()\n-```\n-\n-From these, you can see that the first argument is a format string. It is\n-required by the compiler for this to be a string literal; it cannot be a\n-variable passed in (in order to perform validity checking). The compiler will\n-then parse the format string and determine if the list of arguments provided is\n-suitable to pass to this format string.\n-\n-### Positional parameters\n-\n-Each formatting argument is allowed to specify which value argument it's\n-referencing, and if omitted it is assumed to be \"the next argument\". For\n-example, the format string `{} {} {}` would take three parameters, and they\n-would be formatted in the same order as they're given. The format string\n-`{2} {1} {0}`, however, would format arguments in reverse order.\n-\n-Things can get a little tricky once you start intermingling the two types of\n-positional specifiers. The \"next argument\" specifier can be thought of as an\n-iterator over the argument. Each time a \"next argument\" specifier is seen, the\n-iterator advances. This leads to behavior like this:\n-\n-```rust\n-format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\".to_owned()\n-```\n-\n-The internal iterator over the argument has not been advanced by the time the\n-first `{}` is seen, so it prints the first argument. Then upon reaching the\n-second `{}`, the iterator has advanced forward to the second argument.\n-Essentially, parameters which explicitly name their argument do not affect\n-parameters which do not name an argument in terms of positional specifiers.\n-\n-A format string is required to use all of its arguments, otherwise it is a\n-compile-time error. You may refer to the same argument more than once in the\n-format string, although it must always be referred to with the same type.\n-\n-### Named parameters\n-\n-Rust itself does not have a Python-like equivalent of named parameters to a\n-function, but the `format!` macro is a syntax extension which allows it to\n-leverage named parameters. Named parameters are listed at the end of the\n-argument list and have the syntax:\n-\n-```notrust\n-identifier '=' expression\n-```\n-\n-For example, the following `format!` expressions all use named argument:\n-\n-```rust\n-format!(\"{argument}\", argument = \"test\");       // => \"test\".to_owned()\n-format!(\"{name} {}\", 1, name = 2);              // => \"2 1\".to_owned()\n-format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3); // => \"a 3 ()\".to_owned()\n-```\n-\n-It is illegal to put positional parameters (those without names) after arguments\n-which have names. Like positional parameters, it is illegal to provided named\n-parameters that are unused by the format string.\n-\n-### Argument types\n-\n-Each argument's type is dictated by the format string. It is a requirement that\n-every argument is only ever referred to by one type. When specifying the format\n-of an argument, however, a string like `{}` indicates no type. This is allowed,\n-and if all references to one argument do not provide a type, then the format `?`\n-is used (the type's rust-representation is printed). For example, this is an\n-invalid format string:\n-\n-```notrust\n-{0:d} {0:s}\n-```\n-\n-Because the first argument is both referred to as an integer as well as a\n-string.\n-\n-Because formatting is done via traits, there is no requirement that the\n-`d` format actually takes an `int`, but rather it simply requires a type which\n-ascribes to the `Signed` formatting trait. There are various parameters which do\n-require a particular type, however. Namely if the syntax `{:.*s}` is used, then\n-the number of characters to print from the string precedes the actual string and\n-must have the type `uint`. Although a `uint` can be printed with `{:u}`, it is\n-illegal to reference an argument as such. For example, this is another invalid\n-format string:\n-\n-```notrust\n-{:.*s} {0:u}\n-```\n-\n-### Formatting traits\n-\n-When requesting that an argument be formatted with a particular type, you are\n-actually requesting that an argument ascribes to a particular trait. This allows\n-multiple actual types to be formatted via `{:d}` (like `i8` as well as `int`).\n-The current mapping of types to traits is:\n-\n-* `?` \u21d2 `Poly`\n-* `d` \u21d2 `Signed`\n-* `i` \u21d2 `Signed`\n-* `u` \u21d2 `Unsigned`\n-* `b` \u21d2 `Bool`\n-* `c` \u21d2 `Char`\n-* `o` \u21d2 `Octal`\n-* `x` \u21d2 `LowerHex`\n-* `X` \u21d2 `UpperHex`\n-* `s` \u21d2 `String`\n-* `p` \u21d2 `Pointer`\n-* `t` \u21d2 `Binary`\n-* `f` \u21d2 `Float`\n-* `e` \u21d2 `LowerExp`\n-* `E` \u21d2 `UpperExp`\n-* *nothing* \u21d2 `Show`\n-\n-What this means is that any type of argument which implements the\n-`std::fmt::Binary` trait can then be formatted with `{:t}`. Implementations are\n-provided for these traits for a number of primitive types by the standard\n-library as well. If no format is specified (as in `{}` or `{:6}`), then the\n-format trait used is the `Show` trait. This is one of the more commonly\n-implemented traits when formatting a custom type.\n-\n-When implementing a format trait for your own type, you will have to implement a\n-method of the signature:\n-\n-```rust\n-# use std;\n-# mod fmt { pub type Result = (); }\n-# struct T;\n-# trait SomeName<T> {\n-fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result;\n-# }\n-```\n-\n-Your type will be passed as `self` by-reference, and then the function should\n-emit output into the `f.buf` stream. It is up to each format trait\n-implementation to correctly adhere to the requested formatting parameters. The\n-values of these parameters will be listed in the fields of the `Formatter`\n-struct. In order to help with this, the `Formatter` struct also provides some\n-helper methods.\n-\n-Additionally, the return value of this function is `fmt::Result` which is a\n-typedef to `Result<(), IoError>` (also known as `IoError<()>`). Formatting\n-implementations should ensure that they return errors from `write!` correctly\n-(propagating errors upward).\n-\n-An example of implementing the formatting traits would look\n-like:\n-\n-```rust\n-use std::fmt;\n-use std::f64;\n-\n-struct Vector2D {\n-    x: int,\n-    y: int,\n-}\n-\n-impl fmt::Show for Vector2D {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // The `f.buf` value is of the type `&mut io::Writer`, which is what the\n-        // write! macro is expecting. Note that this formatting ignores the\n-        // various flags provided to format strings.\n-        write!(f.buf, \"({}, {})\", self.x, self.y)\n-    }\n-}\n-\n-// Different traits allow different forms of output of a type. The meaning of\n-// this format is to print the magnitude of a vector.\n-impl fmt::Binary for Vector2D {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let magnitude = (self.x * self.x + self.y * self.y) as f64;\n-        let magnitude = magnitude.sqrt();\n-\n-        // Respect the formatting flags by using the helper method\n-        // `pad_integral` on the Formatter object. See the method documentation\n-        // for details, and the function `pad` can be used to pad strings.\n-        let decimals = f.precision.unwrap_or(3);\n-        let string = f64::to_str_exact(magnitude, decimals);\n-        f.pad_integral(true, \"\", string.as_bytes())\n-    }\n-}\n-\n-fn main() {\n-    let myvector = Vector2D { x: 3, y: 4 };\n-\n-    println!(\"{}\", myvector);       // => \"(3, 4)\"\n-    println!(\"{:10.3t}\", myvector); // => \"     5.000\"\n-}\n-```\n-\n-### Related macros\n-\n-There are a number of related macros in the `format!` family. The ones that are\n-currently implemented are:\n-\n-```ignore\n-format!      // described above\n-write!       // first argument is a &mut io::Writer, the destination\n-writeln!     // same as write but appends a newline\n-print!       // the format string is printed to the standard output\n-println!     // same as print but appends a newline\n-format_args! // described below.\n-```\n-\n-\n-#### `write!`\n-\n-This and `writeln` are two macros which are used to emit the format string to a\n-specified stream. This is used to prevent intermediate allocations of format\n-strings and instead directly write the output. Under the hood, this function is\n-actually invoking the `write` function defined in this module. Example usage is:\n-\n-```rust\n-# #![allow(unused_must_use)]\n-use std::io;\n-\n-let mut w = io::MemWriter::new();\n-write!(&mut w as &mut io::Writer, \"Hello {}!\", \"world\");\n-```\n-\n-#### `print!`\n-\n-This and `println` emit their output to stdout. Similarly to the `write!` macro,\n-the goal of these macros is to avoid intermediate allocations when printing\n-output. Example usage is:\n-\n-```rust\n-print!(\"Hello {}!\", \"world\");\n-println!(\"I have a newline {}\", \"character at the end\");\n-```\n-\n-#### `format_args!`\n-This is a curious macro which is used to safely pass around\n-an opaque object describing the format string. This object\n-does not require any heap allocations to create, and it only\n-references information on the stack. Under the hood, all of\n-the related macros are implemented in terms of this. First\n-off, some example usage is:\n-\n-```\n-use std::fmt;\n-use std::io;\n-\n-# #[allow(unused_must_use)]\n-# fn main() {\n-format_args!(fmt::format, \"this returns {}\", \"~str\");\n-\n-let some_writer: &mut io::Writer = &mut io::stdout();\n-format_args!(|args| { fmt::write(some_writer, args) }, \"print with a {}\", \"closure\");\n-\n-fn my_fmt_fn(args: &fmt::Arguments) {\n-    fmt::write(&mut io::stdout(), args);\n-}\n-format_args!(my_fmt_fn, \"or a {} too\", \"function\");\n-# }\n-```\n-\n-The first argument of the `format_args!` macro is a function (or closure) which\n-takes one argument of type `&fmt::Arguments`. This structure can then be\n-passed to the `write` and `format` functions inside this module in order to\n-process the format string. The goal of this macro is to even further prevent\n-intermediate allocations when dealing formatting strings.\n-\n-For example, a logging library could use the standard formatting syntax, but it\n-would internally pass around this structure until it has been determined where\n-output should go to.\n-\n-It is unsafe to programmatically create an instance of `fmt::Arguments` because\n-the operations performed when executing a format string require the compile-time\n-checks provided by the compiler. The `format_args!` macro is the only method of\n-safely creating these structures, but they can be unsafely created with the\n-constructor provided.\n-\n-## Internationalization\n-\n-The formatting syntax supported by the `format!` extension supports\n-internationalization by providing \"methods\" which execute various different\n-outputs depending on the input. The syntax and methods provided are similar to\n-other internationalization systems, so again nothing should seem alien.\n-Currently two methods are supported by this extension: \"select\" and \"plural\".\n-\n-Each method will execute one of a number of clauses, and then the value of the\n-clause will become what's the result of the argument's format. Inside of the\n-cases, nested argument strings may be provided, but all formatting arguments\n-must not be done through implicit positional means. All arguments inside of each\n-case of a method must be explicitly selected by their name or their integer\n-position.\n-\n-Furthermore, whenever a case is running, the special character `#` can be used\n-to reference the string value of the argument which was selected upon. As an\n-example:\n-\n-```rust\n-format!(\"{0, select, other{#}}\", \"hello\"); // => \"hello\".to_owned()\n-```\n-\n-This example is the equivalent of `{0:s}` essentially.\n-\n-### Select\n-\n-The select method is a switch over a `&str` parameter, and the parameter *must*\n-be of the type `&str`. An example of the syntax is:\n-\n-```notrust\n-{0, select, male{...} female{...} other{...}}\n-```\n-\n-Breaking this down, the `0`-th argument is selected upon with the `select`\n-method, and then a number of cases follow. Each case is preceded by an\n-identifier which is the match-clause to execute the given arm. In this case,\n-there are two explicit cases, `male` and `female`. The case will be executed if\n-the string argument provided is an exact match to the case selected.\n-\n-The `other` case is also a required case for all `select` methods. This arm will\n-be executed if none of the other arms matched the word being selected over.\n-\n-### Plural\n-\n-The plural method is a switch statement over a `uint` parameter, and the\n-parameter *must* be a `uint`. A plural method in its full glory can be specified\n-as:\n-\n-```notrust\n-{0, plural, offset=1 =1{...} two{...} many{...} other{...}}\n-```\n-\n-To break this down, the first `0` indicates that this method is selecting over\n-the value of the first positional parameter to the format string. Next, the\n-`plural` method is being executed. An optionally-supplied `offset` is then given\n-which indicates a number to subtract from argument `0` when matching. This is\n-then followed by a list of cases.\n-\n-Each case is allowed to supply a specific value to match upon with the syntax\n-`=N`. This case is executed if the value at argument `0` matches N exactly,\n-without taking the offset into account. A case may also be specified by one of\n-five keywords: `zero`, `one`, `two`, `few`, and `many`. These cases are matched\n-on after argument `0` has the offset taken into account. Currently the\n-definitions of `many` and `few` are hardcoded, but they are in theory defined by\n-the current locale.\n-\n-Finally, all `plural` methods must have an `other` case supplied which will be\n-executed if none of the other cases match.\n-\n-## Syntax\n-\n-The syntax for the formatting language used is drawn from other languages, so it\n-should not be too alien. Arguments are formatted with python-like syntax,\n-meaning that arguments are surrounded by `{}` instead of the C-like `%`. The\n-actual grammar for the formatting syntax is:\n-\n-```notrust\n-format_string := <text> [ format <text> ] *\n-format := '{' [ argument ] [ ':' format_spec ] [ ',' function_spec ] '}'\n-argument := integer | identifier\n-\n-format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n-fill := character\n-align := '<' | '>'\n-sign := '+' | '-'\n-width := count\n-precision := count | '*'\n-type := identifier | ''\n-count := parameter | integer\n-parameter := integer '$'\n-\n-function_spec := plural | select\n-select := 'select' ',' ( identifier arm ) *\n-plural := 'plural' ',' [ 'offset:' integer ] ( selector arm ) *\n-selector := '=' integer | keyword\n-keyword := 'zero' | 'one' | 'two' | 'few' | 'many' | 'other'\n-arm := '{' format_string '}'\n-```\n-\n-## Formatting Parameters\n-\n-Each argument being formatted can be transformed by a number of formatting\n-parameters (corresponding to `format_spec` in the syntax above). These\n-parameters affect the string representation of what's being formatted. This\n-syntax draws heavily from Python's, so it may seem a bit familiar.\n-\n-### Fill/Alignment\n-\n-The fill character is provided normally in conjunction with the `width`\n-parameter. This indicates that if the value being formatted is smaller than\n-`width` some extra characters will be printed around it. The extra characters\n-are specified by `fill`, and the alignment can be one of two options:\n-\n-* `<` - the argument is left-aligned in `width` columns\n-* `>` - the argument is right-aligned in `width` columns\n-\n-### Sign/#/0\n-\n-These can all be interpreted as flags for a particular formatter.\n-\n-* '+' - This is intended for numeric types and indicates that the sign should\n-        always be printed. Positive signs are never printed by default, and the\n-        negative sign is only printed by default for the `Signed` trait. This\n-        flag indicates that the correct sign (+ or -) should always be printed.\n-* '-' - Currently not used\n-* '#' - This flag is indicates that the \"alternate\" form of printing should be\n-        used. By default, this only applies to the integer formatting traits and\n-        performs like:\n-    * `x` - precedes the argument with a \"0x\"\n-    * `X` - precedes the argument with a \"0x\"\n-    * `t` - precedes the argument with a \"0b\"\n-    * `o` - precedes the argument with a \"0o\"\n-* '0' - This is used to indicate for integer formats that the padding should\n-        both be done with a `0` character as well as be sign-aware. A format\n-        like `{:08d}` would yield `00000001` for the integer `1`, while the same\n-        format would yield `-0000001` for the integer `-1`. Notice that the\n-        negative version has one fewer zero than the positive version.\n-\n-### Width\n-\n-This is a parameter for the \"minimum width\" that the format should take up. If\n-the value's string does not fill up this many characters, then the padding\n-specified by fill/alignment will be used to take up the required space.\n-\n-The default fill/alignment for non-numerics is a space and left-aligned. The\n-defaults for numeric formatters is also a space but with right-alignment. If the\n-'0' flag is specified for numerics, then the implicit fill character is '0'.\n-\n-The value for the width can also be provided as a `uint` in the list of\n-parameters by using the `2$` syntax indicating that the second argument is a\n-`uint` specifying the width.\n-\n-### Precision\n-\n-For non-numeric types, this can be considered a \"maximum width\". If the\n-resulting string is longer than this width, then it is truncated down to this\n-many characters and only those are emitted.\n-\n-For integral types, this has no meaning currently.\n-\n-For floating-point types, this indicates how many digits after the decimal point\n-should be printed.\n-\n-## Escaping\n-\n-The literal characters `{`, `}`, or `#` may be included in a string by\n-preceding them with the `\\` character. Since `\\` is already an\n-escape character in Rust strings, a string literal using this escape\n-will look like `\"\\\\{\"`.\n-\n-*/\n-\n-use any;\n-use cell::Cell;\n-use char::Char;\n-use cmp;\n-use container::Container;\n-use intrinsics::TypeId;\n-use io::MemWriter;\n-use io;\n-use iter::{Iterator, range};\n-use iter;\n-use kinds::Copy;\n-use mem;\n-use num::Signed;\n-use option::{Option, Some, None};\n-use owned::Box;\n-use repr;\n-use result::{Ok, Err, ResultUnwrap};\n-use slice::{Vector, ImmutableVector};\n-use slice;\n-use str::{StrSlice, StrAllocating, UTF16Item, ScalarValue, LoneSurrogate};\n-use str;\n-use strbuf::StrBuf;\n-\n-pub use self::num::radix;\n-pub use self::num::Radix;\n-pub use self::num::RadixFmt;\n-\n-mod num;\n-pub mod rt;\n-\n-pub type Result = io::IoResult<()>;\n-\n-/// A struct to represent both where to emit formatting strings to and how they\n-/// should be formatted. A mutable version of this is passed to all formatting\n-/// traits.\n-pub struct Formatter<'a> {\n-    /// Flags for formatting (packed version of rt::Flag)\n-    pub flags: uint,\n-    /// Character used as 'fill' whenever there is alignment\n-    pub fill: char,\n-    /// Boolean indication of whether the output should be left-aligned\n-    pub align: rt::Alignment,\n-    /// Optionally specified integer width that the output should be\n-    pub width: Option<uint>,\n-    /// Optionally specified precision for numeric types\n-    pub precision: Option<uint>,\n-\n-    /// Output buffer.\n-    pub buf: &'a mut io::Writer,\n-    curarg: slice::Items<'a, Argument<'a>>,\n-    args: &'a [Argument<'a>],\n-}\n-\n-/// This struct represents the generic \"argument\" which is taken by the Xprintf\n-/// family of functions. It contains a function to format the given value. At\n-/// compile time it is ensured that the function and the value have the correct\n-/// types, and then this struct is used to canonicalize arguments to one type.\n-pub struct Argument<'a> {\n-    formatter: extern \"Rust\" fn(&any::Void, &mut Formatter) -> Result,\n-    value: &'a any::Void,\n-}\n-\n-impl<'a> Arguments<'a> {\n-    /// When using the format_args!() macro, this function is used to generate the\n-    /// Arguments structure. The compiler inserts an `unsafe` block to call this,\n-    /// which is valid because the compiler performs all necessary validation to\n-    /// ensure that the resulting call to format/write would be safe.\n-    #[doc(hidden)] #[inline]\n-    pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],\n-                          args: &'a [Argument<'a>]) -> Arguments<'a> {\n-        Arguments{ fmt: mem::transmute(fmt), args: args }\n-    }\n-}\n-\n-/// This structure represents a safely precompiled version of a format string\n-/// and its arguments. This cannot be generated at runtime because it cannot\n-/// safely be done so, so no constructors are given and the fields are private\n-/// to prevent modification.\n-///\n-/// The `format_args!` macro will safely create an instance of this structure\n-/// and pass it to a user-supplied function. The macro validates the format\n-/// string at compile-time so usage of the `write` and `format` functions can\n-/// be safely performed.\n-pub struct Arguments<'a> {\n-    fmt: &'a [rt::Piece<'a>],\n-    args: &'a [Argument<'a>],\n-}\n-\n-impl<'a> Show for Arguments<'a> {\n-    fn fmt(&self, fmt: &mut Formatter) -> Result {\n-        write(fmt.buf, self)\n-    }\n-}\n-\n-/// When a format is not otherwise specified, types are formatted by ascribing\n-/// to this trait. There is not an explicit way of selecting this trait to be\n-/// used for formatting, it is only if no other format is specified.\n-pub trait Show {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `b` character\n-pub trait Bool {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `c` character\n-pub trait Char {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `i` and `d` characters\n-pub trait Signed {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `u` character\n-pub trait Unsigned {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `o` character\n-pub trait Octal {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `t` character\n-pub trait Binary {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `x` character\n-pub trait LowerHex {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `X` character\n-pub trait UpperHex {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `s` character\n-pub trait String {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `?` character\n-pub trait Poly {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `p` character\n-pub trait Pointer {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `f` character\n-pub trait Float {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `e` character\n-pub trait LowerExp {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-/// Format trait for the `E` character\n-pub trait UpperExp {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n-// FIXME #11938 - UFCS would make us able call the above methods\n-// directly Show::show(x, fmt).\n-macro_rules! uniform_fn_call_workaround {\n-    ($( $name: ident, $trait_: ident; )*) => {\n-        $(\n-            #[doc(hidden)]\n-            pub fn $name<T: $trait_>(x: &T, fmt: &mut Formatter) -> Result {\n-                x.fmt(fmt)\n-            }\n-            )*\n-    }\n-}\n-uniform_fn_call_workaround! {\n-    secret_show, Show;\n-    secret_bool, Bool;\n-    secret_char, Char;\n-    secret_signed, Signed;\n-    secret_unsigned, Unsigned;\n-    secret_octal, Octal;\n-    secret_binary, Binary;\n-    secret_lower_hex, LowerHex;\n-    secret_upper_hex, UpperHex;\n-    secret_string, String;\n-    secret_poly, Poly;\n-    secret_pointer, Pointer;\n-    secret_float, Float;\n-    secret_lower_exp, LowerExp;\n-    secret_upper_exp, UpperExp;\n-}\n-\n-/// The `write` function takes an output stream, a precompiled format string,\n-/// and a list of arguments. The arguments will be formatted according to the\n-/// specified format string into the output stream provided.\n-///\n-/// # Arguments\n-///\n-///   * output - the buffer to write output to\n-///   * args - the precompiled arguments generated by `format_args!`\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(unused_must_use)]\n-/// use std::fmt;\n-/// use std::io;\n-///\n-/// let mut w = io::stdout();\n-/// format_args!(|args| { fmt::write(&mut w, args); }, \"Hello, {}!\", \"world\");\n-/// ```\n-pub fn write(output: &mut io::Writer, args: &Arguments) -> Result {\n-    unsafe { write_unsafe(output, args.fmt, args.args) }\n-}\n-\n-/// The `writeln` function takes the same arguments as `write`, except that it\n-/// will also write a newline (`\\n`) character at the end of the format string.\n-pub fn writeln(output: &mut io::Writer, args: &Arguments) -> Result {\n-    let first = unsafe { write_unsafe(output, args.fmt, args.args) };\n-    first.and_then(|()| output.write(['\\n' as u8]))\n-}\n-\n-/// The `write_unsafe` function takes an output stream, a precompiled format\n-/// string, and a list of arguments. The arguments will be formatted according\n-/// to the specified format string into the output stream provided.\n-///\n-/// See the documentation for `format` for why this function is unsafe and care\n-/// should be taken if calling it manually.\n-///\n-/// Thankfully the rust compiler provides macros like `write!` and\n-/// `format_args!` which perform all of this validation at compile-time\n-/// and provide a safe interface for invoking this function.\n-///\n-/// # Arguments\n-///\n-///   * output - the buffer to write output to\n-///   * fmts - the precompiled format string to emit\n-///   * args - the list of arguments to the format string. These are only the\n-///            positional arguments (not named)\n-///\n-/// Note that this function assumes that there are enough arguments for the\n-/// format string.\n-pub unsafe fn write_unsafe(output: &mut io::Writer,\n-                           fmt: &[rt::Piece],\n-                           args: &[Argument]) -> Result {\n-    let mut formatter = Formatter {\n-        flags: 0,\n-        width: None,\n-        precision: None,\n-        buf: output,\n-        align: rt::AlignUnknown,\n-        fill: ' ',\n-        args: args,\n-        curarg: args.iter(),\n-    };\n-    for piece in fmt.iter() {\n-        try!(formatter.run(piece, None));\n-    }\n-    Ok(())\n-}\n-\n-/// The format function takes a precompiled format string and a list of\n-/// arguments, to return the resulting formatted string.\n-///\n-/// # Arguments\n-///\n-///   * args - a structure of arguments generated via the `format_args!` macro.\n-///            Because this structure can only be safely generated at\n-///            compile-time, this function is safe.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::fmt;\n-///\n-/// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n-/// assert_eq!(s, \"Hello, world!\".to_owned());\n-/// ```\n-pub fn format(args: &Arguments) -> ~str {\n-    unsafe { format_unsafe(args.fmt, args.args) }\n-}\n-\n-/// Temporary transitionary thing.\n-pub fn format_strbuf(args: &Arguments) -> StrBuf {\n-    unsafe { format_unsafe_strbuf(args.fmt, args.args) }\n-}\n-\n-/// The unsafe version of the formatting function.\n-///\n-/// This is currently an unsafe function because the types of all arguments\n-/// aren't verified by immediate callers of this function. This currently does\n-/// not validate that the correct types of arguments are specified for each\n-/// format specifier, nor that each argument itself contains the right function\n-/// for formatting the right type value. Because of this, the function is marked\n-/// as `unsafe` if this is being called manually.\n-///\n-/// Thankfully the rust compiler provides the macro `format!` which will perform\n-/// all of this validation at compile-time and provides a safe interface for\n-/// invoking this function.\n-///\n-/// # Arguments\n-///\n-///   * fmts - the precompiled format string to emit.\n-///   * args - the list of arguments to the format string. These are only the\n-///            positional arguments (not named)\n-///\n-/// Note that this function assumes that there are enough arguments for the\n-/// format string.\n-pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n-    let mut output = MemWriter::new();\n-    write_unsafe(&mut output as &mut io::Writer, fmt, args).unwrap();\n-    return str::from_utf8(output.unwrap().as_slice()).unwrap().to_owned();\n-}\n-\n-/// Temporary transitionary thing.\n-pub unsafe fn format_unsafe_strbuf(fmt: &[rt::Piece], args: &[Argument])\n-                                   -> StrBuf {\n-    let mut output = MemWriter::new();\n-    write_unsafe(&mut output as &mut io::Writer, fmt, args).unwrap();\n-    return str::from_utf8(output.unwrap().as_slice()).unwrap().into_strbuf();\n-}\n-\n-impl<'a> Formatter<'a> {\n-\n-    // First up is the collection of functions used to execute a format string\n-    // at runtime. This consumes all of the compile-time statics generated by\n-    // the format! syntax extension.\n-\n-    fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) -> Result {\n-        match *piece {\n-            rt::String(s) => self.buf.write(s.as_bytes()),\n-            rt::CurrentArgument(()) => self.buf.write(cur.unwrap().as_bytes()),\n-            rt::Argument(ref arg) => {\n-                // Fill in the format parameters into the formatter\n-                self.fill = arg.format.fill;\n-                self.align = arg.format.align;\n-                self.flags = arg.format.flags;\n-                self.width = self.getcount(&arg.format.width);\n-                self.precision = self.getcount(&arg.format.precision);\n-\n-                // Extract the correct argument\n-                let value = match arg.position {\n-                    rt::ArgumentNext => { *self.curarg.next().unwrap() }\n-                    rt::ArgumentIs(i) => self.args[i],\n-                };\n-\n-                // Then actually do some printing\n-                match arg.method {\n-                    None => (value.formatter)(value.value, self),\n-                    Some(ref method) => self.execute(*method, value)\n-                }\n-            }\n-        }\n-    }\n-\n-    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {\n-        match *cnt {\n-            rt::CountIs(n) => { Some(n) }\n-            rt::CountImplied => { None }\n-            rt::CountIsParam(i) => {\n-                let v = self.args[i].value;\n-                unsafe { Some(*(v as *any::Void as *uint)) }\n-            }\n-            rt::CountIsNextParam => {\n-                let v = self.curarg.next().unwrap().value;\n-                unsafe { Some(*(v as *any::Void as *uint)) }\n-            }\n-        }\n-    }\n-\n-    fn execute(&mut self, method: &rt::Method, arg: Argument) -> Result {\n-        match *method {\n-            // Pluralization is selection upon a numeric value specified as the\n-            // parameter.\n-            rt::Plural(offset, ref selectors, ref default) => {\n-                // This is validated at compile-time to be a pointer to a\n-                // '&uint' value.\n-                let value: &uint = unsafe { mem::transmute(arg.value) };\n-                let value = *value;\n-\n-                // First, attempt to match against explicit values without the\n-                // offsetted value\n-                for s in selectors.iter() {\n-                    match s.selector {\n-                        rt::Literal(val) if value == val => {\n-                            return self.runplural(value, s.result);\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                // Next, offset the value and attempt to match against the\n-                // keyword selectors.\n-                let value = value - match offset { Some(i) => i, None => 0 };\n-                for s in selectors.iter() {\n-                    let run = match s.selector {\n-                        rt::Keyword(rt::Zero) => value == 0,\n-                        rt::Keyword(rt::One) => value == 1,\n-                        rt::Keyword(rt::Two) => value == 2,\n-\n-                        // FIXME: Few/Many should have a user-specified boundary\n-                        //      One possible option would be in the function\n-                        //      pointer of the 'arg: Argument' struct.\n-                        rt::Keyword(rt::Few) => value < 8,\n-                        rt::Keyword(rt::Many) => value >= 8,\n-\n-                        rt::Literal(..) => false\n-                    };\n-                    if run {\n-                        return self.runplural(value, s.result);\n-                    }\n-                }\n-\n-                self.runplural(value, *default)\n-            }\n-\n-            // Select is just a matching against the string specified.\n-            rt::Select(ref selectors, ref default) => {\n-                // This is validated at compile-time to be a pointer to a\n-                // string slice,\n-                let value: & &str = unsafe { mem::transmute(arg.value) };\n-                let value = *value;\n-\n-                for s in selectors.iter() {\n-                    if s.selector == value {\n-                        for piece in s.result.iter() {\n-                            try!(self.run(piece, Some(value)));\n-                        }\n-                        return Ok(());\n-                    }\n-                }\n-                for piece in default.iter() {\n-                    try!(self.run(piece, Some(value)));\n-                }\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) -> Result {\n-        ::uint::to_str_bytes(value, 10, |buf| {\n-            let valuestr = str::from_utf8(buf).unwrap();\n-            for piece in pieces.iter() {\n-                try!(self.run(piece, Some(valuestr)));\n-            }\n-            Ok(())\n-        })\n-    }\n-\n-    // Helper methods used for padding and processing formatting arguments that\n-    // all formatting traits can use.\n-\n-    /// Performs the correct padding for an integer which has already been\n-    /// emitted into a byte-array. The byte-array should *not* contain the sign\n-    /// for the integer, that will be added by this method.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * is_positive - whether the original integer was positive or not.\n-    /// * prefix - if the '#' character (FlagAlternate) is provided, this\n-    ///   is the prefix to put in front of the number.\n-    /// * buf - the byte array that the number has been formatted into\n-    ///\n-    /// This function will correctly account for the flags provided as well as\n-    /// the minimum width. It will not take precision into account.\n-    pub fn pad_integral(&mut self, is_positive: bool, prefix: &str, buf: &[u8]) -> Result {\n-        use fmt::rt::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n-\n-        let mut width = buf.len();\n-\n-        let mut sign = None;\n-        if !is_positive {\n-            sign = Some('-'); width += 1;\n-        } else if self.flags & (1 << (FlagSignPlus as uint)) != 0 {\n-            sign = Some('+'); width += 1;\n-        }\n-\n-        let mut prefixed = false;\n-        if self.flags & (1 << (FlagAlternate as uint)) != 0 {\n-            prefixed = true; width += prefix.len();\n-        }\n-\n-        // Writes the sign if it exists, and then the prefix if it was requested\n-        let write_prefix = |f: &mut Formatter| {\n-            for c in sign.move_iter() { try!(f.buf.write_char(c)); }\n-            if prefixed { f.buf.write_str(prefix) }\n-            else { Ok(()) }\n-        };\n-\n-        // The `width` field is more of a `min-width` parameter at this point.\n-        match self.width {\n-            // If there's no minimum length requirements then we can just\n-            // write the bytes.\n-            None => {\n-                try!(write_prefix(self)); self.buf.write(buf)\n-            }\n-            // Check if we're over the minimum width, if so then we can also\n-            // just write the bytes.\n-            Some(min) if width >= min => {\n-                try!(write_prefix(self)); self.buf.write(buf)\n-            }\n-            // The sign and prefix goes before the padding if the fill character\n-            // is zero\n-            Some(min) if self.flags & (1 << (FlagSignAwareZeroPad as uint)) != 0 => {\n-                self.fill = '0';\n-                try!(write_prefix(self));\n-                self.with_padding(min - width, rt::AlignRight, |f| f.buf.write(buf))\n-            }\n-            // Otherwise, the sign and prefix goes after the padding\n-            Some(min) => {\n-                self.with_padding(min - width, rt::AlignRight, |f| {\n-                    try!(write_prefix(f)); f.buf.write(buf)\n-                })\n-            }\n-        }\n-    }\n-\n-    /// This function takes a string slice and emits it to the internal buffer\n-    /// after applying the relevant formatting flags specified. The flags\n-    /// recognized for generic strings are:\n-    ///\n-    /// * width - the minimum width of what to emit\n-    /// * fill/align - what to emit and where to emit it if the string\n-    ///                provided needs to be padded\n-    /// * precision - the maximum length to emit, the string is truncated if it\n-    ///               is longer than this length\n-    ///\n-    /// Notably this function ignored the `flag` parameters\n-    pub fn pad(&mut self, s: &str) -> Result {\n-        // Make sure there's a fast path up front\n-        if self.width.is_none() && self.precision.is_none() {\n-            return self.buf.write(s.as_bytes());\n-        }\n-        // The `precision` field can be interpreted as a `max-width` for the\n-        // string being formatted\n-        match self.precision {\n-            Some(max) => {\n-                // If there's a maximum width and our string is longer than\n-                // that, then we must always have truncation. This is the only\n-                // case where the maximum length will matter.\n-                let char_len = s.char_len();\n-                if char_len >= max {\n-                    let nchars = ::cmp::min(max, char_len);\n-                    return self.buf.write(s.slice_chars(0, nchars).as_bytes());\n-                }\n-            }\n-            None => {}\n-        }\n-        // The `width` field is more of a `min-width` parameter at this point.\n-        match self.width {\n-            // If we're under the maximum length, and there's no minimum length\n-            // requirements, then we can just emit the string\n-            None => self.buf.write(s.as_bytes()),\n-            // If we're under the maximum width, check if we're over the minimum\n-            // width, if so it's as easy as just emitting the string.\n-            Some(width) if s.char_len() >= width => {\n-                self.buf.write(s.as_bytes())\n-            }\n-            // If we're under both the maximum and the minimum width, then fill\n-            // up the minimum width with the specified string + some alignment.\n-            Some(width) => {\n-                self.with_padding(width - s.len(), rt::AlignLeft, |me| {\n-                    me.buf.write(s.as_bytes())\n-                })\n-            }\n-        }\n-    }\n-\n-    /// Runs a callback, emitting the correct padding either before or\n-    /// afterwards depending on whether right or left alingment is requested.\n-    fn with_padding(&mut self,\n-                    padding: uint,\n-                    default: rt::Alignment,\n-                    f: |&mut Formatter| -> Result) -> Result {\n-        let align = match self.align {\n-            rt::AlignUnknown => default,\n-            rt::AlignLeft | rt::AlignRight => self.align\n-        };\n-        if align == rt::AlignLeft {\n-            try!(f(self));\n-        }\n-        let mut fill = [0u8, ..4];\n-        let len = self.fill.encode_utf8(fill);\n-        for _ in range(0, padding) {\n-            try!(self.buf.write(fill.slice_to(len)));\n-        }\n-        if align == rt::AlignRight {\n-            try!(f(self));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// This is a function which calls are emitted to by the compiler itself to\n-/// create the Argument structures that are passed into the `format` function.\n-#[doc(hidden)] #[inline]\n-pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n-                       t: &'a T) -> Argument<'a> {\n-    unsafe {\n-        Argument {\n-            formatter: mem::transmute(f),\n-            value: mem::transmute(t)\n-        }\n-    }\n-}\n-\n-/// When the compiler determines that the type of an argument *must* be a string\n-/// (such as for select), then it invokes this method.\n-#[doc(hidden)] #[inline]\n-pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n-    argument(secret_string, s)\n-}\n-\n-/// When the compiler determines that the type of an argument *must* be a uint\n-/// (such as for plural), then it invokes this method.\n-#[doc(hidden)] #[inline]\n-pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n-    argument(secret_unsigned, s)\n-}\n-\n-// Implementations of the core formatting traits\n-\n-impl<T: Show> Show for @T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n-}\n-impl<T: Show> Show for Box<T> {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n-}\n-impl<'a, T: Show> Show for &'a T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n-}\n-impl<'a, T: Show> Show for &'a mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n-}\n-\n-impl Bool for bool {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_string(&(if *self {\"true\"} else {\"false\"}), f)\n-    }\n-}\n-\n-impl<'a, T: str::Str> String for T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.pad(self.as_slice())\n-    }\n-}\n-\n-impl Char for char {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        let mut utf8 = [0u8, ..4];\n-        let amt = self.encode_utf8(utf8);\n-        let s: &str = unsafe { mem::transmute(utf8.slice_to(amt)) };\n-        secret_string(&s, f)\n-    }\n-}\n-\n-macro_rules! floating(($ty:ident) => {\n-    impl Float for $ty {\n-        fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            // FIXME: this shouldn't perform an allocation\n-            let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exact(self.abs(), i),\n-                None => ::$ty::to_str_digits(self.abs(), 6)\n-            };\n-            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n-        }\n-    }\n-\n-    impl LowerExp for $ty {\n-        fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            // FIXME: this shouldn't perform an allocation\n-            let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, false),\n-                None => ::$ty::to_str_exp_digits(self.abs(), 6, false)\n-            };\n-            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n-        }\n-    }\n-\n-    impl UpperExp for $ty {\n-        fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            // FIXME: this shouldn't perform an allocation\n-            let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, true),\n-                None => ::$ty::to_str_exp_digits(self.abs(), 6, true)\n-            };\n-            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n-        }\n-    }\n-})\n-floating!(f32)\n-floating!(f64)\n-\n-impl<T> Poly for T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match (f.width, f.precision) {\n-            (None, None) => {\n-                repr::write_repr(f.buf, self)\n-            }\n-\n-            // If we have a specified width for formatting, then we have to make\n-            // this allocation of a new string\n-            _ => {\n-                let s = repr::repr_to_str(self);\n-                f.pad(s)\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Pointer for *T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.flags |= 1 << (rt::FlagAlternate as uint);\n-        secret_lower_hex::<uint>(&(*self as uint), f)\n-    }\n-}\n-impl<T> Pointer for *mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(*self as *T), f)\n-    }\n-}\n-impl<'a, T> Pointer for &'a T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(&**self as *T), f)\n-    }\n-}\n-impl<'a, T> Pointer for &'a mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(&**self as *T), f)\n-    }\n-}\n-\n-// Implementation of Show for various core types\n-\n-macro_rules! delegate(($ty:ty to $other:ident) => {\n-    impl<'a> Show for $ty {\n-        fn fmt(&self, f: &mut Formatter) -> Result {\n-            (concat_idents!(secret_, $other)(self, f))\n-        }\n-    }\n-})\n-delegate!(~str to string)\n-delegate!(&'a str to string)\n-delegate!(bool to bool)\n-delegate!(char to char)\n-delegate!(f32 to float)\n-delegate!(f64 to float)\n-\n-impl<T> Show for *T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n-}\n-impl<T> Show for *mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n-}\n-\n-macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n-\n-macro_rules! tuple (\n-    () => ();\n-    ( $($name:ident,)+ ) => (\n-        impl<$($name:Show),*> Show for ($($name,)*) {\n-            #[allow(uppercase_variables, dead_assignment)]\n-            fn fmt(&self, f: &mut Formatter) -> Result {\n-                try!(write!(f.buf, \"(\"));\n-                let ($(ref $name,)*) = *self;\n-                let mut n = 0;\n-                $(\n-                    if n > 0 {\n-                        try!(write!(f.buf, \", \"));\n-                    }\n-                    try!(write!(f.buf, \"{}\", *$name));\n-                    n += 1;\n-                )*\n-                if n == 1 {\n-                    try!(write!(f.buf, \",\"));\n-                }\n-                write!(f.buf, \")\")\n-            }\n-        }\n-        peel!($($name,)*)\n-    )\n-)\n-\n-tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n-\n-impl Show for Box<any::Any> {\n-    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"Box<Any>\") }\n-}\n-\n-impl<'a> Show for &'a any::Any {\n-    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n-}\n-\n-impl<T: Show> Show for Option<T> {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            Some(ref t) => write!(f.buf, \"Some({})\", *t),\n-            None => write!(f.buf, \"None\"),\n-        }\n-    }\n-}\n-\n-impl<T: Show, U: Show> Show for ::result::Result<T, U> {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            Ok(ref t) => write!(f.buf, \"Ok({})\", *t),\n-            Err(ref t) => write!(f.buf, \"Err({})\", *t),\n-        }\n-    }\n-}\n-\n-impl<'a, T: Show> Show for &'a [T] {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n-            try!(write!(f.buf, \"[\"));\n-        }\n-        let mut is_first = true;\n-        for x in self.iter() {\n-            if is_first {\n-                is_first = false;\n-            } else {\n-                try!(write!(f.buf, \", \"));\n-            }\n-            try!(write!(f.buf, \"{}\", *x))\n-        }\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n-            try!(write!(f.buf, \"]\"));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, T: Show> Show for &'a mut [T] {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_show(&self.as_slice(), f)\n-    }\n-}\n-\n-impl<T: Show> Show for ~[T] {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_show(&self.as_slice(), f)\n-    }\n-}\n-\n-impl Show for () {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.pad(\"()\")\n-    }\n-}\n-\n-impl Show for TypeId {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        write!(f.buf, \"TypeId \\\\{ {} \\\\}\", self.hash())\n-    }\n-}\n-\n-impl<T: Show> Show for iter::MinMaxResult<T> {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            iter::NoElements =>\n-                write!(f.buf, \"NoElements\"),\n-            iter::OneElement(ref t) =>\n-                write!(f.buf, \"OneElement({})\", *t),\n-            iter::MinMax(ref t1, ref t2) =>\n-                write!(f.buf, \"MinMax({}, {})\", *t1, *t2),\n-        }\n-    }\n-}\n-\n-impl Show for cmp::Ordering {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            cmp::Less => write!(f.buf, \"Less\"),\n-            cmp::Greater => write!(f.buf, \"Greater\"),\n-            cmp::Equal => write!(f.buf, \"Equal\"),\n-        }\n-    }\n-}\n-\n-impl<T: Copy + Show> Show for Cell<T> {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        write!(f.buf, r\"Cell \\{ value: {} \\}\", self.get())\n-    }\n-}\n-\n-impl Show for UTF16Item {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            ScalarValue(c) => write!(f.buf, \"ScalarValue({})\", c),\n-            LoneSurrogate(u) => write!(f.buf, \"LoneSurrogate({})\", u),\n-        }\n-    }\n-}\n-\n-// If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n-// it's a lot easier than creating all of the rt::Piece structures here."}]}