{"sha": "790f4c566d9802dfcadc26398dde2051cfe6ec9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MGY0YzU2NmQ5ODAyZGZjYWRjMjYzOThkZGUyMDUxY2ZlNmVjOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-19T20:13:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-19T20:13:40Z"}, "message": "Auto merge of #56613 - Zoxc:query-perf1, r=michaelwoerister\n\nTweak query code for performance\n\nSplit from https://github.com/rust-lang/rust/pull/56509\n\nr? @michaelwoerister", "tree": {"sha": "d48c244d3ce98bd792b0519b485155d12aca988f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d48c244d3ce98bd792b0519b485155d12aca988f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/790f4c566d9802dfcadc26398dde2051cfe6ec9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/790f4c566d9802dfcadc26398dde2051cfe6ec9f", "html_url": "https://github.com/rust-lang/rust/commit/790f4c566d9802dfcadc26398dde2051cfe6ec9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/790f4c566d9802dfcadc26398dde2051cfe6ec9f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a4a4ffc69f2d05eb8b8a32eaf9bd0607b69fe38", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a4a4ffc69f2d05eb8b8a32eaf9bd0607b69fe38", "html_url": "https://github.com/rust-lang/rust/commit/0a4a4ffc69f2d05eb8b8a32eaf9bd0607b69fe38"}, {"sha": "f0adf5add45ac94f6a6d7487e9d055e591d8f42d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0adf5add45ac94f6a6d7487e9d055e591d8f42d", "html_url": "https://github.com/rust-lang/rust/commit/f0adf5add45ac94f6a6d7487e9d055e591d8f42d"}], "stats": {"total": 242, "additions": 167, "deletions": 75}, "files": [{"sha": "56f475314ae6f51d13d163270ad7140b44117b20", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -162,7 +162,9 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[inline]\n+            // FIXME: Make `is_anon`, `is_input`, `is_eval_always` and `has_params` properties\n+            // of queries\n+            #[inline(always)]\n             pub fn is_anon(&self) -> bool {\n                 match *self {\n                     $(\n@@ -171,7 +173,7 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[inline]\n+            #[inline(always)]\n             pub fn is_input(&self) -> bool {\n                 match *self {\n                     $(\n@@ -180,7 +182,7 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[inline]\n+            #[inline(always)]\n             pub fn is_eval_always(&self) -> bool {\n                 match *self {\n                     $(\n@@ -190,7 +192,7 @@ macro_rules! define_dep_nodes {\n             }\n \n             #[allow(unreachable_code)]\n-            #[inline]\n+            #[inline(always)]\n             pub fn has_params(&self) -> bool {\n                 match *self {\n                     $(\n@@ -230,6 +232,7 @@ macro_rules! define_dep_nodes {\n \n         impl DepNode {\n             #[allow(unreachable_code, non_snake_case)]\n+            #[inline(always)]\n             pub fn new<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                        dep: DepConstructor<'gcx>)\n                                        -> DepNode\n@@ -299,11 +302,11 @@ macro_rules! define_dep_nodes {\n             /// Construct a DepNode from the given DepKind and DefPathHash. This\n             /// method will assert that the given DepKind actually requires a\n             /// single DefId/DefPathHash parameter.\n-            #[inline]\n+            #[inline(always)]\n             pub fn from_def_path_hash(kind: DepKind,\n                                       def_path_hash: DefPathHash)\n                                       -> DepNode {\n-                assert!(kind.can_reconstruct_query_key() && kind.has_params());\n+                debug_assert!(kind.can_reconstruct_query_key() && kind.has_params());\n                 DepNode {\n                     kind,\n                     hash: def_path_hash.0,\n@@ -313,9 +316,9 @@ macro_rules! define_dep_nodes {\n             /// Create a new, parameterless DepNode. This method will assert\n             /// that the DepNode corresponding to the given DepKind actually\n             /// does not require any parameters.\n-            #[inline]\n+            #[inline(always)]\n             pub fn new_no_params(kind: DepKind) -> DepNode {\n-                assert!(!kind.has_params());\n+                debug_assert!(!kind.has_params());\n                 DepNode {\n                     kind,\n                     hash: Fingerprint::ZERO,\n@@ -418,14 +421,14 @@ impl fmt::Debug for DepNode {\n \n \n impl DefPathHash {\n-    #[inline]\n+    #[inline(always)]\n     pub fn to_dep_node(self, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, self)\n     }\n }\n \n impl DefId {\n-    #[inline]\n+    #[inline(always)]\n     pub fn to_dep_node(self, tcx: TyCtxt<'_, '_, '_>, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, tcx.def_path_hash(self))\n     }"}, {"sha": "de8a375ca6ddec46489d1b9e354f9c011f45ad11", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -159,6 +159,13 @@ impl Forest {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::Krate));\n         &self.krate\n     }\n+\n+    /// This is internally in the depedency tracking system.\n+    /// Use the `krate` method to ensure your dependency on the\n+    /// crate is tracked.\n+    pub fn untracked_krate<'hir>(&'hir self) -> &'hir Crate {\n+        &self.krate\n+    }\n }\n \n /// Represents a mapping from Node IDs to AST elements and their parent"}, {"sha": "799c2df8a53c5d3775763165184daa5b26ee06e9", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -86,6 +86,7 @@ impl<'a> StableHashingContext<'a> {\n     // The `krate` here is only used for mapping BodyIds to Bodies.\n     // Don't use it for anything else or you'll run the risk of\n     // leaking data out of the tracking system.\n+    #[inline]\n     pub fn new(sess: &'a Session,\n                krate: &'a hir::Crate,\n                definitions: &'a Definitions,"}, {"sha": "b76fb0ed08c992e084d04de9b886babbb9deadec", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -60,10 +60,12 @@\n #![feature(slice_sort_by_cached_key)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n+#![feature(thread_local)]\n #![feature(trace_macros)]\n #![feature(trusted_len)]\n #![feature(vec_remove_item)]\n #![feature(step_trait)]\n+#![feature(stmt_expr_attributes)]\n #![feature(integer_atomics)]\n #![feature(test)]\n #![feature(in_band_lifetimes)]"}, {"sha": "180019ac3875117294aae733a7f416c417ff1537", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -131,6 +131,9 @@ pub struct Session {\n     /// Used by -Z profile-queries in util::common\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n+    /// Used by -Z self-profile\n+    pub self_profiling_active: bool,\n+\n     /// Used by -Z self-profile\n     pub self_profiling: Lock<SelfProfiler>,\n \n@@ -823,10 +826,17 @@ impl Session {\n         }\n     }\n \n+    #[inline(never)]\n+    #[cold]\n+    fn profiler_active<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n+        let mut profiler = self.self_profiling.borrow_mut();\n+        f(&mut profiler);\n+    }\n+\n+    #[inline(always)]\n     pub fn profiler<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n-        if self.opts.debugging_opts.self_profile || self.opts.debugging_opts.profile_json {\n-            let mut profiler = self.self_profiling.borrow_mut();\n-            f(&mut profiler);\n+        if unlikely!(self.self_profiling_active) {\n+            self.profiler_active(f)\n         }\n     }\n \n@@ -1145,6 +1155,9 @@ pub fn build_session_(\n         CguReuseTracker::new_disabled()\n     };\n \n+    let self_profiling_active = sopts.debugging_opts.self_profile ||\n+                                sopts.debugging_opts.profile_json;\n+\n     let sess = Session {\n         target: target_cfg,\n         host,\n@@ -1177,6 +1190,7 @@ pub fn build_session_(\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,\n+        self_profiling_active,\n         self_profiling: Lock::new(SelfProfiler::new()),\n         profile_channel: Lock::new(None),\n         perf_stats: PerfStats {"}, {"sha": "04d96e362a4650c1d57831a70b5ccbc7361ff59b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -1343,8 +1343,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.cstore.crate_data_as_rc_any(cnum)\n     }\n \n+    #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'a> {\n-        let krate = self.dep_graph.with_ignore(|| self.hir().krate());\n+        let krate = self.gcx.hir_map.forest.untracked_krate();\n \n         StableHashingContext::new(self.sess,\n                                   krate,"}, {"sha": "6e513d68f60f52fe9a372062aaa8314a497d75da", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -18,6 +18,11 @@ use syntax_pos::Span;\n use ty::tls;\n use ty::query::Query;\n use ty::query::plumbing::CycleError;\n+#[cfg(not(parallel_queries))]\n+use ty::query::{\n+    plumbing::TryGetJob,\n+    config::QueryDescription,\n+};\n use ty::context::TyCtxt;\n use errors::Diagnostic;\n use std::process;\n@@ -83,44 +88,52 @@ impl<'tcx> QueryJob<'tcx> {\n     ///\n     /// For single threaded rustc there's no concurrent jobs running, so if we are waiting for any\n     /// query that means that there is a query cycle, thus this always running a cycle error.\n-    pub(super) fn await<'lcx>(\n+    #[cfg(not(parallel_queries))]\n+    #[inline(never)]\n+    #[cold]\n+    pub(super) fn cycle_error<'lcx, 'a, D: QueryDescription<'tcx>>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n         span: Span,\n-    ) -> Result<(), CycleError<'tcx>> {\n-        #[cfg(not(parallel_queries))]\n-        {\n-            self.find_cycle_in_stack(tcx, span)\n-        }\n+    ) -> TryGetJob<'a, 'tcx, D> {\n+        TryGetJob::JobCompleted(Err(Box::new(self.find_cycle_in_stack(tcx, span))))\n+    }\n \n-        #[cfg(parallel_queries)]\n-        {\n-            tls::with_related_context(tcx, move |icx| {\n-                let mut waiter = Lrc::new(QueryWaiter {\n-                    query: icx.query.clone(),\n-                    span,\n-                    cycle: Lock::new(None),\n-                    condvar: Condvar::new(),\n-                });\n-                self.latch.await(&waiter);\n-                // FIXME: Get rid of this lock. We have ownership of the QueryWaiter\n-                // although another thread may still have a Lrc reference so we cannot\n-                // use Lrc::get_mut\n-                let mut cycle = waiter.cycle.lock();\n-                match cycle.take() {\n-                    None => Ok(()),\n-                    Some(cycle) => Err(cycle)\n-                }\n-            })\n-        }\n+    /// Awaits for the query job to complete.\n+    ///\n+    /// For single threaded rustc there's no concurrent jobs running, so if we are waiting for any\n+    /// query that means that there is a query cycle, thus this always running a cycle error.\n+    #[cfg(parallel_queries)]\n+    pub(super) fn await<'lcx>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        span: Span,\n+    ) -> Result<(), Box<CycleError<'tcx>>> {\n+        tls::with_related_context(tcx, move |icx| {\n+            let mut waiter = Lrc::new(QueryWaiter {\n+                query: icx.query.clone(),\n+                span,\n+                cycle: Lock::new(None),\n+                condvar: Condvar::new(),\n+            });\n+            self.latch.await(&waiter);\n+            // FIXME: Get rid of this lock. We have ownership of the QueryWaiter\n+            // although another thread may still have a Lrc reference so we cannot\n+            // use Lrc::get_mut\n+            let mut cycle = waiter.cycle.lock();\n+            match cycle.take() {\n+                None => Ok(()),\n+                Some(cycle) => Err(Box::new(cycle))\n+            }\n+        })\n     }\n \n     #[cfg(not(parallel_queries))]\n     fn find_cycle_in_stack<'lcx>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n         span: Span,\n-    ) -> Result<(), CycleError<'tcx>> {\n+    ) -> CycleError<'tcx> {\n         // Get the current executing query (waiter) and find the waitee amongst its parents\n         let mut current_job = tls::with_related_context(tcx, |icx| icx.query.clone());\n         let mut cycle = Vec::new();\n@@ -140,7 +153,7 @@ impl<'tcx> QueryJob<'tcx> {\n                 let usage = job.parent.as_ref().map(|parent| {\n                     (job.info.span, parent.info.query.clone())\n                 });\n-                return Err(CycleError { usage, cycle });\n+                return CycleError { usage, cycle };\n             }\n \n             current_job = job.parent.clone();"}, {"sha": "f760ebbd759ec67ffb85a21adb24c9fca855c8c7", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -705,21 +705,21 @@ impl<'a, 'tcx, 'lcx> TyCtxt<'a, 'tcx, 'lcx> {\n         self,\n         span: Span,\n         key: DefId,\n-    ) -> Result<&'tcx [Ty<'tcx>], DiagnosticBuilder<'a>> {\n+    ) -> Result<&'tcx [Ty<'tcx>], Box<DiagnosticBuilder<'a>>> {\n         self.try_get_query::<queries::adt_sized_constraint<'_>>(span, key)\n     }\n     pub fn try_needs_drop_raw(\n         self,\n         span: Span,\n         key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Result<bool, DiagnosticBuilder<'a>> {\n+    ) -> Result<bool, Box<DiagnosticBuilder<'a>>> {\n         self.try_get_query::<queries::needs_drop_raw<'_>>(span, key)\n     }\n     pub fn try_optimized_mir(\n         self,\n         span: Span,\n         key: DefId,\n-    ) -> Result<&'tcx mir::Mir<'tcx>, DiagnosticBuilder<'a>> {\n+    ) -> Result<&'tcx mir::Mir<'tcx>, Box<DiagnosticBuilder<'a>>> {\n         self.try_get_query::<queries::optimized_mir<'_>>(span, key)\n     }\n }"}, {"sha": "7e799d2d6c39c9358810e61bed328936c7290749", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 57, "deletions": 30, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -153,8 +153,18 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             };\n             mem::drop(lock);\n \n-            if let Err(cycle) = job.await(tcx, span) {\n-                return TryGetJob::JobCompleted(Err(cycle));\n+            // If we are single-threaded we know that we have cycle error,\n+            // so we just turn the errror\n+            #[cfg(not(parallel_queries))]\n+            return job.cycle_error(tcx, span);\n+\n+            // With parallel queries we might just have to wait on some other\n+            // thread\n+            #[cfg(parallel_queries)]\n+            {\n+                if let Err(cycle) = job.await(tcx, span) {\n+                    return TryGetJob::JobCompleted(Err(cycle));\n+                }\n             }\n         }\n     }\n@@ -241,12 +251,16 @@ pub(super) enum TryGetJob<'a, 'tcx: 'a, D: QueryDescription<'tcx> + 'a> {\n     /// The query was already completed.\n     /// Returns the result of the query and its dep node index\n     /// if it succeeded or a cycle error if it failed\n-    JobCompleted(Result<(D::Value, DepNodeIndex), CycleError<'tcx>>),\n+    JobCompleted(Result<(D::Value, DepNodeIndex), Box<CycleError<'tcx>>>),\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub(super) fn report_cycle(self, CycleError { usage, cycle: stack }: CycleError<'gcx>)\n-        -> DiagnosticBuilder<'a>\n+    #[inline(never)]\n+    #[cold]\n+    pub(super) fn report_cycle(\n+        self,\n+        box CycleError { usage, cycle: stack }: Box<CycleError<'gcx>>\n+    ) -> Box<DiagnosticBuilder<'a>>\n     {\n         assert!(!stack.is_empty());\n \n@@ -280,7 +294,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                               &format!(\"cycle used when {}\", query.describe(self)));\n             }\n \n-            return err\n+            return Box::new(err)\n         })\n     }\n \n@@ -345,11 +359,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    #[inline(never)]\n     fn try_get_with<Q: QueryDescription<'gcx>>(\n         self,\n         span: Span,\n         key: Q::Key)\n-    -> Result<Q::Value, CycleError<'gcx>>\n+    -> Result<Q::Value, Box<CycleError<'gcx>>>\n     {\n         debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n                Q::NAME,\n@@ -436,7 +451,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         job: JobOwner<'a, 'gcx, Q>,\n         dep_node_index: DepNodeIndex,\n         dep_node: &DepNode\n-    ) -> Result<Q::Value, CycleError<'gcx>>\n+    ) -> Result<Q::Value, Box<CycleError<'gcx>>>\n     {\n         // Note this function can be called concurrently from the same query\n         // We must ensure that this is handled correctly\n@@ -522,7 +537,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         key: Q::Key,\n         job: JobOwner<'_, 'gcx, Q>,\n         dep_node: DepNode)\n-    -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+    -> Result<(Q::Value, DepNodeIndex), Box<CycleError<'gcx>>> {\n         // If the following assertion triggers, it can have two reasons:\n         // 1. Something is wrong with DepNode creation, either here or\n         //    in DepGraph::try_mark_green()\n@@ -611,37 +626,55 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         key: Q::Key,\n         span: Span,\n         dep_node: DepNode\n-    ) -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+    ) {\n+        profq_msg!(\n+            self,\n+            ProfileQueriesMsg::QueryBegin(span.data(), profq_query_msg!(Q::NAME, self, key))\n+        );\n+\n         // We may be concurrently trying both execute and force a query\n         // Ensure that only one of them runs the query\n         let job = match JobOwner::try_get(self, span, &key) {\n             TryGetJob::NotYetStarted(job) => job,\n-            TryGetJob::JobCompleted(result) => return result,\n+            TryGetJob::JobCompleted(_) => return,\n         };\n-        self.force_query_with_job::<Q>(key, job, dep_node)\n+        if let Err(e) = self.force_query_with_job::<Q>(key, job, dep_node) {\n+            self.report_cycle(e).emit();\n+        }\n     }\n \n     pub(super) fn try_get_query<Q: QueryDescription<'gcx>>(\n         self,\n         span: Span,\n         key: Q::Key,\n-    ) -> Result<Q::Value, DiagnosticBuilder<'a>> {\n+    ) -> Result<Q::Value, Box<DiagnosticBuilder<'a>>> {\n         match self.try_get_with::<Q>(span, key) {\n             Ok(e) => Ok(e),\n             Err(e) => Err(self.report_cycle(e)),\n         }\n     }\n \n+    // FIXME: Try uninlining this\n+    #[inline(always)]\n     pub(super) fn get_query<Q: QueryDescription<'gcx>>(\n         self,\n         span: Span,\n         key: Q::Key,\n     ) -> Q::Value {\n-        self.try_get_query::<Q>(span, key).unwrap_or_else(|mut e| {\n-            e.emit();\n-            Q::handle_cycle_error(self)\n+        self.try_get_with::<Q>(span, key).unwrap_or_else(|e| {\n+            self.emit_error::<Q>(e)\n         })\n     }\n+\n+    #[inline(never)]\n+    #[cold]\n+    fn emit_error<Q: QueryDescription<'gcx>>(\n+        self,\n+        e: Box<CycleError<'gcx>>,\n+    ) -> Q::Value {\n+        self.report_cycle(e).emit();\n+        Q::handle_cycle_error(self)\n+    }\n }\n \n macro_rules! handle_cycle_error {\n@@ -806,15 +839,18 @@ macro_rules! define_queries_inner {\n         }\n \n         impl<$tcx> QueryAccessors<$tcx> for queries::$name<$tcx> {\n+            #[inline(always)]\n             fn query(key: Self::Key) -> Query<'tcx> {\n                 Query::$name(key)\n             }\n \n+            #[inline(always)]\n             fn query_cache<'a>(tcx: TyCtxt<'a, $tcx, '_>) -> &'a Lock<QueryCache<$tcx, Self>> {\n                 &tcx.queries.$name\n             }\n \n             #[allow(unused)]\n+            #[inline(always)]\n             fn to_dep_node(tcx: TyCtxt<'_, $tcx, '_>, key: &Self::Key) -> DepNode {\n                 use dep_graph::DepConstructor::*;\n \n@@ -861,6 +897,7 @@ macro_rules! define_queries_inner {\n \n         impl<'a, 'gcx, 'tcx> Deref for TyCtxtAt<'a, 'gcx, 'tcx> {\n             type Target = TyCtxt<'a, 'gcx, 'tcx>;\n+            #[inline(always)]\n             fn deref(&self) -> &Self::Target {\n                 &self.tcx\n             }\n@@ -869,6 +906,7 @@ macro_rules! define_queries_inner {\n         impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n             /// Return a transparent wrapper for `TyCtxt` which uses\n             /// `span` as the location of queries performed through it.\n+            #[inline(always)]\n             pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n                 TyCtxtAt {\n                     tcx: self,\n@@ -877,13 +915,15 @@ macro_rules! define_queries_inner {\n             }\n \n             $($(#[$attr])*\n+            #[inline(always)]\n             pub fn $name(self, key: $K) -> $V {\n                 self.at(DUMMY_SP).$name(key)\n             })*\n         }\n \n         impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n             $($(#[$attr])*\n+            #[inline(always)]\n             pub fn $name(self, key: $K) -> $V {\n                 self.tcx.get_query::<queries::$name<'_>>(self.span, key)\n             })*\n@@ -1023,20 +1063,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n     macro_rules! force {\n         ($query:ident, $key:expr) => {\n             {\n-                use $crate::util::common::{ProfileQueriesMsg, profq_msg};\n-\n-                profq_msg!(tcx,\n-                    ProfileQueriesMsg::QueryBegin(\n-                        DUMMY_SP.data(),\n-                        profq_query_msg!(::ty::query::queries::$query::NAME, tcx, $key),\n-                    )\n-                );\n-\n-                if let Err(e) = tcx.force_query::<::ty::query::queries::$query<'_>>(\n-                    $key, DUMMY_SP, *dep_node\n-                ) {\n-                    tcx.report_cycle(e).emit();\n-                }\n+                tcx.force_query::<::ty::query::queries::$query<'_>>($key, DUMMY_SP, *dep_node);\n             }\n         }\n     };"}, {"sha": "f8638213b3a2f7cbc456b53301531aa7975f2be2", "filename": "src/librustc_data_structures/fingerprint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc_data_structures%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc_data_structures%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffingerprint.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -86,6 +86,7 @@ impl ::std::fmt::Display for Fingerprint {\n }\n \n impl stable_hasher::StableHasherResult for Fingerprint {\n+    #[inline]\n     fn finish(hasher: stable_hasher::StableHasher<Self>) -> Self {\n         let (_0, _1) = hasher.finalize();\n         Fingerprint(_0, _1)"}, {"sha": "bc2b8f1d6523e20496a762c51243304cd513a61c", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -30,6 +30,8 @@\n #![feature(allow_internal_unstable)]\n #![feature(vec_resize_with)]\n #![feature(hash_raw_entry)]\n+#![feature(stmt_expr_attributes)]\n+#![feature(core_intrinsics)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]\n@@ -58,6 +60,26 @@ extern crate rustc_cratesio_shim;\n \n pub use rustc_serialize::hex::ToHex;\n \n+#[macro_export]\n+macro_rules! likely {\n+      ($e:expr) => {\n+            #[allow(unused_unsafe)]\n+            {\n+                  unsafe { std::intrinsics::likely($e) }\n+            }\n+      }\n+}\n+\n+#[macro_export]\n+macro_rules! unlikely {\n+    ($e:expr) => {\n+            #[allow(unused_unsafe)]\n+            {\n+                  unsafe { std::intrinsics::unlikely($e) }\n+            }\n+      }\n+}\n+\n pub mod macros;\n pub mod svh;\n pub mod base_n;"}, {"sha": "200b1cecc03d6a61fed2417393ef4496249a7b47", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790f4c566d9802dfcadc26398dde2051cfe6ec9f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=790f4c566d9802dfcadc26398dde2051cfe6ec9f", "patch": "@@ -81,6 +81,7 @@ impl ParseSess {\n         }\n     }\n \n+    #[inline]\n     pub fn source_map(&self) -> &SourceMap {\n         &self.source_map\n     }"}]}