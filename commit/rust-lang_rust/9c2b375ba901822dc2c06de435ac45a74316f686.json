{"sha": "9c2b375ba901822dc2c06de435ac45a74316f686", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMmIzNzViYTkwMTgyMmRjMmMwNmRlNDM1YWM0NWE3NDMxNmY2ODY=", "commit": {"author": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2019-09-24T00:25:19Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-09-24T00:25:19Z"}, "message": "refactor to use param naming where appropriate (#3803)", "tree": {"sha": "41f68ecd8604c83796543af242f60616e7b0deb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41f68ecd8604c83796543af242f60616e7b0deb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c2b375ba901822dc2c06de435ac45a74316f686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c2b375ba901822dc2c06de435ac45a74316f686", "html_url": "https://github.com/rust-lang/rust/commit/9c2b375ba901822dc2c06de435ac45a74316f686", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c2b375ba901822dc2c06de435ac45a74316f686/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bb266180e63b5995a2dc6bc85d2b8fa19f429ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bb266180e63b5995a2dc6bc85d2b8fa19f429ee", "html_url": "https://github.com/rust-lang/rust/commit/3bb266180e63b5995a2dc6bc85d2b8fa19f429ee"}], "stats": {"total": 197, "additions": 99, "deletions": 98}, "files": [{"sha": "c89ba4c5cdc253c0b76416d463a9fa8e0fac38fe", "filename": "src/closures.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9c2b375ba901822dc2c06de435ac45a74316f686/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c2b375ba901822dc2c06de435ac45a74316f686/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=9c2b375ba901822dc2c06de435ac45a74316f686", "patch": "@@ -4,7 +4,7 @@ use syntax::{ast, ptr};\n use crate::config::lists::*;\n use crate::config::Version;\n use crate::expr::{block_contains_comment, is_simple_block, is_unsafe_block, rewrite_cond};\n-use crate::items::{span_hi_for_arg, span_lo_for_arg};\n+use crate::items::{span_hi_for_param, span_lo_for_param};\n use crate::lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n use crate::overflow::OverflowableItem;\n use crate::rewrite::{Rewrite, RewriteContext};\n@@ -232,37 +232,37 @@ fn rewrite_closure_fn_decl(\n         .sub_width(4)?;\n \n     // 1 = |\n-    let argument_offset = nested_shape.indent + 1;\n-    let arg_shape = nested_shape.offset_left(1)?.visual_indent(0);\n-    let ret_str = fn_decl.output.rewrite(context, arg_shape)?;\n+    let param_offset = nested_shape.indent + 1;\n+    let param_shape = nested_shape.offset_left(1)?.visual_indent(0);\n+    let ret_str = fn_decl.output.rewrite(context, param_shape)?;\n \n-    let arg_items = itemize_list(\n+    let param_items = itemize_list(\n         context.snippet_provider,\n         fn_decl.inputs.iter(),\n         \"|\",\n         \",\",\n-        |arg| span_lo_for_arg(arg),\n-        |arg| span_hi_for_arg(context, arg),\n-        |arg| arg.rewrite(context, arg_shape),\n+        |param| span_lo_for_param(param),\n+        |param| span_hi_for_param(context, param),\n+        |param| param.rewrite(context, param_shape),\n         context.snippet_provider.span_after(span, \"|\"),\n         body.span.lo(),\n         false,\n     );\n-    let item_vec = arg_items.collect::<Vec<_>>();\n-    // 1 = space between arguments and return type.\n+    let item_vec = param_items.collect::<Vec<_>>();\n+    // 1 = space between parameters and return type.\n     let horizontal_budget = nested_shape.width.saturating_sub(ret_str.len() + 1);\n     let tactic = definitive_tactic(\n         &item_vec,\n         ListTactic::HorizontalVertical,\n         Separator::Comma,\n         horizontal_budget,\n     );\n-    let arg_shape = match tactic {\n-        DefinitiveListTactic::Horizontal => arg_shape.sub_width(ret_str.len() + 1)?,\n-        _ => arg_shape,\n+    let param_shape = match tactic {\n+        DefinitiveListTactic::Horizontal => param_shape.sub_width(ret_str.len() + 1)?,\n+        _ => param_shape,\n     };\n \n-    let fmt = ListFormatting::new(arg_shape, context.config)\n+    let fmt = ListFormatting::new(param_shape, context.config)\n         .tactic(tactic)\n         .preserve_newline(true);\n     let list_str = write_list(&item_vec, &fmt)?;\n@@ -271,7 +271,7 @@ fn rewrite_closure_fn_decl(\n     if !ret_str.is_empty() {\n         if prefix.contains('\\n') {\n             prefix.push('\\n');\n-            prefix.push_str(&argument_offset.to_string(context.config));\n+            prefix.push_str(&param_offset.to_string(context.config));\n         } else {\n             prefix.push(' ');\n         }"}, {"sha": "cdf9fa06eef21e8aa28d9b307e6710557cc5f9e5", "filename": "src/items.rs", "status": "modified", "additions": 83, "deletions": 82, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/9c2b375ba901822dc2c06de435ac45a74316f686/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c2b375ba901822dc2c06de435ac45a74316f686/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=9c2b375ba901822dc2c06de435ac45a74316f686", "patch": "@@ -1867,13 +1867,13 @@ fn is_empty_infer(ty: &ast::Ty, pat_span: Span) -> bool {\n     }\n }\n \n-/// Recover any missing comments between the argument and the type.\n+/// Recover any missing comments between the param and the type.\n ///\n /// # Returns\n ///\n /// A 2-len tuple with the comment before the colon in first position, and the comment after the\n /// colon in second position.\n-fn get_missing_arg_comments(\n+fn get_missing_param_comments(\n     context: &RewriteContext<'_>,\n     pat_span: Span,\n     ty_span: Span,\n@@ -1912,7 +1912,7 @@ impl Rewrite for ast::Param {\n             let num_attrs = self.attrs.len();\n             (\n                 mk_sp(self.attrs[num_attrs - 1].span.hi(), self.pat.span.lo()),\n-                param_attrs_result.matches(\"\\n\").count() > 0,\n+                param_attrs_result.contains(\"\\n\"),\n             )\n         } else {\n             (mk_sp(self.span.lo(), self.span.lo()), false)\n@@ -1927,7 +1927,7 @@ impl Rewrite for ast::Param {\n                 shape,\n                 has_multiple_attr_lines,\n             )\n-        } else if is_named_arg(self) {\n+        } else if is_named_param(self) {\n             let mut result = combine_strs_with_missing_comments(\n                 context,\n                 &param_attrs_result,\n@@ -1941,7 +1941,7 @@ impl Rewrite for ast::Param {\n \n             if !is_empty_infer(&*self.ty, self.pat.span) {\n                 let (before_comment, after_comment) =\n-                    get_missing_arg_comments(context, self.pat.span, self.ty.span, shape);\n+                    get_missing_param_comments(context, self.pat.span, self.ty.span, shape);\n                 result.push_str(&before_comment);\n                 result.push_str(colon_spaces(context.config));\n                 result.push_str(&after_comment);\n@@ -2022,28 +2022,28 @@ fn rewrite_explicit_self(\n     }\n }\n \n-pub(crate) fn span_lo_for_arg(arg: &ast::Param) -> BytePos {\n-    if arg.attrs.is_empty() {\n-        if is_named_arg(arg) {\n-            arg.pat.span.lo()\n+pub(crate) fn span_lo_for_param(param: &ast::Param) -> BytePos {\n+    if param.attrs.is_empty() {\n+        if is_named_param(param) {\n+            param.pat.span.lo()\n         } else {\n-            arg.ty.span.lo()\n+            param.ty.span.lo()\n         }\n     } else {\n-        arg.attrs[0].span.lo()\n+        param.attrs[0].span.lo()\n     }\n }\n \n-pub(crate) fn span_hi_for_arg(context: &RewriteContext<'_>, arg: &ast::Param) -> BytePos {\n-    match arg.ty.node {\n-        ast::TyKind::Infer if context.snippet(arg.ty.span) == \"_\" => arg.ty.span.hi(),\n-        ast::TyKind::Infer if is_named_arg(arg) => arg.pat.span.hi(),\n-        _ => arg.ty.span.hi(),\n+pub(crate) fn span_hi_for_param(context: &RewriteContext<'_>, param: &ast::Param) -> BytePos {\n+    match param.ty.node {\n+        ast::TyKind::Infer if context.snippet(param.ty.span) == \"_\" => param.ty.span.hi(),\n+        ast::TyKind::Infer if is_named_param(param) => param.pat.span.hi(),\n+        _ => param.ty.span.hi(),\n     }\n }\n \n-pub(crate) fn is_named_arg(arg: &ast::Param) -> bool {\n-    if let ast::PatKind::Ident(_, ident, _) = arg.pat.node {\n+pub(crate) fn is_named_param(param: &ast::Param) -> bool {\n+    if let ast::PatKind::Ident(_, ident, _) = param.pat.node {\n         ident.name != symbol::kw::Invalid\n     } else {\n         true\n@@ -2114,8 +2114,8 @@ fn rewrite_fn_base(\n     let multi_line_ret_str = ret_str.contains('\\n');\n     let ret_str_len = if multi_line_ret_str { 0 } else { ret_str.len() };\n \n-    // Args.\n-    let (one_line_budget, multi_line_budget, mut arg_indent) = compute_budgets_for_args(\n+    // Params.\n+    let (one_line_budget, multi_line_budget, mut param_indent) = compute_budgets_for_params(\n         context,\n         &result,\n         indent,\n@@ -2125,8 +2125,8 @@ fn rewrite_fn_base(\n     )?;\n \n     debug!(\n-        \"rewrite_fn_base: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n-        one_line_budget, multi_line_budget, arg_indent\n+        \"rewrite_fn_base: one_line_budget: {}, multi_line_budget: {}, param_indent: {:?}\",\n+        one_line_budget, multi_line_budget, param_indent\n     );\n \n     result.push('(');\n@@ -2135,79 +2135,79 @@ fn rewrite_fn_base(\n         && !snuggle_angle_bracket\n         && context.config.indent_style() == IndentStyle::Visual\n     {\n-        result.push_str(&arg_indent.to_string_with_newline(context.config));\n+        result.push_str(&param_indent.to_string_with_newline(context.config));\n     }\n \n     // Skip `pub(crate)`.\n     let lo_after_visibility = get_bytepos_after_visibility(&fn_sig.visibility, span);\n     // A conservative estimation, to goal is to be over all parens in generics\n-    let args_start = fn_sig\n+    let params_start = fn_sig\n         .generics\n         .params\n         .iter()\n         .last()\n         .map_or(lo_after_visibility, |param| param.span().hi());\n-    let args_end = if fd.inputs.is_empty() {\n+    let params_end = if fd.inputs.is_empty() {\n         context\n             .snippet_provider\n-            .span_after(mk_sp(args_start, span.hi()), \")\")\n+            .span_after(mk_sp(params_start, span.hi()), \")\")\n     } else {\n         let last_span = mk_sp(fd.inputs[fd.inputs.len() - 1].span().hi(), span.hi());\n         context.snippet_provider.span_after(last_span, \")\")\n     };\n-    let args_span = mk_sp(\n+    let params_span = mk_sp(\n         context\n             .snippet_provider\n-            .span_after(mk_sp(args_start, span.hi()), \"(\"),\n-        args_end,\n+            .span_after(mk_sp(params_start, span.hi()), \"(\"),\n+        params_end,\n     );\n-    let arg_str = rewrite_args(\n+    let param_str = rewrite_params(\n         context,\n         &fd.inputs,\n         one_line_budget,\n         multi_line_budget,\n         indent,\n-        arg_indent,\n-        args_span,\n+        param_indent,\n+        params_span,\n         fd.c_variadic,\n     )?;\n \n-    let put_args_in_block = match context.config.indent_style() {\n-        IndentStyle::Block => arg_str.contains('\\n') || arg_str.len() > one_line_budget,\n+    let put_params_in_block = match context.config.indent_style() {\n+        IndentStyle::Block => param_str.contains('\\n') || param_str.len() > one_line_budget,\n         _ => false,\n     } && !fd.inputs.is_empty();\n \n-    let mut args_last_line_contains_comment = false;\n-    let mut no_args_and_over_max_width = false;\n+    let mut params_last_line_contains_comment = false;\n+    let mut no_params_and_over_max_width = false;\n \n-    if put_args_in_block {\n-        arg_indent = indent.block_indent(context.config);\n-        result.push_str(&arg_indent.to_string_with_newline(context.config));\n-        result.push_str(&arg_str);\n+    if put_params_in_block {\n+        param_indent = indent.block_indent(context.config);\n+        result.push_str(&param_indent.to_string_with_newline(context.config));\n+        result.push_str(&param_str);\n         result.push_str(&indent.to_string_with_newline(context.config));\n         result.push(')');\n     } else {\n-        result.push_str(&arg_str);\n+        result.push_str(&param_str);\n         let used_width = last_line_used_width(&result, indent.width()) + first_line_width(&ret_str);\n         // Put the closing brace on the next line if it overflows the max width.\n         // 1 = `)`\n         let closing_paren_overflow_max_width =\n             fd.inputs.is_empty() && used_width + 1 > context.config.max_width();\n-        // If the last line of args contains comment, we cannot put the closing paren\n+        // If the last line of params contains comment, we cannot put the closing paren\n         // on the same line.\n-        args_last_line_contains_comment = arg_str\n+        params_last_line_contains_comment = param_str\n             .lines()\n             .last()\n             .map_or(false, |last_line| last_line.contains(\"//\"));\n \n         if context.config.version() == Version::Two {\n             result.push(')');\n-            if closing_paren_overflow_max_width || args_last_line_contains_comment {\n+            if closing_paren_overflow_max_width || params_last_line_contains_comment {\n                 result.push_str(&indent.to_string_with_newline(context.config));\n-                no_args_and_over_max_width = true;\n+                no_params_and_over_max_width = true;\n             }\n         } else {\n-            if closing_paren_overflow_max_width || args_last_line_contains_comment {\n+            if closing_paren_overflow_max_width || params_last_line_contains_comment {\n                 result.push_str(&indent.to_string_with_newline(context.config));\n             }\n             result.push(')');\n@@ -2217,14 +2217,14 @@ fn rewrite_fn_base(\n     // Return type.\n     if let ast::FunctionRetTy::Ty(..) = fd.output {\n         let ret_should_indent = match context.config.indent_style() {\n-            // If our args are block layout then we surely must have space.\n-            IndentStyle::Block if put_args_in_block || fd.inputs.is_empty() => false,\n-            _ if args_last_line_contains_comment => false,\n+            // If our params are block layout then we surely must have space.\n+            IndentStyle::Block if put_params_in_block || fd.inputs.is_empty() => false,\n+            _ if params_last_line_contains_comment => false,\n             _ if result.contains('\\n') || multi_line_ret_str => true,\n             _ => {\n                 // If the return type would push over the max width, then put the return type on\n                 // a new line. With the +1 for the signature length an additional space between\n-                // the closing parenthesis of the argument and the arrow '->' is considered.\n+                // the closing parenthesis of the param and the arrow '->' is considered.\n                 let mut sig_length = result.len() + indent.width() + ret_str_len + 1;\n \n                 // If there is no where-clause, take into account the space after the return type\n@@ -2240,23 +2240,23 @@ fn rewrite_fn_base(\n             if context.config.version() == Version::One\n                 || context.config.indent_style() == IndentStyle::Visual\n             {\n-                let indent = if arg_str.is_empty() {\n-                    // Aligning with non-existent args looks silly.\n+                let indent = if param_str.is_empty() {\n+                    // Aligning with non-existent params looks silly.\n                     force_new_line_for_brace = true;\n                     indent + 4\n                 } else {\n-                    // FIXME: we might want to check that using the arg indent\n+                    // FIXME: we might want to check that using the param indent\n                     // doesn't blow our budget, and if it does, then fallback to\n                     // the where-clause indent.\n-                    arg_indent\n+                    param_indent\n                 };\n \n                 result.push_str(&indent.to_string_with_newline(context.config));\n                 Shape::indented(indent, context.config)\n             } else {\n                 let mut ret_shape = Shape::indented(indent, context.config);\n-                if arg_str.is_empty() {\n-                    // Aligning with non-existent args looks silly.\n+                if param_str.is_empty() {\n+                    // Aligning with non-existent params looks silly.\n                     force_new_line_for_brace = true;\n                     ret_shape = if context.use_block_indent() {\n                         ret_shape.offset_left(4).unwrap_or(ret_shape)\n@@ -2271,7 +2271,7 @@ fn rewrite_fn_base(\n             }\n         } else {\n             if context.config.version() == Version::Two {\n-                if !arg_str.is_empty() || !no_args_and_over_max_width {\n+                if !param_str.is_empty() || !no_params_and_over_max_width {\n                     result.push(' ');\n                 }\n             } else {\n@@ -2321,19 +2321,19 @@ fn rewrite_fn_base(\n     }\n \n     let pos_before_where = match fd.output {\n-        ast::FunctionRetTy::Default(..) => args_span.hi(),\n+        ast::FunctionRetTy::Default(..) => params_span.hi(),\n         ast::FunctionRetTy::Ty(ref ty) => ty.span.hi(),\n     };\n \n-    let is_args_multi_lined = arg_str.contains('\\n');\n+    let is_params_multi_lined = param_str.contains('\\n');\n \n-    let space = if put_args_in_block && ret_str.is_empty() {\n+    let space = if put_params_in_block && ret_str.is_empty() {\n         WhereClauseSpace::Space\n     } else {\n         WhereClauseSpace::Newline\n     };\n     let mut option = WhereClauseOption::new(fn_brace_style == FnBraceStyle::None, space);\n-    if is_args_multi_lined {\n+    if is_params_multi_lined {\n         option.veto_single_line();\n     }\n     let where_clause_str = rewrite_where_clause(\n@@ -2348,11 +2348,11 @@ fn rewrite_fn_base(\n         option,\n     )?;\n     // If there are neither where-clause nor return type, we may be missing comments between\n-    // args and `{`.\n+    // params and `{`.\n     if where_clause_str.is_empty() {\n         if let ast::FunctionRetTy::Default(ret_span) = fd.output {\n             match recover_missing_comment_in_span(\n-                mk_sp(args_span.hi(), ret_span.hi()),\n+                mk_sp(params_span.hi(), ret_span.hi()),\n                 shape,\n                 context,\n                 last_line_width(&result),\n@@ -2369,7 +2369,7 @@ fn rewrite_fn_base(\n     result.push_str(&where_clause_str);\n \n     force_new_line_for_brace |= last_line_contains_single_line_comment(&result);\n-    force_new_line_for_brace |= is_args_multi_lined && context.config.where_single_line();\n+    force_new_line_for_brace |= is_params_multi_lined && context.config.where_single_line();\n     Some((result, force_new_line_for_brace))\n }\n \n@@ -2432,17 +2432,17 @@ impl WhereClauseOption {\n     }\n }\n \n-fn rewrite_args(\n+fn rewrite_params(\n     context: &RewriteContext<'_>,\n-    args: &[ast::Param],\n+    params: &[ast::Param],\n     one_line_budget: usize,\n     multi_line_budget: usize,\n     indent: Indent,\n-    arg_indent: Indent,\n+    param_indent: Indent,\n     span: Span,\n     variadic: bool,\n ) -> Option<String> {\n-    if args.is_empty() {\n+    if params.is_empty() {\n         let comment = context\n             .snippet(mk_sp(\n                 span.lo(),\n@@ -2452,16 +2452,17 @@ fn rewrite_args(\n             .trim();\n         return Some(comment.to_owned());\n     }\n-    let arg_items: Vec<_> = itemize_list(\n+    let param_items: Vec<_> = itemize_list(\n         context.snippet_provider,\n-        args.iter(),\n+        params.iter(),\n         \")\",\n         \",\",\n-        |arg| span_lo_for_arg(arg),\n-        |arg| arg.ty.span.hi(),\n-        |arg| {\n-            arg.rewrite(context, Shape::legacy(multi_line_budget, arg_indent))\n-                .or_else(|| Some(context.snippet(arg.span()).to_owned()))\n+        |param| span_lo_for_param(param),\n+        |param| param.ty.span.hi(),\n+        |param| {\n+            param\n+                .rewrite(context, Shape::legacy(multi_line_budget, param_indent))\n+                .or_else(|| Some(context.snippet(param.span()).to_owned()))\n         },\n         span.lo(),\n         span.hi(),\n@@ -2470,11 +2471,11 @@ fn rewrite_args(\n     .collect();\n \n     let tactic = definitive_tactic(\n-        &arg_items,\n+        &param_items,\n         context\n             .config\n             .fn_args_layout()\n-            .to_list_tactic(arg_items.len()),\n+            .to_list_tactic(param_items.len()),\n         Separator::Comma,\n         one_line_budget,\n     );\n@@ -2484,7 +2485,7 @@ fn rewrite_args(\n     };\n     let indent = match context.config.indent_style() {\n         IndentStyle::Block => indent.block_indent(context.config),\n-        IndentStyle::Visual => arg_indent,\n+        IndentStyle::Visual => param_indent,\n     };\n     let trailing_separator = if variadic {\n         SeparatorTactic::Never\n@@ -2499,10 +2500,10 @@ fn rewrite_args(\n         .trailing_separator(trailing_separator)\n         .ends_with_newline(tactic.ends_with_newline(context.config.indent_style()))\n         .preserve_newline(true);\n-    write_list(&arg_items, &fmt)\n+    write_list(&param_items, &fmt)\n }\n \n-fn compute_budgets_for_args(\n+fn compute_budgets_for_params(\n     context: &RewriteContext<'_>,\n     result: &str,\n     indent: Indent,\n@@ -2511,7 +2512,7 @@ fn compute_budgets_for_args(\n     force_vertical_layout: bool,\n ) -> Option<((usize, usize, Indent))> {\n     debug!(\n-        \"compute_budgets_for_args {} {:?}, {}, {:?}\",\n+        \"compute_budgets_for_params {} {:?}, {}, {:?}\",\n         result.len(),\n         indent,\n         ret_str_len,\n@@ -2550,7 +2551,7 @@ fn compute_budgets_for_args(\n         }\n     }\n \n-    // Didn't work. we must force vertical layout and put args on a newline.\n+    // Didn't work. we must force vertical layout and put params on a newline.\n     let new_indent = indent.block_indent(context.config);\n     let used_space = match context.config.indent_style() {\n         // 1 = `,`"}, {"sha": "de02b79550ffa4bfc525fb21d5a11838d95cefe8", "filename": "src/spanned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c2b375ba901822dc2c06de435ac45a74316f686/src%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c2b375ba901822dc2c06de435ac45a74316f686/src%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fspanned.rs?ref=9c2b375ba901822dc2c06de435ac45a74316f686", "patch": "@@ -106,7 +106,7 @@ impl Spanned for ast::Arm {\n \n impl Spanned for ast::Param {\n     fn span(&self) -> Span {\n-        if crate::items::is_named_arg(self) {\n+        if crate::items::is_named_param(self) {\n             mk_sp(self.pat.span.lo(), self.ty.span.hi())\n         } else {\n             self.ty.span"}]}