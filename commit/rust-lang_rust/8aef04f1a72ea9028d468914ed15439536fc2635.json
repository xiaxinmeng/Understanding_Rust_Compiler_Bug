{"sha": "8aef04f1a72ea9028d468914ed15439536fc2635", "node_id": "C_kwDOAAsO6NoAKDhhZWYwNGYxYTcyZWE5MDI4ZDQ2ODkxNGVkMTU0Mzk1MzZmYzI2MzU", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-03-29T12:44:23Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-03-29T14:32:37Z"}, "message": "Resolve and normalize path segments one by one in variant resolution", "tree": {"sha": "eda5e186ab668b6d459e4a3541fee8a06195ac34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eda5e186ab668b6d459e4a3541fee8a06195ac34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8aef04f1a72ea9028d468914ed15439536fc2635", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmQkTAUACgkQ4laYqTBY\nYXGpyg/+IhRm3TnVhq636OAmFvR++hEdn4bFXJ4mpz8hO4z7oxaj2Jzrn4WCK/Tt\n7y27vvw+q0bPbTiliWebQQJNKcfuwDk9vvltFIDxAyOjrjoY39EevUUQclYtj8eq\nGdsBU3GW6/PJMLUkydd3klGmBwe0zDheA+fn+ygAv4f/1PWduxyDsZER1ALQ0Sez\nSywUZ3O1VllSXekJ9LA4AQFhRrcbvrW3eW3dflnneZfDvcMC/gh85gTizWejtfa6\ntNVvmTAN5uDQo+D/mmuVaA3qSRB+NGyrsAF/5DSygHa7sspYNnBpvGzUBdU1aQaW\nTBcJmeArVQ8m1NO4+fq8QGZOuDMEzWdI5HomeBK/3a81220IkrTgczuTVIbtajVX\nZdt8wmTPhUH0pFjL2/I8nMSZJq7dhv/5x4wmuziH5v2opeQhFHsvcMcUz5c4IQsv\nVfO9SEsx9KsoMltCQLXDw7OUezFjp86TYh/apBIHcb/2CVN1i6Pr6Q7JRDoZ6Zz2\ngaQDUBDr/HaILD9alDdsCWZfl7eONQKjFq3HuQB7iDb400MEqI/DNx3GNe9yQreP\nqfEb7EkZXCu7UG8MD88NQk4ouTseThLRBwwGzC4h5wONWAGaBmZzBdFuBSnKrJoj\n47hH1VvjR+t+1psHEu8FnTyKgPDshXFSiHFrUbF1+EFcZWVYX30=\n=B/0A\n-----END PGP SIGNATURE-----", "payload": "tree eda5e186ab668b6d459e4a3541fee8a06195ac34\nparent 7a98e24777d127c8d3cdb322aa7e9ea4f4dba5e3\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1680093863 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1680100357 +0900\n\nResolve and normalize path segments one by one in variant resolution\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8aef04f1a72ea9028d468914ed15439536fc2635", "html_url": "https://github.com/rust-lang/rust/commit/8aef04f1a72ea9028d468914ed15439536fc2635", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8aef04f1a72ea9028d468914ed15439536fc2635/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a98e24777d127c8d3cdb322aa7e9ea4f4dba5e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a98e24777d127c8d3cdb322aa7e9ea4f4dba5e3", "html_url": "https://github.com/rust-lang/rust/commit/7a98e24777d127c8d3cdb322aa7e9ea4f4dba5e3"}], "stats": {"total": 244, "additions": 198, "deletions": 46}, "files": [{"sha": "9afe07932ecc6b2cb3c25ea7fa823e3ff564cdd8", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8aef04f1a72ea9028d468914ed15439536fc2635/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aef04f1a72ea9028d468914ed15439536fc2635/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=8aef04f1a72ea9028d468914ed15439536fc2635", "patch": "@@ -79,7 +79,7 @@ enum Scope {\n     ExprScope(ExprScope),\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum TypeNs {\n     SelfType(ImplId),\n     GenericParam(TypeParamId),"}, {"sha": "e027868f14690dcdbdc38ee6355a8b31fa267953", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 69, "deletions": 41, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8aef04f1a72ea9028d468914ed15439536fc2635/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aef04f1a72ea9028d468914ed15439536fc2635/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=8aef04f1a72ea9028d468914ed15439536fc2635", "patch": "@@ -16,7 +16,7 @@\n use std::ops::Index;\n use std::sync::Arc;\n \n-use chalk_ir::{cast::Cast, ConstValue, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n+use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use either::Either;\n use hir_def::{\n     body::Body,\n@@ -37,10 +37,10 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::{always, never};\n \n use crate::{\n-    db::HirDatabase, fold_tys, fold_tys_and_consts, infer::coerce::CoerceMany,\n-    lower::ImplTraitLoweringMode, static_lifetime, to_assoc_type_id, AliasEq, AliasTy, Const,\n-    DomainGoal, GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId,\n-    Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    db::HirDatabase, fold_tys, infer::coerce::CoerceMany, lower::ImplTraitLoweringMode,\n+    static_lifetime, to_assoc_type_id, AliasEq, AliasTy, DomainGoal, GenericArg, Goal, ImplTraitId,\n+    InEnvironment, Interner, ProjectionTy, RpitId, Substitution, TraitRef, Ty, TyBuilder, TyExt,\n+    TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -744,43 +744,13 @@ impl<'a> InferenceContext<'a> {\n         self.result.standard_types.unknown.clone()\n     }\n \n-    /// Replaces ConstScalar::Unknown by a new type var, so we can maybe still infer it.\n-    fn insert_const_vars_shallow(&mut self, c: Const) -> Const {\n-        let data = c.data(Interner);\n-        match &data.value {\n-            ConstValue::Concrete(cc) => match cc.interned {\n-                crate::ConstScalar::Unknown => self.table.new_const_var(data.ty.clone()),\n-                _ => c,\n-            },\n-            _ => c,\n-        }\n-    }\n-\n     /// Replaces `Ty::Error` by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n-        match ty.kind(Interner) {\n-            TyKind::Error => self.table.new_type_var(),\n-            TyKind::InferenceVar(..) => {\n-                let ty_resolved = self.resolve_ty_shallow(&ty);\n-                if ty_resolved.is_unknown() {\n-                    self.table.new_type_var()\n-                } else {\n-                    ty\n-                }\n-            }\n-            _ => ty,\n-        }\n+        self.table.insert_type_vars_shallow(ty)\n     }\n \n     fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n-        fold_tys_and_consts(\n-            ty,\n-            |x, _| match x {\n-                Either::Left(ty) => Either::Left(self.insert_type_vars_shallow(ty)),\n-                Either::Right(c) => Either::Right(self.insert_const_vars_shallow(c)),\n-            },\n-            DebruijnIndex::INNERMOST,\n-        )\n+        self.table.insert_type_vars(ty)\n     }\n \n     fn push_obligation(&mut self, o: DomainGoal) {\n@@ -850,8 +820,6 @@ impl<'a> InferenceContext<'a> {\n             None => return (self.err_ty(), None),\n         };\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n-        // FIXME: this should resolve assoc items as well, see this example:\n-        // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n         let (resolution, unresolved) = if value_ns {\n             match self.resolver.resolve_path_in_value_ns(self.db.upcast(), path) {\n                 Some(ResolveValueResult::ValueNs(value)) => match value {\n@@ -905,8 +873,68 @@ impl<'a> InferenceContext<'a> {\n             TypeNs::SelfType(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = generics.placeholder_subst(self.db);\n-                let ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n-                self.resolve_variant_on_alias(ty, unresolved, mod_path)\n+                let mut ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n+\n+                let Some(mut remaining_idx) = unresolved else {\n+                    return self.resolve_variant_on_alias(ty, None, mod_path);\n+                };\n+\n+                let mut remaining_segments = path.segments().skip(remaining_idx);\n+\n+                // We need to try resolving unresolved segments one by one because each may resolve\n+                // to a projection, which `TyLoweringContext` cannot handle on its own.\n+                while !remaining_segments.is_empty() {\n+                    let resolved_segment = path.segments().get(remaining_idx - 1).unwrap();\n+                    let current_segment = remaining_segments.take(1);\n+\n+                    // If we can resolve to an enum variant, it takes priority over associated type\n+                    // of the same name.\n+                    if let Some((AdtId::EnumId(id), _)) = ty.as_adt() {\n+                        let enum_data = self.db.enum_data(id);\n+                        let name = current_segment.first().unwrap().name;\n+                        if let Some(local_id) = enum_data.variant(name) {\n+                            let variant = EnumVariantId { parent: id, local_id };\n+                            return if remaining_segments.len() == 1 {\n+                                (ty, Some(variant.into()))\n+                            } else {\n+                                // We still have unresolved paths, but enum variants never have\n+                                // associated types!\n+                                (self.err_ty(), None)\n+                            };\n+                        }\n+                    }\n+\n+                    // `lower_partly_resolved_path()` returns `None` as type namespace unless\n+                    // `remaining_segments` is empty, which is never the case here. We don't know\n+                    // which namespace the new `ty` is in until normalized anyway.\n+                    (ty, _) = ctx.lower_partly_resolved_path(\n+                        resolution,\n+                        resolved_segment,\n+                        current_segment,\n+                        false,\n+                    );\n+\n+                    ty = self.table.insert_type_vars(ty);\n+                    ty = self.table.normalize_associated_types_in(ty);\n+                    ty = self.table.resolve_ty_shallow(&ty);\n+                    if ty.is_unknown() {\n+                        return (self.err_ty(), None);\n+                    }\n+\n+                    // FIXME(inherent_associated_types): update `resolution` based on `ty` here.\n+                    remaining_idx += 1;\n+                    remaining_segments = remaining_segments.skip(1);\n+                }\n+\n+                let variant = ty.as_adt().and_then(|(id, _)| match id {\n+                    AdtId::StructId(s) => Some(VariantId::StructId(s)),\n+                    AdtId::UnionId(u) => Some(VariantId::UnionId(u)),\n+                    AdtId::EnumId(_) => {\n+                        // FIXME Error E0071, expected struct, variant or union type, found enum `Foo`\n+                        None\n+                    }\n+                });\n+                (ty, variant)\n             }\n             TypeNs::TypeAliasId(it) => {\n                 let container = it.lookup(self.db.upcast()).container;"}, {"sha": "c73acb4b12ed8a03f926a3f819a4f8873d819ef6", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8aef04f1a72ea9028d468914ed15439536fc2635/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aef04f1a72ea9028d468914ed15439536fc2635/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=8aef04f1a72ea9028d468914ed15439536fc2635", "patch": "@@ -7,16 +7,18 @@ use chalk_ir::{\n     IntTy, TyVariableKind, UniverseIndex,\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n+use either::Either;\n use ena::unify::UnifyKey;\n use hir_expand::name;\n use stdx::never;\n \n use super::{InferOk, InferResult, InferenceContext, TypeError};\n use crate::{\n-    db::HirDatabase, fold_tys, static_lifetime, to_chalk_trait_id, traits::FnTrait, AliasEq,\n-    AliasTy, BoundVar, Canonical, Const, DebruijnIndex, GenericArg, GenericArgData, Goal, Guidance,\n-    InEnvironment, InferenceVar, Interner, Lifetime, ParamKind, ProjectionTy, ProjectionTyExt,\n-    Scalar, Solution, Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind, VariableKind,\n+    db::HirDatabase, fold_tys, fold_tys_and_consts, static_lifetime, to_chalk_trait_id,\n+    traits::FnTrait, AliasEq, AliasTy, BoundVar, Canonical, Const, ConstValue, DebruijnIndex,\n+    GenericArg, GenericArgData, Goal, Guidance, InEnvironment, InferenceVar, Interner, Lifetime,\n+    ParamKind, ProjectionTy, ProjectionTyExt, Scalar, Solution, Substitution, TraitEnvironment, Ty,\n+    TyBuilder, TyExt, TyKind, VariableKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -717,6 +719,45 @@ impl<'a> InferenceTable<'a> {\n             None\n         }\n     }\n+\n+    pub(super) fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n+        fold_tys_and_consts(\n+            ty,\n+            |x, _| match x {\n+                Either::Left(ty) => Either::Left(self.insert_type_vars_shallow(ty)),\n+                Either::Right(c) => Either::Right(self.insert_const_vars_shallow(c)),\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n+    }\n+\n+    /// Replaces `Ty::Error` by a new type var, so we can maybe still infer it.\n+    pub(super) fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n+        match ty.kind(Interner) {\n+            TyKind::Error => self.new_type_var(),\n+            TyKind::InferenceVar(..) => {\n+                let ty_resolved = self.resolve_ty_shallow(&ty);\n+                if ty_resolved.is_unknown() {\n+                    self.new_type_var()\n+                } else {\n+                    ty\n+                }\n+            }\n+            _ => ty,\n+        }\n+    }\n+\n+    /// Replaces ConstScalar::Unknown by a new type var, so we can maybe still infer it.\n+    pub(super) fn insert_const_vars_shallow(&mut self, c: Const) -> Const {\n+        let data = c.data(Interner);\n+        match &data.value {\n+            ConstValue::Concrete(cc) => match cc.interned {\n+                crate::ConstScalar::Unknown => self.new_const_var(data.ty.clone()),\n+                _ => c,\n+            },\n+            _ => c,\n+        }\n+    }\n }\n \n impl<'a> fmt::Debug for InferenceTable<'a> {"}, {"sha": "7e6092f5b6c10c05a8f5541c3b54b8986f837e54", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8aef04f1a72ea9028d468914ed15439536fc2635/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aef04f1a72ea9028d468914ed15439536fc2635/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=8aef04f1a72ea9028d468914ed15439536fc2635", "patch": "@@ -4181,3 +4181,86 @@ fn test() {\n \"#,\n     );\n }\n+\n+#[test]\n+fn associated_type_in_struct_expr_path() {\n+    // FIXME: All annotation should be resolvable.\n+    // For lines marked as unstable, see rust-lang/rust#86935.\n+    // FIXME: Remove the comments once stablized.\n+    check_types(\n+        r#\"\n+trait Trait {\n+    type Assoc;\n+    fn f();\n+}\n+\n+struct S { x: u32 }\n+\n+impl Trait for () {\n+    type Assoc = S;\n+\n+    fn f() {\n+        let x = 42;\n+        let a = Self::Assoc { x };\n+      //    ^ S\n+        let a = <Self>::Assoc { x }; // unstable\n+      //    ^ {unknown}\n+\n+        // should be `Copy` but we don't track ownership anyway.\n+        let value = S { x };\n+        if let Self::Assoc { x } = value {}\n+      //                     ^ u32\n+        if let <Self>::Assoc { x } = value {} // unstable\n+      //                       ^ {unknown}\n+    }\n+}\n+    \"#,\n+    );\n+}\n+\n+#[test]\n+fn associted_type_in_struct_expr_path_enum() {\n+    // FIXME: All annotation should be resolvable.\n+    // For lines marked as unstable, see rust-lang/rust#86935.\n+    // FIXME: Remove the comments once stablized.\n+    check_types(\n+        r#\"\n+trait Trait {\n+    type Assoc;\n+    fn f();\n+}\n+\n+enum E {\n+    Unit,\n+    Struct { x: u32 },\n+}\n+\n+impl Trait for () {\n+    type Assoc = E;\n+\n+    fn f() {\n+        let x = 42;\n+        let a = Self::Assoc::Struct { x };\n+      //    ^ E\n+        let a = <Self>::Assoc::Struct { x }; // unstable\n+      //    ^ {unknown}\n+        let a = <Self::Assoc>::Struct { x }; // unstable\n+      //    ^ {unknown}\n+        let a = <<Self>::Assoc>::Struct { x }; // unstable\n+      //    ^ {unknown}\n+\n+        // should be `Copy` but we don't track ownership anyway.\n+        let value = E::Struct { x: 42 };\n+        if let Self::Assoc::Struct { x } = value {}\n+      //                             ^ u32\n+        if let <Self>::Assoc::Struct { x } = value {} // unstable\n+      //                               ^ {unknown}\n+        if let <Self::Assoc>::Struct { x } = value {} // unstable\n+      //                               ^ {unknown}\n+        if let <<Self>::Assoc>::Struct { x } = value {} // unstable\n+      //                                 ^ {unknown}\n+    }\n+}\n+    \"#,\n+    );\n+}"}]}