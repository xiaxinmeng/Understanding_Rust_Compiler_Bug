{"sha": "173bb10a7698a84faa2e346dc78c8649751942c9", "node_id": "C_kwDOAAsO6NoAKDE3M2JiMTBhNzY5OGE4NGZhYTJlMzQ2ZGM3OGM4NjQ5NzUxOTQyYzk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-17T22:47:28Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-17T22:47:28Z"}, "message": "internal: Split flyimport into its 3 applicable contexts", "tree": {"sha": "41a855f4121b0b8bb92e932c65055864de069bd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41a855f4121b0b8bb92e932c65055864de069bd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/173bb10a7698a84faa2e346dc78c8649751942c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/173bb10a7698a84faa2e346dc78c8649751942c9", "html_url": "https://github.com/rust-lang/rust/commit/173bb10a7698a84faa2e346dc78c8649751942c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/173bb10a7698a84faa2e346dc78c8649751942c9/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00fdb4a3d8f934fd57f0a659d39db72e0dfb47eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/00fdb4a3d8f934fd57f0a659d39db72e0dfb47eb", "html_url": "https://github.com/rust-lang/rust/commit/00fdb4a3d8f934fd57f0a659d39db72e0dfb47eb"}], "stats": {"total": 299, "additions": 169, "deletions": 130}, "files": [{"sha": "15e431f9c50a95d92127d48899e165e32fb53988", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 120, "deletions": 67, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=173bb10a7698a84faa2e346dc78c8649751942c9", "patch": "@@ -1,16 +1,16 @@\n //! See [`import_on_the_fly`].\n use hir::{ItemInNs, ModuleDef};\n use ide_db::imports::{\n-    import_assets::{ImportAssets, ImportCandidate, LocatedImport},\n+    import_assets::{ImportAssets, LocatedImport},\n     insert_use::ImportScope,\n };\n use itertools::Itertools;\n-use syntax::{AstNode, SyntaxNode, T};\n+use syntax::{ast, AstNode, SyntaxNode, T};\n \n use crate::{\n     context::{\n-        CompletionContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind,\n-        PatternContext, TypeLocation,\n+        CompletionContext, DotAccess, PathCompletionCtx, PathKind, PatternContext, Qualified,\n+        TypeLocation,\n     },\n     render::{render_resolution_with_import, RenderContext},\n };\n@@ -108,45 +108,108 @@ use super::Completions;\n // The feature can be forcefully turned off in the settings with the `rust-analyzer.completion.autoimport.enable` flag.\n // Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corresponding\n // capability enabled.\n-pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+pub(crate) fn import_on_the_fly_path(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    path_ctx: &PathCompletionCtx,\n+) -> Option<()> {\n     if !ctx.config.enable_imports_on_the_fly {\n         return None;\n     }\n-    let path_kind = match ctx.nameref_ctx() {\n-        Some(NameRefContext {\n+    let (kind, qualified) = match path_ctx {\n+        PathCompletionCtx {\n             kind:\n-                Some(NameRefKind::Path(PathCompletionCtx {\n-                    kind:\n-                        kind @ (PathKind::Expr { .. }\n-                        | PathKind::Type { .. }\n-                        | PathKind::Attr { .. }\n-                        | PathKind::Derive { .. }\n-                        | PathKind::Pat),\n-                    ..\n-                })),\n+                kind @ (PathKind::Expr { .. }\n+                | PathKind::Type { .. }\n+                | PathKind::Attr { .. }\n+                | PathKind::Derive { .. }\n+                | PathKind::Pat),\n+            qualified,\n             ..\n-        }) => Some(kind),\n-        Some(NameRefContext { kind: Some(NameRefKind::DotAccess(_)), .. }) => None,\n-        None if matches!(ctx.pattern_ctx, Some(PatternContext { record_pat: None, .. })) => {\n-            Some(&PathKind::Pat)\n-        }\n+        } => (Some(kind), qualified),\n         _ => return None,\n     };\n+    let potential_import_name = import_name(ctx);\n+    let qualifier = match qualified {\n+        Qualified::With { path, .. } => Some(path.clone()),\n+        _ => None,\n+    };\n+    let import_assets = import_assets_for_path(ctx, &potential_import_name, qualifier.clone())?;\n \n-    let potential_import_name = {\n-        let token_kind = ctx.token.kind();\n-        if matches!(token_kind, T![.] | T![::]) {\n-            String::new()\n-        } else {\n-            ctx.token.to_string()\n-        }\n+    import_on_the_fly(\n+        acc,\n+        ctx,\n+        kind,\n+        import_assets,\n+        qualifier.map(|it| it.syntax().clone()).or_else(|| ctx.original_token.parent())?,\n+        potential_import_name,\n+    )\n+}\n+\n+pub(crate) fn import_on_the_fly_dot(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    dot_access: &DotAccess,\n+) -> Option<()> {\n+    if !ctx.config.enable_imports_on_the_fly {\n+        return None;\n+    }\n+    let receiver = dot_access.receiver.as_ref()?;\n+    let ty = dot_access.receiver_ty.as_ref()?;\n+    let potential_import_name = import_name(ctx);\n+    let import_assets = ImportAssets::for_fuzzy_method_call(\n+        ctx.module,\n+        ty.original.clone(),\n+        potential_import_name.clone(),\n+        receiver.syntax().clone(),\n+    )?;\n+\n+    import_on_the_fly(\n+        acc,\n+        ctx,\n+        None,\n+        import_assets,\n+        receiver.syntax().clone(),\n+        potential_import_name,\n+    )\n+}\n+\n+pub(crate) fn import_on_the_fly_pat(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    pat_ctx: &PatternContext,\n+) -> Option<()> {\n+    if !ctx.config.enable_imports_on_the_fly {\n+        return None;\n+    }\n+    let kind = match pat_ctx {\n+        PatternContext { record_pat: None, .. } => PathKind::Pat,\n+        _ => return None,\n     };\n \n+    let potential_import_name = import_name(ctx);\n+    let import_assets = import_assets_for_path(ctx, &potential_import_name, None)?;\n+\n+    import_on_the_fly(\n+        acc,\n+        ctx,\n+        Some(&kind),\n+        import_assets,\n+        ctx.original_token.parent()?,\n+        potential_import_name,\n+    )\n+}\n+\n+fn import_on_the_fly(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    path_kind: Option<&PathKind>,\n+    import_assets: ImportAssets,\n+    position: SyntaxNode,\n+    potential_import_name: String,\n+) -> Option<()> {\n     let _p = profile::span(\"import_on_the_fly\").detail(|| potential_import_name.clone());\n \n-    let user_input_lowercased = potential_import_name.to_lowercase();\n-    let import_assets = import_assets(ctx, potential_import_name)?;\n-    let position = position_for_import(ctx, Some(import_assets.import_candidate()))?;\n     if ImportScope::find_insert_use_container(&position, &ctx.sema).is_none() {\n         return None;\n     }\n@@ -194,6 +257,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n             (PathKind::Derive { .. }, _) => false,\n         }\n     };\n+    let user_input_lowercased = potential_import_name.to_lowercase();\n \n     acc.add_all(\n         import_assets\n@@ -216,47 +280,36 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n     Some(())\n }\n \n-pub(crate) fn position_for_import(\n-    ctx: &CompletionContext,\n-    import_candidate: Option<&ImportCandidate>,\n-) -> Option<SyntaxNode> {\n-    Some(\n-        match import_candidate {\n-            Some(ImportCandidate::TraitAssocItem(_)) => ctx.path_qual()?.syntax(),\n-            Some(ImportCandidate::TraitMethod(_)) => ctx.dot_receiver()?.syntax(),\n-            Some(ImportCandidate::Path(_)) | None => return ctx.original_token.parent(),\n-        }\n-        .clone(),\n-    )\n+fn import_name(ctx: &CompletionContext) -> String {\n+    let token_kind = ctx.token.kind();\n+    if matches!(token_kind, T![.] | T![::]) {\n+        String::new()\n+    } else {\n+        ctx.token.to_string()\n+    }\n }\n \n-fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAssets> {\n-    let current_module = ctx.module;\n-    if let Some(dot_receiver) = ctx.dot_receiver() {\n-        ImportAssets::for_fuzzy_method_call(\n-            current_module,\n-            ctx.sema.type_of_expr(dot_receiver)?.original,\n-            fuzzy_name,\n-            dot_receiver.syntax().clone(),\n-        )\n-    } else {\n-        let fuzzy_name_length = fuzzy_name.len();\n-        let mut assets_for_path = ImportAssets::for_fuzzy_path(\n-            current_module,\n-            ctx.path_qual().cloned(),\n-            fuzzy_name,\n-            &ctx.sema,\n-            ctx.token.parent()?,\n-        )?;\n-        if fuzzy_name_length < 3 {\n-            cov_mark::hit!(flyimport_exact_on_short_path);\n-            assets_for_path.path_fuzzy_name_to_exact(false);\n-        }\n-        Some(assets_for_path)\n+fn import_assets_for_path(\n+    ctx: &CompletionContext,\n+    potential_import_name: &str,\n+    qualifier: Option<ast::Path>,\n+) -> Option<ImportAssets> {\n+    let fuzzy_name_length = potential_import_name.len();\n+    let mut assets_for_path = ImportAssets::for_fuzzy_path(\n+        ctx.module,\n+        qualifier,\n+        potential_import_name.to_owned(),\n+        &ctx.sema,\n+        ctx.token.parent()?,\n+    )?;\n+    if fuzzy_name_length < 3 {\n+        cov_mark::hit!(flyimport_exact_on_short_path);\n+        assets_for_path.path_fuzzy_name_to_exact(false);\n     }\n+    Some(assets_for_path)\n }\n \n-pub(crate) fn compute_fuzzy_completion_order_key(\n+fn compute_fuzzy_completion_order_key(\n     proposed_mod_path: &hir::ModPath,\n     user_input_lowercased: &str,\n ) -> usize {"}, {"sha": "5c408c0cc0594a95dc0db2b872948471d2c20c2e", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=173bb10a7698a84faa2e346dc78c8649751942c9", "patch": "@@ -328,8 +328,8 @@ pub(crate) struct CompletionContext<'a> {\n     // FIXME: This shouldn't exist\n     pub(super) previous_token: Option<SyntaxToken>,\n \n+    // We might wanna split these out of CompletionContext\n     pub(super) ident_ctx: IdentContext,\n-\n     pub(super) pattern_ctx: Option<PatternContext>,\n     pub(super) qualifier_ctx: QualifierCtx,\n \n@@ -362,41 +362,6 @@ impl<'a> CompletionContext<'a> {\n         FamousDefs(&self.sema, self.krate)\n     }\n \n-    // FIXME: This shouldn't exist\n-    pub(super) fn nameref_ctx(&self) -> Option<&NameRefContext> {\n-        match &self.ident_ctx {\n-            IdentContext::NameRef(it) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    // FIXME: This shouldn't exist\n-    pub(crate) fn dot_receiver(&self) -> Option<&ast::Expr> {\n-        match self.nameref_ctx() {\n-            Some(NameRefContext {\n-                kind: Some(NameRefKind::DotAccess(DotAccess { receiver, .. })),\n-                ..\n-            }) => receiver.as_ref(),\n-            _ => None,\n-        }\n-    }\n-\n-    // FIXME: This shouldn't exist\n-    pub(crate) fn path_context(&self) -> Option<&PathCompletionCtx> {\n-        self.nameref_ctx().and_then(|ctx| match &ctx.kind {\n-            Some(NameRefKind::Path(path)) => Some(path),\n-            _ => None,\n-        })\n-    }\n-\n-    // FIXME: This shouldn't exist\n-    pub(crate) fn path_qual(&self) -> Option<&ast::Path> {\n-        self.path_context().and_then(|it| match &it.qualified {\n-            Qualified::With { path, .. } => Some(path),\n-            _ => None,\n-        })\n-    }\n-\n     /// Checks if an item is visible and not `doc(hidden)` at the completion site.\n     pub(crate) fn is_visible<I>(&self, item: &I) -> Visible\n     where"}, {"sha": "0efeb852071e06f677e5300170305a1fa8572d09", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=173bb10a7698a84faa2e346dc78c8649751942c9", "patch": "@@ -430,9 +430,12 @@ impl<'a> CompletionContext<'a> {\n                 let (nameref_ctx, pat_ctx, qualifier_ctx) =\n                     Self::classify_name_ref(&self.sema, &original_file, name_ref, parent.clone());\n \n+                if !matches!(nameref_ctx.kind, Some(NameRefKind::Path(_))) {\n+                    // FIXME: Pattern context should probably be part of ident_ctx\n+                    self.pattern_ctx = pat_ctx;\n+                }\n                 self.qualifier_ctx = qualifier_ctx;\n                 self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n-                self.pattern_ctx = pat_ctx;\n             }\n             ast::NameLike::Name(name) => {\n                 let (name_ctx, pat_ctx) = Self::classify_name(&self.sema, original_file, name)?;"}, {"sha": "9f548c888adfa5546061da18f9a050304645556f", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=173bb10a7698a84faa2e346dc78c8649751942c9", "patch": "@@ -10,7 +10,6 @@ mod render;\n mod tests;\n mod snippet;\n \n-use completions::flyimport::position_for_import;\n use ide_db::{\n     base_db::FilePosition,\n     helpers::mod_path_to_ast,\n@@ -25,11 +24,7 @@ use text_edit::TextEdit;\n \n use crate::{\n     completions::Completions,\n-    context::{\n-        CompletionContext,\n-        IdentContext::{self, NameRef},\n-        NameRefContext, NameRefKind,\n-    },\n+    context::{CompletionContext, IdentContext, NameRefContext, NameRefKind},\n };\n \n pub use crate::{\n@@ -156,8 +151,10 @@ pub fn completions(\n \n     // prevent `(` from triggering unwanted completion noise\n     if trigger_character == Some('(') {\n-        if let NameRef(NameRefContext { kind: Some(NameRefKind::Path(path_ctx)), .. }) =\n-            &ctx.ident_ctx\n+        if let IdentContext::NameRef(NameRefContext {\n+            kind: Some(NameRefKind::Path(path_ctx)),\n+            ..\n+        }) = &ctx.ident_ctx\n         {\n             completions::vis::complete_vis_path(&mut completions, ctx, path_ctx);\n         }\n@@ -171,16 +168,18 @@ pub fn completions(\n         match &ctx.ident_ctx {\n             IdentContext::Name(name_ctx) => {\n                 completions::field::complete_field_list_record_variant(acc, ctx, name_ctx);\n-                completions::mod_::complete_mod(acc, ctx, name_ctx);\n                 completions::item_list::trait_impl::complete_trait_impl_name(acc, ctx, name_ctx);\n+                completions::mod_::complete_mod(acc, ctx, name_ctx);\n             }\n-            NameRef(name_ref_ctx @ NameRefContext { kind, .. }) => {\n+            IdentContext::NameRef(name_ref_ctx @ NameRefContext { kind, .. }) => {\n                 completions::expr::complete_expr_path(acc, ctx, name_ref_ctx);\n                 completions::field::complete_field_list_tuple_variant(acc, ctx, name_ref_ctx);\n-                completions::use_::complete_use_tree(acc, ctx, name_ref_ctx);\n                 completions::item_list::complete_item_list(acc, ctx, name_ref_ctx);\n+                completions::use_::complete_use_tree(acc, ctx, name_ref_ctx);\n+\n                 match kind {\n                     Some(NameRefKind::Path(path_ctx)) => {\n+                        completions::flyimport::import_on_the_fly_path(acc, ctx, path_ctx);\n                         completions::record::complete_record_expr_func_update(acc, ctx, path_ctx);\n                         completions::attribute::complete_attribute(acc, ctx, path_ctx);\n                         completions::attribute::complete_derive(acc, ctx, path_ctx);\n@@ -193,6 +192,7 @@ pub fn completions(\n                         completions::vis::complete_vis_path(acc, ctx, path_ctx);\n                     }\n                     Some(NameRefKind::DotAccess(dot_access)) => {\n+                        completions::flyimport::import_on_the_fly_dot(acc, ctx, dot_access);\n                         completions::dot::complete_dot(acc, ctx, dot_access);\n                         completions::postfix::complete_postfix(acc, ctx, dot_access);\n                     }\n@@ -224,19 +224,11 @@ pub fn completions(\n         }\n \n         if let Some(pattern_ctx) = &ctx.pattern_ctx {\n+            completions::flyimport::import_on_the_fly_pat(acc, ctx, pattern_ctx);\n             completions::fn_param::complete_fn_param(acc, ctx, pattern_ctx);\n+            completions::pattern::complete_pattern(acc, ctx, pattern_ctx);\n             completions::record::complete_record_pattern_fields(acc, ctx, pattern_ctx);\n-            // FIXME: this check is odd, we shouldn't need this?\n-            if !matches!(\n-                ctx.ident_ctx,\n-                IdentContext::NameRef(NameRefContext { kind: Some(NameRefKind::Path(_)), .. })\n-            ) {\n-                completions::pattern::complete_pattern(acc, ctx, pattern_ctx);\n-            }\n         }\n-\n-        // FIXME: This should be split\n-        completions::flyimport::import_on_the_fly(acc, ctx);\n     }\n \n     Some(completions)\n@@ -252,7 +244,7 @@ pub fn resolve_completion_edits(\n ) -> Option<Vec<TextEdit>> {\n     let _p = profile::span(\"resolve_completion_edits\");\n     let ctx = CompletionContext::new(db, position, config)?;\n-    let position_for_import = &position_for_import(&ctx, None)?;\n+    let position_for_import = &ctx.original_token.parent()?;\n     let scope = ImportScope::find_insert_use_container(position_for_import, &ctx.sema)?;\n \n     let current_module = ctx.sema.scope(position_for_import)?.module();"}, {"sha": "811a88704d59fd2a2c1223316048e6544126d2f6", "filename": "crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=173bb10a7698a84faa2e346dc78c8649751942c9", "patch": "@@ -9,7 +9,7 @@ use syntax::SmolStr;\n use crate::{\n     context::{\n         CompletionContext, DotAccess, DotAccessKind, IdentContext, NameRefContext, NameRefKind,\n-        PathCompletionCtx, PathKind,\n+        PathCompletionCtx, PathKind, Qualified,\n     },\n     item::{Builder, CompletionItem, CompletionItemKind, CompletionRelevance},\n     render::{compute_exact_name_match, compute_ref_match, compute_type_match, RenderContext},\n@@ -80,7 +80,17 @@ fn render(\n         // FIXME For now we don't properly calculate the edits for ref match\n         // completions on methods or qualified paths, so we've disabled them.\n         // See #8058.\n-        if matches!(func_kind, FuncKind::Function) && ctx.completion.path_qual().is_none() {\n+        let qualified_path = matches!(\n+            ctx.completion.ident_ctx,\n+            IdentContext::NameRef(NameRefContext {\n+                kind: Some(NameRefKind::Path(PathCompletionCtx {\n+                    qualified: Qualified::With { .. },\n+                    ..\n+                })),\n+                ..\n+            })\n+        );\n+        if matches!(func_kind, FuncKind::Function) && !qualified_path {\n             item.ref_match(ref_match);\n         }\n     }"}, {"sha": "ca9408fb138882b29104f33b55be7e03ebd28359", "filename": "crates/ide-completion/src/tests/flyimport.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/173bb10a7698a84faa2e346dc78c8649751942c9/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=173bb10a7698a84faa2e346dc78c8649751942c9", "patch": "@@ -1,14 +1,30 @@\n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, check_edit_with_config, TEST_CONFIG};\n+use crate::{\n+    context::NameRefKind,\n+    tests::{check_edit, check_edit_with_config, TEST_CONFIG},\n+};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let config = TEST_CONFIG;\n     let (db, position) = crate::tests::position(ra_fixture);\n     let ctx = crate::context::CompletionContext::new(&db, position, &config).unwrap();\n \n     let mut acc = crate::completions::Completions::default();\n-    crate::completions::flyimport::import_on_the_fly(&mut acc, &ctx);\n+    if let Some(pattern_ctx) = &ctx.pattern_ctx {\n+        crate::completions::flyimport::import_on_the_fly_pat(&mut acc, &ctx, pattern_ctx);\n+    }\n+    if let crate::context::IdentContext::NameRef(name_ref_ctx) = &ctx.ident_ctx {\n+        match &name_ref_ctx.kind {\n+            Some(NameRefKind::Path(path)) => {\n+                crate::completions::flyimport::import_on_the_fly_path(&mut acc, &ctx, path);\n+            }\n+            Some(NameRefKind::DotAccess(dot_access)) => {\n+                crate::completions::flyimport::import_on_the_fly_dot(&mut acc, &ctx, dot_access);\n+            }\n+            _ => (),\n+        }\n+    }\n \n     expect.assert_eq(&super::render_completion_list(Vec::from(acc)));\n }"}]}