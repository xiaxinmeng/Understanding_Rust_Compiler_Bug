{"sha": "85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YjViMmE4ZTQ2Zjk0M2EzNTUxM2JiMmJiZThhNmQwMjZlZDI3ODU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-28T01:12:37Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-28T01:14:23Z"}, "message": "Tests for while loops that may invalidate constraints\n\nWrote some small test cases that use while loops and moves, to\nmake sure the poststate for the loop body gets propagated into the\nnew prestate and deinitialization gets reflected.\n\nAlong with that, rewrite the code for intersecting states. I still\nfind it dodgy, but I guess I'll continue trying to add more tests.\nAlso, I'll probably feel better about it once I start formalizing\nthe algorithm.", "tree": {"sha": "fc503bd66d9271612611a72cc24f7f679daddec8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc503bd66d9271612611a72cc24f7f679daddec8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "html_url": "https://github.com/rust-lang/rust/commit/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d1050b1c7c8f5075aaaf6b922ff36f3aceef5e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d1050b1c7c8f5075aaaf6b922ff36f3aceef5e2", "html_url": "https://github.com/rust-lang/rust/commit/6d1050b1c7c8f5075aaaf6b922ff36f3aceef5e2"}], "stats": {"total": 296, "additions": 200, "deletions": 96}, "files": [{"sha": "882dc4a42f7e7627ebc46050875cf86e411679ad", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "patch": "@@ -112,7 +112,7 @@ fn set_in_postcond(uint i, &pre_and_post p) -> bool {\n     // sets the ith bit in p's post\n     auto was_set = tritv_get(p.postcondition, i);\n     tritv_set(i, p.postcondition, ttrue);\n-    ret was_set == dont_care;\n+    ret was_set != ttrue;\n }\n \n fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n@@ -123,7 +123,7 @@ fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n fn set_in_poststate_(uint i, &poststate p) -> bool {\n     auto was_set = tritv_get(p, i);\n     tritv_set(i, p, ttrue);\n-    ret was_set == dont_care;\n+    ret was_set != ttrue;\n \n }\n \n@@ -135,14 +135,25 @@ fn clear_in_poststate(uint i, &pre_and_post_state s) -> bool {\n fn clear_in_poststate_(uint i, &poststate s) -> bool {\n     auto was_set = tritv_get(s, i);\n     tritv_set(i, s, tfalse);\n-    ret was_set == dont_care;\n+    ret was_set != tfalse;\n+}\n+\n+fn clear_in_prestate(uint i, &pre_and_post_state s) -> bool {\n+    // sets the ith bit in p's pre\n+    ret clear_in_prestate_(i, s.prestate);\n+}\n+\n+fn clear_in_prestate_(uint i, &prestate s) -> bool {\n+    auto was_set = tritv_get(s, i);\n+    tritv_set(i, s, tfalse);\n+    ret was_set != tfalse;\n }\n \n fn clear_in_postcond(uint i, &pre_and_post s) -> bool {\n     // sets the ith bit in p's post\n     auto was_set = tritv_get(s.postcondition, i);\n     tritv_set(i, s.postcondition, tfalse);\n-    ret was_set == dont_care;\n+    ret was_set != tfalse;\n }\n \n // Sets all the bits in a's precondition to equal the"}, {"sha": "c7e77881e8542f3de926354e03aa14418d1fe334", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "patch": "@@ -43,6 +43,7 @@ import tstate::ann::set_in_postcond;\n import tstate::ann::set_in_poststate;\n import tstate::ann::set_in_poststate_;\n import tstate::ann::clear_in_poststate;\n+import tstate::ann::clear_in_prestate;\n import tstate::ann::clear_in_poststate_;\n import tritv::*;\n \n@@ -147,22 +148,10 @@ fn seq_preconds(&fn_ctxt fcx, &vec[pre_and_post] pps) -> precond {\n     } else { ret true_precond(num_vars); }\n }\n \n-/* Gee, maybe we could use foldl or something */\n-fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-    auto sz = vec::len[postcond](rest);\n-    if (sz > 0u) {\n-        auto other = rest.(0);\n-        intersect(first, other);\n-        intersect_postconds_go(first,\n-                               slice[postcond](rest, 1u,\n-                                               len[postcond](rest)));\n-    }\n-    ret first;\n-}\n-\n-fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n-    assert (len[postcond](pcs) > 0u);\n-    ret intersect_postconds_go(tritv_clone(pcs.(0)), pcs);\n+fn intersect_states(&prestate p, &prestate q) -> prestate {\n+    auto rslt = tritv_clone(p);\n+    tritv_intersect(rslt, q);\n+    ret rslt;\n }\n \n fn gen(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n@@ -219,6 +208,11 @@ fn gen_poststate(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n                          node_id_to_ts_ann(fcx.ccx, id).states);\n }\n \n+fn kill_prestate(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n+    ret clear_in_prestate(bit_num(fcx, c),\n+                           node_id_to_ts_ann(fcx.ccx, id).states);\n+}\n+\n fn kill_poststate(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n     log \"kill_poststate\";\n     ret clear_in_poststate(bit_num(fcx, c),\n@@ -254,6 +248,16 @@ fn set_in_poststate_ident(&fn_ctxt fcx, &node_id id, &ident ident,\n     ret set_in_poststate_(bit_num(fcx, rec(id=id, c=ninit(ident))), t);\n }\n \n+fn clear_in_poststate_ident(&fn_ctxt fcx, &node_id id, &ident ident,\n+                            &node_id parent) -> bool {\n+    ret kill_poststate(fcx, parent, rec(id=id, c=ninit(ident)));\n+}\n+\n+fn clear_in_prestate_ident(&fn_ctxt fcx, &node_id id, &ident ident,\n+                            &node_id parent) -> bool {\n+    ret kill_prestate(fcx, parent, rec(id=id, c=ninit(ident)));\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "0c13c617c4736368585b6ebd2ae09a3008cfcae2", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "patch": "@@ -70,9 +70,9 @@ fn check_states_expr(&fn_ctxt fcx, &@expr e) {\n     log_err(\"check_states_expr:\");\n       util::common::log_expr_err(*e);\n       log_err(\"prec = \");\n-      log_bitv_err(fcx, prec);\n+      log_tritv_err(fcx, prec);\n       log_err(\"pres = \");\n-      log_bitv_err(fcx, pres);\n+      log_tritv_err(fcx, pres);\n     */\n \n     if (!implies(pres, prec)) {\n@@ -99,9 +99,9 @@ fn check_states_stmt(&fn_ctxt fcx, &@stmt s) {\n       log_err(\"check_states_stmt:\");\n       log_stmt_err(*s);\n       log_err(\"prec = \");\n-      log_bitv_err(fcx, prec);\n+      log_tritv_err(fcx, prec);\n       log_err(\"pres = \");\n-      log_bitv_err(fcx, pres);\n+      log_tritv_err(fcx, pres);\n     */\n \n     if (!implies(pres, prec)) {"}, {"sha": "d4495fee6224848dec6da783303ec7ee8db74d4f", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "patch": "@@ -59,7 +59,7 @@ import bitvectors::bit_num;\n import bitvectors::promises;\n import bitvectors::seq_preconds;\n import bitvectors::seq_postconds;\n-import bitvectors::intersect_postconds;\n+import bitvectors::intersect_states;\n import bitvectors::declare_var;\n import bitvectors::gen_poststate;\n import bitvectors::relax_precond_block;\n@@ -180,9 +180,8 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n         seq_preconds(fcx,\n                      [expr_pp(fcx.ccx, index),\n                       block_pp(fcx.ccx, body)]);\n-    auto loop_postcond =\n-        intersect_postconds([expr_postcond(fcx.ccx, index),\n-                             block_postcond(fcx.ccx, body)]);\n+    auto loop_postcond = intersect_states(expr_postcond(fcx.ccx, index),\n+                                          block_postcond(fcx.ccx, body));\n     copy_pre_post_(fcx.ccx, id, loop_precond, loop_postcond);\n }\n \n@@ -247,8 +246,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                 seq_postconds(fcx, [precond_true_case,\n                                     precond_false_case]);\n             auto postcond_res =\n-                intersect_postconds([postcond_true_case,\n-                                     postcond_false_case]);\n+                intersect_states(postcond_true_case, postcond_false_case);\n             set_pre_and_post(fcx.ccx, id, precond_res, postcond_res);\n         }\n     }\n@@ -459,10 +457,9 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                              seq_preconds(fcx,\n                                           [expr_pp(fcx.ccx, test),\n                                            block_pp(fcx.ccx, body)]),\n-                             intersect_postconds([expr_postcond(fcx.ccx,\n-                                                                test),\n-                                                  block_postcond(fcx.ccx,\n-                                                                 body)]));\n+                             intersect_states(expr_postcond(fcx.ccx, test),\n+                                              block_postcond(fcx.ccx,\n+                                                             body)));\n         }\n         case (expr_do_while(?body, ?test)) {\n             find_pre_post_block(fcx, body);"}, {"sha": "d5676fad7efd9ee2f8a101a97c6c9f3dec3dea96", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 83, "deletions": 55, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "patch": "@@ -69,10 +69,12 @@ import tritv::ttrue;\n \n import bitvectors::set_in_poststate_ident;\n import bitvectors::clear_in_poststate_expr;\n-import bitvectors::intersect_postconds;\n+import bitvectors::clear_in_prestate_ident;\n import bitvectors::bit_num;\n import bitvectors::gen_poststate;\n import bitvectors::kill_poststate;\n+import bitvectors::clear_in_poststate_ident;\n+import bitvectors::intersect_states;\n import front::ast;\n import front::ast::*;\n import middle::ty::expr_ty;\n@@ -188,23 +190,27 @@ fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, ast::node_id id,\n \n fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@local l,\n                             &@expr index, &block body, node_id id) -> bool {\n-    /* same issues as while */\n+    auto loop_pres = intersect_states(pres,\n+                                      block_poststate(fcx.ccx, body));\n \n-    // FIXME: also want to set l as initialized, no?\n-    auto changed = set_prestate_ann(fcx.ccx, id, pres) |\n+    auto changed = set_prestate_ann(fcx.ccx, id, loop_pres) |\n         find_pre_post_state_expr(fcx, pres, index);\n-    /* in general, would need the intersection of\n-       (poststate of index, poststate of body) */\n         find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, index), body);\n \n     if (has_nonlocal_exits(body)) { \n-        changed |= set_poststate_ann(fcx.ccx, id, pres);\n+        // See [Break-unsound]\n+        ret (changed | set_poststate_ann(fcx.ccx, id, pres));\n     }\n-\n+    else {\n+        auto res_p = intersect_states(expr_poststate(fcx.ccx, index),\n+                                      block_poststate(fcx.ccx, body));\n+    /*\n     auto res_p =\n         intersect_postconds([expr_poststate(fcx.ccx, index),\n-                             block_poststate(fcx.ccx, body)]);\n-    ret changed | set_poststate_ann(fcx.ccx, id, res_p);\n+        block_poststate(fcx.ccx, body)]); */\n+\n+        ret changed | set_poststate_ann(fcx.ccx, id, res_p);\n+    }\n }\n \n fn gen_if_local(&fn_ctxt fcx, &poststate p, &@expr e) -> bool {\n@@ -269,16 +275,18 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                 find_pre_post_state_block(fcx, conseq_prestate, conseq);\n    \n             auto poststate_res =\n-                intersect_postconds([block_poststate(fcx.ccx, conseq),\n-                                     expr_poststate(fcx.ccx, altern)]);\n-            /*   fcx.ccx.tcx.sess.span_note(antec.span,\n-               \"poststate_res = \" + aux::bitv_to_str(fcx, poststate_res));\n+                intersect_states(block_poststate(fcx.ccx, conseq),\n+                                    expr_poststate(fcx.ccx, altern));\n+            /*\n+               fcx.ccx.tcx.sess.span_note(antec.span,\n+               \"poststate_res = \" + aux::tritv_to_str(fcx, poststate_res));\n             fcx.ccx.tcx.sess.span_note(antec.span,\n                \"altern poststate = \" +\n-                aux::bitv_to_str(fcx, expr_poststate(fcx.ccx, altern)));\n+                aux::tritv_to_str(fcx, expr_poststate(fcx.ccx, altern)));\n             fcx.ccx.tcx.sess.span_note(antec.span,\n-            \"conseq poststate = \" + aux::bitv_to_str(fcx,\n-               block_poststate(fcx.ccx, conseq))); */\n+            \"conseq poststate = \" + aux::tritv_to_str(fcx,\n+               block_poststate(fcx.ccx, conseq))); \n+            */\n \n             changed |= set_poststate_ann(fcx.ccx, id, poststate_res);\n         }\n@@ -287,7 +295,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n }\n \n fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n-    auto num_local_vars = num_constraints(fcx.enclosing);\n+    auto num_constrs = num_constraints(fcx.enclosing);\n \n     alt (e.node) {\n         case (expr_vec(?elts, _, _)) {\n@@ -381,7 +389,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                a ret expression (since execution never continues locally\n                after a ret expression */\n \n-            set_poststate_ann(fcx.ccx, e.id, false_postcond(num_local_vars));\n+            set_poststate_ann(fcx.ccx, e.id, false_postcond(num_constrs));\n             /* return from an always-failing function clears the return bit */\n \n             alt (fcx.enclosing.cf) {\n@@ -401,7 +409,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         }\n         case (expr_be(?val)) {\n             auto changed = set_prestate_ann(fcx.ccx, e.id, pres);\n-            set_poststate_ann(fcx.ccx, e.id, false_postcond(num_local_vars));\n+            set_poststate_ann(fcx.ccx, e.id, false_postcond(num_constrs));\n             ret changed | find_pre_post_state_expr(fcx, pres, val);\n         }\n         case (expr_if(?antec, ?conseq, ?maybe_alt)) {\n@@ -423,55 +431,62 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                                         oper_assign);\n         }\n         case (expr_while(?test, ?body)) {\n-            auto changed = set_prestate_ann(fcx.ccx, e.id, pres) |\n-            /* to handle general predicates, we need to pass in\n-                pres `intersect` (poststate(a)) \n-             like: auto test_pres = intersect_postconds(pres,\n-             expr_postcond(a)); However, this doesn't work right now because\n-             we would be passing in an all-zero prestate initially\n-               FIXME\n-               maybe need a \"don't know\" state in addition to 0 or 1?\n+            /*\n+            log_err \"in a while loop:\";\n+            log_expr_err(*e);\n+            aux::log_tritv_err(fcx, block_poststate(fcx.ccx, body));\n+            aux::log_tritv_err(fcx, pres);\n             */\n-                find_pre_post_state_expr(fcx, pres, test) |\n+            auto loop_pres = intersect_states\n+                (block_poststate(fcx.ccx, body), pres);\n+            // aux::log_tritv_err(fcx, loop_pres);\n+            // log_err \"---------------\";\n+\n+            auto changed = set_prestate_ann(fcx.ccx, e.id, loop_pres) |\n+                find_pre_post_state_expr(fcx, loop_pres, test) |\n                 find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, test),\n                                           body);\n             /* conservative approximation: if a loop contains a break\n                or cont, we assume nothing about the poststate */\n+            /* which is still unsound -- see [Break-unsound] */\n             if (has_nonlocal_exits(body)) { \n-                changed |= set_poststate_ann(fcx.ccx, e.id, pres);\n+                ret changed | set_poststate_ann(fcx.ccx, e.id, pres);\n+            }\n+            else {\n+                auto e_post = expr_poststate(fcx.ccx, test);\n+                auto b_post = block_poststate(fcx.ccx, body);\n+                ret changed | set_poststate_ann\n+                    (fcx.ccx, e.id, intersect_states(e_post, b_post));\n             }\n-\n-            auto e_post = expr_poststate(fcx.ccx, test);\n-            auto b_post = block_poststate(fcx.ccx, body);\n-            ret changed | set_poststate_ann\n-                (fcx.ccx, e.id, intersect_postconds([e_post, b_post]));\n         }\n         case (expr_do_while(?body, ?test)) {\n-            auto changed = set_prestate_ann(fcx.ccx, e.id, pres);\n-            auto changed0 = changed;\n-            changed |= find_pre_post_state_block(fcx, pres, body);\n+            auto loop_pres = intersect_states(expr_poststate(fcx.ccx, test),\n+                                              pres);\n+\n+            auto changed = set_prestate_ann(fcx.ccx, e.id, loop_pres);\n+            changed |= find_pre_post_state_block(fcx, loop_pres, body);\n             /* conservative approximination: if the body of the loop\n                could break or cont, we revert to the prestate\n                (TODO: could treat cont differently from break, since\n                if there's a cont, the test will execute) */\n \n-            auto breaks = has_nonlocal_exits(body);\n-            if (breaks) {\n-                // this should probably be true_poststate and not pres,\n-                // b/c the body could invalidate stuff\n-                // FIXME\n-                 // This doesn't set \"changed\", as if the previous state\n-                // was different, this might come back true every time\n-                set_poststate_ann(fcx.ccx, body.node.id, pres);\n-                changed = changed0;\n-            }\n-\n             changed |= find_pre_post_state_expr\n                 (fcx, block_poststate(fcx.ccx, body), test);\n \n+            auto breaks = has_nonlocal_exits(body);\n             if (breaks) {\n-                set_poststate_ann(fcx.ccx, e.id, pres);\n-            }\n+                // this should probably be true_poststate and not pres,\n+                // b/c the body could invalidate stuff\n+                // FIXME [Break-unsound]\n+                // This is unsound as it is -- consider\n+                // while (true) {\n+                //    x <- y;\n+                //    break;\n+                // }\n+                // The poststate wouldn't take into account that\n+                // y gets deinitialized\n+                changed |= set_poststate_ann(fcx.ccx, e.id, pres);\n+             }\n             else {\n                 changed |= set_poststate_ann\n                     (fcx.ccx, e.id, expr_poststate(fcx.ccx, test));\n@@ -493,7 +508,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             auto e_post = expr_poststate(fcx.ccx, val);\n             auto a_post;\n             if (vec::len[arm](alts) > 0u) {\n-                a_post = false_postcond(num_local_vars);\n+                a_post = false_postcond(num_constrs);\n                 for (arm an_alt in alts) {\n                     changed |= find_pre_post_state_block\n                         (fcx, e_post, an_alt.block);\n@@ -524,7 +539,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             /* if execution continues after fail, then everything is true!\n                woo! */\n                 set_poststate_ann(fcx.ccx, e.id,\n-                                  false_postcond(num_local_vars));\n+                                  false_postcond(num_constrs));\n         }\n         case (expr_assert(?p)) {\n             ret find_pre_post_state_sub(fcx, pres, p, e.id, none);\n@@ -604,8 +619,12 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n                             */\n                         }\n                         case (none) {\n-                            ret set_prestate(stmt_ann, pres) |\n-                                set_poststate(stmt_ann, pres);\n+                            // let int = x; => x is uninit in poststate\n+                            set_poststate_ann(fcx.ccx, id, pres);\n+                            clear_in_poststate_ident(fcx, alocal.node.id,\n+                                                         alocal.node.ident, id);\n+                            set_prestate(stmt_ann, pres);\n+                            ret false;\n                         }\n                     }\n                 }\n@@ -683,6 +702,8 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b)\n \n fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n     auto num_local_vars = num_constraints(fcx.enclosing);\n+    // make sure the return bit starts out False\n+    clear_in_prestate_ident(fcx, fcx.id, fcx.name, f.body.node.id);\n     auto changed =\n         find_pre_post_state_block(fcx, block_prestate(fcx.ccx, f.body),\n                                   f.body);\n@@ -704,6 +725,13 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n         }\n         case (none) {/* fallthrough */ }\n     }\n+\n+/*\n+    log_err \"find_pre_post_state_fn\";\n+    log_err changed;\n+    fcx.ccx.tcx.sess.span_note(f.body.span, fcx.name);\n+*/\n+\n     ret changed;\n }\n //"}, {"sha": "90be1810301f274236c811cd41c8438a7b2800b9", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "patch": "@@ -82,18 +82,32 @@ fn trit_or(trit a, trit b) -> trit {\n   }\n }\n \n+// FIXME: This still seems kind of dodgy to me (that is,\n+// that 1 + ? = 1. But it might work out given that\n+// all variables start out in a 0 state. Probably I need\n+// to make it so that all constraints start out in a 0 state\n+// (we consider a constraint false until proven true), too.\n fn trit_and(trit a, trit b) -> trit {\n   alt (a) {\n-    case (dont_care) { dont_care }\n-    case (ttrue)     {\n-      alt (b) {\n-        case (dont_care) { dont_care }\n-        case (ttrue)     { ttrue }\n-        case (tfalse)    { dont_care } // ???\n+      case (dont_care) { b }  // also seems wrong for case b = ttrue\n+      case (ttrue)     {\n+          alt (b) {\n+              case (dont_care) { ttrue } // ??? Seems wrong\n+              case (ttrue)     { ttrue }\n+              // false wins, since if something is uninit\n+              // on one path, we care\n+              // (Rationale: it's always safe to assume that\n+         // a var is uninitialized or that a constraint\n+         // needs to be re-established)\n+              case (tfalse)    { tfalse }\n+          }\n       }\n-    }\n+      // Rationale: if it's uninit on one path,\n+      // we can consider it as uninit on all paths\n     case (tfalse) { tfalse }\n   }\n+  // if the result is dont_care, that means\n+  // a and b were both dont_care\n }\n \n fn change(bool changed, trit old, trit new) -> bool { changed || new != old }"}, {"sha": "c9c557320a0976f722ae20b85ae690ebcb188b12", "filename": "src/test/compile-fail/do-while-constraints.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Ftest%2Fcompile-fail%2Fdo-while-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Ftest%2Fcompile-fail%2Fdo-while-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo-while-constraints.rs?ref=85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "patch": "@@ -0,0 +1,17 @@\n+// xfail-stage0\n+// error-pattern: Unsatisfied precondition constraint (for example, init(y\n+fn main() {\n+\n+  let int y = 42;\n+  let int x;\n+  do {\n+    log y;\n+    do {\n+      do {\n+\tdo {\n+\t  x <- y;\n+\t} while (true);\n+      } while (true);\n+    } while (true);\n+  } while (true);\n+}\n\\ No newline at end of file"}, {"sha": "981a555ff30a4a77a079ec5d9e2879193e9a9f6f", "filename": "src/test/compile-fail/while-loop-constraints.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Ftest%2Fcompile-fail%2Fwhile-loop-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Ftest%2Fcompile-fail%2Fwhile-loop-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-loop-constraints.rs?ref=85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "patch": "@@ -0,0 +1,17 @@\n+// xfail-stage0\n+// error-pattern: Unsatisfied precondition constraint (for example, init(y\n+fn main() {\n+\n+  let int y = 42;\n+  let int x;\n+  while (true) {\n+    log y;\n+    while (true) {\n+      while (true) {\n+\twhile (true) {\n+\t  x <- y;\n+\t}\n+      }\n+    }\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "c1550ad2d08ac851ff21bbceabfc13dac014ecfa", "filename": "src/test/run-pass/while-loop-constraints-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Ftest%2Frun-pass%2Fwhile-loop-constraints-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b5b2a8e46f943a35513bb2bbe8a6d026ed2785/src%2Ftest%2Frun-pass%2Fwhile-loop-constraints-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-loop-constraints-2.rs?ref=85b5b2a8e46f943a35513bb2bbe8a6d026ed2785", "patch": "@@ -0,0 +1,16 @@\n+// xfail-stage0\n+fn main() {\n+\n+  let int y = 42;\n+  let int z = 42;\n+  let int x;\n+  while (z < 50) {\n+    z += 1; \n+    while (false) {\n+      x <- y;\n+      y = z;\n+    }\n+    log y;\n+  }\n+  assert (y == 42 && z == 50);\n+}\n\\ No newline at end of file"}]}