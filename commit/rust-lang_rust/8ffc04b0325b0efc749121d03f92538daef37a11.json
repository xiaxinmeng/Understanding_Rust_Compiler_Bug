{"sha": "8ffc04b0325b0efc749121d03f92538daef37a11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZmMwNGIwMzI1YjBlZmM3NDkxMjFkMDNmOTI1MzhkYWVmMzdhMTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-22T20:52:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-22T20:57:08Z"}, "message": "Avoid writing a temporary closure kind\n\nWe used to write a temporary closure kind into the inference table, but\nthis could lead to obligations being incorrectled resolved before\ninference had completed. This result could then be cached, leading to\nfurther trouble. This patch avoids writing any closure kind until the\ncomputation is complete.\n\nFixes #34349.", "tree": {"sha": "243ccd3b57d2b23e84dc5ba3485d28b7ce9b44f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/243ccd3b57d2b23e84dc5ba3485d28b7ce9b44f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ffc04b0325b0efc749121d03f92538daef37a11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ffc04b0325b0efc749121d03f92538daef37a11", "html_url": "https://github.com/rust-lang/rust/commit/8ffc04b0325b0efc749121d03f92538daef37a11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ffc04b0325b0efc749121d03f92538daef37a11/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d15e2656e574533704cee927592f6dbe2ee59c5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d15e2656e574533704cee927592f6dbe2ee59c5f", "html_url": "https://github.com/rust-lang/rust/commit/d15e2656e574533704cee927592f6dbe2ee59c5f"}], "stats": {"total": 155, "additions": 105, "deletions": 50}, "files": [{"sha": "dfca7b924b1297c606a154c4b5d57c7187fa4daf", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ffc04b0325b0efc749121d03f92538daef37a11/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ffc04b0325b0efc749121d03f92538daef37a11/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8ffc04b0325b0efc749121d03f92538daef37a11", "patch": "@@ -175,6 +175,12 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // any obligations set during the current snapshot. In that case, the\n     // snapshot can't be rolled back.\n     pub obligations_in_snapshot: Cell<bool>,\n+\n+    // This is false except during closure kind inference. It is used\n+    // by the mem-categorization code to be able to have stricter\n+    // assertions (which are always true except during upvar\n+    // inference).\n+    during_closure_kind_inference: Cell<bool>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -491,6 +497,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n             obligations_in_snapshot: Cell::new(false),\n+            during_closure_kind_inference: Cell::new(false),\n         }\n     }\n }\n@@ -532,6 +539,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n             obligations_in_snapshot: Cell::new(false),\n+            during_closure_kind_inference: Cell::new(false),\n         }))\n     }\n }\n@@ -1294,6 +1302,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                         .map(|method| resolve_ty(method.ty)))\n     }\n \n+    pub fn set_during_closure_kind_inference(&self, value: bool) {\n+        self.during_closure_kind_inference.set(value);\n+    }\n+\n+    pub fn during_closure_kind_inference(&self) -> bool {\n+        self.during_closure_kind_inference.get()\n+    }\n+\n     /// True if errors have been reported since this infcx was\n     /// created.  This is sometimes used as a heuristic to skip\n     /// reporting errors that often occur as a result of earlier"}, {"sha": "e4308aabf5f7523d6ad4616373f8775675b17504", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8ffc04b0325b0efc749121d03f92538daef37a11/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ffc04b0325b0efc749121d03f92538daef37a11/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8ffc04b0325b0efc749121d03f92538daef37a11", "patch": "@@ -362,7 +362,9 @@ impl MutabilityCategory {\n impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n                -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-        MemCategorizationContext { infcx: infcx }\n+        MemCategorizationContext {\n+            infcx: infcx,\n+        }\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -584,10 +586,20 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                               self.cat_upvar(id, span, var_id, fn_node_id, kind)\n                           }\n                           None => {\n-                              span_bug!(\n-                                  span,\n-                                  \"No closure kind for {:?}\",\n-                                  closure_id);\n+                              if !self.infcx.during_closure_kind_inference() {\n+                                  span_bug!(\n+                                      span,\n+                                      \"No closure kind for {:?}\",\n+                                      closure_id);\n+                              }\n+\n+                              // during closure kind inference, we\n+                              // don't know the closure kind yet, but\n+                              // it's ok because we detect that we are\n+                              // accessing an upvar and handle that\n+                              // case specially anyhow. Use Fn\n+                              // arbitrarily.\n+                              self.cat_upvar(id, span, var_id, fn_node_id, ty::ClosureKind::Fn)\n                           }\n                       }\n                   }"}, {"sha": "c1ffc668bc2612d859ed7bc90111189063a660a1", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 40, "deletions": 45, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8ffc04b0325b0efc749121d03f92538daef37a11/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ffc04b0325b0efc749121d03f92538daef37a11/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=8ffc04b0325b0efc749121d03f92538daef37a11", "patch": "@@ -47,11 +47,11 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty};\n use rustc::infer::UpvarRegion;\n-use std::collections::HashSet;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor};\n+use rustc::util::nodemap::NodeMap;\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n@@ -60,9 +60,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_analyze_fn(&self, body: &hir::Block) {\n         let mut seed = SeedBorrowKind::new(self);\n         seed.visit_block(body);\n-        let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n \n-        let mut adjust = AdjustBorrowKind::new(self, &closures_with_inferred_kinds);\n+        let mut adjust = AdjustBorrowKind::new(self, seed.temp_closure_kinds);\n         adjust.visit_block(body);\n \n         // it's our job to process these.\n@@ -72,9 +71,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_analyze_const(&self, body: &hir::Expr) {\n         let mut seed = SeedBorrowKind::new(self);\n         seed.visit_expr(body);\n-        let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n \n-        let mut adjust = AdjustBorrowKind::new(self, &closures_with_inferred_kinds);\n+        let mut adjust = AdjustBorrowKind::new(self, seed.temp_closure_kinds);\n         adjust.visit_expr(body);\n \n         // it's our job to process these.\n@@ -87,7 +85,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    closures_with_inferred_kinds: HashSet<ast::NodeId>,\n+    temp_closure_kinds: NodeMap<ty::ClosureKind>,\n }\n \n impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n@@ -106,7 +104,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>) -> SeedBorrowKind<'a, 'gcx, 'tcx> {\n-        SeedBorrowKind { fcx: fcx, closures_with_inferred_kinds: HashSet::new() }\n+        SeedBorrowKind { fcx: fcx, temp_closure_kinds: NodeMap() }\n     }\n \n     fn check_closure(&mut self,\n@@ -116,11 +114,8 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n     {\n         let closure_def_id = self.fcx.tcx.map.local_def_id(expr.id);\n         if !self.fcx.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n-            self.closures_with_inferred_kinds.insert(expr.id);\n-            self.fcx.tables.borrow_mut().closure_kinds\n-                                        .insert(closure_def_id, ty::ClosureKind::Fn);\n-            debug!(\"check_closure: adding closure_id={:?} to closures_with_inferred_kinds\",\n-                   closure_def_id);\n+            self.temp_closure_kinds.insert(expr.id, ty::ClosureKind::Fn);\n+            debug!(\"check_closure: adding closure {:?} as Fn\", expr.id);\n         }\n \n         self.fcx.tcx.with_freevars(expr.id, |freevars| {\n@@ -154,14 +149,14 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n \n struct AdjustBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    closures_with_inferred_kinds: &'a HashSet<ast::NodeId>,\n+    temp_closure_kinds: NodeMap<ty::ClosureKind>,\n }\n \n impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-           closures_with_inferred_kinds: &'a HashSet<ast::NodeId>)\n+           temp_closure_kinds: NodeMap<ty::ClosureKind>)\n            -> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n-        AdjustBorrowKind { fcx: fcx, closures_with_inferred_kinds: closures_with_inferred_kinds }\n+        AdjustBorrowKind { fcx: fcx, temp_closure_kinds: temp_closure_kinds }\n     }\n \n     fn analyze_closure(&mut self,\n@@ -176,8 +171,10 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id);\n \n         {\n+            self.fcx.set_during_closure_kind_inference(true);\n             let mut euv = euv::ExprUseVisitor::new(self, self.fcx);\n             euv.walk_fn(decl, body);\n+            self.fcx.set_during_closure_kind_inference(false);\n         }\n \n         // Now that we've analyzed the closure, we know how each\n@@ -211,10 +208,14 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             self.fcx.demand_eqtype(span, final_upvar_ty, upvar_ty);\n         }\n \n-        // Now we must process and remove any deferred resolutions,\n-        // since we have a concrete closure kind.\n+        // If we are also inferred the closure kind here, update the\n+        // main table and process any deferred resolutions.\n         let closure_def_id = self.fcx.tcx.map.local_def_id(id);\n-        if self.closures_with_inferred_kinds.contains(&id) {\n+        if let Some(&kind) = self.temp_closure_kinds.get(&id) {\n+            self.fcx.tables.borrow_mut().closure_kinds\n+                                        .insert(closure_def_id, kind);\n+            debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n+\n             let mut deferred_call_resolutions =\n                 self.fcx.remove_deferred_call_resolutions(closure_def_id);\n             for deferred_call_resolution in &mut deferred_call_resolutions {\n@@ -259,7 +260,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             })\n     }\n \n-    fn adjust_upvar_borrow_kind_for_consume(&self,\n+    fn adjust_upvar_borrow_kind_for_consume(&mut self,\n                                             cmt: mc::cmt<'tcx>,\n                                             mode: euv::ConsumeMode)\n     {\n@@ -350,7 +351,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn adjust_upvar_borrow_kind_for_unique(&self, cmt: mc::cmt<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_unique(&mut self, cmt: mc::cmt<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\",\n                cmt);\n \n@@ -381,7 +382,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn try_adjust_upvar_deref(&self,\n+    fn try_adjust_upvar_deref(&mut self,\n                               note: &mc::Note,\n                               borrow_kind: ty::BorrowKind)\n                               -> bool\n@@ -430,7 +431,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     /// moving from left to right as needed (but never right to left).\n     /// Here the argument `mutbl` is the borrow_kind that is required by\n     /// some particular use.\n-    fn adjust_upvar_borrow_kind(&self,\n+    fn adjust_upvar_borrow_kind(&mut self,\n                                 upvar_id: ty::UpvarId,\n                                 upvar_capture: &mut ty::UpvarCapture,\n                                 kind: ty::BorrowKind) {\n@@ -460,36 +461,30 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn adjust_closure_kind(&self,\n+    fn adjust_closure_kind(&mut self,\n                            closure_id: ast::NodeId,\n                            new_kind: ty::ClosureKind) {\n         debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?})\",\n                closure_id, new_kind);\n \n-        if !self.closures_with_inferred_kinds.contains(&closure_id) {\n-            return;\n-        }\n-\n-        let closure_def_id = self.fcx.tcx.map.local_def_id(closure_id);\n-        let closure_kinds = &mut self.fcx.tables.borrow_mut().closure_kinds;\n-        let existing_kind = *closure_kinds.get(&closure_def_id).unwrap();\n+        if let Some(&existing_kind) = self.temp_closure_kinds.get(&closure_id) {\n+            debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n+                   closure_id, existing_kind, new_kind);\n \n-        debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n-               closure_id, existing_kind, new_kind);\n-\n-        match (existing_kind, new_kind) {\n-            (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::Fn) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-            (ty::ClosureKind::FnOnce, _) => {\n-                // no change needed\n-            }\n+            match (existing_kind, new_kind) {\n+                (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+                (ty::ClosureKind::FnMut, ty::ClosureKind::Fn) |\n+                (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+                (ty::ClosureKind::FnOnce, _) => {\n+                    // no change needed\n+                }\n \n-            (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) |\n-            (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-                // new kind is stronger than the old kind\n-                closure_kinds.insert(closure_def_id, new_kind);\n+                (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) |\n+                (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+                (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+                    // new kind is stronger than the old kind\n+                    self.temp_closure_kinds.insert(closure_id, new_kind);\n+                }\n             }\n         }\n     }"}, {"sha": "591753181db1203a8afba29ebacb62fafeee36ea", "filename": "src/test/compile-fail/issue-34349.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8ffc04b0325b0efc749121d03f92538daef37a11/src%2Ftest%2Fcompile-fail%2Fissue-34349.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ffc04b0325b0efc749121d03f92538daef37a11/src%2Ftest%2Fcompile-fail%2Fissue-34349.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-34349.rs?ref=8ffc04b0325b0efc749121d03f92538daef37a11", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a regression test for a problem encountered around upvar\n+// inference and trait caching: in particular, we were entering a\n+// temporary closure kind during inference, and then caching results\n+// based on that temporary kind, which led to no error being reported\n+// in this particular test.\n+\n+fn main() {\n+    let inc = || {};\n+    inc();\n+\n+    fn apply<F>(f: F) where F: Fn() {\n+        f()\n+    }\n+\n+    let mut farewell = \"goodbye\".to_owned();\n+    let diary = || { //~ ERROR E0525\n+        farewell.push_str(\"!!!\");\n+        println!(\"Then I screamed {}.\", farewell);\n+    };\n+\n+    apply(diary);\n+}"}]}