{"sha": "b3e54d59911a82330adb63afdea58873e426e67e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZTU0ZDU5OTExYTgyMzMwYWRiNjNhZmRlYTU4ODczZTQyNmU2N2U=", "commit": {"author": {"name": "Edward Z. Yang", "email": "ezyang@cs.stanford.edu", "date": "2013-12-05T10:58:30Z"}, "committer": {"name": "Edward Z. Yang", "email": "ezyang@cs.stanford.edu", "date": "2013-12-10T05:24:47Z"}, "message": "Add some more commentary to FFI tutorial.\n\nSigned-off-by: Edward Z. Yang <ezyang@cs.stanford.edu>", "tree": {"sha": "6d327b0ff9924f06e69bef82094c1ef4ca4c9e3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d327b0ff9924f06e69bef82094c1ef4ca4c9e3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3e54d59911a82330adb63afdea58873e426e67e", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3e54d59911a82330adb63afdea58873e426e67e", "html_url": "https://github.com/rust-lang/rust/commit/b3e54d59911a82330adb63afdea58873e426e67e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3e54d59911a82330adb63afdea58873e426e67e/comments", "author": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ca4350c8d64facb39311660e8ee919766f481a", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ca4350c8d64facb39311660e8ee919766f481a", "html_url": "https://github.com/rust-lang/rust/commit/29ca4350c8d64facb39311660e8ee919766f481a"}], "stats": {"total": 35, "additions": 26, "deletions": 9}, "files": [{"sha": "0746728a0f5b35c7ede07374f776290d0d9ae86f", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b3e54d59911a82330adb63afdea58873e426e67e/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3e54d59911a82330adb63afdea58873e426e67e/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=b3e54d59911a82330adb63afdea58873e426e67e", "patch": "@@ -152,7 +152,7 @@ for the rust task is plenty for the C function to have.\n \n A planned future improvement (net yet implemented at the time of this writing)\n is to have a guard page at the end of every rust stack. No rust function will\n-hit this guard page (due to rust's usage of LLVM's __morestack). The intention\n+hit this guard page (due to Rust's usage of LLVM's `__morestack`). The intention\n for this unmapped page is to prevent infinite recursion in C from overflowing\n onto other rust stacks. If the guard page is hit, then the process will be\n terminated with a message saying that the guard page was hit.\n@@ -166,30 +166,39 @@ the stack of the task which is spawned.\n \n # Destructors\n \n-Foreign libraries often hand off ownership of resources to the calling code,\n-which should be wrapped in a destructor to provide safety and guarantee their\n-release.\n+Foreign libraries often hand off ownership of resources to the calling code.\n+When this occurs, we must use Rust's destructors to provide safety and guarantee\n+the release of these resources (especially in the case of failure).\n \n-A type with the same functionality as owned boxes can be implemented by\n-wrapping `malloc` and `free`:\n+As an example, we give a reimplementation of owned boxes by wrapping `malloc`\n+and `free`:\n \n ~~~~\n use std::cast;\n use std::libc::{c_void, size_t, malloc, free};\n use std::ptr;\n use std::unstable::intrinsics;\n \n-// a wrapper around the handle returned by the foreign code\n+// Define a wrapper around the handle returned by the foreign code.\n+// Unique<T> has the same semantics as ~T\n pub struct Unique<T> {\n+    // It contains a single raw, mutable pointer to the object in question.\n     priv ptr: *mut T\n }\n \n+// Implement methods for creating and using the values in the box.\n+// NB: For simplicity and correctness, we require that T has kind Send\n+// (owned boxes relax this restriction, and can contain managed (GC) boxes).\n+// This is because, as implemented, the garbage collector would not know\n+// about any shared boxes stored in the malloc'd region of memory.\n impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n         unsafe {\n             let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\n             assert!(!ptr::is_null(ptr));\n             // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\n+            // move_val_init moves a value into this memory without\n+            // attempting to drop the original value.\n             intrinsics::move_val_init(&mut *ptr, value);\n             Unique{ptr: ptr}\n         }\n@@ -206,12 +215,20 @@ impl<T: Send> Unique<T> {\n     }\n }\n \n+// The key ingredient for safety, we associate a destructor with\n+// Unique<T>, making the struct manage the raw pointer: when the\n+// struct goes out of scope, it will automatically free the raw pointer.\n+// NB: This is an unsafe destructor, because rustc will not normally\n+// allow destructors to be associated with parametrized types, due to\n+// bad interaction with managed boxes. (With the Send restriction,\n+// we don't have this problem.)\n #[unsafe_destructor]\n impl<T: Send> Drop for Unique<T> {\n     fn drop(&mut self) {\n         unsafe {\n-            let x = intrinsics::init(); // dummy value to swap in\n-            // moving the object out is needed to call the destructor\n+            let x = intrinsics::uninit(); // dummy value to swap in\n+            // We need to move the object out of the box, so that\n+            // the destructor is called (at the end of this scope.)\n             ptr::replace_ptr(self.ptr, x);\n             free(self.ptr as *c_void)\n         }"}]}