{"sha": "53e90c15a6e677f13981b58373f7427384a9188f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZTkwYzE1YTZlNjc3ZjEzOTgxYjU4MzczZjc0MjczODRhOTE4OGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T07:01:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T07:01:55Z"}, "message": "auto merge of #12614 : alexcrichton/rust/rollup, r=alexcrichton\n\nCloses #12546 (Add new target 'make dist-osx' to create a .pkg installer for OS X) r=brson\r\nCloses #12575 (rustc: Move local native libs back in link-args) r=brson\r\nCloses #12587 (Provide a more helpful error for tests that fail due to noexec) r=brson\r\nCloses #12589 (rustc: Remove codemap and reachable from metadata encoder) r=alexcrichton\r\nCloses #12591 (Fix syntax::ext::deriving{,::*} docs formatting.) r=huonw\r\nCloses #12592 (Miscellaneous Vim improvements) r=alexcrichton\r\nCloses #12596 (path: Implement windows::make_non_verbatim()) r=alexcrichton\r\nCloses #12598 (Improve the ctags function regular expression) r=alexcrichton\r\nCloses #12599 (Tutorial improvement (new variant of PR #12472).) r=pnkfelix\r\nCloses #12603 (std: Export the select! macro) r=pcwalton\r\nCloses #12605 (Fix typo in doc of Binary trait in std::fmt) r=alexcrichton\r\nCloses #12613 (Fix bytepos_to_file_charpos) r=brson", "tree": {"sha": "9ef3997a738750ed361c1a2335a3b606c8f5f40d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ef3997a738750ed361c1a2335a3b606c8f5f40d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53e90c15a6e677f13981b58373f7427384a9188f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53e90c15a6e677f13981b58373f7427384a9188f", "html_url": "https://github.com/rust-lang/rust/commit/53e90c15a6e677f13981b58373f7427384a9188f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53e90c15a6e677f13981b58373f7427384a9188f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "html_url": "https://github.com/rust-lang/rust/commit/f203fc7daf8d598a7eacee1a135f2fd92dc6382e"}, {"sha": "a8d57a26dfe1c8e44e9af1923c900f147d13889b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d57a26dfe1c8e44e9af1923c900f147d13889b", "html_url": "https://github.com/rust-lang/rust/commit/a8d57a26dfe1c8e44e9af1923c900f147d13889b"}], "stats": {"total": 505, "additions": 407, "deletions": 98}, "files": [{"sha": "17afeaae37732cbc4f7e336aa9ce2501b652866d", "filename": "mk/dist.mk", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -12,6 +12,10 @@ PKG_ICO = $(S)src/etc/pkg/rust-logo.ico\n PKG_EXE = $(PKG_DIR)-install.exe\n endif\n \n+ifeq ($(CFG_OSTYPE), apple-darwin)\n+PKG_OSX = $(PKG_DIR).pkg\n+endif\n+\n PKG_GITMODULES := $(S)src/libuv $(S)src/llvm $(S)src/gyp $(S)src/compiler-rt\n \n PKG_FILES := \\\n@@ -41,10 +45,10 @@ PKG_FILES := \\\n \n UNROOTED_PKG_FILES := $(patsubst $(S)%,./%,$(PKG_FILES))\n \n-ifdef CFG_ISCC\n LICENSE.txt: $(S)COPYRIGHT $(S)LICENSE-APACHE $(S)LICENSE-MIT\n \tcat $^ > $@\n \n+ifdef CFG_ISCC\n %.iss: $(S)src/etc/pkg/%.iss\n \tcp $< $@\n \n@@ -103,7 +107,7 @@ distcheck: dist\n \n else\n \n-dist: $(PKG_TAR)\n+dist: $(PKG_TAR) $(PKG_OSX)\n \n distcheck: $(PKG_TAR)\n \t$(Q)rm -Rf dist\n@@ -124,3 +128,31 @@ distcheck: $(PKG_TAR)\n \t@echo -----------------------------------------------\n \n endif\n+\n+ifeq ($(CFG_OSTYPE), apple-darwin)\n+\n+dist-prepare-osx: PREPARE_HOST=$(CFG_BUILD)\n+dist-prepare-osx: PREPARE_TARGETS=$(CFG_BUILD)\n+dist-prepare-osx: PREPARE_DEST_DIR=tmp/dist/pkgroot\n+dist-prepare-osx: PREPARE_STAGE=2\n+dist-prepare-osx: PREPARE_DIR_CMD=$(DEFAULT_PREPARE_DIR_CMD)\n+dist-prepare-osx: PREPARE_BIN_CMD=$(DEFAULT_PREPARE_BIN_CMD)\n+dist-prepare-osx: PREPARE_LIB_CMD=$(DEFAULT_PREPARE_LIB_CMD)\n+dist-prepare-osx: PREPARE_MAN_CMD=$(DEFAULT_PREPARE_MAN_CMD)\n+dist-prepare-osx: prepare-base\n+\n+$(PKG_OSX): Distribution.xml LICENSE.txt dist-prepare-osx\n+\t@$(call E, making OS X pkg)\n+\t$(Q)pkgbuild --identifier org.rust-lang.rust --root tmp/dist/pkgroot rust.pkg\n+\t$(Q)productbuild --distribution Distribution.xml --resources . $(PKG_OSX)\n+\t$(Q)rm -rf tmp rust.pkg\n+\n+dist-osx: $(PKG_OSX)\n+\n+distcheck-osx: $(PKG_OSX)\n+\t@echo\n+\t@echo -----------------------------------------------\n+\t@echo $(PKG_OSX) ready for distribution\n+\t@echo -----------------------------------------------\n+\n+endif"}, {"sha": "339e5552d7f6d150d354ada7f61ddfb182b8e84d", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -133,6 +133,10 @@ fn main() {\n     println!(\"hello?\");\n }\n ~~~~\n+> ***Note:*** An identifier followed by an exclamation point, like\n+> `println!`, is a macro invocation.  Macros are explained\n+> [later](#syntax-extensions); for now just remember to include the\n+> exclamation point.\n \n If the Rust compiler was installed successfully, running `rustc\n hello.rs` will produce an executable called `hello` (or `hello.exe` on\n@@ -1059,7 +1063,7 @@ box, while the owner holds onto a pointer to it:\n     list -> | Cons | 1 | ~ | -> | Cons | 2 | ~ | -> | Cons | 3 | ~ | -> | Nil          |\n             +--------------+    +--------------+    +--------------+    +--------------+\n \n-> Note: the above diagram shows the logical contents of the enum. The actual\n+> ***Note:*** the above diagram shows the logical contents of the enum. The actual\n > memory layout of the enum may vary. For example, for the `List` enum shown\n > above, Rust guarantees that there will be no enum tag field in the actual\n > structure. See the language reference for more details.\n@@ -1114,7 +1118,7 @@ let z = x; // no new memory allocated, `x` can no longer be used\n ~~~~\n \n The `clone` method is provided by the `Clone` trait, and can be derived for\n-our `List` type. Traits will be explained in detail later.\n+our `List` type. Traits will be explained in detail [later](#traits).\n \n ~~~{.ignore}\n #[deriving(Clone)]\n@@ -1207,8 +1211,8 @@ let ys = Cons(5, ~Cons(10, ~Nil));\n assert!(eq(&xs, &ys));\n ~~~\n \n-Note that Rust doesn't guarantee [tail-call](http://en.wikipedia.org/wiki/Tail_call) optimization,\n-but LLVM is able to handle a simple case like this with optimizations enabled.\n+> ***Note:*** Rust doesn't guarantee [tail-call](http://en.wikipedia.org/wiki/Tail_call) optimization,\n+> but LLVM is able to handle a simple case like this with optimizations enabled.\n \n ## Lists of other types\n \n@@ -1218,6 +1222,9 @@ element type.\n \n The `u32` in the previous definition can be substituted with a type parameter:\n \n+> ***Note:*** The following code introduces generics, which are explained in a\n+> [dedicated section](#generics).\n+\n ~~~\n enum List<T> {\n     Cons(T, ~List<T>),\n@@ -1336,10 +1343,14 @@ impl<T: Eq> Eq for List<T> {\n \n let xs = Cons(5, ~Cons(10, ~Nil));\n let ys = Cons(5, ~Cons(10, ~Nil));\n+// The methods below are part of the Eq trait,\n+// which we implemented on our linked list.\n assert!(xs.eq(&ys));\n-assert!(xs == ys);\n assert!(!xs.ne(&ys));\n-assert!(!(xs != ys));\n+\n+// The Eq trait also allows us to use the shorthand infix operators.\n+assert!(xs == ys);    // `xs == ys` is short for `xs.eq(&ys)`\n+assert!(!(xs != ys)); // `xs != ys` is short for `xs.ne(&ys)`\n ~~~\n \n # More on boxes"}, {"sha": "b42edf7579a644f790c1f9b4d462441e87ce26f9", "filename": "src/etc/ctags.rust", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Fetc%2Fctags.rust", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Fetc%2Fctags.rust", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fctags.rust?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -1,6 +1,6 @@\n --langdef=Rust\n --langmap=Rust:.rs\n---regex-Rust=/^[ \\t]*(pub[ \\t]+)?fn[ \\t]+([a-zA-Z0-9_]+)/\\2/f,functions,function definitions/\n+--regex-Rust=/^[ \\t]*(#\\[[^\\]]\\][ \\t]*)*(pub[ \\t]+)?(extern[ \\t]+)?(\"[^\"]+\"[ \\t]+)?(unsafe[ \\t]+)?fn[ \\t]+([a-zA-Z0-9_]+)/\\6/f,functions,function definitions/\n --regex-Rust=/^[ \\t]*(pub[ \\t]+)?type[ \\t]+([a-zA-Z0-9_]+)/\\2/T,types,type definitions/\n --regex-Rust=/^[ \\t]*(pub[ \\t]+)?enum[ \\t]+([a-zA-Z0-9_]+)/\\2/g,enum,enumeration names/\n --regex-Rust=/^[ \\t]*(pub[ \\t]+)?struct[ \\t]+([a-zA-Z0-9_]+)/\\2/s,structure names/"}, {"sha": "9c2e5d658843386fa019d2c5fabe56f1010a57cc", "filename": "src/etc/pkg/Distribution.xml", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Fetc%2Fpkg%2FDistribution.xml", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Fetc%2Fpkg%2FDistribution.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpkg%2FDistribution.xml?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -0,0 +1,22 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\n+<installer-gui-script minSpecVersion=\"2\">\n+    <title>Rust</title>\n+    <license file=\"LICENSE.txt\" mime-type=\"text/plain\"/>\n+    <pkg-ref id=\"org.rust-lang.rust\"/>\n+    <options customize=\"never\" require-scripts=\"false\" hostArchitectures=\"i386,x86_64\"/>\n+    <volume-check>\n+        <allowed-os-versions>\n+            <os-version min=\"10.7\"/>\n+        </allowed-os-versions>\n+    </volume-check>\n+    <choices-outline>\n+        <line choice=\"default\">\n+            <line choice=\"org.rust-lang.rust\"/>\n+        </line>\n+    </choices-outline>\n+    <choice id=\"default\"/>\n+    <choice id=\"org.rust-lang.rust\" visible=\"false\">\n+        <pkg-ref id=\"org.rust-lang.rust\"/>\n+    </choice>\n+    <pkg-ref id=\"org.rust-lang.rust\" version=\"0\" onConclusion=\"none\">rust.pkg</pkg-ref>\n+</installer-gui-script>"}, {"sha": "b70cda9b998c405ff372d89825f28f847e8b4384", "filename": "src/etc/vim/ftplugin/rust.vim", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -1,7 +1,7 @@\n \" Vim syntax file\n \" Language:     Rust\n \" Maintainer:   Chris Morgan <me@chrismorgan.info>\n-\" Last Change:  2013 Jul 10\n+\" Last Change:  2014 Feb 27\n \n if exists(\"b:did_ftplugin\")\n \tfinish\n@@ -42,4 +42,55 @@ if exists(\"g:loaded_delimitMate\")\n \tlet b:delimitMate_excluded_regions = delimitMate#Get(\"excluded_regions\") . ',rustLifetimeCandidate,rustGenericLifetimeCandidate'\n endif\n \n-let b:undo_ftplugin = \"setlocal formatoptions< comments< commentstring< includeexpr< suffixesadd< | if exists('b:rust_original_delimitMate_excluded_regions') | let b:delimitMate_excluded_regions = b:rust_original_delimitMate_excluded_regions | unlet b:rust_original_delimitMate_excluded_regions | elseif exists('b:delimitMate_excluded_regions') | unlet b:delimitMate_excluded_regions | endif\"\n+\" Bind motion commands to support hanging indents\n+nnoremap <silent> <buffer> [[ :call <SID>Rust_Jump('n', 'Back')<CR>\n+nnoremap <silent> <buffer> ]] :call <SID>Rust_Jump('n', 'Forward')<CR>\n+xnoremap <silent> <buffer> [[ :call <SID>Rust_Jump('v', 'Back')<CR>\n+xnoremap <silent> <buffer> ]] :call <SID>Rust_Jump('v', 'Forward')<CR>\n+onoremap <silent> <buffer> [[ :call <SID>Rust_Jump('o', 'Back')<CR>\n+onoremap <silent> <buffer> ]] :call <SID>Rust_Jump('o', 'Forward')<CR>\n+\n+let b:undo_ftplugin = \"\n+\t\t\\setlocal formatoptions< comments< commentstring< includeexpr< suffixesadd<\n+\t\t\\|if exists('b:rust_original_delimitMate_excluded_regions')\n+\t\t  \\|let b:delimitMate_excluded_regions = b:rust_original_delimitMate_excluded_regions\n+\t\t  \\|unlet b:rust_original_delimitMate_excluded_regions\n+\t\t\\|elseif exists('b:delimitMate_excluded_regions')\n+\t\t  \\|unlet b:delimitMate_excluded_regions\n+\t\t\\|endif\n+\t\t\\|nunmap <buffer> [[\n+\t\t\\|nunmap <buffer> ]]\n+\t\t\\|xunmap <buffer> [[\n+\t\t\\|xunmap <buffer> ]]\n+\t\t\\|ounmap <buffer> [[\n+\t\t\\|ounmap <buffer> ]]\n+\t\t\\\"\n+\n+if exists('*<SID>Rust_Jump') | finish | endif\n+\n+function! <SID>Rust_Jump(mode, function) range\n+\tlet cnt = v:count1\n+\tnormal! m'\n+\tif a:mode ==# 'v'\n+\t\tnorm! gv\n+\tendif\n+\tlet foldenable = &foldenable\n+\tset nofoldenable\n+\twhile cnt > 0\n+\t\texecute \"call <SID>Rust_Jump_\" . a:function . \"()\"\n+\t\tlet cnt = cnt - 1\n+\tendwhile\n+\tlet &foldenable = foldenable\n+endfunction\n+\n+function! <SID>Rust_Jump_Back()\n+\tcall search('{', 'b')\n+\tkeepjumps normal! w99[{\n+endfunction\n+\n+function! <SID>Rust_Jump_Forward()\n+\tnormal! j0\n+\tcall search('{', 'b')\n+\tkeepjumps normal! w99[{%\n+\tcall search('{')\n+endfunction"}, {"sha": "cc158bb44af379300f84e09c8bdbf3a2d19c5390", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -3,7 +3,7 @@\n \" Maintainer:   Patrick Walton <pcwalton@mozilla.com>\n \" Maintainer:   Ben Blum <bblum@cs.cmu.edu>\n \" Maintainer:   Chris Morgan <me@chrismorgan.info>\n-\" Last Change:  2014 Feb 14\n+\" Last Change:  2014 Feb 27\n \n if version < 600\n   syntax clear\n@@ -18,8 +18,8 @@ syn keyword   rustOperator    as\n \n syn match     rustAssert      \"\\<assert\\(\\w\\)*!\" contained\n syn match     rustFail        \"\\<fail\\(\\w\\)*!\" contained\n-syn keyword   rustKeyword     break continue do\n-syn keyword   rustKeyword     extern nextgroup=rustExternCrate skipwhite\n+syn keyword   rustKeyword     break continue\n+syn keyword   rustKeyword     extern nextgroup=rustExternCrate,rustObsoleteExternMod skipwhite\n syn keyword   rustKeyword     for in if impl let\n syn keyword   rustKeyword     loop once priv pub\n syn keyword   rustKeyword     return\n@@ -35,12 +35,13 @@ syn keyword   rustObsoleteStorage const\n syn keyword   rustInvalidBareKeyword crate\n \n syn keyword   rustExternCrate crate contained nextgroup=rustIdentifier skipwhite\n+syn keyword   rustObsoleteExternMod mod contained nextgroup=rustIdentifier skipwhite\n \n syn match     rustIdentifier  contains=rustIdentifierPrime \"\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\" display contained\n syn match     rustFuncName    \"\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\" display contained\n \n \" Reserved (but not yet used) keywords {{{2\n-syn keyword   rustReservedKeyword alignof be offsetof pure sizeof typeof yield\n+syn keyword   rustReservedKeyword alignof be do offsetof pure sizeof typeof yield\n \n \" Built-in types {{{2\n syn keyword   rustType        int uint float char bool u8 u16 u32 u64 f32\n@@ -51,8 +52,7 @@ syn keyword   rustType        f64 i8 i16 i32 i64 str Self\n \" to make it easy to update.\n \n \" Core operators {{{3\n-syn keyword   rustTrait       Sized\n-syn keyword   rustTrait       Freeze Send\n+syn keyword   rustTrait       Freeze Pod Send Sized\n syn keyword   rustTrait       Add Sub Mul Div Rem Neg Not\n syn keyword   rustTrait       BitAnd BitOr BitXor\n syn keyword   rustTrait       Drop\n@@ -63,32 +63,25 @@ syn keyword   rustEnum        Result\n syn keyword   rustEnumVariant Ok Err\n \n \" Functions {{{3\n-\"syn keyword rustFunction print println\n-\"syn keyword rustFunction range\n \"syn keyword rustFunction from_str\n+\"syn keyword rustFunction range\n+\"syn keyword rustFunction drop\n \n \" Types and traits {{{3\n syn keyword rustTrait Any AnyOwnExt AnyRefExt AnyMutRefExt\n syn keyword rustTrait Ascii AsciiCast OwnedAsciiCast AsciiStr IntoBytes\n-syn keyword rustTrait Bool\n syn keyword rustTrait ToCStr\n syn keyword rustTrait Char\n syn keyword rustTrait Clone DeepClone\n syn keyword rustTrait Eq Ord TotalEq TotalOrd Ordering Equiv\n syn keyword rustEnumVariant Less Equal Greater\n syn keyword rustTrait Container Mutable Map MutableMap Set MutableSet\n-syn keyword rustTrait Default\n-syn keyword rustTrait Hash\n-syn keyword rustTrait FromStr\n syn keyword rustTrait FromIterator Extendable\n syn keyword rustTrait Iterator DoubleEndedIterator RandomAccessIterator CloneableIterator\n syn keyword rustTrait OrdIterator MutableDoubleEndedIterator ExactSize\n-\n-syn keyword rustTrait Algebraic Trigonometric Exponential Hyperbolic\n-syn keyword rustTrait Bitwise Bounded Fractional\n-syn keyword rustTrait Num NumCast CheckedAdd CheckedSub CheckedMul CheckedDiv\n-syn keyword rustTrait Orderable Signed Unsigned Round\n-syn keyword rustTrait Primitive Int Float ToStrRadix ToPrimitive FromPrimitive\n+syn keyword rustTrait Num NumCast CheckedAdd CheckedSub CheckedMul\n+syn keyword rustTrait Signed Unsigned Round\n+syn keyword rustTrait Primitive Int Float ToPrimitive FromPrimitive\n syn keyword rustTrait GenericPath Path PosixPath WindowsPath\n syn keyword rustTrait RawPtr\n syn keyword rustTrait Buffer Writer Reader Seek\n@@ -98,20 +91,17 @@ syn keyword rustTrait Tuple1 Tuple2 Tuple3 Tuple4\n syn keyword rustTrait Tuple5 Tuple6 Tuple7 Tuple8\n syn keyword rustTrait Tuple9 Tuple10 Tuple11 Tuple12\n syn keyword rustTrait ImmutableEqVector ImmutableTotalOrdVector ImmutableCloneableVector\n-syn keyword rustTrait OwnedVector OwnedCloneableVector OwnedEqVector MutableVector\n+syn keyword rustTrait OwnedVector OwnedCloneableVector OwnedEqVector\n+syn keyword rustTrait MutableVector MutableTotalOrdVector\n syn keyword rustTrait Vector VectorVector CloneableVector ImmutableVector\n \n \"syn keyword rustFunction stream\n-syn keyword rustTrait Port Chan GenericChan GenericSmartChan GenericPort Peekable\n+syn keyword rustTrait Port Chan\n \"syn keyword rustFunction spawn\n \n syn keyword   rustSelf        self\n syn keyword   rustBoolean     true false\n \n-syn keyword   rustConstant    Some None       \" option\n-syn keyword   rustConstant    Ok Err          \" result\n-syn keyword   rustConstant    Less Equal Greater \" Ordering\n-\n \" Other syntax {{{2\n \n \" If foo::bar changes to foo.bar, change this (\"::\" to \"\\.\").\n@@ -247,6 +237,7 @@ hi def link rustObsoleteStorage Error\n hi def link rustLifetime      Special\n hi def link rustInvalidBareKeyword Error\n hi def link rustExternCrate   rustKeyword\n+hi def link rustObsoleteExternMod Error\n \n \" Other Suggestions:\n \" hi rustAttribute ctermfg=cyan"}, {"sha": "33d3a1c67f2e2a9af033d3801a2aecff586773ee", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -1132,8 +1132,41 @@ fn link_args(sess: Session,\n         args.push(~\"-Wl,--allow-multiple-definition\");\n     }\n \n-    add_local_native_libraries(&mut args, sess);\n+    // Take careful note of the ordering of the arguments we pass to the linker\n+    // here. Linkers will assume that things on the left depend on things to the\n+    // right. Things on the right cannot depend on things on the left. This is\n+    // all formally implemented in terms of resolving symbols (libs on the right\n+    // resolve unknown symbols of libs on the left, but not vice versa).\n+    //\n+    // For this reason, we have organized the arguments we pass to the linker as\n+    // such:\n+    //\n+    //  1. The local object that LLVM just generated\n+    //  2. Upstream rust libraries\n+    //  3. Local native libraries\n+    //  4. Upstream native libraries\n+    //\n+    // This is generally fairly natural, but some may expect 2 and 3 to be\n+    // swapped. The reason that all native libraries are put last is that it's\n+    // not recommended for a native library to depend on a symbol from a rust\n+    // crate. If this is the case then a staticlib crate is recommended, solving\n+    // the problem.\n+    //\n+    // Additionally, it is occasionally the case that upstream rust libraries\n+    // depend on a local native library. In the case of libraries such as\n+    // lua/glfw/etc the name of the library isn't the same across all platforms,\n+    // so only the consumer crate of a library knows the actual name. This means\n+    // that downstream crates will provide the #[link] attribute which upstream\n+    // crates will depend on. Hence local native libraries are after out\n+    // upstream rust crates.\n+    //\n+    // In theory this means that a symbol in an upstream native library will be\n+    // shadowed by a local native library when it wouldn't have been before, but\n+    // this kind of behavior is pretty platform specific and generally not\n+    // recommended anyway, so I don't think we're shooting ourself in the foot\n+    // much with that.\n     add_upstream_rust_crates(&mut args, sess, dylib, tmpdir);\n+    add_local_native_libraries(&mut args, sess);\n     add_upstream_native_libraries(&mut args, sess);\n \n     // # Telling the linker what we're doing"}, {"sha": "285a7411270fff896675da0bf6f4240cfcacdedc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -40,7 +40,6 @@ use syntax::ast_util::*;\n use syntax::ast_util;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n-use syntax::codemap;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::InternedString;\n use syntax::parse::token::special_idents;\n@@ -73,8 +72,6 @@ pub struct EncodeParams<'a> {\n     link_meta: &'a LinkMeta,\n     cstore: @cstore::CStore,\n     encode_inlined_item: EncodeInlinedItem<'a>,\n-    reachable: @RefCell<HashSet<ast::NodeId>>,\n-    codemap: @codemap::CodeMap,\n }\n \n struct Stats {\n@@ -104,13 +101,6 @@ pub struct EncodeContext<'a> {\n     cstore: &'a cstore::CStore,\n     encode_inlined_item: EncodeInlinedItem<'a>,\n     type_abbrevs: abbrev_map,\n-    reachable: @RefCell<HashSet<ast::NodeId>>,\n-    codemap: @codemap::CodeMap,\n-}\n-\n-pub fn reachable(ecx: &EncodeContext, id: NodeId) -> bool {\n-    let reachable = ecx.reachable.borrow();\n-    reachable.get().contains(&id)\n }\n \n fn encode_name(ebml_w: &mut writer::Encoder, name: Name) {\n@@ -1630,7 +1620,7 @@ impl<'a, 'b> Visitor<()> for MacroDefVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n             ItemMac(..) => {\n-                let def = self.ecx.codemap.span_to_snippet(item.span)\n+                let def = self.ecx.tcx.sess.codemap.span_to_snippet(item.span)\n                     .expect(\"Unable to find source for macro\");\n                 self.ebml_w.start_tag(tag_macro_def);\n                 self.ebml_w.wr_str(def);\n@@ -1796,9 +1786,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         cstore,\n         encode_inlined_item,\n         link_meta,\n-        reachable,\n         non_inlineable_statics,\n-        codemap,\n         ..\n     } = parms;\n     let type_abbrevs = @RefCell::new(HashMap::new());\n@@ -1814,8 +1802,6 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         cstore: cstore,\n         encode_inlined_item: encode_inlined_item,\n         type_abbrevs: type_abbrevs,\n-        reachable: reachable,\n-        codemap: codemap,\n      };\n \n     let mut ebml_w = writer::Encoder(wr);"}, {"sha": "6a7694b2b81a1aa1dfb698f40987776630b33c4e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -2552,8 +2552,6 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeI\n             link_meta: link_meta,\n             cstore: cx.sess.cstore,\n             encode_inlined_item: ie,\n-            reachable: cx.reachable,\n-            codemap: cx.sess.codemap,\n         }\n }\n "}, {"sha": "ab90b27a0dee3faf3063926817eb0b269022c166", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n+use std::io;\n use std::io::Process;\n use std::local_data;\n use std::os;\n@@ -128,7 +129,10 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool)\n     let exe = outdir.path().join(\"rust_out\");\n     let out = Process::output(exe.as_str().unwrap(), []);\n     match out {\n-        Err(e) => fail!(\"couldn't run the test: {}\", e),\n+        Err(e) => fail!(\"couldn't run the test: {}{}\", e,\n+                        if e.kind == io::PermissionDenied {\n+                            \" - maybe your tempdir is mounted with noexec?\"\n+                        } else { \"\" }),\n         Ok(out) => {\n             if should_fail && out.status.success() {\n                 fail!(\"test executable succeeded when it should have failed\");"}, {"sha": "75e7265705a77ededc0acdf8b35cfc08d999fcf1", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -58,22 +58,6 @@ use rt::task::{Task, BlockedTask};\n use super::Port;\n use uint;\n \n-macro_rules! select {\n-    (\n-        $($name:pat = $port:ident.$meth:ident() => $code:expr),+\n-    ) => ({\n-        use std::comm::Select;\n-        let sel = Select::new();\n-        $( let mut $port = sel.handle(&$port); )+\n-        unsafe {\n-            $( $port.add(); )+\n-        }\n-        let ret = sel.wait();\n-        $( if ret == $port.id() { let $name = $port.$meth(); $code } else )+\n-        { unreachable!() }\n-    })\n-}\n-\n /// The \"port set\" of the select interface. This structure is used to manage a\n /// set of ports which are being selected over.\n pub struct Select {"}, {"sha": "bdc1aa75c9419340109a943d7fb6f79cb5362cea", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -580,7 +580,7 @@ pub trait Unsigned { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `o` character\n #[allow(missing_doc)]\n pub trait Octal { fn fmt(&self, &mut Formatter) -> Result; }\n-/// Format trait for the `b` character\n+/// Format trait for the `t` character\n #[allow(missing_doc)]\n pub trait Binary { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `x` character"}, {"sha": "e16d944fb462888925b095d97ed9f93a9272325a", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -368,3 +368,47 @@ macro_rules! vec(\n     })\n )\n \n+\n+/// A macro to select an event from a number of ports.\n+///\n+/// This macro is used to wait for the first event to occur on a number of\n+/// ports. It places no restrictions on the types of ports given to this macro,\n+/// this can be viewed as a heterogeneous select.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let (p1, c1) = Chan::new();\n+/// let (p2, c2) = Chan::new();\n+/// # fn long_running_task() {}\n+/// # fn calculate_the_answer() -> int { 42 }\n+///\n+/// spawn(proc() { long_running_task(); c1.send(()) });\n+/// spawn(proc() { c2.send(calculate_the_answer()) });\n+///\n+/// select! (\n+///     () = p1.recv() => println!(\"the long running task finished first\"),\n+///     answer = p2.recv() => {\n+///         println!(\"the answer was: {}\", answer);\n+///     }\n+/// )\n+/// ```\n+///\n+/// For more information about select, see the `std::comm::Select` structure.\n+#[macro_export]\n+#[experimental]\n+macro_rules! select {\n+    (\n+        $($name:pat = $port:ident.$meth:ident() => $code:expr),+\n+    ) => ({\n+        use std::comm::Select;\n+        let sel = Select::new();\n+        $( let mut $port = sel.handle(&$port); )+\n+        unsafe {\n+            $( $port.add(); )+\n+        }\n+        let ret = sel.wait();\n+        $( if ret == $port.id() { let $name = $port.$meth(); $code } else )+\n+        { unreachable!() }\n+    })\n+}"}, {"sha": "864cdebe1a0909f093f8cf19f612291c426d2047", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -865,12 +865,44 @@ pub fn prefix(path: &Path) -> Option<PathPrefix> {\n     path.prefix\n }\n \n-/// Returns whether the Path's prefix is a verbatim prefix, i.e. \\\\?\\\n+/// Returns whether the Path's prefix is a verbatim prefix, i.e. `\\\\?\\`\n #[inline]\n pub fn is_verbatim(path: &Path) -> bool {\n     prefix_is_verbatim(path.prefix)\n }\n \n+/// Returns the non-verbatim equivalent of the input path, if possible.\n+/// If the input path is a device namespace path, None is returned.\n+/// If the input path is not verbatim, it is returned as-is.\n+/// If the input path is verbatim, but the same path can be expressed as\n+/// non-verbatim, the non-verbatim version is returned.\n+/// Otherwise, None is returned.\n+pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n+    let new_path = match path.prefix {\n+        Some(VerbatimPrefix(_)) | Some(DeviceNSPrefix(_)) => return None,\n+        Some(UNCPrefix(_,_)) | Some(DiskPrefix) | None => return Some(path.clone()),\n+        Some(VerbatimDiskPrefix) => {\n+            // \\\\?\\D:\\\n+            Path::new(path.repr.slice_from(4))\n+        }\n+        Some(VerbatimUNCPrefix(_,_)) => {\n+            // \\\\?\\UNC\\server\\share\n+            Path::new(format!(r\"\\\\{}\", path.repr.slice_from(7)))\n+        }\n+    };\n+    if new_path.prefix.is_none() {\n+        // \\\\?\\UNC\\server is a VerbatimUNCPrefix\n+        // but \\\\server is nothing\n+        return None;\n+    }\n+    // now ensure normalization didn't change anything\n+    if path.repr.slice_from(path.prefix_len()) == new_path.repr.slice_from(new_path.prefix_len()) {\n+        Some(new_path)\n+    } else {\n+        None\n+    }\n+}\n+\n /// The standard path separator character\n pub static SEP: char = '\\\\';\n /// The standard path separator byte\n@@ -926,7 +958,6 @@ pub enum PathPrefix {\n     DiskPrefix\n }\n \n-// FIXME (#8169): Make private once visibility is fixed\n fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n     if path.starts_with(\"\\\\\\\\\") {\n         // \\\\\n@@ -2285,4 +2316,38 @@ mod tests {\n         t!(s: \".\", [b!(\".\")]);\n         // since this is really a wrapper around str_components, those tests suffice\n     }\n+\n+    #[test]\n+    fn test_make_non_verbatim() {\n+        macro_rules! t(\n+            ($path:expr, $exp:expr) => (\n+                {\n+                    let path = Path::new($path);\n+                    let exp: Option<&str> = $exp;\n+                    let exp = exp.map(|s| Path::new(s));\n+                    assert_eq!(make_non_verbatim(&path), exp);\n+                }\n+            )\n+        )\n+\n+        t!(r\"\\a\\b\\c\", Some(r\"\\a\\b\\c\"));\n+        t!(r\"a\\b\\c\", Some(r\"a\\b\\c\"));\n+        t!(r\"C:\\a\\b\\c\", Some(r\"C:\\a\\b\\c\"));\n+        t!(r\"C:a\\b\\c\", Some(r\"C:a\\b\\c\"));\n+        t!(r\"\\\\server\\share\\foo\", Some(r\"\\\\server\\share\\foo\"));\n+        t!(r\"\\\\.\\foo\", None);\n+        t!(r\"\\\\?\\foo\", None);\n+        t!(r\"\\\\?\\C:\", None);\n+        t!(r\"\\\\?\\C:foo\", None);\n+        t!(r\"\\\\?\\C:\\\", Some(r\"C:\\\"));\n+        t!(r\"\\\\?\\C:\\foo\", Some(r\"C:\\foo\"));\n+        t!(r\"\\\\?\\C:\\foo\\bar\\baz\", Some(r\"C:\\foo\\bar\\baz\"));\n+        t!(r\"\\\\?\\C:\\foo\\.\\bar\\baz\", None);\n+        t!(r\"\\\\?\\C:\\foo\\bar\\..\\baz\", None);\n+        t!(r\"\\\\?\\C:\\foo\\bar\\..\", None);\n+        t!(r\"\\\\?\\UNC\\server\\share\\foo\", Some(r\"\\\\server\\share\\foo\"));\n+        t!(r\"\\\\?\\UNC\\server\\share\", Some(r\"\\\\server\\share\"));\n+        t!(r\"\\\\?\\UNC\\server\", None);\n+        t!(r\"\\\\?\\UNC\\server\\\", None);\n+    }\n }"}, {"sha": "7b70e14e802e254291ffc78277e803d19ffb0b5b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 52, "deletions": 10, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -420,10 +420,10 @@ impl CodeMap {\n     fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n-        let chpos = self.bytepos_to_charpos(pos);\n+        let chpos = self.bytepos_to_file_charpos(pos);\n         let lines = f.lines.borrow();\n         let linebpos = lines.get()[a];\n-        let linechpos = self.bytepos_to_charpos(linebpos);\n+        let linechpos = self.bytepos_to_file_charpos(linebpos);\n         debug!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n         debug!(\"codemap: char pos {:?} is on the line at char pos {:?}\",\n@@ -446,8 +446,8 @@ impl CodeMap {\n         return FileMapAndBytePos {fm: fm, pos: offset};\n     }\n \n-    // Converts an absolute BytePos to a CharPos relative to the codemap.\n-    fn bytepos_to_charpos(&self, bpos: BytePos) -> CharPos {\n+    // Converts an absolute BytePos to a CharPos relative to the filemap.\n+    fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n         debug!(\"codemap: converting {:?} to char pos\", bpos);\n         let idx = self.lookup_filemap_idx(bpos);\n         let files = self.files.borrow();\n@@ -471,7 +471,8 @@ impl CodeMap {\n             }\n         }\n \n-        CharPos(bpos.to_uint() - total_extra_bytes)\n+        assert!(map.start_pos.to_uint() + total_extra_bytes <= bpos.to_uint());\n+        CharPos(bpos.to_uint() - map.start_pos.to_uint() - total_extra_bytes)\n     }\n }\n \n@@ -501,7 +502,7 @@ mod test {\n         fm.next_line(BytePos(2));\n     }\n \n-    fn init_code_map() ->CodeMap {\n+    fn init_code_map() -> CodeMap {\n         let cm = CodeMap::new();\n         let fm1 = cm.new_filemap(~\"blork.rs\",~\"first line.\\nsecond line\");\n         let fm2 = cm.new_filemap(~\"empty.rs\",~\"\");\n@@ -532,14 +533,14 @@ mod test {\n \n     #[test]\n     fn t4() {\n-        // Test bytepos_to_charpos\n+        // Test bytepos_to_file_charpos\n         let cm = init_code_map();\n \n-        let cp1 = cm.bytepos_to_charpos(BytePos(22));\n+        let cp1 = cm.bytepos_to_file_charpos(BytePos(22));\n         assert_eq!(cp1, CharPos(22));\n \n-        let cp2 = cm.bytepos_to_charpos(BytePos(23));\n-        assert_eq!(cp2, CharPos(23));\n+        let cp2 = cm.bytepos_to_file_charpos(BytePos(23));\n+        assert_eq!(cp2, CharPos(0));\n     }\n \n     #[test]\n@@ -557,4 +558,45 @@ mod test {\n         assert_eq!(loc2.line, 1);\n         assert_eq!(loc2.col, CharPos(0));\n     }\n+\n+    fn init_code_map_mbc() -> CodeMap {\n+        let cm = CodeMap::new();\n+        // \u20ac is a three byte utf8 char.\n+        let fm1 = cm.new_filemap(~\"blork.rs\",~\"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\");\n+        let fm2 = cm.new_filemap(~\"blork2.rs\",~\"first line\u20ac\u20ac.\\n\u20ac second line\");\n+\n+        fm1.next_line(BytePos(0));\n+        fm1.next_line(BytePos(22));\n+        fm2.next_line(BytePos(39));\n+        fm2.next_line(BytePos(57));\n+\n+        fm1.record_multibyte_char(BytePos(3), 3);\n+        fm1.record_multibyte_char(BytePos(9), 3);\n+        fm1.record_multibyte_char(BytePos(12), 3);\n+        fm1.record_multibyte_char(BytePos(15), 3);\n+        fm1.record_multibyte_char(BytePos(18), 3);\n+        fm2.record_multibyte_char(BytePos(49), 3);\n+        fm2.record_multibyte_char(BytePos(52), 3);\n+        fm2.record_multibyte_char(BytePos(57), 3);\n+\n+        cm\n+    }\n+\n+    #[test]\n+    fn t6() {\n+        // Test bytepos_to_file_charpos in the presence of multi-byte chars\n+        let cm = init_code_map_mbc();\n+\n+        let cp1 = cm.bytepos_to_file_charpos(BytePos(3));\n+        assert_eq!(cp1, CharPos(3));\n+\n+        let cp2 = cm.bytepos_to_file_charpos(BytePos(6));\n+        assert_eq!(cp2, CharPos(4));\n+\n+        let cp3 = cm.bytepos_to_file_charpos(BytePos(55));\n+        assert_eq!(cp3, CharPos(12));\n+\n+        let cp4 = cm.bytepos_to_file_charpos(BytePos(60));\n+        assert_eq!(cp4, CharPos(15));\n+    }\n }"}, {"sha": "7aaa66cbfb5de9cbfac5e10dd4e97c33a5271a1b", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n /*!\n-The compiler code necessary for #[deriving(Decodable)]. See\n+The compiler code necessary for `#[deriving(Decodable)]`. See\n encodable.rs for more.\n */\n "}, {"sha": "ae23013b7ccc67550a7b3e01c2710b4dae59cec8", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -10,20 +10,20 @@\n \n /*!\n \n-The compiler code necessary to implement the #[deriving(Encodable)]\n-(and Decodable, in decodable.rs) extension.  The idea here is that\n-type-defining items may be tagged with #[deriving(Encodable,\n-Decodable)].\n+The compiler code necessary to implement the `#[deriving(Encodable)]`\n+(and `Decodable`, in decodable.rs) extension.  The idea here is that\n+type-defining items may be tagged with `#[deriving(Encodable, Decodable)]`.\n \n For example, a type like:\n \n ```ignore\n-    #[deriving(Encodable, Decodable)]\n-    struct Node {id: uint}\n+#[deriving(Encodable, Decodable)]\n+struct Node { id: uint }\n ```\n \n would generate two implementations like:\n \n+```ignore\n impl<S:serialize::Encoder> Encodable<S> for Node {\n     fn encode(&self, s: &S) {\n         s.emit_struct(\"Node\", 1, || {\n@@ -41,13 +41,14 @@ impl<D:Decoder> Decodable for node_id {\n         })\n     }\n }\n+```\n \n Other interesting scenarios are whe the item has type parameters or\n references other non-built-in types.  A type definition like:\n \n ```ignore\n-    #[deriving(Encodable, Decodable)]\n-    struct spanned<T> {node: T, span: Span}\n+#[deriving(Encodable, Decodable)]\n+struct spanned<T> { node: T, span: Span }\n ```\n \n would yield functions like:"}, {"sha": "24d4efb1b0e68bcc57f7dd44c70107564ab6ea6b", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -16,6 +16,7 @@ access to the fields of the 4 different sorts of structs and enum\n variants, as well as creating the method and impl ast instances.\n \n Supported features (fairly exhaustive):\n+\n - Methods taking any number of parameters of any type, and returning\n   any type, other than vectors, bottom and closures.\n - Generating `impl`s for types with type parameters and lifetimes\n@@ -59,7 +60,7 @@ associated with. It is only not `None` when the associated field has\n an identifier in the source code. For example, the `x`s in the\n following snippet\n \n-~~~notrust\n+```rust\n struct A { x : int }\n \n struct B(int);\n@@ -68,7 +69,7 @@ enum C {\n     C0(int),\n     C1 { x: int }\n }\n-~~~\n+```\n \n The `int`s in `B` and `C0` don't have an identifier, so the\n `Option<ident>`s would be `None` for them.\n@@ -83,7 +84,7 @@ variants, it is represented as a count of 0.\n \n The following simplified `Eq` is used for in-code examples:\n \n-~~~notrust\n+```rust\n trait Eq {\n     fn eq(&self, other: &Self);\n }\n@@ -92,7 +93,7 @@ impl Eq for int {\n         *self == *other\n     }\n }\n-~~~\n+```\n \n Some examples of the values of `SubstructureFields` follow, using the\n above `Eq`, `A`, `B` and `C`."}, {"sha": "28f039f0818123b4bd7491a0da8b22fe67e88d0e", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n /*!\n-The compiler code necessary to implement the #[deriving] extensions.\n+The compiler code necessary to implement the `#[deriving]` extensions.\n \n \n-FIXME (#2810)--Hygiene. Search for \"__\" strings (in other files too).\n+FIXME (#2810): hygiene. Search for \"__\" strings (in other files too).\n We also assume \"extra\" is the standard library, and \"std\" is the core\n library.\n "}, {"sha": "e864ee0058c7e3da5be9864bbbced3b2b20629c6", "filename": "src/test/run-make/issue-12446/Makefile", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Ftest%2Frun-make%2Fissue-12446%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Ftest%2Frun-make%2Fissue-12446%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-12446%2FMakefile?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -0,0 +1,6 @@\n+-include ../tools.mk\n+\n+all: $(call STATICLIB,foo)\n+\t$(RUSTC) foo.rs\n+\t$(RUSTC) bar.rs\n+\t$(call RUN,bar)"}, {"sha": "cd41058744d5a5d9c15b4848fa38b40ecd647e6c", "filename": "src/test/run-make/issue-12446/bar.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Ftest%2Frun-make%2Fissue-12446%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Ftest%2Frun-make%2Fissue-12446%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-12446%2Fbar.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate foo;\n+\n+#[link(name = \"foo\")]\n+extern {}\n+\n+fn main() {\n+    foo::foo();\n+}"}, {"sha": "a58cd8bb7c98f32cba0afd0b60a4082884f01203", "filename": "src/test/run-make/issue-12446/foo.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Ftest%2Frun-make%2Fissue-12446%2Ffoo.c", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Ftest%2Frun-make%2Fissue-12446%2Ffoo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-12446%2Ffoo.c?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -0,0 +1 @@\n+void some_c_symbol() {}"}, {"sha": "f16dd5e1d5c30785d258dbc7b9e1219862d9b3d0", "filename": "src/test/run-make/issue-12446/foo.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/53e90c15a6e677f13981b58373f7427384a9188f/src%2Ftest%2Frun-make%2Fissue-12446%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e90c15a6e677f13981b58373f7427384a9188f/src%2Ftest%2Frun-make%2Fissue-12446%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-12446%2Ffoo.rs?ref=53e90c15a6e677f13981b58373f7427384a9188f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_type = \"rlib\"];\n+\n+extern {\n+    fn some_c_symbol();\n+}\n+\n+pub fn foo() {\n+    unsafe { some_c_symbol() }\n+}"}]}