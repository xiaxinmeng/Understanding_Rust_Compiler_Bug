{"sha": "21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxYmExZDVlNTgxNDRjODMwOTNhOGNiYjQ2N2E2YzljYjEyZmM0YTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-01T21:56:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-01T21:56:53Z"}, "message": "auto merge of #19405 : jfager/rust/de-match-pyramid, r=bstrie\n\nNo semantic changes, no enabling `if let` where it wasn't already enabled.", "tree": {"sha": "c2855394846b767303ca815487cbbf81be608f4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2855394846b767303ca815487cbbf81be608f4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "html_url": "https://github.com/rust-lang/rust/commit/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de95ad4c46788518822326941bdc5084b1023abf", "url": "https://api.github.com/repos/rust-lang/rust/commits/de95ad4c46788518822326941bdc5084b1023abf", "html_url": "https://github.com/rust-lang/rust/commit/de95ad4c46788518822326941bdc5084b1023abf"}, {"sha": "a779e3b5c432c341b0e32d588d966199d3be9c27", "url": "https://api.github.com/repos/rust-lang/rust/commits/a779e3b5c432c341b0e32d588d966199d3be9c27", "html_url": "https://github.com/rust-lang/rust/commit/a779e3b5c432c341b0e32d588d966199d3be9c27"}], "stats": {"total": 2264, "additions": 895, "deletions": 1369}, "files": [{"sha": "aa99fe996f02ab9ed37564cbd99cd43bc22744c2", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 86, "deletions": 153, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -61,23 +61,13 @@ impl LintPass for WhileTrue {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        match e.node {\n-            ast::ExprWhile(ref cond, _, _) => {\n-                match cond.node {\n-                    ast::ExprLit(ref lit) => {\n-                        match lit.node {\n-                            ast::LitBool(true) => {\n-                                cx.span_lint(WHILE_TRUE, e.span,\n-                                             \"denote infinite loops with loop \\\n-                                              { ... }\");\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                    _ => ()\n+        if let ast::ExprWhile(ref cond, _, _) = e.node {\n+            if let ast::ExprLit(ref lit) = cond.node {\n+                if let ast::LitBool(true) = lit.node {\n+                    cx.span_lint(WHILE_TRUE, e.span,\n+                                 \"denote infinite loops with loop { ... }\");\n                 }\n             }\n-            _ => ()\n         }\n     }\n }\n@@ -93,14 +83,11 @@ impl LintPass for UnusedCasts {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        match e.node {\n-            ast::ExprCast(ref expr, ref ty) => {\n-                let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &**ty);\n-                if ty::expr_ty(cx.tcx, &**expr) == t_t {\n-                    cx.span_lint(UNUSED_TYPECASTS, ty.span, \"unnecessary type cast\");\n-                }\n+        if let ast::ExprCast(ref expr, ref ty) = e.node {\n+            let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &**ty);\n+            if ty::expr_ty(cx.tcx, &**expr) == t_t {\n+                cx.span_lint(UNUSED_TYPECASTS, ty.span, \"unnecessary type cast\");\n             }\n-            _ => ()\n         }\n     }\n }\n@@ -540,9 +527,8 @@ struct RawPtrDerivingVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for RawPtrDerivingVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n         static MSG: &'static str = \"use of `#[deriving]` with a raw pointer\";\n-        match ty.node {\n-            ast::TyPtr(..) => self.cx.span_lint(RAW_POINTER_DERIVING, ty.span, MSG),\n-            _ => {}\n+        if let ast::TyPtr(..) = ty.node {\n+            self.cx.span_lint(RAW_POINTER_DERIVING, ty.span, MSG);\n         }\n         visit::walk_ty(self, ty);\n     }\n@@ -720,9 +706,8 @@ impl LintPass for UnusedResults {\n             _ => return\n         };\n \n-        match expr.node {\n-            ast::ExprRet(..) => return,\n-            _ => {}\n+        if let ast::ExprRet(..) = expr.node {\n+            return;\n         }\n \n         let t = ty::expr_ty(cx.tcx, expr);\n@@ -733,11 +718,8 @@ impl LintPass for UnusedResults {\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n-                    match cx.tcx.map.get(did.node) {\n-                        ast_map::NodeItem(it) => {\n-                            warned |= check_must_use(cx, it.attrs.as_slice(), s.span);\n-                        }\n-                        _ => {}\n+                    if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n+                        warned |= check_must_use(cx, it.attrs.as_slice(), s.span);\n                     }\n                 } else {\n                     csearch::get_item_attrs(&cx.sess().cstore, did, |attrs| {\n@@ -969,11 +951,8 @@ impl LintPass for NonSnakeCase {\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        match it.node {\n-            ast::ItemMod(_) => {\n-                self.check_snake_case(cx, \"module\", it.ident, it.span);\n-            }\n-            _ => {}\n+        if let ast::ItemMod(_) = it.node {\n+            self.check_snake_case(cx, \"module\", it.ident, it.span);\n         }\n     }\n \n@@ -986,27 +965,18 @@ impl LintPass for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n-        match &p.node {\n-            &ast::PatIdent(_, ref path1, _) => {\n-                match cx.tcx.def_map.borrow().get(&p.id) {\n-                    Some(&def::DefLocal(_)) => {\n-                        self.check_snake_case(cx, \"variable\", path1.node, p.span);\n-                    }\n-                    _ => {}\n-                }\n+        if let &ast::PatIdent(_, ref path1, _) = &p.node {\n+            if let Some(&def::DefLocal(_)) = cx.tcx.def_map.borrow().get(&p.id) {\n+                self.check_snake_case(cx, \"variable\", path1.node, p.span);\n             }\n-            _ => {}\n         }\n     }\n \n     fn check_struct_def(&mut self, cx: &Context, s: &ast::StructDef,\n             _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n         for sf in s.fields.iter() {\n-            match sf.node {\n-                ast::StructField_ { kind: ast::NamedField(ident, _), .. } => {\n-                    self.check_snake_case(cx, \"structure field\", ident, sf.span);\n-                }\n-                _ => {}\n+            if let ast::StructField_ { kind: ast::NamedField(ident, _), .. } = sf.node {\n+                self.check_snake_case(cx, \"structure field\", ident, sf.span);\n             }\n         }\n     }\n@@ -1069,16 +1039,13 @@ pub struct UnusedParens;\n impl UnusedParens {\n     fn check_unused_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n                                      struct_lit_needs_parens: bool) {\n-        match value.node {\n-            ast::ExprParen(ref inner) => {\n-                let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n-                if !necessary {\n-                    cx.span_lint(UNUSED_PARENS, value.span,\n-                                 format!(\"unnecessary parentheses around {}\",\n-                                         msg).as_slice())\n-                }\n+        if let ast::ExprParen(ref inner) = value.node {\n+            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n+            if !necessary {\n+                cx.span_lint(UNUSED_PARENS, value.span,\n+                             format!(\"unnecessary parentheses around {}\",\n+                                     msg).as_slice())\n             }\n-            _ => {}\n         }\n \n         /// Expressions that syntactically contain an \"exterior\" struct\n@@ -1201,24 +1168,19 @@ impl LintPass for NonShorthandFieldPatterns {\n \n     fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n         let def_map = cx.tcx.def_map.borrow();\n-        match pat.node {\n-            ast::PatStruct(_, ref v, _) => {\n-                for fieldpat in v.iter()\n-                                 .filter(|fieldpat| !fieldpat.node.is_shorthand)\n-                                 .filter(|fieldpat| def_map.get(&fieldpat.node.pat.id)\n-                                    == Some(&def::DefLocal(fieldpat.node.pat.id))) {\n-                    match fieldpat.node.pat.node {\n-                        ast::PatIdent(_, ident, None) if ident.node.as_str()\n-                                                         == fieldpat.node.ident.as_str() => {\n-                            cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n-                                         format!(\"the `{}:` in this pattern is redundant and can \\\n-                                                  be removed\", ident.node.as_str()).as_slice())\n-                        },\n-                        _ => {},\n+        if let ast::PatStruct(_, ref v, _) = pat.node {\n+            for fieldpat in v.iter()\n+                             .filter(|fieldpat| !fieldpat.node.is_shorthand)\n+                             .filter(|fieldpat| def_map.get(&fieldpat.node.pat.id)\n+                                                == Some(&def::DefLocal(fieldpat.node.pat.id))) {\n+                if let ast::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n+                    if ident.node.as_str() == fieldpat.node.ident.as_str() {\n+                        cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n+                                     format!(\"the `{}:` in this pattern is redundant and can \\\n+                                              be removed\", ident.node.as_str()).as_slice())\n                     }\n                 }\n-            },\n-            _ => {}\n+            }\n         }\n     }\n }\n@@ -1234,15 +1196,12 @@ impl LintPass for UnusedUnsafe {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        match e.node {\n+        if let ast::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n-            ast::ExprBlock(ref blk) => {\n-                if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n-                    !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n+            if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n+                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n                     cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n-                }\n             }\n-            _ => ()\n         }\n     }\n }\n@@ -1258,12 +1217,11 @@ impl LintPass for UnsafeBlocks {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        match e.node {\n+        if let ast::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n-            ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n+            if blk.rules == ast::UnsafeBlock(ast::UserProvided) {\n                 cx.span_lint(UNSAFE_BLOCKS, blk.span, \"usage of an `unsafe` block\");\n             }\n-            _ => ()\n         }\n     }\n }\n@@ -1282,17 +1240,13 @@ impl UnusedMut {\n         for p in pats.iter() {\n             pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n                 let ident = path1.node;\n-                match mode {\n-                    ast::BindByValue(ast::MutMutable) => {\n-                        if !token::get_ident(ident).get().starts_with(\"_\") {\n-                            match mutables.entry(ident.name.uint()) {\n-                                Vacant(entry) => { entry.set(vec![id]); },\n-                                Occupied(mut entry) => { entry.get_mut().push(id); },\n-                            }\n+                if let ast::BindByValue(ast::MutMutable) = mode {\n+                    if !token::get_ident(ident).get().starts_with(\"_\") {\n+                        match mutables.entry(ident.name.uint()) {\n+                            Vacant(entry) => { entry.set(vec![id]); },\n+                            Occupied(mut entry) => { entry.get_mut().push(id); },\n                         }\n                     }\n-                    _ => {\n-                    }\n                 }\n             });\n         }\n@@ -1313,27 +1267,18 @@ impl LintPass for UnusedMut {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        match e.node {\n-            ast::ExprMatch(_, ref arms, _) => {\n-                for a in arms.iter() {\n-                    self.check_unused_mut_pat(cx, a.pats.as_slice())\n-                }\n+        if let ast::ExprMatch(_, ref arms, _) = e.node {\n+            for a in arms.iter() {\n+                self.check_unused_mut_pat(cx, a.pats.as_slice())\n             }\n-            _ => {}\n         }\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n-        match s.node {\n-            ast::StmtDecl(ref d, _) => {\n-                match d.node {\n-                    ast::DeclLocal(ref l) => {\n-                        self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n-                    },\n-                    _ => {}\n-                }\n-            },\n-            _ => {}\n+        if let ast::StmtDecl(ref d, _) = s.node {\n+            if let ast::DeclLocal(ref l) = d.node {\n+                self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n+            }\n         }\n     }\n \n@@ -1362,26 +1307,20 @@ impl LintPass for UnusedAllocation {\n             _ => return\n         }\n \n-        match cx.tcx.adjustments.borrow().get(&e.id) {\n-            Some(adjustment) => {\n-                match *adjustment {\n-                    ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n-                        match autoref {\n-                            &Some(ty::AutoPtr(_, ast::MutImmutable, None)) => {\n-                                cx.span_lint(UNUSED_ALLOCATION, e.span,\n-                                             \"unnecessary allocation, use & instead\");\n-                            }\n-                            &Some(ty::AutoPtr(_, ast::MutMutable, None)) => {\n-                                cx.span_lint(UNUSED_ALLOCATION, e.span,\n-                                             \"unnecessary allocation, use &mut instead\");\n-                            }\n-                            _ => ()\n-                        }\n+        if let Some(adjustment) = cx.tcx.adjustments.borrow().get(&e.id) {\n+            if let ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) = *adjustment {\n+                match autoref {\n+                    &Some(ty::AutoPtr(_, ast::MutImmutable, None)) => {\n+                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                                     \"unnecessary allocation, use & instead\");\n                     }\n-                    _ => {}\n+                    &Some(ty::AutoPtr(_, ast::MutMutable, None)) => {\n+                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                                     \"unnecessary allocation, use &mut instead\");\n+                    }\n+                    _ => ()\n                 }\n             }\n-            _ => ()\n         }\n     }\n }\n@@ -1430,9 +1369,10 @@ impl MissingDoc {\n         // Only check publicly-visible items, using the result from the privacy pass.\n         // It's an option so the crate root can also use this function (it doesn't\n         // have a NodeId).\n-        match id {\n-            Some(ref id) if !cx.exported_items.contains(id) => return,\n-            _ => ()\n+        if let Some(ref id) = id {\n+            if !cx.exported_items.contains(id) {\n+                return;\n+            }\n         }\n \n         let has_doc = attrs.iter().any(|a| {\n@@ -1499,17 +1439,14 @@ impl LintPass for MissingDoc {\n     fn check_fn(&mut self, cx: &Context,\n             fk: visit::FnKind, _: &ast::FnDecl,\n             _: &ast::Block, _: Span, _: ast::NodeId) {\n-        match fk {\n-            visit::FkMethod(_, _, m) => {\n-                // If the method is an impl for a trait, don't doc.\n-                if method_context(cx, m) == TraitImpl { return; }\n-\n-                // Otherwise, doc according to privacy. This will also check\n-                // doc for default methods defined on traits.\n-                self.check_missing_docs_attrs(cx, Some(m.id), m.attrs.as_slice(),\n-                                             m.span, \"a method\");\n-            }\n-            _ => {}\n+        if let visit::FkMethod(_, _, m) = fk {\n+            // If the method is an impl for a trait, don't doc.\n+            if method_context(cx, m) == TraitImpl { return; }\n+\n+            // Otherwise, doc according to privacy. This will also check\n+            // doc for default methods defined on traits.\n+            self.check_missing_docs_attrs(cx, Some(m.id), m.attrs.as_slice(),\n+                                          m.span, \"a method\");\n         }\n     }\n \n@@ -1519,15 +1456,14 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n-        match sf.node.kind {\n-            ast::NamedField(_, vis) if vis == ast::Public || self.in_variant => {\n+        if let ast::NamedField(_, vis) = sf.node.kind {\n+            if vis == ast::Public || self.in_variant {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                             sf.node.attrs.as_slice(), sf.span,\n-                                             \"a struct field\")\n+                                              sf.node.attrs.as_slice(), sf.span,\n+                                              \"a struct field\")\n             }\n-            _ => {}\n         }\n     }\n \n@@ -1693,12 +1629,9 @@ impl LintPass for Stability {\n         match item.node {\n             ast::ItemTrait(_, _, ref supertraits, _) => {\n                 for t in supertraits.iter() {\n-                    match *t {\n-                        ast::TraitTyParamBound(ref t) => {\n-                            let id = ty::trait_ref_to_def_id(cx.tcx, &t.trait_ref);\n-                            self.lint(cx, id, t.trait_ref.path.span);\n-                        }\n-                        _ => (/* pass */)\n+                    if let ast::TraitTyParamBound(ref t) = *t {\n+                        let id = ty::trait_ref_to_def_id(cx.tcx, &t.trait_ref);\n+                        self.lint(cx, id, t.trait_ref.path.span);\n                     }\n                 }\n             }"}, {"sha": "ec812cea3728da68668f1f579d1a6b94e3583bd1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 27, "deletions": 44, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -514,41 +514,27 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n         let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc,\n                                                cdata);\n         let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n-        match maybe_find_item(inherent_impl_def_id.node, items) {\n-            None => {}\n-            Some(inherent_impl_doc) => {\n-                let _ = reader::tagged_docs(inherent_impl_doc,\n-                                            tag_item_impl_item,\n-                                            |impl_item_def_id_doc| {\n-                    let impl_item_def_id = item_def_id(impl_item_def_id_doc,\n-                                                       cdata);\n-                    match maybe_find_item(impl_item_def_id.node, items) {\n-                        None => {}\n-                        Some(impl_method_doc) => {\n-                            match item_family(impl_method_doc) {\n-                                StaticMethod => {\n-                                    // Hand off the static method\n-                                    // to the callback.\n-                                    let static_method_name =\n-                                        item_name(&*intr, impl_method_doc);\n-                                    let static_method_def_like =\n-                                        item_to_def_like(impl_method_doc,\n-                                                         impl_item_def_id,\n-                                                         cdata.cnum);\n-                                    callback(static_method_def_like,\n-                                             static_method_name,\n-                                             item_visibility(impl_method_doc));\n-                                }\n-                                _ => {}\n-                            }\n-                        }\n+        if let Some(inherent_impl_doc) = maybe_find_item(inherent_impl_def_id.node, items) {\n+            let _ = reader::tagged_docs(inherent_impl_doc,\n+                                        tag_item_impl_item,\n+                                        |impl_item_def_id_doc| {\n+                let impl_item_def_id = item_def_id(impl_item_def_id_doc,\n+                                                   cdata);\n+                if let Some(impl_method_doc) = maybe_find_item(impl_item_def_id.node, items) {\n+                    if let StaticMethod = item_family(impl_method_doc) {\n+                        // Hand off the static method to the callback.\n+                        let static_method_name = item_name(&*intr, impl_method_doc);\n+                        let static_method_def_like = item_to_def_like(impl_method_doc,\n+                                                                      impl_item_def_id,\n+                                                                      cdata.cnum);\n+                        callback(static_method_def_like,\n+                                 static_method_name,\n+                                 item_visibility(impl_method_doc));\n                     }\n-\n-                    true\n-                });\n-            }\n+                }\n+                true\n+            });\n         }\n-\n         true\n     });\n \n@@ -578,17 +564,14 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n         let other_crates_items = reader::get_doc(rbml::Doc::new(crate_data.data()), tag_items);\n \n         // Get the item.\n-        match maybe_find_item(child_def_id.node, other_crates_items) {\n-            None => {}\n-            Some(child_item_doc) => {\n-                // Hand off the item to the callback.\n-                let def_like = item_to_def_like(child_item_doc,\n-                                                child_def_id,\n-                                                child_def_id.krate);\n-                // These items have a public visibility because they're part of\n-                // a public re-export.\n-                callback(def_like, token::intern(name), ast::Public);\n-            }\n+        if let Some(child_item_doc) = maybe_find_item(child_def_id.node, other_crates_items) {\n+            // Hand off the item to the callback.\n+            let def_like = item_to_def_like(child_item_doc,\n+                                            child_def_id,\n+                                            child_def_id.krate);\n+            // These items have a public visibility because they're part of\n+            // a public re-export.\n+            callback(def_like, token::intern(name), ast::Public);\n         }\n \n         true"}, {"sha": "f7ee9fa65229ce0d0aa4cae02c757185000c926e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 63, "deletions": 86, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -433,17 +433,13 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n     match ecx.tcx.trait_items_cache.borrow().get(&exp.def_id) {\n         Some(trait_items) => {\n             for trait_item in trait_items.iter() {\n-                match *trait_item {\n-                    ty::MethodTraitItem(ref m) => {\n-                        encode_reexported_static_method(rbml_w,\n-                                                        exp,\n-                                                        m.def_id,\n-                                                        m.name);\n-                    }\n-                    _ => {}\n+                if let ty::MethodTraitItem(ref m) = *trait_item {\n+                    encode_reexported_static_method(rbml_w,\n+                                                    exp,\n+                                                    m.def_id,\n+                                                    m.name);\n                 }\n             }\n-\n             true\n         }\n         None => { false }\n@@ -454,46 +450,42 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     mod_path: PathElems,\n                                     exp: &middle::resolve::Export2) {\n-    match ecx.tcx.map.find(exp.def_id.node) {\n-        Some(ast_map::NodeItem(item)) => {\n-            let original_name = token::get_ident(item.ident);\n-\n-            let path_differs = ecx.tcx.map.with_path(exp.def_id.node, |path| {\n-                let (mut a, mut b) = (path, mod_path.clone());\n-                loop {\n-                    match (a.next(), b.next()) {\n-                        (None, None) => return true,\n-                        (None, _) | (_, None) => return false,\n-                        (Some(x), Some(y)) => if x != y { return false },\n-                    }\n+    if let Some(ast_map::NodeItem(item)) = ecx.tcx.map.find(exp.def_id.node) {\n+        let original_name = token::get_ident(item.ident);\n+\n+        let path_differs = ecx.tcx.map.with_path(exp.def_id.node, |path| {\n+            let (mut a, mut b) = (path, mod_path.clone());\n+            loop {\n+                match (a.next(), b.next()) {\n+                    (None, None) => return true,\n+                    (None, _) | (_, None) => return false,\n+                    (Some(x), Some(y)) => if x != y { return false },\n                 }\n-            });\n+            }\n+        });\n \n-            //\n-            // We don't need to reexport static methods on items\n-            // declared in the same module as our `pub use ...` since\n-            // that's done when we encode the item itself.\n-            //\n-            // The only exception is when the reexport *changes* the\n-            // name e.g. `pub use Foo = self::Bar` -- we have\n-            // encoded metadata for static methods relative to Bar,\n-            // but not yet for Foo.\n-            //\n-            if path_differs || original_name.get() != exp.name.as_slice() {\n-                if !encode_reexported_static_base_methods(ecx, rbml_w, exp) {\n-                    if encode_reexported_static_trait_methods(ecx, rbml_w, exp) {\n-                        debug!(\"(encode reexported static methods) {} \\\n-                                 [trait]\",\n-                                original_name);\n-                    }\n-                }\n-                else {\n-                    debug!(\"(encode reexported static methods) {} [base]\",\n-                            original_name);\n+        //\n+        // We don't need to reexport static methods on items\n+        // declared in the same module as our `pub use ...` since\n+        // that's done when we encode the item itself.\n+        //\n+        // The only exception is when the reexport *changes* the\n+        // name e.g. `pub use Foo = self::Bar` -- we have\n+        // encoded metadata for static methods relative to Bar,\n+        // but not yet for Foo.\n+        //\n+        if path_differs || original_name.get() != exp.name.as_slice() {\n+            if !encode_reexported_static_base_methods(ecx, rbml_w, exp) {\n+                if encode_reexported_static_trait_methods(ecx, rbml_w, exp) {\n+                    debug!(\"(encode reexported static methods) {} [trait]\",\n+                           original_name);\n                 }\n             }\n+            else {\n+                debug!(\"(encode reexported static methods) {} [base]\",\n+                       original_name);\n+            }\n         }\n-        _ => {}\n     }\n }\n \n@@ -581,19 +573,15 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n             true\n         });\n \n-        match item.node {\n-            ast::ItemImpl(..) => {\n-                let (ident, did) = (item.ident, item.id);\n-                debug!(\"(encoding info for module) ... encoding impl {} \\\n-                        ({}/{})\",\n-                        token::get_ident(ident),\n-                        did, ecx.tcx.map.node_to_string(did));\n+        if let ast::ItemImpl(..) = item.node {\n+            let (ident, did) = (item.ident, item.id);\n+            debug!(\"(encoding info for module) ... encoding impl {} ({}/{})\",\n+                   token::get_ident(ident),\n+                   did, ecx.tcx.map.node_to_string(did));\n \n-                rbml_w.start_tag(tag_mod_impl);\n-                rbml_w.wr_str(def_to_string(local_def(did)).as_slice());\n-                rbml_w.end_tag();\n-            }\n-            _ => {}\n+            rbml_w.start_tag(tag_mod_impl);\n+            rbml_w.wr_str(def_to_string(local_def(did)).as_slice());\n+            rbml_w.end_tag();\n         }\n     }\n \n@@ -923,12 +911,9 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n     rbml_w.start_tag(tag_method_argument_names);\n     for arg in decl.inputs.iter() {\n         rbml_w.start_tag(tag_method_argument_name);\n-        match arg.pat.node {\n-            ast::PatIdent(_, ref path1, _) => {\n-                let name = token::get_ident(path1.node);\n-                rbml_w.writer.write(name.get().as_bytes());\n-            }\n-            _ => {}\n+        if let ast::PatIdent(_, ref path1, _) = arg.pat.node {\n+            let name = token::get_ident(path1.node);\n+            rbml_w.writer.write(name.get().as_bytes());\n         }\n         rbml_w.end_tag();\n     }\n@@ -1854,22 +1839,19 @@ struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n \n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemImpl(_, Some(ref trait_ref), _, _) => {\n-                let def_map = &self.ecx.tcx.def_map;\n-                let trait_def = def_map.borrow()[trait_ref.ref_id].clone();\n-                let def_id = trait_def.def_id();\n-\n-                // Load eagerly if this is an implementation of the Drop trait\n-                // or if the trait is not defined in this crate.\n-                if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n-                        def_id.krate != ast::LOCAL_CRATE {\n-                    self.rbml_w.start_tag(tag_impls_impl);\n-                    encode_def_id(self.rbml_w, local_def(item.id));\n-                    self.rbml_w.end_tag();\n-                }\n+        if let ast::ItemImpl(_, Some(ref trait_ref), _, _) = item.node {\n+            let def_map = &self.ecx.tcx.def_map;\n+            let trait_def = def_map.borrow()[trait_ref.ref_id].clone();\n+            let def_id = trait_def.def_id();\n+\n+            // Load eagerly if this is an implementation of the Drop trait\n+            // or if the trait is not defined in this crate.\n+            if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n+                    def_id.krate != ast::LOCAL_CRATE {\n+                self.rbml_w.start_tag(tag_impls_impl);\n+                encode_def_id(self.rbml_w, local_def(item.id));\n+                self.rbml_w.end_tag();\n             }\n-            _ => {}\n         }\n         visit::walk_item(self, item);\n     }\n@@ -1931,17 +1913,12 @@ fn encode_reachable_extern_fns(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_reachable_extern_fns);\n \n     for id in ecx.reachable.iter() {\n-        match ecx.tcx.map.find(*id) {\n-            Some(ast_map::NodeItem(i)) => {\n-                match i.node {\n-                    ast::ItemFn(_, _, abi, ref generics, _)\n-                                if abi != abi::Rust && !generics.is_type_parameterized() => {\n-                        rbml_w.wr_tagged_u32(tag_reachable_extern_fn_id, *id);\n-                    }\n-                    _ => {}\n+        if let Some(ast_map::NodeItem(i)) = ecx.tcx.map.find(*id) {\n+            if let ast::ItemFn(_, _, abi, ref generics, _) = i.node {\n+                if abi != abi::Rust && !generics.is_type_parameterized() {\n+                    rbml_w.wr_tagged_u32(tag_reachable_extern_fn_id, *id);\n                 }\n             }\n-            _ => {}\n         }\n     }\n "}, {"sha": "72c6256dcb5182849c8d88c766824f48c3cacc78", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -892,14 +892,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             let guarantor = cmt.guarantor();\n             debug!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n                    cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n-            match guarantor.cat {\n-                mc::cat_deref(ref b, _, mc::BorrowedPtr(ty::MutBorrow, _)) => {\n-                    // Statically prohibit writes to `&mut` when aliasable\n-\n-                    check_for_aliasability_violation(this, span, b.clone());\n-                }\n-\n-                _ => {}\n+            if let mc::cat_deref(ref b, _, mc::BorrowedPtr(ty::MutBorrow, _)) = guarantor.cat {\n+                // Statically prohibit writes to `&mut` when aliasable\n+                check_for_aliasability_violation(this, span, b.clone());\n             }\n \n             return true; // no errors reported\n@@ -962,4 +957,3 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.loan_path_to_string(loan_path)).as_slice());\n     }\n }\n-"}, {"sha": "edffe59fff59c4b8c652553d156f62237a6a3ad6", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -97,12 +97,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                cmt.repr(self.tcx()),\n                mode);\n \n-        match cmt.cat {\n-            mc::cat_downcast(..) =>\n-                gather_moves::gather_match_variant(\n-                    self.bccx, &self.move_data, &self.move_error_collector,\n-                    matched_pat, cmt, mode),\n-            _ => {}\n+        if let mc::cat_downcast(..) = cmt.cat {\n+            gather_moves::gather_match_variant(\n+                self.bccx, &self.move_data, &self.move_error_collector,\n+                matched_pat, cmt, mode);\n         }\n     }\n \n@@ -489,17 +487,14 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n-        match ex.node {\n-            ast::ExprAddrOf(mutbl, ref base) => {\n-                let base_cmt = self.bccx.cat_expr(&**base);\n-                let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n-                // Check that we don't allow borrows of unsafe static items.\n-                if check_aliasability(self.bccx, ex.span, euv::AddrOf,\n-                                      base_cmt, borrow_kind).is_err() {\n-                    return; // reported an error, no sense in reporting more.\n-                }\n+        if let ast::ExprAddrOf(mutbl, ref base) = ex.node {\n+            let base_cmt = self.bccx.cat_expr(&**base);\n+            let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n+            // Check that we don't allow borrows of unsafe static items.\n+            if check_aliasability(self.bccx, ex.span, euv::AddrOf,\n+                                  base_cmt, borrow_kind).is_err() {\n+                return; // reported an error, no sense in reporting more.\n             }\n-            _ => {}\n         }\n \n         visit::walk_expr(self, ex);"}, {"sha": "d5a292b9f09c6cfd2f1475048bd783ed7a186f6b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -278,11 +278,8 @@ impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ConstEvalVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &ast::Ty) {\n-        match t.node {\n-            ast::TyFixedLengthVec(_, ref expr) => {\n-                check::check_const_in_type(self.tcx, &**expr, ty::mk_uint());\n-            }\n-            _ => {}\n+        if let ast::TyFixedLengthVec(_, ref expr) = t.node {\n+            check::check_const_in_type(self.tcx, &**expr, ty::mk_uint());\n         }\n \n         visit::walk_ty(self, t);\n@@ -321,10 +318,9 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n \n         ast::ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow()[callee.id].clone();\n-            match tcx.def_map.borrow_mut().entry(expr.id) {\n-              Vacant(entry) => { entry.set(def); }\n-              _ => {}\n-            };\n+            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n+               entry.set(def);\n+            }\n             let path = match def {\n                 def::DefStruct(def_id) => def_to_path(tcx, def_id),\n                 def::DefVariant(_, variant_did, _) => def_to_path(tcx, variant_did),"}, {"sha": "e67df0332dce6f64e73af14d561fe591172b357f", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -71,12 +71,9 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n         debug!(\"effect: checking index with base type {}\",\n                 ppaux::ty_to_string(self.tcx, base_type));\n         match base_type.sty {\n-            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty.sty {\n-                ty::ty_str => {\n-                    span_err!(self.tcx.sess, e.span, E0134,\n-                              \"modification of string types is not allowed\");\n-                }\n-                _ => {}\n+            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => if ty::ty_str == ty.sty {\n+                span_err!(self.tcx.sess, e.span, E0134,\n+                          \"modification of string types is not allowed\");\n             },\n             ty::ty_str => {\n                 span_err!(self.tcx.sess, e.span, E0135,\n@@ -165,13 +162,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             ast::ExprUnary(ast::UnDeref, ref base) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: unary case, base type is {}\",\n-                        ppaux::ty_to_string(self.tcx, base_type));\n-                match base_type.sty {\n-                    ty::ty_ptr(_) => {\n-                        self.require_unsafe(expr.span,\n-                                            \"dereference of unsafe pointer\")\n-                    }\n-                    _ => {}\n+                       ppaux::ty_to_string(self.tcx, base_type));\n+                if let ty::ty_ptr(_) = base_type.sty {\n+                    self.require_unsafe(expr.span, \"dereference of unsafe pointer\")\n                 }\n             }\n             ast::ExprAssign(ref base, _) | ast::ExprAssignOp(_, ref base, _) => {\n@@ -181,14 +174,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 self.check_str_index(&**base);\n             }\n             ast::ExprInlineAsm(..) => {\n-                self.require_unsafe(expr.span, \"use of inline assembly\")\n+                self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n             ast::ExprPath(..) => {\n-                match ty::resolve_expr(self.tcx, expr) {\n-                    def::DefStatic(_, true) => {\n-                        self.require_unsafe(expr.span, \"use of mutable static\")\n-                    }\n-                    _ => {}\n+                if let def::DefStatic(_, true) = ty::resolve_expr(self.tcx, expr) {\n+                    self.require_unsafe(expr.span, \"use of mutable static\");\n                 }\n             }\n             _ => {}"}, {"sha": "acfdf6fefb55f0a8c80a8c3c11c32cd92c1be2a5", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -118,31 +118,26 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n-        match expr.node {\n-            ast::ExprPath(..) => {\n-                match ty::resolve_expr(self.tcx, expr) {\n-                    DefFn(did, _) if self.def_id_is_transmute(did) => {\n-                        let typ = ty::node_id_to_type(self.tcx, expr.id);\n-                        match typ.sty {\n-                            ty_bare_fn(ref bare_fn_ty)\n-                                    if bare_fn_ty.abi == RustIntrinsic => {\n-                                if let ty::FnConverging(to) = bare_fn_ty.sig.output {\n-                                    let from = bare_fn_ty.sig.inputs[0];\n-                                    self.check_transmute(expr.span, from, to, expr.id);\n-                                }\n-                            }\n-                            _ => {\n-                                self.tcx\n-                                    .sess\n-                                    .span_bug(expr.span,\n-                                              \"transmute wasn't a bare fn?!\");\n+        if let ast::ExprPath(..) = expr.node {\n+            match ty::resolve_expr(self.tcx, expr) {\n+                DefFn(did, _) if self.def_id_is_transmute(did) => {\n+                    let typ = ty::node_id_to_type(self.tcx, expr.id);\n+                    match typ.sty {\n+                        ty_bare_fn(ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n+                            if let ty::FnConverging(to) = bare_fn_ty.sig.output {\n+                                let from = bare_fn_ty.sig.inputs[0];\n+                                self.check_transmute(expr.span, from, to, expr.id);\n                             }\n                         }\n+                        _ => {\n+                            self.tcx\n+                                .sess\n+                                .span_bug(expr.span, \"transmute wasn't a bare fn?!\");\n+                        }\n                     }\n-                    _ => {}\n                 }\n+                _ => {}\n             }\n-            _ => {}\n         }\n \n         visit::walk_expr(self, expr);\n@@ -153,4 +148,3 @@ pub fn check_crate(tcx: &ctxt) {\n     visit::walk_crate(&mut IntrinsicCheckingVisitor { tcx: tcx },\n                       tcx.map.krate());\n }\n-"}, {"sha": "fcc23d8ac554812abca61799ea0e6ff6b58277be", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -445,9 +445,8 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       ast::ExprPath(_) => {\n         let def = ir.tcx.def_map.borrow()[expr.id].clone();\n         debug!(\"expr {}: path that leads to {}\", expr.id, def);\n-        match def {\n-            DefLocal(..) => ir.add_live_node_for_node(expr.id, ExprNode(expr.span)),\n-            _ => {}\n+        if let DefLocal(..) = def {\n+            ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n         visit::walk_expr(ir, expr);\n       }\n@@ -463,13 +462,10 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         let mut call_caps = Vec::new();\n         ty::with_freevars(ir.tcx, expr.id, |freevars| {\n             for fv in freevars.iter() {\n-                match fv.def {\n-                    DefLocal(rv) => {\n-                        let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n-                        call_caps.push(CaptureInfo {ln: fv_ln,\n-                                                    var_nid: rv});\n-                    }\n-                    _ => {}\n+                if let DefLocal(rv) = fv.def {\n+                    let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n+                    call_caps.push(CaptureInfo {ln: fv_ln,\n+                                                var_nid: rv});\n                 }\n             }\n         });\n@@ -1576,27 +1572,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n-          ast::ExprPath(_) => {\n-            match self.ir.tcx.def_map.borrow()[expr.id].clone() {\n-              DefLocal(nid) => {\n-                // Assignment to an immutable variable or argument: only legal\n-                // if there is no later assignment. If this local is actually\n-                // mutable, then check for a reassignment to flag the mutability\n-                // as being used.\n-                let ln = self.live_node(expr.id, expr.span);\n-                let var = self.variable(nid, expr.span);\n-                self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n-              }\n-              _ => {}\n+            ast::ExprPath(_) => {\n+                if let DefLocal(nid) = self.ir.tcx.def_map.borrow()[expr.id].clone() {\n+                    // Assignment to an immutable variable or argument: only legal\n+                    // if there is no later assignment. If this local is actually\n+                    // mutable, then check for a reassignment to flag the mutability\n+                    // as being used.\n+                    let ln = self.live_node(expr.id, expr.span);\n+                    let var = self.variable(nid, expr.span);\n+                    self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n+                }\n             }\n-          }\n-\n-          _ => {\n-            // For other kinds of lvalues, no checks are required,\n-            // and any embedded expressions are actually rvalues\n-            visit::walk_expr(self, expr);\n-          }\n-       }\n+            _ => {\n+                // For other kinds of lvalues, no checks are required,\n+                // and any embedded expressions are actually rvalues\n+                visit::walk_expr(self, expr);\n+            }\n+        }\n     }\n \n     fn should_warn(&self, var: Variable) -> Option<String> {"}, {"sha": "5e182ba8337cbf64b3157f3b7f14f1b5b4b5bd2a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 30, "deletions": 52, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -310,19 +310,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             }\n \n             ast::ItemTy(ref ty, _) if public_first => {\n-                match ty.node {\n-                    ast::TyPath(_, id) => {\n-                        match self.tcx.def_map.borrow()[id].clone() {\n-                            def::DefPrimTy(..) | def::DefTyParam(..) => {},\n-                            def => {\n-                                let did = def.def_id();\n-                                if is_local(did) {\n-                                    self.exported_items.insert(did.node);\n-                                }\n+                if let ast::TyPath(_, id) = ty.node {\n+                    match self.tcx.def_map.borrow()[id].clone() {\n+                        def::DefPrimTy(..) | def::DefTyParam(..) => {},\n+                        def => {\n+                            let did = def.def_id();\n+                            if is_local(did) {\n+                                self.exported_items.insert(did.node);\n                             }\n                         }\n                     }\n-                    _ => {}\n                 }\n             }\n \n@@ -771,11 +768,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                 resolve::AllPublic => None,\n                                 resolve::DependsOn(def) => ck_public(def),\n                             };\n-                            match (v, t) {\n-                                (Some(_), Some(t)) => {\n-                                    self.report_error(Some(t));\n-                                },\n-                                _ => {},\n+                            if let (Some(_), Some(t)) = (v, t) {\n+                                self.report_error(Some(t));\n                             }\n                         },\n                         _ => {},\n@@ -1001,9 +995,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 match ty::pat_ty(self.tcx, pattern).sty {\n                     ty::ty_struct(id, _) => {\n                         for (i, field) in fields.iter().enumerate() {\n-                            match field.node {\n-                                ast::PatWild(..) => continue,\n-                                _ => {}\n+                            if let ast::PatWild(..) = field.node {\n+                                continue\n                             }\n                             self.check_field(field.span, id, UnnamedField(i));\n                         }\n@@ -1075,14 +1068,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n                     self.tcx.sess.span_err(i.span, \"unnecessary `pub`, imports \\\n                                                     in functions are never \\\n                                                     reachable\");\n-                } else {\n-                    match i.node {\n-                        ast::ViewItemExternCrate(..) => {\n-                            self.tcx.sess.span_err(i.span, \"`pub` visibility \\\n-                                                            is not allowed\");\n-                        }\n-                        _ => {}\n-                    }\n+                } else if let ast::ViewItemExternCrate(..) = i.node {\n+                    self.tcx.sess.span_err(i.span, \"`pub` visibility \\\n+                                                    is not allowed\");\n                 }\n             }\n         }\n@@ -1275,34 +1263,28 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn check_ty_param_bound(&self,\n                             span: Span,\n                             ty_param_bound: &ast::TyParamBound) {\n-        match *ty_param_bound {\n-            ast::TraitTyParamBound(ref trait_ref) => {\n-                if !self.tcx.sess.features.borrow().visible_private_types &&\n-                        self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n+        if let ast::TraitTyParamBound(ref trait_ref) = *ty_param_bound {\n+            if !self.tcx.sess.features.borrow().visible_private_types &&\n+                self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n                     self.tcx.sess.span_err(span,\n                                            \"private type in exported type \\\n                                             parameter bound\");\n-                }\n             }\n-            _ => {}\n         }\n     }\n }\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n-        match ty.node {\n-            ast::TyPath(_, path_id) => {\n-                if self.inner.path_is_private_type(path_id) {\n-                    self.contains_private = true;\n-                    // found what we're looking for so let's stop\n-                    // working.\n-                    return\n-                } else if self.at_outer_type {\n-                    self.outer_type_is_public_path = true;\n-                }\n+        if let ast::TyPath(_, path_id) = ty.node {\n+            if self.inner.path_is_private_type(path_id) {\n+                self.contains_private = true;\n+                // found what we're looking for so let's stop\n+                // working.\n+                return\n+            } else if self.at_outer_type {\n+                self.outer_type_is_public_path = true;\n             }\n-            _ => {}\n         }\n         self.at_outer_type = false;\n         visit::walk_ty(self, ty)\n@@ -1492,16 +1474,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n-        match t.node {\n-            ast::TyPath(ref p, path_id) => {\n-                if !self.tcx.sess.features.borrow().visible_private_types &&\n-                        self.path_is_private_type(path_id) {\n-                    self.tcx.sess.span_err(p.span,\n-                                           \"private type in exported type \\\n-                                            signature\");\n-                }\n+        if let ast::TyPath(ref p, path_id) = t.node {\n+            if !self.tcx.sess.features.borrow().visible_private_types &&\n+                self.path_is_private_type(path_id) {\n+                self.tcx.sess.span_err(p.span,\n+                                       \"private type in exported type signature\");\n             }\n-            _ => {}\n         }\n         visit::walk_ty(self, t)\n     }"}, {"sha": "96e1aacb0cef5614ac1805c6fe7683a51231f642", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -264,18 +264,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // functions may still participate in some form of native interface,\n             // but all other rust-only interfaces can be private (they will not\n             // participate in linkage after this product is produced)\n-            match *node {\n-                ast_map::NodeItem(item) => {\n-                    match item.node {\n-                        ast::ItemFn(_, _, abi, _, _) => {\n-                            if abi != abi::Rust {\n-                                self.reachable_symbols.insert(search_item);\n-                            }\n-                        }\n-                        _ => {}\n+            if let ast_map::NodeItem(item) = *node {\n+                if let ast::ItemFn(_, _, abi, _, _) = item.node {\n+                    if abi != abi::Rust {\n+                        self.reachable_symbols.insert(search_item);\n                     }\n                 }\n-                _ => {}\n             }\n         } else {\n             // If we are building a library, then reachable symbols will"}, {"sha": "b958bdce0a7e87b1ebad6369f4e29e84452d4ee6", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 114, "deletions": 185, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -3052,82 +3052,59 @@ impl<'a> Resolver<'a> {\n \n         match import_resolution.value_target {\n             Some(ref target) if !target.shadowable => {\n-                match *name_bindings.value_def.borrow() {\n-                    Some(ref value) => {\n-                        let msg = format!(\"import `{}` conflicts with value \\\n-                                           in this module\",\n-                                          token::get_name(name).get());\n-                        self.session.span_err(import_span, msg.as_slice());\n-                        match value.value_span {\n-                            None => {}\n-                            Some(span) => {\n-                                self.session\n-                                    .span_note(span,\n+                if let Some(ref value) = *name_bindings.value_def.borrow() {\n+                    let msg = format!(\"import `{}` conflicts with value \\\n+                                       in this module\",\n+                                      token::get_name(name).get());\n+                    self.session.span_err(import_span, msg.as_slice());\n+                    if let Some(span) = value.value_span {\n+                        self.session.span_note(span,\n                                                \"conflicting value here\");\n-                            }\n-                        }\n                     }\n-                    _ => {}\n                 }\n             }\n             Some(_) | None => {}\n         }\n \n         match import_resolution.type_target {\n             Some(ref target) if !target.shadowable => {\n-                match *name_bindings.type_def.borrow() {\n-                    Some(ref ty) => {\n-                        match ty.module_def {\n-                            None => {\n-                                let msg = format!(\"import `{}` conflicts with type in \\\n-                                                   this module\",\n-                                                  token::get_name(name).get());\n-                                self.session.span_err(import_span, msg.as_slice());\n-                                match ty.type_span {\n-                                    None => {}\n-                                    Some(span) => {\n-                                        self.session\n-                                            .span_note(span,\n+                if let Some(ref ty) = *name_bindings.type_def.borrow() {\n+                    match ty.module_def {\n+                        None => {\n+                            let msg = format!(\"import `{}` conflicts with type in \\\n+                                               this module\",\n+                                              token::get_name(name).get());\n+                            self.session.span_err(import_span, msg.as_slice());\n+                            if let Some(span) = ty.type_span {\n+                                self.session.span_note(span,\n                                                        \"note conflicting type here\")\n-                                    }\n-                                }\n                             }\n-                            Some(ref module_def) => {\n-                                match module_def.kind.get() {\n-                                    ImplModuleKind => {\n-                                        match ty.type_span {\n-                                            None => { /* this can't ever happen */ }\n-                                            Some(span) => {\n-                                                let msg = format!(\"inherent implementations \\\n-                                                                   are only allowed on types \\\n-                                                                   defined in the current module\");\n-                                                self.session\n-                                                    .span_err(span, msg.as_slice());\n-                                                self.session\n-                                                    .span_note(import_span,\n+                        }\n+                        Some(ref module_def) => {\n+                            match module_def.kind.get() {\n+                                ImplModuleKind => {\n+                                    if let Some(span) = ty.type_span {\n+                                        let msg = format!(\"inherent implementations \\\n+                                                           are only allowed on types \\\n+                                                           defined in the current module\");\n+                                        self.session.span_err(span, msg.as_slice());\n+                                        self.session.span_note(import_span,\n                                                                \"import from other module here\")\n-                                            }\n-                                        }\n                                     }\n-                                    _ => {\n-                                        let msg = format!(\"import `{}` conflicts with existing \\\n-                                                           submodule\",\n-                                                          token::get_name(name).get());\n-                                        self.session.span_err(import_span, msg.as_slice());\n-                                        match ty.type_span {\n-                                            None => {}\n-                                            Some(span) => {\n-                                                self.session\n-                                                    .span_note(span,\n+                                }\n+                                _ => {\n+                                    let msg = format!(\"import `{}` conflicts with existing \\\n+                                                       submodule\",\n+                                                      token::get_name(name).get());\n+                                    self.session.span_err(import_span, msg.as_slice());\n+                                    if let Some(span) = ty.type_span {\n+                                        self.session.span_note(span,\n                                                                \"note conflicting module here\")\n-                                            }\n-                                        }\n                                     }\n                                 }\n                             }\n                         }\n                     }\n-                    _ => {}\n                 }\n             }\n             Some(_) | None => {}\n@@ -3269,25 +3246,16 @@ impl<'a> Resolver<'a> {\n                                     search_module = module_def.clone();\n \n                                     // track extern crates for unused_extern_crate lint\n-                                    match module_def.def_id.get() {\n-                                        Some(did) => {\n-                                            self.used_crates.insert(did.krate);\n-                                        }\n-                                        _ => {}\n+                                    if let Some(did) = module_def.def_id.get() {\n+                                        self.used_crates.insert(did.krate);\n                                     }\n \n                                     // Keep track of the closest\n                                     // private module used when\n                                     // resolving this import chain.\n-                                    if !used_proxy &&\n-                                       !search_module.is_public {\n-                                        match search_module.def_id\n-                                                           .get() {\n-                                            Some(did) => {\n-                                                closest_private =\n-                                                    LastMod(DependsOn(did));\n-                                            }\n-                                            None => {}\n+                                    if !used_proxy && !search_module.is_public {\n+                                        if let Some(did) = search_module.def_id.get() {\n+                                            closest_private = LastMod(DependsOn(did));\n                                         }\n                                     }\n                                 }\n@@ -3442,46 +3410,35 @@ impl<'a> Resolver<'a> {\n         // all its imports in the usual way; this is because chains of\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n-        match module_.import_resolutions.borrow().get(&name) {\n-            None => {\n-                // Not found; continue.\n-            }\n-            Some(import_resolution) => {\n-                match (*import_resolution).target_for_namespace(namespace) {\n-                    None => {\n-                        // Not found; continue.\n-                        debug!(\"(resolving item in lexical scope) found \\\n-                                import resolution, but not in namespace {}\",\n-                               namespace);\n-                    }\n-                    Some(target) => {\n-                        debug!(\"(resolving item in lexical scope) using \\\n-                                import resolution\");\n-                        // track used imports and extern crates as well\n-                        self.used_imports.insert((import_resolution.id(namespace), namespace));\n-                        match target.target_module.def_id.get() {\n-                            Some(DefId{krate: kid, ..}) => { self.used_crates.insert(kid); },\n-                            _ => {}\n-                        }\n-                        return Success((target, false));\n+        if let Some(import_resolution) = module_.import_resolutions.borrow().get(&name) {\n+            match (*import_resolution).target_for_namespace(namespace) {\n+                None => {\n+                    // Not found; continue.\n+                    debug!(\"(resolving item in lexical scope) found \\\n+                            import resolution, but not in namespace {}\",\n+                           namespace);\n+                }\n+                Some(target) => {\n+                    debug!(\"(resolving item in lexical scope) using \\\n+                            import resolution\");\n+                    // track used imports and extern crates as well\n+                    self.used_imports.insert((import_resolution.id(namespace), namespace));\n+                    if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n+                        self.used_crates.insert(kid);\n                     }\n+                    return Success((target, false));\n                 }\n             }\n         }\n \n         // Search for external modules.\n         if namespace == TypeNS {\n-            match module_.external_module_children.borrow().get(&name).cloned() {\n-                None => {}\n-                Some(module) => {\n-                    let name_bindings =\n-                        Rc::new(Resolver::create_name_bindings_from_module(module));\n-                    debug!(\"lower name bindings succeeded\");\n-                    return Success((Target::new(module_,\n-                                                name_bindings,\n-                                                false),\n-                                    false));\n-                }\n+            if let Some(module) = module_.external_module_children.borrow().get(&name).cloned() {\n+                let name_bindings =\n+                    Rc::new(Resolver::create_name_bindings_from_module(module));\n+                debug!(\"lower name bindings succeeded\");\n+                return Success((Target::new(module_, name_bindings, false),\n+                                false));\n             }\n         }\n \n@@ -3743,9 +3700,8 @@ impl<'a> Resolver<'a> {\n                                 import\");\n                         // track used imports and extern crates as well\n                         self.used_imports.insert((import_resolution.id(namespace), namespace));\n-                        match target.target_module.def_id.get() {\n-                            Some(DefId{krate: kid, ..}) => { self.used_crates.insert(kid); },\n-                            _ => {}\n+                        if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n+                            self.used_crates.insert(kid);\n                         }\n                         return Success((target, true));\n                     }\n@@ -3756,16 +3712,11 @@ impl<'a> Resolver<'a> {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            match module_.external_module_children.borrow().get(&name).cloned() {\n-                None => {}\n-                Some(module) => {\n-                    let name_bindings =\n-                        Rc::new(Resolver::create_name_bindings_from_module(module));\n-                    return Success((Target::new(module_,\n-                                                name_bindings,\n-                                                false),\n-                                    false));\n-                }\n+            if let Some(module) = module_.external_module_children.borrow().get(&name).cloned() {\n+                let name_bindings =\n+                    Rc::new(Resolver::create_name_bindings_from_module(module));\n+                return Success((Target::new(module_, name_bindings, false),\n+                                false));\n             }\n         }\n \n@@ -4271,11 +4222,8 @@ impl<'a> Resolver<'a> {\n                                     this.resolve_type(&*argument.ty);\n                                 }\n \n-                                match ty_m.explicit_self.node {\n-                                    SelfExplicit(ref typ, _) => {\n-                                        this.resolve_type(&**typ)\n-                                    }\n-                                    _ => {}\n+                                if let SelfExplicit(ref typ, _) = ty_m.explicit_self.node {\n+                                    this.resolve_type(&**typ)\n                                 }\n \n                                 if let ast::Return(ref ret_ty) = ty_m.decl.output {\n@@ -4563,19 +4511,14 @@ impl<'a> Resolver<'a> {\n                                                        &trait_reference.path)));\n \n                         // If it's a typedef, give a note\n-                        match def {\n-                            DefTy(..) => {\n-                                self.session.span_note(\n-                                    trait_reference.path.span,\n-                                    format!(\"`type` aliases cannot \\\n-                                                        be used for traits\")\n-                                                        .as_slice());\n-                            }\n-                            _ => {}\n+                        if let DefTy(..) = def {\n+                            self.session.span_note(\n+                                trait_reference.path.span,\n+                                format!(\"`type` aliases cannot be used for traits\")\n+                                    .as_slice());\n                         }\n                     }\n                 }\n-\n             }\n         }\n     }\n@@ -4637,9 +4580,8 @@ impl<'a> Resolver<'a> {\n                                                 method.id,\n                                                 rib_kind);\n \n-        match method.pe_explicit_self().node {\n-            SelfExplicit(ref typ, _) => self.resolve_type(&**typ),\n-            _ => {}\n+        if let SelfExplicit(ref typ, _) = method.pe_explicit_self().node {\n+            self.resolve_type(&**typ);\n         }\n \n         self.resolve_function(rib_kind,\n@@ -5351,51 +5293,42 @@ impl<'a> Resolver<'a> {\n         // Next, search import resolutions.\n         match containing_module.import_resolutions.borrow().get(&name) {\n             Some(import_resolution) if import_resolution.is_public => {\n-                match (*import_resolution).target_for_namespace(namespace) {\n-                    Some(target) => {\n-                        match target.bindings.def_for_namespace(namespace) {\n-                            Some(def) => {\n-                                // Found it.\n-                                let id = import_resolution.id(namespace);\n-                                // track imports and extern crates as well\n-                                self.used_imports.insert((id, namespace));\n-                                match target.target_module.def_id.get() {\n-                                    Some(DefId{krate: kid, ..}) => {\n-                                        self.used_crates.insert(kid);\n-                                    },\n-                                    _ => {}\n-                                }\n-                                return ImportNameDefinition(def, LastMod(AllPublic));\n-                            }\n-                            None => {\n-                                // This can happen with external impls, due to\n-                                // the imperfect way we read the metadata.\n+                if let Some(target) = (*import_resolution).target_for_namespace(namespace) {\n+                    match target.bindings.def_for_namespace(namespace) {\n+                        Some(def) => {\n+                            // Found it.\n+                            let id = import_resolution.id(namespace);\n+                            // track imports and extern crates as well\n+                            self.used_imports.insert((id, namespace));\n+                            match target.target_module.def_id.get() {\n+                                Some(DefId{krate: kid, ..}) => {\n+                                    self.used_crates.insert(kid);\n+                                },\n+                                _ => {}\n                             }\n+                            return ImportNameDefinition(def, LastMod(AllPublic));\n+                        }\n+                        None => {\n+                            // This can happen with external impls, due to\n+                            // the imperfect way we read the metadata.\n                         }\n                     }\n-                    None => {}\n                 }\n             }\n             Some(..) | None => {} // Continue.\n         }\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            match containing_module.external_module_children.borrow()\n-                                   .get(&name).cloned() {\n-                None => {}\n-                Some(module) => {\n-                    match module.def_id.get() {\n-                        None => {} // Continue.\n-                        Some(def_id) => {\n-                            // track used crates\n-                            self.used_crates.insert(def_id.krate);\n-                            let lp = if module.is_public {LastMod(AllPublic)} else {\n-                                LastMod(DependsOn(def_id))\n-                            };\n-                            return ChildNameDefinition(DefMod(def_id), lp);\n-                        }\n-                    }\n+            if let Some(module) = containing_module.external_module_children.borrow()\n+                                                   .get(&name).cloned() {\n+                if let Some(def_id) = module.def_id.get() {\n+                    // track used crates\n+                    self.used_crates.insert(def_id.krate);\n+                    let lp = if module.is_public {LastMod(AllPublic)} else {\n+                        LastMod(DependsOn(def_id))\n+                    };\n+                    return ChildNameDefinition(DefMod(def_id), lp);\n                 }\n             }\n         }\n@@ -5454,9 +5387,8 @@ impl<'a> Resolver<'a> {\n                 (def, last_private.or(lp))\n             }\n         };\n-        match containing_module.def_id.get() {\n-            Some(DefId{krate: kid, ..}) => { self.used_crates.insert(kid); },\n-            _ => {}\n+        if let Some(DefId{krate: kid, ..}) = containing_module.def_id.get() {\n+            self.used_crates.insert(kid);\n         }\n         return Some(def);\n     }\n@@ -6049,9 +5981,8 @@ impl<'a> Resolver<'a> {\n                 if self.trait_item_map.contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n                     self.used_imports.insert((import.type_id, TypeNS));\n-                    match target.target_module.def_id.get() {\n-                        Some(DefId{krate: kid, ..}) => { self.used_crates.insert(kid); },\n-                        _ => {}\n+                    if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n+                        self.used_crates.insert(kid);\n                     }\n                 }\n             }\n@@ -6128,15 +6059,13 @@ impl<'a> Resolver<'a> {\n \n         match vi.node {\n             ViewItemExternCrate(_, _, id) => {\n-                match self.session.cstore.find_extern_mod_stmt_cnum(id)\n-                {\n-                    Some(crate_num) => if !self.used_crates.contains(&crate_num) {\n-                    self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n-                                          id,\n-                                          vi.span,\n-                                          \"unused extern crate\".to_string());\n-                    },\n-                    _ => {}\n+                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(id) {\n+                    if !self.used_crates.contains(&crate_num) {\n+                        self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n+                                              id,\n+                                              vi.span,\n+                                              \"unused extern crate\".to_string());\n+                    }\n                 }\n             },\n             ViewItemUse(ref p) => {"}, {"sha": "994fe2e9e27c4a21bd7b73019eede78a154928ea", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -69,24 +69,18 @@ impl<'v> Visitor<'v> for Annotator {\n     fn visit_item(&mut self, i: &Item) {\n         self.annotate(i.id, &i.attrs, |v| visit::walk_item(v, i));\n \n-        match i.node {\n-            ast::ItemStruct(ref sd, _) => {\n-                sd.ctor_id.map(|id| {\n-                    self.annotate(id, &i.attrs, |_| {})\n-                });\n-            }\n-            _ => {}\n+        if let ast::ItemStruct(ref sd, _) = i.node {\n+            sd.ctor_id.map(|id| {\n+                self.annotate(id, &i.attrs, |_| {})\n+            });\n         }\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, _: &'v FnDecl,\n                 _: &'v Block, _: Span, _: NodeId) {\n-        match fk {\n-            FkMethod(_, _, meth) => {\n-                // Methods are not already annotated, so we annotate it\n-                self.annotate(meth.id, &meth.attrs, |_| {});\n-            }\n-            _ => {}\n+        if let FkMethod(_, _, meth) = fk {\n+            // Methods are not already annotated, so we annotate it\n+            self.annotate(meth.id, &meth.attrs, |_| {});\n         }\n         // Items defined in a function body have no reason to have\n         // a stability attribute, so we don't recurse."}, {"sha": "e8b292aac6d32a2b48b65be357abfc0a5513978f", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -211,9 +211,8 @@ fn push_obligations_for_param_bounds<'tcx>(\n                                                       builtin_bound,\n                                                       recursion_depth,\n                                                       param_ty);\n-        match obligation {\n-            Ok(ob) => obligations.push(space, ob),\n-            _ => {}\n+        if let Ok(ob) = obligation {\n+            obligations.push(space, ob);\n         }\n     }\n \n@@ -383,4 +382,3 @@ impl<'tcx> Repr<'tcx> for ty::type_err<'tcx> {\n         ty::type_err_to_str(tcx, self)\n     }\n }\n-"}, {"sha": "35aed356303d87faf7d1eb551ab27d2aaff9925b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -1893,11 +1893,8 @@ impl FlagComputation {\n             }\n \n             &ty_closure(ref f) => {\n-                match f.store {\n-                    RegionTraitStore(r, _) => {\n-                        self.add_region(r);\n-                    }\n-                    _ => {}\n+                if let RegionTraitStore(r, _) = f.store {\n+                    self.add_region(r);\n                 }\n                 self.add_fn_sig(&f.sig);\n                 self.add_bounds(&f.bounds);\n@@ -3664,9 +3661,8 @@ pub fn adjust_ty<'tcx>(cx: &ctxt<'tcx>,\n                        method_type: |typeck::MethodCall| -> Option<Ty<'tcx>>)\n                        -> Ty<'tcx> {\n \n-    match unadjusted_ty.sty {\n-        ty_err => return unadjusted_ty,\n-        _ => {}\n+    if let ty_err = unadjusted_ty.sty {\n+        return unadjusted_ty;\n     }\n \n     return match adjustment {"}, {"sha": "641cbd11d64e0359d2ff07be5873a4bc5cc71d3a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 35, "deletions": 50, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -441,21 +441,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &ast::Pat) {\n-        match p.node {\n-            ast::PatIdent(_, ref path1, _)\n-                if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) => {\n-                    let var_ty = self.assign(p.span, p.id, None);\n-\n-                    self.fcx.require_type_is_sized(var_ty, p.span,\n-                                                   traits::VariableType(p.id));\n-\n-                    debug!(\"Pattern binding {} is assigned to {} with type {}\",\n-                           token::get_ident(path1.node),\n-                           self.fcx.infcx().ty_to_string(\n-                               self.fcx.inh.locals.borrow()[p.id].clone()),\n-                           var_ty.repr(self.fcx.tcx()));\n-                }\n-            _ => {}\n+        if let ast::PatIdent(_, ref path1, _) = p.node {\n+            if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) {\n+                let var_ty = self.assign(p.span, p.id, None);\n+\n+                self.fcx.require_type_is_sized(var_ty, p.span,\n+                                               traits::VariableType(p.id));\n+\n+                debug!(\"Pattern binding {} is assigned to {} with type {}\",\n+                       token::get_ident(path1.node),\n+                       self.fcx.infcx().ty_to_string(\n+                           self.fcx.inh.locals.borrow()[p.id].clone()),\n+                       var_ty.repr(self.fcx.tcx()));\n+            }\n         }\n         visit::walk_pat(self, p);\n     }\n@@ -681,14 +679,11 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                         \"foreign items may not have type parameters\");\n                 }\n \n-                match item.node {\n-                    ast::ForeignItemFn(ref fn_decl, _) => {\n-                        if fn_decl.variadic && m.abi != abi::C {\n-                            span_err!(ccx.tcx.sess, item.span, E0045,\n-                                \"variadic function must have C calling convention\");\n-                        }\n+                if let ast::ForeignItemFn(ref fn_decl, _) = item.node {\n+                    if fn_decl.variadic && m.abi != abi::C {\n+                        span_err!(ccx.tcx.sess, item.span, E0045,\n+                                  \"variadic function must have C calling convention\");\n                     }\n-                    _ => {}\n                 }\n             }\n         }\n@@ -1808,9 +1803,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             traits::ObligationCause::new(span, code),\n             ty,\n             bound);\n-        match obligation {\n-            Ok(ob) => self.register_obligation(ob),\n-            _ => {}\n+        if let Ok(ob) = obligation {\n+            self.register_obligation(ob);\n         }\n     }\n \n@@ -3763,19 +3757,16 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n           check_expr(fcx, &**subexpr);\n \n           let mut checked = false;\n-          match place.node {\n-              ast::ExprPath(ref path) => {\n-                  // FIXME(pcwalton): For now we hardcode the two permissible\n-                  // places: the exchange heap and the managed heap.\n-                  let definition = lookup_def(fcx, path.span, place.id);\n-                  let def_id = definition.def_id();\n-                  let referent_ty = fcx.expr_ty(&**subexpr);\n-                  if tcx.lang_items.exchange_heap() == Some(def_id) {\n-                      fcx.write_ty(id, ty::mk_uniq(tcx, referent_ty));\n-                      checked = true\n-                  }\n+          if let ast::ExprPath(ref path) = place.node {\n+              // FIXME(pcwalton): For now we hardcode the two permissible\n+              // places: the exchange heap and the managed heap.\n+              let definition = lookup_def(fcx, path.span, place.id);\n+              let def_id = definition.def_id();\n+              let referent_ty = fcx.expr_ty(&**subexpr);\n+              if tcx.lang_items.exchange_heap() == Some(def_id) {\n+                  fcx.write_ty(id, ty::mk_uniq(tcx, referent_ty));\n+                  checked = true\n               }\n-              _ => {}\n           }\n \n           if !checked {\n@@ -4129,11 +4120,8 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       ast::ExprCast(ref e, ref t) => {\n-        match t.node {\n-            ast::TyFixedLengthVec(_, ref count_expr) => {\n-                check_expr_with_hint(fcx, &**count_expr, ty::mk_uint());\n-            }\n-            _ => {}\n+        if let ast::TyFixedLengthVec(_, ref count_expr) = t.node {\n+            check_expr_with_hint(fcx, &**count_expr, ty::mk_uint());\n         }\n         check_cast(fcx, expr, &**e, &**t);\n       }\n@@ -4524,15 +4512,12 @@ pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n     let t = fcx.local_ty(local.span, local.id);\n     fcx.write_ty(local.id, t);\n \n-    match local.init {\n-        Some(ref init) => {\n-            check_decl_initializer(fcx, local.id, &**init);\n-            let init_ty = fcx.expr_ty(&**init);\n-            if ty::type_is_error(init_ty) {\n-                fcx.write_ty(local.id, init_ty);\n-            }\n+    if let Some(ref init) = local.init {\n+        check_decl_initializer(fcx, local.id, &**init);\n+        let init_ty = fcx.expr_ty(&**init);\n+        if ty::type_is_error(init_ty) {\n+            fcx.write_ty(local.id, init_ty);\n         }\n-        _ => {}\n     }\n \n     let pcx = pat_ctxt {"}, {"sha": "08f7f9cf5e37fb5a38d6c7e249fdaee33d49fd38", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 52, "deletions": 77, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -672,12 +672,9 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 }\n                 None => rcx.resolve_node_type(base.id)\n             };\n-            match base_ty.sty {\n-                ty::ty_rptr(r_ptr, _) => {\n-                    mk_subregion_due_to_dereference(\n-                        rcx, expr.span, ty::ReScope(CodeExtent::from_node_id(expr.id)), r_ptr);\n-                }\n-                _ => {}\n+            if let ty::ty_rptr(r_ptr, _) = base_ty.sty {\n+                mk_subregion_due_to_dereference(\n+                    rcx, expr.span, ty::ReScope(CodeExtent::from_node_id(expr.id)), r_ptr);\n             }\n \n             visit::walk_expr(rcx, expr);\n@@ -943,12 +940,9 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 let cause = traits::ObligationCause::new(freevar.span, code);\n                 let obligation = traits::obligation_for_builtin_bound(rcx.tcx(), cause,\n                                                                       var_ty, builtin_bound);\n-                match obligation {\n-                    Ok(obligation) => {\n-                        rcx.fcx.inh.fulfillment_cx.borrow_mut().register_obligation(rcx.tcx(),\n-                                                                                    obligation)\n-                    }\n-                    _ => {}\n+                if let Ok(obligation) = obligation {\n+                    rcx.fcx.inh.fulfillment_cx.borrow_mut().register_obligation(rcx.tcx(),\n+                                                                                obligation)\n                 }\n             }\n             type_must_outlive(\n@@ -1036,20 +1030,17 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             // after checking the inner closure (and hence\n             // determining the final borrow_kind) and propagate that as\n             // a constraint on the outer closure.\n-            match freevar.def {\n-                def::DefUpvar(var_id, outer_closure_id, _) => {\n-                    // thing being captured is itself an upvar:\n-                    let outer_upvar_id = ty::UpvarId {\n-                        var_id: var_id,\n-                        closure_expr_id: outer_closure_id };\n-                    let inner_upvar_id = ty::UpvarId {\n-                        var_id: var_id,\n-                        closure_expr_id: expr.id };\n-                    link_upvar_borrow_kind_for_nested_closures(rcx,\n-                                                               inner_upvar_id,\n-                                                               outer_upvar_id);\n-                }\n-                _ => {}\n+            if let def::DefUpvar(var_id, outer_closure_id, _) = freevar.def {\n+                // thing being captured is itself an upvar:\n+                let outer_upvar_id = ty::UpvarId {\n+                    var_id: var_id,\n+                    closure_expr_id: outer_closure_id };\n+                let inner_upvar_id = ty::UpvarId {\n+                    var_id: var_id,\n+                    closure_expr_id: expr.id };\n+                link_upvar_borrow_kind_for_nested_closures(rcx,\n+                                                           inner_upvar_id,\n+                                                           outer_upvar_id);\n             }\n         }\n     }\n@@ -1199,12 +1190,9 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n             None => derefd_ty\n         };\n \n-        match derefd_ty.sty {\n-            ty::ty_rptr(r_ptr, _) => {\n-                mk_subregion_due_to_dereference(rcx, deref_expr.span,\n-                                                r_deref_expr, r_ptr);\n-            }\n-            _ => {}\n+        if let ty::ty_rptr(r_ptr, _) =  derefd_ty.sty {\n+            mk_subregion_due_to_dereference(rcx, deref_expr.span,\n+                                            r_deref_expr, r_ptr);\n         }\n \n         match ty::deref(derefd_ty, true) {\n@@ -1235,16 +1223,14 @@ fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            rcx.fcx.infcx().ty_to_string(indexed_ty));\n \n     let r_index_expr = ty::ReScope(CodeExtent::from_node_id(index_expr.id));\n-    match indexed_ty.sty {\n-        ty::ty_rptr(r_ptr, mt) => match mt.ty.sty {\n+    if let ty::ty_rptr(r_ptr, mt) = indexed_ty.sty {\n+        match mt.ty.sty {\n             ty::ty_vec(_, None) | ty::ty_str => {\n                 rcx.fcx.mk_subr(infer::IndexSlice(index_expr.span),\n                                 r_index_expr, r_ptr);\n             }\n             _ => {}\n-        },\n-\n-        _ => {}\n+        }\n     }\n }\n \n@@ -1615,21 +1601,18 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n             // upvar borrow kind to mutable/unique.  Record the\n             // information needed to perform the recursive link in the\n             // maybe link map.\n-            match note {\n-                mc::NoteUpvarRef(upvar_id) => {\n-                    let link = MaybeLink {\n-                        span: span,\n-                        borrow_region: borrow_region,\n-                        borrow_kind: new_borrow_kind,\n-                        borrow_cmt: ref_cmt\n-                    };\n-\n-                    match rcx.maybe_links.borrow_mut().entry(upvar_id) {\n-                        Vacant(entry) => { entry.set(vec![link]); }\n-                        Occupied(entry) => { entry.into_mut().push(link); }\n-                    }\n-                },\n-                _ => {}\n+            if let mc::NoteUpvarRef(upvar_id) = note {\n+                let link = MaybeLink {\n+                    span: span,\n+                    borrow_region: borrow_region,\n+                    borrow_kind: new_borrow_kind,\n+                    borrow_cmt: ref_cmt\n+                };\n+\n+                match rcx.maybe_links.borrow_mut().entry(upvar_id) {\n+                    Vacant(entry) => { entry.set(vec![link]); }\n+                    Occupied(entry) => { entry.into_mut().push(link); }\n+                }\n             }\n \n             return None;\n@@ -1673,19 +1656,15 @@ fn adjust_upvar_borrow_kind_for_mut<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n             mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                match cmt.note {\n-                    mc::NoteUpvarRef(ref upvar_id) => {\n-                        // if this is an implicit deref of an\n-                        // upvar, then we need to modify the\n-                        // borrow_kind of the upvar to make sure it\n-                        // is inferred to mutable if necessary\n-                        let mut upvar_borrow_map =\n-                            rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                        let ub = &mut (*upvar_borrow_map)[*upvar_id];\n-                        return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::MutBorrow);\n-                    }\n-\n-                    _ => {}\n+                if let mc::NoteUpvarRef(ref upvar_id) = cmt.note {\n+                    // if this is an implicit deref of an\n+                    // upvar, then we need to modify the\n+                    // borrow_kind of the upvar to make sure it\n+                    // is inferred to mutable if necessary\n+                    let mut upvar_borrow_map =\n+                        rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+                    let ub = &mut (*upvar_borrow_map)[*upvar_id];\n+                    return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::MutBorrow);\n                 }\n \n                 // assignment to deref of an `&mut`\n@@ -1724,18 +1703,14 @@ fn adjust_upvar_borrow_kind_for_unique<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, cmt: mc::c\n \n             mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                match cmt.note {\n-                    mc::NoteUpvarRef(ref upvar_id) => {\n-                        // if this is an implicit deref of an\n-                        // upvar, then we need to modify the\n-                        // borrow_kind of the upvar to make sure it\n-                        // is inferred to unique if necessary\n-                        let mut ub = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                        let ub = &mut (*ub)[*upvar_id];\n-                        return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::UniqueImmBorrow);\n-                    }\n-\n-                    _ => {}\n+                if let mc::NoteUpvarRef(ref upvar_id) = cmt.note {\n+                    // if this is an implicit deref of an\n+                    // upvar, then we need to modify the\n+                    // borrow_kind of the upvar to make sure it\n+                    // is inferred to unique if necessary\n+                    let mut ub = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+                    let ub = &mut (*ub)[*upvar_id];\n+                    return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::UniqueImmBorrow);\n                 }\n \n                 // for a borrowed pointer to be unique, its"}, {"sha": "84cb74b4de2481755bb8959a4b75bdafcb7b3476", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -208,15 +208,13 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n         };\n         let ref sig = method.fty.sig;\n         for &input_ty in sig.inputs[1..].iter() {\n-            match check_for_self_ty(input_ty) {\n-                Some(msg) => msgs.push(msg),\n-                _ => {}\n+            if let Some(msg) = check_for_self_ty(input_ty) {\n+                msgs.push(msg);\n             }\n         }\n         if let ty::FnConverging(result_type) = sig.output {\n-            match check_for_self_ty(result_type) {\n-                Some(msg) => msgs.push(msg),\n-                _ => {}\n+            if let Some(msg) = check_for_self_ty(result_type) {\n+                msgs.push(msg);\n             }\n         }\n \n@@ -290,10 +288,9 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      traits::ObjectCastObligation(object_trait_ty)),\n                 referent_ty,\n                 builtin_bound);\n-            match obligation {\n-                Ok(obligation) => fcx.register_obligation(obligation),\n-                _ => {}\n-            }\n+        if let Ok(obligation) = obligation {\n+            fcx.register_obligation(obligation);\n+        }\n     }\n \n     object_trait_ref"}, {"sha": "8535ec4fa6e801d5184e2832d6eb9f3586af9e92", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -127,9 +127,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                                               cause,\n                                                                               field.ty,\n                                                                               ty::BoundSized);\n-                        match obligation {\n-                            Ok(obligation) => fcx.register_obligation(obligation),\n-                            _ => {}\n+                        if let Ok(obligation) = obligation {\n+                            fcx.register_obligation(obligation);\n                         }\n                     }\n                 }\n@@ -233,9 +232,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                                       cause,\n                                                                       trait_ref.self_ty(),\n                                                                       builtin_bound);\n-                match obligation {\n-                    Ok (obligation) => fcx.register_obligation(obligation),\n-                    _ => {}\n+                if let Ok(obligation) = obligation {\n+                    fcx.register_obligation(obligation);\n                 }\n             }\n             for trait_bound in trait_def.bounds.trait_bounds.iter() {\n@@ -471,9 +469,8 @@ fn check_struct_safe_for_destructor<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                               cause,\n                                                               self_ty,\n                                                               ty::BoundSend);\n-        match obligation {\n-            Ok(obligation) => fcx.register_obligation(obligation),\n-            _ => {}\n+        if let Ok(obligation) = obligation {\n+            fcx.register_obligation(obligation);\n         }\n     } else {\n         span_err!(fcx.tcx().sess, span, E0141,"}, {"sha": "6e989dd73dbeff548668c0141225616878d66ee3", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 135, "deletions": 160, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -258,112 +258,96 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    trait_def: &ty::TraitDef<'tcx>) {\n     let tcx = ccx.tcx;\n-    match tcx.map.get(trait_id) {\n-        ast_map::NodeItem(item) => {\n-            match item.node {\n-                ast::ItemTrait(_, _, _, ref trait_items) => {\n-                    // For each method, construct a suitable ty::Method and\n-                    // store it into the `tcx.impl_or_trait_items` table:\n-                    for trait_item in trait_items.iter() {\n-                        match *trait_item {\n-                            ast::RequiredMethod(_) |\n-                            ast::ProvidedMethod(_) => {\n-                                let ty_method = Rc::new(match *trait_item {\n-                                    ast::RequiredMethod(ref m) => {\n-                                        ty_method_of_trait_method(\n-                                            ccx,\n-                                            trait_id,\n-                                            &trait_def.generics,\n-                                            trait_items.as_slice(),\n-                                            &m.id,\n-                                            &m.ident.name,\n-                                            &m.explicit_self,\n-                                            m.abi,\n-                                            &m.generics,\n-                                            &m.fn_style,\n-                                            &*m.decl)\n-                                    }\n-                                    ast::ProvidedMethod(ref m) => {\n-                                        ty_method_of_trait_method(\n-                                            ccx,\n-                                            trait_id,\n-                                            &trait_def.generics,\n-                                            trait_items.as_slice(),\n-                                            &m.id,\n-                                            &m.pe_ident().name,\n-                                            m.pe_explicit_self(),\n-                                            m.pe_abi(),\n-                                            m.pe_generics(),\n-                                            &m.pe_fn_style(),\n-                                            &*m.pe_fn_decl())\n-                                    }\n-                                    ast::TypeTraitItem(ref at) => {\n-                                        tcx.sess.span_bug(at.ty_param.span,\n-                                                          \"there shouldn't \\\n-                                                           be a type trait \\\n-                                                           item here\")\n-                                    }\n-                                });\n-\n-                                debug!(\"ty_method_of_trait_method yielded {} \\\n-                                        for method {} of trait {}\",\n-                                       ty_method.repr(ccx.tcx),\n-                                       trait_item.repr(ccx.tcx),\n-                                       local_def(trait_id).repr(ccx.tcx));\n-\n-                                make_method_ty(ccx, &*ty_method);\n-\n-                                tcx.impl_or_trait_items\n-                                   .borrow_mut()\n-                                   .insert(ty_method.def_id,\n-                                           ty::MethodTraitItem(ty_method));\n+    if let ast_map::NodeItem(item) = tcx.map.get(trait_id) {\n+        if let ast::ItemTrait(_, _, _, ref trait_items) = item.node {\n+            // For each method, construct a suitable ty::Method and\n+            // store it into the `tcx.impl_or_trait_items` table:\n+            for trait_item in trait_items.iter() {\n+                match *trait_item {\n+                    ast::RequiredMethod(_) |\n+                    ast::ProvidedMethod(_) => {\n+                        let ty_method = Rc::new(match *trait_item {\n+                            ast::RequiredMethod(ref m) => {\n+                                ty_method_of_trait_method(\n+                                    ccx,\n+                                    trait_id,\n+                                    &trait_def.generics,\n+                                    trait_items.as_slice(),\n+                                    &m.id,\n+                                    &m.ident.name,\n+                                    &m.explicit_self,\n+                                    m.abi,\n+                                    &m.generics,\n+                                    &m.fn_style,\n+                                    &*m.decl)\n                             }\n-                            ast::TypeTraitItem(ref ast_associated_type) => {\n-                                let trait_did = local_def(trait_id);\n-                                let associated_type = ty::AssociatedType {\n-                                    name: ast_associated_type.ty_param.ident.name,\n-                                    vis: ast::Public,\n-                                    def_id: local_def(ast_associated_type.ty_param.id),\n-                                    container: TraitContainer(trait_did),\n-                                };\n-\n-                                let trait_item = ty::TypeTraitItem(Rc::new(\n-                                        associated_type));\n-                                tcx.impl_or_trait_items\n-                                   .borrow_mut()\n-                                   .insert(associated_type.def_id,\n-                                           trait_item);\n+                            ast::ProvidedMethod(ref m) => {\n+                                ty_method_of_trait_method(\n+                                    ccx,\n+                                    trait_id,\n+                                    &trait_def.generics,\n+                                    trait_items.as_slice(),\n+                                    &m.id,\n+                                    &m.pe_ident().name,\n+                                    m.pe_explicit_self(),\n+                                    m.pe_abi(),\n+                                    m.pe_generics(),\n+                                    &m.pe_fn_style(),\n+                                    &*m.pe_fn_decl())\n                             }\n-                        }\n-                    }\n-\n-                    // Add an entry mapping\n-                    let trait_item_def_ids =\n-                        Rc::new(trait_items.iter()\n-                                           .map(|ti| {\n-                            match *ti {\n-                                ast::RequiredMethod(ref ty_method) => {\n-                                    ty::MethodTraitItemId(local_def(\n-                                            ty_method.id))\n-                                }\n-                                ast::ProvidedMethod(ref method) => {\n-                                    ty::MethodTraitItemId(local_def(\n-                                            method.id))\n-                                }\n-                                ast::TypeTraitItem(ref typedef) => {\n-                                    ty::TypeTraitItemId(local_def(typedef.ty_param.id))\n-                                }\n+                            ast::TypeTraitItem(ref at) => {\n+                                tcx.sess.span_bug(at.ty_param.span,\n+                                                  \"there shouldn't be a type trait item here\")\n                             }\n-                        }).collect());\n+                        });\n+\n+                        debug!(\"ty_method_of_trait_method yielded {} for method {} of trait {}\",\n+                               ty_method.repr(ccx.tcx),\n+                               trait_item.repr(ccx.tcx),\n+                               local_def(trait_id).repr(ccx.tcx));\n+\n+                        make_method_ty(ccx, &*ty_method);\n \n-                    let trait_def_id = local_def(trait_id);\n-                    tcx.trait_item_def_ids.borrow_mut()\n-                        .insert(trait_def_id, trait_item_def_ids);\n+                        tcx.impl_or_trait_items\n+                            .borrow_mut()\n+                            .insert(ty_method.def_id, ty::MethodTraitItem(ty_method));\n+                    }\n+                    ast::TypeTraitItem(ref ast_associated_type) => {\n+                        let trait_did = local_def(trait_id);\n+                        let associated_type = ty::AssociatedType {\n+                            name: ast_associated_type.ty_param.ident.name,\n+                            vis: ast::Public,\n+                            def_id: local_def(ast_associated_type.ty_param.id),\n+                            container: TraitContainer(trait_did),\n+                        };\n+\n+                        let trait_item = ty::TypeTraitItem(Rc::new(associated_type));\n+                        tcx.impl_or_trait_items\n+                            .borrow_mut()\n+                            .insert(associated_type.def_id, trait_item);\n+                    }\n                 }\n-                _ => {} // Ignore things that aren't traits.\n             }\n+\n+            // Add an entry mapping\n+            let trait_item_def_ids =\n+                Rc::new(trait_items.iter().map(|ti| {\n+                    match *ti {\n+                        ast::RequiredMethod(ref ty_method) => {\n+                            ty::MethodTraitItemId(local_def(ty_method.id))\n+                        }\n+                        ast::ProvidedMethod(ref method) => {\n+                            ty::MethodTraitItemId(local_def(method.id))\n+                        }\n+                        ast::TypeTraitItem(ref typedef) => {\n+                            ty::TypeTraitItemId(local_def(typedef.ty_param.id))\n+                        }\n+                    }\n+                }).collect());\n+\n+            let trait_def_id = local_def(trait_id);\n+            tcx.trait_item_def_ids.borrow_mut().insert(trait_def_id, trait_item_def_ids);\n         }\n-        _ => { /* Ignore things that aren't traits */ }\n     }\n \n     fn make_method_ty<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n@@ -664,17 +648,13 @@ fn is_associated_type_valid_for_param(ty: Ty,\n                                       trait_id: ast::DefId,\n                                       generics: &ty::Generics)\n                                       -> bool {\n-    match ty.sty {\n-        ty::ty_param(param_ty) => {\n-            let type_parameter = generics.types.get(param_ty.space,\n-                                                    param_ty.idx);\n-            for trait_bound in type_parameter.bounds.trait_bounds.iter() {\n-                if trait_bound.def_id == trait_id {\n-                    return true\n-                }\n+    if let ty::ty_param(param_ty) = ty.sty {\n+        let type_parameter = generics.types.get(param_ty.space, param_ty.idx);\n+        for trait_bound in type_parameter.bounds.trait_bounds.iter() {\n+            if trait_bound.def_id == trait_id {\n+                return true\n             }\n         }\n-        _ => {}\n     }\n \n     false\n@@ -1352,9 +1332,8 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    -> Rc<ty::TraitDef<'tcx>> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    match tcx.trait_defs.borrow().get(&def_id) {\n-        Some(def) => return def.clone(),\n-        _ => {}\n+    if let Some(def) = tcx.trait_defs.borrow().get(&def_id) {\n+        return def.clone();\n     }\n \n     let (generics, unbound, bounds, items) = match it.node {\n@@ -1452,9 +1431,8 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                             -> ty::Polytype<'tcx> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    match tcx.tcache.borrow().get(&def_id) {\n-        Some(pty) => return pty.clone(),\n-        _ => {}\n+    if let Some(pty) = tcx.tcache.borrow().get(&def_id) {\n+        return pty.clone();\n     }\n     match it.node {\n         ast::ItemStatic(ref t, _, _) | ast::ItemConst(ref t, _) => {\n@@ -2146,54 +2124,51 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n     explicit_self: &ast::ExplicitSelf,\n     body_id: ast::NodeId)\n {\n-    match explicit_self.node {\n-        ast::SelfExplicit(ref ast_type, _) => {\n-            let typ = crate_context.to_ty(rs, &**ast_type);\n-            let base_type = match typ.sty {\n-                ty::ty_ptr(tm) | ty::ty_rptr(_, tm) => tm.ty,\n-                ty::ty_uniq(typ) => typ,\n-                _ => typ,\n-            };\n+    if let ast::SelfExplicit(ref ast_type, _) = explicit_self.node {\n+        let typ = crate_context.to_ty(rs, &**ast_type);\n+        let base_type = match typ.sty {\n+            ty::ty_ptr(tm) | ty::ty_rptr(_, tm) => tm.ty,\n+            ty::ty_uniq(typ) => typ,\n+            _ => typ,\n+        };\n \n-            let body_scope = region::CodeExtent::from_node_id(body_id);\n-\n-            // \"Required type\" comes from the trait definition. It may\n-            // contain late-bound regions from the method, but not the\n-            // trait (since traits only have early-bound region\n-            // parameters).\n-            assert!(!ty::type_escapes_depth(required_type, 1));\n-            let required_type_free =\n-                ty::liberate_late_bound_regions(\n-                    crate_context.tcx, body_scope, &ty::bind(required_type)).value;\n-\n-            // The \"base type\" comes from the impl. It may have late-bound\n-            // regions from the impl or the method.\n-            let base_type_free = // liberate impl regions:\n-                ty::liberate_late_bound_regions(\n-                    crate_context.tcx, body_scope, &ty::bind(ty::bind(base_type))).value.value;\n-            let base_type_free = // liberate method regions:\n-                ty::liberate_late_bound_regions(\n-                    crate_context.tcx, body_scope, &ty::bind(base_type_free)).value;\n-\n-            debug!(\"required_type={} required_type_free={} \\\n-                    base_type={} base_type_free={}\",\n-                   required_type.repr(crate_context.tcx),\n-                   required_type_free.repr(crate_context.tcx),\n-                   base_type.repr(crate_context.tcx),\n-                   base_type_free.repr(crate_context.tcx));\n-            let infcx = infer::new_infer_ctxt(crate_context.tcx);\n-            drop(typeck::require_same_types(crate_context.tcx,\n-                                            Some(&infcx),\n-                                            false,\n-                                            explicit_self.span,\n-                                            base_type_free,\n-                                            required_type_free,\n-                                            || {\n+        let body_scope = region::CodeExtent::from_node_id(body_id);\n+\n+        // \"Required type\" comes from the trait definition. It may\n+        // contain late-bound regions from the method, but not the\n+        // trait (since traits only have early-bound region\n+        // parameters).\n+        assert!(!ty::type_escapes_depth(required_type, 1));\n+        let required_type_free =\n+            ty::liberate_late_bound_regions(\n+                crate_context.tcx, body_scope, &ty::bind(required_type)).value;\n+\n+        // The \"base type\" comes from the impl. It may have late-bound\n+        // regions from the impl or the method.\n+        let base_type_free = // liberate impl regions:\n+            ty::liberate_late_bound_regions(\n+                crate_context.tcx, body_scope, &ty::bind(ty::bind(base_type))).value.value;\n+        let base_type_free = // liberate method regions:\n+            ty::liberate_late_bound_regions(\n+                crate_context.tcx, body_scope, &ty::bind(base_type_free)).value;\n+\n+        debug!(\"required_type={} required_type_free={} \\\n+                base_type={} base_type_free={}\",\n+               required_type.repr(crate_context.tcx),\n+               required_type_free.repr(crate_context.tcx),\n+               base_type.repr(crate_context.tcx),\n+               base_type_free.repr(crate_context.tcx));\n+        let infcx = infer::new_infer_ctxt(crate_context.tcx);\n+        drop(typeck::require_same_types(crate_context.tcx,\n+                                        Some(&infcx),\n+                                        false,\n+                                        explicit_self.span,\n+                                        base_type_free,\n+                                        required_type_free,\n+                                        || {\n                 format!(\"mismatched self type: expected `{}`\",\n                         ppaux::ty_to_string(crate_context.tcx, required_type))\n-            }));\n-            infcx.resolve_regions_and_report_errors();\n-        }\n-        _ => {}\n+        }));\n+        infcx.resolve_regions_and_report_errors();\n     }\n }"}, {"sha": "a8018662d292f204b5ead25144eecc5b5c418900", "filename": "src/librustc/plugin/build.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fplugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc%2Fplugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fbuild.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -23,14 +23,11 @@ struct RegistrarFinder {\n \n impl<'v> Visitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemFn(..) => {\n-                if attr::contains_name(item.attrs.as_slice(),\n-                                       \"plugin_registrar\") {\n-                    self.registrars.push((item.id, item.span));\n-                }\n+        if let ast::ItemFn(..) = item.node {\n+            if attr::contains_name(item.attrs.as_slice(),\n+                                   \"plugin_registrar\") {\n+                self.registrars.push((item.id, item.span));\n             }\n-            _ => {}\n         }\n \n         visit::walk_item(self, item);"}, {"sha": "d8cdffe210057e8b91955105ee6afc9039a260c0", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -139,39 +139,27 @@ pub fn find_crate_name(sess: Option<&Session>,\n     let attr_crate_name = attrs.iter().find(|at| at.check_name(\"crate_name\"))\n                                .and_then(|at| at.value_str().map(|s| (at, s)));\n \n-    match sess {\n-        Some(sess) => {\n-            match sess.opts.crate_name {\n-                Some(ref s) => {\n-                    match attr_crate_name {\n-                        Some((attr, ref name)) if s.as_slice() != name.get() => {\n-                            let msg = format!(\"--crate-name and #[crate_name] \\\n-                                               are required to match, but `{}` \\\n-                                               != `{}`\", s, name);\n-                            sess.span_err(attr.span, msg.as_slice());\n-                        }\n-                        _ => {},\n-                    }\n-                    return validate(s.clone(), None);\n+    if let Some(sess) = sess {\n+        if let Some(ref s) = sess.opts.crate_name {\n+            if let Some((attr, ref name)) = attr_crate_name {\n+                if s.as_slice() != name.get() {\n+                    let msg = format!(\"--crate-name and #[crate_name] are \\\n+                                       required to match, but `{}` != `{}`\",\n+                                      s, name);\n+                    sess.span_err(attr.span, msg.as_slice());\n                 }\n-                None => {}\n             }\n+            return validate(s.clone(), None);\n         }\n-        None => {}\n     }\n \n-    match attr_crate_name {\n-        Some((attr, s)) => return validate(s.get().to_string(), Some(attr.span)),\n-        None => {}\n+    if let Some((attr, s)) = attr_crate_name {\n+        return validate(s.get().to_string(), Some(attr.span));\n     }\n-    match *input {\n-        FileInput(ref path) => {\n-            match path.filestem_str() {\n-                Some(s) => return validate(s.to_string(), None),\n-                None => {}\n-            }\n+    if let FileInput(ref path) = *input {\n+        if let Some(s) = path.filestem_str() {\n+            return validate(s.to_string(), None);\n         }\n-        _ => {}\n     }\n \n     \"rust-out\".to_string()"}, {"sha": "7a41be1dbe46f49013551c32335f2174c925a0ab", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -1073,16 +1073,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     fn visit_generics(&mut self, generics: &ast::Generics) {\n         for param in generics.ty_params.iter() {\n             for bound in param.bounds.iter() {\n-                match *bound {\n-                    ast::TraitTyParamBound(ref trait_ref) => {\n-                        self.process_trait_ref(&trait_ref.trait_ref, None);\n-                    }\n-                    _ => {}\n+                if let ast::TraitTyParamBound(ref trait_ref) = *bound {\n+                    self.process_trait_ref(&trait_ref.trait_ref, None);\n                 }\n             }\n-            match param.default {\n-                Some(ref ty) => self.visit_ty(&**ty),\n-                None => {}\n+            if let Some(ref ty) = param.default {\n+                self.visit_ty(&**ty);\n             }\n         }\n     }"}, {"sha": "ada46ab7db71942ae48de30155f90109cc4c5fb6", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -438,14 +438,11 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     }\n                 }\n                 ast::PatVec(ref before, Some(ref slice), ref after) => {\n-                    match slice.node {\n-                        ast::PatIdent(_, ref path, None) => {\n-                            let subslice_val = bind_subslice_pat(\n-                                bcx, this.id, val,\n-                                before.len(), after.len());\n-                            bound_ptrs.push((path.node, subslice_val));\n-                        }\n-                        _ => {}\n+                    if let ast::PatIdent(_, ref path, None) = slice.node {\n+                        let subslice_val = bind_subslice_pat(\n+                            bcx, this.id, val,\n+                            before.len(), after.len());\n+                        bound_ptrs.push((path.node, subslice_val));\n                     }\n                 }\n                 _ => {}\n@@ -835,9 +832,8 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 let datum = Datum::new(llval, binding_info.ty, Lvalue);\n                 call_lifetime_start(bcx, llbinding);\n                 bcx = datum.store_to(bcx, llbinding);\n-                match cs {\n-                    Some(cs) => bcx.fcx.schedule_lifetime_end(cs, llbinding),\n-                    _ => {}\n+                if let Some(cs) = cs {\n+                    bcx.fcx.schedule_lifetime_end(cs, llbinding);\n                 }\n \n                 llbinding\n@@ -851,12 +847,9 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         };\n \n         let datum = Datum::new(llval, binding_info.ty, Lvalue);\n-        match cs {\n-            Some(cs) => {\n-                bcx.fcx.schedule_drop_and_zero_mem(cs, llval, binding_info.ty);\n-                bcx.fcx.schedule_lifetime_end(cs, binding_info.llmatch);\n-            }\n-            _ => {}\n+        if let Some(cs) = cs {\n+            bcx.fcx.schedule_drop_and_zero_mem(cs, llval, binding_info.ty);\n+            bcx.fcx.schedule_lifetime_end(cs, binding_info.llmatch);\n         }\n \n         debug!(\"binding {} to {}\",\n@@ -894,9 +887,8 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let val = val.to_llbool(bcx);\n \n     for (_, &binding_info) in data.bindings_map.iter() {\n-        match binding_info.trmode {\n-            TrByCopy(llbinding) => call_lifetime_end(bcx, llbinding),\n-            _ => {}\n+        if let TrByCopy(llbinding) = binding_info.trmode {\n+            call_lifetime_end(bcx, llbinding);\n         }\n     }\n "}, {"sha": "9d6d1bc4a9e1ced372b43066d1cf2503a50a744f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -2212,21 +2212,18 @@ pub fn update_linkage(ccx: &CrateContext,\n         OriginalTranslation => {},\n     }\n \n-    match id {\n-        Some(id) => {\n-            let item = ccx.tcx().map.get(id);\n-            if let ast_map::NodeItem(i) = item {\n-                if let Some(name) =  attr::first_attr_value_str_by_name(i.attrs[], \"linkage\") {\n-                    if let Some(linkage) = llvm_linkage_by_name(name.get()) {\n-                        llvm::SetLinkage(llval, linkage);\n-                    } else {\n-                        ccx.sess().span_fatal(i.span, \"invalid linkage specified\");\n-                    }\n-                    return;\n+    if let Some(id) = id {\n+        let item = ccx.tcx().map.get(id);\n+        if let ast_map::NodeItem(i) = item {\n+            if let Some(name) = attr::first_attr_value_str_by_name(i.attrs[], \"linkage\") {\n+                if let Some(linkage) = llvm_linkage_by_name(name.get()) {\n+                    llvm::SetLinkage(llval, linkage);\n+                } else {\n+                    ccx.sess().span_fatal(i.span, \"invalid linkage specified\");\n                 }\n+                return;\n             }\n         }\n-        _ => {}\n     }\n \n     match id {\n@@ -2492,11 +2489,8 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n                 _ => {}\n             }\n \n-            match ret_ty.sty {\n-                ty::ty_bool => {\n-                    attrs.ret(llvm::ZExtAttribute);\n-                }\n-                _ => {}\n+            if let ty::ty_bool = ret_ty.sty {\n+                attrs.ret(llvm::ZExtAttribute);\n             }\n         }\n     }\n@@ -2543,11 +2537,8 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n                     attrs.arg(idx, llvm::ReadOnlyAttribute);\n                 }\n \n-                match b {\n-                    ReLateBound(_, BrAnon(_)) => {\n-                        attrs.arg(idx, llvm::NoCaptureAttribute);\n-                    }\n-                    _ => {}\n+                if let ReLateBound(_, BrAnon(_)) = b {\n+                    attrs.arg(idx, llvm::NoCaptureAttribute);\n                 }\n             }\n "}, {"sha": "80a17465d7899af0b6f1834ee40a6ea0698b0519", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -92,11 +92,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n     debug!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n \n     // pick out special kinds of expressions that can be called:\n-    match expr.node {\n-        ast::ExprPath(_) => {\n-            return trans_def(bcx, bcx.def(expr.id), expr);\n-        }\n-        _ => {}\n+    if let ast::ExprPath(_) = expr.node {\n+        return trans_def(bcx, bcx.def(expr.id), expr);\n     }\n \n     // any other expressions are closures:"}, {"sha": "33393ba76c58059805995150b066770c6d39d8a9", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -236,11 +236,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     /// Returns the id of the top-most loop scope\n     fn top_loop_scope(&self) -> ast::NodeId {\n         for scope in self.scopes.borrow().iter().rev() {\n-            match scope.kind {\n-                LoopScopeKind(id, _) => {\n-                    return id;\n-                }\n-                _ => {}\n+            if let LoopScopeKind(id, _) = scope.kind {\n+                return id;\n             }\n         }\n         self.ccx.sess().bug(\"no loop scope found\");"}, {"sha": "42daf71881605342c5a672395091cd346d7a4a0a", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -171,9 +171,8 @@ pub fn get_const_val(cx: &CrateContext,\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n         }\n \n-        match cx.tcx().map.expect_item(def_id.node).node {\n-            ast::ItemConst(..) => { base::get_item_val(cx, def_id.node); }\n-            _ => {}\n+        if let ast::ItemConst(..) = cx.tcx().map.expect_item(def_id.node).node {\n+            base::get_item_val(cx, def_id.node);\n         }\n     }\n \n@@ -546,12 +545,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   }\n               }\n               let opt_def = cx.tcx().def_map.borrow().get(&cur.id).cloned();\n-              match opt_def {\n-                  Some(def::DefStatic(def_id, _)) => {\n-                      let ty = ty::expr_ty(cx.tcx(), e);\n-                      return get_static_val(cx, def_id, ty);\n-                  }\n-                  _ => {}\n+              if let Some(def::DefStatic(def_id, _)) = opt_def {\n+                  let ty = ty::expr_ty(cx.tcx(), e);\n+                  return get_static_val(cx, def_id, ty);\n               }\n \n               // If this isn't the address of a static, then keep going through"}, {"sha": "a0b7eb02f02e448897bedcaa344c09d8987b26e0", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -519,9 +519,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn get_intrinsic(&self, key: & &'static str) -> ValueRef {\n-        match self.intrinsics().borrow().get(key).cloned() {\n-            Some(v) => return v,\n-            _ => {}\n+        if let Some(v) = self.intrinsics().borrow().get(key).cloned() {\n+            return v;\n         }\n         match declare_intrinsic(self, key) {\n             Some(v) => return v,"}, {"sha": "7b2e48cd2e3186e53b86780606dc04e834d08c60", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -465,17 +465,14 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         _ => expr::Ignore,\n     };\n-    match e {\n-        Some(x) => {\n-            bcx = expr::trans_into(bcx, &*x, dest);\n-            match dest {\n-                expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n-                    Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n-                }\n-                _ => {}\n+    if let Some(x) = e {\n+        bcx = expr::trans_into(bcx, &*x, dest);\n+        match dest {\n+            expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n+                Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n             }\n+            _ => {}\n         }\n-        _ => {}\n     }\n     let cleanup_llbb = fcx.return_exit_block();\n     Br(bcx, cleanup_llbb);"}, {"sha": "5a9131d94e27d67b4dab6e7d901887bab3e49a55", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -209,14 +209,11 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             // (You might think there is a more elegant way to do this than a\n             // use_autoref bool, but then you remember that the borrow checker exists).\n-            match (use_autoref, &adj.autoref) {\n-                (true, &Some(ref a)) => {\n-                    datum = unpack_datum!(bcx, apply_autoref(a,\n-                                                             bcx,\n-                                                             expr,\n-                                                             datum));\n-                }\n-                _ => {}\n+            if let (true, &Some(ref a)) = (use_autoref, &adj.autoref) {\n+                datum = unpack_datum!(bcx, apply_autoref(a,\n+                                                         bcx,\n+                                                         expr,\n+                                                         datum));\n             }\n         }\n     }"}, {"sha": "615d5467f8464541f1d5c6199305761b40792a6e", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -355,9 +355,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // skip padding\n         if arg_ty.pad.is_some() { arg_idx += 1; }\n \n-        match arg_ty.attr {\n-            Some(attr) => { attrs.arg(arg_idx, attr); },\n-            _ => {}\n+        if let Some(attr) = arg_ty.attr {\n+            attrs.arg(arg_idx, attr);\n         }\n \n         arg_idx += 1;\n@@ -429,22 +428,19 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n     for foreign_item in foreign_mod.items.iter() {\n         let lname = link_name(&**foreign_item);\n \n-        match foreign_item.node {\n-            ast::ForeignItemFn(..) => {\n-                match foreign_mod.abi {\n-                    Rust | RustIntrinsic => {}\n-                    abi => {\n-                        let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n-                        register_foreign_item_fn(ccx, abi, ty,\n-                                                 lname.get().as_slice());\n-                        // Unlike for other items, we shouldn't call\n-                        // `base::update_linkage` here.  Foreign items have\n-                        // special linkage requirements, which are handled\n-                        // inside `foreign::register_*`.\n-                    }\n+        if let ast::ForeignItemFn(..) = foreign_item.node {\n+            match foreign_mod.abi {\n+                Rust | RustIntrinsic => {}\n+                abi => {\n+                    let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n+                    register_foreign_item_fn(ccx, abi, ty,\n+                                             lname.get().as_slice());\n+                    // Unlike for other items, we shouldn't call\n+                    // `base::update_linkage` here.  Foreign items have\n+                    // special linkage requirements, which are handled\n+                    // inside `foreign::register_*`.\n                 }\n             }\n-            _ => {}\n         }\n \n         ccx.item_symbols().borrow_mut().insert(foreign_item.id,"}, {"sha": "cb3c56ad2778e63e05892fb4b76fd2de2c9fb402", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -84,14 +84,11 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     fn_id)\n         });\n \n-    match map_node {\n-        ast_map::NodeForeignItem(_) => {\n-            if ccx.tcx().map.get_foreign_abi(fn_id.node) != abi::RustIntrinsic {\n-                // Foreign externs don't have to be monomorphized.\n-                return (get_item_val(ccx, fn_id.node), true);\n-            }\n+    if let ast_map::NodeForeignItem(_) = map_node {\n+        if ccx.tcx().map.get_foreign_abi(fn_id.node) != abi::RustIntrinsic {\n+            // Foreign externs don't have to be monomorphized.\n+            return (get_item_val(ccx, fn_id.node), true);\n         }\n-        _ => {}\n     }\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));"}, {"sha": "00f938191f8d9438276b766fa951432cc59b2a60", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -151,21 +151,15 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let vec_ty = node_id_type(bcx, slice_expr.id);\n \n     // Handle the \"...\" case (returns a slice since strings are always unsized):\n-    match content_expr.node {\n-        ast::ExprLit(ref lit) => {\n-            match lit.node {\n-                ast::LitStr(ref s, _) => {\n-                    let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n-                    bcx = trans_lit_str(bcx,\n-                                        content_expr,\n-                                        s.clone(),\n-                                        SaveIn(scratch.val));\n-                    return DatumBlock::new(bcx, scratch.to_expr_datum());\n-                }\n-                _ => {}\n-            }\n+    if let ast::ExprLit(ref lit) = content_expr.node {\n+        if let ast::LitStr(ref s, _) = lit.node {\n+            let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n+            bcx = trans_lit_str(bcx,\n+                                content_expr,\n+                                s.clone(),\n+                                SaveIn(scratch.val));\n+            return DatumBlock::new(bcx, scratch.to_expr_datum());\n         }\n-        _ => {}\n     }\n \n     // Handle the &[...] case:"}, {"sha": "6f1ddaff3605f2e7740d5f0fba977f2272f88e53", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -2203,12 +2203,9 @@ fn register_def(cx: &DocContext, def: def::Def) -> ast::DefId {\n         None => return did\n     };\n     inline::record_extern_fqn(cx, did, kind);\n-    match kind {\n-        TypeTrait => {\n-            let t = inline::build_external_trait(cx, tcx, did);\n-            cx.external_traits.borrow_mut().as_mut().unwrap().insert(did, t);\n-        }\n-        _ => {}\n+    if let TypeTrait = kind {\n+        let t = inline::build_external_trait(cx, tcx, did);\n+        cx.external_traits.borrow_mut().as_mut().unwrap().insert(did, t);\n     }\n     return did;\n }"}, {"sha": "2be703e2458bb658ddf1e695ba6a0a11d3af71ee", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 90, "deletions": 104, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -814,96 +814,87 @@ impl DocFolder for Cache {\n \n         // Propagate a trait methods' documentation to all implementors of the\n         // trait\n-        match item.inner {\n-            clean::TraitItem(ref t) => {\n-                self.traits.insert(item.def_id, t.clone());\n-            }\n-            _ => {}\n+        if let clean::TraitItem(ref t) = item.inner {\n+            self.traits.insert(item.def_id, t.clone());\n         }\n \n         // Collect all the implementors of traits.\n-        match item.inner {\n-            clean::ImplItem(ref i) => {\n-                match i.trait_ {\n-                    Some(clean::ResolvedPath{ did, .. }) => {\n-                        let v = match self.implementors.entry(did) {\n-                            Vacant(entry) => entry.set(Vec::with_capacity(1)),\n-                            Occupied(entry) => entry.into_mut(),\n-                        };\n-                        v.push(Implementor {\n-                            def_id: item.def_id,\n-                            generics: i.generics.clone(),\n-                            trait_: i.trait_.as_ref().unwrap().clone(),\n-                            for_: i.for_.clone(),\n-                            stability: item.stability.clone(),\n-                        });\n-                    }\n-                    Some(..) | None => {}\n+        if let clean::ImplItem(ref i) = item.inner {\n+            match i.trait_ {\n+                Some(clean::ResolvedPath{ did, .. }) => {\n+                    let v = match self.implementors.entry(did) {\n+                        Vacant(entry) => entry.set(Vec::with_capacity(1)),\n+                        Occupied(entry) => entry.into_mut(),\n+                    };\n+                    v.push(Implementor {\n+                        def_id: item.def_id,\n+                        generics: i.generics.clone(),\n+                        trait_: i.trait_.as_ref().unwrap().clone(),\n+                        for_: i.for_.clone(),\n+                        stability: item.stability.clone(),\n+                    });\n                 }\n+                Some(..) | None => {}\n             }\n-            _ => {}\n         }\n \n         // Index this method for searching later on\n-        match item.name {\n-            Some(ref s) => {\n-                let (parent, is_method) = match item.inner {\n-                    clean::TyMethodItem(..) |\n-                    clean::StructFieldItem(..) |\n-                    clean::VariantItem(..) => {\n-                        ((Some(*self.parent_stack.last().unwrap()),\n-                          Some(self.stack[..self.stack.len() - 1])),\n-                          false)\n-                    }\n-                    clean::MethodItem(..) => {\n-                        if self.parent_stack.len() == 0 {\n-                            ((None, None), false)\n-                        } else {\n-                            let last = self.parent_stack.last().unwrap();\n-                            let did = *last;\n-                            let path = match self.paths.get(&did) {\n-                                Some(&(_, item_type::Trait)) =>\n-                                    Some(self.stack[..self.stack.len() - 1]),\n-                                // The current stack not necessarily has correlation for\n-                                // where the type was defined. On the other hand,\n-                                // `paths` always has the right information if present.\n-                                Some(&(ref fqp, item_type::Struct)) |\n-                                Some(&(ref fqp, item_type::Enum)) =>\n-                                    Some(fqp[..fqp.len() - 1]),\n-                                Some(..) => Some(self.stack.as_slice()),\n-                                None => None\n-                            };\n-                            ((Some(*last), path), true)\n-                        }\n+        if let Some(ref s) = item.name {\n+            let (parent, is_method) = match item.inner {\n+                clean::TyMethodItem(..) |\n+                clean::StructFieldItem(..) |\n+                clean::VariantItem(..) => {\n+                    ((Some(*self.parent_stack.last().unwrap()),\n+                      Some(self.stack[..self.stack.len() - 1])),\n+                     false)\n+                }\n+                clean::MethodItem(..) => {\n+                    if self.parent_stack.len() == 0 {\n+                        ((None, None), false)\n+                    } else {\n+                        let last = self.parent_stack.last().unwrap();\n+                        let did = *last;\n+                        let path = match self.paths.get(&did) {\n+                            Some(&(_, item_type::Trait)) =>\n+                                Some(self.stack[..self.stack.len() - 1]),\n+                            // The current stack not necessarily has correlation for\n+                            // where the type was defined. On the other hand,\n+                            // `paths` always has the right information if present.\n+                            Some(&(ref fqp, item_type::Struct)) |\n+                            Some(&(ref fqp, item_type::Enum)) =>\n+                                Some(fqp[..fqp.len() - 1]),\n+                            Some(..) => Some(self.stack.as_slice()),\n+                            None => None\n+                        };\n+                        ((Some(*last), path), true)\n                     }\n-                    _ => ((None, Some(self.stack.as_slice())), false)\n-                };\n-                let hidden_field = match item.inner {\n-                    clean::StructFieldItem(clean::HiddenStructField) => true,\n-                    _ => false\n-                };\n+                }\n+                _ => ((None, Some(self.stack.as_slice())), false)\n+            };\n+            let hidden_field = match item.inner {\n+                clean::StructFieldItem(clean::HiddenStructField) => true,\n+                _ => false\n+            };\n \n-                match parent {\n-                    (parent, Some(path)) if is_method || (!self.privmod && !hidden_field) => {\n-                        self.search_index.push(IndexItem {\n-                            ty: shortty(&item),\n-                            name: s.to_string(),\n-                            path: path.connect(\"::\").to_string(),\n-                            desc: shorter(item.doc_value()).to_string(),\n-                            parent: parent,\n-                        });\n-                    }\n-                    (Some(parent), None) if is_method || (!self.privmod && !hidden_field)=> {\n-                        if ast_util::is_local(parent) {\n-                            // We have a parent, but we don't know where they're\n-                            // defined yet. Wait for later to index this item.\n-                            self.orphan_methods.push((parent.node, item.clone()))\n-                        }\n+            match parent {\n+                (parent, Some(path)) if is_method || (!self.privmod && !hidden_field) => {\n+                    self.search_index.push(IndexItem {\n+                        ty: shortty(&item),\n+                        name: s.to_string(),\n+                        path: path.connect(\"::\").to_string(),\n+                        desc: shorter(item.doc_value()).to_string(),\n+                        parent: parent,\n+                    });\n+                }\n+                (Some(parent), None) if is_method || (!self.privmod && !hidden_field)=> {\n+                    if ast_util::is_local(parent) {\n+                        // We have a parent, but we don't know where they're\n+                        // defined yet. Wait for later to index this item.\n+                        self.orphan_methods.push((parent.node, item.clone()))\n                     }\n-                    _ => {}\n                 }\n+                _ => {}\n             }\n-            None => {}\n         }\n \n         // Keep track of the fully qualified path for this item.\n@@ -1022,20 +1013,18 @@ impl DocFolder for Cache {\n                             _ => None,\n                         };\n \n-                        match did {\n-                            Some(did) => {\n-                                let v = match self.impls.entry(did) {\n-                                    Vacant(entry) => entry.set(Vec::with_capacity(1)),\n-                                    Occupied(entry) => entry.into_mut(),\n-                                };\n-                                v.push(Impl {\n-                                    impl_: i,\n-                                    dox: dox,\n-                                    stability: item.stability.clone(),\n-                                });\n-                            }\n-                            None => {}\n+                        if let Some(did) = did {\n+                            let v = match self.impls.entry(did) {\n+                                Vacant(entry) => entry.set(Vec::with_capacity(1)),\n+                                Occupied(entry) => entry.into_mut(),\n+                            };\n+                            v.push(Impl {\n+                                impl_: i,\n+                                dox: dox,\n+                                stability: item.stability.clone(),\n+                            });\n                         }\n+\n                         None\n                     }\n \n@@ -1874,22 +1863,19 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             _ => false,\n         }\n     }).peekable();\n-    match s.struct_type {\n-        doctree::Plain => {\n-            if fields.peek().is_some() {\n-                try!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n-                for field in fields {\n-                    try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n-                                      {stab}<code>{name}</code></td><td>\",\n-                                  stab = ConciseStability(&field.stability),\n-                                  name = field.name.as_ref().unwrap().as_slice()));\n-                    try!(document(w, field));\n-                    try!(write!(w, \"</td></tr>\"));\n-                }\n-                try!(write!(w, \"</table>\"));\n+    if let doctree::Plain = s.struct_type {\n+        if fields.peek().is_some() {\n+            try!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n+            for field in fields {\n+                try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n+                                  {stab}<code>{name}</code></td><td>\",\n+                            stab = ConciseStability(&field.stability),\n+                            name = field.name.as_ref().unwrap().as_slice()));\n+                try!(document(w, field));\n+                try!(write!(w, \"</td></tr>\"));\n             }\n+            try!(write!(w, \"</table>\"));\n         }\n-        _ => {}\n     }\n     render_methods(w, it)\n }"}, {"sha": "8675d2b3749cd33ef1396b18906af3b145612d9b", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -65,26 +65,20 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n         };\n         impl<'a> fold::DocFolder for ImplStripper<'a> {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n-                match i.inner {\n-                    clean::ImplItem(clean::Impl{\n-                        for_: clean::ResolvedPath{ did, .. },\n-                        ref trait_, ..\n-                    }) => {\n-                        // Impls for stripped types don't need to exist\n+                if let clean::ImplItem(clean::Impl{\n+                           for_: clean::ResolvedPath{ did, .. },\n+                           ref trait_, ..\n+                }) = i.inner {\n+                    // Impls for stripped types don't need to exist\n+                    if self.stripped.contains(&did.node) {\n+                        return None;\n+                    }\n+                    // Impls of stripped traits also don't need to exist\n+                    if let Some(clean::ResolvedPath { did, .. }) = *trait_ {\n                         if self.stripped.contains(&did.node) {\n                             return None;\n                         }\n-                        // Impls of stripped traits also don't need to exist\n-                        match *trait_ {\n-                            Some(clean::ResolvedPath { did, .. }) => {\n-                                if self.stripped.contains(&did.node) {\n-                                    return None\n-                                }\n-                            }\n-                            _ => {}\n-                        }\n                     }\n-                    _ => {}\n                 }\n                 self.fold_item_recur(i)\n             }\n@@ -239,19 +233,16 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n struct ImplStripper<'a>(&'a HashSet<ast::NodeId>);\n impl<'a> fold::DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::ImplItem(ref imp) => {\n-                match imp.trait_ {\n-                    Some(clean::ResolvedPath{ did, .. }) => {\n-                        let ImplStripper(s) = *self;\n-                        if ast_util::is_local(did) && !s.contains(&did.node) {\n-                            return None;\n-                        }\n+        if let clean::ImplItem(ref imp) = i.inner {\n+            match imp.trait_ {\n+                Some(clean::ResolvedPath{ did, .. }) => {\n+                    let ImplStripper(s) = *self;\n+                    if ast_util::is_local(did) && !s.contains(&did.node) {\n+                        return None;\n                     }\n-                    Some(..) | None => {}\n                 }\n+                Some(..) | None => {}\n             }\n-            _ => {}\n         }\n         self.fold_item_recur(i)\n     }"}, {"sha": "2913666a31535b7aebd99a0af543272bdb5b164a", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -776,11 +776,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             }\n             ItemTrait(_, _, ref bounds, ref trait_items) => {\n                 for b in bounds.iter() {\n-                    match *b {\n-                        TraitTyParamBound(ref t) => {\n-                            self.insert(t.trait_ref.ref_id, NodeItem(i));\n-                        }\n-                        _ => {}\n+                    if let TraitTyParamBound(ref t) = *b {\n+                        self.insert(t.trait_ref.ref_id, NodeItem(i));\n                     }\n                 }\n "}, {"sha": "68bb7ecfb8526d9e3b3665a4243916a4a83c5e8f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -412,13 +412,10 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         }\n \n         self.operation.visit_id(item.id);\n-        match item.node {\n-            ItemEnum(ref enum_definition, _) => {\n-                for variant in enum_definition.variants.iter() {\n-                    self.operation.visit_id(variant.node.id)\n-                }\n+        if let ItemEnum(ref enum_definition, _) = item.node {\n+            for variant in enum_definition.variants.iter() {\n+                self.operation.visit_id(variant.node.id)\n             }\n-            _ => {}\n         }\n \n         visit::walk_item(self, item);\n@@ -453,9 +450,8 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n \n     fn visit_ty(&mut self, typ: &Ty) {\n         self.operation.visit_id(typ.id);\n-        match typ.node {\n-            TyPath(_, id) => self.operation.visit_id(id),\n-            _ => {}\n+        if let TyPath(_, id) = typ.node {\n+            self.operation.visit_id(id);\n         }\n         visit::walk_ty(self, typ)\n     }\n@@ -500,9 +496,8 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n                        span);\n \n         if !self.pass_through_items {\n-            match function_kind {\n-                visit::FkMethod(..) => self.visited_outermost = false,\n-                _ => {}\n+            if let visit::FkMethod(..) = function_kind {\n+                self.visited_outermost = false;\n             }\n         }\n     }"}, {"sha": "7453da6374e00bd0c4b458f38f44cdf55a52c1bd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -151,13 +151,10 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n     fn visit_view_item(&mut self, i: &ast::ViewItem) {\n         match i.node {\n             ast::ViewItemUse(ref path) => {\n-                match path.node {\n-                    ast::ViewPathGlob(..) => {\n-                        self.gate_feature(\"globs\", path.span,\n-                                          \"glob import statements are \\\n-                                           experimental and possibly buggy\");\n-                    }\n-                    _ => {}\n+                if let ast::ViewPathGlob(..) = path.node {\n+                    self.gate_feature(\"globs\", path.span,\n+                                      \"glob import statements are \\\n+                                       experimental and possibly buggy\");\n                 }\n             }\n             ast::ViewItemExternCrate(..) => {\n@@ -295,13 +292,10 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n     }\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n-        match t.node {\n-            ast::TyClosure(ref closure) => {\n-                // this used to be blocked by a feature gate, but it should just\n-                // be plain impossible right now\n-                assert!(closure.onceness != ast::Once);\n-            },\n-            _ => {}\n+        if let ast::TyClosure(ref closure) =  t.node {\n+            // this used to be blocked by a feature gate, but it should just\n+            // be plain impossible right now\n+            assert!(closure.onceness != ast::Once);\n         }\n \n         visit::walk_ty(self, t);\n@@ -465,4 +459,3 @@ pub fn check_crate(span_handler: &SpanHandler, krate: &ast::Crate) -> (Features,\n     },\n     unknown_features)\n }\n-"}, {"sha": "fe9c549451743fae5e2ba6393b694c77d0f6df66", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -178,11 +178,8 @@ macro_rules! maybe_whole (\n                 }\n                 _ => None\n             };\n-            match found {\n-                Some(token::Interpolated(token::$constructor(x))) => {\n-                    return x.clone()\n-                }\n-                _ => {}\n+            if let Some(token::Interpolated(token::$constructor(x))) = found {\n+                return x.clone();\n             }\n         }\n     );\n@@ -194,11 +191,8 @@ macro_rules! maybe_whole (\n                 }\n                 _ => None\n             };\n-            match found {\n-                Some(token::Interpolated(token::$constructor(x))) => {\n-                    return x\n-                }\n-                _ => {}\n+            if let Some(token::Interpolated(token::$constructor(x))) = found {\n+                return x;\n             }\n         }\n     );\n@@ -210,11 +204,8 @@ macro_rules! maybe_whole (\n                 }\n                 _ => None\n             };\n-            match found {\n-                Some(token::Interpolated(token::$constructor(x))) => {\n-                    return (*x).clone()\n-                }\n-                _ => {}\n+            if let Some(token::Interpolated(token::$constructor(x))) = found {\n+                return (*x).clone();\n             }\n         }\n     );\n@@ -226,11 +217,8 @@ macro_rules! maybe_whole (\n                 }\n                 _ => None\n             };\n-            match found {\n-                Some(token::Interpolated(token::$constructor(x))) => {\n-                    return Some(x.clone()),\n-                }\n-                _ => {}\n+            if let Some(token::Interpolated(token::$constructor(x))) = found {\n+                return Some(x.clone());\n             }\n         }\n     );\n@@ -242,11 +230,8 @@ macro_rules! maybe_whole (\n                 }\n                 _ => None\n             };\n-            match found {\n-                Some(token::Interpolated(token::$constructor(x))) => {\n-                    return IoviItem(x.clone())\n-                }\n-                _ => {}\n+            if let Some(token::Interpolated(token::$constructor(x))) = found {\n+                return IoviItem(x.clone());\n             }\n         }\n     );\n@@ -258,11 +243,8 @@ macro_rules! maybe_whole (\n                 }\n                 _ => None\n             };\n-            match found {\n-                Some(token::Interpolated(token::$constructor(x))) => {\n-                    return (Vec::new(), x)\n-                }\n-                _ => {}\n+            if let Some(token::Interpolated(token::$constructor(x))) = found {\n+                return (Vec::new(), x);\n             }\n         }\n     )\n@@ -469,15 +451,11 @@ impl<'a> Parser<'a> {\n     /// from anticipated input errors, discarding erroneous characters.\n     pub fn commit_expr(&mut self, e: &Expr, edible: &[token::Token], inedible: &[token::Token]) {\n         debug!(\"commit_expr {}\", e);\n-        match e.node {\n-            ExprPath(..) => {\n-                // might be unit-struct construction; check for recoverableinput error.\n-                let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n-                expected.push_all(inedible);\n-                self.check_for_erroneous_unit_struct_expecting(\n-                    expected.as_slice());\n-            }\n-            _ => {}\n+        if let ExprPath(..) = e.node {\n+            // might be unit-struct construction; check for recoverableinput error.\n+            let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n+            expected.push_all(inedible);\n+            self.check_for_erroneous_unit_struct_expecting(expected.as_slice());\n         }\n         self.expect_one_of(edible, inedible)\n     }\n@@ -1765,11 +1743,8 @@ impl<'a> Parser<'a> {\n             token::Interpolated(token::NtPath(_)) => Some(self.bump_and_get()),\n             _ => None,\n         };\n-        match found {\n-            Some(token::Interpolated(token::NtPath(box path))) => {\n-                return path;\n-            }\n-            _ => {}\n+        if let Some(token::Interpolated(token::NtPath(box path))) = found {\n+            return path;\n         }\n \n         let lo = self.span.lo;"}, {"sha": "e9937dc9b60452b19c1c9b9116d3a959d587e2e6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -969,14 +969,11 @@ impl<'a> State<'a> {\n                                                     \"trait\").as_slice()));\n                 try!(self.print_ident(item.ident));\n                 try!(self.print_generics(generics));\n-                match unbound {\n-                    &Some(ref tref) => {\n-                        try!(space(&mut self.s));\n-                        try!(self.word_space(\"for\"));\n-                        try!(self.print_trait_ref(tref));\n-                        try!(word(&mut self.s, \"?\"));\n-                    }\n-                    _ => {}\n+                if let &Some(ref tref) = unbound {\n+                    try!(space(&mut self.s));\n+                    try!(self.word_space(\"for\"));\n+                    try!(self.print_trait_ref(tref));\n+                    try!(word(&mut self.s, \"?\"));\n                 }\n                 try!(self.print_bounds(\":\", bounds.as_slice()));\n                 try!(self.print_where_clause(generics));\n@@ -1761,16 +1758,14 @@ impl<'a> State<'a> {\n                         try!(space(&mut self.s));\n                     }\n                 }\n-                match start {\n-                    &Some(ref e) => try!(self.print_expr(&**e)),\n-                    _ => {}\n+                if let &Some(ref e) = start {\n+                    try!(self.print_expr(&**e));\n                 }\n                 if start.is_some() || end.is_some() {\n                     try!(word(&mut self.s, \"..\"));\n                 }\n-                match end {\n-                    &Some(ref e) => try!(self.print_expr(&**e)),\n-                    _ => {}\n+                if let &Some(ref e) = end {\n+                    try!(self.print_expr(&**e));\n                 }\n                 try!(word(&mut self.s, \"]\"));\n             }\n@@ -1879,13 +1874,10 @@ impl<'a> State<'a> {\n                 try!(self.ibox(indent_unit));\n                 try!(self.print_local_decl(&**loc));\n                 try!(self.end());\n-                match loc.init {\n-                    Some(ref init) => {\n-                        try!(self.nbsp());\n-                        try!(self.word_space(\"=\"));\n-                        try!(self.print_expr(&**init));\n-                    }\n-                    _ => {}\n+                if let Some(ref init) = loc.init {\n+                    try!(self.nbsp());\n+                    try!(self.word_space(\"=\"));\n+                    try!(self.print_expr(&**init));\n                 }\n                 self.end()\n             }\n@@ -2408,12 +2400,9 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ty_param(&mut self, param: &ast::TyParam) -> IoResult<()> {\n-        match param.unbound {\n-            Some(ref tref) => {\n-                try!(self.print_trait_ref(tref));\n-                try!(self.word_space(\"?\"));\n-            }\n-            _ => {}\n+        if let Some(ref tref) = param.unbound {\n+            try!(self.print_trait_ref(tref));\n+            try!(self.word_space(\"?\"));\n         }\n         try!(self.print_ident(param.ident));\n         try!(self.print_bounds(\":\", param.bounds.as_slice()));"}, {"sha": "18623ca2a81e2078e611b515342793935c8f5515", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=21ba1d5e58144c83093a8cbb467a6c9cb12fc4a1", "patch": "@@ -671,11 +671,8 @@ pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              struct_field: &'v StructField) {\n-    match struct_field.node.kind {\n-        NamedField(name, _) => {\n-            visitor.visit_ident(struct_field.span, name)\n-        }\n-        _ => {}\n+    if let NamedField(name, _) = struct_field.node.kind {\n+        visitor.visit_ident(struct_field.span, name);\n     }\n \n     visitor.visit_ty(&*struct_field.node.ty);"}]}