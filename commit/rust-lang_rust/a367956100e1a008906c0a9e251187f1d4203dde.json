{"sha": "a367956100e1a008906c0a9e251187f1d4203dde", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNjc5NTYxMDBlMWEwMDg5MDZjMGE5ZTI1MTE4N2YxZDQyMDNkZGU=", "commit": {"author": {"name": "Dennis Duda", "email": "git@seri.tools", "date": "2020-05-27T19:58:12Z"}, "committer": {"name": "Dennis Duda", "email": "git@seri.tools", "date": "2020-05-31T15:23:46Z"}, "message": "Make remote-test-client and remote-test-server compatible with windows\n\n`compiletest` and `remote-test-client`:\n\nThe command line for `remote-test-client` was changed slightly\nto allow cross-platform compatible paths. The old way of supplying\nthe support libs was by joining their paths with the executable path\nwith `:`. This caused Windows-style paths to be split after the\ndirectory letter. Now, the number of support libs is provided\nas a parameter as well, and the support lib paths are split off\nfrom the regular args in the client.\n\n`remote-test-server`:\n\n- Marked Unix-only parts as such and implemented Windows alternatives\n- On Windows `LD_LIBRARY_PATH` doesn't exist. Libraries are\n  loaded from `PATH` though, so that's the way around it.\n- Tiny cleanup: `Command::args`/`envs` instead of manually\n  looping over them\n- The temp path for Windows has to be set via environment variable,\n  since there isn't a global temp directory that would work on every\n  machine (as a static string)", "tree": {"sha": "74c98b2a772ec3dad451f70f6915435021cc8a91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74c98b2a772ec3dad451f70f6915435021cc8a91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a367956100e1a008906c0a9e251187f1d4203dde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a367956100e1a008906c0a9e251187f1d4203dde", "html_url": "https://github.com/rust-lang/rust/commit/a367956100e1a008906c0a9e251187f1d4203dde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a367956100e1a008906c0a9e251187f1d4203dde/comments", "author": {"login": "seritools", "id": 5844066, "node_id": "MDQ6VXNlcjU4NDQwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5844066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seritools", "html_url": "https://github.com/seritools", "followers_url": "https://api.github.com/users/seritools/followers", "following_url": "https://api.github.com/users/seritools/following{/other_user}", "gists_url": "https://api.github.com/users/seritools/gists{/gist_id}", "starred_url": "https://api.github.com/users/seritools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seritools/subscriptions", "organizations_url": "https://api.github.com/users/seritools/orgs", "repos_url": "https://api.github.com/users/seritools/repos", "events_url": "https://api.github.com/users/seritools/events{/privacy}", "received_events_url": "https://api.github.com/users/seritools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seritools", "id": 5844066, "node_id": "MDQ6VXNlcjU4NDQwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5844066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seritools", "html_url": "https://github.com/seritools", "followers_url": "https://api.github.com/users/seritools/followers", "following_url": "https://api.github.com/users/seritools/following{/other_user}", "gists_url": "https://api.github.com/users/seritools/gists{/gist_id}", "starred_url": "https://api.github.com/users/seritools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seritools/subscriptions", "organizations_url": "https://api.github.com/users/seritools/orgs", "repos_url": "https://api.github.com/users/seritools/repos", "events_url": "https://api.github.com/users/seritools/events{/privacy}", "received_events_url": "https://api.github.com/users/seritools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b1f86adbe41e8dd4864ca2315f43953dd503bb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b1f86adbe41e8dd4864ca2315f43953dd503bb5", "html_url": "https://github.com/rust-lang/rust/commit/4b1f86adbe41e8dd4864ca2315f43953dd503bb5"}], "stats": {"total": 119, "additions": 83, "deletions": 36}, "files": [{"sha": "a6995eb820a783617a584911880c6ec6a05a9f42", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a367956100e1a008906c0a9e251187f1d4203dde/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a367956100e1a008906c0a9e251187f1d4203dde/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=a367956100e1a008906c0a9e251187f1d4203dde", "patch": "@@ -1584,29 +1584,35 @@ impl<'test> TestCx<'test> {\n             //\n             // into\n             //\n-            //      remote-test-client run program:support-lib.so arg1 arg2\n+            //      remote-test-client run program 2 support-lib.so support-lib2.so arg1 arg2\n             //\n             // The test-client program will upload `program` to the emulator\n             // along with all other support libraries listed (in this case\n-            // `support-lib.so`. It will then execute the program on the\n-            // emulator with the arguments specified (in the environment we give\n-            // the process) and then report back the same result.\n+            // `support-lib.so` and `support-lib2.so`. It will then execute\n+            // the program on the emulator with the arguments specified\n+            // (in the environment we give the process) and then report back\n+            // the same result.\n             _ if self.config.remote_test_client.is_some() => {\n                 let aux_dir = self.aux_output_dir_name();\n-                let ProcArgs { mut prog, args } = self.make_run_args();\n+                let ProcArgs { prog, args } = self.make_run_args();\n+                let mut support_libs = Vec::new();\n                 if let Ok(entries) = aux_dir.read_dir() {\n                     for entry in entries {\n                         let entry = entry.unwrap();\n                         if !entry.path().is_file() {\n                             continue;\n                         }\n-                        prog.push_str(\":\");\n-                        prog.push_str(entry.path().to_str().unwrap());\n+                        support_libs.push(entry.path());\n                     }\n                 }\n                 let mut test_client =\n                     Command::new(self.config.remote_test_client.as_ref().unwrap());\n-                test_client.args(&[\"run\", &prog]).args(args).envs(env.clone());\n+                test_client\n+                    .args(&[\"run\", &prog])\n+                    .arg(support_libs.len().to_string())\n+                    .args(support_libs)\n+                    .args(args)\n+                    .envs(env.clone());\n                 self.compose_and_run(\n                     test_client,\n                     self.config.run_lib_path.to_str().unwrap(),"}, {"sha": "dea8bb933c9d9c15fd7810a0394a62e464f6e9e3", "filename": "src/tools/remote-test-client/src/main.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a367956100e1a008906c0a9e251187f1d4203dde/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a367956100e1a008906c0a9e251187f1d4203dde/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs?ref=a367956100e1a008906c0a9e251187f1d4203dde", "patch": "@@ -44,7 +44,11 @@ fn main() {\n             args.next().map(|s| s.into()),\n         ),\n         \"push\" => push(Path::new(&args.next().unwrap())),\n-        \"run\" => run(args.next().unwrap(), args.collect()),\n+        \"run\" => run(\n+            args.next().unwrap(),\n+            args.next().and_then(|count| count.parse().ok()).unwrap(),\n+            args.collect(),\n+        ),\n         \"help\" | \"-h\" | \"--help\" => help(),\n         cmd => {\n             println!(\"unknown command: {}\", cmd);\n@@ -197,12 +201,14 @@ fn push(path: &Path) {\n     println!(\"done pushing {:?}\", path);\n }\n \n-fn run(files: String, args: Vec<String>) {\n+fn run(exe: String, support_lib_count: usize, all_args: Vec<String>) {\n     let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(DEFAULT_ADDR.to_string());\n     let client = t!(TcpStream::connect(device_address));\n     let mut client = BufWriter::new(client);\n     t!(client.write_all(b\"run \"));\n \n+    let (support_libs, args) = all_args.split_at(support_lib_count);\n+\n     // Send over the args\n     for arg in args {\n         t!(client.write_all(arg.as_bytes()));\n@@ -227,9 +233,7 @@ fn run(files: String, args: Vec<String>) {\n     t!(client.write_all(&[0]));\n \n     // Send over support libraries\n-    let mut files = files.split(':');\n-    let exe = files.next().unwrap();\n-    for file in files.map(Path::new) {\n+    for file in support_libs.iter().map(Path::new) {\n         send(&file, &mut client);\n     }\n     t!(client.write_all(&[0]));"}, {"sha": "d9f65cf502da6019d342d6837a2045c8234a756c", "filename": "src/tools/remote-test-server/src/main.rs", "status": "modified", "additions": 60, "deletions": 23, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a367956100e1a008906c0a9e251187f1d4203dde/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a367956100e1a008906c0a9e251187f1d4203dde/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs?ref=a367956100e1a008906c0a9e251187f1d4203dde", "patch": "@@ -12,15 +12,19 @@\n \n #![deny(warnings)]\n \n+#[cfg(not(windows))]\n+use std::fs::Permissions;\n+#[cfg(not(windows))]\n+use std::os::unix::prelude::*;\n+\n use std::cmp;\n use std::env;\n-use std::fs::{self, File, Permissions};\n+use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::net::{TcpListener, TcpStream};\n-use std::os::unix::prelude::*;\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Stdio};\n+use std::process::{Command, ExitStatus, Stdio};\n use std::str;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::{Arc, Mutex};\n@@ -72,21 +76,23 @@ fn main() {\n \n     let config = Config::parse_args();\n \n-    let bind_addr = if cfg!(target_os = \"android\") || config.remote {\n+    let bind_addr = if cfg!(target_os = \"android\") || cfg!(windows) || config.remote {\n         \"0.0.0.0:12345\"\n     } else {\n         \"10.0.2.15:12345\"\n     };\n \n-    let (listener, work) = if cfg!(target_os = \"android\") {\n-        (t!(TcpListener::bind(bind_addr)), \"/data/tmp/work\")\n+    let listener = t!(TcpListener::bind(bind_addr));\n+    let work: PathBuf = if cfg!(windows) {\n+        env::var_os(\"RUST_TEMP\").expect(\"Set RUST_TEMP to your preferred temp folder\").into()\n+    } else if cfg!(target_os = \"android\") {\n+        \"/data/tmp/work\".into()\n     } else {\n-        (t!(TcpListener::bind(bind_addr)), \"/tmp/work\")\n+        \"/tmp/work\".into()\n     };\n     println!(\"listening!\");\n \n-    let work = Path::new(work);\n-    t!(fs::create_dir_all(work));\n+    t!(fs::create_dir_all(&work));\n \n     let lock = Arc::new(Mutex::new(()));\n \n@@ -99,10 +105,11 @@ fn main() {\n         if &buf[..] == b\"ping\" {\n             t!(socket.write_all(b\"pong\"));\n         } else if &buf[..] == b\"push\" {\n-            handle_push(socket, work);\n+            handle_push(socket, &work);\n         } else if &buf[..] == b\"run \" {\n             let lock = lock.clone();\n-            thread::spawn(move || handle_run(socket, work, &lock));\n+            let work = work.clone();\n+            thread::spawn(move || handle_run(socket, &work, &lock));\n         } else {\n             panic!(\"unknown command {:?}\", buf);\n         }\n@@ -196,17 +203,28 @@ fn handle_run(socket: TcpStream, work: &Path, lock: &Mutex<()>) {\n     let exe = recv(&path, &mut reader);\n \n     let mut cmd = Command::new(&exe);\n-    for arg in args {\n-        cmd.arg(arg);\n-    }\n-    for (k, v) in env {\n-        cmd.env(k, v);\n-    }\n+    cmd.args(args);\n+    cmd.envs(env);\n \n     // Support libraries were uploaded to `work` earlier, so make sure that's\n     // in `LD_LIBRARY_PATH`. Also include our own current dir which may have\n     // had some libs uploaded.\n-    cmd.env(\"LD_LIBRARY_PATH\", format!(\"{}:{}\", work.display(), path.display()));\n+    if cfg!(windows) {\n+        // On windows, libraries are just searched in the executable directory,\n+        // system directories, PWD, and PATH, in that order. PATH is the only one\n+        // we can change for this.\n+        cmd.env(\n+            \"PATH\",\n+            env::join_paths(\n+                std::iter::once(work.to_owned())\n+                    .chain(std::iter::once(path.clone()))\n+                    .chain(env::split_paths(&env::var_os(\"PATH\").unwrap())),\n+            )\n+            .unwrap(),\n+        );\n+    } else {\n+        cmd.env(\"LD_LIBRARY_PATH\", format!(\"{}:{}\", work.display(), path.display()));\n+    }\n \n     // Spawn the child and ferry over stdout/stderr to the socket in a framed\n     // fashion (poor man's style)\n@@ -223,10 +241,9 @@ fn handle_run(socket: TcpStream, work: &Path, lock: &Mutex<()>) {\n \n     // Finally send over the exit status.\n     let status = t!(child.wait());\n-    let (which, code) = match status.code() {\n-        Some(n) => (0, n),\n-        None => (1, status.signal().unwrap()),\n-    };\n+\n+    let (which, code) = get_status_code(&status);\n+\n     t!(socket.lock().unwrap().write_all(&[\n         which,\n         (code >> 24) as u8,\n@@ -236,6 +253,19 @@ fn handle_run(socket: TcpStream, work: &Path, lock: &Mutex<()>) {\n     ]));\n }\n \n+#[cfg(not(windows))]\n+fn get_status_code(status: &ExitStatus) -> (u8, i32) {\n+    match status.code() {\n+        Some(n) => (0, n),\n+        None => (1, status.signal().unwrap()),\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn get_status_code(status: &ExitStatus) -> (u8, i32) {\n+    (0, status.code().unwrap())\n+}\n+\n fn recv<B: BufRead>(dir: &Path, io: &mut B) -> PathBuf {\n     let mut filename = Vec::new();\n     t!(io.read_until(0, &mut filename));\n@@ -253,10 +283,17 @@ fn recv<B: BufRead>(dir: &Path, io: &mut B) -> PathBuf {\n     let dst = dir.join(t!(str::from_utf8(&filename[..len])));\n     let amt = read_u32(io) as u64;\n     t!(io::copy(&mut io.take(amt), &mut t!(File::create(&dst))));\n-    t!(fs::set_permissions(&dst, Permissions::from_mode(0o755)));\n+    set_permissions(&dst);\n     dst\n }\n \n+#[cfg(not(windows))]\n+fn set_permissions(path: &Path) {\n+    t!(fs::set_permissions(&dst, Permissions::from_mode(0o755)));\n+}\n+#[cfg(windows)]\n+fn set_permissions(_path: &Path) {}\n+\n fn my_copy(src: &mut dyn Read, which: u8, dst: &Mutex<dyn Write>) {\n     let mut b = [0; 1024];\n     loop {"}]}