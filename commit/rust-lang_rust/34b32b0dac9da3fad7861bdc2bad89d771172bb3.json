{"sha": "34b32b0dac9da3fad7861bdc2bad89d771172bb3", "node_id": "C_kwDOAAsO6NoAKDM0YjMyYjBkYWM5ZGEzZmFkNzg2MWJkYzJiYWQ4OWQ3NzExNzJiYjM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-03T02:35:49Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-03T04:58:19Z"}, "message": "Use `Mode` less.\n\nIt's passed to numerous places where we just need an `is_byte` bool.\nPassing the bool avoids the need for some assertions.\n\nAlso rename `is_bytes()` as `is_byte()`, to better match `Mode::Byte`,\n`Mode::ByteStr`, and `Mode::RawByteStr`.", "tree": {"sha": "a7917a88980232aac0e700871ad326269b215c96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7917a88980232aac0e700871ad326269b215c96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34b32b0dac9da3fad7861bdc2bad89d771172bb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34b32b0dac9da3fad7861bdc2bad89d771172bb3", "html_url": "https://github.com/rust-lang/rust/commit/34b32b0dac9da3fad7861bdc2bad89d771172bb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34b32b0dac9da3fad7861bdc2bad89d771172bb3/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84ca2c3bab370ee58ebd23050e9286e1d9e664b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/84ca2c3bab370ee58ebd23050e9286e1d9e664b9", "html_url": "https://github.com/rust-lang/rust/commit/84ca2c3bab370ee58ebd23050e9286e1d9e664b9"}], "stats": {"total": 60, "additions": 29, "deletions": 31}, "files": [{"sha": "f0042a397c2c5480de0e04512b0b22d1990a4810", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/34b32b0dac9da3fad7861bdc2bad89d771172bb3/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b32b0dac9da3fad7861bdc2bad89d771172bb3/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=34b32b0dac9da3fad7861bdc2bad89d771172bb3", "patch": "@@ -85,14 +85,16 @@ where\n     match mode {\n         Mode::Char | Mode::Byte => {\n             let mut chars = src.chars();\n-            let result = unescape_char_or_byte(&mut chars, mode);\n+            let result = unescape_char_or_byte(&mut chars, mode == Mode::Byte);\n             // The Chars iterator moved forward.\n             callback(0..(src.len() - chars.as_str().len()), result);\n         }\n-        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(src, mode, callback),\n+        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(src, mode == Mode::ByteStr, callback),\n         // NOTE: Raw strings do not perform any explicit character escaping, here we\n         // only translate CRLF to LF and produce errors on bare CR.\n-        Mode::RawStr | Mode::RawByteStr => unescape_raw_str_or_raw_byte_str(src, mode, callback),\n+        Mode::RawStr | Mode::RawByteStr => {\n+            unescape_raw_str_or_raw_byte_str(src, mode == Mode::RawByteStr, callback)\n+        }\n     }\n }\n \n@@ -103,7 +105,7 @@ pub fn unescape_byte_literal<F>(src: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<u8, EscapeError>),\n {\n-    debug_assert!(mode.is_bytes());\n+    debug_assert!(mode.is_byte());\n     unescape_literal(src, mode, &mut |range, result| {\n         callback(range, result.map(byte_from_char));\n     })\n@@ -113,15 +115,14 @@ where\n /// unescaped char or an error\n pub fn unescape_char(src: &str) -> Result<char, (usize, EscapeError)> {\n     let mut chars = src.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Char)\n-        .map_err(|err| (src.len() - chars.as_str().len(), err))\n+    unescape_char_or_byte(&mut chars, false).map_err(|err| (src.len() - chars.as_str().len(), err))\n }\n \n /// Takes a contents of a byte literal (without quotes), and returns an\n /// unescaped byte or an error.\n pub fn unescape_byte(src: &str) -> Result<u8, (usize, EscapeError)> {\n     let mut chars = src.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Byte)\n+    unescape_char_or_byte(&mut chars, true)\n         .map(byte_from_char)\n         .map_err(|err| (src.len() - chars.as_str().len(), err))\n }\n@@ -145,15 +146,15 @@ impl Mode {\n         }\n     }\n \n-    pub fn is_bytes(self) -> bool {\n+    pub fn is_byte(self) -> bool {\n         match self {\n             Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n             Mode::Char | Mode::Str | Mode::RawStr => false,\n         }\n     }\n }\n \n-fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n     // Previous character was '\\\\', unescape what follows.\n     let res = match chars.next().ok_or(EscapeError::LoneSlash)? {\n         '\"' => '\"',\n@@ -176,7 +177,7 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n             let value = hi * 16 + lo;\n \n             // For a non-byte literal verify that it is within ASCII range.\n-            if !mode.is_bytes() && !is_ascii(value) {\n+            if !is_byte && !is_ascii(value) {\n                 return Err(EscapeError::OutOfRangeHexEscape);\n             }\n             let value = value as u8;\n@@ -212,7 +213,7 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n \n                         // Incorrect syntax has higher priority for error reporting\n                         // than unallowed value for a literal.\n-                        if mode.is_bytes() {\n+                        if is_byte {\n                             return Err(EscapeError::UnicodeEscapeInByte);\n                         }\n \n@@ -244,23 +245,22 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n }\n \n #[inline]\n-fn ascii_check(c: char, mode: Mode) -> Result<char, EscapeError> {\n-    if mode.is_bytes() && !c.is_ascii() {\n+fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n+    if is_byte && !c.is_ascii() {\n         // Byte literal can't be a non-ascii character.\n         Err(EscapeError::NonAsciiCharInByte)\n     } else {\n         Ok(c)\n     }\n }\n \n-fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n-    debug_assert!(mode == Mode::Char || mode == Mode::Byte);\n+fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n     let c = chars.next().ok_or(EscapeError::ZeroChars)?;\n     let res = match c {\n-        '\\\\' => scan_escape(chars, mode),\n+        '\\\\' => scan_escape(chars, is_byte),\n         '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n         '\\r' => Err(EscapeError::BareCarriageReturn),\n-        _ => ascii_check(c, mode),\n+        _ => ascii_check(c, is_byte),\n     }?;\n     if chars.next().is_some() {\n         return Err(EscapeError::MoreThanOneChar);\n@@ -270,11 +270,10 @@ fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, Esca\n \n /// Takes a contents of a string literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n-fn unescape_str_or_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n+fn unescape_str_or_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    debug_assert!(mode == Mode::Str || mode == Mode::ByteStr);\n     let mut chars = src.chars();\n \n     // The `start` and `end` computation here is complicated because\n@@ -293,14 +292,14 @@ where\n                         skip_ascii_whitespace(&mut chars, start, callback);\n                         continue;\n                     }\n-                    _ => scan_escape(&mut chars, mode),\n+                    _ => scan_escape(&mut chars, is_byte),\n                 }\n             }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n             '\"' => Err(EscapeError::EscapeOnlyChar),\n             '\\r' => Err(EscapeError::BareCarriageReturn),\n-            _ => ascii_check(c, mode),\n+            _ => ascii_check(c, is_byte),\n         };\n         let end = src.len() - chars.as_str().len();\n         callback(start..end, result);\n@@ -337,11 +336,10 @@ where\n /// sequence of characters or errors.\n /// NOTE: Raw strings do not perform any explicit character escaping, here we\n /// only translate CRLF to LF and produce errors on bare CR.\n-fn unescape_raw_str_or_raw_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n+fn unescape_raw_str_or_raw_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    debug_assert!(mode == Mode::RawStr || mode == Mode::RawByteStr);\n     let mut chars = src.chars();\n \n     // The `start` and `end` computation here matches the one in\n@@ -351,7 +349,7 @@ where\n         let start = src.len() - chars.as_str().len() - c.len_utf8();\n         let result = match c {\n             '\\r' => Err(EscapeError::BareCarriageReturnInRawString),\n-            c if mode.is_bytes() && !c.is_ascii() => Err(EscapeError::NonAsciiCharInByteString),\n+            c if is_byte && !c.is_ascii() => Err(EscapeError::NonAsciiCharInByteString),\n             c => Ok(c),\n         };\n         let end = src.len() - chars.as_str().len();"}, {"sha": "055ee98a00aa3c1c7786fc8665d5b4ed3bc60837", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34b32b0dac9da3fad7861bdc2bad89d771172bb3/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b32b0dac9da3fad7861bdc2bad89d771172bb3/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=34b32b0dac9da3fad7861bdc2bad89d771172bb3", "patch": "@@ -108,7 +108,7 @@ pub(crate) fn emit_unescape_error(\n             }\n \n             if !has_help {\n-                let (prefix, msg) = if mode.is_bytes() {\n+                let (prefix, msg) = if mode.is_byte() {\n                     (\"b\", \"if you meant to write a byte string literal, use double quotes\")\n                 } else {\n                     (\"\", \"if you meant to write a `str` literal, use double quotes\")\n@@ -142,7 +142,7 @@ pub(crate) fn emit_unescape_error(\n         EscapeError::EscapeOnlyChar => {\n             let (c, char_span) = last_char();\n \n-            let msg = if mode.is_bytes() {\n+            let msg = if mode.is_byte() {\n                 \"byte constant must be escaped\"\n             } else {\n                 \"character constant must be escaped\"\n@@ -182,11 +182,11 @@ pub(crate) fn emit_unescape_error(\n             let (c, span) = last_char();\n \n             let label =\n-                if mode.is_bytes() { \"unknown byte escape\" } else { \"unknown character escape\" };\n+                if mode.is_byte() { \"unknown byte escape\" } else { \"unknown character escape\" };\n             let ec = escaped_char(c);\n             let mut diag = handler.struct_span_err(span, &format!(\"{}: `{}`\", label, ec));\n             diag.span_label(span, label);\n-            if c == '{' || c == '}' && !mode.is_bytes() {\n+            if c == '{' || c == '}' && !mode.is_byte() {\n                 diag.help(\n                     \"if used in a formatting string, curly braces are escaped with `{{` and `}}`\",\n                 );\n@@ -196,7 +196,7 @@ pub(crate) fn emit_unescape_error(\n                      version control settings\",\n                 );\n             } else {\n-                if !mode.is_bytes() {\n+                if !mode.is_byte() {\n                     diag.span_suggestion(\n                         span_with_quotes,\n                         \"if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\",\n@@ -231,7 +231,7 @@ pub(crate) fn emit_unescape_error(\n                 .emit();\n         }\n         EscapeError::NonAsciiCharInByte => {\n-            assert!(mode.is_bytes());\n+            assert!(mode.is_byte());\n             let (c, span) = last_char();\n             let mut err = handler.struct_span_err(span, \"non-ASCII character in byte constant\");\n             let postfix = if unicode_width::UnicodeWidthChar::width(c).unwrap_or(1) == 0 {\n@@ -271,7 +271,7 @@ pub(crate) fn emit_unescape_error(\n             err.emit();\n         }\n         EscapeError::NonAsciiCharInByteString => {\n-            assert!(mode.is_bytes());\n+            assert!(mode.is_byte());\n             let (c, span) = last_char();\n             let postfix = if unicode_width::UnicodeWidthChar::width(c).unwrap_or(1) == 0 {\n                 format!(\" but is {:?}\", c)"}]}