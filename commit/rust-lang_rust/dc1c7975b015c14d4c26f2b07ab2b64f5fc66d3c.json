{"sha": "dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMWM3OTc1YjAxNWMxNGQ0YzI2ZjJiMDdhYjJiNjRmNWZjNjZkM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-18T16:57:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-18T16:57:21Z"}, "message": "Auto merge of #28336 - petrochenkov:empstr, r=pnkfelix\n\nCloses https://github.com/rust-lang/rust/issues/24266\r\nCloses https://github.com/rust-lang/rust/issues/16819", "tree": {"sha": "90c8b72b7eecdde1c1f23df051fa712e196d7291", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90c8b72b7eecdde1c1f23df051fa712e196d7291"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "html_url": "https://github.com/rust-lang/rust/commit/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53ba768b8a88a72cb96e8ff9b76ec36797ba2acd", "url": "https://api.github.com/repos/rust-lang/rust/commits/53ba768b8a88a72cb96e8ff9b76ec36797ba2acd", "html_url": "https://github.com/rust-lang/rust/commit/53ba768b8a88a72cb96e8ff9b76ec36797ba2acd"}, {"sha": "1eb42f1c784e999259b15f68c63040e1fafbe273", "url": "https://api.github.com/repos/rust-lang/rust/commits/1eb42f1c784e999259b15f68c63040e1fafbe273", "html_url": "https://github.com/rust-lang/rust/commit/1eb42f1c784e999259b15f68c63040e1fafbe273"}], "stats": {"total": 311, "additions": 187, "deletions": 124}, "files": [{"sha": "83849574260e1ff93034292314a991f962be5935", "filename": "src/doc/reference.md", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -1178,11 +1178,22 @@ let px: i32 = match p { Point(x, _) => x };\n ```\n \n A _unit-like struct_ is a structure without any fields, defined by leaving off\n-the list of fields entirely. Such types will have a single value. For example:\n+the list of fields entirely. Such a structure implicitly defines a constant of\n+its type with the same name. For example:\n \n ```\n+# #![feature(braced_empty_structs)]\n struct Cookie;\n-let c = [Cookie, Cookie, Cookie, Cookie];\n+let c = [Cookie, Cookie {}, Cookie, Cookie {}];\n+```\n+\n+is equivalent to\n+\n+```\n+# #![feature(braced_empty_structs)]\n+struct Cookie {}\n+const Cookie: Cookie = Cookie {};\n+let c = [Cookie, Cookie {}, Cookie, Cookie {}];\n ```\n \n The precise memory layout of a structure is not specified. One can specify a\n@@ -2411,6 +2422,7 @@ The currently implemented features of the reference compiler are:\n                               terms of encapsulation).\n * - `default_type_parameter_fallback` - Allows type parameter defaults to\n                                         influence type inference.\n+* - `braced_empty_structs` - Allows use of empty structs with braces.\n \n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled"}, {"sha": "940145aa4173b26c6812314163508fc7254fadfe", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -1218,34 +1218,34 @@ impl<'a> State<'a> {\n                          fields: &[hir::Field],\n                          wth: &Option<P<hir::Expr>>) -> io::Result<()> {\n         try!(self.print_path(path, true, 0));\n-        if !(fields.is_empty() && wth.is_none()) {\n-            try!(word(&mut self.s, \"{\"));\n-            try!(self.commasep_cmnt(\n-                Consistent,\n-                &fields[..],\n-                |s, field| {\n-                    try!(s.ibox(indent_unit));\n-                    try!(s.print_ident(field.ident.node));\n-                    try!(s.word_space(\":\"));\n-                    try!(s.print_expr(&*field.expr));\n-                    s.end()\n-                },\n-                |f| f.span));\n-            match *wth {\n-                Some(ref expr) => {\n-                    try!(self.ibox(indent_unit));\n-                    if !fields.is_empty() {\n-                        try!(word(&mut self.s, \",\"));\n-                        try!(space(&mut self.s));\n-                    }\n-                    try!(word(&mut self.s, \"..\"));\n-                    try!(self.print_expr(&**expr));\n-                    try!(self.end());\n+        try!(word(&mut self.s, \"{\"));\n+        try!(self.commasep_cmnt(\n+            Consistent,\n+            &fields[..],\n+            |s, field| {\n+                try!(s.ibox(indent_unit));\n+                try!(s.print_ident(field.ident.node));\n+                try!(s.word_space(\":\"));\n+                try!(s.print_expr(&*field.expr));\n+                s.end()\n+            },\n+            |f| f.span));\n+        match *wth {\n+            Some(ref expr) => {\n+                try!(self.ibox(indent_unit));\n+                if !fields.is_empty() {\n+                    try!(word(&mut self.s, \",\"));\n+                    try!(space(&mut self.s));\n                 }\n-                _ => try!(word(&mut self.s, \",\")),\n+                try!(word(&mut self.s, \"..\"));\n+                try!(self.print_expr(&**expr));\n+                try!(self.end());\n+            }\n+            _ => if !fields.is_empty() {\n+                try!(word(&mut self.s, \",\"))\n             }\n-            try!(word(&mut self.s, \"}\"));\n         }\n+        try!(word(&mut self.s, \"}\"));\n         Ok(())\n     }\n "}, {"sha": "6f1e2e283e7a2a95ee74b2ba2c2b3695129ccb7d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -1473,14 +1473,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return None\n         };\n \n-        if let ty::VariantKind::Dict = variant.kind() {\n+        let var_kind = variant.kind();\n+        if var_kind == ty::VariantKind::Dict || var_kind == ty::VariantKind::Unit {\n             Some((adt, variant))\n         } else {\n             None\n         }\n     }\n \n-\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx().mk_nil());\n     }"}, {"sha": "989977a691755b7cc8b7711b4af871b5ba9396dd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -191,6 +191,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n \n     // allow `#[unwind]`\n     (\"unwind_attributes\", \"1.4.0\", None, Active),\n+\n+    // allow empty structs/enum variants with braces\n+    (\"braced_empty_structs\", \"1.5.0\", None, Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -775,7 +778,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemStruct(..) => {\n+            ast::ItemStruct(ref def, _) => {\n                 if attr::contains_name(&i.attrs[..], \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n@@ -794,6 +797,10 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                         }\n                     }\n                 }\n+                if def.fields.is_empty() && def.ctor_id.is_none() {\n+                    self.gate_feature(\"braced_empty_structs\", i.span,\n+                                      \"empty structs with braces are unstable\");\n+                }\n             }\n \n             ast::ItemDefaultImpl(..) => {\n@@ -843,6 +850,12 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                   \"box expression syntax is experimental; \\\n                                    you can call `Box::new` instead.\");\n             }\n+            ast::ExprStruct(_, ref fields, ref expr) => {\n+                if fields.is_empty() && expr.is_none() {\n+                    self.gate_feature(\"braced_empty_structs\", e.span,\n+                                      \"empty structs with braces are unstable\");\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);\n@@ -867,6 +880,12 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                   pattern.span,\n                                   \"box pattern syntax is experimental\");\n             }\n+            ast::PatStruct(_, ref fields, dotdot) => {\n+                if fields.is_empty() && !dotdot {\n+                    self.gate_feature(\"braced_empty_structs\", pattern.span,\n+                                      \"empty structs with braces are unstable\");\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_pat(self, pattern)"}, {"sha": "a7978babcb7e1c000d7b96a21a1e22bc2274c417", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -2231,14 +2231,6 @@ impl<'a> Parser<'a> {\n                                                  &[token::CloseDelim(token::Brace)]));\n                             }\n \n-                            if fields.is_empty() && base.is_none() {\n-                                let last_span = self.last_span;\n-                                self.span_err(last_span,\n-                                              \"structure literal must either \\\n-                                              have at least one field or use \\\n-                                              structure update syntax\");\n-                            }\n-\n                             hi = self.span.hi;\n                             try!(self.expect(&token::CloseDelim(token::Brace)));\n                             ex = ExprStruct(pth, fields, base);\n@@ -4713,14 +4705,14 @@ impl<'a> Parser<'a> {\n                 (Vec::new(), Some(ast::DUMMY_NODE_ID))\n             } else {\n                 // If we see: `struct Foo<T> where T: Copy { ... }`\n-                (try!(self.parse_record_struct_body(&class_name)), None)\n+                (try!(self.parse_record_struct_body()), None)\n             }\n         // No `where` so: `struct Foo<T>;`\n         } else if try!(self.eat(&token::Semi) ){\n             (Vec::new(), Some(ast::DUMMY_NODE_ID))\n         // Record-style struct definition\n         } else if self.token == token::OpenDelim(token::Brace) {\n-            let fields = try!(self.parse_record_struct_body(&class_name));\n+            let fields = try!(self.parse_record_struct_body());\n             (fields, None)\n         // Tuple-style struct definition with optional where-clause.\n         } else if self.token == token::OpenDelim(token::Paren) {\n@@ -4740,20 +4732,13 @@ impl<'a> Parser<'a> {\n          None))\n     }\n \n-    pub fn parse_record_struct_body(&mut self,\n-                                    class_name: &ast::Ident) -> PResult<Vec<StructField>> {\n+    pub fn parse_record_struct_body(&mut self) -> PResult<Vec<StructField>> {\n         let mut fields = Vec::new();\n         if try!(self.eat(&token::OpenDelim(token::Brace)) ){\n             while self.token != token::CloseDelim(token::Brace) {\n                 fields.push(try!(self.parse_struct_decl_field(true)));\n             }\n \n-            if fields.is_empty() {\n-                return Err(self.fatal(&format!(\"unit-like struct definition should be \\\n-                    written as `struct {};`\",\n-                    class_name)));\n-            }\n-\n             try!(self.bump());\n         } else {\n             let token_str = self.this_token_to_string();"}, {"sha": "1d22c83122e51a2b0dfcf297c806bb4b140e76f4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -1855,34 +1855,34 @@ impl<'a> State<'a> {\n                          fields: &[ast::Field],\n                          wth: &Option<P<ast::Expr>>) -> io::Result<()> {\n         try!(self.print_path(path, true, 0));\n-        if !(fields.is_empty() && wth.is_none()) {\n-            try!(word(&mut self.s, \"{\"));\n-            try!(self.commasep_cmnt(\n-                Consistent,\n-                &fields[..],\n-                |s, field| {\n-                    try!(s.ibox(indent_unit));\n-                    try!(s.print_ident(field.ident.node));\n-                    try!(s.word_space(\":\"));\n-                    try!(s.print_expr(&*field.expr));\n-                    s.end()\n-                },\n-                |f| f.span));\n-            match *wth {\n-                Some(ref expr) => {\n-                    try!(self.ibox(indent_unit));\n-                    if !fields.is_empty() {\n-                        try!(word(&mut self.s, \",\"));\n-                        try!(space(&mut self.s));\n-                    }\n-                    try!(word(&mut self.s, \"..\"));\n-                    try!(self.print_expr(&**expr));\n-                    try!(self.end());\n+        try!(word(&mut self.s, \"{\"));\n+        try!(self.commasep_cmnt(\n+            Consistent,\n+            &fields[..],\n+            |s, field| {\n+                try!(s.ibox(indent_unit));\n+                try!(s.print_ident(field.ident.node));\n+                try!(s.word_space(\":\"));\n+                try!(s.print_expr(&*field.expr));\n+                s.end()\n+            },\n+            |f| f.span));\n+        match *wth {\n+            Some(ref expr) => {\n+                try!(self.ibox(indent_unit));\n+                if !fields.is_empty() {\n+                    try!(word(&mut self.s, \",\"));\n+                    try!(space(&mut self.s));\n                 }\n-                _ => try!(word(&mut self.s, \",\")),\n+                try!(word(&mut self.s, \"..\"));\n+                try!(self.print_expr(&**expr));\n+                try!(self.end());\n+            }\n+            _ => if !fields.is_empty() {\n+                try!(word(&mut self.s, \",\"))\n             }\n-            try!(word(&mut self.s, \"}\"));\n         }\n+        try!(word(&mut self.s, \"}\"));\n         Ok(())\n     }\n "}, {"sha": "ad412259faa29722b65985795698e908dd2dc4ae", "filename": "src/test/compile-fail/empty-struct-with-braces-1.rs", "status": "renamed", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-1.rs?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// Empty struct defined with braces shouldn't add names into value namespace\n \n-struct Foo;\n+#![feature(braced_empty_structs)]\n \n-fn f2() {\n-    let _end_stmt     = Foo { };\n-    //~^ ERROR: structure literal must either have at least one field\n-}\n+struct Empty {}\n \n-fn main() {}\n+fn main() {\n+    let e = Empty; //~ ERROR `Empty` is the name of a struct or struct variant\n+}", "previous_filename": "src/test/parse-fail/struct-no-fields-2.rs"}, {"sha": "0e72e7dc44185349cbac763f7133e7184d15e8bb", "filename": "src/test/compile-fail/empty-struct-with-braces-2.rs", "status": "renamed", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-2.rs?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// Empty struct defined with braces shouldn't add names into value namespace\n \n-struct Foo;\n+#![feature(braced_empty_structs)]\n+#![deny(warnings)]\n \n-fn h4() {\n-    let _end_of_tuple = (3, Foo { });\n-    //~^ ERROR: structure literal must either have at least one field\n-}\n+struct Empty {}\n+\n+fn main() {\n+    let e = Empty {};\n \n-fn main() {}\n+    match e {\n+        Empty => () //~ ERROR unused variable: `Empty`\n+        //~^ ERROR variable `Empty` should have a snake case name such as `empty`\n+    }\n+}", "previous_filename": "src/test/parse-fail/struct-no-fields-4.rs"}, {"sha": "e6f20ba345ad35fec6697bd6a06ea2f5504a2d4c", "filename": "src/test/compile-fail/empty-struct-with-braces-3.rs", "status": "renamed", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-with-braces-3.rs?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// Feature gate test for empty struct with braces\n \n-struct Foo;\n+struct Empty {} //~ ERROR empty structs with braces are unstable\n \n-fn g3() {\n-    let _mid_tuple    = (Foo { }, 2);\n-    //~^ ERROR: structure literal must either have at least one field\n-}\n+fn main() {\n+    let e = Empty {}; //~ ERROR empty structs with braces are unstable\n \n-fn main() {}\n+    match e {\n+        Empty {} => {} //~ ERROR empty structs with braces are unstable\n+    }\n+}", "previous_filename": "src/test/parse-fail/struct-no-fields-3.rs"}, {"sha": "533387c576008c5d3e0f73e77cfd44b0ada09f11", "filename": "src/test/compile-fail/issue-27831.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -22,8 +22,8 @@ fn main() {\n     let Foo { .. } = x; //~ ERROR `Foo` does not name a struct\n \n     let x = Bar;\n-    Bar { ..x }; //~ ERROR `Bar` does not name a structure\n-    let Bar { .. } = x; //~ ERROR `Bar` does not name a struct\n+    Bar { ..x };\n+    let Bar { .. } = x;\n \n     match Enum::Bar {\n         Enum::Bar { .. } //~ ERROR `Enum::Bar` does not name a struct"}, {"sha": "5f92d98606693215bee452db483f88af5899c362", "filename": "src/test/parse-fail/struct-no-fields-5.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/53ba768b8a88a72cb96e8ff9b76ec36797ba2acd/src%2Ftest%2Fparse-fail%2Fstruct-no-fields-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ba768b8a88a72cb96e8ff9b76ec36797ba2acd/src%2Ftest%2Fparse-fail%2Fstruct-no-fields-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-no-fields-5.rs?ref=53ba768b8a88a72cb96e8ff9b76ec36797ba2acd", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-struct Foo;\n-\n-fn i5() {\n-    let _end_of_block = { Foo { } };\n-    //~^ ERROR: structure literal must either have at least one field\n-}\n-\n-fn main() {}"}, {"sha": "dc806acb980ddc7186aea13e80ab750cfbd5bb40", "filename": "src/test/run-pass/empty-struct-with-braces.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Frun-pass%2Fempty-struct-with-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Frun-pass%2Fempty-struct-with-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-struct-with-braces.rs?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Empty struct defined with braces add names into type namespace\n+// Empty struct defined without braces add names into both type and value namespaces\n+\n+#![feature(braced_empty_structs)]\n+\n+struct Empty1 {}\n+struct Empty2;\n+struct Empty3 {}\n+const Empty3: Empty3 = Empty3 {};\n+\n+fn main() {\n+    let e1: Empty1 = Empty1 {};\n+    let e2: Empty2 = Empty2 {};\n+    let e2: Empty2 = Empty2;\n+    let e3: Empty3 = Empty3 {};\n+    let e3: Empty3 = Empty3;\n+\n+    match e1 {\n+        Empty1 {} => ()\n+    }\n+    match e2 {\n+        Empty2 {} => ()\n+    }\n+    match e2 {\n+        Empty2 => ()\n+    }\n+    match e3 {\n+        Empty3 {} => ()\n+    }\n+    match e3 {\n+        Empty3 => ()\n+    }\n+    match e1 {\n+        Empty1 { .. } => ()\n+    }\n+    match e2 {\n+        Empty2 { .. } => ()\n+    }\n+    match e3 {\n+        Empty3 { .. } => ()\n+    }\n+\n+    let e11 = Empty1 { ..e1 };\n+    let e22 = Empty2 { ..e2 };\n+    let e33 = Empty3 { ..e3 };\n+}"}, {"sha": "a9abb99696f59a210f7c47f4e77db4820e0217e2", "filename": "src/test/run-pass/issue-16819.rs", "status": "renamed", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Frun-pass%2Fissue-16819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c/src%2Ftest%2Frun-pass%2Fissue-16819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16819.rs?ref=dc1c7975b015c14d4c26f2b07ab2b64f5fc66d3c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+//`#[cfg]` on struct field permits empty unusable struct\n \n-struct Foo {}\n-//~^ ERROR: unit-like struct definition should be written as `struct Foo;`\n+#![feature(braced_empty_structs)]\n \n-fn main() {}\n+struct S {\n+    #[cfg(untrue)]\n+    a: int,\n+}\n+\n+fn main() {\n+    let s = S {};\n+}", "previous_filename": "src/test/parse-fail/struct-no-fields.rs"}]}