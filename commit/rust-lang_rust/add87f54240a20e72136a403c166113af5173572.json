{"sha": "add87f54240a20e72136a403c166113af5173572", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZDg3ZjU0MjQwYTIwZTcyMTM2YTQwM2MxNjYxMTNhZjUxNzM1NzI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-01-18T11:52:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-01-18T11:52:12Z"}, "message": "Avoid blocking the main loop when editing Cargo.toml\n\nI've noticed a bunch of \"main loop too long\" warnings in console when\ntyping in Cargo.toml. Profiling showed that the culprit is `rustc\n--print cfg` call.\n\nI moved it to the background project loading phase, where it belongs.\nThis highlighted a problem: we generally use single `cfg`, while it\nreally should be per crate.", "tree": {"sha": "14ed8b5ca07a40dea9b0599506d78b3d6f4c4a6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14ed8b5ca07a40dea9b0599506d78b3d6f4c4a6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/add87f54240a20e72136a403c166113af5173572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/add87f54240a20e72136a403c166113af5173572", "html_url": "https://github.com/rust-lang/rust/commit/add87f54240a20e72136a403c166113af5173572", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/add87f54240a20e72136a403c166113af5173572/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc963d2b1190578ad9f1d1f4589e8ea2c98c1a14", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc963d2b1190578ad9f1d1f4589e8ea2c98c1a14", "html_url": "https://github.com/rust-lang/rust/commit/cc963d2b1190578ad9f1d1f4589e8ea2c98c1a14"}], "stats": {"total": 171, "additions": 100, "deletions": 71}, "files": [{"sha": "970a7e1402f6768455ab424ec6cdd78d73b4b23d", "filename": "crates/project_model/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/add87f54240a20e72136a403c166113af5173572/crates%2Fproject_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add87f54240a20e72136a403c166113af5173572/crates%2Fproject_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Flib.rs?ref=add87f54240a20e72136a403c166113af5173572", "patch": "@@ -5,6 +5,7 @@ mod cfg_flag;\n mod project_json;\n mod sysroot;\n mod workspace;\n+mod rustc_cfg;\n \n use std::{\n     fs::{read_dir, ReadDir},"}, {"sha": "4a7bd8ae3530f9e0c140a9e5c9f8b0eb3b61822e", "filename": "crates/project_model/src/rustc_cfg.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/add87f54240a20e72136a403c166113af5173572/crates%2Fproject_model%2Fsrc%2Frustc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add87f54240a20e72136a403c166113af5173572/crates%2Fproject_model%2Fsrc%2Frustc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Frustc_cfg.rs?ref=add87f54240a20e72136a403c166113af5173572", "patch": "@@ -0,0 +1,34 @@\n+//! Runs `rustc --print cfg` to get built-in cfg flags.\n+\n+use std::process::Command;\n+\n+use crate::{cfg_flag::CfgFlag, utf8_stdout};\n+\n+pub(crate) fn get(target: Option<&str>) -> Vec<CfgFlag> {\n+    let _p = profile::span(\"rustc_cfg::get\");\n+    let mut res = Vec::new();\n+\n+    // Some nightly-only cfgs, which are required for stdlib\n+    res.push(CfgFlag::Atom(\"target_thread_local\".into()));\n+    for &ty in [\"8\", \"16\", \"32\", \"64\", \"cas\", \"ptr\"].iter() {\n+        for &key in [\"target_has_atomic\", \"target_has_atomic_load_store\"].iter() {\n+            res.push(CfgFlag::KeyValue { key: key.to_string(), value: ty.into() });\n+        }\n+    }\n+\n+    let rustc_cfgs = {\n+        let mut cmd = Command::new(toolchain::rustc());\n+        cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n+        if let Some(target) = target {\n+            cmd.args(&[\"--target\", target]);\n+        }\n+        utf8_stdout(cmd)\n+    };\n+\n+    match rustc_cfgs {\n+        Ok(rustc_cfgs) => res.extend(rustc_cfgs.lines().map(|it| it.parse().unwrap())),\n+        Err(e) => log::error!(\"failed to get rustc cfgs: {:#}\", e),\n+    }\n+\n+    res\n+}"}, {"sha": "8e0481ae97450a25f2e61325c10e9d837a8f037f", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 58, "deletions": 61, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/add87f54240a20e72136a403c166113af5173572/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add87f54240a20e72136a403c166113af5173572/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=add87f54240a20e72136a403c166113af5173572", "patch": "@@ -16,7 +16,7 @@ use proc_macro_api::ProcMacroClient;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n-    cargo_workspace, cfg_flag::CfgFlag, sysroot::SysrootCrate, utf8_stdout, CargoConfig,\n+    cargo_workspace, cfg_flag::CfgFlag, rustc_cfg, sysroot::SysrootCrate, utf8_stdout, CargoConfig,\n     CargoWorkspace, ProjectJson, ProjectManifest, Sysroot, TargetKind,\n };\n \n@@ -34,29 +34,41 @@ pub struct PackageRoot {\n #[derive(Clone, Eq, PartialEq)]\n pub enum ProjectWorkspace {\n     /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.\n-    Cargo { cargo: CargoWorkspace, sysroot: Sysroot, rustc: Option<CargoWorkspace> },\n+    Cargo {\n+        cargo: CargoWorkspace,\n+        sysroot: Sysroot,\n+        rustc: Option<CargoWorkspace>,\n+        /// Holds cfg flags for the current target. We get those by running\n+        /// `rustc --print cfg`.\n+        ///\n+        /// FIXME: make this a per-crate map, as, eg, build.rs might have a\n+        /// different target.\n+        rustc_cfg: Vec<CfgFlag>,\n+    },\n     /// Project workspace was manually specified using a `rust-project.json` file.\n-    Json { project: ProjectJson, sysroot: Option<Sysroot> },\n+    Json { project: ProjectJson, sysroot: Option<Sysroot>, rustc_cfg: Vec<CfgFlag> },\n }\n \n impl fmt::Debug for ProjectWorkspace {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => f\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc, rustc_cfg } => f\n                 .debug_struct(\"Cargo\")\n                 .field(\"n_packages\", &cargo.packages().len())\n                 .field(\"n_sysroot_crates\", &sysroot.crates().len())\n                 .field(\n                     \"n_rustc_compiler_crates\",\n                     &rustc.as_ref().map_or(0, |rc| rc.packages().len()),\n                 )\n+                .field(\"rustc_cfg\", rustc_cfg)\n                 .finish(),\n-            ProjectWorkspace::Json { project, sysroot } => {\n+            ProjectWorkspace::Json { project, sysroot, rustc_cfg } => {\n                 let mut debug_struct = f.debug_struct(\"Json\");\n                 debug_struct.field(\"n_crates\", &project.n_crates());\n                 if let Some(sysroot) = sysroot {\n                     debug_struct.field(\"n_sysroot_crates\", &sysroot.crates().len());\n                 }\n+                debug_struct.field(\"rustc_cfg\", rustc_cfg);\n                 debug_struct.finish()\n             }\n         }\n@@ -79,7 +91,7 @@ impl ProjectWorkspace {\n                 })?;\n                 let project_location = project_json.parent().unwrap().to_path_buf();\n                 let project_json = ProjectJson::new(&project_location, data);\n-                ProjectWorkspace::load_inline(project_json)?\n+                ProjectWorkspace::load_inline(project_json, config.target.as_deref())?\n             }\n             ProjectManifest::CargoToml(cargo_toml) => {\n                 let cargo_version = utf8_stdout({\n@@ -117,29 +129,32 @@ impl ProjectWorkspace {\n                 } else {\n                     None\n                 };\n-\n-                ProjectWorkspace::Cargo { cargo, sysroot, rustc }\n+                let rustc_cfg = rustc_cfg::get(config.target.as_deref());\n+                ProjectWorkspace::Cargo { cargo, sysroot, rustc, rustc_cfg }\n             }\n         };\n \n         Ok(res)\n     }\n \n-    pub fn load_inline(project_json: ProjectJson) -> Result<ProjectWorkspace> {\n+    pub fn load_inline(\n+        project_json: ProjectJson,\n+        target: Option<&str>,\n+    ) -> Result<ProjectWorkspace> {\n         let sysroot = match &project_json.sysroot_src {\n             Some(path) => Some(Sysroot::load(path)?),\n             None => None,\n         };\n-\n-        Ok(ProjectWorkspace::Json { project: project_json, sysroot })\n+        let rustc_cfg = rustc_cfg::get(target);\n+        Ok(ProjectWorkspace::Json { project: project_json, sysroot, rustc_cfg })\n     }\n \n     /// Returns the roots for the current `ProjectWorkspace`\n     /// The return type contains the path and whether or not\n     /// the root is a member of the current workspace\n     pub fn to_roots(&self) -> Vec<PackageRoot> {\n         match self {\n-            ProjectWorkspace::Json { project, sysroot } => project\n+            ProjectWorkspace::Json { project, sysroot, rustc_cfg: _ } => project\n                 .crates()\n                 .map(|(_, krate)| PackageRoot {\n                     is_member: krate.is_workspace_member,\n@@ -156,7 +171,7 @@ impl ProjectWorkspace {\n                     })\n                 }))\n                 .collect::<Vec<_>>(),\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => cargo\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc, rustc_cfg: _ } => cargo\n                 .packages()\n                 .map(|pkg| {\n                     let is_member = cargo[pkg].is_member;\n@@ -194,7 +209,7 @@ impl ProjectWorkspace {\n     pub fn n_packages(&self) -> usize {\n         match self {\n             ProjectWorkspace::Json { project, .. } => project.n_crates(),\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc, .. } => {\n                 let rustc_package_len = rustc.as_ref().map_or(0, |rc| rc.packages().len());\n                 cargo.packages().len() + sysroot.crates().len() + rustc_package_len\n             }\n@@ -203,7 +218,6 @@ impl ProjectWorkspace {\n \n     pub fn to_crate_graph(\n         &self,\n-        target: Option<&str>,\n         proc_macro_client: Option<&ProcMacroClient>,\n         load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     ) -> CrateGraph {\n@@ -214,12 +228,21 @@ impl ProjectWorkspace {\n         };\n \n         let mut crate_graph = match self {\n-            ProjectWorkspace::Json { project, sysroot } => {\n-                project_json_to_crate_graph(target, &proc_macro_loader, load, project, sysroot)\n-            }\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n-                cargo_to_crate_graph(target, &proc_macro_loader, load, cargo, sysroot, rustc)\n-            }\n+            ProjectWorkspace::Json { project, sysroot, rustc_cfg } => project_json_to_crate_graph(\n+                rustc_cfg.clone(),\n+                &proc_macro_loader,\n+                load,\n+                project,\n+                sysroot,\n+            ),\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc, rustc_cfg } => cargo_to_crate_graph(\n+                rustc_cfg.clone(),\n+                &proc_macro_loader,\n+                load,\n+                cargo,\n+                sysroot,\n+                rustc,\n+            ),\n         };\n         if crate_graph.patch_cfg_if() {\n             log::debug!(\"Patched std to depend on cfg-if\")\n@@ -231,7 +254,7 @@ impl ProjectWorkspace {\n }\n \n fn project_json_to_crate_graph(\n-    target: Option<&str>,\n+    rustc_cfg: Vec<CfgFlag>,\n     proc_macro_loader: &dyn Fn(&Path) -> Vec<ProcMacro>,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     project: &ProjectJson,\n@@ -240,9 +263,9 @@ fn project_json_to_crate_graph(\n     let mut crate_graph = CrateGraph::default();\n     let sysroot_deps = sysroot\n         .as_ref()\n-        .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load));\n+        .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, rustc_cfg.clone(), load));\n \n-    let mut cfg_cache: FxHashMap<Option<&str>, Vec<CfgFlag>> = FxHashMap::default();\n+    let mut cfg_cache: FxHashMap<&str, Vec<CfgFlag>> = FxHashMap::default();\n     let crates: FxHashMap<CrateId, CrateId> = project\n         .crates()\n         .filter_map(|(crate_id, krate)| {\n@@ -254,9 +277,12 @@ fn project_json_to_crate_graph(\n             let env = krate.env.clone().into_iter().collect();\n             let proc_macro = krate.proc_macro_dylib_path.clone().map(|it| proc_macro_loader(&it));\n \n-            let target = krate.target.as_deref().or(target);\n-            let target_cfgs =\n-                cfg_cache.entry(target).or_insert_with(|| get_rustc_cfg_options(target));\n+            let target_cfgs = match krate.target.as_deref() {\n+                Some(target) => {\n+                    cfg_cache.entry(target).or_insert_with(|| rustc_cfg::get(Some(target)))\n+                }\n+                None => &rustc_cfg,\n+            };\n \n             let mut cfg_options = CfgOptions::default();\n             cfg_options.extend(target_cfgs.iter().chain(krate.cfg.iter()).cloned());\n@@ -293,7 +319,7 @@ fn project_json_to_crate_graph(\n }\n \n fn cargo_to_crate_graph(\n-    target: Option<&str>,\n+    rustc_cfg: Vec<CfgFlag>,\n     proc_macro_loader: &dyn Fn(&Path) -> Vec<ProcMacro>,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     cargo: &CargoWorkspace,\n@@ -303,10 +329,10 @@ fn cargo_to_crate_graph(\n     let _p = profile::span(\"cargo_to_crate_graph\");\n     let mut crate_graph = CrateGraph::default();\n     let (public_deps, libproc_macro) =\n-        sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load);\n+        sysroot_to_crate_graph(&mut crate_graph, sysroot, rustc_cfg.clone(), load);\n \n     let mut cfg_options = CfgOptions::default();\n-    cfg_options.extend(get_rustc_cfg_options(target));\n+    cfg_options.extend(rustc_cfg);\n \n     let mut pkg_to_lib_crate = FxHashMap::default();\n \n@@ -492,12 +518,12 @@ fn add_target_crate_root(\n fn sysroot_to_crate_graph(\n     crate_graph: &mut CrateGraph,\n     sysroot: &Sysroot,\n-    target: Option<&str>,\n+    rustc_cfg: Vec<CfgFlag>,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n ) -> (Vec<(CrateName, CrateId)>, Option<CrateId>) {\n     let _p = profile::span(\"sysroot_to_crate_graph\");\n     let mut cfg_options = CfgOptions::default();\n-    cfg_options.extend(get_rustc_cfg_options(target));\n+    cfg_options.extend(rustc_cfg);\n     let sysroot_crates: FxHashMap<SysrootCrate, CrateId> = sysroot\n         .crates()\n         .filter_map(|krate| {\n@@ -536,35 +562,6 @@ fn sysroot_to_crate_graph(\n     (public_deps, libproc_macro)\n }\n \n-fn get_rustc_cfg_options(target: Option<&str>) -> Vec<CfgFlag> {\n-    let _p = profile::span(\"get_rustc_cfg_options\");\n-    let mut res = Vec::new();\n-\n-    // Some nightly-only cfgs, which are required for stdlib\n-    res.push(CfgFlag::Atom(\"target_thread_local\".into()));\n-    for &ty in [\"8\", \"16\", \"32\", \"64\", \"cas\", \"ptr\"].iter() {\n-        for &key in [\"target_has_atomic\", \"target_has_atomic_load_store\"].iter() {\n-            res.push(CfgFlag::KeyValue { key: key.to_string(), value: ty.into() });\n-        }\n-    }\n-\n-    let rustc_cfgs = {\n-        let mut cmd = Command::new(toolchain::rustc());\n-        cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n-        if let Some(target) = target {\n-            cmd.args(&[\"--target\", target]);\n-        }\n-        utf8_stdout(cmd)\n-    };\n-\n-    match rustc_cfgs {\n-        Ok(rustc_cfgs) => res.extend(rustc_cfgs.lines().map(|it| it.parse().unwrap())),\n-        Err(e) => log::error!(\"failed to get rustc cfgs: {:#}\", e),\n-    }\n-\n-    res\n-}\n-\n fn add_dep(graph: &mut CrateGraph, from: CrateId, name: CrateName, to: CrateId) {\n     if let Err(err) = graph.add_dep(from, name, to) {\n         log::error!(\"{}\", err)"}, {"sha": "16ccab7817f14d577378ec1caecddd5dc38926d9", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/add87f54240a20e72136a403c166113af5173572/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add87f54240a20e72136a403c166113af5173572/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=add87f54240a20e72136a403c166113af5173572", "patch": "@@ -39,7 +39,7 @@ pub fn load_cargo(\n         None\n     };\n \n-    let crate_graph = ws.to_crate_graph(None, proc_macro_client.as_ref(), &mut |path: &AbsPath| {\n+    let crate_graph = ws.to_crate_graph(proc_macro_client.as_ref(), &mut |path: &AbsPath| {\n         let contents = loader.load_sync(path);\n         let path = vfs::VfsPath::from(path.to_path_buf());\n         vfs.set_file_contents(path.clone(), contents);"}, {"sha": "dabfb4241574a77c278fc975c528d6e320540ec0", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/add87f54240a20e72136a403c166113af5173572/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add87f54240a20e72136a403c166113af5173572/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=add87f54240a20e72136a403c166113af5173572", "patch": "@@ -135,7 +135,10 @@ impl GlobalState {\n                             )\n                         }\n                         LinkedProject::InlineJsonProject(it) => {\n-                            project_model::ProjectWorkspace::load_inline(it.clone())\n+                            project_model::ProjectWorkspace::load_inline(\n+                                it.clone(),\n+                                cargo_config.target.as_deref(),\n+                            )\n                         }\n                     })\n                     .collect::<Vec<_>>();\n@@ -253,11 +256,7 @@ impl GlobalState {\n                 res\n             };\n             for ws in workspaces.iter() {\n-                crate_graph.extend(ws.to_crate_graph(\n-                    self.config.cargo().target.as_deref(),\n-                    self.proc_macro_client.as_ref(),\n-                    &mut load,\n-                ));\n+                crate_graph.extend(ws.to_crate_graph(self.proc_macro_client.as_ref(), &mut load));\n             }\n \n             crate_graph\n@@ -289,9 +288,7 @@ impl GlobalState {\n             .iter()\n             .enumerate()\n             .filter_map(|(id, w)| match w {\n-                ProjectWorkspace::Cargo { cargo, sysroot: _, rustc: _ } => {\n-                    Some((id, cargo.workspace_root()))\n-                }\n+                ProjectWorkspace::Cargo { cargo, .. } => Some((id, cargo.workspace_root())),\n                 ProjectWorkspace::Json { project, .. } => {\n                     // Enable flychecks for json projects if a custom flycheck command was supplied\n                     // in the workspace configuration."}]}