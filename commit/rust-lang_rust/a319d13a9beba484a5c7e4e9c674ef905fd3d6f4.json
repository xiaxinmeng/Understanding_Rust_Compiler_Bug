{"sha": "a319d13a9beba484a5c7e4e9c674ef905fd3d6f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMTlkMTNhOWJlYmE0ODRhNWM3ZTRlOWM2NzRlZjkwNWZkM2Q2ZjQ=", "commit": {"author": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2016-10-20T22:09:59Z"}, "committer": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2016-10-25T18:33:03Z"}, "message": "Small improvement to SipHasher", "tree": {"sha": "a89265290471a2d4322d6780612b6d8c4d5dafe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a89265290471a2d4322d6780612b6d8c4d5dafe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a319d13a9beba484a5c7e4e9c674ef905fd3d6f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a319d13a9beba484a5c7e4e9c674ef905fd3d6f4", "html_url": "https://github.com/rust-lang/rust/commit/a319d13a9beba484a5c7e4e9c674ef905fd3d6f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a319d13a9beba484a5c7e4e9c674ef905fd3d6f4/comments", "author": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bccb829d0fe9a733bd6efcf6f7313186ae237ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bccb829d0fe9a733bd6efcf6f7313186ae237ab", "html_url": "https://github.com/rust-lang/rust/commit/7bccb829d0fe9a733bd6efcf6f7313186ae237ab"}], "stats": {"total": 168, "additions": 118, "deletions": 50}, "files": [{"sha": "6b3ab64dfd88ccb4bc67e1e4fdf6945ef01d8c7c", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 97, "deletions": 50, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/a319d13a9beba484a5c7e4e9c674ef905fd3d6f4/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a319d13a9beba484a5c7e4e9c674ef905fd3d6f4/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=a319d13a9beba484a5c7e4e9c674ef905fd3d6f4", "patch": "@@ -14,6 +14,8 @@\n \n use marker::PhantomData;\n use ptr;\n+use cmp;\n+use mem;\n \n /// An implementation of SipHash 1-3.\n ///\n@@ -78,45 +80,6 @@ struct State {\n     v3: u64,\n }\n \n-// sadly, these macro definitions can't appear later,\n-// because they're needed in the following defs;\n-// this design could be improved.\n-\n-macro_rules! u8to64_le {\n-    ($buf:expr, $i:expr) =>\n-    ($buf[0+$i] as u64 |\n-     ($buf[1+$i] as u64) << 8 |\n-     ($buf[2+$i] as u64) << 16 |\n-     ($buf[3+$i] as u64) << 24 |\n-     ($buf[4+$i] as u64) << 32 |\n-     ($buf[5+$i] as u64) << 40 |\n-     ($buf[6+$i] as u64) << 48 |\n-     ($buf[7+$i] as u64) << 56);\n-    ($buf:expr, $i:expr, $len:expr) =>\n-    ({\n-        let mut t = 0;\n-        let mut out = 0;\n-        while t < $len {\n-            out |= ($buf[t+$i] as u64) << t*8;\n-            t += 1;\n-        }\n-        out\n-    });\n-}\n-\n-/// Load a full u64 word from a byte stream, in LE order. Use\n-/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n-/// to load u64 from a possibly unaligned address.\n-///\n-/// Unsafe because: unchecked indexing at i..i+8\n-#[inline]\n-unsafe fn load_u64_le(buf: &[u8], i: usize) -> u64 {\n-    debug_assert!(i + 8 <= buf.len());\n-    let mut data = 0u64;\n-    ptr::copy_nonoverlapping(buf.get_unchecked(i), &mut data as *mut _ as *mut u8, 8);\n-    data.to_le()\n-}\n-\n macro_rules! compress {\n     ($state:expr) => ({\n         compress!($state.v0, $state.v1, $state.v2, $state.v3)\n@@ -132,6 +95,47 @@ macro_rules! compress {\n     });\n }\n \n+/// Load an integer of the desired type from a byte stream, in LE order. Uses\n+/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n+/// to load it from a possibly unaligned address.\n+///\n+/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n+macro_rules! load_int_le {\n+    ($buf:expr, $i:expr, $int_ty:ident) =>\n+    ({\n+       debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n+       let mut data = 0 as $int_ty;\n+       ptr::copy_nonoverlapping($buf.get_unchecked($i),\n+                                &mut data as *mut _ as *mut u8,\n+                                mem::size_of::<$int_ty>());\n+       data.to_le()\n+    });\n+}\n+\n+/// Load an u64 using up to 7 bytes of a byte slice.\n+///\n+/// Unsafe because: unchecked indexing at start..start+len\n+#[inline]\n+unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+    debug_assert!(len < 8);\n+    let mut i = 0; // current byte index (from LSB) in the output u64\n+    let mut out = 0;\n+    if i + 3 < len {\n+        out = load_int_le!(buf, start + i, u32) as u64;\n+        i += 4;\n+    }\n+    if i + 1 < len {\n+        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+        i += 2\n+    }\n+    if i < len {\n+        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+        i += 1;\n+    }\n+    debug_assert_eq!(i, len);\n+    out\n+}\n+\n impl SipHasher {\n     /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n@@ -220,6 +224,37 @@ impl<S: Sip> Hasher<S> {\n         self.state.v3 = self.k1 ^ 0x7465646279746573;\n         self.ntail = 0;\n     }\n+\n+    // Specialized write function that is only valid for buffers with len <= 8.\n+    // It's used to force inlining of write_u8 and write_usize, those would normally be inlined\n+    // except for composite types (that includes slices and str hashing because of delimiter).\n+    // Without this extra push the compiler is very reluctant to inline delimiter writes,\n+    // degrading performance substantially for the most common use cases.\n+    #[inline(always)]\n+    fn short_write(&mut self, msg: &[u8]) {\n+        debug_assert!(msg.len() <= 8);\n+        let length = msg.len();\n+        self.length += length;\n+\n+        let needed = 8 - self.ntail;\n+        let fill = cmp::min(length, needed);\n+        if fill == 8 {\n+            self.tail = unsafe { load_int_le!(msg, 0, u64) };\n+        } else {\n+            self.tail |= unsafe { u8to64_le(msg, 0, fill) } << (8 * self.ntail);\n+            if length < needed {\n+                self.ntail += length;\n+                return;\n+            }\n+        }\n+        self.state.v3 ^= self.tail;\n+        S::c_rounds(&mut self.state);\n+        self.state.v0 ^= self.tail;\n+\n+        // Buffered tail is now flushed, process new input.\n+        self.ntail = length - needed;\n+        self.tail = unsafe { u8to64_le(msg, needed, self.ntail) };\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -262,6 +297,21 @@ impl super::Hasher for SipHasher24 {\n }\n \n impl<S: Sip> super::Hasher for Hasher<S> {\n+    // see short_write comment for explanation\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        let bytes = unsafe {\n+            ::slice::from_raw_parts(&i as *const usize as *const u8, mem::size_of::<usize>())\n+        };\n+        self.short_write(bytes);\n+    }\n+\n+    // see short_write comment for explanation\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.short_write(&[i]);\n+    }\n+\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n@@ -271,19 +321,16 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n \n         if self.ntail != 0 {\n             needed = 8 - self.ntail;\n+            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << 8 * self.ntail;\n             if length < needed {\n-                self.tail |= u8to64_le!(msg, 0, length) << 8 * self.ntail;\n                 self.ntail += length;\n                 return\n+            } else {\n+                self.state.v3 ^= self.tail;\n+                S::c_rounds(&mut self.state);\n+                self.state.v0 ^= self.tail;\n+                self.ntail = 0;\n             }\n-\n-            let m = self.tail | u8to64_le!(msg, 0, needed) << 8 * self.ntail;\n-\n-            self.state.v3 ^= m;\n-            S::c_rounds(&mut self.state);\n-            self.state.v0 ^= m;\n-\n-            self.ntail = 0;\n         }\n \n         // Buffered tail is now flushed, process new input.\n@@ -292,7 +339,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n \n         let mut i = needed;\n         while i < len - left {\n-            let mi = unsafe { load_u64_le(msg, i) };\n+            let mi = unsafe { load_int_le!(msg, i, u64) };\n \n             self.state.v3 ^= mi;\n             S::c_rounds(&mut self.state);\n@@ -301,7 +348,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n             i += 8;\n         }\n \n-        self.tail = u8to64_le!(msg, i, left);\n+        self.tail = unsafe { u8to64_le(msg, i, left) };\n         self.ntail = left;\n     }\n "}, {"sha": "fa3bfdea42df8194734d8ccb3e80222f9b1d5636", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a319d13a9beba484a5c7e4e9c674ef905fd3d6f4/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a319d13a9beba484a5c7e4e9c674ef905fd3d6f4/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=a319d13a9beba484a5c7e4e9c674ef905fd3d6f4", "patch": "@@ -14,6 +14,7 @@ use test::{Bencher, black_box};\n \n use core::hash::{Hash, Hasher};\n use core::hash::{SipHasher, SipHasher13, SipHasher24};\n+use core::{slice, mem};\n \n // Hash just the bytes of the slice, without length prefix\n struct Bytes<'a>(&'a [u8]);\n@@ -327,6 +328,26 @@ fn test_hash_no_concat_alias() {\n     assert!(hash(&v) != hash(&w));\n }\n \n+#[test]\n+fn test_write_short_works() {\n+    let test_usize = 0xd0c0b0a0usize;\n+    let mut h1 = SipHasher24::new();\n+    h1.write_usize(test_usize);\n+    h1.write(b\"bytes\");\n+    h1.write(b\"string\");\n+    h1.write_u8(0xFFu8);\n+    h1.write_u8(0x01u8);\n+    let mut h2 = SipHasher24::new();\n+    h2.write(unsafe {\n+        slice::from_raw_parts(&test_usize as *const _ as *const u8,\n+                              mem::size_of::<usize>())\n+    });\n+    h2.write(b\"bytes\");\n+    h2.write(b\"string\");\n+    h2.write(&[0xFFu8, 0x01u8]);\n+    assert_eq!(h1.finish(), h2.finish());\n+}\n+\n #[bench]\n fn bench_str_under_8_bytes(b: &mut Bencher) {\n     let s = \"foo\";"}]}