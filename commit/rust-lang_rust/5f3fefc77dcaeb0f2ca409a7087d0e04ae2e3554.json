{"sha": "5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmM2ZlZmM3N2RjYWViMGYyY2E0MDlhNzA4N2QwZTA0YWUyZTM1NTQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-13T22:14:47Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-07-08T14:42:46Z"}, "message": "trans: Get rid of the last potential on-demand creation of non-closure functions.", "tree": {"sha": "ba26bad73685646138911a6f34aa42830e47c94d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba26bad73685646138911a6f34aa42830e47c94d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554", "html_url": "https://github.com/rust-lang/rust/commit/5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67171069472f57875ac8cf4c94e1a56fa635582a", "url": "https://api.github.com/repos/rust-lang/rust/commits/67171069472f57875ac8cf4c94e1a56fa635582a", "html_url": "https://github.com/rust-lang/rust/commit/67171069472f57875ac8cf4c94e1a56fa635582a"}], "stats": {"total": 102, "additions": 11, "deletions": 91}, "files": [{"sha": "fc45d73a7ae9a572f27a411211dd3c9a67efd406", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 67, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554", "patch": "@@ -25,8 +25,6 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::ValueOrigin::*;\n-\n use super::CrateTranslation;\n use super::ModuleTranslation;\n \n@@ -1918,37 +1916,6 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fcx.finish(bcx, fn_cleanup_debug_loc.debug_loc());\n }\n \n-/// Creates an LLVM function corresponding to a source language function.\n-pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                          decl: &hir::FnDecl,\n-                          body: &hir::Block,\n-                          llfndecl: ValueRef,\n-                          param_substs: &'tcx Substs<'tcx>,\n-                          id: ast::NodeId) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx().node_path_str(id));\n-    debug!(\"trans_fn(param_substs={:?})\", param_substs);\n-    let _icx = push_ctxt(\"trans_fn\");\n-    let def_id = if let Some(&def_id) = ccx.external_srcs().borrow().get(&id) {\n-        def_id\n-    } else {\n-        ccx.tcx().map.local_def_id(id)\n-    };\n-    let fn_ty = ccx.tcx().lookup_item_type(def_id).ty;\n-    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fn_ty);\n-    let sig = ccx.tcx().erase_late_bound_regions(fn_ty.fn_sig());\n-    let sig = ccx.tcx().normalize_associated_type(&sig);\n-    let abi = fn_ty.fn_abi();\n-    trans_closure(ccx,\n-                  decl,\n-                  body,\n-                  llfndecl,\n-                  Instance::new(def_id, param_substs),\n-                  id,\n-                  &sig,\n-                  abi,\n-                  closure::ClosureEnv::NotClosure);\n-}\n-\n pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n     let instance = inline::maybe_inline_instance(ccx, instance);\n \n@@ -2215,46 +2182,14 @@ pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     }\n }\n \n-\n-/// Enum describing the origin of an LLVM `Value`, for linkage purposes.\n-#[derive(Copy, Clone)]\n-pub enum ValueOrigin {\n-    /// The LLVM `Value` is in this context because the corresponding item was\n-    /// assigned to the current compilation unit.\n-    OriginalTranslation,\n-    /// The `Value`'s corresponding item was assigned to some other compilation\n-    /// unit, but the `Value` was translated in this context anyway because the\n-    /// item is marked `#[inline]`.\n-    InlinedCopy,\n-}\n-\n /// Set the appropriate linkage for an LLVM `ValueRef` (function or global).\n /// If the `llval` is the direct translation of a specific Rust item, `id`\n /// should be set to the `NodeId` of that item.  (This mapping should be\n /// 1-to-1, so monomorphizations and drop/visit glue should have `id` set to\n-/// `None`.)  `llval_origin` indicates whether `llval` is the translation of an\n-/// item assigned to `ccx`'s compilation unit or an inlined copy of an item\n-/// assigned to a different compilation unit.\n+/// `None`.)\n pub fn update_linkage(ccx: &CrateContext,\n                       llval: ValueRef,\n-                      id: Option<ast::NodeId>,\n-                      llval_origin: ValueOrigin) {\n-    match llval_origin {\n-        InlinedCopy => {\n-            // `llval` is a translation of an item defined in a separate\n-            // compilation unit.  This only makes sense if there are at least\n-            // two compilation units.\n-            assert!(ccx.sess().opts.cg.codegen_units > 1 ||\n-                    ccx.sess().opts.debugging_opts.incremental.is_some());\n-            // `llval` is a copy of something defined elsewhere, so use\n-            // `AvailableExternallyLinkage` to avoid duplicating code in the\n-            // output.\n-            llvm::SetLinkage(llval, llvm::AvailableExternallyLinkage);\n-            return;\n-        },\n-        OriginalTranslation => {},\n-    }\n-\n+                      id: Option<ast::NodeId>) {\n     if let Some(id) = id {\n         let item = ccx.tcx().map.get(id);\n         if let hir_map::NodeItem(i) = item {"}, {"sha": "e4519ff82a0eaef4bde4068d8b737c9dd15cbb40", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554", "patch": "@@ -285,7 +285,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let bcx = fcx.init(false, None);\n \n-    update_linkage(ccx, llfn, None, OriginalTranslation);\n+    update_linkage(ccx, llfn, None);\n \n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a"}, {"sha": "832acfe14bedc7ac163734df070a440af9d6b14f", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=5f3fefc77dcaeb0f2ca409a7087d0e04ae2e3554", "patch": "@@ -17,7 +17,6 @@ use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n use attributes;\n use base::{push_ctxt};\n-use base::trans_fn;\n use base;\n use common::*;\n use declare;\n@@ -27,17 +26,16 @@ use rustc::util::ppaux;\n \n use rustc::hir;\n \n-use syntax::attr;\n use errors;\n \n use std::fmt;\n+use trans_item::TransItem;\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: DefId,\n                                 psubsts: &'tcx subst::Substs<'tcx>)\n                                 -> (ValueRef, Ty<'tcx>) {\n     debug!(\"monomorphic_fn(fn_id={:?}, real_substs={:?})\", fn_id, psubsts);\n-\n     assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n \n     let _icx = push_ctxt(\"monomorphic_fn\");\n@@ -53,6 +51,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if let Some(&val) = ccx.instances().borrow().get(&instance) {\n         debug!(\"leaving monomorphic fn {:?}\", instance);\n         return (val, mono_ty);\n+    } else {\n+        assert!(!ccx.codegen_unit().items.contains_key(&TransItem::Fn(instance)));\n     }\n \n     debug!(\"monomorphic_fn({:?})\", instance);\n@@ -96,6 +96,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     ccx.instances().borrow_mut().insert(instance, lldecl);\n \n+\n     // we can only monomorphize things in this crate (or inlined into it)\n     let fn_node_id = ccx.tcx().map.as_local_node_id(fn_id).unwrap();\n     let map_node = errors::expect(\n@@ -110,34 +111,18 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match map_node {\n         hir_map::NodeItem(&hir::Item {\n             ref attrs,\n-            node: hir::ItemFn(ref decl, _, _, _, _, ref body), ..\n+            node: hir::ItemFn(..), ..\n         }) |\n         hir_map::NodeImplItem(&hir::ImplItem {\n             ref attrs, node: hir::ImplItemKind::Method(\n-                hir::MethodSig { ref decl, .. }, ref body), ..\n+                hir::MethodSig { .. }, _), ..\n         }) |\n         hir_map::NodeTraitItem(&hir::TraitItem {\n             ref attrs, node: hir::MethodTraitItem(\n-                hir::MethodSig { ref decl, .. }, Some(ref body)), ..\n+                hir::MethodSig { .. }, Some(_)), ..\n         }) => {\n             attributes::from_fn_attrs(ccx, attrs, lldecl);\n-\n-            let is_first = !ccx.available_monomorphizations().borrow()\n-                                                             .contains(&symbol);\n-            if is_first {\n-                ccx.available_monomorphizations().borrow_mut().insert(symbol.clone());\n-            }\n-\n-            let trans_everywhere = attr::requests_inline(attrs);\n-            if trans_everywhere || is_first {\n-                let origin = if is_first { base::OriginalTranslation } else { base::InlinedCopy };\n-                base::update_linkage(ccx, lldecl, None, origin);\n-                trans_fn(ccx, decl, body, lldecl, psubsts, fn_node_id);\n-            } else {\n-                // We marked the value as using internal linkage earlier, but that is illegal for\n-                // declarations, so switch back to external linkage.\n-                llvm::SetLinkage(lldecl, llvm::ExternalLinkage);\n-            }\n+            llvm::SetLinkage(lldecl, llvm::ExternalLinkage);\n         }\n \n         hir_map::NodeVariant(_) | hir_map::NodeStructCtor(_) => {"}]}