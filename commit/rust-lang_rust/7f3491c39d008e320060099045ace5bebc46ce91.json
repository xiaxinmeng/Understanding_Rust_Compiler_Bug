{"sha": "7f3491c39d008e320060099045ace5bebc46ce91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMzQ5MWMzOWQwMDhlMzIwMDYwMDk5MDQ1YWNlNWJlYmM0NmNlOTE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-08T21:44:19Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-08T23:28:33Z"}, "message": "Fix name resolution in lexical scopes", "tree": {"sha": "7694c29915176aa35e2c2529698e300557f262ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7694c29915176aa35e2c2529698e300557f262ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f3491c39d008e320060099045ace5bebc46ce91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f3491c39d008e320060099045ace5bebc46ce91", "html_url": "https://github.com/rust-lang/rust/commit/7f3491c39d008e320060099045ace5bebc46ce91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f3491c39d008e320060099045ace5bebc46ce91/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b7c3f20e83de20518abb879f7a0e41b6e93414f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b7c3f20e83de20518abb879f7a0e41b6e93414f", "html_url": "https://github.com/rust-lang/rust/commit/8b7c3f20e83de20518abb879f7a0e41b6e93414f"}], "stats": {"total": 93, "additions": 26, "deletions": 67}, "files": [{"sha": "7415e9a9674f5c648753143ff9ea051e263a6ce9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 65, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7f3491c39d008e320060099045ace5bebc46ce91/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3491c39d008e320060099045ace5bebc46ce91/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7f3491c39d008e320060099045ace5bebc46ce91", "patch": "@@ -1357,7 +1357,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// On success, returns the resolved module, and the closest *private*\n     /// module found to the destination when resolving this path.\n     fn resolve_module_path(&mut self,\n-                           module_: Module<'a>,\n                            module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span)\n@@ -1368,10 +1367,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n                names_to_string(module_path),\n-               module_to_string(&module_));\n+               module_to_string(self.current_module));\n \n         // Resolve the module prefix, if any.\n-        let module_prefix_result = self.resolve_module_prefix(module_, module_path);\n+        let module_prefix_result = self.resolve_module_prefix(module_path);\n \n         let search_module;\n         let start_index;\n@@ -1413,8 +1412,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        match self.resolve_item_in_lexical_scope(module_,\n-                                                                 module_path[0],\n+                        match self.resolve_item_in_lexical_scope(module_path[0],\n                                                                  TypeNS,\n                                                                  true) {\n                             Failed(err) => return Failed(err),\n@@ -1448,61 +1446,30 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_item_in_lexical_scope(&mut self,\n-                                     module_: Module<'a>,\n                                      name: Name,\n                                      namespace: Namespace,\n                                      record_used: bool)\n                                      -> ResolveResult<&'a NameBinding<'a>> {\n-        debug!(\"(resolving item in lexical scope) resolving `{}` in namespace {:?} in `{}`\",\n-               name,\n-               namespace,\n-               module_to_string(&module_));\n-\n-        // Proceed up the scope chain looking for parent modules.\n-        let mut search_module = module_;\n-        loop {\n-            // Resolve the name in the parent module.\n-            match self.resolve_name_in_module(search_module, name, namespace, true, record_used) {\n-                Failed(Some((span, msg))) => {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                }\n-                Failed(None) => (), // Continue up the search chain.\n-                Indeterminate => {\n-                    // We couldn't see through the higher scope because of an\n-                    // unresolved import higher up. Bail.\n-\n-                    debug!(\"(resolving item in lexical scope) indeterminate higher scope; bailing\");\n-                    return Indeterminate;\n-                }\n-                Success(binding) => {\n-                    // We found the module.\n-                    debug!(\"(resolving item in lexical scope) found name in module, done\");\n-                    return Success(binding);\n-                }\n+        // Check the local set of ribs.\n+        for i in (0 .. self.get_ribs(namespace).len()).rev() {\n+            if let Some(_) = self.get_ribs(namespace)[i].bindings.get(&name).cloned() {\n+                return Failed(None);\n             }\n \n-            // Go to the next parent.\n-            match search_module.parent_link {\n-                NoParentLink => {\n-                    // No more parents. This module was unresolved.\n-                    debug!(\"(resolving item in lexical scope) unresolved module: no parent module\");\n-                    return Failed(None);\n-                }\n-                ModuleParentLink(parent_module_node, _) => {\n-                    if search_module.is_normal() {\n-                        // We stop the search here.\n-                        debug!(\"(resolving item in lexical scope) unresolved module: not \\\n-                                searching through module parents\");\n-                            return Failed(None);\n-                    } else {\n-                        search_module = parent_module_node;\n-                    }\n-                }\n-                BlockParentLink(parent_module_node, _) => {\n-                    search_module = parent_module_node;\n+            if let ModuleRibKind(module) = self.get_ribs(namespace)[i].kind {\n+                if let Success(binding) = self.resolve_name_in_module(module,\n+                                                                      name,\n+                                                                      namespace,\n+                                                                      true,\n+                                                                      record_used) {\n+                    return Success(binding);\n                 }\n+                // We can only see through anonymous modules\n+                if module.def.is_some() { return Failed(None); }\n             }\n         }\n+\n+        Failed(None)\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n@@ -1538,9 +1505,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n-    fn resolve_module_prefix(&mut self,\n-                             module_: Module<'a>,\n-                             module_path: &[Name])\n+    fn resolve_module_prefix(&mut self, module_path: &[Name])\n                              -> ResolveResult<ModulePrefixResult<'a>> {\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n@@ -1549,6 +1514,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             \"super\" => 0,\n             _ => return Success(NoPrefixFound),\n         };\n+        let module_ = self.current_module;\n         let mut containing_module = self.get_nearest_normal_module_parent_or_self(module_);\n \n         // Now loop through all the `super`s we find.\n@@ -2594,8 +2560,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        name: Name,\n                                        span: Span)\n                                        -> BareIdentifierPatternResolution {\n-        let module = self.current_module;\n-        match self.resolve_item_in_lexical_scope(module, name, ValueNS, true) {\n+        match self.resolve_item_in_lexical_scope(name, ValueNS, true) {\n             Success(binding) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n                        name,\n@@ -2754,9 +2719,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Check the items.\n-        let module = self.current_module;\n         let name = identifier.unhygienic_name;\n-        match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n+        match self.resolve_item_in_lexical_scope(name, namespace, record_used) {\n             Success(binding) => binding.def().map(LocalDef::from_def),\n             Failed(Some((span, msg))) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -2869,8 +2833,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                   .collect::<Vec<_>>();\n \n         let containing_module;\n-        let current_module = self.current_module;\n-        match self.resolve_module_path(current_module, &module_path, UseLexicalScope, span) {\n+        match self.resolve_module_path(&module_path, UseLexicalScope, span) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n@@ -3024,7 +2987,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 span: Span,\n                                 name_path: &[ast::Name])\n                                 -> Option<Module<'a>> {\n-            let root = this.current_module;\n             let last_name = name_path.last().unwrap();\n \n             if name_path.len() == 1 {\n@@ -3034,7 +2996,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                .and_then(NameBinding::module)\n                 }\n             } else {\n-                this.resolve_module_path(root, &name_path, UseLexicalScope, span).success()\n+                this.resolve_module_path(&name_path, UseLexicalScope, span).success()\n             }\n         }\n \n@@ -3274,10 +3236,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let name_path = path.segments.iter()\n                                                         .map(|seg| seg.identifier.name)\n                                                         .collect::<Vec<_>>();\n-                                    let current_module = self.current_module;\n \n-                                    match self.resolve_module_path(current_module,\n-                                                                   &name_path[..],\n+                                    match self.resolve_module_path(&name_path[..],\n                                                                    UseLexicalScope,\n                                                                    expr.span) {\n                                         Success(_) => {"}, {"sha": "423604661ed56715ba1e8a5dfe3e7fbfc9217e58", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f3491c39d008e320060099045ace5bebc46ce91/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3491c39d008e320060099045ace5bebc46ce91/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7f3491c39d008e320060099045ace5bebc46ce91", "patch": "@@ -427,8 +427,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                module_to_string(&module_));\n \n         self.resolver\n-            .resolve_module_path(module_,\n-                                 &import_directive.module_path,\n+            .resolve_module_path(&import_directive.module_path,\n                                  UseLexicalScopeFlag::DontUseLexicalScope,\n                                  import_directive.span)\n             .and_then(|containing_module| {"}]}