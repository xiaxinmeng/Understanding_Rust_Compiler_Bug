{"sha": "414a86e7598b339f8b2681d0aa090d9fb4b6f0e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNGE4NmU3NTk4YjMzOWY4YjI2ODFkMGFhMDkwZDlmYjRiNmYwZTE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-18T00:08:49Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-20T09:22:24Z"}, "message": "resolve: Add some comments to in-module resolution", "tree": {"sha": "f3dfb341d6a5900f63c641e22048c894cd63a91a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3dfb341d6a5900f63c641e22048c894cd63a91a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/414a86e7598b339f8b2681d0aa090d9fb4b6f0e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/414a86e7598b339f8b2681d0aa090d9fb4b6f0e1", "html_url": "https://github.com/rust-lang/rust/commit/414a86e7598b339f8b2681d0aa090d9fb4b6f0e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/414a86e7598b339f8b2681d0aa090d9fb4b6f0e1/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2533b64a32b44dfde9b6a8a2301403a6568c313", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2533b64a32b44dfde9b6a8a2301403a6568c313", "html_url": "https://github.com/rust-lang/rust/commit/c2533b64a32b44dfde9b6a8a2301403a6568c313"}], "stats": {"total": 45, "additions": 31, "deletions": 14}, "files": [{"sha": "c242b9c7f2f4dbe31484ca10d28e76c36e55e894", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/414a86e7598b339f8b2681d0aa090d9fb4b6f0e1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/414a86e7598b339f8b2681d0aa090d9fb4b6f0e1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=414a86e7598b339f8b2681d0aa090d9fb4b6f0e1", "patch": "@@ -130,7 +130,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n-    /// Invariant: if `record_used` is `Some`, import resolution must be complete.\n+    /// Invariant: if `record_used` is `Some`, expansion and import resolution must be complete.\n     pub fn resolve_ident_in_module_unadjusted(&mut self,\n                                               module: Module<'a>,\n                                               ident: Ident,\n@@ -187,7 +187,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        // From now on we either have a glob resolution or no resolution.\n+        // --- From now on we either have a glob resolution or no resolution. ---\n \n         // Check if one of single imports can still define the name,\n         // if it can then our result is not determined and can be invalidated.\n@@ -207,27 +207,43 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let no_unresolved_invocations =\n-            restricted_shadowing || module.unresolved_invocations.borrow().is_empty();\n+        let no_unexpanded_macros = module.unresolved_invocations.borrow().is_empty();\n         match resolution.binding {\n-            // In `MacroNS`, expanded bindings do not shadow (enforced in `try_define`).\n-            Some(binding) if no_unresolved_invocations || ns == MacroNS =>\n+            // So we have a resolution that's from a glob import. This resolution is determined\n+            // if it cannot be shadowed by some new item/import expanded from a macro.\n+            // This happens either if there are no unexpanded macros, or expanded names cannot\n+            // shadow globs (that happens in macro namespace or with restricted shadowing).\n+            Some(binding) if no_unexpanded_macros || ns == MacroNS || restricted_shadowing =>\n                 return check_usable(self, binding),\n-            None if no_unresolved_invocations => {}\n+            // If we have no resolution, then it's a determined error it some new item/import\n+            // cannot appear from a macro expansion or an undetermined glob.\n+            None if no_unexpanded_macros => {} // go check for globs below\n+            // This is actually an undetermined error, but we need to return determinate error\n+            // due to subtle interactions with `resolve_lexical_macro_path_segment`\n+            // that are going to be removed in the next commit.\n+            None if restricted_shadowing => {} // go check for globs below\n             _ => return Err(Undetermined),\n         }\n \n-        // Check if the globs are determined\n+        // --- From now on we have no resolution. ---\n+\n+        // Check if one of glob imports can still define the name,\n+        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n+\n+        // What on earth is this?\n+        // Apparently one more subtle interaction with `resolve_lexical_macro_path_segment`\n+        // that are going to be removed in the next commit.\n         if restricted_shadowing && module.def().is_some() {\n             return Err(Determined);\n         }\n-        for directive in module.globs.borrow().iter() {\n-            if !self.is_accessible(directive.vis.get()) {\n+\n+        for glob_import in module.globs.borrow().iter() {\n+            if !self.is_accessible(glob_import.vis.get()) {\n                 continue\n             }\n-            let module = unwrap_or!(directive.imported_module.get(), return Err(Undetermined));\n+            let module = unwrap_or!(glob_import.imported_module.get(), return Err(Undetermined));\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n-            match ident.span.glob_adjust(module.expansion, directive.span.ctxt().modern()) {\n+            match ident.span.glob_adjust(module.expansion, glob_import.span.ctxt().modern()) {\n                 Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n                 Some(None) => {}\n                 None => continue,\n@@ -236,8 +252,9 @@ impl<'a> Resolver<'a> {\n                 module, ident, ns, false, false, path_span,\n             );\n             self.current_module = orig_current_module;\n-            if let Err(Undetermined) = result {\n-                return Err(Undetermined);\n+            match result {\n+                Err(Determined) => continue,\n+                Ok(_) | Err(Undetermined) => return Err(Undetermined),\n             }\n         }\n "}]}