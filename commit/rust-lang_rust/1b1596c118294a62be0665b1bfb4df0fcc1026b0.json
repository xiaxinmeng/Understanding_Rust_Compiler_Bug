{"sha": "1b1596c118294a62be0665b1bfb4df0fcc1026b0", "node_id": "C_kwDOAAsO6NoAKDFiMTU5NmMxMTgyOTRhNjJiZTA2NjViMWJmYjRkZjBmY2MxMDI2YjA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-09-24T12:29:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-24T12:29:52Z"}, "message": "Rollup merge of #100823 - WaffleLapkin:less_offsets, r=scottmcm\n\nRefactor some `std` code that works with pointer offstes\n\nThis PR replaces `pointer::offset` in standard library with `pointer::add` and `pointer::sub`, [re]moving some casts and using `.addr()` while we are at it.\n\nThis is a more complicated refactor than all other sibling PRs, so take a closer look when reviewing, please \ud83d\ude03  (though I've checked this multiple times and it looks fine).\n\nr? ````@scottmcm````\n\n_split off from #100746, continuation of #100822_", "tree": {"sha": "f4f6e3eb64b53cabcbb5e41c5c20c35e68fb0292", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4f6e3eb64b53cabcbb5e41c5c20c35e68fb0292"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b1596c118294a62be0665b1bfb4df0fcc1026b0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjLvhACRBK7hj4Ov3rIwAAlugIACYmnW0RCe/1IBPMbvJ9yFom\nth5A0KRLwV5xF5v0FIlQ48+rplH8Oyknr8xCF08moyU2CL71MVXc30nZKRYQK41f\nPTsHsJIONcQtjX1nwNYcs+Hd4vpm5vVjVWhQGnUdseTtoujtC/x9rg4G8TDxmbZ8\npLTam2zmKvG32mlBzEqu0jnfUWqulTM3Uy4UYo/oRl9lDeS2bbrcRkD6VPEPNY+j\nNDXzRs6qadbzb9PO+uQjgadzBLX9SFxab61Uqz95v8cpdJcOaV5fb1+Kte65ukQQ\nDtoBKBQsv3NWReWUIx7jlIom+uMz5swLPqHJl54hnZAczcpzgNFlGrxihGZmSe8=\n=9tmr\n-----END PGP SIGNATURE-----\n", "payload": "tree f4f6e3eb64b53cabcbb5e41c5c20c35e68fb0292\nparent bb5a01617589b5e3ece5a36435fc285bfd13c9a4\nparent 98a32305afabb8e31d898e2a74da63268e0a7f5f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1664022592 +0200\ncommitter GitHub <noreply@github.com> 1664022592 +0200\n\nRollup merge of #100823 - WaffleLapkin:less_offsets, r=scottmcm\n\nRefactor some `std` code that works with pointer offstes\n\nThis PR replaces `pointer::offset` in standard library with `pointer::add` and `pointer::sub`, [re]moving some casts and using `.addr()` while we are at it.\n\nThis is a more complicated refactor than all other sibling PRs, so take a closer look when reviewing, please \ud83d\ude03  (though I've checked this multiple times and it looks fine).\n\nr? ````@scottmcm````\n\n_split off from #100746, continuation of #100822_\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b1596c118294a62be0665b1bfb4df0fcc1026b0", "html_url": "https://github.com/rust-lang/rust/commit/1b1596c118294a62be0665b1bfb4df0fcc1026b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b1596c118294a62be0665b1bfb4df0fcc1026b0/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb5a01617589b5e3ece5a36435fc285bfd13c9a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb5a01617589b5e3ece5a36435fc285bfd13c9a4", "html_url": "https://github.com/rust-lang/rust/commit/bb5a01617589b5e3ece5a36435fc285bfd13c9a4"}, {"sha": "98a32305afabb8e31d898e2a74da63268e0a7f5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/98a32305afabb8e31d898e2a74da63268e0a7f5f", "html_url": "https://github.com/rust-lang/rust/commit/98a32305afabb8e31d898e2a74da63268e0a7f5f"}], "stats": {"total": 124, "additions": 62, "deletions": 62}, "files": [{"sha": "d8365ae9bf92034c4b6c592b780c93ebb2ec77f4", "filename": "library/core/src/fmt/num.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1b1596c118294a62be0665b1bfb4df0fcc1026b0/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1596c118294a62be0665b1bfb4df0fcc1026b0/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs?ref=1b1596c118294a62be0665b1bfb4df0fcc1026b0", "patch": "@@ -211,7 +211,7 @@ macro_rules! impl_Display {\n         fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n             let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n-            let mut curr = buf.len() as isize;\n+            let mut curr = buf.len();\n             let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n@@ -228,7 +228,7 @@ macro_rules! impl_Display {\n \n                 // eagerly decode 4 characters at a time\n                 while n >= 10000 {\n-                    let rem = (n % 10000) as isize;\n+                    let rem = (n % 10000) as usize;\n                     n /= 10000;\n \n                     let d1 = (rem / 100) << 1;\n@@ -238,37 +238,37 @@ macro_rules! impl_Display {\n                     // We are allowed to copy to `buf_ptr[curr..curr + 3]` here since\n                     // otherwise `curr < 0`. But then `n` was originally at least `10000^10`\n                     // which is `10^40 > 2^128 > n`.\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d2), buf_ptr.add(curr + 2), 2);\n                 }\n \n                 // if we reach here numbers are <= 9999, so at most 4 chars long\n-                let mut n = n as isize; // possibly reduce 64bit math\n+                let mut n = n as usize; // possibly reduce 64bit math\n \n                 // decode 2 more chars, if > 2 chars\n                 if n >= 100 {\n                     let d1 = (n % 100) << 1;\n                     n /= 100;\n                     curr -= 2;\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n                 }\n \n                 // decode last 1 or 2 chars\n                 if n < 10 {\n                     curr -= 1;\n-                    *buf_ptr.offset(curr) = (n as u8) + b'0';\n+                    *buf_ptr.add(curr) = (n as u8) + b'0';\n                 } else {\n                     let d1 = n << 1;\n                     curr -= 2;\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n                 }\n             }\n \n             // SAFETY: `curr` > 0 (since we made `buf` large enough), and all the chars are valid\n             // UTF-8 since `DEC_DIGITS_LUT` is\n             let buf_slice = unsafe {\n                 str::from_utf8_unchecked(\n-                    slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n+                    slice::from_raw_parts(buf_ptr.add(curr), buf.len() - curr))\n             };\n             f.pad_integral(is_nonnegative, \"\", buf_slice)\n         }\n@@ -339,18 +339,18 @@ macro_rules! impl_Exp {\n             // Since `curr` always decreases by the number of digits copied, this means\n             // that `curr >= 0`.\n             let mut buf = [MaybeUninit::<u8>::uninit(); 40];\n-            let mut curr = buf.len() as isize; //index for buf\n+            let mut curr = buf.len(); //index for buf\n             let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             // decode 2 chars at a time\n             while n >= 100 {\n-                let d1 = ((n % 100) as isize) << 1;\n+                let d1 = ((n % 100) as usize) << 1;\n                 curr -= 2;\n                 // SAFETY: `d1 <= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since\n                 // `DEC_DIGITS_LUT` has a length of 200.\n                 unsafe {\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n                 }\n                 n /= 100;\n                 exponent += 2;\n@@ -362,7 +362,7 @@ macro_rules! impl_Exp {\n                 curr -= 1;\n                 // SAFETY: Safe since `40 > curr >= 0` (see comment)\n                 unsafe {\n-                    *buf_ptr.offset(curr) = (n as u8 % 10_u8) + b'0';\n+                    *buf_ptr.add(curr) = (n as u8 % 10_u8) + b'0';\n                 }\n                 n /= 10;\n                 exponent += 1;\n@@ -372,18 +372,18 @@ macro_rules! impl_Exp {\n                 curr -= 1;\n                 // SAFETY: Safe since `40 > curr >= 0`\n                 unsafe {\n-                    *buf_ptr.offset(curr) = b'.';\n+                    *buf_ptr.add(curr) = b'.';\n                 }\n             }\n \n             // SAFETY: Safe since `40 > curr >= 0`\n             let buf_slice = unsafe {\n                 // decode last character\n                 curr -= 1;\n-                *buf_ptr.offset(curr) = (n as u8) + b'0';\n+                *buf_ptr.add(curr) = (n as u8) + b'0';\n \n                 let len = buf.len() - curr as usize;\n-                slice::from_raw_parts(buf_ptr.offset(curr), len)\n+                slice::from_raw_parts(buf_ptr.add(curr), len)\n             };\n \n             // stores 'e' (or 'E') and the up to 2-digit exponent\n@@ -392,13 +392,13 @@ macro_rules! impl_Exp {\n             // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`\n             // is contained within `exp_buf` since `len <= 3`.\n             let exp_slice = unsafe {\n-                *exp_ptr.offset(0) = if upper { b'E' } else { b'e' };\n+                *exp_ptr.add(0) = if upper { b'E' } else { b'e' };\n                 let len = if exponent < 10 {\n-                    *exp_ptr.offset(1) = (exponent as u8) + b'0';\n+                    *exp_ptr.add(1) = (exponent as u8) + b'0';\n                     2\n                 } else {\n                     let off = exponent << 1;\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(off), exp_ptr.offset(1), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(off), exp_ptr.add(1), 2);\n                     3\n                 };\n                 slice::from_raw_parts(exp_ptr, len)\n@@ -479,7 +479,7 @@ mod imp {\n impl_Exp!(i128, u128 as u128 via to_u128 named exp_u128);\n \n /// Helper function for writing a u64 into `buf` going from last to first, with `curr`.\n-fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], curr: &mut isize) {\n+fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], curr: &mut usize) {\n     let buf_ptr = MaybeUninit::slice_as_mut_ptr(buf);\n     let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n     assert!(*curr > 19);\n@@ -505,14 +505,14 @@ fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], cu\n \n             *curr -= 16;\n \n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d3 as isize), buf_ptr.offset(*curr + 4), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d4 as isize), buf_ptr.offset(*curr + 6), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d5 as isize), buf_ptr.offset(*curr + 8), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d6 as isize), buf_ptr.offset(*curr + 10), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d7 as isize), buf_ptr.offset(*curr + 12), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d8 as isize), buf_ptr.offset(*curr + 14), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d3 as usize), buf_ptr.add(*curr + 4), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d4 as usize), buf_ptr.add(*curr + 6), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d5 as usize), buf_ptr.add(*curr + 8), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d6 as usize), buf_ptr.add(*curr + 10), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d7 as usize), buf_ptr.add(*curr + 12), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d8 as usize), buf_ptr.add(*curr + 14), 2);\n         }\n         if n >= 1e8 as u64 {\n             let to_parse = n % 1e8 as u64;\n@@ -525,10 +525,10 @@ fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], cu\n             let d4 = ((to_parse / 1e0 as u64) % 100) << 1;\n             *curr -= 8;\n \n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d3 as isize), buf_ptr.offset(*curr + 4), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d4 as isize), buf_ptr.offset(*curr + 6), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d3 as usize), buf_ptr.add(*curr + 4), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d4 as usize), buf_ptr.add(*curr + 6), 2);\n         }\n         // `n` < 1e8 < (1 << 32)\n         let mut n = n as u32;\n@@ -540,8 +540,8 @@ fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], cu\n             let d2 = (to_parse % 100) << 1;\n             *curr -= 4;\n \n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add(*curr + 2), 2);\n         }\n \n         // `n` < 1e4 < (1 << 16)\n@@ -550,17 +550,17 @@ fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], cu\n             let d1 = (n % 100) << 1;\n             n /= 100;\n             *curr -= 2;\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr), 2);\n         }\n \n         // decode last 1 or 2 chars\n         if n < 10 {\n             *curr -= 1;\n-            *buf_ptr.offset(*curr) = (n as u8) + b'0';\n+            *buf_ptr.add(*curr) = (n as u8) + b'0';\n         } else {\n             let d1 = n << 1;\n             *curr -= 2;\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr), 2);\n         }\n     }\n }\n@@ -593,21 +593,21 @@ impl fmt::Display for i128 {\n fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n     // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n     let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n-    let mut curr = buf.len() as isize;\n+    let mut curr = buf.len();\n \n     let (n, rem) = udiv_1e19(n);\n     parse_u64_into(rem, &mut buf, &mut curr);\n \n     if n != 0 {\n         // 0 pad up to point\n-        let target = (buf.len() - 19) as isize;\n+        let target = buf.len() - 19;\n         // SAFETY: Guaranteed that we wrote at most 19 bytes, and there must be space\n         // remaining since it has length 39\n         unsafe {\n             ptr::write_bytes(\n-                MaybeUninit::slice_as_mut_ptr(&mut buf).offset(target),\n+                MaybeUninit::slice_as_mut_ptr(&mut buf).add(target),\n                 b'0',\n-                (curr - target) as usize,\n+                curr - target,\n             );\n         }\n         curr = target;\n@@ -616,16 +616,16 @@ fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::R\n         parse_u64_into(rem, &mut buf, &mut curr);\n         // Should this following branch be annotated with unlikely?\n         if n != 0 {\n-            let target = (buf.len() - 38) as isize;\n+            let target = buf.len() - 38;\n             // The raw `buf_ptr` pointer is only valid until `buf` is used the next time,\n             // buf `buf` is not used in this scope so we are good.\n             let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n             // SAFETY: At this point we wrote at most 38 bytes, pad up to that point,\n             // There can only be at most 1 digit remaining.\n             unsafe {\n-                ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\n+                ptr::write_bytes(buf_ptr.add(target), b'0', curr - target);\n                 curr = target - 1;\n-                *buf_ptr.offset(curr) = (n as u8) + b'0';\n+                *buf_ptr.add(curr) = (n as u8) + b'0';\n             }\n         }\n     }\n@@ -634,8 +634,8 @@ fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::R\n     // UTF-8 since `DEC_DIGITS_LUT` is\n     let buf_slice = unsafe {\n         str::from_utf8_unchecked(slice::from_raw_parts(\n-            MaybeUninit::slice_as_mut_ptr(&mut buf).offset(curr),\n-            buf.len() - curr as usize,\n+            MaybeUninit::slice_as_mut_ptr(&mut buf).add(curr),\n+            buf.len() - curr,\n         ))\n     };\n     f.pad_integral(is_nonnegative, \"\", buf_slice)"}, {"sha": "c848c2e18e9b5293a132e2c926cb8ae3e7508b8c", "filename": "library/core/src/slice/memchr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b1596c118294a62be0665b1bfb4df0fcc1026b0/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1596c118294a62be0665b1bfb4df0fcc1026b0/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs?ref=1b1596c118294a62be0665b1bfb4df0fcc1026b0", "patch": "@@ -141,8 +141,8 @@ pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n         // SAFETY: offset starts at len - suffix.len(), as long as it is greater than\n         // min_aligned_offset (prefix.len()) the remaining distance is at least 2 * chunk_bytes.\n         unsafe {\n-            let u = *(ptr.offset(offset as isize - 2 * chunk_bytes as isize) as *const Chunk);\n-            let v = *(ptr.offset(offset as isize - chunk_bytes as isize) as *const Chunk);\n+            let u = *(ptr.add(offset - 2 * chunk_bytes) as *const Chunk);\n+            let v = *(ptr.add(offset - chunk_bytes) as *const Chunk);\n \n             // Break if there is a matching byte.\n             let zu = contains_zero_byte(u ^ repeated_x);"}, {"sha": "0d934318c22a45a2db6269ddfc44907d6bc99a24", "filename": "library/std/src/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1b1596c118294a62be0665b1bfb4df0fcc1026b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1596c118294a62be0665b1bfb4df0fcc1026b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=1b1596c118294a62be0665b1bfb4df0fcc1026b0", "patch": "@@ -316,9 +316,9 @@ where\n //   | small1 | Chunk smaller than 8 bytes\n //   +--------+\n fn region_as_aligned_chunks(ptr: *const u8, len: usize) -> (usize, usize, usize) {\n-    let small0_size = if ptr as usize % 8 == 0 { 0 } else { 8 - ptr as usize % 8 };\n-    let small1_size = (len - small0_size as usize) % 8;\n-    let big_size = len - small0_size as usize - small1_size as usize;\n+    let small0_size = if ptr.is_aligned_to(8) { 0 } else { 8 - ptr.addr() % 8 };\n+    let small1_size = (len - small0_size) % 8;\n+    let big_size = len - small0_size - small1_size;\n \n     (small0_size, big_size, small1_size)\n }\n@@ -364,8 +364,8 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n                     mfence\n                     lfence\n                     \",\n-                    val = in(reg_byte) *src.offset(off as isize),\n-                    dst = in(reg) dst.offset(off as isize),\n+                    val = in(reg_byte) *src.add(off),\n+                    dst = in(reg) dst.add(off),\n                     seg_sel = in(reg) &mut seg_sel,\n                     options(nostack, att_syntax)\n                 );\n@@ -378,8 +378,8 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n     assert!(is_enclave_range(src, len));\n     assert!(is_user_range(dst, len));\n     assert!(len < isize::MAX as usize);\n-    assert!(!(src as usize).overflowing_add(len).1);\n-    assert!(!(dst as usize).overflowing_add(len).1);\n+    assert!(!src.addr().overflowing_add(len).1);\n+    assert!(!dst.addr().overflowing_add(len).1);\n \n     if len < 8 {\n         // Can't align on 8 byte boundary: copy safely byte per byte\n@@ -404,17 +404,17 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n \n         unsafe {\n             // Copy small0\n-            copy_bytewise_to_userspace(src, dst, small0_size as _);\n+            copy_bytewise_to_userspace(src, dst, small0_size);\n \n             // Copy big\n-            let big_src = src.offset(small0_size as _);\n-            let big_dst = dst.offset(small0_size as _);\n-            copy_quadwords(big_src as _, big_dst, big_size);\n+            let big_src = src.add(small0_size);\n+            let big_dst = dst.add(small0_size);\n+            copy_quadwords(big_src, big_dst, big_size);\n \n             // Copy small1\n-            let small1_src = src.offset(big_size as isize + small0_size as isize);\n-            let small1_dst = dst.offset(big_size as isize + small0_size as isize);\n-            copy_bytewise_to_userspace(small1_src, small1_dst, small1_size as _);\n+            let small1_src = src.add(big_size + small0_size);\n+            let small1_dst = dst.add(big_size + small0_size);\n+            copy_bytewise_to_userspace(small1_src, small1_dst, small1_size);\n         }\n     }\n }"}]}