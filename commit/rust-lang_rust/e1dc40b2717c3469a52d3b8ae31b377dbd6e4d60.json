{"sha": "e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZGM0MGIyNzE3YzM0NjlhNTJkM2I4YWUzMWIzNzdkYmQ2ZTRkNjA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-02T15:50:51Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-03T14:36:57Z"}, "message": "More work on translating dictionary-passing\n\nReached a point where simple uses of interfaces without bounds work.\n\nIssue #1227", "tree": {"sha": "c0d4a3941422fbbfcf80e4db53b87e854ac53b9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0d4a3941422fbbfcf80e4db53b87e854ac53b9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "html_url": "https://github.com/rust-lang/rust/commit/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45b153adfeb8e9df626bb2d48d319b8320386a58", "url": "https://api.github.com/repos/rust-lang/rust/commits/45b153adfeb8e9df626bb2d48d319b8320386a58", "html_url": "https://github.com/rust-lang/rust/commit/45b153adfeb8e9df626bb2d48d319b8320386a58"}], "stats": {"total": 549, "additions": 387, "deletions": 162}, "files": [{"sha": "b8a6ba2872937a9838403685587b57caa3d59feb", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "patch": "@@ -173,8 +173,9 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n     time(time_passes, \"const checking\",\n          bind middle::check_const::check_crate(sess, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars);\n-    let method_map = time(time_passes, \"typechecking\",\n-                          bind typeck::check_crate(ty_cx, impl_map, crate));\n+    let (method_map, dict_map) =\n+        time(time_passes, \"typechecking\",\n+             bind typeck::check_crate(ty_cx, impl_map, crate));\n     time(time_passes, \"block-use checking\",\n          bind middle::block_use::check_crate(ty_cx, crate));\n     time(time_passes, \"function usage\",\n@@ -202,7 +203,7 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n              bind trans::trans_crate(sess, crate, ty_cx,\n                                      outputs.obj_filename, exp_map, ast_map,\n                                      mut_map, copy_map, last_uses,\n-                                     method_map));\n+                                     method_map, dict_map));\n     time(time_passes, \"LLVM passes\",\n          bind link::write::run_passes(sess, llmod, outputs.obj_filename));\n "}, {"sha": "927e9879657106e103c170e9e7e7593c6c87221c", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "patch": "@@ -993,7 +993,8 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n       }\n       10 {\n         let el_ty = llvm::LLVMGetElementType(ty);\n-        ret \"[\" + type_to_str_inner(names, outer, el_ty) + \"]\";\n+        ret \"[\" + type_to_str_inner(names, outer, el_ty) + \" x \" +\n+            uint::str(llvm::LLVMGetArrayLength(ty)) + \"]\";\n       }\n       11 {\n         let i: uint = 0u;"}, {"sha": "d0f16a332a3056e89a7c50ff3becf77ea421886d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 76, "deletions": 42, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "patch": "@@ -98,9 +98,14 @@ fn type_of_fn(cx: @crate_ctxt, sp: span, is_method: bool, inputs: [ty::arg],\n \n     // Args >2: ty params, if not acquired via capture...\n     if !is_method {\n-        // FIXME[impl] Also add args for the dicts\n-        for _param in params {\n+        for bounds in params {\n             atys += [T_ptr(cx.tydesc_type)];\n+            for bound in *bounds {\n+                alt bound {\n+                  ty::bound_iface(_) { atys += [T_ptr(T_dict())]; }\n+                  _ {}\n+                }\n+            }\n         }\n     }\n     // ... then explicit args.\n@@ -905,7 +910,10 @@ fn linearize_ty_params(cx: @block_ctxt, t: ty::t) ->\n           ty::ty_param(pid, _) {\n             let seen: bool = false;\n             for d: uint in r.defs { if d == pid { seen = true; } }\n-            if !seen { r.vals += [r.cx.fcx.lltydescs[pid]]; r.defs += [pid]; }\n+            if !seen {\n+                r.vals += [r.cx.fcx.lltyparams[pid].desc];\n+                r.defs += [pid];\n+            }\n           }\n           _ { }\n         }\n@@ -1041,8 +1049,9 @@ fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt ty::type_param(bcx_tcx(cx), t) {\n       some(id) {\n-        if id < vec::len(cx.fcx.lltydescs) {\n-            ret {kind: tk_param, result: rslt(cx, cx.fcx.lltydescs[id])};\n+        if id < vec::len(cx.fcx.lltyparams) {\n+            ret {kind: tk_param,\n+                 result: rslt(cx, cx.fcx.lltyparams[id].desc)};\n         } else {\n             bcx_tcx(cx).sess.span_bug(cx.sp,\n                                       \"Unbound typaram in get_tydesc: \" +\n@@ -1205,10 +1214,7 @@ fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n         p += 1u;\n     }\n \n-    // FIXME: Implement some kind of freeze operation in the standard library.\n-    let lltydescs_frozen = [];\n-    for lltydesc: ValueRef in lltydescs { lltydescs_frozen += [lltydesc]; }\n-    fcx.lltydescs = lltydescs_frozen;\n+    fcx.lltyparams = vec::map_mut(lltydescs, {|d| {desc: d, dicts: none}});\n \n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n@@ -2558,11 +2564,13 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n     ret next_cx;\n }\n \n-type generic_info =\n-    {item_type: ty::t,\n-     static_tis: [option::t<@tydesc_info>],\n-     tydescs: [ValueRef],\n-     param_bounds: @[ty::param_bounds]};\n+type generic_info = {\n+    item_type: ty::t,\n+    static_tis: [option::t<@tydesc_info>],\n+    tydescs: [ValueRef],\n+    param_bounds: @[ty::param_bounds],\n+    origins: option::t<typeck::dict_res>\n+};\n \n tag lval_kind {\n     temporary; //< Temporary value passed by value if of immediate type\n@@ -2571,7 +2579,12 @@ tag lval_kind {\n }\n type local_var_result = {val: ValueRef, kind: lval_kind};\n type lval_result = {bcx: @block_ctxt, val: ValueRef, kind: lval_kind};\n-tag callee_env { obj_env(ValueRef); null_env; is_closure; }\n+tag callee_env {\n+    null_env;\n+    is_closure;\n+    obj_env(ValueRef);\n+    dict_env(ValueRef, ValueRef);\n+}\n type lval_maybe_callee = {bcx: @block_ctxt,\n                           val: ValueRef,\n                           kind: lval_kind,\n@@ -2630,11 +2643,11 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n             bcx = td.bcx;\n             tydescs += [td.val];\n         }\n-        let bounds = ty::lookup_item_type(ccx.tcx, fn_id).bounds;\n         gen = some({item_type: tpt.ty,\n                     static_tis: tis,\n                     tydescs: tydescs,\n-                    param_bounds: bounds});\n+                    param_bounds: tpt.bounds,\n+                    origins: ccx.dict_map.find(id)});\n     }\n     ret {bcx: bcx, val: val, kind: owned, env: null_env, generic: gen};\n }\n@@ -2843,17 +2856,6 @@ fn expr_is_lval(bcx: @block_ctxt, e: @ast::expr) -> bool {\n     ty::expr_is_lval(ccx.method_map, ccx.tcx, e)\n }\n \n-// This is for impl methods, not obj methods.\n-fn trans_method_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n-                       did: ast::def_id) -> lval_maybe_callee {\n-    let tz = [], tr = [];\n-    let basety = ty::expr_ty(bcx_tcx(bcx), base);\n-    let {bcx, val} = trans_arg_expr(bcx, {mode: ast::by_ref, ty: basety},\n-                                    type_of_or_i8(bcx, basety), tz, tr, base);\n-    let val = PointerCast(bcx, val, T_opaque_boxed_closure_ptr(bcx_ccx(bcx)));\n-    {env: obj_env(val) with lval_static_fn(bcx, did, e.id)}\n-}\n-\n fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n     alt e.node {\n       ast::expr_path(p) { ret trans_path(bcx, p, e.id); }\n@@ -2862,10 +2864,11 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n         if !expr_is_lval(bcx, e) {\n             alt bcx_ccx(bcx).method_map.find(e.id) {\n               some(typeck::method_static(did)) { // An impl method\n-                ret trans_method_callee(bcx, e, base, did);\n+                ret trans_impl::trans_static_callee(bcx, e, base, did);\n               }\n-              some(typeck::method_param(_)) {\n-                fail \"not implemented\"; // FIXME[impl]\n+              some(typeck::method_param(iid, off, p, b)) {\n+                ret trans_impl::trans_dict_callee(\n+                    bcx, e, base, iid, off, p, b);\n               }\n               none. { // An object method\n                 let of = trans_object_field(bcx, base, ident);\n@@ -2936,7 +2939,7 @@ fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n     -> (lval_kind, ValueRef) {\n     alt c.env {\n       is_closure. { (c.kind, c.val) }\n-      obj_env(_) {\n+      obj_env(_) | dict_env(_, _) {\n         fail \"Taking the value of a method does not work yet (issue #435)\";\n       }\n       null_env. {\n@@ -3149,7 +3152,23 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n     alt gen {\n       some(g) {\n         lazily_emit_all_generic_info_tydesc_glues(cx, g);\n-        lltydescs = g.tydescs;\n+        let i = 0u, n_orig = 0u;\n+        for param in *g.param_bounds {\n+            lltydescs += [g.tydescs[i]];\n+            for bound in *param {\n+                alt bound {\n+                  ty::bound_iface(_) {\n+                    let res = trans_impl::get_dict(\n+                        bcx, option::get(g.origins)[n_orig]);\n+                    lltydescs += [res.val];\n+                    bcx = res.bcx;\n+                    n_orig += 1u;\n+                  }\n+                  _ {}\n+                }\n+            }\n+            i += 1u;\n+        }\n         args = ty::ty_fn_args(tcx, g.item_type);\n         retty = ty::ty_fn_ret(tcx, g.item_type);\n       }\n@@ -3220,12 +3239,13 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     let bcx = f_res.bcx;\n \n     let faddr = f_res.val;\n-    let llenv;\n+    let llenv, dict_param = none;\n     alt f_res.env {\n       null_env. {\n         llenv = llvm::LLVMGetUndef(T_opaque_boxed_closure_ptr(bcx_ccx(cx)));\n       }\n       obj_env(e) { llenv = e; }\n+      dict_env(dict, e) { llenv = e; dict_param = some(dict); }\n       is_closure. {\n         // It's a closure. Have to fetch the elements\n         if f_res.kind == owned {\n@@ -3244,6 +3264,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n         trans_args(bcx, llenv, f_res.generic, args, fn_expr_ty, dest);\n     bcx = args_res.bcx;\n     let llargs = args_res.args;\n+    option::may(dict_param) {|dict| llargs = [dict] + llargs}\n     let llretslot = args_res.retslot;\n \n     /* If the block is terminated,\n@@ -3306,8 +3327,7 @@ fn invoke_(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef],\n     // cleanups to run\n     if bcx.unreachable { ret bcx; }\n     let normal_bcx = new_sub_block_ctxt(bcx, \"normal return\");\n-    invoker(bcx, llfn, llargs,\n-            normal_bcx.llbb,\n+    invoker(bcx, llfn, llargs, normal_bcx.llbb,\n             get_landing_pad(bcx, to_zero, to_revoke));\n     ret normal_bcx;\n }\n@@ -4351,7 +4371,7 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: span, llfndecl: ValueRef,\n           llobjfields: new_int_hash::<ValueRef>(),\n           lllocals: new_int_hash::<local_val>(),\n           llupvars: new_int_hash::<ValueRef>(),\n-          mutable lltydescs: [],\n+          mutable lltyparams: [],\n           derived_tydescs: ty::new_ty_hash(),\n           id: id,\n           ret_style: rstyle,\n@@ -4393,10 +4413,22 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n       obj_self(_) {}\n       _ {\n         for tp in ty_params {\n-            let llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n-            assert (llarg as int != 0);\n-            cx.lltydescs += [llarg];\n+            let lltydesc = llvm::LLVMGetParam(cx.llfn, arg_n), dicts = none;\n             arg_n += 1u;\n+            for bound in *fcx_tcx(cx).ty_param_bounds.get(tp.id) {\n+                alt bound {\n+                  ty::bound_iface(_) {\n+                    let dict = llvm::LLVMGetParam(cx.llfn, arg_n);\n+                    arg_n += 1u;\n+                    dicts = some(alt dicts {\n+                      none. { [dict] }\n+                      some(ds) { ds + [dict] }\n+                    });\n+                  }\n+                  _ {}\n+                }\n+            }\n+            cx.lltyparams += [{desc: lltydesc, dicts: dicts}];\n         }\n       }\n     }\n@@ -4485,7 +4517,7 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n         let lltyparam: ValueRef =\n             GEPi(bcx, obj_typarams, [0, i]);\n         lltyparam = Load(bcx, lltyparam);\n-        fcx.lltydescs += [lltyparam];\n+        fcx.lltyparams += [{desc: lltyparam, dicts: none}];\n         i += 1;\n     }\n     i = 0;\n@@ -5582,7 +5614,8 @@ fn write_abi_version(ccx: @crate_ctxt) {\n fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n                output: str, emap: resolve::exp_map, amap: ast_map::map,\n                mut_map: mut::mut_map, copy_map: alias::copy_map,\n-               last_uses: last_use::last_uses, method_map: typeck::method_map)\n+               last_uses: last_use::last_uses, method_map: typeck::method_map,\n+               dict_map: typeck::dict_map)\n     -> (ModuleRef, link::link_meta) {\n     let sha = std::sha1::mk_sha1();\n     let link_meta = link::build_link_meta(sess, *crate, output, sha);\n@@ -5659,6 +5692,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           copy_map: copy_map,\n           last_uses: last_uses,\n           method_map: method_map,\n+          dict_map: dict_map,\n           stats:\n               {mutable n_static_tydescs: 0u,\n                mutable n_derived_tydescs: 0u,"}, {"sha": "66b0c775533a43016a40b22dc5e136d49780f37b", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 80, "deletions": 36, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "patch": "@@ -82,17 +82,21 @@ tag environment_value {\n // Given a closure ty, emits a corresponding tuple ty\n fn mk_closure_ty(tcx: ty::ctxt,\n                  ck: ty::closure_kind,\n-                 n_bound_tds: uint,\n+                 ty_params: [fn_ty_param],\n                  bound_data_ty: ty::t)\n     -> ty::t {\n     let tydesc_ty = alt ck {\n       ty::closure_block. | ty::closure_shared. { ty::mk_type(tcx) }\n       ty::closure_send. { ty::mk_send_type(tcx) }\n     };\n-    ret ty::mk_tup(tcx, [\n-        tydesc_ty,\n-        ty::mk_tup(tcx, vec::init_elt(tydesc_ty, n_bound_tds)),\n-        bound_data_ty]);\n+    let param_ptrs = [];\n+    for tp in ty_params {\n+        param_ptrs += [tydesc_ty];\n+        option::may(tp.dicts) {|dicts|\n+            for dict in dicts { param_ptrs += [tydesc_ty]; }\n+        }\n+    }\n+    ty::mk_tup(tcx, [tydesc_ty, ty::mk_tup(tcx, param_ptrs), bound_data_ty])\n }\n \n fn shared_opaque_closure_box_ty(tcx: ty::ctxt) -> ty::t {\n@@ -117,7 +121,7 @@ type closure_result = {\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n fn store_environment(\n-    bcx: @block_ctxt, lltydescs: [ValueRef],\n+    bcx: @block_ctxt, lltyparams: [fn_ty_param],\n     bound_values: [environment_value],\n     ck: ty::closure_kind)\n     -> closure_result {\n@@ -162,7 +166,7 @@ fn store_environment(\n     }\n     let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n     let closure_ty =\n-        mk_closure_ty(tcx, ck, vec::len(lltydescs), bound_data_ty);\n+        mk_closure_ty(tcx, ck, lltyparams, bound_data_ty);\n \n     let temp_cleanups = [];\n \n@@ -210,7 +214,7 @@ fn store_environment(\n         // in the shape code.  Therefore, I am using\n         // tps_normal, which is what we used before.\n         //\n-        // let tps = tps_fn(vec::len(lltydescs));\n+        // let tps = tps_fn(vec::len(lltyparams));\n \n         let tps = tps_normal;\n         let {result:closure_td, _} =\n@@ -232,10 +236,19 @@ fn store_environment(\n     let {bcx:bcx, val:ty_params_slot} =\n         GEP_tup_like_1(bcx, closure_ty, closure,\n                        [0, abi::closure_elt_ty_params]);\n-    vec::iteri(lltydescs) { |i, td|\n-        let ty_param_slot = GEPi(bcx, ty_params_slot, [0, i as int]);\n-        let cloned_td = maybe_clone_tydesc(bcx, ck, td);\n-        Store(bcx, cloned_td, ty_param_slot);\n+    let off = 0;\n+\n+    for tp in lltyparams {\n+        let cloned_td = maybe_clone_tydesc(bcx, ck, tp.desc);\n+        Store(bcx, cloned_td, GEPi(bcx, ty_params_slot, [0, off]));\n+        off += 1;\n+        option::may(tp.dicts, {|dicts|\n+            for dict in dicts {\n+                let cast = PointerCast(bcx, dict, val_ty(cloned_td));\n+                Store(bcx, cast, GEPi(bcx, ty_params_slot, [0, off]));\n+                off += 1;\n+            }\n+        });\n     }\n \n     // Copy expr values into boxed bindings.\n@@ -316,7 +329,7 @@ fn build_closure(bcx0: @block_ctxt,\n           }\n         }\n     }\n-    ret store_environment(bcx, copy bcx.fcx.lltydescs, env_vals, ck);\n+    ret store_environment(bcx, copy bcx.fcx.lltyparams, env_vals, ck);\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n@@ -338,13 +351,23 @@ fn load_environment(enclosing_cx: @block_ctxt,\n     // Populate the type parameters from the environment. We need to\n     // do this first because the tydescs are needed to index into\n     // the bindings if they are dynamically sized.\n-    let tydesc_count = vec::len(enclosing_cx.fcx.lltydescs);\n     let lltydescs = GEPi(bcx, llclosure,\n                          [0, abi::box_rc_field_body,\n                           abi::closure_elt_ty_params]);\n-    uint::range(0u, tydesc_count) { |i|\n-        let lltydescptr = GEPi(bcx, lltydescs, [0, i as int]);\n-        fcx.lltydescs += [Load(bcx, lltydescptr)];\n+    let off = 0;\n+    for tp in copy enclosing_cx.fcx.lltyparams {\n+        let tydesc = Load(bcx, GEPi(bcx, lltydescs, [0, off]));\n+        off += 1;\n+        let dicts = option::map(tp.dicts, {|dicts|\n+            let rslt = [];\n+            for dict in dicts {\n+                let dict = Load(bcx, GEPi(bcx, lltydescs, [0, off]));\n+                rslt += [PointerCast(bcx, dict, T_ptr(T_dict()))];\n+                off += 1;\n+            }\n+            rslt\n+        });\n+        fcx.lltyparams += [{desc: tydesc, dicts: dicts}];\n     }\n \n     // Populate the upvars from the environment.\n@@ -439,13 +462,22 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     let (outgoing_fty_real, lltydescs, param_bounds) = alt f_res.generic {\n       none. { (outgoing_fty, [], @[]) }\n       some(ginfo) {\n+        for bounds in *ginfo.param_bounds {\n+            for bound in *bounds {\n+                alt bound {\n+                  ty::bound_iface(_) {\n+                    fail \"FIXME[impl] binding bounded types not implemented\";\n+                  }\n+                  _ {}\n+                }\n+            }\n+        }\n         lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n         (ginfo.item_type, ginfo.tydescs, ginfo.param_bounds)\n       }\n     };\n \n-    let ty_param_count = vec::len(lltydescs);\n-    if vec::len(bound) == 0u && ty_param_count == 0u {\n+    if vec::len(bound) == 0u && vec::len(lltydescs) == 0u {\n         // Trivial 'binding': just return the closure\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n         bcx = lv.bcx;\n@@ -477,7 +509,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n \n     // Actually construct the closure\n     let {llbox, box_ty, bcx} = store_environment(\n-        bcx, lltydescs,\n+        bcx, vec::map(lltydescs, {|d| {desc: d, dicts: none}}),\n         env_vals + vec::map(bound, {|x| env_expr(x)}),\n         ty::closure_shared);\n \n@@ -603,7 +635,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     // our bound tydescs, we need to load tydescs out of the environment\n     // before derived tydescs are constructed. To do this, we load them\n     // in the load_env block.\n-    let load_env_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n+    let l_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n \n     // The 'llenv' that will arrive in the thunk we're creating is an\n     // environment that will contain the values of its arguments and a pointer\n@@ -613,7 +645,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     // 'boxed_closure_ty', which was determined by trans_bind.\n     check (type_has_static_size(ccx, boxed_closure_ty));\n     let llclosure_ptr_ty = type_of(ccx, sp, boxed_closure_ty);\n-    let llclosure = PointerCast(load_env_bcx, fcx.llenv, llclosure_ptr_ty);\n+    let llclosure = PointerCast(l_bcx, fcx.llenv, llclosure_ptr_ty);\n \n     // \"target\", in this context, means the function that's having some of its\n     // arguments bound and that will be called inside the thunk we're\n@@ -664,20 +696,32 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let llargs: [ValueRef] = [llretptr, lltargetenv];\n \n     // Copy in the type parameters.\n-    // FIXME[impl] This will also have to copy the dicts\n-    let i = 0u, ty_param_count = vec::len(param_bounds);\n-    while i < ty_param_count {\n-        // Silly check\n-        check type_is_tup_like(load_env_bcx, boxed_closure_ty);\n-        let lltyparam_ptr =\n-            GEP_tup_like(load_env_bcx, boxed_closure_ty, llclosure,\n-                         [0, abi::box_rc_field_body,\n-                          abi::closure_elt_ty_params, i as int]);\n-        load_env_bcx = lltyparam_ptr.bcx;\n-        let td = Load(load_env_bcx, lltyparam_ptr.val);\n-        llargs += [td];\n-        fcx.lltydescs += [td];\n-        i += 1u;\n+    check type_is_tup_like(l_bcx, boxed_closure_ty);\n+    let {bcx: l_bcx, val: param_record} =\n+        GEP_tup_like(l_bcx, boxed_closure_ty, llclosure,\n+                     [0, abi::box_rc_field_body, abi::closure_elt_ty_params]);\n+    let off = 0;\n+    for param in param_bounds {\n+        let dsc = Load(l_bcx, GEPi(l_bcx, param_record, [0, off])),\n+            dicts = none;\n+        llargs += [dsc];\n+        off += 1;\n+        for bound in *param {\n+            alt bound {\n+              ty::bound_iface(_) {\n+                let dict = Load(l_bcx, GEPi(l_bcx, param_record, [0, off]));\n+                dict = PointerCast(l_bcx, dict, T_ptr(T_dict()));\n+                llargs += [dict];\n+                off += 1;\n+                dicts = some(alt dicts {\n+                  none. { [dict] }\n+                  some(ds) { ds + [dict] }\n+                });\n+              }\n+              _ {}\n+            }\n+        }\n+        fcx.lltyparams += [{desc: dsc, dicts: dicts}];\n     }\n \n     let a: uint = 2u; // retptr, env come first"}, {"sha": "fa0810fcf912ce3f8f64dcddcc8149d445a1ed2f", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "patch": "@@ -104,6 +104,7 @@ type crate_ctxt =\n      copy_map: alias::copy_map,\n      last_uses: last_use::last_uses,\n      method_map: typeck::method_map,\n+     dict_map: typeck::dict_map,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n      rust_object_type: TypeRef,\n@@ -130,6 +131,8 @@ type val_self_pair = {v: ValueRef, t: ty::t};\n \n tag local_val { local_mem(ValueRef); local_imm(ValueRef); }\n \n+type fn_ty_param = {desc: ValueRef, dicts: option::t<[ValueRef]>};\n+\n // Function context.  Every LLVM function we create will have one of\n // these.\n type fn_ctxt =\n@@ -235,7 +238,7 @@ type fn_ctxt =\n      llobjfields: hashmap<ast::node_id, ValueRef>,\n      lllocals: hashmap<ast::node_id, local_val>,\n      llupvars: hashmap<ast::node_id, ValueRef>,\n-     mutable lltydescs: [ValueRef],\n+     mutable lltyparams: [fn_ty_param],\n      derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n      id: ast::node_id,\n      ret_style: ast::ret_style,\n@@ -532,11 +535,9 @@ fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n     ret T_int(targ_cfg);\n }\n \n-fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef {\n-    unsafe {\n-        ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n-                                   vec::len::<TypeRef>(inputs), False);\n-    }\n+fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef unsafe {\n+    ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n+                               vec::len::<TypeRef>(inputs), False);\n }\n \n fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n@@ -545,10 +546,8 @@ fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n \n fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n \n-fn T_struct(elts: [TypeRef]) -> TypeRef {\n-    unsafe {\n-        ret llvm::LLVMStructType(to_ptr(elts), vec::len(elts), False);\n-    }\n+fn T_struct(elts: [TypeRef]) -> TypeRef unsafe {\n+    ret llvm::LLVMStructType(to_ptr(elts), vec::len(elts), False);\n }\n \n fn T_named_struct(name: str) -> TypeRef {\n@@ -573,6 +572,12 @@ fn T_rust_object() -> TypeRef {\n     ret t;\n }\n \n+// A dict is, in reality, a vtable pointer followed by zero or more pointers\n+// to tydescs and other dicts that it closes over. But the types and number of\n+// those are rarely known to the code that needs to manipulate them, so they\n+// are described by this opaque type.\n+fn T_dict() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n+\n fn T_task(targ_cfg: @session::config) -> TypeRef {\n     let t = T_named_struct(\"task\");\n "}, {"sha": "aab8aaf10fad946d5f254762957442d2928c7bb6", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 92, "deletions": 11, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "patch": "@@ -22,6 +22,40 @@ fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n     }\n }\n \n+fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n+    let tz = [], tr = [];\n+    let basety = ty::expr_ty(bcx_tcx(bcx), base);\n+    let {bcx, val} = trans_arg_expr(bcx, {mode: ast::by_ref, ty: basety},\n+                                    T_ptr(type_of_or_i8(bcx, basety)), tz,\n+                                    tr, base);\n+    rslt(bcx, PointerCast(bcx, val, T_opaque_boxed_closure_ptr(bcx_ccx(bcx))))\n+}\n+\n+fn trans_static_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n+                       did: ast::def_id) -> lval_maybe_callee {\n+    let {bcx, val} = trans_self_arg(bcx, base);\n+    {env: obj_env(val) with lval_static_fn(bcx, did, e.id)}\n+}\n+\n+fn trans_dict_callee(bcx: @block_ctxt, _e: @ast::expr, base: @ast::expr,\n+                     iface_id: ast::def_id, n_method: uint,\n+                     n_param: uint, n_bound: uint) -> lval_maybe_callee {\n+    let {bcx, val} = trans_self_arg(bcx, base);\n+    let dict = option::get(bcx.fcx.lltyparams[n_param].dicts)[n_bound];\n+    let method = ty::iface_methods(bcx_tcx(bcx), iface_id)[n_method];\n+    let bare_fn_ty = type_of_fn(bcx_ccx(bcx), ast_util::dummy_sp(),\n+                                false, method.fty.inputs, method.fty.output,\n+                                *method.tps);\n+    let {inputs: bare_inputs, output} = llfn_arg_tys(bare_fn_ty);\n+    let fn_ty = T_fn([val_ty(dict)] + bare_inputs, output);\n+    let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),\n+                             T_ptr(T_array(T_ptr(fn_ty), n_method + 1u)));\n+    let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n+    {bcx: bcx, val: mptr, kind: owned,\n+     env: dict_env(dict, val),\n+     generic: none} // FIXME[impl] fetch generic info for method\n+}\n+\n fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n     let out_ty = llvm::llvm::LLVMGetReturnType(ft);\n     let n_args = llvm::llvm::LLVMCountParamTypes(ft);\n@@ -35,12 +69,21 @@ fn trans_wrapper(ccx: @crate_ctxt, pt: [ast::ident],\n     let real_fn = ccx.item_ids.get(m.id);\n     let {inputs: real_args, output: real_ret} =\n         llfn_arg_tys(llvm::llvm::LLVMGetElementType(val_ty(real_fn)));\n-    let env_ty = T_ptr(T_struct([T_ptr(T_i8())] +\n-                                vec::map(extra_tps,\n-                                         {|_p| T_ptr(ccx.tydesc_type)})));\n-    // FIXME[impl] filter and pass along dicts for bounds\n-    let wrap_args = [env_ty] + vec::slice(real_args, 0u, 2u) +\n-        vec::slice(real_args, 2u + vec::len(extra_tps), vec::len(real_args));\n+    let extra_ptrs = [];\n+    for tp in extra_tps {\n+        extra_ptrs += [T_ptr(ccx.tydesc_type)];\n+        for bound in *tp {\n+            alt bound {\n+              ty::bound_iface(_) { extra_ptrs += [T_ptr(T_dict())]; }\n+              _ {}\n+            }\n+        }\n+    }\n+    let env_ty = T_ptr(T_struct([T_ptr(T_i8())] + extra_ptrs));\n+    let n_extra_ptrs = vec::len(extra_ptrs);\n+\n+    let wrap_args = [T_ptr(T_dict())] + vec::slice(real_args, 0u, 2u) +\n+        vec::slice(real_args, 2u + vec::len(extra_ptrs), vec::len(real_args));\n     let llfn_ty = T_fn(wrap_args, real_ret);\n \n     let lcx = @{path: pt + [\"wrapper\", m.ident], module_path: [],\n@@ -50,13 +93,13 @@ fn trans_wrapper(ccx: @crate_ctxt, pt: [ast::ident],\n     let fcx = new_fn_ctxt(lcx, ast_util::dummy_sp(), llfn);\n     let bcx = new_top_block_ctxt(fcx), lltop = bcx.llbb;\n \n-    let dict = LLVMGetParam(llfn, 0u);\n+    let dict = PointerCast(bcx, LLVMGetParam(llfn, 0u), env_ty);\n     // retptr, self\n-    let args = [LLVMGetParam(llfn, 1u), LLVMGetParam(llfn, 2u)], i = 1;\n+    let args = [LLVMGetParam(llfn, 1u), LLVMGetParam(llfn, 2u)], i = 0u;\n     // saved tydescs/dicts\n-    for extra_tp in extra_tps {\n-        args += [load_inbounds(bcx, dict, [0, i])];\n-        i += 1;\n+    while i < n_extra_ptrs {\n+        i += 1u;\n+        args += [load_inbounds(bcx, dict, [0, i as int])];\n     }\n     // the rest of the parameters\n     let i = 3u, params_total = llvm::llvm::LLVMCountParamTypes(llfn_ty);\n@@ -65,7 +108,45 @@ fn trans_wrapper(ccx: @crate_ctxt, pt: [ast::ident],\n         i += 1u;\n     }\n     Call(bcx, ccx.item_ids.get(m.id), args);\n+    build_return(bcx);\n     finish_fn(fcx, lltop);\n     ret llfn;\n }\n \n+// FIXME[impl] cache these on the function level somehow\n+fn get_dict(bcx: @block_ctxt, origin: typeck::dict_origin) -> result {\n+    let bcx = bcx, ccx = bcx_ccx(bcx);\n+    alt origin {\n+      typeck::dict_static(impl_did, tys, sub_origins) {\n+        assert impl_did.crate == ast::local_crate; // FIXME[impl]\n+        let vtable = ccx.item_ids.get(impl_did.node);\n+        let impl_params = ty::lookup_item_type(ccx.tcx, impl_did).bounds;\n+        let ptrs = [vtable], i = 0u, origin = 0u, ti = none;\n+        for param in *impl_params {\n+            let rslt = get_tydesc(bcx, tys[i], false, tps_normal, ti).result;\n+            ptrs += [rslt.val];\n+            bcx = rslt.bcx;\n+            for bound in *param {\n+                alt bound {\n+                  ty::bound_iface(_) {\n+                    let res = get_dict(bcx, sub_origins[origin]);\n+                    ptrs += [res.val];\n+                    bcx = res.bcx;\n+                    origin += 1u;\n+                  }\n+                  _ {}\n+                }\n+            }\n+            i += 1u;\n+        }\n+        let pty = T_ptr(T_i8()), dict_ty = T_array(pty, vec::len(ptrs));\n+        let dict = alloca(bcx, dict_ty), i = 0;\n+        for ptr in ptrs {\n+            Store(bcx, PointerCast(bcx, ptr, pty), GEPi(bcx, dict, [0, i]));\n+            i += 1;\n+        }\n+        rslt(bcx, PointerCast(bcx, dict, T_ptr(T_dict())))\n+      }\n+      typeck::dict_param(_param) { fail \"FIXME[impl]\"; }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "913cca74192aa72c01690983951b406093c18eb0", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "patch": "@@ -158,7 +158,7 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n         let typarams_ty: ty::t = ty::mk_tup(ccx.tcx, tps);\n         let i: int = 0;\n         for tp: ast::ty_param in ty_params {\n-            let typaram = bcx.fcx.lltydescs[i];\n+            let typaram = bcx.fcx.lltyparams[i].desc;\n             // Silly check\n             check type_is_tup_like(bcx, typarams_ty);\n             let capture ="}, {"sha": "27d945591390d9eb92b188013ba0df74df2d0ef0", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 117, "deletions": 58, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "patch": "@@ -19,10 +19,12 @@ import option::{none, some};\n import syntax::print::pprust::*;\n \n export check_crate, method_map, method_origin, method_static, method_param;\n+export dict_map, dict_res, dict_origin, dict_static, dict_param;\n \n tag method_origin {\n     method_static(ast::def_id);\n-    method_param(uint);\n+    // iface id, method num, param num, bound num\n+    method_param(ast::def_id, uint, uint, uint);\n }\n type method_map = hashmap<ast::node_id, method_origin>;\n \n@@ -694,14 +696,15 @@ mod collect {\n             get_tag_variant_types(cx, tpt.ty, variants, ty_params);\n           }\n           ast::item_impl(tps, _, selfty, ms) {\n-            ty_param_bounds(cx.tcx, m_collect, tps);\n+            let i_bounds = ty_param_bounds(cx.tcx, m_collect, tps);\n             for m in ms {\n                 let bounds = ty_param_bounds(cx.tcx, m_collect, m.tps);\n                 let ty = ty::mk_fn(cx.tcx,\n                                    ty_of_fn_decl(cx.tcx, m_collect,\n                                                  ast::proto_bare, m.decl));\n-                cx.tcx.tcache.insert(local_def(m.id), {bounds: bounds,\n-                                                       ty: ty});\n+                cx.tcx.tcache.insert(local_def(m.id),\n+                                     {bounds: @(*i_bounds + *bounds),\n+                                      ty: ty});\n                 write::ty_only(cx.tcx, m.id, ty);\n             }\n             write::ty_only(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n@@ -1493,26 +1496,29 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n     // First, see whether this is an interface-bounded parameter\n     alt ty::struct(tcx, ty) {\n       ty::ty_param(n, did) {\n+        let bound_n = 0u;\n         for bound in *tcx.ty_param_bounds.get(did.node) {\n             alt bound {\n               ty::bound_iface(t) {\n                 let (iid, _tps) = alt ty::struct(tcx, t) {\n                     ty::ty_iface(i, tps) { (i, tps) }\n                     _ { ret none; }\n                 };\n-                alt vec::find(*ty::iface_methods(tcx, iid),\n-                              {|m| m.ident == name}) {\n-                  some(m) {\n+                let ifce_methods = ty::iface_methods(tcx, iid);\n+                alt vec::position_pred(*ifce_methods, {|m| m.ident == name}) {\n+                  some(pos) {\n+                    let m = ifce_methods[pos];\n                     ret some({method_ty: ty::mk_fn(tcx, m.fty),\n                               n_tps: vec::len(*m.tps),\n                               ids: [], // FIXME[impl]\n-                              origin: method_param(n)});\n+                              origin: method_param(iid, pos, n, bound_n)});\n                   }\n                   _ {}\n                 }\n               }\n               _ {}\n             }\n+            bound_n += 1u;\n         }\n         ret none;\n       }\n@@ -2742,7 +2748,8 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         vec::pop(ccx.self_infos);\n         alt ifce {\n           some(ty) {\n-            alt ty::struct(ccx.tcx, ast_ty_to_ty(ccx.tcx, m_check, ty)) {\n+            let iface_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n+            alt ty::struct(ccx.tcx, iface_ty) {\n               ty::ty_iface(did, tys) {\n                 for if_m in *ty::iface_methods(ccx.tcx, did) {\n                     alt vec::find(my_methods, {|m| if_m.ident == m.ident}) {\n@@ -2759,6 +2766,9 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                       }\n                     }\n                 }\n+                let tpt = {bounds: ty_param_bounds(ccx.tcx, m_check, tps),\n+                           ty: iface_ty};\n+                ccx.tcx.tcache.insert(local_def(it.id), tpt);\n               }\n               _ {\n                 ccx.tcx.sess.span_err(ty.span, \"can only implement interface \\\n@@ -2854,12 +2864,22 @@ fn check_for_main_fn(tcx: ty::ctxt, crate: @ast::crate) {\n     }\n }\n \n+// Resolutions for bounds of all parameters, left to right, for a given path.\n+type dict_res = @[dict_origin];\n+tag dict_origin {\n+    dict_static(ast::def_id, [ty::t], dict_res);\n+    dict_param(uint);\n+}\n+type dict_map = hashmap<ast::node_id, dict_res>;\n+\n // Detect points where an interface-bounded type parameter is instantiated,\n // resolve the impls for the parameters.\n-fn resolve_vtables(tcx: ty::ctxt, impl_map: resolve::impl_map,\n-                   crate: @ast::crate) {\n-    type ccx = {tcx: ty::ctxt, impl_map: resolve::impl_map};\n-    let cx = {tcx: tcx, impl_map: impl_map};\n+fn resolve_dicts(tcx: ty::ctxt, impl_map: resolve::impl_map,\n+                   crate: @ast::crate) -> dict_map {\n+    type ccx = {tcx: ty::ctxt,\n+                impl_map: resolve::impl_map,\n+                dict_map: dict_map};\n+    let cx = {tcx: tcx, impl_map: impl_map, dict_map: new_int_hash()};\n     fn resolve_expr(ex: @ast::expr, cx: ccx, v: visit::vt<ccx>) {\n         alt ex.node {\n           ast::expr_path(_) {\n@@ -2868,18 +2888,15 @@ fn resolve_vtables(tcx: ty::ctxt, impl_map: resolve::impl_map,\n             alt substs.substs {\n               some(ts) {\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n-                let item_ty = ty::lookup_item_type(cx.tcx, did), i = 0u;\n-                for s_ty in ts {\n-                    for bound in *item_ty.bounds[i] {\n-                        alt bound {\n-                          ty::bound_iface(i_ty) {\n-                            let impls = cx.impl_map.get(ex.id);\n-                            lookup_impl(cx, impls, ex.span, s_ty, i_ty);\n-                          }\n-                          _ {}\n-                        }\n-                    }\n-                    i += 1u;\n+                let item_ty = ty::lookup_item_type(cx.tcx, did);\n+                if vec::any(*item_ty.bounds, {|bs|\n+                    vec::any(*bs, {|b|\n+                        alt b { ty::bound_iface(_) { true } _ { false } }\n+                    })\n+                }) {\n+                    let impls = cx.impl_map.get(ex.id);\n+                    cx.dict_map.insert(ex.id, lookup_dicts(\n+                        cx.tcx, impls, ex.span, *item_ty.bounds, ts));\n                 }\n               }\n               _ {}\n@@ -2889,52 +2906,94 @@ fn resolve_vtables(tcx: ty::ctxt, impl_map: resolve::impl_map,\n         }\n         visit::visit_expr(ex, cx, v);\n     }\n-    fn lookup_impl(cx: ccx, isc: resolve::iscopes, sp: span,\n-                   sub_ty: ty::t, iface_ty: ty::t) {\n-        let iface_id = alt ty::struct(cx.tcx, iface_ty) {\n+    fn lookup_dicts(tcx: ty::ctxt, isc: resolve::iscopes, sp: span,\n+                      bounds: [ty::param_bounds], tys: [ty::t])\n+        -> dict_res {\n+        let result = [], i = 0u;\n+        for ty in tys {\n+            for bound in *bounds[i] {\n+                alt bound {\n+                  ty::bound_iface(i_ty) {\n+                    result += [lookup_dict(tcx, isc, sp, ty, i_ty)];\n+                  }\n+                  _ {}\n+                }\n+            }\n+            i += 1u;\n+        }\n+        @result\n+    }\n+    fn lookup_dict(tcx: ty::ctxt, isc: resolve::iscopes, sp: span,\n+                     ty: ty::t, iface_ty: ty::t) -> dict_origin {\n+        let iface_id = alt ty::struct(tcx, iface_ty) {\n             ty::ty_iface(did, _) { did }\n-            _ { ret; }\n+            _ { tcx.sess.abort_if_errors(); fail; }\n         };\n-        // FIXME check against bounded param types\n-        let found = false;\n-        std::list::iter(isc) {|impls|\n-            if found { ret; }\n-            for im in *impls {\n-                if im.iface_did == some(iface_id) {\n-                    let self_ty = impl_self_ty(cx.tcx, im.did).ty;\n-                    let params = @mutable [mutable];\n-                    alt ty::unify::unify(sub_ty, self_ty,\n-                                         ty::unify::bind_params(params),\n-                                         cx.tcx) {\n-                      ures_ok(_) {\n-                        if found {\n-                            cx.tcx.sess.span_err(\n-                                sp, \"multiple applicable implementations in \\\n-                                     scope\");\n-                        } else {\n-                            found = true;\n-                        }\n+        alt ty::struct(tcx, ty) {\n+          ty::ty_param(n, did) {\n+            for bound in *tcx.ty_param_bounds.get(did.node) {\n+                alt bound {\n+                  ty::bound_iface(ity) {\n+                    alt ty::struct(tcx, ity) {\n+                      ty::ty_iface(idid, _) {\n+                        if did == idid { ret dict_param(n); }\n                       }\n-                      _ {}\n                     }\n+                  }\n+                  _ {}\n                 }\n             }\n+          }\n+          _ {\n+            let found = none;\n+            std::list::iter(isc) {|impls|\n+                if option::is_some(found) { ret; }\n+                for im in *impls {\n+                    if im.iface_did == some(iface_id) {\n+                        let self_ty = impl_self_ty(tcx, im.did).ty;\n+                        let params = @mutable [mutable];\n+                        alt ty::unify::unify(ty, self_ty,\n+                                             ty::unify::bind_params(params),\n+                                             tcx) {\n+                          ures_ok(_) {\n+                            if option::is_some(found) {\n+                                tcx.sess.span_err(\n+                                    sp, \"multiple applicable implementations \\\n+                                         in scope\");\n+                            } else {\n+                                let params = vec::map_mut(\n+                                    *params, {|p| option::get(p)});\n+                                // FIXME[impl] check for sub-bounds\n+                                found = some(dict_static(\n+                                    im.did, params, @[]));\n+                            }\n+                          }\n+                          _ {}\n+                        }\n+                    }\n+                }\n+            }\n+            alt found {\n+              some(rslt) { ret rslt; }\n+              _ {}\n+            }\n+          }\n         }\n-        if !found {\n-            cx.tcx.sess.span_err(\n-                sp, \"failed to find an implementation of interface \" +\n-                ty_to_str(cx.tcx, iface_ty) + \" for \" +\n-                ty_to_str(cx.tcx, sub_ty));\n-        }\n+\n+        tcx.sess.span_fatal(\n+            sp, \"failed to find an implementation of interface \" +\n+            ty_to_str(tcx, iface_ty) + \" for \" +\n+            ty_to_str(tcx, ty));\n     }\n     visit::visit_crate(*crate, cx, visit::mk_vt(@{\n         visit_expr: resolve_expr\n         with *visit::default_visitor()\n     }));\n+    cx.dict_map\n }\n \n fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n-               crate: @ast::crate) -> method_map {\n+               crate: @ast::crate) -> (method_map, dict_map) {\n     collect::collect_item_types(tcx, crate);\n \n     let ccx = @{mutable self_infos: [],\n@@ -2947,10 +3006,10 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                                        bind check_native_item(ccx, _)\n                                    with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visit);\n-    resolve_vtables(tcx, impl_map, crate);\n+    let dict_map = resolve_dicts(tcx, impl_map, crate);\n     check_for_main_fn(tcx, crate);\n     tcx.sess.abort_if_errors();\n-    ccx.method_map\n+    (ccx.method_map, dict_map)\n }\n //\n // Local Variables:"}]}