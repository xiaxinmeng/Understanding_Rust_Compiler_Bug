{"sha": "8dad7f579e029fd883d64848f4abb12630dcc3e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYWQ3ZjU3OWUwMjlmZDg4M2Q2NDg0OGY0YWJiMTI2MzBkY2MzZTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-24T03:17:27Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-25T08:18:37Z"}, "message": "rustdoc: Get [src] links working for inlined dox\n\nThese links work by hyperlinking back to the actual documentation page with a\nquery parameter which will be recognized and then auto-click the appropriate\n[src] link.", "tree": {"sha": "fe14ce6ab9aa198a387914d5fc8742d0e9261154", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe14ce6ab9aa198a387914d5fc8742d0e9261154"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dad7f579e029fd883d64848f4abb12630dcc3e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dad7f579e029fd883d64848f4abb12630dcc3e6", "html_url": "https://github.com/rust-lang/rust/commit/8dad7f579e029fd883d64848f4abb12630dcc3e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dad7f579e029fd883d64848f4abb12630dcc3e6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f13db2cb2edfd626006bd86e01351a8b1c23401", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f13db2cb2edfd626006bd86e01351a8b1c23401", "html_url": "https://github.com/rust-lang/rust/commit/9f13db2cb2edfd626006bd86e01351a8b1c23401"}], "stats": {"total": 128, "additions": 96, "deletions": 32}, "files": [{"sha": "ab953419a41719a780bb221eed3edcfb2f6cf743", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8dad7f579e029fd883d64848f4abb12630dcc3e6/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dad7f579e029fd883d64848f4abb12630dcc3e6/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=8dad7f579e029fd883d64848f4abb12630dcc3e6", "patch": "@@ -1575,28 +1575,40 @@ fn try_inline(id: ast::NodeId) -> Option<Vec<Item>> {\n     };\n     let did = ast_util::def_id_of_def(def);\n     if ast_util::is_local(did) { return None }\n-    try_inline_def(tcx, def)\n+    try_inline_def(&**cx, tcx, def)\n }\n \n-fn try_inline_def(tcx: &ty::ctxt, def: ast::Def) -> Option<Vec<Item>> {\n+fn try_inline_def(cx: &core::DocContext,\n+                  tcx: &ty::ctxt,\n+                  def: ast::Def) -> Option<Vec<Item>> {\n     let mut ret = Vec::new();\n     let did = ast_util::def_id_of_def(def);\n     let inner = match def {\n-        ast::DefTrait(did) => TraitItem(build_external_trait(tcx, did)),\n-        ast::DefFn(did, style) =>\n-            FunctionItem(build_external_function(tcx, did, style)),\n+        ast::DefTrait(did) => {\n+            record_extern_fqn(cx, did, TypeTrait);\n+            TraitItem(build_external_trait(tcx, did))\n+        }\n+        ast::DefFn(did, style) => {\n+            record_extern_fqn(cx, did, TypeFunction);\n+            FunctionItem(build_external_function(tcx, did, style))\n+        }\n         ast::DefStruct(did) => {\n+            record_extern_fqn(cx, did, TypeStruct);\n             ret.extend(build_impls(tcx, did).move_iter());\n             StructItem(build_struct(tcx, did))\n         }\n         ast::DefTy(did) => {\n+            record_extern_fqn(cx, did, TypeEnum);\n             ret.extend(build_impls(tcx, did).move_iter());\n             build_type(tcx, did)\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n         ast::DefVariant(..) => return Some(Vec::new()),\n-        ast::DefMod(did) => ModuleItem(build_module(tcx, did)),\n+        ast::DefMod(did) => {\n+            record_extern_fqn(cx, did, TypeModule);\n+            ModuleItem(build_module(cx, tcx, did))\n+        }\n         _ => return None,\n     };\n     let fqn = csearch::get_item_path(tcx, did);\n@@ -1838,10 +1850,7 @@ fn register_def(cx: &core::DocContext, def: ast::Def) -> ast::DefId {\n         core::Typed(ref t) => t,\n         core::NotTyped(_) => return did\n     };\n-    let fqn = csearch::get_item_path(tcx, did);\n-    let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf()).collect();\n-    debug!(\"recording {} => {}\", did, fqn);\n-    cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n+    record_extern_fqn(cx, did, kind);\n     match kind {\n         TypeTrait => {\n             let t = build_external_trait(tcx, did);\n@@ -1852,6 +1861,19 @@ fn register_def(cx: &core::DocContext, def: ast::Def) -> ast::DefId {\n     return did;\n }\n \n+fn record_extern_fqn(cx: &core::DocContext,\n+                     did: ast::DefId,\n+                     kind: TypeKind) {\n+    match cx.maybe_typed {\n+        core::Typed(ref tcx) => {\n+            let fqn = csearch::get_item_path(tcx, did);\n+            let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf()).collect();\n+            cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n+        }\n+        core::NotTyped(..) => {}\n+    }\n+}\n+\n fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> Trait {\n     let def = ty::lookup_trait_def(tcx, did);\n     let methods = ty::trait_methods(tcx, did);\n@@ -2000,13 +2022,14 @@ fn build_impl(tcx: &ty::ctxt, did: ast::DefId) -> Item {\n     }\n }\n \n-fn build_module(tcx: &ty::ctxt, did: ast::DefId) -> Module {\n+fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n+                did: ast::DefId) -> Module {\n     let mut items = Vec::new();\n \n     csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, _| {\n         match def {\n             decoder::DlDef(def) => {\n-                match try_inline_def(tcx, def) {\n+                match try_inline_def(cx, tcx, def) {\n                     Some(i) => items.extend(i.move_iter()),\n                     None => {}\n                 }"}, {"sha": "ce7f230ea53f0022484ed9797d03811e8ec163a7", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 51, "deletions": 20, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8dad7f579e029fd883d64848f4abb12630dcc3e6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dad7f579e029fd883d64848f4abb12630dcc3e6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8dad7f579e029fd883d64848f4abb12630dcc3e6", "patch": "@@ -141,6 +141,10 @@ pub struct Cache {\n     /// necessary.\n     pub paths: HashMap<ast::DefId, (Vec<String>, ItemType)>,\n \n+    /// Similar to `paths`, but only holds external paths. This is only used for\n+    /// generating explicit hyperlinks to other crates.\n+    pub external_paths: HashMap<ast::DefId, Vec<StrBuf>>,\n+\n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n@@ -249,7 +253,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     let analysis = ::analysiskey.get();\n     let public_items = analysis.as_ref().map(|a| a.public_items.clone());\n     let public_items = public_items.unwrap_or(NodeSet::new());\n-    let paths = analysis.as_ref().map(|a| {\n+    let paths: HashMap<ast::DefId, (Vec<StrBuf>, ItemType)> =\n+      analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take_unwrap();\n         paths.move_iter().map(|(k, (v, t))| {\n             (k, (v, match t {\n@@ -265,6 +270,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     }).unwrap_or(HashMap::new());\n     let mut cache = Cache {\n         impls: HashMap::new(),\n+        external_paths: paths.iter().map(|(&k, &(ref v, _))| (k, v.clone()))\n+                             .collect(),\n         paths: paths,\n         implementors: HashMap::new(),\n         stack: Vec::new(),\n@@ -496,13 +503,15 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n             seen: HashSet::new(),\n             cx: &mut cx,\n         };\n+        // skip all invalid spans\n+        folder.seen.insert(\"\".to_strbuf());\n         krate = folder.fold_crate(krate);\n     }\n \n     for &(n, ref e) in krate.externs.iter() {\n         cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n         let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n-        cache.paths.insert(did, (Vec::new(), item_type::Module));\n+        cache.paths.insert(did, (vec![e.name.to_strbuf()], item_type::Module));\n     }\n \n     // And finally render the whole crate's documentation\n@@ -1032,23 +1041,38 @@ impl<'a> Item<'a> {\n         }\n     }\n \n-    fn link(&self) -> String {\n-        let mut path = Vec::new();\n-        clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n-            path.push(component.to_owned());\n-        });\n-        let href = if self.item.source.loline == self.item.source.hiline {\n-            format_strbuf!(\"{}\", self.item.source.loline)\n+    fn link(&self) -> Option<String> {\n+        if ast_util::is_local(self.item.def_id) {\n+            let mut path = Vec::new();\n+            clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n+                path.push(component.to_owned());\n+            });\n+            let href = if self.item.source.loline == self.item.source.hiline {\n+                format!(\"{}\", self.item.source.loline)\n+            } else {\n+                format!(\"{}-{}\",\n+                        self.item.source.loline,\n+                        self.item.source.hiline)\n+            };\n+            Some(format!(\"{root}src/{krate}/{path}.html\\\\#{href}\",\n+                         root = self.cx.root_path,\n+                         krate = self.cx.layout.krate,\n+                         path = path.connect(\"/\"),\n+                         href = href))\n         } else {\n-            format_strbuf!(\"{}-{}\",\n-                           self.item.source.loline,\n-                           self.item.source.hiline)\n-        };\n-        format_strbuf!(\"{root}src/{krate}/{path}.html\\\\#{href}\",\n-                       root = self.cx.root_path,\n-                       krate = self.cx.layout.krate,\n-                       path = path.connect(\"/\"),\n-                       href = href)\n+            let cache = cache_key.get().unwrap();\n+            let path = cache.external_paths.get(&self.item.def_id);\n+            let root = match *cache.extern_locations.get(&self.item.def_id.krate) {\n+                Remote(ref s) => s.to_strbuf(),\n+                Local => format!(\"{}/..\", self.cx.root_path),\n+                Unknown => return None,\n+            };\n+            Some(format!(\"{root}/{path}/{file}?gotosrc={goto}\",\n+                         root = root,\n+                         path = path.slice_to(path.len() - 1).connect(\"/\"),\n+                         file = item_path(self.item),\n+                         goto = self.item.def_id.node))\n+        }\n     }\n }\n \n@@ -1097,8 +1121,15 @@ impl<'a> fmt::Show for Item<'a> {\n \n         // Write `src` tag\n         if self.cx.include_sources {\n-            try!(write!(fmt, \"<a class='source' href='{}'>[src]</a>\",\n-                        self.link()));\n+            match self.link() {\n+                Some(l) => {\n+                    try!(write!(fmt,\n+                                \"<a class='source' id='src-{}' \\\n+                                    href='{}'>[src]</a>\",\n+                                self.item.def_id.node, l));\n+                }\n+                None => {}\n+            }\n         }\n         try!(write!(fmt, \"</h1>\\n\"));\n "}, {"sha": "ec58162fa92657f3c6a3455dc5b14b28134674df", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8dad7f579e029fd883d64848f4abb12630dcc3e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/8dad7f579e029fd883d64848f4abb12630dcc3e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=8dad7f579e029fd883d64848f4abb12630dcc3e6", "patch": "@@ -675,4 +675,14 @@\n     if (window.pending_implementors) {\n         window.register_implementors(window.pending_implementors);\n     }\n+\n+\n+    var query = window.location.search.substring(1);\n+    var vars = query.split('&');\n+    for (var i = 0; i < vars.length; i++) {\n+        var pair = vars[i].split('=');\n+        if (pair[0] == 'gotosrc') {\n+            window.location = $('#src-' + pair[1]).attr('href');\n+        }\n+    }\n }());"}]}