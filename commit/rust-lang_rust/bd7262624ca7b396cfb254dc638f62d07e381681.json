{"sha": "bd7262624ca7b396cfb254dc638f62d07e381681", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNzI2MjYyNGNhN2IzOTZjZmIyNTRkYzYzOGY2MmQwN2UzODE2ODE=", "commit": {"author": {"name": "Elly Jones", "email": "elly@leptoquark.net", "date": "2011-11-07T19:01:28Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-07T23:44:43Z"}, "message": "stdlib: add json.\n\nAdd a json serializer and deserializer.\n\nSigned-off-by: Elly Jones <ellyjones@google.com>", "tree": {"sha": "000f503d1a700d5a07fed8ec684df5c2cb14e282", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/000f503d1a700d5a07fed8ec684df5c2cb14e282"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd7262624ca7b396cfb254dc638f62d07e381681", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd7262624ca7b396cfb254dc638f62d07e381681", "html_url": "https://github.com/rust-lang/rust/commit/bd7262624ca7b396cfb254dc638f62d07e381681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd7262624ca7b396cfb254dc638f62d07e381681/comments", "author": null, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcd39b1191f92d1f1851fa71098471ad60ab22c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcd39b1191f92d1f1851fa71098471ad60ab22c2", "html_url": "https://github.com/rust-lang/rust/commit/fcd39b1191f92d1f1851fa71098471ad60ab22c2"}], "stats": {"total": 294, "additions": 294, "deletions": 0}, "files": [{"sha": "02d5d3d5e7e36b21252e694e1a9ca56768b3443a", "filename": "src/lib/json.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/bd7262624ca7b396cfb254dc638f62d07e381681/src%2Flib%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7262624ca7b396cfb254dc638f62d07e381681/src%2Flib%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fjson.rs?ref=bd7262624ca7b396cfb254dc638f62d07e381681", "patch": "@@ -0,0 +1,293 @@\n+#[link(name = \"json\",\n+       vers = \"0.1\",\n+       uuid = \"09d7f2fc-1fad-48b2-9f9d-a65512342f16\",\n+       url = \"http://www.leptoquark.net/~elly/rust/\")];\n+#[copyright = \"Google Inc. 2011\"];\n+#[comment = \"JSON serialization format library\"];\n+#[license = \"BSD\"];\n+\n+import float;\n+import map;\n+import option;\n+import option::{some, none};\n+import str;\n+import vec;\n+\n+export json;\n+export tostr;\n+export fromstr;\n+\n+tag json {\n+    num(float);\n+    string(str);\n+    boolean(bool);\n+    list(@[json]);\n+    dict(map::hashmap<str,json>);\n+}\n+\n+fn tostr(j: json) -> str {\n+    alt j {\n+        num(f) { float::to_str(f, 6u) }\n+        string(s) { #fmt[\"\\\"%s\\\"\", s] } // XXX: escape\n+        boolean(true) { \"true\" }\n+        boolean(false) { \"false\" }\n+        list(@js) {\n+            str::concat([\"[\",\n+                    str::connect(\n+                        vec::map::<json,str>({ |e| tostr(e) }, js),\n+                        \", \"),\n+                    \"]\"])\n+        }\n+        dict(m) {\n+            let parts = [];\n+            m.items({ |k, v|\n+                        vec::grow(parts, 1u,\n+                                  str::concat([\"\\\"\", k, \"\\\": \", tostr(v)])\n+                        )\n+            });\n+            str::concat([\"{ \", str::connect(parts, \", \"), \" }\"])\n+        }\n+    }\n+}\n+\n+fn rest(s: str) -> str {\n+    str::char_slice(s, 1u, str::char_len(s))\n+}\n+\n+fn fromstr_str(s: str) -> (option::t<json>, str) {\n+    let pos = 0u;\n+    let len = str::byte_len(s);\n+    let escape = false;\n+    let res = \"\";\n+\n+    alt str::char_at(s, 0u) {\n+        '\"' { pos = 1u; }\n+        _ { ret (none, s); }\n+    }\n+\n+    while (pos < len) {\n+        let chr = str::char_range_at(s, pos);\n+        let c = chr.ch;\n+        pos = chr.next;\n+        if (escape) {\n+            res = res + str::from_char(c);\n+            escape = false;\n+            cont;\n+        }\n+        if (c == '\\\\') {\n+            escape = true;\n+            cont;\n+        } else if (c == '\"') {\n+            ret (some(string(res)), str::char_slice(s, pos, str::char_len(s)));\n+        }\n+        res = res + str::from_char(c);\n+    }\n+\n+    ret (none, s);\n+}\n+\n+fn fromstr_list(s: str) -> (option::t<json>, str) {\n+    if str::char_at(s, 0u) != '[' { ret (none, s); }\n+    let s0 = str::trim_left(rest(s));\n+    let vals = [];\n+    if str::is_empty(s0) { ret (none, s0); }\n+    if str::char_at(s0, 0u) == ']' { ret (some(list(@[])), rest(s0)); }\n+    while str::is_not_empty(s0) {\n+        s0 = str::trim_left(s0);\n+        let (next, s1) = fromstr_helper(s0);\n+        s0 = s1;\n+        alt next {\n+            some(j) { vec::grow(vals, 1u, j); }\n+            none { ret (none, s0); }\n+        }\n+        s0 = str::trim_left(s0);\n+        if str::is_empty(s0) { ret (none, s0); }\n+        alt str::char_at(s0, 0u) {\n+            ',' { }\n+            ']' { ret (some(list(@vals)), rest(s0)); }\n+            _ { ret (none, s0); }\n+        }\n+        s0 = rest(s0);\n+    }\n+    ret (none, s0);\n+}\n+\n+fn fromstr_dict(s: str) -> (option::t<json>, str) {\n+    if str::char_at(s, 0u) != '{' { ret (none, s); }\n+    let s0 = str::trim_left(rest(s));\n+    let vals = map::new_str_hash::<json>();\n+    if str::is_empty(s0) { ret (none, s0); }\n+    if str::char_at(s0, 0u) == '}' { ret (some(dict(vals)), rest(s0)); }\n+    while str::is_not_empty(s0) {\n+        s0 = str::trim_left(s0);\n+        let (next, s1) = fromstr_helper(s0);    // key\n+        let key = \"\";\n+        s0 = s1;\n+        alt next {\n+            some(string(k)) { key = k; }\n+            _ { ret (none, s0); }\n+        }\n+        s0 = str::trim_left(s0);\n+        if str::is_empty(s0) { ret (none, s0); }\n+        if str::char_at(s0, 0u) != ':' { ret (none, s0); }\n+        s0 = str::trim_left(rest(s0));\n+        let (next, s1) = fromstr_helper(s0);    // value\n+        s0 = s1;\n+        alt next {\n+            some(j) { vals.insert(key, j); }\n+            _ { ret (none, s0); }\n+        }\n+        s0 = str::trim_left(s0);\n+        if str::is_empty(s0) { ret (none, s0); }\n+        alt str::char_at(s0, 0u) {\n+            ',' { }\n+            '}' { ret (some(dict(vals)), rest(s0)); }\n+            _ { ret (none, s0); }\n+        }\n+        s0 = str::trim_left(rest(s0));\n+    }\n+    (none, s)\n+}\n+\n+fn fromstr_float(s: str) -> (option::t<json>, str) {\n+    let pos = 0u;\n+    let len = str::byte_len(s);\n+    let res = 0f;\n+    let neg = 1.f;\n+\n+    alt str::char_at(s, 0u) {\n+        '-' {\n+            neg = -1.f;\n+            pos = 1u;\n+        }\n+        '+' {\n+            pos = 1u;\n+        }\n+        '0' to '9' | '.' { }\n+        _ { ret (none, s); }\n+    }\n+\n+    while (pos < len) {\n+        let opos = pos;\n+        let chr = str::char_range_at(s, pos);\n+        let c = chr.ch;\n+        pos = chr.next;\n+        alt c {\n+            '0' to '9' {\n+                res = res * 10f;\n+                res += ((c as int) - ('0' as int)) as float;\n+            }\n+            '.' { break; }\n+            _ { ret (some(num(neg * res)),\n+                     str::char_slice(s, opos, str::char_len(s))); }\n+        }\n+    }\n+\n+    if pos == len {\n+        ret (some(num(neg * res)), str::char_slice(s, pos, str::char_len(s)));\n+    }\n+\n+    let dec = 1.f;\n+    while (pos < len) {\n+        let opos = pos;\n+        let chr = str::char_range_at(s, pos);\n+        let c = chr.ch;\n+        pos = chr.next;\n+        alt c {\n+            '0' to '9' {\n+                dec /= 10.f;\n+                res += (((c as int) - ('0' as int)) as float) * dec;\n+            }\n+            _ { ret (some(num(neg * res)),\n+                     str::char_slice(s, opos, str::char_len(s))); }\n+        }\n+    }\n+    ret (some(num(neg * res)), str::char_slice(s, pos, str::char_len(s)));\n+}\n+\n+fn fromstr_bool(s: str) -> (option::t<json>, str) {\n+    if (str::starts_with(s, \"true\")) {\n+        (some(boolean(true)), str::slice(s, 4u, str::byte_len(s)))\n+    } else if (str::starts_with(s, \"false\")) {\n+        (some(boolean(false)), str::slice(s, 5u, str::byte_len(s)))\n+    } else {\n+        (none, s)\n+    }\n+}\n+\n+fn fromstr_helper(s: str) -> (option::t<json>, str) {\n+    let s = str::trim_left(s);\n+    if str::is_empty(s) { ret (none, s); }\n+    let start = str::char_at(s, 0u);\n+    alt start {\n+        '\"' { fromstr_str(s) }\n+        '[' { fromstr_list(s) }\n+        '{' { fromstr_dict(s) }\n+        '0' to '9' | '-' | '+' | '.' { fromstr_float(s) }\n+        't' | 'f' { fromstr_bool(s) }\n+        _ { ret (none, s); }\n+    }\n+}\n+\n+fn fromstr(s: str) -> option::t<json> {\n+    let (j, _) = fromstr_helper(s);\n+    j\n+}\n+\n+fn main() {\n+    let j = fromstr(\"{ \\\"foo\\\": [ 4, 5 ], \\\"bar\\\": { \\\"baz\\\": true}}\");\n+    alt j {\n+        some(j0) {\n+            log tostr(j0);\n+        }\n+        _ { }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_fromstr_num() {\n+        assert(fromstr(\"3\") == some(num(3f)));\n+        assert(fromstr(\"3.1\") == some(num(3.1f)));\n+        assert(fromstr(\"-1.2\") == some(num(-1.2f)));\n+        assert(fromstr(\".4\") == some(num(0.4f)));\n+    }\n+\n+    #[test]\n+    fn test_fromstr_str() {\n+        assert(fromstr(\"\\\"foo\\\"\") == some(string(\"foo\")));\n+        assert(fromstr(\"\\\"\\\\\\\"\\\"\") == some(string(\"\\\"\")));\n+        assert(fromstr(\"\\\"lol\") == none);\n+    }\n+\n+    #[test]\n+    fn test_fromstr_bool() {\n+        assert(fromstr(\"true\") == some(boolean(true)));\n+        assert(fromstr(\"false\") == some(boolean(false)));\n+        assert(fromstr(\"truz\") == none);\n+    }\n+\n+    #[test]\n+    fn test_fromstr_list() {\n+        assert(fromstr(\"[]\") == some(list(@[])));\n+        assert(fromstr(\"[true]\") == some(list(@[boolean(true)])));\n+        assert(fromstr(\"[3, 1]\") == some(list(@[num(3f), num(1f)])));\n+        assert(fromstr(\"[2, [4, 1]]\") ==\n+            some(list(@[num(2f), list(@[num(4f), num(1f)])])));\n+        assert(fromstr(\"[2, ]\") == none);\n+        assert(fromstr(\"[5, \") == none);\n+        assert(fromstr(\"[6 7]\") == none);\n+        assert(fromstr(\"[3\") == none);\n+    }\n+\n+    #[test]\n+    fn test_fromstr_dict() {\n+        assert(fromstr(\"{}\") != none);\n+        assert(fromstr(\"{\\\"a\\\": 3}\") != none);\n+        assert(fromstr(\"{\\\"a\\\": }\") == none);\n+        assert(fromstr(\"{\\\"a\\\" }\") == none);\n+        assert(fromstr(\"{\\\"a\\\"\") == none);\n+        assert(fromstr(\"{\") == none);\n+    }\n+}"}, {"sha": "86335d6312eaa31b45f7ae4199a63b216b4c40dc", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd7262624ca7b396cfb254dc638f62d07e381681/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bd7262624ca7b396cfb254dc638f62d07e381681/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=bd7262624ca7b396cfb254dc638f62d07e381681", "patch": "@@ -74,6 +74,7 @@ mod ufind;\n mod ebml;\n mod dbg;\n mod getopts;\n+mod json;\n mod math;\n mod rand;\n mod sha1;"}]}