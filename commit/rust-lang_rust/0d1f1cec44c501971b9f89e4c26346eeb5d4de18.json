{"sha": "0d1f1cec44c501971b9f89e4c26346eeb5d4de18", "node_id": "C_kwDOAAsO6NoAKDBkMWYxY2VjNDRjNTAxOTcxYjlmODllNGMyNjM0NmVlYjVkNGRlMTg", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-11-20T01:51:20Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-11-20T02:14:51Z"}, "message": "Remove surrounding unsafe block in `strlen_on_c_strings` when possible", "tree": {"sha": "c2892a3b265e49130a03a2aff7710c2da09e748a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2892a3b265e49130a03a2aff7710c2da09e748a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d1f1cec44c501971b9f89e4c26346eeb5d4de18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d1f1cec44c501971b9f89e4c26346eeb5d4de18", "html_url": "https://github.com/rust-lang/rust/commit/0d1f1cec44c501971b9f89e4c26346eeb5d4de18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d1f1cec44c501971b9f89e4c26346eeb5d4de18/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c443f8fb95da16cb9bd30bc9662f506a9e9c5a5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c443f8fb95da16cb9bd30bc9662f506a9e9c5a5c", "html_url": "https://github.com/rust-lang/rust/commit/c443f8fb95da16cb9bd30bc9662f506a9e9c5a5c"}], "stats": {"total": 159, "additions": 128, "deletions": 31}, "files": [{"sha": "fee01fb0bd186db7999e817c8f3751e0d2cf6d82", "filename": "clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0d1f1cec44c501971b9f89e4c26346eeb5d4de18/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1f1cec44c501971b9f89e4c26346eeb5d4de18/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=0d1f1cec44c501971b9f89e4c26346eeb5d4de18", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::match_libc_symbol;\n use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::is_expr_unsafe;\n+use clippy_utils::{get_parent_node, match_libc_symbol};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir as hir;\n+use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, Node, UnsafeSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::sym;\n@@ -39,20 +40,31 @@ declare_clippy_lint! {\n declare_lint_pass!(StrlenOnCStrings => [STRLEN_ON_C_STRINGS]);\n \n impl LateLintPass<'tcx> for StrlenOnCStrings {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if !expr.span.from_expansion();\n-            if let hir::ExprKind::Call(func, [recv]) = expr.kind;\n-            if let hir::ExprKind::Path(path) = &func.kind;\n+            if let ExprKind::Call(func, [recv]) = expr.kind;\n+            if let ExprKind::Path(path) = &func.kind;\n             if let Some(did) = cx.qpath_res(path, func.hir_id).opt_def_id();\n             if match_libc_symbol(cx, did, \"strlen\");\n-            if let hir::ExprKind::MethodCall(path, _, [self_arg], _) = recv.kind;\n+            if let ExprKind::MethodCall(path, _, [self_arg], _) = recv.kind;\n             if !recv.span.from_expansion();\n             if path.ident.name == sym::as_ptr;\n             then {\n+                let ctxt = expr.span.ctxt();\n+                let span = match get_parent_node(cx.tcx, expr.hir_id) {\n+                    Some(Node::Block(&Block {\n+                        rules: BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided), span, ..\n+                    }))\n+                    if span.ctxt() == ctxt && !is_expr_unsafe(cx, self_arg) => {\n+                        span\n+                    }\n+                    _ => expr.span,\n+                };\n+\n                 let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n-                let mut app = Applicability::Unspecified;\n-                let val_name = snippet_with_context(cx, self_arg.span, expr.span.ctxt(), \"..\", &mut app).0;\n+                let mut app = Applicability::MachineApplicable;\n+                let val_name = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n                 let method_name = if is_type_diagnostic_item(cx, ty, sym::cstring_type) {\n                     \"as_bytes\"\n                 } else if is_type_diagnostic_item(cx, ty, sym::CStr) {\n@@ -64,11 +76,11 @@ impl LateLintPass<'tcx> for StrlenOnCStrings {\n                 span_lint_and_sugg(\n                     cx,\n                     STRLEN_ON_C_STRINGS,\n-                    expr.span,\n+                    span,\n                     \"using `libc::strlen` on a `CString` or `CStr` value\",\n-                    \"try this (you might also need to get rid of `unsafe` block in some cases):\",\n+                    \"try this\",\n                     format!(\"{}.{}().len()\", val_name, method_name),\n-                    Applicability::Unspecified // Sometimes unnecessary `unsafe` block\n+                    app,\n                 );\n             }\n         }"}, {"sha": "4bfd3c64b9c361acb61001600277e3064bbb2ff3", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0d1f1cec44c501971b9f89e4c26346eeb5d4de18/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1f1cec44c501971b9f89e4c26346eeb5d4de18/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=0d1f1cec44c501971b9f89e4c26346eeb5d4de18", "patch": "@@ -1,8 +1,10 @@\n use crate::path_to_local_id;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Arm, Block, Body, BodyId, Expr, ExprKind, HirId, Stmt, UnOp};\n+use rustc_hir::intravisit::{self, walk_block, walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{\n+    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Stmt, UnOp, Unsafety,\n+};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n@@ -317,3 +319,64 @@ pub fn is_const_evaluatable(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n     v.visit_expr(e);\n     v.is_const\n }\n+\n+/// Checks if the given expression performs an unsafe operation outside of an unsafe block.\n+pub fn is_expr_unsafe(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n+    struct V<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        is_unsafe: bool,\n+    }\n+    impl<'tcx> Visitor<'tcx> for V<'_, 'tcx> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+        }\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.is_unsafe {\n+                return;\n+            }\n+            match e.kind {\n+                ExprKind::Unary(UnOp::Deref, e) if self.cx.typeck_results().expr_ty(e).is_unsafe_ptr() => {\n+                    self.is_unsafe = true;\n+                },\n+                ExprKind::MethodCall(..)\n+                    if self\n+                        .cx\n+                        .typeck_results()\n+                        .type_dependent_def_id(e.hir_id)\n+                        .map_or(false, |id| self.cx.tcx.fn_sig(id).unsafety() == Unsafety::Unsafe) =>\n+                {\n+                    self.is_unsafe = true;\n+                },\n+                ExprKind::Call(func, _) => match *self.cx.typeck_results().expr_ty(func).peel_refs().kind() {\n+                    ty::FnDef(id, _) if self.cx.tcx.fn_sig(id).unsafety() == Unsafety::Unsafe => self.is_unsafe = true,\n+                    ty::FnPtr(sig) if sig.unsafety() == Unsafety::Unsafe => self.is_unsafe = true,\n+                    _ => walk_expr(self, e),\n+                },\n+                ExprKind::Path(ref p)\n+                    if self\n+                        .cx\n+                        .qpath_res(p, e.hir_id)\n+                        .opt_def_id()\n+                        .map_or(false, |id| self.cx.tcx.is_mutable_static(id)) =>\n+                {\n+                    self.is_unsafe = true;\n+                },\n+                _ => walk_expr(self, e),\n+            }\n+        }\n+        fn visit_block(&mut self, b: &'tcx Block<'_>) {\n+            if !matches!(b.rules, BlockCheckMode::UnsafeBlock(_)) {\n+                walk_block(self, b);\n+            }\n+        }\n+        fn visit_nested_item(&mut self, id: ItemId) {\n+            if let ItemKind::Impl(i) = &self.cx.tcx.hir().item(id).kind {\n+                self.is_unsafe = i.unsafety == Unsafety::Unsafe;\n+            }\n+        }\n+    }\n+    let mut v = V { cx, is_unsafe: false };\n+    v.visit_expr(e);\n+    v.is_unsafe\n+}"}, {"sha": "a3451d992a0500ff1c8ef347b6c11b05e6cdcfd4", "filename": "tests/ui/strlen_on_c_strings.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d1f1cec44c501971b9f89e4c26346eeb5d4de18/tests%2Fui%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1f1cec44c501971b9f89e4c26346eeb5d4de18/tests%2Fui%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstrlen_on_c_strings.rs?ref=0d1f1cec44c501971b9f89e4c26346eeb5d4de18", "patch": "@@ -16,4 +16,16 @@ fn main() {\n     let len = unsafe { libc::strlen(cstr.as_ptr()) };\n \n     let len = unsafe { strlen(cstr.as_ptr()) };\n+\n+    let pcstr: *const &CStr = &cstr;\n+    let len = unsafe { strlen((*pcstr).as_ptr()) };\n+\n+    unsafe fn unsafe_identity<T>(x: T) -> T {\n+        x\n+    }\n+    let len = unsafe { strlen(unsafe_identity(cstr).as_ptr()) };\n+    let len = unsafe { strlen(unsafe { unsafe_identity(cstr) }.as_ptr()) };\n+\n+    let f: unsafe fn(_) -> _ = unsafe_identity;\n+    let len = unsafe { strlen(f(cstr).as_ptr()) };\n }"}, {"sha": "0dbecda62e3af5e66469173110b57a7973c7b6c1", "filename": "tests/ui/strlen_on_c_strings.stderr", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0d1f1cec44c501971b9f89e4c26346eeb5d4de18/tests%2Fui%2Fstrlen_on_c_strings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0d1f1cec44c501971b9f89e4c26346eeb5d4de18/tests%2Fui%2Fstrlen_on_c_strings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstrlen_on_c_strings.stderr?ref=0d1f1cec44c501971b9f89e4c26346eeb5d4de18", "patch": "@@ -1,36 +1,46 @@\n error: using `libc::strlen` on a `CString` or `CStr` value\n-  --> $DIR/strlen_on_c_strings.rs:12:24\n+  --> $DIR/strlen_on_c_strings.rs:12:15\n    |\n LL |     let len = unsafe { libc::strlen(cstring.as_ptr()) };\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `cstring.as_bytes().len()`\n    |\n    = note: `-D clippy::strlen-on-c-strings` implied by `-D warnings`\n-help: try this (you might also need to get rid of `unsafe` block in some cases):\n-   |\n-LL |     let len = unsafe { cstring.as_bytes().len() };\n-   |                        ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: using `libc::strlen` on a `CString` or `CStr` value\n-  --> $DIR/strlen_on_c_strings.rs:16:24\n+  --> $DIR/strlen_on_c_strings.rs:16:15\n    |\n LL |     let len = unsafe { libc::strlen(cstr.as_ptr()) };\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `cstr.to_bytes().len()`\n+\n+error: using `libc::strlen` on a `CString` or `CStr` value\n+  --> $DIR/strlen_on_c_strings.rs:18:15\n    |\n-help: try this (you might also need to get rid of `unsafe` block in some cases):\n+LL |     let len = unsafe { strlen(cstr.as_ptr()) };\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `cstr.to_bytes().len()`\n+\n+error: using `libc::strlen` on a `CString` or `CStr` value\n+  --> $DIR/strlen_on_c_strings.rs:21:24\n    |\n-LL |     let len = unsafe { cstr.to_bytes().len() };\n-   |                        ~~~~~~~~~~~~~~~~~~~~~\n+LL |     let len = unsafe { strlen((*pcstr).as_ptr()) };\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(*pcstr).to_bytes().len()`\n \n error: using `libc::strlen` on a `CString` or `CStr` value\n-  --> $DIR/strlen_on_c_strings.rs:18:24\n+  --> $DIR/strlen_on_c_strings.rs:26:24\n    |\n-LL |     let len = unsafe { strlen(cstr.as_ptr()) };\n-   |                        ^^^^^^^^^^^^^^^^^^^^^\n+LL |     let len = unsafe { strlen(unsafe_identity(cstr).as_ptr()) };\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unsafe_identity(cstr).to_bytes().len()`\n+\n+error: using `libc::strlen` on a `CString` or `CStr` value\n+  --> $DIR/strlen_on_c_strings.rs:27:15\n    |\n-help: try this (you might also need to get rid of `unsafe` block in some cases):\n+LL |     let len = unsafe { strlen(unsafe { unsafe_identity(cstr) }.as_ptr()) };\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unsafe { unsafe_identity(cstr) }.to_bytes().len()`\n+\n+error: using `libc::strlen` on a `CString` or `CStr` value\n+  --> $DIR/strlen_on_c_strings.rs:30:24\n    |\n-LL |     let len = unsafe { cstr.to_bytes().len() };\n-   |                        ~~~~~~~~~~~~~~~~~~~~~\n+LL |     let len = unsafe { strlen(f(cstr).as_ptr()) };\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `f(cstr).to_bytes().len()`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 7 previous errors\n "}]}