{"sha": "4039176ec63e5c75d76398f2debe26ac6fa59cbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMzkxNzZlYzYzZTVjNzVkNzYzOThmMmRlYmUyNmFjNmZhNTljYmM=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-10-03T09:48:02Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-10-12T07:59:54Z"}, "message": "Create basic support for names case checks and implement function name case check", "tree": {"sha": "8f2f2b6d22c57985fc6a8f1b40d84663d40b09f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f2f2b6d22c57985fc6a8f1b40d84663d40b09f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4039176ec63e5c75d76398f2debe26ac6fa59cbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4039176ec63e5c75d76398f2debe26ac6fa59cbc", "html_url": "https://github.com/rust-lang/rust/commit/4039176ec63e5c75d76398f2debe26ac6fa59cbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4039176ec63e5c75d76398f2debe26ac6fa59cbc/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "518f6d772482c7c58e59081f340947087a9b4800", "url": "https://api.github.com/repos/rust-lang/rust/commits/518f6d772482c7c58e59081f340947087a9b4800", "html_url": "https://github.com/rust-lang/rust/commit/518f6d772482c7c58e59081f340947087a9b4800"}], "stats": {"total": 303, "additions": 300, "deletions": 3}, "files": [{"sha": "19ea26e36cbd2733f06b8b0a4f4533379f4203cd", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=4039176ec63e5c75d76398f2debe26ac6fa59cbc", "patch": "@@ -255,6 +255,37 @@ impl ModuleDef {\n             ModuleDef::BuiltinType(it) => Some(it.as_name()),\n         }\n     }\n+\n+    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n+        match self {\n+            ModuleDef::Adt(it) => match it {\n+                Adt::Struct(it) => {\n+                    hir_ty::diagnostics::validate_module_item(db, it.id.into(), sink)\n+                }\n+                Adt::Enum(it) => hir_ty::diagnostics::validate_module_item(db, it.id.into(), sink),\n+                Adt::Union(it) => hir_ty::diagnostics::validate_module_item(db, it.id.into(), sink),\n+            },\n+            ModuleDef::Trait(it) => {\n+                hir_ty::diagnostics::validate_module_item(db, it.id.into(), sink)\n+            }\n+            ModuleDef::Function(it) => {\n+                hir_ty::diagnostics::validate_module_item(db, it.id.into(), sink)\n+            }\n+            ModuleDef::TypeAlias(it) => {\n+                hir_ty::diagnostics::validate_module_item(db, it.id.into(), sink)\n+            }\n+            ModuleDef::Module(it) => {\n+                hir_ty::diagnostics::validate_module_item(db, it.id.into(), sink)\n+            }\n+            ModuleDef::Const(it) => {\n+                hir_ty::diagnostics::validate_module_item(db, it.id.into(), sink)\n+            }\n+            ModuleDef::Static(it) => {\n+                hir_ty::diagnostics::validate_module_item(db, it.id.into(), sink)\n+            }\n+            _ => return,\n+        }\n+    }\n }\n \n pub use hir_def::{"}, {"sha": "733db2eaca65cc64c76e4a214f1808a3f667fc6a", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=4039176ec63e5c75d76398f2debe26ac6fa59cbc", "patch": "@@ -19,6 +19,7 @@ use crate::{\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FunctionData {\n     pub name: Name,\n+    pub param_names: Vec<Option<Name>>,\n     pub params: Vec<TypeRef>,\n     pub ret_type: TypeRef,\n     pub attrs: Attrs,\n@@ -39,6 +40,7 @@ impl FunctionData {\n \n         Arc::new(FunctionData {\n             name: func.name.clone(),\n+            param_names: func.param_names.to_vec(),\n             params: func.params.to_vec(),\n             ret_type: func.ret_type.clone(),\n             attrs: item_tree.attrs(ModItem::from(loc.id.value).into()).clone(),"}, {"sha": "ca502ce2ba1494a5c1120784b1fe9184e5fe75ec", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=4039176ec63e5c75d76398f2debe26ac6fa59cbc", "patch": "@@ -507,6 +507,8 @@ pub struct Function {\n     pub has_self_param: bool,\n     pub has_body: bool,\n     pub is_unsafe: bool,\n+    /// List of function parameters names. Does not include `self`.\n+    pub param_names: Box<[Option<Name>]>,\n     pub params: Box<[TypeRef]>,\n     pub is_varargs: bool,\n     pub ret_type: TypeRef,"}, {"sha": "2ffa46ac0eefff7202d313b0342878e91b31b8b5", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=4039176ec63e5c75d76398f2debe26ac6fa59cbc", "patch": "@@ -283,6 +283,7 @@ impl Ctx {\n         let name = func.name()?.as_name();\n \n         let mut params = Vec::new();\n+        let mut param_names = Vec::new();\n         let mut has_self_param = false;\n         if let Some(param_list) = func.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n@@ -305,6 +306,18 @@ impl Ctx {\n                 has_self_param = true;\n             }\n             for param in param_list.params() {\n+                let param_name = param\n+                    .pat()\n+                    .map(|name| {\n+                        if let ast::Pat::IdentPat(ident) = name {\n+                            Some(ident.name()?.as_name())\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .flatten();\n+                param_names.push(param_name);\n+\n                 let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ty());\n                 params.push(type_ref);\n             }\n@@ -341,6 +354,7 @@ impl Ctx {\n             has_body,\n             is_unsafe: func.unsafe_token().is_some(),\n             params: params.into_boxed_slice(),\n+            param_names: param_names.into_boxed_slice(),\n             is_varargs,\n             ret_type,\n             ast_id,"}, {"sha": "7227e7010fd488b57e3f9bfbe7f6f2db5df769ad", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 78, "deletions": 3, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=4039176ec63e5c75d76398f2debe26ac6fa59cbc", "patch": "@@ -2,10 +2,11 @@\n mod expr;\n mod match_check;\n mod unsafe_check;\n+mod decl_check;\n \n-use std::any::Any;\n+use std::{any::Any, fmt};\n \n-use hir_def::DefWithBodyId;\n+use hir_def::{DefWithBodyId, ModuleDefId};\n use hir_expand::diagnostics::{Diagnostic, DiagnosticCode, DiagnosticSink};\n use hir_expand::{name::Name, HirFileId, InFile};\n use stdx::format_to;\n@@ -15,6 +16,16 @@ use crate::db::HirDatabase;\n \n pub use crate::diagnostics::expr::{record_literal_missing_fields, record_pattern_missing_fields};\n \n+pub fn validate_module_item(\n+    db: &dyn HirDatabase,\n+    owner: ModuleDefId,\n+    sink: &mut DiagnosticSink<'_>,\n+) {\n+    let _p = profile::span(\"validate_body\");\n+    let mut validator = decl_check::DeclValidator::new(owner, sink);\n+    validator.validate_item(db);\n+}\n+\n pub fn validate_body(db: &dyn HirDatabase, owner: DefWithBodyId, sink: &mut DiagnosticSink<'_>) {\n     let _p = profile::span(\"validate_body\");\n     let infer = db.infer(owner);\n@@ -231,6 +242,64 @@ impl Diagnostic for MismatchedArgCount {\n     }\n }\n \n+#[derive(Debug)]\n+pub enum CaseType {\n+    // `some_var`\n+    LowerSnakeCase,\n+    // `SOME_CONST`\n+    UpperSnakeCase,\n+    // `SomeStruct`\n+    UpperCamelCase,\n+}\n+\n+impl fmt::Display for CaseType {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let repr = match self {\n+            CaseType::LowerSnakeCase => \"snake_case\",\n+            CaseType::UpperSnakeCase => \"UPPER_SNAKE_CASE\",\n+            CaseType::UpperCamelCase => \"UpperCamelCase\",\n+        };\n+\n+        write!(f, \"{}\", repr)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct IncorrectCase {\n+    pub file: HirFileId,\n+    pub ident: SyntaxNodePtr,\n+    pub expected_case: CaseType,\n+    pub ident_text: String,\n+    pub suggested_text: String,\n+}\n+\n+impl Diagnostic for IncorrectCase {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"incorrect-ident-case\")\n+    }\n+\n+    fn message(&self) -> String {\n+        format!(\n+            \"Argument `{}` should have a {} name, e.g. `{}`\",\n+            self.ident_text,\n+            self.expected_case.to_string(),\n+            self.suggested_text\n+        )\n+    }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.ident.clone())\n+    }\n+\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+\n+    fn is_experimental(&self) -> bool {\n+        true\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use base_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n@@ -242,7 +311,10 @@ mod tests {\n     use rustc_hash::FxHashMap;\n     use syntax::{TextRange, TextSize};\n \n-    use crate::{diagnostics::validate_body, test_db::TestDB};\n+    use crate::{\n+        diagnostics::{validate_body, validate_module_item},\n+        test_db::TestDB,\n+    };\n \n     impl TestDB {\n         fn diagnostics<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n@@ -253,6 +325,9 @@ mod tests {\n                 let mut fns = Vec::new();\n                 for (module_id, _) in crate_def_map.modules.iter() {\n                     for decl in crate_def_map[module_id].scope.declarations() {\n+                        let mut sink = DiagnosticSinkBuilder::new().build(&mut cb);\n+                        validate_module_item(self, decl, &mut sink);\n+\n                         if let ModuleDefId::FunctionId(f) = decl {\n                             fns.push(f)\n                         }"}, {"sha": "6c3cd65c5752523b5a7fd4e337ad256c73c4fed2", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4039176ec63e5c75d76398f2debe26ac6fa59cbc/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=4039176ec63e5c75d76398f2debe26ac6fa59cbc", "patch": "@@ -0,0 +1,173 @@\n+//! Provides validators for the item declarations.\n+//! This includes the following items:\n+//! - variable bindings (e.g. `let x = foo();`)\n+//! - struct fields (e.g. `struct Foo { field: u8 }`)\n+//! - enum fields (e.g. `enum Foo { Variant { field: u8 } }`)\n+//! - function/method arguments (e.g. `fn foo(arg: u8)`)\n+\n+// TODO: Temporary, to not see warnings until module is somewhat complete.\n+// If you see these lines in the pull request, feel free to call me stupid :P.\n+#![allow(dead_code, unused_imports, unused_variables)]\n+\n+use std::sync::Arc;\n+\n+use hir_def::{\n+    body::Body,\n+    db::DefDatabase,\n+    expr::{Expr, ExprId, UnaryOp},\n+    item_tree::ItemTreeNode,\n+    resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n+    src::HasSource,\n+    AdtId, FunctionId, Lookup, ModuleDefId,\n+};\n+use hir_expand::{diagnostics::DiagnosticSink, name::Name};\n+use syntax::{ast::NameOwner, AstPtr};\n+\n+use crate::{\n+    db::HirDatabase,\n+    diagnostics::{CaseType, IncorrectCase},\n+    lower::CallableDefId,\n+    ApplicationTy, InferenceResult, Ty, TypeCtor,\n+};\n+\n+pub(super) struct DeclValidator<'a, 'b: 'a> {\n+    owner: ModuleDefId,\n+    sink: &'a mut DiagnosticSink<'b>,\n+}\n+\n+#[derive(Debug)]\n+struct Replacement {\n+    current_name: Name,\n+    suggested_text: String,\n+    expected_case: CaseType,\n+}\n+\n+impl<'a, 'b> DeclValidator<'a, 'b> {\n+    pub(super) fn new(\n+        owner: ModuleDefId,\n+        sink: &'a mut DiagnosticSink<'b>,\n+    ) -> DeclValidator<'a, 'b> {\n+        DeclValidator { owner, sink }\n+    }\n+\n+    pub(super) fn validate_item(&mut self, db: &dyn HirDatabase) {\n+        // let def = self.owner.into();\n+        match self.owner {\n+            ModuleDefId::FunctionId(func) => self.validate_func(db, func),\n+            ModuleDefId::AdtId(adt) => self.validate_adt(db, adt),\n+            _ => return,\n+        }\n+    }\n+\n+    fn validate_func(&mut self, db: &dyn HirDatabase, func: FunctionId) {\n+        let data = db.function_data(func);\n+\n+        // 1. Check the function name.\n+        let function_name = data.name.to_string();\n+        let fn_name_replacement = if let Some(new_name) = to_lower_snake_case(&function_name) {\n+            let replacement = Replacement {\n+                current_name: data.name.clone(),\n+                suggested_text: new_name,\n+                expected_case: CaseType::LowerSnakeCase,\n+            };\n+            Some(replacement)\n+        } else {\n+            None\n+        };\n+\n+        // 2. Check the param names.\n+        let mut fn_param_replacements = Vec::new();\n+\n+        for param_name in data.param_names.iter().cloned().filter_map(|i| i) {\n+            let name = param_name.to_string();\n+            if let Some(new_name) = to_lower_snake_case(&name) {\n+                let replacement = Replacement {\n+                    current_name: param_name,\n+                    suggested_text: new_name,\n+                    expected_case: CaseType::LowerSnakeCase,\n+                };\n+                fn_param_replacements.push(replacement);\n+            }\n+        }\n+\n+        // 3. If there is at least one element to spawn a warning on, go to the source map and generate a warning.\n+        self.create_incorrect_case_diagnostic_for_func(\n+            func,\n+            db,\n+            fn_name_replacement,\n+            fn_param_replacements,\n+        )\n+    }\n+\n+    /// Given the information about incorrect names in the function declaration, looks up into the source code\n+    /// for exact locations and adds diagnostics into the sink.\n+    fn create_incorrect_case_diagnostic_for_func(\n+        &mut self,\n+        func: FunctionId,\n+        db: &dyn HirDatabase,\n+        fn_name_replacement: Option<Replacement>,\n+        fn_param_replacements: Vec<Replacement>,\n+    ) {\n+        // XXX: only look at sources if we do have incorrect names\n+        if fn_name_replacement.is_none() && fn_param_replacements.is_empty() {\n+            return;\n+        }\n+\n+        let fn_loc = func.lookup(db.upcast());\n+        let fn_src = fn_loc.source(db.upcast());\n+\n+        if let Some(replacement) = fn_name_replacement {\n+            let ast_ptr = if let Some(name) = fn_src.value.name() {\n+                name\n+            } else {\n+                // We don't want rust-analyzer to panic over this, but it is definitely some kind of error in the logic.\n+                log::error!(\n+                    \"Replacement was generated for a function without a name: {:?}\",\n+                    fn_src\n+                );\n+                return;\n+            };\n+\n+            let diagnostic = IncorrectCase {\n+                file: fn_src.file_id,\n+                ident: AstPtr::new(&ast_ptr).into(),\n+                expected_case: replacement.expected_case,\n+                ident_text: replacement.current_name.to_string(),\n+                suggested_text: replacement.suggested_text,\n+            };\n+\n+            self.sink.push(diagnostic);\n+        }\n+\n+        // let item_tree = db.item_tree(loc.id.file_id);\n+        // let fn_def = &item_tree[fn_loc.id.value];\n+        // let (_, source_map) = db.body_with_source_map(func.into());\n+    }\n+\n+    fn validate_adt(&mut self, db: &dyn HirDatabase, adt: AdtId) {}\n+}\n+\n+fn to_lower_snake_case(ident: &str) -> Option<String> {\n+    let lower_snake_case = stdx::to_lower_snake_case(ident);\n+\n+    if lower_snake_case == ident {\n+        None\n+    } else {\n+        Some(lower_snake_case)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn incorrect_function_name() {\n+        check_diagnostics(\n+            r#\"\n+fn NonSnakeCaseName() {}\n+// ^^^^^^^^^^^^^^^^ Argument `NonSnakeCaseName` should have a snake_case name, e.g. `non_snake_case_name`\n+\"#,\n+        );\n+    }\n+}"}]}