{"sha": "322017b2bc578216a62a297de84b98eb7143923e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMjAxN2IyYmM1NzgyMTZhNjJhMjk3ZGU4NGI5OGViNzE0MzkyM2U=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-03T09:38:16Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-09T11:08:00Z"}, "message": "unify handling of thin and fat pointers by moving primitive type handling out of aggregate handling\n\nAlso, make enum variant handling a bit nicer", "tree": {"sha": "644898c18fae3aad705c4b1f6fe9d08bbe22e70a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/644898c18fae3aad705c4b1f6fe9d08bbe22e70a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/322017b2bc578216a62a297de84b98eb7143923e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/322017b2bc578216a62a297de84b98eb7143923e", "html_url": "https://github.com/rust-lang/rust/commit/322017b2bc578216a62a297de84b98eb7143923e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/322017b2bc578216a62a297de84b98eb7143923e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95593331bfac293478582c2945b7106225500743", "url": "https://api.github.com/repos/rust-lang/rust/commits/95593331bfac293478582c2945b7106225500743", "html_url": "https://github.com/rust-lang/rust/commit/95593331bfac293478582c2945b7106225500743"}], "stats": {"total": 427, "additions": 225, "deletions": 202}, "files": [{"sha": "2aa6b07df90d72c59ab6de91c32fa7ba0c94285d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 206, "deletions": 194, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/322017b2bc578216a62a297de84b98eb7143923e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322017b2bc578216a62a297de84b98eb7143923e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=322017b2bc578216a62a297de84b98eb7143923e", "patch": "@@ -11,15 +11,15 @@\n use std::fmt::Write;\n \n use syntax_pos::symbol::Symbol;\n-use rustc::ty::layout::{self, Size};\n-use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, Size, Align, TyLayout};\n+use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n     Scalar, AllocType, EvalResult, EvalErrorKind\n };\n \n use super::{\n-    OpTy, MPlaceTy, Machine, EvalContext, ScalarMaybeUndef\n+    ValTy, OpTy, MPlaceTy, Machine, EvalContext, ScalarMaybeUndef\n };\n \n macro_rules! validation_failure {\n@@ -140,55 +140,137 @@ fn scalar_format(value: ScalarMaybeUndef) -> String {\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    /// Make sure that `value` is valid for `ty`\n-    fn validate_scalar_type(\n+    /// Make sure that `value` is valid for `ty`, *assuming* `ty` is a primitive type.\n+    fn validate_primitive_type(\n         &self,\n-        value: ScalarMaybeUndef,\n-        size: Size,\n+        value: ValTy<'tcx>,\n         path: &Vec<PathElem>,\n-        ty: Ty,\n+        ref_tracking: Option<&mut RefTracking<'tcx>>,\n         const_mode: bool,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"validate scalar by type: {:#?}, {:#?}, {}\", value, size, ty);\n+        trace!(\"validate scalar by type: {:#?}, {:#?}, {}\",\n+            *value, value.layout.size, value.layout.ty);\n \n         // Go over all the primitive types\n-        match ty.sty {\n+        match value.layout.ty.sty {\n             ty::Bool => {\n+                let value = value.to_scalar_or_undef();\n                 try_validation!(value.to_bool(),\n                     scalar_format(value), path, \"a boolean\");\n             },\n             ty::Char => {\n+                let value = value.to_scalar_or_undef();\n                 try_validation!(value.to_char(),\n                     scalar_format(value), path, \"a valid unicode codepoint\");\n             },\n-            ty::Float(_) | ty::Int(_) | ty::Uint(_) if const_mode => {\n-                // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n-                try_validation!(value.to_bits(size),\n-                    scalar_format(value), path, \"initialized plain bits\");\n-            }\n-            ty::Float(_) | ty::Int(_) | ty::Uint(_) | ty::RawPtr(_) => {\n+            ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n+                let size = value.layout.size;\n+                let value = value.to_scalar_or_undef();\n                 if const_mode {\n-                    // Anything but undef goes\n-                    try_validation!(value.not_undef(),\n-                        scalar_format(value), path, \"a raw pointer\");\n+                    // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n+                    try_validation!(value.to_bits(size),\n+                        scalar_format(value), path, \"initialized plain bits\");\n                 } else {\n-                    // At run-time, for now, we accept *anything* for these types.\n+                    // At run-time, for now, we accept *anything* for these types, including\n+                    // undef. We should fix that, but let's start low.\n+                }\n+            }\n+            ty::RawPtr(..) | ty::Ref(..) => {\n+                // Handle fat pointers. We also check fat raw pointers,\n+                // their metadata must be valid!\n+                // This also checks that the ptr itself is initialized, which\n+                // seems reasonable even for raw pointers.\n+                let place = try_validation!(self.ref_to_mplace(value),\n+                    \"undefined data in pointer\", path);\n+                // Check metadata early, for better diagnostics\n+                if place.layout.is_unsized() {\n+                    match self.tcx.struct_tail(place.layout.ty).sty {\n+                        ty::Dynamic(..) => {\n+                            let vtable = try_validation!(place.extra.unwrap().to_ptr(),\n+                                \"non-pointer vtable in fat pointer\", path);\n+                            try_validation!(self.read_drop_type_from_vtable(vtable),\n+                                \"invalid drop fn in vtable\", path);\n+                            try_validation!(self.read_size_and_align_from_vtable(vtable),\n+                                \"invalid size or align in vtable\", path);\n+                            // FIXME: More checks for the vtable.\n+                        }\n+                        ty::Slice(..) | ty::Str => {\n+                            try_validation!(place.extra.unwrap().to_usize(self),\n+                                \"non-integer slice length in fat pointer\", path);\n+                        }\n+                        ty::Foreign(..) => {\n+                            // Unsized, but not fat.\n+                        }\n+                        _ =>\n+                            bug!(\"Unexpected unsized type tail: {:?}\",\n+                                self.tcx.struct_tail(place.layout.ty)\n+                            ),\n+                    }\n+                }\n+                // for safe ptrs, recursively check\n+                if let ty::Ref(..) = value.layout.ty.sty {\n+                    if const_mode {\n+                        // Skip validation entirely for some external statics\n+                        if let Scalar::Ptr(ptr) = place.ptr {\n+                            let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                            if let Some(AllocType::Static(did)) = alloc_kind {\n+                                // `extern static` cannot be validated as they have no body.\n+                                // They are not even properly aligned.\n+                                // Statics from other crates are already checked.\n+                                // They might be checked at a different type, but for now we want\n+                                // to avoid recursing too deeply.  This is not sound!\n+                                if !did.is_local() || self.tcx.is_foreign_item(did) {\n+                                    return Ok(());\n+                                }\n+                            }\n+                        }\n+                    }\n+                    // Make sure this is non-NULL and aligned\n+                    let (size, align) = self.size_and_align_of(place.extra, place.layout)?;\n+                    match self.memory.check_align(place.ptr, align) {\n+                        Ok(_) => {},\n+                        Err(err) => match err.kind {\n+                            EvalErrorKind::InvalidNullPointerUsage =>\n+                                return validation_failure!(\"NULL reference\", path),\n+                            EvalErrorKind::AlignmentCheckFailed { .. } =>\n+                                return validation_failure!(\"unaligned reference\", path),\n+                            _ =>\n+                                return validation_failure!(\n+                                    \"dangling (deallocated) reference\", path\n+                                ),\n+                        }\n+                    }\n+                    // non-ZST also have to be dereferencable\n+                    if !place.layout.is_zst() {\n+                        let ptr = try_validation!(place.ptr.to_ptr(),\n+                            \"integer pointer in non-ZST reference\", path);\n+                        try_validation!(self.memory.check_bounds(ptr, size, false),\n+                            \"dangling (not entirely in bounds) reference\", path);\n+                    }\n+                    if let Some(ref_tracking) = ref_tracking {\n+                        // Check if we have encountered this pointer+layout combination\n+                        // before.  Proceed recursively even for integer pointers, no\n+                        // reason to skip them! They are (recursively) valid for some ZST,\n+                        // but not for others (e.g. `!` is a ZST).\n+                        let op = place.into();\n+                        if ref_tracking.seen.insert(op) {\n+                            trace!(\"Recursing below ptr {:#?}\", *op);\n+                            ref_tracking.todo.push((op, path_clone_and_deref(path)));\n+                        }\n+                    }\n                 }\n-            },\n-            ty::Ref(..) => {\n-                // This is checked by the recursive reference handling, nothing to do here.\n-                debug_assert!(ty.builtin_deref(true).is_some() && !ty.is_unsafe_ptr());\n             }\n             ty::FnPtr(_sig) => {\n+                let value = value.to_scalar_or_undef();\n                 let ptr = try_validation!(value.to_ptr(),\n                     scalar_format(value), path, \"a pointer\");\n                 let _fn = try_validation!(self.memory.get_fn(ptr),\n                     scalar_format(value), path, \"a function pointer\");\n                 // FIXME: Check if the signature matches\n             }\n-            // This should be all\n+            // This should be all the primitive types\n             ty::Never => bug!(\"Uninhabited type should have been catched earlier\"),\n-            _ => bug!(\"Unexpected primitive type {}\", ty)\n+            _ => bug!(\"Unexpected primitive type {}\", value.layout.ty)\n         }\n         Ok(())\n     }\n@@ -203,19 +285,43 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     ) -> EvalResult<'tcx> {\n         trace!(\"validate scalar by layout: {:#?}, {:#?}, {:#?}\", value, size, layout);\n         let (lo, hi) = layout.valid_range.clone().into_inner();\n-        if lo == u128::min_value() && hi == u128::max_value() {\n+        let max_hi = u128::max_value() >> (128 - size.bits()); // as big as the size fits\n+        assert!(hi <= max_hi);\n+        if lo == 0 && hi == max_hi {\n             // Nothing to check\n             return Ok(());\n         }\n         // At least one value is excluded. Get the bits.\n         let value = try_validation!(value.not_undef(),\n             scalar_format(value), path, format!(\"something in the range {:?}\", layout.valid_range));\n         let bits = match value {\n-            Scalar::Ptr(_) => {\n-                // Comparing a ptr with a range is not meaningfully possible.\n-                // In principle, *if* the pointer is inbonds, we could exclude NULL, but\n-                // that does not seem worth it.\n-                return Ok(());\n+            Scalar::Ptr(ptr) => {\n+                if lo == 1 && hi == max_hi {\n+                    // only NULL is not allowed.\n+                    // We can call `check_align` to check non-NULL-ness, but have to also look\n+                    // for function pointers.\n+                    let non_null =\n+                        self.memory.check_align(\n+                            Scalar::Ptr(ptr), Align::from_bytes(1, 1).unwrap()\n+                        ).is_ok() ||\n+                        self.memory.get_fn(ptr).is_ok();\n+                    if !non_null {\n+                        // could be NULL\n+                        return validation_failure!(\"a potentially NULL pointer\", path);\n+                    }\n+                    return Ok(());\n+                } else {\n+                    // Conservatively, we reject, because the pointer *could* have this\n+                    // value.\n+                    return validation_failure!(\n+                        \"a pointer\",\n+                        path,\n+                        format!(\n+                            \"something that cannot possibly be outside the (wrapping) range {:?}\",\n+                            layout.valid_range\n+                        )\n+                    );\n+                }\n             }\n             Scalar::Bits { bits, size: value_size } => {\n                 assert_eq!(value_size as u64, size.bytes());\n@@ -227,13 +333,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         let in_range = |bound: RangeInclusive<u128>| bound.contains(&bits);\n         if lo > hi {\n             // wrapping around\n-            if in_range(0..=hi) || in_range(lo..=u128::max_value()) {\n+            if in_range(0..=hi) || in_range(lo..=max_hi) {\n                 Ok(())\n             } else {\n                 validation_failure!(\n                     bits,\n                     path,\n-                    format!(\"something in the range {:?} or {:?}\", 0..=hi, lo..=u128::max_value())\n+                    format!(\"something in the range {:?} or {:?}\", 0..=hi, lo..=max_hi)\n                 )\n             }\n         } else {\n@@ -243,59 +349,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 validation_failure!(\n                     bits,\n                     path,\n-                    format!(\"something in the range {:?}\", layout.valid_range)\n-                )\n-            }\n-        }\n-    }\n-\n-    /// Validate a reference, potentially recursively. `place` is assumed to already be\n-    /// dereferenced, i.e. it describes the target.\n-    fn validate_ref(\n-        &self,\n-        place: MPlaceTy<'tcx>,\n-        path: &mut Vec<PathElem>,\n-        ref_tracking: Option<&mut RefTracking<'tcx>>,\n-        const_mode: bool,\n-    ) -> EvalResult<'tcx> {\n-        if const_mode {\n-            // Skip validation entirely for some external statics\n-            if let Scalar::Ptr(ptr) = place.ptr {\n-                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                if let Some(AllocType::Static(did)) = alloc_kind {\n-                    // `extern static` cannot be validated as they have no body.\n-                    // They are not even properly aligned.\n-                    // Statics from other crates are already checked.\n-                    // They might be checked at a different type, but for now we want\n-                    // to avoid recursing too deeply.  This is not sound!\n-                    if !did.is_local() || self.tcx.is_foreign_item(did) {\n-                        return Ok(());\n+                    if hi == max_hi {\n+                        format!(\"something greater or equal to {}\", lo)\n+                    } else {\n+                        format!(\"something in the range {:?}\", layout.valid_range)\n                     }\n-                }\n-            }\n-        }\n-        // Make sure this is non-NULL, aligned and entirely in-bounds.\n-        let (size, align) = self.size_and_align_of(place.extra, place.layout)?;\n-        try_validation!(self.memory.check_align(place.ptr, align),\n-            \"unaligned reference\", path);\n-        if !place.layout.is_zst() {\n-            let ptr = try_validation!(place.ptr.to_ptr(),\n-                \"integer pointer in non-ZST reference\", path);\n-            try_validation!(self.memory.check_bounds(ptr, size, false),\n-                \"dangling reference (not entirely in bounds)\", path);\n-        }\n-        // Check if we have encountered this pointer+layout combination\n-        // before.  Proceed recursively even for integer pointers, no\n-        // reason to skip them! They are valid for some ZST, but not for others\n-        // (e.g. `!` is a ZST).\n-        if let Some(ref_tracking) = ref_tracking {\n-            let op = place.into();\n-            if ref_tracking.seen.insert(op) {\n-                trace!(\"Recursing below ptr {:#?}\", *op);\n-                ref_tracking.todo.push((op, path_clone_and_deref(path)));\n+                )\n             }\n         }\n-        Ok(())\n     }\n \n     /// This function checks the data at `op`.  `op` is assumed to cover valid memory if it\n@@ -316,10 +377,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     ) -> EvalResult<'tcx> {\n         trace!(\"validate_operand: {:?}, {:#?}\", *dest, dest.layout);\n \n-        // Find the right variant.  We have to handle this as a prelude, not via\n-        // proper recursion with the new inner layout, to be able to later nicely\n-        // print the field names of the enum field that is being accessed.\n-        let (variant, dest) = match dest.layout.variants {\n+        // If this is a multi-variant layout, we have find the right one and proceed with that.\n+        // (No good reasoning to make this recursion, but it is equivalent to that.)\n+        let dest = match dest.layout.variants {\n             layout::Variants::NicheFilling { .. } |\n             layout::Variants::Tagged { .. } => {\n                 let variant = match self.read_discriminant(dest) {\n@@ -335,34 +395,28 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             ),\n                     }\n                 };\n-                let inner_dest = self.operand_downcast(dest, variant)?;\n                 // Put the variant projection onto the path, as a field\n                 path.push(PathElem::Field(dest.layout.ty\n                                           .ty_adt_def()\n                                           .unwrap()\n                                           .variants[variant].name));\n+                // Proceed with this variant\n+                let dest = self.operand_downcast(dest, variant)?;\n                 trace!(\"variant layout: {:#?}\", dest.layout);\n-                (variant, inner_dest)\n+                dest\n             },\n-            layout::Variants::Single { index } => {\n-                // Pre-processing for trait objects: Treat them at their real type.\n-                // (We do not do this for slices and strings: For slices it is not needed,\n-                // `mplace_array_fields` does the right thing, and for strings there is no\n-                // real type that would show the actual length.)\n-                let dest = match dest.layout.ty.sty {\n-                    ty::Dynamic(..) => {\n-                        let dest = dest.to_mem_place(); // immediate trait objects are not a thing\n-                        try_validation!(self.unpack_dyn_trait(dest),\n-                            \"invalid vtable in fat pointer\", path).1.into()\n-                    }\n-                    _ => dest\n-                };\n-                (index, dest)\n-            }\n+            layout::Variants::Single { .. } => dest,\n         };\n \n-        // Remember the length, in case we need to truncate\n-        let path_len = path.len();\n+        // First thing, find the real type:\n+        // If it is a trait object, switch to the actual type that was used to create it.\n+        let dest = match dest.layout.ty.sty {\n+            ty::Dynamic(..) => {\n+                let dest = dest.to_mem_place(); // immediate trait objects are not a thing\n+                self.unpack_dyn_trait(dest)?.1.into()\n+            },\n+            _ => dest\n+        };\n \n         // If this is a scalar, validate the scalar layout.\n         // Things can be aggregates and have scalar layout at the same time, and that\n@@ -380,81 +434,49 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             _ => {}\n         }\n \n-        // Validate all fields\n-        match dest.layout.fields {\n+        // Check primitive types.  We do this after checking the scalar layout,\n+        // just to have that done as well.  Primitives can have varying layout,\n+        // so we check them separately and before aggregate handling.\n+        // It is CRITICAL that we get this check right, or we might be\n+        // validating the wrong thing!\n+        let primitive = match dest.layout.fields {\n             // Primitives appear as Union with 0 fields -- except for fat pointers.\n-            // We still check `layout.fields`, not `layout.abi`, because `layout.abi`\n-            // is `Scalar` for newtypes around scalars, but we want to descend through the\n-            // fields to get a proper `path`.\n-            layout::FieldPlacement::Union(0) => {\n-                match dest.layout.abi {\n-                    // check that the scalar is a valid pointer or that its bit range matches the\n-                    // expectation.\n-                    layout::Abi::Scalar(_) => {\n-                        let value = try_validation!(self.read_value(dest),\n-                            \"uninitialized or unrepresentable data\", path);\n-                        self.validate_scalar_type(\n-                            value.to_scalar_or_undef(),\n-                            dest.layout.size,\n-                            &path,\n-                            dest.layout.ty,\n-                            const_mode,\n-                        )?;\n-                        // Recursively check *safe* references\n-                        if dest.layout.ty.builtin_deref(true).is_some() &&\n-                            !dest.layout.ty.is_unsafe_ptr()\n-                        {\n-                            self.validate_ref(\n-                                self.ref_to_mplace(value)?,\n-                                path,\n-                                ref_tracking,\n-                                const_mode,\n-                            )?;\n-                        }\n-                    },\n-                    _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", dest.layout.abi),\n-                }\n-            }\n-            layout::FieldPlacement::Arbitrary { .. }\n-                if dest.layout.ty.builtin_deref(true).is_some() =>\n-            {\n-                // This is a fat pointer. We also check fat raw pointers, their metadata must\n-                // be valid!\n-                let ptr = try_validation!(self.read_value(dest.into()),\n-                    \"undefined location in fat pointer\", path);\n-                let ptr = try_validation!(self.ref_to_mplace(ptr),\n-                    \"undefined metadata in fat pointer\", path);\n-                // check metadata early, for better diagnostics\n-                match self.tcx.struct_tail(ptr.layout.ty).sty {\n-                    ty::Dynamic(..) => {\n-                        let vtable = try_validation!(ptr.extra.unwrap().to_ptr(),\n-                            \"non-pointer vtable in fat pointer\", path);\n-                        try_validation!(self.read_drop_type_from_vtable(vtable),\n-                            \"invalid drop fn in vtable\", path);\n-                        try_validation!(self.read_size_and_align_from_vtable(vtable),\n-                            \"invalid size or align in vtable\", path);\n-                        // FIXME: More checks for the vtable.\n-                    }\n-                    ty::Slice(..) | ty::Str => {\n-                        try_validation!(ptr.extra.unwrap().to_usize(self),\n-                            \"non-integer slice length in fat pointer\", path);\n-                    }\n-                    _ =>\n-                        bug!(\"Unexpected unsized type tail: {:?}\",\n-                            self.tcx.struct_tail(ptr.layout.ty)\n-                        ),\n-                }\n-                // for safe ptrs, recursively check it\n-                if !dest.layout.ty.is_unsafe_ptr() {\n-                    self.validate_ref(ptr, path, ref_tracking, const_mode)?;\n-                }\n-            }\n-            // Compound data structures\n-            layout::FieldPlacement::Union(_) => {\n+            layout::FieldPlacement::Union(0) => true,\n+            _ => dest.layout.ty.builtin_deref(true).is_some(),\n+        };\n+        if primitive {\n+            let value = try_validation!(self.read_value(dest),\n+                \"uninitialized or unrepresentable data\", path);\n+            return self.validate_primitive_type(\n+                value,\n+                &path,\n+                ref_tracking,\n+                const_mode,\n+            );\n+        }\n+\n+        // Validate all fields of compound data structures\n+        let path_len = path.len(); // Remember the length, in case we need to truncate\n+        match dest.layout.fields {\n+            layout::FieldPlacement::Union(..) => {\n                 // We can't check unions, their bits are allowed to be anything.\n                 // The fields don't need to correspond to any bit pattern of the union's fields.\n                 // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n             },\n+            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n+                // Go look at all the fields\n+                for i in 0..offsets.len() {\n+                    let field = self.operand_field(dest, i as u64)?;\n+                    path.push(self.aggregate_field_path_elem(dest.layout, i));\n+                    self.validate_operand(\n+                        field,\n+                        path,\n+                        ref_tracking.as_mut().map(|r| &mut **r),\n+                        const_mode,\n+                    )?;\n+                    path.truncate(path_len);\n+                }\n+            }\n             layout::FieldPlacement::Array { stride, .. } => {\n                 let dest = if dest.layout.is_zst() {\n                     // it's a ZST, the memory content cannot matter\n@@ -526,25 +548,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     }\n                 }\n             },\n-            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                for i in 0..offsets.len() {\n-                    let field = self.operand_field(dest, i as u64)?;\n-                    path.push(self.aggregate_field_path_elem(dest.layout.ty, variant, i));\n-                    self.validate_operand(\n-                        field,\n-                        path,\n-                        ref_tracking.as_mut().map(|r| &mut **r),\n-                        const_mode,\n-                    )?;\n-                    path.truncate(path_len);\n-                }\n-            }\n         }\n         Ok(())\n     }\n \n-    fn aggregate_field_path_elem(&self, ty: Ty<'tcx>, variant: usize, field: usize) -> PathElem {\n-        match ty.sty {\n+    fn aggregate_field_path_elem(&self, layout: TyLayout<'tcx>, field: usize) -> PathElem {\n+        match layout.ty.sty {\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                 let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n@@ -557,15 +566,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n             // enums\n             ty::Adt(def, ..) if def.is_enum() => {\n-                let variant = &def.variants[variant];\n+                let variant = match layout.variants {\n+                    layout::Variants::Single { index } => &def.variants[index],\n+                    _ => bug!(\"aggregate_field_path_elem: got enum but not in a specific variant\"),\n+                };\n                 PathElem::Field(variant.fields[field].ident.name)\n             }\n \n             // other ADTs\n             ty::Adt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n \n             // nothing else has an aggregate layout\n-            _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", ty),\n+            _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", layout.ty),\n         }\n     }\n }"}, {"sha": "8d1ca885b5aba9fe4797ecbe0261d2bff1741c29", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/322017b2bc578216a62a297de84b98eb7143923e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/322017b2bc578216a62a297de84b98eb7143923e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=322017b2bc578216a62a297de84b98eb7143923e", "patch": "@@ -2,23 +2,23 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-nonnull.rs:17:1\n    |\n LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something in the range 1..=18446744073709551615\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-nonnull.rs:20:1\n    |\n LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something in the range 1..=255\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-nonnull.rs:22:1\n    |\n LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something in the range 1..=18446744073709551615\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "7ee13f20dd2d90c87cd6749f987d698286a9a3a4", "filename": "src/test/ui/consts/const-eval/ub-ref.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/322017b2bc578216a62a297de84b98eb7143923e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322017b2bc578216a62a297de84b98eb7143923e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs?ref=322017b2bc578216a62a297de84b98eb7143923e", "patch": "@@ -15,6 +15,9 @@ use std::mem;\n const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n //~^ ERROR this constant likely exhibits undefined behavior\n \n+const NULL: &u16 = unsafe { mem::transmute(0usize) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n //~^ ERROR this constant likely exhibits undefined behavior\n "}, {"sha": "9907c780d2ccba674935f4dd3c457cbf8fe2a2d1", "filename": "src/test/ui/consts/const-eval/ub-ref.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/322017b2bc578216a62a297de84b98eb7143923e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/322017b2bc578216a62a297de84b98eb7143923e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr?ref=322017b2bc578216a62a297de84b98eb7143923e", "patch": "@@ -9,19 +9,27 @@ LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-ref.rs:18:1\n    |\n+LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-ref.rs:21:1\n+   |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/ub-ref.rs:21:1\n+  --> $DIR/ub-ref.rs:24:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered integer pointer in non-ZST reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "4484dd6a14740f12cf06feb11faa1b2361e96e3d", "filename": "src/test/ui/consts/const-eval/union-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/322017b2bc578216a62a297de84b98eb7143923e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/322017b2bc578216a62a297de84b98eb7143923e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr?ref=322017b2bc578216a62a297de84b98eb7143923e", "patch": "@@ -13,7 +13,7 @@ LL | / const FIELD_PATH: Struct = Struct { //~ ERROR this constant likely exhibi\n LL | |     a: 42,\n LL | |     b: unsafe { UNION.field3 },\n LL | | };\n-   | |__^ type validation failed: encountered uninitialized bytes at .b, but expected something in the range 0..=18446744073709551615\n+   | |__^ type validation failed: encountered uninitialized bytes at .b, but expected initialized plain bits\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "c4632ffe30974afccebc505d716d5bcbb5435db7", "filename": "src/test/ui/consts/const-eval/union-ub-fat-ptr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/322017b2bc578216a62a297de84b98eb7143923e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/322017b2bc578216a62a297de84b98eb7143923e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr?ref=322017b2bc578216a62a297de84b98eb7143923e", "patch": "@@ -2,7 +2,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:87:1\n    |\n LL | const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling (not entirely in bounds) reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -26,7 +26,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:99:1\n    |\n LL | const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling (not entirely in bounds) reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}]}