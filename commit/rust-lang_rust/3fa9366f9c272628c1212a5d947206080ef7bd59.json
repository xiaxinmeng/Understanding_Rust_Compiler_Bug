{"sha": "3fa9366f9c272628c1212a5d947206080ef7bd59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYTkzNjZmOWMyNzI2MjhjMTIxMmE1ZDk0NzIwNjA4MGVmN2JkNTk=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-03-11T12:58:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-11T12:58:22Z"}, "message": "Merge pull request #916 from bjorn3/fn_once_for_box_without_alloca\n\nEmulate `<Box<F> as FnOnce>::call_once` without `alloca`", "tree": {"sha": "7459c450d0495d3206e2c9e6ab9a0b352d2e042b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7459c450d0495d3206e2c9e6ab9a0b352d2e042b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fa9366f9c272628c1212a5d947206080ef7bd59", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeaOBuCRBK7hj4Ov3rIwAAdHIIABIAkfcPsJkb86RW9fTJcJrG\nCp526ulWInWfAgyWWm4p1mEAXdU1nCSnrpQ58gOHfVwquAfkCBYPxOe5aEes5/Gf\no+v+dL1Uo3fCKQ3LtV+Yngsm+PlNV/7qLIGx+hMc33My5i8L5KbJQDWTbrY/j9db\nQxn2O1A3wZsA3VIlvViDwF9N6NTQ/UP31tF/+DO9+gpqvBN1aXO1LxohwmJfXmJA\nHJTp1q5btHMAl5ERo7Q2UMw3HWMtRSJKrdQAoCG4ZlDXsL1pYfpn6ONhEur39o1W\nj59mlzhiOAVH0c6/fbG3qs1lz7xxffSNBF2+ZxgSshyZAH4eHNiAXmuOyQRhKTE=\n=yicY\n-----END PGP SIGNATURE-----\n", "payload": "tree 7459c450d0495d3206e2c9e6ab9a0b352d2e042b\nparent 240d56c33c1a0b7097e7b7da475f61fa1d57400f\nparent c5b5b2b702f9d2847e088d0e9e73fea1914793c5\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1583931502 +0100\ncommitter GitHub <noreply@github.com> 1583931502 +0100\n\nMerge pull request #916 from bjorn3/fn_once_for_box_without_alloca\n\nEmulate `<Box<F> as FnOnce>::call_once` without `alloca`"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fa9366f9c272628c1212a5d947206080ef7bd59", "html_url": "https://github.com/rust-lang/rust/commit/3fa9366f9c272628c1212a5d947206080ef7bd59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fa9366f9c272628c1212a5d947206080ef7bd59/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "240d56c33c1a0b7097e7b7da475f61fa1d57400f", "url": "https://api.github.com/repos/rust-lang/rust/commits/240d56c33c1a0b7097e7b7da475f61fa1d57400f", "html_url": "https://github.com/rust-lang/rust/commit/240d56c33c1a0b7097e7b7da475f61fa1d57400f"}, {"sha": "c5b5b2b702f9d2847e088d0e9e73fea1914793c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5b5b2b702f9d2847e088d0e9e73fea1914793c5", "html_url": "https://github.com/rust-lang/rust/commit/c5b5b2b702f9d2847e088d0e9e73fea1914793c5"}], "stats": {"total": 449, "additions": 98, "deletions": 351}, "files": [{"sha": "9c60ac55a9f3147ea6dd52fd41f4a4a3811b4242", "filename": "patches/0015-Remove-usage-of-unsized-locals.patch", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/240d56c33c1a0b7097e7b7da475f61fa1d57400f/patches%2F0015-Remove-usage-of-unsized-locals.patch", "raw_url": "https://github.com/rust-lang/rust/raw/240d56c33c1a0b7097e7b7da475f61fa1d57400f/patches%2F0015-Remove-usage-of-unsized-locals.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0015-Remove-usage-of-unsized-locals.patch?ref=240d56c33c1a0b7097e7b7da475f61fa1d57400f", "patch": "@@ -1,73 +0,0 @@\n-From 7403e2998345ef0650fd50628d7098d4d1e88e5c Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Sat, 6 Apr 2019 12:16:21 +0200\n-Subject: [PATCH] Remove usage of unsized locals\n-\n----\n- src/liballoc/boxed.rs                | 23 -----------------------\n- src/libstd/sys_common/at_exit_imp.rs |  2 ++\n- src/libstd/sys_common/mod.rs         |  1 -\n- src/libstd/sys_common/thread.rs      |  7 +------\n- 4 files changed, 3 insertions(+), 30 deletions(-)\n-\n-diff --git a/src/liballoc/boxed.rs b/src/liballoc/boxed.rs\n-index f6dee7c..0c6a8c0 100644\n---- a/src/liballoc/boxed.rs\n-+++ b/src/liballoc/boxed.rs\n-@@ -694,29 +694,6 @@ impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {\n- #[stable(feature = \"fused\", since = \"1.26.0\")]\n- impl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}\n- \n--#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n--impl<A, F: FnOnce<A> + ?Sized> FnOnce<A> for Box<F> {\n--    type Output = <F as FnOnce<A>>::Output;\n--\n--    extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n--        <F as FnOnce<A>>::call_once(*self, args)\n--    }\n--}\n--\n--#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n--impl<A, F: FnMut<A> + ?Sized> FnMut<A> for Box<F> {\n--    extern \"rust-call\" fn call_mut(&mut self, args: A) -> Self::Output {\n--        <F as FnMut<A>>::call_mut(self, args)\n--    }\n--}\n--\n--#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n--impl<A, F: Fn<A> + ?Sized> Fn<A> for Box<F> {\n--    extern \"rust-call\" fn call(&self, args: A) -> Self::Output {\n--        <F as Fn<A>>::call(self, args)\n--    }\n--}\n--\n- #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n- impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n- \n-diff --git a/src/libstd/sys_common/thread.rs b/src/libstd/sys_common/thread.rs\n-index b2142e7..718bb1c 100644\n---- a/src/libstd/sys_common/thread.rs\n-+++ b/src/libstd/sys_common/thread.rs\n-@@ -6,7 +6,7 @@ pub unsafe fn start_thread(main: *mut u8) {\n-     let _handler = stack_overflow::Handler::new();\n- \n-     // Finally, let's run some code.\n--    Box::from_raw(main as *mut Box<dyn FnOnce()>)()\n-+    Box::from_raw(main as *mut Box<dyn FnBox()>)()\n- }\n- \n- pub fn min_stack() -> usize {\n-diff --git a/src/libstd/sys/unix/thread.rs b/src/libstd/sys/unix/thread.rs\n-index f4a1783..362b537 100644\n---- a/src/libstd/sys/unix/thread.rs\n-+++ b/src/libstd/sys/unix/thread.rs\n-@@ -40,5 +40,7 @@ impl Thread {\n-     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-+        panic!(\"Warning: Threads are not yet fully supported, because cranelift doesn't support atomics.\");\n-+\n-         let p = box p;\n-         let mut native: libc::pthread_t = mem::zeroed();\n-         let mut attr: libc::pthread_attr_t = mem::zeroed();\n--- \n-2.20.1 (Apple Git-117)"}, {"sha": "12dac18f3fa3313fe5718afdb499522141a9f92d", "filename": "patches/0017-Fix-libtest-compilation.patch", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/240d56c33c1a0b7097e7b7da475f61fa1d57400f/patches%2F0017-Fix-libtest-compilation.patch", "raw_url": "https://github.com/rust-lang/rust/raw/240d56c33c1a0b7097e7b7da475f61fa1d57400f/patches%2F0017-Fix-libtest-compilation.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0017-Fix-libtest-compilation.patch?ref=240d56c33c1a0b7097e7b7da475f61fa1d57400f", "patch": "@@ -1,92 +0,0 @@\n-From e06143d3373293d0490df482261cd4a842f1a5c5 Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Thu, 3 Oct 2019 16:51:34 +0200\n-Subject: [PATCH] Fix libtest compilation\n-\n----\n- src/libtest/lib.rs | 28 ++++++++--------------------\n- 1 file changed, 8 insertions(+), 20 deletions(-)\n-\n-diff --git a/src/libtest/lib.rs b/src/libtest/lib.rs\n-index 8b76080..9e65de2 100644\n---- a/src/libtest/lib.rs\n-+++ b/src/libtest/lib.rs\n-@@ -52,7 +52,7 @@ use std::fmt;\n- use std::{\n-     env, io,\n-     io::prelude::Write,\n--    panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n-+    panic::{self, PanicInfo},\n-     process::{self, Command, Termination},\n-     sync::mpsc::{channel, Sender},\n-     sync::{Arc, Mutex},\n-@@ -1493,7 +1493,7 @@ pub fn run_test(\n-     fn run_test_inner(\n-         desc: TestDesc,\n-         monitor_ch: Sender<CompletedTest>,\n--        testfn: Box<dyn FnOnce() + Send>,\n-+        testfn: Box<impl FnOnce() + Send + 'static>,\n-         opts: TestRunOpts,\n-     ) {\n-         let concurrency = opts.concurrency;\n-@@ -1509,7 +1509,7 @@ pub fn run_test(\n-         // If the platform is single-threaded we're just going to run\n-         // the test synchronously, regardless of the concurrency\n-         // level.\n--        let supports_threads = !cfg!(target_os = \"emscripten\") && !cfg!(target_arch = \"wasm32\");\n-+        let supports_threads = false;\n-         if concurrency == Concurrent::Yes && supports_threads {\n-             let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n-             cfg.spawn(runtest).unwrap();\n-@@ -1531,17 +1531,8 @@ pub fn run_test(\n-             // Benchmarks aren't expected to panic, so we run them all in-process.\n-             crate::bench::benchmark(desc, monitor_ch, opts.nocapture, benchfn);\n-         }\n--        DynTestFn(f) => {\n--            match strategy {\n--                RunStrategy::InProcess => (),\n--                _ => panic!(\"Cannot run dynamic test fn out-of-process\"),\n--            };\n--            run_test_inner(\n--                desc,\n--                monitor_ch,\n--                Box::new(move || __rust_begin_short_backtrace(f)),\n--                test_run_opts,\n--            );\n-+        DynTestFn(_f) => {\n-+            unimplemented!();\n-         }\n-         StaticTestFn(f) => run_test_inner(\n-             desc,\n-@@ -1604,10 +1592,10 @@ fn get_result_from_exit_code(desc: &TestDesc, code: i32) -> TestResult {\n- fn run_test_in_process(\n-     desc: TestDesc,\n-     nocapture: bool,\n-     report_time: bool,\n--    testfn: Box<dyn FnOnce() + Send>,\n-+    testfn: Box<impl FnOnce() + Send + 'static>,\n-     monitor_ch: Sender<CompletedTest>,\n-     time_opts: Option<time::TestTimeOptions>,\n- ) {\n-     // Buffer for capturing standard I/O\n-     let data = Arc::new(Mutex::new(Vec::new()));\n-@@ -1623,7 +1611,7 @@ fn run_test_in_process(desc: TestDesc,\n-     };\n- \n-     let start = report_time.then(Instant::now);\n--    let result = catch_unwind(AssertUnwindSafe(testfn));\n-+    let result = Ok::<(), Box<dyn std::any::Any + Send>>(testfn());\n-     let exec_time = start.map(|start| {\n-         let duration = start.elapsed();\n-         TestExecTime(duration)\n-@@ -1688,7 +1676,7 @@ fn spawn_test_subprocess(desc: TestDesc, report_time: bool, monitor_ch: Sender<M\n-     monitor_ch.send(message).unwrap();\n- }\n- \n--fn run_test_in_spawned_subprocess(desc: TestDesc, testfn: Box<dyn FnOnce() + Send>) -> ! {\n-+fn run_test_in_spawned_subprocess(desc: TestDesc, testfn: Box<impl FnOnce() + Send + 'static>) -> ! {\n-     let builtin_panic_hook = panic::take_hook();\n-     let record_result = Arc::new(move |panic_info: Option<&'_ PanicInfo<'_>>| {\n-         let test_result = match panic_info {\n--- \n-2.20.1"}, {"sha": "12a4fbf4425e156bf6c9a4c7a2e5e143764fd1f5", "filename": "patches/0018-Add-FnBox-back.patch", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/240d56c33c1a0b7097e7b7da475f61fa1d57400f/patches%2F0018-Add-FnBox-back.patch", "raw_url": "https://github.com/rust-lang/rust/raw/240d56c33c1a0b7097e7b7da475f61fa1d57400f/patches%2F0018-Add-FnBox-back.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0018-Add-FnBox-back.patch?ref=240d56c33c1a0b7097e7b7da475f61fa1d57400f", "patch": "@@ -1,174 +0,0 @@\n-From 8617310c3c9e192080df6a0c7b4835d3f02e27b9 Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Fri, 1 Nov 2019 20:58:30 +0100\n-Subject: [PATCH] Add FnBox back\n-\n----\n- src/liballoc/boxed.rs                | 13 +++++++++++++\n- src/libstd/prelude/v1.rs             |  2 +-\n- src/libstd/sys/cloudabi/thread.rs    |  2 +-\n- src/libstd/sys/hermit/thread.rs      |  4 ++--\n- src/libstd/sys/unix/thread.rs        |  4 ++--\n- src/libstd/sys_common/at_exit_imp.rs |  6 +++---\n- src/libstd/sys_common/mod.rs         |  2 +-\n- src/libstd/sys_common/thread.rs      |  2 +-\n- src/libstd/thread/mod.rs             |  2 +-\n- 9 files changed, 25 insertions(+), 12 deletions(-)\n-\n-diff --git a/src/liballoc/boxed.rs b/src/liballoc/boxed.rs\n-index ef9b648..e32b870 100644\n---- a/src/liballoc/boxed.rs\n-+++ b/src/liballoc/boxed.rs\n-@@ -1079,3 +1079,16 @@ impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n-         F::poll(Pin::new(&mut *self), cx)\n-     }\n- }\n-+\n-+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-+pub trait FnBox<A>: FnOnce<A> {\n-+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-+    extern \"rust-call\" fn call_box(self: Box<Self>, args: A) -> Self::Output;\n-+}\n-+\n-+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-+impl<A, F: FnOnce<A>> FnBox<A> for F {\n-+    extern \"rust-call\" fn call_box(self: Box<Self>, args: A) -> Self::Output {\n-+        <F as FnOnce<A>>::call_once(*self, args)\n-+    }\n-+}\n-diff --git a/src/libstd/prelude/v1.rs b/src/libstd/prelude/v1.rs\n-index 3e4cf91..1f50eb3 100644\n---- a/src/libstd/prelude/v1.rs\n-+++ b/src/libstd/prelude/v1.rs\n-@@ -94,6 +94,6 @@ pub use core::prelude::v1::{\n- #[stable(feature = \"rust1\", since = \"1.0.0\")]\n- #[doc(no_inline)]\n--pub use crate::boxed::Box;\n-+pub use crate::boxed::{Box, FnBox};\n- #[stable(feature = \"rust1\", since = \"1.0.0\")]\n- #[doc(no_inline)]\n- pub use crate::string::{String, ToString};\n-diff --git a/src/libstd/sys/cloudabi/thread.rs b/src/libstd/sys/cloudabi/thread.rs\n-index 240b6ea..6f71c6b 100644\n---- a/src/libstd/sys/cloudabi/thread.rs\n-+++ b/src/libstd/sys/cloudabi/thread.rs\n-@@ -21,7 +21,7 @@ unsafe impl Sync for Thread {}\n- \n- impl Thread {\n-     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n--    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-+    pub unsafe fn new(stack: usize, p: Box<dyn FnBox()>) -> io::Result<Thread> {\n-         let p = box p;\n-         let mut native: libc::pthread_t = mem::zeroed();\n-         let mut attr: libc::pthread_attr_t = mem::zeroed();\n-diff --git a/src/libstd/sys/hermit/thread.rs b/src/libstd/sys/hermit/thread.rs\n-index 99a9c83..b8bc392 100644\n---- a/src/libstd/sys/hermit/thread.rs\n-+++ b/src/libstd/sys/hermit/thread.rs\n-@@ -44,9 +44,9 @@ unsafe impl Sync for Thread {}\n- pub const DEFAULT_MIN_STACK_SIZE: usize = 262144;\n- \n- impl Thread {\n-     pub unsafe fn new_with_coreid(\n-         _stack: usize,\n--        p: Box<dyn FnOnce()>,\n-+        p: Box<dyn FnBox()>,\n-         core_id: isize,\n-     ) -> io::Result<Thread> {\n-         let p = box p;\n-@@ -67,7 +67,7 @@ impl Thread {\n-         }\n-     }\n- \n--    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-+    pub unsafe fn new(stack: usize, p: Box<dyn FnBox()>) -> io::Result<Thread> {\n-         Thread::new_with_coreid(stack, p, -1 /* = no specific core */)\n-     }\n- \n-diff --git a/src/libstd/sys/unix/thread.rs b/src/libstd/sys/unix/thread.rs\n-index 143cf2f..a6e8faf 100644\n---- a/src/libstd/sys/unix/thread.rs\n-+++ b/src/libstd/sys/unix/thread.rs\n-@@ -38,8 +38,8 @@ unsafe fn pthread_attr_setstacksize(_attr: *mut libc::pthread_attr_t,\n- \n- impl Thread {\n-     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n--    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-+    pub unsafe fn new(stack: usize, p: Box<dyn FnBox()>) -> io::Result<Thread> {\n--        panic!(\"Warning: Threads are not yet fully supported, because cranelift doesn't support atomics.\");\n-+        println!(\"Spawned thread\");\n-\n-         let p = box p;\n-         let mut native: libc::pthread_t = mem::zeroed();\n-diff --git a/src/libstd/sys_common/at_exit_imp.rs b/src/libstd/sys_common/at_exit_imp.rs\n-index cdb72ee..e523333 100644\n---- a/src/libstd/sys_common/at_exit_imp.rs\n-+++ b/src/libstd/sys_common/at_exit_imp.rs\n-@@ -6,7 +6,7 @@ use crate::mem;\n- use crate::ptr;\n- use crate::sys_common::mutex::Mutex;\n- \n--type Queue = Vec<Box<dyn FnOnce()>>;\n-+type Queue = Vec<Box<dyn FnBox()>>;\n- \n- // NB these are specifically not types from `std::sync` as they currently rely\n- // on poisoning and this module needs to operate at a lower level than requiring\n-@@ -53,14 +53,14 @@ pub fn cleanup() {\n-                 let queue: Box<Queue> = Box::from_raw(queue);\n-                 for to_run in *queue {\n-                     // We are not holding any lock, so reentrancy is fine.\n--                    to_run();\n-+                    to_run.call_box(());\n-                 }\n-             }\n-         }\n-     }\n- }\n- \n--pub fn push(f: Box<dyn FnOnce()>) -> bool {\n-+pub fn push(f: Box<dyn FnBox()>) -> bool {\n-     unsafe {\n-         let _guard = LOCK.lock();\n-         if init() {\n-diff --git a/src/libstd/sys_common/mod.rs b/src/libstd/sys_common/mod.rs\n-index 7a0bcd0..668bef2 100644\n---- a/src/libstd/sys_common/mod.rs\n-+++ b/src/libstd/sys_common/mod.rs\n-@@ -113,7 +113,7 @@ pub trait FromInner<Inner> {\n- /// closure will be run once the main thread exits. Returns `Err` to indicate\n- /// that the closure could not be registered, meaning that it is not scheduled\n- /// to be run.\n--pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n-+pub fn at_exit<F: FnBox() + Send + 'static>(f: F) -> Result<(), ()> {\n-     if at_exit_imp::push(Box::new(f)) { Ok(()) } else { Err(()) }\n- }\n- \n-diff --git a/src/libstd/sys_common/thread.rs b/src/libstd/sys_common/thread.rs\n-index c638be9..5c18a18 100644\n---- a/src/libstd/sys_common/thread.rs\n-+++ b/src/libstd/sys_common/thread.rs\n-@@ -10,7 +10,7 @@ pub unsafe fn start_thread(main: *mut u8) {\n-     let _handler = stack_overflow::Handler::new();\n- \n-     // Finally, let's run some code.\n--    Box::from_raw(main as *mut Box<dyn FnBox()>)()\n-+    Box::from_raw(main as *mut Box<dyn FnBox()>).call_box(())\n- }\n- \n- pub fn min_stack() -> usize {\n-diff --git a/src/libstd/thread/mod.rs b/src/libstd/thread/mod.rs\n-index 0ffa6ac..4a3e3d6 100644\n---- a/src/libstd/thread/mod.rs\n-+++ b/src/libstd/thread/mod.rs\n-@@ -485,7 +485,7 @@ impl Builder {\n-             // returning.\n-             native: Some(imp::Thread::new(\n-                 stack_size,\n--                mem::transmute::<Box<dyn FnOnce() + 'a>, Box<dyn FnOnce() + 'static>>(Box::new(\n-+                mem::transmute::<Box<dyn FnBox() + 'a>, Box<dyn FnBox() + 'static>>(Box::new(\n-                     main,\n-                 )),\n-             )?),\n--- \n-2.20.1\n-"}, {"sha": "c1c2521f63d0064229e3d68dc8c2260e80a0247a", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fa9366f9c272628c1212a5d947206080ef7bd59/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/3fa9366f9c272628c1212a5d947206080ef7bd59/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=3fa9366f9c272628c1212a5d947206080ef7bd59", "patch": "@@ -1 +1 @@\n-nightly-2020-03-07\n+nightly-2020-03-10"}, {"sha": "0f62efea632de0ac275472390e62fd7e1e03739a", "filename": "src/abi/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3fa9366f9c272628c1212a5d947206080ef7bd59/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fa9366f9c272628c1212a5d947206080ef7bd59/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=3fa9366f9c272628c1212a5d947206080ef7bd59", "patch": "@@ -288,7 +288,7 @@ fn local_place<'tcx>(\n     fx.local_map[&local]\n }\n \n-pub fn codegen_fn_prelude(fx: &mut FunctionCx<'_, '_, impl Backend>, start_block: Block) {\n+pub fn codegen_fn_prelude(fx: &mut FunctionCx<'_, '_, impl Backend>, start_block: Block, should_codegen_locals: bool) {\n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n     #[cfg(debug_assertions)]\n@@ -405,13 +405,17 @@ pub fn codegen_fn_prelude(fx: &mut FunctionCx<'_, '_, impl Backend>, start_block\n         }\n     }\n \n-    for local in fx.mir.vars_and_temps_iter() {\n-        let ty = fx.monomorphize(&fx.mir.local_decls[local].ty);\n-        let layout = fx.layout_of(ty);\n+    // HACK should_codegen_locals required for the ``implement `<Box<F> as FnOnce>::call_once`\n+    // without `alloca``` hack in `base::trans_fn`.\n+    if should_codegen_locals {\n+        for local in fx.mir.vars_and_temps_iter() {\n+            let ty = fx.monomorphize(&fx.mir.local_decls[local].ty);\n+            let layout = fx.layout_of(ty);\n \n-        let is_ssa = ssa_analyzed[local] == crate::analyze::SsaKind::Ssa;\n+            let is_ssa = ssa_analyzed[local] == crate::analyze::SsaKind::Ssa;\n \n-        local_place(fx, local, layout, is_ssa);\n+            local_place(fx, local, layout, is_ssa);\n+        }\n     }\n \n     fx.bcx"}, {"sha": "1d73c69dc001de9bfbaba4a30ee4f3bcf5bc5041", "filename": "src/base.rs", "status": "modified", "additions": 87, "deletions": 5, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3fa9366f9c272628c1212a5d947206080ef7bd59/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fa9366f9c272628c1212a5d947206080ef7bd59/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=3fa9366f9c272628c1212a5d947206080ef7bd59", "patch": "@@ -57,14 +57,96 @@ pub fn trans_fn<'clif, 'tcx, B: Backend + 'static>(\n         source_info_set: indexmap::IndexSet::new(),\n     };\n \n-    if fx.mir.args_iter().any(|arg| fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty)).abi.is_uninhabited()) {\n-        let entry_block = fx.bcx.create_block();\n-        fx.bcx.append_block_params_for_function_params(entry_block);\n-        fx.bcx.switch_to_block(entry_block);\n+    let arg_uninhabited = fx.mir.args_iter().any(|arg| fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n+    let is_call_once_for_box = name.starts_with(\"_ZN83_$LT$alloc..boxed..Box$LT$F$GT$$u20$as$u20$core..ops..function..FnOnce$LT$A$GT$$GT$9call_once\");\n+\n+    if arg_uninhabited {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n         crate::trap::trap_unreachable(&mut fx, \"function has uninhabited argument\");\n+    } else if is_call_once_for_box {\n+        // HACK implement `<Box<F> as FnOnce>::call_once` without `alloca`.\n+        tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block, false));\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        let bb_data = &fx.mir.basic_blocks()[START_BLOCK];\n+        let destination = match &bb_data.terminator().kind {\n+            TerminatorKind::Call {\n+                func,\n+                args,\n+                destination,\n+                cleanup: _,\n+                from_hir_call: _,\n+            } => {\n+                assert_eq!(args.len(), 2);\n+\n+                let closure_arg = Local::new(1);\n+                let closure_local = args[0].place().unwrap().as_local().unwrap();\n+                assert_eq!(fx.mir.local_decls[closure_local].ty, fx.mir.local_decls[closure_arg].ty.builtin_deref(true).unwrap().ty);\n+                let closure_deref = fx.local_map[&closure_arg].place_deref(&mut fx);\n+                fx.local_map.insert(closure_local, closure_deref);\n+\n+                let args_arg = Local::new(2);\n+                let args_local = args[1].place().unwrap().as_local().unwrap();\n+                assert_eq!(fx.mir.local_decls[args_local].ty, fx.mir.local_decls[args_arg].ty);\n+                fx.local_map.insert(args_local, fx.local_map[&args_arg]);\n+\n+                fx.tcx.sess.time(\"codegen call\", || crate::abi::codegen_terminator_call(\n+                    &mut fx,\n+                    bb_data.terminator().source_info.span,\n+                    func,\n+                    args,\n+                    destination,\n+                ));\n+                destination.map(|(_ret_place, ret_block)| ret_block)\n+            }\n+            _ => unreachable!(),\n+        };\n+\n+        let destination = if let Some(destination) = destination {\n+            fx.bcx.switch_to_block(fx.block_map[destination]);\n+            let bb_data = &fx.mir.basic_blocks()[destination];\n+            match &bb_data.terminator().kind {\n+                TerminatorKind::Call {\n+                    func,\n+                    args,\n+                    destination,\n+                    cleanup: _,\n+                    from_hir_call: _,\n+                } => {\n+                    match destination {\n+                        Some((ret_place, _ret_block)) => {\n+                            fx.local_map.insert(ret_place.as_local().unwrap(), CPlace::no_place(fx.layout_of(fx.tcx.mk_unit())));\n+                        }\n+                        None => {}\n+                    }\n+\n+                    assert_eq!(args.len(), 1);\n+                    fx.tcx.sess.time(\"codegen call\", || crate::abi::codegen_terminator_call(\n+                        &mut fx,\n+                        bb_data.terminator().source_info.span,\n+                        func,\n+                        args,\n+                        destination,\n+                    ));\n+                    destination.map(|(_ret_place, ret_block)| ret_block)\n+                }\n+                _ => unreachable!(),\n+            }\n+        } else {\n+            None\n+        };\n+\n+        if let Some(destination) = destination {\n+            fx.bcx.switch_to_block(fx.block_map[destination]);\n+            let bb_data = &fx.mir.basic_blocks()[destination];\n+            match &bb_data.terminator().kind {\n+                TerminatorKind::Return => crate::abi::codegen_return(&mut fx),\n+                _ => unreachable!(),\n+            }\n+        }\n     } else {\n         tcx.sess.time(\"codegen clif ir\", || {\n-            tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block));\n+            tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block, true));\n             codegen_fn_content(&mut fx);\n         });\n     }"}]}