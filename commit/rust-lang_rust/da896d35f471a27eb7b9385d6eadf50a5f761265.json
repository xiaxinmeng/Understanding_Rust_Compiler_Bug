{"sha": "da896d35f471a27eb7b9385d6eadf50a5f761265", "node_id": "C_kwDOAAsO6NoAKGRhODk2ZDM1ZjQ3MWEyN2ViN2I5Mzg1ZDZlYWRmNTBhNWY3NjEyNjU", "commit": {"author": {"name": "Lo\u00efc BRANSTETT", "email": "lolo.branstett@numericable.fr", "date": "2022-02-19T22:06:11Z"}, "committer": {"name": "Lo\u00efc BRANSTETT", "email": "lolo.branstett@numericable.fr", "date": "2022-02-22T21:41:49Z"}, "message": "Improve CheckCfg internal representation", "tree": {"sha": "4ccc8f3571c097b8c232031bbcebe61b81454d0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ccc8f3571c097b8c232031bbcebe61b81454d0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da896d35f471a27eb7b9385d6eadf50a5f761265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da896d35f471a27eb7b9385d6eadf50a5f761265", "html_url": "https://github.com/rust-lang/rust/commit/da896d35f471a27eb7b9385d6eadf50a5f761265", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da896d35f471a27eb7b9385d6eadf50a5f761265/comments", "author": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb4ee81ef555126e49b3e9f16ca6f12a3264a451", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb4ee81ef555126e49b3e9f16ca6f12a3264a451", "html_url": "https://github.com/rust-lang/rust/commit/cb4ee81ef555126e49b3e9f16ca6f12a3264a451"}], "stats": {"total": 101, "additions": 58, "deletions": 43}, "files": [{"sha": "cd2e150a1907d51eef88d36a807cfd01664d892f", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/da896d35f471a27eb7b9385d6eadf50a5f761265/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da896d35f471a27eb7b9385d6eadf50a5f761265/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=da896d35f471a27eb7b9385d6eadf50a5f761265", "patch": "@@ -463,27 +463,30 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n             MetaItemKind::NameValue(..) | MetaItemKind::Word => {\n                 let name = cfg.ident().expect(\"multi-segment cfg predicate\").name;\n                 let value = cfg.value_str();\n-                if sess.check_config.names_checked && !sess.check_config.names_valid.contains(&name)\n-                {\n-                    sess.buffer_lint(\n-                        UNEXPECTED_CFGS,\n-                        cfg.span,\n-                        CRATE_NODE_ID,\n-                        \"unexpected `cfg` condition name\",\n-                    );\n-                }\n-                if let Some(val) = value {\n-                    if sess.check_config.values_checked.contains(&name)\n-                        && !sess.check_config.values_valid.contains(&(name, val))\n-                    {\n+                if let Some(names_valid) = &sess.check_config.names_valid {\n+                    if !names_valid.contains(&name) {\n                         sess.buffer_lint(\n                             UNEXPECTED_CFGS,\n                             cfg.span,\n                             CRATE_NODE_ID,\n-                            \"unexpected `cfg` condition value\",\n+                            \"unexpected `cfg` condition name\",\n                         );\n                     }\n                 }\n+                if let Some(val) = value {\n+                    if let Some(values_valid) = &sess.check_config.values_valid {\n+                        if let Some(values) = values_valid.get(&name) {\n+                            if !values.contains(&val) {\n+                                sess.buffer_lint(\n+                                    UNEXPECTED_CFGS,\n+                                    cfg.span,\n+                                    CRATE_NODE_ID,\n+                                    \"unexpected `cfg` condition value\",\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n                 sess.config.contains(&(name, value))\n             }\n         }"}, {"sha": "5e0d59bf1b13610460431465faea3179bc748454", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da896d35f471a27eb7b9385d6eadf50a5f761265/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da896d35f471a27eb7b9385d6eadf50a5f761265/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=da896d35f471a27eb7b9385d6eadf50a5f761265", "patch": "@@ -169,11 +169,12 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                     Ok(meta_item) if parser.token == token::Eof => {\n                         if let Some(args) = meta_item.meta_item_list() {\n                             if meta_item.has_name(sym::names) {\n-                                cfg.names_checked = true;\n+                                let names_valid =\n+                                    cfg.names_valid.get_or_insert_with(|| FxHashSet::default());\n                                 for arg in args {\n                                     if arg.is_word() && arg.ident().is_some() {\n                                         let ident = arg.ident().expect(\"multi-segment cfg key\");\n-                                        cfg.names_valid.insert(ident.name.to_string());\n+                                        names_valid.insert(ident.name.to_string());\n                                     } else {\n                                         error!(\"`names()` arguments must be simple identifers\");\n                                     }\n@@ -182,14 +183,19 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                             } else if meta_item.has_name(sym::values) {\n                                 if let Some((name, values)) = args.split_first() {\n                                     if name.is_word() && name.ident().is_some() {\n+                                        let values_valid = cfg\n+                                            .values_valid\n+                                            .get_or_insert_with(|| FxHashMap::default());\n                                         let ident = name.ident().expect(\"multi-segment cfg key\");\n-                                        cfg.values_checked.insert(ident.to_string());\n+                                        let ident_values = values_valid\n+                                            .entry(ident.to_string())\n+                                            .or_insert_with(|| FxHashSet::default());\n+\n                                         for val in values {\n                                             if let Some(LitKind::Str(s, _)) =\n                                                 val.literal().map(|lit| &lit.kind)\n                                             {\n-                                                cfg.values_valid\n-                                                    .insert((ident.to_string(), s.to_string()));\n+                                                ident_values.insert(s.to_string());\n                                             } else {\n                                                 error!(\n                                                     \"`values()` arguments must be string literals\"\n@@ -219,7 +225,11 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n             );\n         }\n \n-        cfg.names_valid.extend(cfg.values_checked.iter().cloned());\n+        if let Some(values_valid) = &cfg.values_valid {\n+            if let Some(names_valid) = &mut cfg.names_valid {\n+                names_valid.extend(values_valid.keys().cloned());\n+            }\n+        }\n         cfg\n     })\n }"}, {"sha": "e0a3cc78b1772e7a84c96dac702fb8bc6f80aad0", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/da896d35f471a27eb7b9385d6eadf50a5f761265/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da896d35f471a27eb7b9385d6eadf50a5f761265/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=da896d35f471a27eb7b9385d6eadf50a5f761265", "patch": "@@ -8,7 +8,7 @@ use crate::search_paths::SearchPath;\n use crate::utils::{CanonicalizedPath, NativeLib, NativeLibKind};\n use crate::{early_error, early_warn, Session};\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::impl_stable_hash_via_hash;\n \n use rustc_target::abi::{Align, TargetDataLayout};\n@@ -1023,34 +1023,28 @@ pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> CrateConfig\n \n /// The parsed `--check-cfg` options\n pub struct CheckCfg<T = String> {\n-    /// Set if `names()` checking is enabled\n-    pub names_checked: bool,\n-    /// The union of all `names()`\n-    pub names_valid: FxHashSet<T>,\n-    /// The set of names for which `values()` was used\n-    pub values_checked: FxHashSet<T>,\n-    /// The set of all (name, value) pairs passed in `values()`\n-    pub values_valid: FxHashSet<(T, T)>,\n+    /// The set of all `names()`, if none no names checking is performed\n+    pub names_valid: Option<FxHashSet<T>>,\n+    /// The set of all `values()`, if none no values chcking is performed\n+    pub values_valid: Option<FxHashMap<T, FxHashSet<T>>>,\n }\n \n impl<T> Default for CheckCfg<T> {\n     fn default() -> Self {\n-        CheckCfg {\n-            names_checked: false,\n-            names_valid: FxHashSet::default(),\n-            values_checked: FxHashSet::default(),\n-            values_valid: FxHashSet::default(),\n-        }\n+        CheckCfg { names_valid: Default::default(), values_valid: Default::default() }\n     }\n }\n \n impl<T> CheckCfg<T> {\n     fn map_data<O: Eq + Hash>(&self, f: impl Fn(&T) -> O) -> CheckCfg<O> {\n         CheckCfg {\n-            names_checked: self.names_checked,\n-            names_valid: self.names_valid.iter().map(|a| f(a)).collect(),\n-            values_checked: self.values_checked.iter().map(|a| f(a)).collect(),\n-            values_valid: self.values_valid.iter().map(|(a, b)| (f(a), f(b))).collect(),\n+            names_valid: self\n+                .names_valid\n+                .as_ref()\n+                .map(|names_valid| names_valid.iter().map(|a| f(a)).collect()),\n+            values_valid: self.values_valid.as_ref().map(|values_valid| {\n+                values_valid.iter().map(|(a, b)| (f(a), b.iter().map(|b| f(b)).collect())).collect()\n+            }),\n         }\n     }\n }\n@@ -1090,17 +1084,25 @@ impl CrateCheckConfig {\n             sym::doctest,\n             sym::feature,\n         ];\n-        for &name in WELL_KNOWN_NAMES {\n-            self.names_valid.insert(name);\n+        if let Some(names_valid) = &mut self.names_valid {\n+            for &name in WELL_KNOWN_NAMES {\n+                names_valid.insert(name);\n+            }\n         }\n     }\n \n     /// Fills a `CrateCheckConfig` with configuration names and values that are actually active.\n     pub fn fill_actual(&mut self, cfg: &CrateConfig) {\n         for &(k, v) in cfg {\n-            self.names_valid.insert(k);\n+            if let Some(names_valid) = &mut self.names_valid {\n+                names_valid.insert(k);\n+            }\n             if let Some(v) = v {\n-                self.values_valid.insert((k, v));\n+                if let Some(values_valid) = &mut self.values_valid {\n+                    values_valid.entry(k).and_modify(|values| {\n+                        values.insert(v);\n+                    });\n+                }\n             }\n         }\n     }"}]}