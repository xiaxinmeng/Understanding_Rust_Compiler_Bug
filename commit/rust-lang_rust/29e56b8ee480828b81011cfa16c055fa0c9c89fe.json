{"sha": "29e56b8ee480828b81011cfa16c055fa0c9c89fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZTU2YjhlZTQ4MDgyOGI4MTAxMWNmYTE2YzA1NWZhMGM5Yzg5ZmU=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-25T21:56:55Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-25T22:16:58Z"}, "message": "Support all coercion places", "tree": {"sha": "45f901e9a92ffc8cf1d90a3fef1db45a70df632a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45f901e9a92ffc8cf1d90a3fef1db45a70df632a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29e56b8ee480828b81011cfa16c055fa0c9c89fe", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl2L51oACgkQztOS3gxI\nPQA2OxAApIiOu9XE+GwgyMsiwQIqSSSuXFC1t4nT9TFZdm3GeqbaWeAGE7XKpLf5\nmbrxI0Uy04LE3Pwkfapo5RPplLGWXtWyiXh55aByf/d+k2dUYvUVd5guN4oHY1Cd\nyEYRiGYMGlLS+LX7tYhZ38NJLfw129/xHRythHWGL69I7Q4HWBb0NTTsorROP9Vj\n/mCsQcwSdHepOUM5rGQYZuMGS+XqIM8F+8+t4ZTsdoOmL4mKiO3ziNREXImDEsQm\nNHxtqZRVEjwzMApusip5F+J5ZEZnikA2kNVaQ2MRC47bEw9FhmzQDlhWM4zOnnkb\nrXuMWgKN4ylBvnRE97xrJ9U30vlv+vfWsASvwc/dIFUCMnhtLZVcF3CiR9b3Vw5T\nCRms05+4YbfMlXmF/POmxEwU5xHQNsEFvnGYuRgJMOnULF48iaPAdzrTiuygQ7+U\nsJ8dMQzgBGMf4sHE8adBmullfxoSTGzN17dzXyJDgkhheRQEdRMu2W/F1IUMXaey\n7xyAJXIA2t/mXvgEgklSkUr9yDb0Mk3LMVikS2ogedolryZ46Pwhy64WKoGgC3og\n6uWISHg1U89jBkfJjYymR51XOHMOjeSBTZ31f/RS9UMIMVS8adtqIMj6AjDnoEmI\n48uDiUHyBLxCN6bSn6KI2GLliBzBdfDGSNC9s/Pj6JuzcsgryT8=\n=etEP\n-----END PGP SIGNATURE-----", "payload": "tree 45f901e9a92ffc8cf1d90a3fef1db45a70df632a\nparent 5807e261c27e4964fc6a8d2b8cf02e548292b940\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1569448615 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1569449818 +0800\n\nSupport all coercion places\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29e56b8ee480828b81011cfa16c055fa0c9c89fe", "html_url": "https://github.com/rust-lang/rust/commit/29e56b8ee480828b81011cfa16c055fa0c9c89fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29e56b8ee480828b81011cfa16c055fa0c9c89fe/comments", "author": null, "committer": null, "parents": [{"sha": "5807e261c27e4964fc6a8d2b8cf02e548292b940", "url": "https://api.github.com/repos/rust-lang/rust/commits/5807e261c27e4964fc6a8d2b8cf02e548292b940", "html_url": "https://github.com/rust-lang/rust/commit/5807e261c27e4964fc6a8d2b8cf02e548292b940"}], "stats": {"total": 312, "additions": 216, "deletions": 96}, "files": [{"sha": "db337735725d1efea691d44cd98b332b96ffff01", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 57, "deletions": 25, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/29e56b8ee480828b81011cfa16c055fa0c9c89fe/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e56b8ee480828b81011cfa16c055fa0c9c89fe/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=29e56b8ee480828b81011cfa16c055fa0c9c89fe", "patch": "@@ -14,7 +14,7 @@\n //! the `ena` crate, which is extracted from rustc.\n \n use std::borrow::Cow;\n-use std::iter::repeat;\n+use std::iter::{repeat, repeat_with};\n use std::mem;\n use std::ops::Index;\n use std::sync::Arc;\n@@ -876,10 +876,23 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     /// Infer type of expression with possibly implicit coerce to the expected type.\n+    /// Return the type after possible coercion.\n     fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(expr, &expected);\n-        self.coerce(&ty, &expected.ty);\n-        ty\n+        let ty = if !self.coerce(&ty, &expected.ty) {\n+            self.result\n+                .type_mismatches\n+                .insert(expr, TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() });\n+            // Return actual type when type mismatch.\n+            // This is needed for diagnostic when return type mismatch.\n+            ty\n+        } else if expected.ty == Ty::Unknown {\n+            ty\n+        } else {\n+            expected.ty.clone()\n+        };\n+\n+        self.resolve_ty_as_possible(&mut vec![], ty)\n     }\n \n     /// Merge two types from different branches, with possible implicit coerce.\n@@ -1328,6 +1341,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     self.write_variant_resolution(tgt_expr.into(), variant);\n                 }\n \n+                self.unify(&ty, &expected.ty);\n+\n                 let substs = ty.substs().unwrap_or_else(Substs::empty);\n                 for (field_idx, field) in fields.iter().enumerate() {\n                     let field_ty = def_id\n@@ -1343,7 +1358,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         })\n                         .map_or(Ty::Unknown, |field| field.ty(self.db))\n                         .subst(&substs);\n-                    self.infer_expr(field.expr, &Expectation::has_type(field_ty));\n+                    self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n                 }\n                 if let Some(expr) = spread {\n                     self.infer_expr(*expr, &Expectation::has_type(ty.clone()));\n@@ -1513,35 +1528,41 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Ty::Unknown\n             }\n             Expr::Tuple { exprs } => {\n-                let mut ty_vec = Vec::with_capacity(exprs.len());\n-                for arg in exprs.iter() {\n-                    ty_vec.push(self.infer_expr(*arg, &Expectation::none()));\n+                let mut tys = match &expected.ty {\n+                    ty_app!(TypeCtor::Tuple { .. }, st) => st\n+                        .iter()\n+                        .cloned()\n+                        .chain(repeat_with(|| self.new_type_var()))\n+                        .take(exprs.len())\n+                        .collect::<Vec<_>>(),\n+                    _ => (0..exprs.len()).map(|_| self.new_type_var()).collect(),\n+                };\n+\n+                for (expr, ty) in exprs.iter().zip(tys.iter_mut()) {\n+                    self.infer_expr_coerce(*expr, &Expectation::has_type(ty.clone()));\n                 }\n \n-                Ty::apply(\n-                    TypeCtor::Tuple { cardinality: ty_vec.len() as u16 },\n-                    Substs(ty_vec.into()),\n-                )\n+                Ty::apply(TypeCtor::Tuple { cardinality: tys.len() as u16 }, Substs(tys.into()))\n             }\n             Expr::Array(array) => {\n                 let elem_ty = match &expected.ty {\n-                    Ty::Apply(a_ty) => match a_ty.ctor {\n-                        TypeCtor::Slice | TypeCtor::Array => {\n-                            Ty::clone(&a_ty.parameters.as_single())\n-                        }\n-                        _ => self.new_type_var(),\n-                    },\n+                    ty_app!(TypeCtor::Array, st) | ty_app!(TypeCtor::Slice, st) => {\n+                        st.as_single().clone()\n+                    }\n                     _ => self.new_type_var(),\n                 };\n \n                 match array {\n                     Array::ElementList(items) => {\n                         for expr in items.iter() {\n-                            self.infer_expr(*expr, &Expectation::has_type(elem_ty.clone()));\n+                            self.infer_expr_coerce(*expr, &Expectation::has_type(elem_ty.clone()));\n                         }\n                     }\n                     Array::Repeat { initializer, repeat } => {\n-                        self.infer_expr(*initializer, &Expectation::has_type(elem_ty.clone()));\n+                        self.infer_expr_coerce(\n+                            *initializer,\n+                            &Expectation::has_type(elem_ty.clone()),\n+                        );\n                         self.infer_expr(\n                             *repeat,\n                             &Expectation::has_type(Ty::simple(TypeCtor::Int(\n@@ -1588,22 +1609,33 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Statement::Let { pat, type_ref, initializer } => {\n                     let decl_ty =\n                         type_ref.as_ref().map(|tr| self.make_ty(tr)).unwrap_or(Ty::Unknown);\n-                    let decl_ty = self.insert_type_vars(decl_ty);\n+\n+                    // Always use the declared type when specified\n+                    let mut ty = decl_ty.clone();\n+\n                     if let Some(expr) = initializer {\n-                        self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()));\n+                        let actual_ty =\n+                            self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()));\n+                        if decl_ty == Ty::Unknown {\n+                            ty = actual_ty;\n+                        }\n                     }\n \n-                    let ty = self.resolve_ty_as_possible(&mut vec![], decl_ty);\n+                    let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n                     self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr(expr) => {\n                     self.infer_expr(*expr, &Expectation::none());\n                 }\n             }\n         }\n-        let ty =\n-            if let Some(expr) = tail { self.infer_expr_inner(expr, expected) } else { Ty::unit() };\n-        ty\n+\n+        if let Some(expr) = tail {\n+            self.infer_expr_coerce(expr, expected)\n+        } else {\n+            self.coerce(&Ty::unit(), &expected.ty);\n+            Ty::unit()\n+        }\n     }\n \n     fn check_call_arguments(&mut self, args: &[ExprId], param_tys: &[Ty]) {"}, {"sha": "4362bb27a3c65ef6f4c58d37aae47a76737212b0", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/29e56b8ee480828b81011cfa16c055fa0c9c89fe/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e56b8ee480828b81011cfa16c055fa0c9c89fe/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=29e56b8ee480828b81011cfa16c055fa0c9c89fe", "patch": "@@ -239,17 +239,23 @@ fn test() {\n     let a = 1isize;\n     let b: usize = 1;\n     let c = b;\n+    let d: u32;\n+    let e;\n+    let f: i32 = e;\n }\n \"#),\n         @r###\"\n-\n-    [11; 71) '{     ...= b; }': ()\n+    [11; 118) '{     ...= e; }': ()\n     [21; 22) 'a': isize\n     [25; 31) '1isize': isize\n     [41; 42) 'b': usize\n     [52; 53) '1': usize\n     [63; 64) 'c': usize\n     [67; 68) 'b': usize\n+    [78; 79) 'd': u32\n+    [94; 95) 'e': i32\n+    [105; 106) 'f': i32\n+    [114; 115) 'e': i32\n     \"###\n     );\n }\n@@ -331,14 +337,14 @@ fn test() {\n \"#),\n         @r###\"\n     [45; 49) 'self': &[T]\n-    [56; 79) '{     ...     }': !\n+    [56; 79) '{     ...     }': T\n     [66; 73) 'loop {}': !\n     [71; 73) '{}': ()\n     [133; 160) '{     ...o\"); }': ()\n     [139; 149) '<[_]>::foo': fn foo<u8>(&[T]) -> T\n     [139; 157) '<[_]>:...\"foo\")': u8\n     [150; 156) 'b\"foo\"': &[u8]\n-\"###\n+    \"###\n     );\n }\n \n@@ -817,7 +823,7 @@ struct A<T>(T);\n \n impl<T> A<T> {\n     fn foo(&self) -> &T {\n-        self.0\n+        &self.0\n     }\n }\n \n@@ -837,28 +843,29 @@ fn test() {\n         @r###\"\n     [68; 72) 'self': &Self\n     [139; 143) 'self': &A<T>\n-    [151; 173) '{     ...     }': T\n-    [161; 165) 'self': &A<T>\n-    [161; 167) 'self.0': T\n-    [254; 258) 'self': &B<T>\n-    [277; 300) '{     ...     }': &T\n-    [287; 294) '&self.0': &T\n-    [288; 292) 'self': &B<T>\n-    [288; 294) 'self.0': T\n-    [314; 352) '{     ...))); }': ()\n-    [324; 325) 't': &i32\n-    [328; 334) 'A::foo': fn foo<i32>(&A<T>) -> &T\n-    [328; 349) 'A::foo...42))))': &i32\n-    [335; 348) '&&B(B(A(42)))': &&B<B<A<i32>>>\n-    [336; 348) '&B(B(A(42)))': &B<B<A<i32>>>\n-    [337; 338) 'B': B<B<A<i32>>>(T) -> B<T>\n-    [337; 348) 'B(B(A(42)))': B<B<A<i32>>>\n-    [339; 340) 'B': B<A<i32>>(T) -> B<T>\n-    [339; 347) 'B(A(42))': B<A<i32>>\n-    [341; 342) 'A': A<i32>(T) -> A<T>\n-    [341; 346) 'A(42)': A<i32>\n-    [343; 345) '42': i32\n-\"###\n+    [151; 174) '{     ...     }': &T\n+    [161; 168) '&self.0': &T\n+    [162; 166) 'self': &A<T>\n+    [162; 168) 'self.0': T\n+    [255; 259) 'self': &B<T>\n+    [278; 301) '{     ...     }': &T\n+    [288; 295) '&self.0': &T\n+    [289; 293) 'self': &B<T>\n+    [289; 295) 'self.0': T\n+    [315; 353) '{     ...))); }': ()\n+    [325; 326) 't': &i32\n+    [329; 335) 'A::foo': fn foo<i32>(&A<T>) -> &T\n+    [329; 350) 'A::foo...42))))': &i32\n+    [336; 349) '&&B(B(A(42)))': &&B<B<A<i32>>>\n+    [337; 349) '&B(B(A(42)))': &B<B<A<i32>>>\n+    [338; 339) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [338; 349) 'B(B(A(42)))': B<B<A<i32>>>\n+    [340; 341) 'B': B<A<i32>>(T) -> B<T>\n+    [340; 348) 'B(A(42))': B<A<i32>>\n+    [342; 343) 'A': A<i32>(T) -> A<T>\n+    [342; 347) 'A(42)': A<i32>\n+    [344; 346) '42': i32\n+    \"###\n     );\n }\n \n@@ -1109,13 +1116,12 @@ fn test(x: &str, y: isize) {\n \n     let b = [a, [\"b\"]];\n     let x: [u8; 0] = [];\n-    let z: &[u8] = &[1, 2, 3];\n }\n \"#),\n         @r###\"\n     [9; 10) 'x': &str\n     [18; 19) 'y': isize\n-    [28; 324) '{     ... 3]; }': ()\n+    [28; 293) '{     ... []; }': ()\n     [38; 39) 'a': [&str;_]\n     [42; 45) '[x]': [&str;_]\n     [43; 44) 'x': &str\n@@ -1165,12 +1171,6 @@ fn test(x: &str, y: isize) {\n     [260; 263) '\"b\"': &str\n     [275; 276) 'x': [u8;_]\n     [288; 290) '[]': [u8;_]\n-    [300; 301) 'z': &[u8]\n-    [311; 321) '&[1, 2, 3]': &[u8;_]\n-    [312; 321) '[1, 2, 3]': [u8;_]\n-    [313; 314) '1': u8\n-    [316; 317) '2': u8\n-    [319; 320) '3': u8\n     \"###\n     );\n }\n@@ -1892,8 +1892,7 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n-    [80; 104) '{     ...     }': !\n+    [80; 104) '{     ...     }': Gen<T>\n     [90; 98) 'loop { }': !\n     [95; 98) '{ }': ()\n     [118; 146) '{     ...e(); }': ()\n@@ -1923,8 +1922,7 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n-    [76; 100) '{     ...     }': !\n+    [76; 100) '{     ...     }': Gen<T>\n     [86; 94) 'loop { }': !\n     [91; 94) '{ }': ()\n     [114; 149) '{     ...e(); }': ()\n@@ -1955,8 +1953,7 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n-    [102; 126) '{     ...     }': !\n+    [102; 126) '{     ...     }': Gen<u32, T>\n     [112; 120) 'loop { }': !\n     [117; 120) '{ }': ()\n     [140; 180) '{     ...e(); }': ()\n@@ -2100,7 +2097,7 @@ fn test() {\n         @r###\"\n     [11; 48) '{     ...&y]; }': ()\n     [21; 22) 'y': &{unknown}\n-    [25; 32) 'unknown': &&{unknown}\n+    [25; 32) 'unknown': &{unknown}\n     [38; 45) '[y, &y]': [&&{unknown};_]\n     [39; 40) 'y': &{unknown}\n     [42; 44) '&y': &&{unknown}\n@@ -2124,11 +2121,11 @@ fn test() {\n         @r###\"\n     [11; 80) '{     ...x)]; }': ()\n     [21; 22) 'x': &&{unknown}\n-    [25; 32) 'unknown': &&&{unknown}\n+    [25; 32) 'unknown': &&{unknown}\n     [42; 43) 'y': &&{unknown}\n-    [46; 53) 'unknown': &&&{unknown}\n-    [59; 77) '[(x, y..., &x)]': [(&&{unknown}, &&{unknown});_]\n-    [60; 66) '(x, y)': (&&{unknown}, &&{unknown})\n+    [46; 53) 'unknown': &&{unknown}\n+    [59; 77) '[(x, y..., &x)]': [(&&&{unknown}, &&&{unknown});_]\n+    [60; 66) '(x, y)': (&&&{unknown}, &&&{unknown})\n     [61; 62) 'x': &&{unknown}\n     [64; 65) 'y': &&{unknown}\n     [68; 76) '(&y, &x)': (&&&{unknown}, &&&{unknown})\n@@ -2149,7 +2146,7 @@ fn id<T>(x: T) -> T {\n }\n \n fn clone<T>(x: &T) -> T {\n-    x\n+    *x\n }\n \n fn test() {\n@@ -2160,26 +2157,26 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n     [10; 11) 'x': T\n     [21; 30) '{     x }': T\n     [27; 28) 'x': T\n     [44; 45) 'x': &T\n-    [56; 65) '{     x }': &T\n-    [62; 63) 'x': &T\n-    [77; 157) '{     ...(1); }': ()\n-    [87; 88) 'y': u32\n-    [91; 96) '10u32': u32\n-    [102; 104) 'id': fn id<u32>(T) -> T\n-    [102; 107) 'id(y)': u32\n-    [105; 106) 'y': u32\n-    [117; 118) 'x': bool\n-    [127; 132) 'clone': fn clone<bool>(&T) -> T\n-    [127; 135) 'clone(z)': bool\n-    [133; 134) 'z': &bool\n-    [141; 151) 'id::<i128>': fn id<i128>(T) -> T\n-    [141; 154) 'id::<i128>(1)': i128\n-    [152; 153) '1': i128\n+    [56; 66) '{     *x }': T\n+    [62; 64) '*x': T\n+    [63; 64) 'x': &T\n+    [78; 158) '{     ...(1); }': ()\n+    [88; 89) 'y': u32\n+    [92; 97) '10u32': u32\n+    [103; 105) 'id': fn id<u32>(T) -> T\n+    [103; 108) 'id(y)': u32\n+    [106; 107) 'y': u32\n+    [118; 119) 'x': bool\n+    [128; 133) 'clone': fn clone<bool>(&T) -> T\n+    [128; 136) 'clone(z)': bool\n+    [134; 135) 'z': &bool\n+    [142; 152) 'id::<i128>': fn id<i128>(T) -> T\n+    [142; 155) 'id::<i128>(1)': i128\n+    [153; 154) '1': i128\n     \"###\n     );\n }\n@@ -3404,7 +3401,7 @@ impl S {\n }\n \n fn test(s: Arc<S>) {\n-    (*s, s.foo())<|>\n+    (*s, s.foo())<|>;\n }\n \"#,\n     );\n@@ -3488,7 +3485,7 @@ impl S {\n }\n \n fn test(s: Arc<S>) {\n-    (*s, s.foo())<|>\n+    (*s, s.foo())<|>;\n }\n \"#,\n     );"}, {"sha": "1530fcc6378a55e895dae1793df0edf6bf933b25", "filename": "crates/ra_hir/src/ty/tests/coercion.rs", "status": "modified", "additions": 97, "deletions": 6, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/29e56b8ee480828b81011cfa16c055fa0c9c89fe/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e56b8ee480828b81011cfa16c055fa0c9c89fe/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fcoercion.rs?ref=29e56b8ee480828b81011cfa16c055fa0c9c89fe", "patch": "@@ -19,6 +19,97 @@ fn infer(source: &str) -> String {\n     super::infer(&format!(\"{}{}\", source, defs))\n }\n \n+#[test]\n+fn infer_block_expr_type_mismatch() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let a: i32 = { 1i64 };\n+}\n+\"#),\n+        @r###\"\n+    [11; 41) '{     ...4 }; }': ()\n+    [21; 22) 'a': i32\n+    [30; 38) '{ 1i64 }': i64\n+    [32; 36) '1i64': i64\n+    \"###);\n+}\n+\n+#[test]\n+fn coerce_places() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S<T> { a: T }\n+\n+fn f<T>(_: &[T]) -> T { loop {} }\n+fn g<T>(_: S<&[T]>) -> T { loop {} }\n+\n+fn gen<T>() -> *mut [T; 2] { loop {} }\n+fn test1<U>() -> *mut [U] {\n+    gen()\n+}\n+\n+fn test2() {\n+    let arr: &[u8; 1] = &[1];\n+\n+    let a: &[_] = arr;\n+    let b = f(arr);\n+    let c: &[_] = { arr };\n+    let d = g(S { a: arr });\n+    let e: [&[_]; 1] = [arr];\n+    let f: [&[_]; 2] = [arr; 2];\n+    let g: (&[_], &[_]) = (arr, arr);\n+}\n+\"#),\n+        @r###\"\n+    [31; 32) '_': &[T]\n+    [45; 56) '{ loop {} }': T\n+    [47; 54) 'loop {}': !\n+    [52; 54) '{}': ()\n+    [65; 66) '_': S<&[T]>\n+    [82; 93) '{ loop {} }': T\n+    [84; 91) 'loop {}': !\n+    [89; 91) '{}': ()\n+    [122; 133) '{ loop {} }': *mut [T;_]\n+    [124; 131) 'loop {}': !\n+    [129; 131) '{}': ()\n+    [160; 173) '{     gen() }': *mut [U]\n+    [166; 169) 'gen': fn gen<U>() -> *mut [T;_]\n+    [166; 171) 'gen()': *mut [U;_]\n+    [186; 420) '{     ...rr); }': ()\n+    [196; 199) 'arr': &[u8;_]\n+    [212; 216) '&[1]': &[u8;_]\n+    [213; 216) '[1]': [u8;_]\n+    [214; 215) '1': u8\n+    [227; 228) 'a': &[u8]\n+    [237; 240) 'arr': &[u8;_]\n+    [250; 251) 'b': u8\n+    [254; 255) 'f': fn f<u8>(&[T]) -> T\n+    [254; 260) 'f(arr)': u8\n+    [256; 259) 'arr': &[u8;_]\n+    [270; 271) 'c': &[u8]\n+    [280; 287) '{ arr }': &[u8]\n+    [282; 285) 'arr': &[u8;_]\n+    [297; 298) 'd': u8\n+    [301; 302) 'g': fn g<u8>(S<&[T]>) -> T\n+    [301; 316) 'g(S { a: arr })': u8\n+    [303; 315) 'S { a: arr }': S<&[u8]>\n+    [310; 313) 'arr': &[u8;_]\n+    [326; 327) 'e': [&[u8];_]\n+    [341; 346) '[arr]': [&[u8];_]\n+    [342; 345) 'arr': &[u8;_]\n+    [356; 357) 'f': [&[u8];_]\n+    [371; 379) '[arr; 2]': [&[u8];_]\n+    [372; 375) 'arr': &[u8;_]\n+    [377; 378) '2': usize\n+    [389; 390) 'g': (&[u8], &[u8])\n+    [407; 417) '(arr, arr)': (&[u8], &[u8])\n+    [408; 411) 'arr': &[u8;_]\n+    [413; 416) 'arr': &[u8;_]\n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_let_stmt_coerce() {\n     assert_snapshot!(\n@@ -102,7 +193,7 @@ fn test() {\n \"#),\n         @r###\"\n     [11; 12) 'x': &[T]\n-    [28; 39) '{ loop {} }': !\n+    [28; 39) '{ loop {} }': &[T]\n     [30; 37) 'loop {}': !\n     [35; 37) '{}': ()\n     [50; 126) '{     ...  }; }': ()\n@@ -119,7 +210,7 @@ fn test() {\n     [113; 117) '&[1]': &[i32;_]\n     [114; 117) '[1]': [i32;_]\n     [115; 116) '1': i32\n-\"###\n+    \"###\n     );\n }\n \n@@ -138,7 +229,7 @@ fn test() {\n \"#),\n         @r###\"\n     [11; 12) 'x': &[T]\n-    [28; 39) '{ loop {} }': !\n+    [28; 39) '{ loop {} }': &[T]\n     [30; 37) 'loop {}': !\n     [35; 37) '{}': ()\n     [50; 126) '{     ...  }; }': ()\n@@ -155,7 +246,7 @@ fn test() {\n     [112; 116) '&[1]': &[i32;_]\n     [113; 116) '[1]': [i32;_]\n     [114; 115) '1': i32\n-\"###\n+    \"###\n     );\n }\n \n@@ -174,7 +265,7 @@ fn test(i: i32) {\n \"#),\n         @r###\"\n     [11; 12) 'x': &[T]\n-    [28; 39) '{ loop {} }': !\n+    [28; 39) '{ loop {} }': &[T]\n     [30; 37) 'loop {}': !\n     [35; 37) '{}': ()\n     [48; 49) 'i': i32\n@@ -215,7 +306,7 @@ fn test(i: i32) {\n \"#),\n         @r###\"\n     [11; 12) 'x': &[T]\n-    [28; 39) '{ loop {} }': !\n+    [28; 39) '{ loop {} }': &[T]\n     [30; 37) 'loop {}': !\n     [35; 37) '{}': ()\n     [48; 49) 'i': i32"}]}