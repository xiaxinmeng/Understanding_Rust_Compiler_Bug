{"sha": "b58339205803689b0037b46bddc62351d0b44ad3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ODMzOTIwNTgwMzY4OWIwMDM3YjQ2YmRkYzYyMzUxZDBiNDRhZDM=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-26T12:15:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-26T12:15:02Z"}, "message": "Rollup merge of #43447 - estebank:import-span, r=nikomatsakis\n\nPoint at path segment on module not found\n\nPoint at the correct path segment on a import statement where a module\ndoesn't exist.\n\nNew output:\n\n```rust\nerror[E0432]: unresolved import `std::bar`\n --> <anon>:1:10\n  |\n1 | use std::bar::{foo1, foo2};\n  |          ^^^ Could not find `bar` in `std`\n```\n\ninstead of:\n\n```rust\nerror[E0432]: unresolved import `std::bar::foo1`\n --> <anon>:1:16\n  |\n1 | use std::bar::{foo1, foo2};\n  |                ^^^^ Could not find `bar` in `std`\n\nerror[E0432]: unresolved import `std::bar::foo2`\n --> <anon>:1:22\n  |\n1 | use std::bar::{foo1, foo2};\n  |                      ^^^^ Could not find `bar` in `std`\n```\n\nFix #43040.", "tree": {"sha": "671d629eba95810102f5d48c085172f64b163c05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/671d629eba95810102f5d48c085172f64b163c05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b58339205803689b0037b46bddc62351d0b44ad3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b58339205803689b0037b46bddc62351d0b44ad3", "html_url": "https://github.com/rust-lang/rust/commit/b58339205803689b0037b46bddc62351d0b44ad3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b58339205803689b0037b46bddc62351d0b44ad3/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5b7266b786cb953581ba588d400bddcdae4a852", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b7266b786cb953581ba588d400bddcdae4a852", "html_url": "https://github.com/rust-lang/rust/commit/b5b7266b786cb953581ba588d400bddcdae4a852"}, {"sha": "552ff07758545173c94fa260e5266ec07cd0bbde", "url": "https://api.github.com/repos/rust-lang/rust/commits/552ff07758545173c94fa260e5266ec07cd0bbde", "html_url": "https://github.com/rust-lang/rust/commit/552ff07758545173c94fa260e5266ec07cd0bbde"}], "stats": {"total": 323, "additions": 194, "deletions": 129}, "files": [{"sha": "a061484b5c4a51032018e2fa7fa5324a9b030c75", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -35,6 +35,7 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::codemap::respan;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::hygiene::Mark;\n@@ -119,22 +120,24 @@ impl<'a> Resolver<'a> {\n                                  .unwrap()\n                                  .1\n                                  .iter()\n-                                 .map(|seg| seg.identifier)\n+                                 .map(|seg| respan(seg.span, seg.identifier))\n                                  .collect()\n                     }\n \n                     ViewPathGlob(ref module_ident_path) |\n                     ViewPathList(ref module_ident_path, _) => {\n                         module_ident_path.segments\n                                          .iter()\n-                                         .map(|seg| seg.identifier)\n+                                         .map(|seg| respan(seg.span, seg.identifier))\n                                          .collect()\n                     }\n                 };\n \n                 // This can be removed once warning cycle #36888 is complete.\n-                if module_path.len() >= 2 && module_path[0].name == keywords::CrateRoot.name() &&\n-                   token::Ident(module_path[1]).is_path_segment_keyword() {\n+                if module_path.len() >= 2 &&\n+                    module_path[0].node.name == keywords::CrateRoot.name() &&\n+                    token::Ident(module_path[1].node).is_path_segment_keyword()\n+                {\n                     module_path.remove(0);\n                 }\n \n@@ -202,10 +205,13 @@ impl<'a> Resolver<'a> {\n                             let (module_path, ident, rename, type_ns_only) = {\n                                 if node.name.name != keywords::SelfValue.name() {\n                                     let rename = node.rename.unwrap_or(node.name);\n-                                    (module_path.clone(), node.name, rename, false)\n+                                    (module_path.clone(),\n+                                     respan(source_item.span, node.name),\n+                                     rename,\n+                                     false)\n                                 } else {\n                                     let ident = *module_path.last().unwrap();\n-                                    if ident.name == keywords::CrateRoot.name() {\n+                                    if ident.node.name == keywords::CrateRoot.name() {\n                                         resolve_error(\n                                             self,\n                                             source_item.span,\n@@ -215,13 +221,13 @@ impl<'a> Resolver<'a> {\n                                         continue;\n                                     }\n                                     let module_path = module_path.split_last().unwrap().1;\n-                                    let rename = node.rename.unwrap_or(ident);\n+                                    let rename = node.rename.unwrap_or(ident.node);\n                                     (module_path.to_vec(), ident, rename, true)\n                                 }\n                             };\n                             let subclass = SingleImport {\n                                 target: rename,\n-                                source: ident,\n+                                source: ident.node,\n                                 result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n                                 type_ns_only: type_ns_only,\n                             };"}, {"sha": "88013b45a05a4ac9f07cff84bd6efb4ec68546b9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 80, "deletions": 61, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -43,6 +43,7 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n+use syntax::codemap::{dummy_spanned, respan};\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n@@ -147,7 +148,7 @@ enum ResolutionError<'a> {\n     /// error E0431: `self` import can only appear in an import list with a non-empty prefix\n     SelfImportOnlyInImportListWithNonEmptyPrefix,\n     /// error E0432: unresolved import\n-    UnresolvedImport(Option<(&'a str, &'a str)>),\n+    UnresolvedImport(Option<(Span, &'a str, &'a str)>),\n     /// error E0433: failed to resolve\n     FailedToResolve(&'a str),\n     /// error E0434: can't capture dynamic environment in a fn item\n@@ -295,12 +296,12 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                               non-empty prefix\")\n         }\n         ResolutionError::UnresolvedImport(name) => {\n-            let msg = match name {\n-                Some((n, _)) => format!(\"unresolved import `{}`\", n),\n-                None => \"unresolved import\".to_owned(),\n+            let (span, msg) = match name {\n+                Some((sp, n, _)) => (sp, format!(\"unresolved import `{}`\", n)),\n+                None => (span, \"unresolved import\".to_owned()),\n             };\n             let mut err = struct_span_err!(resolver.session, span, E0432, \"{}\", msg);\n-            if let Some((_, p)) = name {\n+            if let Some((_, _, p)) = name {\n                 err.span_label(span, p);\n             }\n             err\n@@ -823,7 +824,7 @@ enum PathResult<'a> {\n     Module(Module<'a>),\n     NonModule(PathResolution),\n     Indeterminate,\n-    Failed(String, bool /* is the error from the last segment? */),\n+    Failed(Span, String, bool /* is the error from the last segment? */),\n }\n \n enum ModuleKind {\n@@ -1282,19 +1283,21 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool) {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let hir::Path { ref segments, span, ref mut def } = *path;\n-        let path: Vec<_> = segments.iter().map(|seg| Ident::with_empty_ctxt(seg.name)).collect();\n+        let path: Vec<SpannedIdent> = segments.iter()\n+            .map(|seg| respan(span, Ident::with_empty_ctxt(seg.name)))\n+            .collect();\n         match self.resolve_path(&path, Some(namespace), true, span) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n             PathResult::NonModule(..) => match self.resolve_path(&path, None, true, span) {\n-                PathResult::Failed(msg, _) => {\n+                PathResult::Failed(span, msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n                 _ => {}\n             },\n             PathResult::Indeterminate => unreachable!(),\n-            PathResult::Failed(msg, _) => {\n+            PathResult::Failed(span, msg, _) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n             }\n         }\n@@ -1916,7 +1919,9 @@ impl<'a> Resolver<'a> {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            let path: Vec<_> = trait_ref.path.segments.iter().map(|seg| seg.identifier).collect();\n+            let path: Vec<_> = trait_ref.path.segments.iter()\n+                .map(|seg| respan(seg.span, seg.identifier))\n+                .collect();\n             let def = self.smart_resolve_path_fragment(trait_ref.ref_id,\n                                                        None,\n                                                        &path,\n@@ -2341,15 +2346,17 @@ impl<'a> Resolver<'a> {\n                           path: &Path,\n                           source: PathSource)\n                           -> PathResolution {\n-        let segments = &path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>();\n+        let segments = &path.segments.iter()\n+            .map(|seg| respan(seg.span, seg.identifier))\n+            .collect::<Vec<_>>();\n         let ident_span = path.segments.last().map_or(path.span, |seg| seg.span);\n         self.smart_resolve_path_fragment(id, qself, segments, path.span, ident_span, source)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n-                                   path: &[Ident],\n+                                   path: &[SpannedIdent],\n                                    span: Span,\n                                    ident_span: Span,\n                                    source: PathSource)\n@@ -2368,10 +2375,11 @@ impl<'a> Resolver<'a> {\n                 (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n                  format!(\"not a {}\", expected), span)\n             } else {\n-                let item_str = path[path.len() - 1];\n+                let item_str = path[path.len() - 1].node;\n+                let item_span = path[path.len() - 1].span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (format!(\"\"), format!(\"this scope\"))\n-                } else if path.len() == 2 && path[0].name == keywords::CrateRoot.name() {\n+                } else if path.len() == 2 && path[0].node.name == keywords::CrateRoot.name() {\n                     (format!(\"\"), format!(\"the crate root\"))\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n@@ -2382,7 +2390,7 @@ impl<'a> Resolver<'a> {\n                     (mod_prefix, format!(\"`{}`\", names_to_string(mod_path)))\n                 };\n                 (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n-                 format!(\"not found in {}\", mod_str), ident_span)\n+                 format!(\"not found in {}\", mod_str), item_span)\n             };\n             let mut err = this.session.struct_span_err_with_code(base_span, &base_msg, code);\n \n@@ -2403,15 +2411,15 @@ impl<'a> Resolver<'a> {\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n             let ident = *path.last().unwrap();\n-            let candidates = this.lookup_import_candidates(ident.name, ns, is_expected);\n+            let candidates = this.lookup_import_candidates(ident.node.name, ns, is_expected);\n             if !candidates.is_empty() {\n                 let mut module_span = this.current_module.span;\n                 module_span.hi = module_span.lo;\n                 // Report import candidates as help and proceed searching for labels.\n                 show_candidates(&mut err, module_span, &candidates, def.is_some());\n             } else if is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates =\n-                    this.lookup_import_candidates(ident.name, ns, is_enum_variant);\n+                    this.lookup_import_candidates(ident.node.name, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n                     .map(|suggestion| import_candidate_to_paths(&suggestion)).collect::<Vec<_>>();\n                 enum_candidates.sort();\n@@ -2429,8 +2437,8 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             if path.len() == 1 && this.self_type_is_available(span) {\n-                if let Some(candidate) = this.lookup_assoc_candidate(ident, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].ctxt, span);\n+                if let Some(candidate) = this.lookup_assoc_candidate(ident.node, ns, is_expected) {\n+                    let self_is_available = this.self_value_is_available(path[0].node.ctxt, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n                             err.span_suggestion(span, \"try\",\n@@ -2546,7 +2554,7 @@ impl<'a> Resolver<'a> {\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n-                    let item_name = *path.last().unwrap();\n+                    let item_name = path.last().unwrap().node;\n                     let traits = self.get_traits_containing_item(item_name, ns);\n                     self.trait_map.insert(id, traits);\n                 }\n@@ -2613,7 +2621,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_qpath_anywhere(&mut self,\n                               id: NodeId,\n                               qself: Option<&QSelf>,\n-                              path: &[Ident],\n+                              path: &[SpannedIdent],\n                               primary_ns: Namespace,\n                               span: Span,\n                               defer_to_typeck: bool,\n@@ -2633,9 +2641,10 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n         }\n-        let is_global = self.global_macros.get(&path[0].name).cloned()\n+        let is_global = self.global_macros.get(&path[0].node.name).cloned()\n             .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n-        if primary_ns != MacroNS && (is_global || self.macro_names.contains(&path[0].modern())) {\n+        if primary_ns != MacroNS && (is_global ||\n+                                     self.macro_names.contains(&path[0].node.modern())) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n@@ -2648,7 +2657,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_qpath(&mut self,\n                      id: NodeId,\n                      qself: Option<&QSelf>,\n-                     path: &[Ident],\n+                     path: &[SpannedIdent],\n                      ns: Namespace,\n                      span: Span,\n                      global_by_default: bool)\n@@ -2688,8 +2697,9 @@ impl<'a> Resolver<'a> {\n             // The same fallback is used when `a` resolves to nothing.\n             PathResult::Module(..) | PathResult::Failed(..)\n                     if (ns == TypeNS || path.len() > 1) &&\n-                       self.primitive_type_table.primitive_types.contains_key(&path[0].name) => {\n-                let prim = self.primitive_type_table.primitive_types[&path[0].name];\n+                       self.primitive_type_table.primitive_types\n+                           .contains_key(&path[0].node.name) => {\n+                let prim = self.primitive_type_table.primitive_types[&path[0].node.name];\n                 match prim {\n                     TyUint(UintTy::U128) | TyInt(IntTy::I128) => {\n                         if !self.session.features.borrow().i128_type {\n@@ -2704,7 +2714,7 @@ impl<'a> Resolver<'a> {\n                 PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n-            PathResult::Failed(msg, false) => {\n+            PathResult::Failed(span, msg, false) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 err_path_resolution()\n             }\n@@ -2713,8 +2723,8 @@ impl<'a> Resolver<'a> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].name != keywords::CrateRoot.name() &&\n-           path[0].name != keywords::DollarCrate.name() {\n+           path[0].node.name != keywords::CrateRoot.name() &&\n+           path[0].node.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n@@ -2732,7 +2742,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_path(&mut self,\n-                    path: &[Ident],\n+                    path: &[SpannedIdent],\n                     opt_ns: Option<Namespace>, // `None` indicates a module path\n                     record_used: bool,\n                     path_span: Span)\n@@ -2741,15 +2751,16 @@ impl<'a> Resolver<'a> {\n         let mut allow_super = true;\n \n         for (i, &ident) in path.iter().enumerate() {\n+            debug!(\"resolve_path ident {} {:?}\", i, ident);\n             let is_last = i == path.len() - 1;\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n \n-            if i == 0 && ns == TypeNS && ident.name == keywords::SelfValue.name() {\n-                let mut ctxt = ident.ctxt.modern();\n+            if i == 0 && ns == TypeNS && ident.node.name == keywords::SelfValue.name() {\n+                let mut ctxt = ident.node.ctxt.modern();\n                 module = Some(self.resolve_self(&mut ctxt, self.current_module));\n                 continue\n-            } else if allow_super && ns == TypeNS && ident.name == keywords::Super.name() {\n-                let mut ctxt = ident.ctxt.modern();\n+            } else if allow_super && ns == TypeNS && ident.node.name == keywords::Super.name() {\n+                let mut ctxt = ident.node.ctxt.modern();\n                 let self_module = match i {\n                     0 => self.resolve_self(&mut ctxt, self.current_module),\n                     _ => module.unwrap(),\n@@ -2759,26 +2770,26 @@ impl<'a> Resolver<'a> {\n                     continue\n                 } else {\n                     let msg = \"There are too many initial `super`s.\".to_string();\n-                    return PathResult::Failed(msg, false);\n+                    return PathResult::Failed(ident.span, msg, false);\n                 }\n             }\n             allow_super = false;\n \n-            if i == 0 && ns == TypeNS && ident.name == keywords::CrateRoot.name() {\n-                module = Some(self.resolve_crate_root(ident.ctxt.modern()));\n+            if i == 0 && ns == TypeNS && ident.node.name == keywords::CrateRoot.name() {\n+                module = Some(self.resolve_crate_root(ident.node.ctxt.modern()));\n                 continue\n-            } else if i == 0 && ns == TypeNS && ident.name == keywords::DollarCrate.name() {\n-                module = Some(self.resolve_crate_root(ident.ctxt));\n+            } else if i == 0 && ns == TypeNS && ident.node.name == keywords::DollarCrate.name() {\n+                module = Some(self.resolve_crate_root(ident.node.ctxt));\n                 continue\n             }\n \n             let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(module, ident, ns, false, record_used, path_span)\n+                self.resolve_ident_in_module(module, ident.node, ns, false, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n-                self.resolve_lexical_macro_path_segment(ident, ns, record_used, path_span)\n+                self.resolve_lexical_macro_path_segment(ident.node, ns, record_used, path_span)\n                     .map(MacroBinding::binding)\n             } else {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, record_used, path_span) {\n+                match self.resolve_ident_in_lexical_scope(ident.node, ns, record_used, path_span) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     Some(LexicalScopeBinding::Def(def))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n@@ -2803,7 +2814,9 @@ impl<'a> Resolver<'a> {\n                             def, path.len() - i - 1\n                         ));\n                     } else {\n-                        return PathResult::Failed(format!(\"Not a module `{}`\", ident), is_last);\n+                        return PathResult::Failed(ident.span,\n+                                                  format!(\"Not a module `{}`\", ident.node),\n+                                                  is_last);\n                     }\n                 }\n                 Err(Undetermined) => return PathResult::Indeterminate,\n@@ -2818,19 +2831,19 @@ impl<'a> Resolver<'a> {\n                     let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n-                            self.lookup_import_candidates(ident.name, TypeNS, is_mod);\n+                            self.lookup_import_candidates(ident.node.name, TypeNS, is_mod);\n                         candidates.sort_by_key(|c| (c.path.segments.len(), c.path.to_string()));\n                         if let Some(candidate) = candidates.get(0) {\n                             format!(\"Did you mean `{}`?\", candidate.path)\n                         } else {\n-                            format!(\"Maybe a missing `extern crate {};`?\", ident)\n+                            format!(\"Maybe a missing `extern crate {};`?\", ident.node)\n                         }\n                     } else if i == 0 {\n-                        format!(\"Use of undeclared type or module `{}`\", ident)\n+                        format!(\"Use of undeclared type or module `{}`\", ident.node)\n                     } else {\n-                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1])\n+                        format!(\"Could not find `{}` in `{}`\", ident.node, path[i - 1].node)\n                     };\n-                    return PathResult::Failed(msg, is_last);\n+                    return PathResult::Failed(ident.span, msg, is_last);\n                 }\n             }\n         }\n@@ -2850,8 +2863,7 @@ impl<'a> Resolver<'a> {\n         // An invalid forward use of a type parameter from a previous default.\n         if let ForwardTyParamBanRibKind = self.ribs[ns][rib_index].kind {\n             if record_used {\n-                resolve_error(self, span,\n-                        ResolutionError::ForwardDeclaredTyParam);\n+                resolve_error(self, span, ResolutionError::ForwardDeclaredTyParam);\n             }\n             assert_eq!(def, Def::Err);\n             return Def::Err;\n@@ -3021,7 +3033,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn lookup_typo_candidate<FilterFn>(&mut self,\n-                                       path: &[Ident],\n+                                       path: &[SpannedIdent],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn,\n                                        span: Span)\n@@ -3082,7 +3094,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let name = path[path.len() - 1].name;\n+        let name = path[path.len() - 1].node.name;\n         // Make sure error reporting is deterministic.\n         names.sort_by_key(|name| name.as_str());\n         match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n@@ -3620,27 +3632,31 @@ fn is_struct_like(def: Def) -> bool {\n     }\n }\n \n-fn is_self_type(path: &[Ident], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].name == keywords::SelfType.name()\n+fn is_self_type(path: &[SpannedIdent], namespace: Namespace) -> bool {\n+    namespace == TypeNS && path.len() == 1 && path[0].node.name == keywords::SelfType.name()\n }\n \n-fn is_self_value(path: &[Ident], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].name == keywords::SelfValue.name()\n+fn is_self_value(path: &[SpannedIdent], namespace: Namespace) -> bool {\n+    namespace == ValueNS && path.len() == 1 && path[0].node.name == keywords::SelfValue.name()\n }\n \n-fn names_to_string(idents: &[Ident]) -> String {\n+fn names_to_string(idents: &[SpannedIdent]) -> String {\n     let mut result = String::new();\n-    for (i, ident) in idents.iter().filter(|i| i.name != keywords::CrateRoot.name()).enumerate() {\n+    for (i, ident) in idents.iter()\n+                            .filter(|i| i.node.name != keywords::CrateRoot.name())\n+                            .enumerate() {\n         if i > 0 {\n             result.push_str(\"::\");\n         }\n-        result.push_str(&ident.name.as_str());\n+        result.push_str(&ident.node.name.as_str());\n     }\n     result\n }\n \n fn path_names_to_string(path: &Path) -> String {\n-    names_to_string(&path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>())\n+    names_to_string(&path.segments.iter()\n+                        .map(|seg| respan(seg.span, seg.identifier))\n+                        .collect::<Vec<_>>())\n }\n \n /// Get the path for an enum and the variant from an `ImportSuggestion` for an enum variant.\n@@ -3708,7 +3724,10 @@ fn module_to_string(module: Module) -> String {\n     if names.is_empty() {\n         return \"???\".to_string();\n     }\n-    names_to_string(&names.into_iter().rev().collect::<Vec<_>>())\n+    names_to_string(&names.into_iter()\n+                        .rev()\n+                        .map(|n| dummy_spanned(n))\n+                        .collect::<Vec<_>>())\n }\n \n fn err_path_resolution() -> PathResolution {"}, {"sha": "18ec2b3cc1b9a9fd6946bc856baad60e0d65b9b3", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -19,6 +19,7 @@ use rustc::hir::map::{self, DefCollector};\n use rustc::{ty, lint};\n use syntax::ast::{self, Name, Ident};\n use syntax::attr::{self, HasAttrs};\n+use syntax::codemap::respan;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n@@ -393,7 +394,7 @@ impl<'a> Resolver<'a> {\n             return Err(Determinacy::Determined);\n         }\n \n-        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n+        let path: Vec<_> = segments.iter().map(|seg| respan(seg.span, seg.identifier)).collect();\n         let invocation = self.invocations[&scope];\n         self.current_module = invocation.module.get();\n \n@@ -418,16 +419,19 @@ impl<'a> Resolver<'a> {\n                     Err(Determinacy::Determined)\n                 },\n             };\n+            let path = path.iter().map(|p| p.node).collect::<Vec<_>>();\n             self.current_module.nearest_item_scope().macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n             return def;\n         }\n \n-        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n+        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope,\n+                                                          path[0].node,\n+                                                          false);\n         let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n             Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, span) {\n+            match self.resolve_lexical_macro_path_segment(path[0].node, MacroNS, false, span) {\n                 Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 Err(_) => {\n@@ -438,7 +442,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n-            .push((scope, path[0], span, kind));\n+            .push((scope, path[0].node, span, kind));\n \n         result\n     }\n@@ -576,9 +580,10 @@ impl<'a> Resolver<'a> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            match self.resolve_path(path, Some(MacroNS), true, span) {\n+            let path = path.iter().map(|p| respan(span, *p)).collect::<Vec<_>>();\n+            match self.resolve_path(&path, Some(MacroNS), true, span) {\n                 PathResult::NonModule(_) => {},\n-                PathResult::Failed(msg, _) => {\n+                PathResult::Failed(span, msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n                 _ => unreachable!(),\n@@ -652,7 +657,7 @@ impl<'a> Resolver<'a> {\n                 }\n             };\n             let ident = Ident::from_str(name);\n-            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro, span)\n+            self.lookup_typo_candidate(&vec![respan(span, ident)], MacroNS, is_macro, span)\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "5e799b14f209c9071d06b043e8cbdfa1d1e4aa0f", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -21,9 +21,9 @@ use rustc::ty;\n use rustc::lint::builtin::PUB_USE_OF_PRIVATE_EXTERN_CRATE;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::*;\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n-use syntax::ast::{Ident, NodeId};\n+use syntax::ast::{Ident, SpannedIdent, NodeId};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::parse::token;\n@@ -57,7 +57,7 @@ pub enum ImportDirectiveSubclass<'a> {\n pub struct ImportDirective<'a> {\n     pub id: NodeId,\n     pub parent: Module<'a>,\n-    pub module_path: Vec<Ident>,\n+    pub module_path: Vec<SpannedIdent>,\n     pub imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub span: Span,\n@@ -256,7 +256,7 @@ impl<'a> Resolver<'a> {\n \n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n-                                module_path: Vec<Ident>,\n+                                module_path: Vec<SpannedIdent>,\n                                 subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n@@ -478,9 +478,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n \n         let mut errors = false;\n+        let mut seen_spans = FxHashSet();\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n-            if let Some(err) = self.finalize_import(import) {\n+            if let Some((span, err)) = self.finalize_import(import) {\n                 errors = true;\n \n                 if let SingleImport { source, ref result, .. } = import.subclass {\n@@ -496,9 +497,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 // If the error is a single failed import then create a \"fake\" import\n                 // resolution for it so that later resolve stages won't complain.\n                 self.import_dummy_binding(import);\n-                let path = import_path_to_string(&import.module_path, &import.subclass);\n-                let error = ResolutionError::UnresolvedImport(Some((&path, &err)));\n-                resolve_error(self.resolver, import.span, error);\n+                if !seen_spans.contains(&span) {\n+                    let path = import_path_to_string(&import.module_path[..],\n+                                                     &import.subclass,\n+                                                     span);\n+                    let error = ResolutionError::UnresolvedImport(Some((span, &path, &err)));\n+                    resolve_error(self.resolver, span, error);\n+                    seen_spans.insert(span);\n+                }\n             }\n         }\n \n@@ -516,7 +522,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               names_to_string(&directive.module_path),\n+               names_to_string(&directive.module_path[..]),\n                module_to_string(self.current_module));\n \n         self.current_module = directive.parent;\n@@ -528,7 +534,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n-            let result = self.resolve_path(&directive.module_path, None, false, directive.span);\n+            let result = self.resolve_path(&directive.module_path[..], None, false, directive.span);\n             directive.vis.set(vis);\n \n             match result {\n@@ -593,23 +599,25 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     }\n \n     // If appropriate, returns an error to report.\n-    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<String> {\n+    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<(Span, String)> {\n         self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n         let module_result = self.resolve_path(&module_path, None, true, span);\n         let module = match module_result {\n             PathResult::Module(module) => module,\n-            PathResult::Failed(msg, _) => {\n+            PathResult::Failed(span, msg, _) => {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n-                if !self_path.is_empty() && !token::Ident(self_path[0]).is_path_segment_keyword() {\n-                    self_path[0].name = keywords::SelfValue.name();\n+                if !self_path.is_empty() &&\n+                    !token::Ident(self_path[0].node).is_path_segment_keyword()\n+                {\n+                    self_path[0].node.name = keywords::SelfValue.name();\n                     self_result = Some(self.resolve_path(&self_path, None, false, span));\n                 }\n                 return if let Some(PathResult::Module(..)) = self_result {\n-                    Some(format!(\"Did you mean `{}`?\", names_to_string(&self_path)))\n+                    Some((span, format!(\"Did you mean `{}`?\", names_to_string(&self_path[..]))))\n                 } else {\n-                    Some(msg)\n+                    Some((span, msg))\n                 };\n             },\n             _ => return None,\n@@ -619,7 +627,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             SingleImport { source, ref result, type_ns_only, .. } => (source, result, type_ns_only),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n-                return Some(\"Cannot glob-import a module into itself.\".to_string());\n+                return Some((directive.span,\n+                             \"Cannot glob-import a module into itself.\".to_string()));\n             }\n             GlobImport { is_prelude, ref max_vis } => {\n                 if !is_prelude &&\n@@ -708,7 +717,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 } else {\n                     format!(\"no `{}` in `{}`{}\", ident, module_str, lev_suggestion)\n                 };\n-                Some(msg)\n+                Some((span, msg))\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);\n@@ -888,16 +897,24 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     }\n }\n \n-fn import_path_to_string(names: &[Ident], subclass: &ImportDirectiveSubclass) -> String {\n-    let global = !names.is_empty() && names[0].name == keywords::CrateRoot.name();\n-    let names = if global { &names[1..] } else { names };\n-    if names.is_empty() {\n-        import_directive_subclass_to_string(subclass)\n+fn import_path_to_string(names: &[SpannedIdent],\n+                         subclass: &ImportDirectiveSubclass,\n+                         span: Span) -> String {\n+    let pos = names.iter()\n+        .position(|p| span == p.span && p.node.name != keywords::CrateRoot.name());\n+    let global = !names.is_empty() && names[0].node.name == keywords::CrateRoot.name();\n+    if let Some(pos) = pos {\n+        let names = if global { &names[1..pos + 1] } else { &names[..pos + 1] };\n+        names_to_string(names)\n     } else {\n-        (format!(\"{}::{}\",\n-                 names_to_string(names),\n-                 import_directive_subclass_to_string(subclass)))\n-            .to_string()\n+        let names = if global { &names[1..] } else { names };\n+        if names.is_empty() {\n+            import_directive_subclass_to_string(subclass)\n+        } else {\n+            (format!(\"{}::{}\",\n+                     names_to_string(names),\n+                     import_directive_subclass_to_string(subclass)))\n+        }\n     }\n }\n "}, {"sha": "ac96279d614670de0cd3435fafa310e7ae934d70", "filename": "src/test/compile-fail/dollar-crate-is-keyword-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -13,7 +13,7 @@ mod a {}\n macro_rules! m {\n     () => {\n         use a::$crate; //~ ERROR unresolved import `a::$crate`\n-        use a::$crate::b; //~ ERROR unresolved import `a::$crate::b`\n+        use a::$crate::b; //~ ERROR unresolved import `a::$crate`\n         type A = a::$crate; //~ ERROR cannot find type `$crate` in module `a`\n     }\n }"}, {"sha": "c4bd9ff1e2abeae6b1b475e00f705ad19fa110b9", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use baz::zed::bar; //~ ERROR unresolved import `baz::zed::bar` [E0432]\n+use baz::zed::bar; //~ ERROR unresolved import `baz::zed` [E0432]\n                    //~^ Could not find `zed` in `baz`\n \n mod baz {}"}, {"sha": "f8a68264339b93da003a9a2510f897b3cf1c6a0b", "filename": "src/test/compile-fail/issue-1697.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -10,7 +10,7 @@\n \n // Testing that we don't fail abnormally after hitting the errors\n \n-use unresolved::*; //~ ERROR unresolved import `unresolved::*` [E0432]\n+use unresolved::*; //~ ERROR unresolved import `unresolved` [E0432]\n                    //~^ Maybe a missing `extern crate unresolved;`?\n \n fn main() {}"}, {"sha": "0b1afd75ca935703bb96999e56fc88359d2aef99", "filename": "src/test/compile-fail/issue-30560.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fissue-30560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fissue-30560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30560.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -10,10 +10,10 @@\n \n type Alias = ();\n use Alias::*;\n-//~^ ERROR unresolved import `Alias::*` [E0432]\n+//~^ ERROR unresolved import `Alias` [E0432]\n //~| Not a module `Alias`\n use std::io::Result::*;\n-//~^ ERROR unresolved import `std::io::Result::*` [E0432]\n+//~^ ERROR unresolved import `std::io::Result` [E0432]\n //~| Not a module `Result`\n \n trait T {}"}, {"sha": "b7dbaf20ecae1fccd5b98236d1b8eac978305fba", "filename": "src/test/compile-fail/issue-33464.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fissue-33464.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fissue-33464.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-33464.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -11,13 +11,10 @@\n // Make sure that the spans of import errors are correct.\n \n use abc::one_el;\n-//~^ ERROR 13:5: 13:16\n+//~^ ERROR 13:5: 13:8\n use abc::{a, bbb, cccccc};\n-//~^ ERROR 15:11: 15:12\n-//~^^ ERROR 15:14: 15:17\n-//~^^^ ERROR 15:19: 15:25\n+//~^ ERROR 15:5: 15:8\n use a_very_long_name::{el, el2};\n-//~^ ERROR 19:24: 19:26\n-//~^^ ERROR 19:28: 19:31\n+//~^ ERROR 17:5: 17:21\n \n fn main() {}"}, {"sha": "099513484480bacb86d884462b41290c28126999", "filename": "src/test/compile-fail/resolve_self_super_hint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve_self_super_hint.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -13,19 +13,19 @@\n mod a {\n     extern crate alloc;\n     use alloc::HashMap;\n-    //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+    //~^ ERROR unresolved import `alloc` [E0432]\n     //~| Did you mean `self::alloc`?\n     mod b {\n         use alloc::HashMap;\n-        //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+        //~^ ERROR unresolved import `alloc` [E0432]\n         //~| Did you mean `a::alloc`?\n         mod c {\n             use alloc::HashMap;\n-            //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+            //~^ ERROR unresolved import `alloc` [E0432]\n             //~| Did you mean `a::alloc`?\n             mod d {\n                 use alloc::HashMap;\n-                //~^ ERROR unresolved import `alloc::HashMap` [E0432]\n+                //~^ ERROR unresolved import `alloc` [E0432]\n                 //~| Did you mean `a::alloc`?\n             }\n         }"}, {"sha": "4db673e2006f5fb0315e2f7aa034a18b67ec5eb6", "filename": "src/test/compile-fail/super-at-top-level.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::f; //~ ERROR unresolved import `super::f` [E0432]\n+use super::f; //~ ERROR unresolved import `super` [E0432]\n               //~^ There are too many initial `super`s.\n \n fn main() {"}, {"sha": "a3eeb6de96bda1f9867a1d6d9c13510571f76bdb", "filename": "src/test/compile-fail/unresolved-import.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n \n-use foo::bar; //~ ERROR unresolved import `foo::bar` [E0432]\n+use foo::bar; //~ ERROR unresolved import `foo` [E0432]\n               //~^ Maybe a missing `extern crate foo;`?\n \n use bar::Baz as x; //~ ERROR unresolved import `bar::Baz` [E0432]\n@@ -41,7 +41,7 @@ mod m {\n         MyVariant\n     }\n \n-    use MyEnum::*; //~ ERROR unresolved import `MyEnum::*` [E0432]\n+    use MyEnum::*; //~ ERROR unresolved import `MyEnum` [E0432]\n                    //~^ Did you mean `self::MyEnum`?\n }\n \n@@ -50,7 +50,7 @@ mod items {\n         Variant\n     }\n \n-    use Enum::*; //~ ERROR unresolved import `Enum::*` [E0432]\n+    use Enum::*; //~ ERROR unresolved import `Enum` [E0432]\n                  //~^ Did you mean `self::Enum`?\n \n     fn item() {}"}, {"sha": "3848b6814d9a52411d12a57e4aea0e5301660be9", "filename": "src/test/compile-fail/use-from-trait-xc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -22,13 +22,13 @@ use use_from_trait_xc::Trait::CONST;\n //~^ ERROR `CONST` is not directly importable\n \n use use_from_trait_xc::Foo::new; //~ ERROR struct `Foo` is private\n-//~^ ERROR unresolved import `use_from_trait_xc::Foo::new`\n+//~^ ERROR unresolved import `use_from_trait_xc::Foo`\n \n use use_from_trait_xc::Foo::C; //~ ERROR struct `Foo` is private\n-//~^ ERROR unresolved import `use_from_trait_xc::Foo::C`\n+//~^ ERROR unresolved import `use_from_trait_xc::Foo`\n \n use use_from_trait_xc::Bar::new as bnew;\n-//~^ ERROR unresolved import `use_from_trait_xc::Bar::new`\n+//~^ ERROR unresolved import `use_from_trait_xc::Bar`\n \n use use_from_trait_xc::Baz::new as baznew;\n //~^ ERROR unresolved import `use_from_trait_xc::Baz::new`"}, {"sha": "29db949acd04a5379283f28f2d6e7647c9937313", "filename": "src/test/compile-fail/use-from-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -17,11 +17,11 @@ use Trait::C;\n //~^ ERROR `C` is not directly importable\n \n use Foo::new;\n-//~^ ERROR unresolved import `Foo::new` [E0432]\n+//~^ ERROR unresolved import `Foo` [E0432]\n //~| Not a module `Foo`\n \n use Foo::C2;\n-//~^ ERROR unresolved import `Foo::C2` [E0432]\n+//~^ ERROR unresolved import `Foo` [E0432]\n //~| Not a module `Foo`\n \n pub trait Trait {"}, {"sha": "275e5ff1da6ff50193604ca68abbea342ab1b57d", "filename": "src/test/compile-fail/use-mod-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use foo::self; //~ ERROR unresolved import `foo::self`\n+use foo::self; //~ ERROR unresolved import `foo`\n //~^ ERROR `self` imports are only allowed within a { } list\n \n use std::mem::self;"}, {"sha": "5c3bb66d83a87728a273db0d2b72d91435b2eed7", "filename": "src/test/ui/macros/macro_path_as_generic_bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -2,7 +2,7 @@ error[E0433]: failed to resolve. Use of undeclared type or module `m`\n   --> $DIR/macro_path_as_generic_bound.rs:17:6\n    |\n 17 | foo!(m::m2::A);\n-   |      ^^^^^^^^ Use of undeclared type or module `m`\n+   |      ^ Use of undeclared type or module `m`\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "3d45a94d531c178c80f460052106fbb99aa0e41f", "filename": "src/test/ui/span/non-existing-module-import.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.rs?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::bar::{foo1, foo2};\n+\n+fn main() {}"}, {"sha": "93339576f49043a3eff3ed62252e1f87fb65b566", "filename": "src/test/ui/span/non-existing-module-import.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b58339205803689b0037b46bddc62351d0b44ad3/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fnon-existing-module-import.stderr?ref=b58339205803689b0037b46bddc62351d0b44ad3", "patch": "@@ -0,0 +1,8 @@\n+error[E0432]: unresolved import `std::bar`\n+  --> $DIR/non-existing-module-import.rs:11:10\n+   |\n+11 | use std::bar::{foo1, foo2};\n+   |          ^^^ Could not find `bar` in `std`\n+\n+error: aborting due to previous error\n+"}]}