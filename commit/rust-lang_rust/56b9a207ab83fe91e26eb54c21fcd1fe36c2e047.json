{"sha": "56b9a207ab83fe91e26eb54c21fcd1fe36c2e047", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2YjlhMjA3YWI4M2ZlOTFlMjZlYjU0YzIxZmNkMWZlMzZjMmUwNDc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-23T00:48:05Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T23:54:37Z"}, "message": "librustc: De-`@mut` the value and type ribs in the resolver", "tree": {"sha": "1b8a2e87d5740819fd9289d822f153c34e622d85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b8a2e87d5740819fd9289d822f153c34e622d85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56b9a207ab83fe91e26eb54c21fcd1fe36c2e047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56b9a207ab83fe91e26eb54c21fcd1fe36c2e047", "html_url": "https://github.com/rust-lang/rust/commit/56b9a207ab83fe91e26eb54c21fcd1fe36c2e047", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56b9a207ab83fe91e26eb54c21fcd1fe36c2e047/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c48335e334ccacc0f18b8d3dd9cad2ffc7a0a72d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c48335e334ccacc0f18b8d3dd9cad2ffc7a0a72d", "html_url": "https://github.com/rust-lang/rust/commit/c48335e334ccacc0f18b8d3dd9cad2ffc7a0a72d"}], "stats": {"total": 110, "additions": 80, "deletions": 30}, "files": [{"sha": "ac5501c5b6a57307648d94760ab0b431f129b108", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 80, "deletions": 30, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/56b9a207ab83fe91e26eb54c21fcd1fe36c2e047/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b9a207ab83fe91e26eb54c21fcd1fe36c2e047/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=56b9a207ab83fe91e26eb54c21fcd1fe36c2e047", "patch": "@@ -799,8 +799,8 @@ fn Resolver(session: Session,\n         unresolved_imports: 0,\n \n         current_module: current_module,\n-        value_ribs: @mut ~[],\n-        type_ribs: @mut ~[],\n+        value_ribs: @RefCell::new(~[]),\n+        type_ribs: @RefCell::new(~[]),\n         label_ribs: @RefCell::new(~[]),\n \n         current_trait_refs: None,\n@@ -846,10 +846,10 @@ struct Resolver {\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: @mut ~[@Rib],\n+    value_ribs: @RefCell<~[@Rib]>,\n \n     // The current set of local scopes, for types.\n-    type_ribs: @mut ~[@Rib],\n+    type_ribs: @RefCell<~[@Rib]>,\n \n     // The current set of local scopes, for labels.\n     label_ribs: @RefCell<~[@Rib]>,\n@@ -3673,7 +3673,10 @@ impl Resolver {\n             item_trait(ref generics, ref traits, ref methods) => {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib::new(NormalRibKind);\n-                self.type_ribs.push(self_type_rib);\n+                {\n+                    let mut type_ribs = self.type_ribs.borrow_mut();\n+                    type_ribs.get().push(self_type_rib);\n+                }\n                 // plain insert (no renaming)\n                 let name = self.type_self_ident.name;\n                 {\n@@ -3731,7 +3734,8 @@ impl Resolver {\n                     }\n                 });\n \n-                self.type_ribs.pop();\n+                let mut type_ribs = self.type_ribs.borrow_mut();\n+                type_ribs.get().pop();\n             }\n \n             item_struct(ref struct_def, ref generics) => {\n@@ -3802,7 +3806,10 @@ impl Resolver {\n                               rib_kind) => {\n \n                 let function_type_rib = @Rib::new(rib_kind);\n-                self.type_ribs.push(function_type_rib);\n+                {\n+                    let mut type_ribs = self.type_ribs.borrow_mut();\n+                    type_ribs.get().push(function_type_rib);\n+                }\n \n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n                     let ident = type_parameter.ident;\n@@ -3831,7 +3838,8 @@ impl Resolver {\n \n         match type_parameters {\n             HasTypeParameters(..) => {\n-                self.type_ribs.pop();\n+                let mut type_ribs = self.type_ribs.borrow_mut();\n+                type_ribs.get().pop();\n             }\n \n             NoTypeParameters => {\n@@ -3855,11 +3863,19 @@ impl Resolver {\n     }\n \n     fn with_constant_rib(&mut self, f: |&mut Resolver|) {\n-        self.value_ribs.push(@Rib::new(ConstantItemRibKind));\n-        self.type_ribs.push(@Rib::new(ConstantItemRibKind));\n+        {\n+            let mut value_ribs = self.value_ribs.borrow_mut();\n+            let mut type_ribs = self.type_ribs.borrow_mut();\n+            value_ribs.get().push(@Rib::new(ConstantItemRibKind));\n+            type_ribs.get().push(@Rib::new(ConstantItemRibKind));\n+        }\n         f(self);\n-        self.type_ribs.pop();\n-        self.value_ribs.pop();\n+        {\n+            let mut value_ribs = self.value_ribs.borrow_mut();\n+            let mut type_ribs = self.type_ribs.borrow_mut();\n+            type_ribs.get().pop();\n+            value_ribs.get().pop();\n+        }\n     }\n \n     fn resolve_function(&mut self,\n@@ -3870,7 +3886,10 @@ impl Resolver {\n                             self_binding: SelfBinding) {\n         // Create a value rib for the function.\n         let function_value_rib = @Rib::new(rib_kind);\n-        self.value_ribs.push(function_value_rib);\n+        {\n+            let mut value_ribs = self.value_ribs.borrow_mut();\n+            value_ribs.get().push(function_value_rib);\n+        }\n \n         // Create a label rib for the function.\n         {\n@@ -3935,7 +3954,9 @@ impl Resolver {\n \n         let mut label_ribs = self.label_ribs.borrow_mut();\n         label_ribs.get().pop();\n-        self.value_ribs.pop();\n+\n+        let mut value_ribs = self.value_ribs.borrow_mut();\n+        value_ribs.get().pop();\n     }\n \n     fn resolve_type_parameters(&mut self,\n@@ -4208,7 +4229,10 @@ impl Resolver {\n     }\n \n     fn resolve_arm(&mut self, arm: &Arm) {\n-        self.value_ribs.push(@Rib::new(NormalRibKind));\n+        {\n+            let mut value_ribs = self.value_ribs.borrow_mut();\n+            value_ribs.get().push(@Rib::new(NormalRibKind));\n+        }\n \n         let mut bindings_list = HashMap::new();\n         for pattern in arm.pats.iter() {\n@@ -4224,12 +4248,16 @@ impl Resolver {\n         visit::walk_expr_opt(self, arm.guard, ());\n         self.resolve_block(arm.body);\n \n-        self.value_ribs.pop();\n+        let mut value_ribs = self.value_ribs.borrow_mut();\n+        value_ribs.get().pop();\n     }\n \n     fn resolve_block(&mut self, block: P<Block>) {\n         debug!(\"(resolving block) entering block\");\n-        self.value_ribs.push(@Rib::new(NormalRibKind));\n+        {\n+            let mut value_ribs = self.value_ribs.borrow_mut();\n+            value_ribs.get().push(@Rib::new(NormalRibKind));\n+        }\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n@@ -4251,7 +4279,8 @@ impl Resolver {\n         // Move back up.\n         self.current_module = orig_module;\n \n-        self.value_ribs.pop();\n+        let mut value_ribs = self.value_ribs.borrow_mut();\n+        value_ribs.get().pop();\n         debug!(\"(resolving block) leaving block\");\n     }\n \n@@ -4456,9 +4485,11 @@ impl Resolver {\n                                 Some(ref mut bindings_list)\n                                 if !bindings_list.contains_key(&renamed) => {\n                                     let this = &mut *self;\n-                                    let last_rib = this.value_ribs[\n-                                            this.value_ribs.len() - 1];\n                                     {\n+                                        let mut value_ribs =\n+                                            this.value_ribs.borrow_mut();\n+                                        let last_rib = value_ribs.get()[\n+                                            value_ribs.get().len() - 1];\n                                         let mut bindings =\n                                             last_rib.bindings.borrow_mut();\n                                         bindings.get().insert(renamed,\n@@ -4481,9 +4512,11 @@ impl Resolver {\n                                 }\n                                 None => {\n                                     let this = &mut *self;\n-                                    let last_rib = this.value_ribs[\n-                                            this.value_ribs.len() - 1];\n                                     {\n+                                        let mut value_ribs =\n+                                            this.value_ribs.borrow_mut();\n+                                        let last_rib = value_ribs.get()[\n+                                                value_ribs.get().len() - 1];\n                                         let mut bindings =\n                                             last_rib.bindings.borrow_mut();\n                                         bindings.get().insert(renamed,\n@@ -4936,14 +4969,19 @@ impl Resolver {\n         match namespace {\n             ValueNS => {\n                 let renamed = mtwt_resolve(ident);\n-                search_result = self.search_ribs(self.value_ribs, renamed,\n+                let mut value_ribs = self.value_ribs.borrow_mut();\n+                search_result = self.search_ribs(value_ribs.get(),\n+                                                 renamed,\n                                                  span,\n                                                  DontAllowCapturingSelf);\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                search_result = self.search_ribs(self.type_ribs, name,\n-                                                 span, AllowCapturingSelf);\n+                let mut type_ribs = self.type_ribs.borrow_mut();\n+                search_result = self.search_ribs(type_ribs.get(),\n+                                                 name,\n+                                                 span,\n+                                                 AllowCapturingSelf);\n             }\n         }\n \n@@ -4964,12 +5002,20 @@ impl Resolver {\n     fn resolve_self_value_in_local_ribs(&mut self, span: Span)\n                                             -> Option<Def> {\n         // FIXME #4950: This should not use a while loop.\n-        let mut i = self.value_ribs.len();\n+        let mut i = {\n+            let value_ribs = self.value_ribs.borrow();\n+            value_ribs.get().len()\n+        };\n         while i != 0 {\n             i -= 1;\n-            match self.value_ribs[i].self_binding.get() {\n+            let self_binding_opt = {\n+                let value_ribs = self.value_ribs.borrow();\n+                value_ribs.get()[i].self_binding.get()\n+            };\n+            match self_binding_opt {\n                 Some(def_like) => {\n-                    match self.upvarify(self.value_ribs,\n+                    let mut value_ribs = self.value_ribs.borrow_mut();\n+                    match self.upvarify(value_ribs.get(),\n                                         i,\n                                         def_like,\n                                         span,\n@@ -5054,10 +5100,14 @@ impl Resolver {\n         let mut maybes: ~[@str] = ~[];\n         let mut values: ~[uint] = ~[];\n \n-        let mut j = this.value_ribs.len();\n+        let mut j = {\n+            let value_ribs = this.value_ribs.borrow();\n+            value_ribs.get().len()\n+        };\n         while j != 0 {\n             j -= 1;\n-            let bindings = this.value_ribs[j].bindings.borrow();\n+            let value_ribs = this.value_ribs.borrow();\n+            let bindings = value_ribs.get()[j].bindings.borrow();\n             for (&k, _) in bindings.get().iter() {\n                 maybes.push(interner_get(k));\n                 values.push(uint::max_value);"}]}