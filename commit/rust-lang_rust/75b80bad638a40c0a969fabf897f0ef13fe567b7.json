{"sha": "75b80bad638a40c0a969fabf897f0ef13fe567b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1YjgwYmFkNjM4YTQwYzBhOTY5ZmFiZjg5N2YwZWYxM2ZlNTY3Yjc=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-22T00:01:17Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-29T07:58:50Z"}, "message": "Use more deriving(IterBytes) in libsyntax.", "tree": {"sha": "397af7b8aff224447389e7b4aad0bc1df70e2a07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/397af7b8aff224447389e7b4aad0bc1df70e2a07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75b80bad638a40c0a969fabf897f0ef13fe567b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75b80bad638a40c0a969fabf897f0ef13fe567b7", "html_url": "https://github.com/rust-lang/rust/commit/75b80bad638a40c0a969fabf897f0ef13fe567b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75b80bad638a40c0a969fabf897f0ef13fe567b7/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5784c0912f99a4bfeb75909fab0cf9bb6bef794f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5784c0912f99a4bfeb75909fab0cf9bb6bef794f", "html_url": "https://github.com/rust-lang/rust/commit/5784c0912f99a4bfeb75909fab0cf9bb6bef794f"}], "stats": {"total": 335, "additions": 93, "deletions": 242}, "files": [{"sha": "bc432c4c7b0b6c1e44578c1276251eed02d6d1e5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 82, "deletions": 183, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/75b80bad638a40c0a969fabf897f0ef13fe567b7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b80bad638a40c0a969fabf897f0ef13fe567b7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=75b80bad638a40c0a969fabf897f0ef13fe567b7", "patch": "@@ -17,17 +17,14 @@ use parse::token::{interner_get, str_to_ident};\n \n use std::hashmap::HashMap;\n use std::option::Option;\n-use std::to_bytes::IterBytes;\n-use std::to_bytes;\n use std::to_str::ToStr;\n use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-\n // an identifier contains a Name (index into the interner\n // table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct ident { name: Name, ctxt: SyntaxContext }\n \n /// Construct an identifier with the given name and an empty context:\n@@ -57,7 +54,7 @@ pub struct SCTable {\n pub static empty_ctxt : uint = 0;\n pub static illegal_ctxt : uint = 1;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n@@ -86,42 +83,28 @@ impl<S:Encoder> Encodable<S> for ident {\n     }\n }\n \n+#[deriving(IterBytes)]\n impl<D:Decoder> Decodable<D> for ident {\n     fn decode(d: &mut D) -> ident {\n         str_to_ident(d.read_str())\n     }\n }\n \n-impl to_bytes::IterBytes for ident {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.name.iter_bytes(lsb0, f)\n-    }\n-}\n-\n // Functions may or may not have names.\n pub type fn_ident = Option<ident>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct Lifetime {\n     id: node_id,\n     span: span,\n     ident: ident\n }\n \n-impl to_bytes::IterBytes for Lifetime {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.id.iter_bytes(lsb0, f) &&\n-        self.span.iter_bytes(lsb0, f) &&\n-        self.ident.iter_bytes(lsb0, f)\n-    }\n-}\n-\n // a \"Path\" is essentially Rust's notion of a name;\n // for instance: core::cmp::Eq  .  It's represented\n // as a sequence of identifiers, along with a bunch\n // of supporting information.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct Path {\n     span: span,\n     global: bool,\n@@ -134,7 +117,7 @@ pub type crate_num = int;\n \n pub type node_id = int;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct def_id {\n     crate: crate_num,\n     node: node_id,\n@@ -143,7 +126,7 @@ pub struct def_id {\n pub static local_crate: crate_num = 0;\n pub static crate_node_id: node_id = 0;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n // The AST represents all type param bounds as types.\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n@@ -153,14 +136,14 @@ pub enum TyParamBound {\n     RegionTyParamBound\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TyParam {\n     ident: ident,\n     id: node_id,\n     bounds: @OptVec<TyParamBound>\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct Generics {\n     lifetimes: OptVec<Lifetime>,\n     ty_params: OptVec<TyParam>\n@@ -178,7 +161,7 @@ impl Generics {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum def {\n     def_fn(def_id, purity),\n     def_static_method(/* method */ def_id,\n@@ -216,7 +199,7 @@ pub type crate_cfg = ~[@meta_item];\n \n pub type crate = spanned<crate_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct crate_ {\n     module: _mod,\n     attrs: ~[attribute],\n@@ -225,7 +208,7 @@ pub struct crate_ {\n \n pub type meta_item = spanned<meta_item_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum meta_item_ {\n     meta_word(@str),\n     meta_list(@str, ~[@meta_item]),\n@@ -234,7 +217,7 @@ pub enum meta_item_ {\n \n pub type blk = spanned<blk_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct blk_ {\n     view_items: ~[@view_item],\n     stmts: ~[@stmt],\n@@ -243,40 +226,26 @@ pub struct blk_ {\n     rules: blk_check_mode,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct pat {\n     id: node_id,\n     node: pat_,\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct field_pat {\n     ident: ident,\n     pat: @pat,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum binding_mode {\n     bind_by_ref(mutability),\n     bind_infer\n }\n \n-impl to_bytes::IterBytes for binding_mode {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-          bind_by_ref(ref m) => {\n-              0u8.iter_bytes(lsb0, f) && m.iter_bytes(lsb0, f)\n-          }\n-\n-          bind_infer => {\n-              1u8.iter_bytes(lsb0, f)\n-          }\n-        }\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -301,28 +270,16 @@ pub enum pat_ {\n     pat_vec(~[@pat], Option<@pat>, ~[@pat])\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n-impl to_bytes::IterBytes for mutability {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum Sigil {\n     BorrowedSigil,\n     OwnedSigil,\n     ManagedSigil\n }\n \n-impl to_bytes::IterBytes for Sigil {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl ToStr for Sigil {\n     fn to_str(&self) -> ~str {\n         match *self {\n@@ -333,7 +290,7 @@ impl ToStr for Sigil {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(Option<uint>),     // [1,2,3,4]\n@@ -342,7 +299,7 @@ pub enum vstore {\n     vstore_slice(Option<@Lifetime>) // &'foo? [1,2,3,4]\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum expr_vstore {\n     expr_vstore_uniq,                  // ~[1,2,3,4]\n     expr_vstore_box,                   // @[1,2,3,4]\n@@ -351,7 +308,7 @@ pub enum expr_vstore {\n     expr_vstore_mut_slice,             // &mut [1,2,3,4]\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum binop {\n     add,\n     subtract,\n@@ -373,7 +330,7 @@ pub enum binop {\n     gt,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum unop {\n     box(mutability),\n     uniq(mutability),\n@@ -384,7 +341,7 @@ pub enum unop {\n \n pub type stmt = spanned<stmt_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum stmt_ {\n     // could be an item or a local (let) binding:\n     stmt_decl(@decl, node_id),\n@@ -401,7 +358,7 @@ pub enum stmt_ {\n \n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct local_ {\n     is_mutbl: bool,\n     ty: @Ty,\n@@ -414,33 +371,33 @@ pub type local = spanned<local_>;\n \n pub type decl = spanned<decl_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum decl_ {\n     // a local (let) binding:\n     decl_local(@local),\n     // an item binding:\n     decl_item(@item),\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct arm {\n     pats: ~[@pat],\n     guard: Option<@expr>,\n     body: blk,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct field_ {\n     ident: ident,\n     expr: @expr,\n }\n \n pub type field = spanned<field_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum blk_check_mode { default_blk, unsafe_blk, }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct expr {\n     id: node_id,\n     node: expr_,\n@@ -460,14 +417,14 @@ impl expr {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum CallSugar {\n     NoSugar,\n     DoSugar,\n     ForSugar\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n@@ -538,7 +495,7 @@ pub enum expr_ {\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum token_tree {\n     // a single token\n@@ -611,7 +568,7 @@ pub enum token_tree {\n //\n pub type matcher = spanned<matcher_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum matcher_ {\n     // match one token\n     match_tok(::parse::token::Token),\n@@ -624,14 +581,14 @@ pub enum matcher_ {\n \n pub type mac = spanned<mac_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum mac_ {\n     mac_invoc_tt(@Path,~[token_tree]),   // new macro-invocation\n }\n \n pub type lit = spanned<lit_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum lit_ {\n     lit_str(@str),\n     lit_int(i64, int_ty),\n@@ -645,21 +602,21 @@ pub enum lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct mt {\n     ty: @Ty,\n     mutbl: mutability,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct ty_field_ {\n     ident: ident,\n     mt: mt,\n }\n \n pub type ty_field = spanned<ty_field_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct ty_method {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -671,7 +628,7 @@ pub struct ty_method {\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n@@ -680,7 +637,7 @@ pub enum trait_method {\n     provided(@method),\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n impl ToStr for int_ty {\n@@ -689,13 +646,7 @@ impl ToStr for int_ty {\n     }\n }\n \n-impl to_bytes::IterBytes for int_ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n impl ToStr for uint_ty {\n@@ -704,13 +655,7 @@ impl ToStr for uint_ty {\n     }\n }\n \n-impl to_bytes::IterBytes for uint_ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum float_ty { ty_f, ty_f32, ty_f64, }\n \n impl ToStr for float_ty {\n@@ -719,22 +664,16 @@ impl ToStr for float_ty {\n     }\n }\n \n-impl to_bytes::IterBytes for float_ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n // NB Eq method appears below.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct Ty {\n     id: node_id,\n     node: ty_,\n     span: span,\n }\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -743,12 +682,13 @@ pub enum prim_ty {\n     ty_bool,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum Onceness {\n     Once,\n     Many\n }\n \n+#[deriving(IterBytes)]\n impl ToStr for Onceness {\n     fn to_str(&self) -> ~str {\n         match *self {\n@@ -758,13 +698,7 @@ impl ToStr for Onceness {\n     }\n }\n \n-impl to_bytes::IterBytes for Onceness {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TyClosure {\n     sigil: Sigil,\n     region: Option<@Lifetime>,\n@@ -779,15 +713,15 @@ pub struct TyClosure {\n     bounds: Option<OptVec<TyParamBound>>,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TyBareFn {\n     purity: purity,\n     abis: AbiSet,\n     lifetimes: OptVec<Lifetime>,\n     decl: fn_decl\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -808,19 +742,13 @@ pub enum ty_ {\n     ty_infer,\n }\n \n-impl to_bytes::IterBytes for Ty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.span.lo.iter_bytes(lsb0, f) && self.span.hi.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum asm_dialect {\n     asm_att,\n     asm_intel\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct inline_asm {\n     asm: @str,\n     clobbers: @str,\n@@ -831,28 +759,29 @@ pub struct inline_asm {\n     dialect: asm_dialect\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct arg {\n     is_mutbl: bool,\n     ty: @Ty,\n     pat: @pat,\n     id: node_id,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct fn_decl {\n     inputs: ~[arg],\n     output: @Ty,\n     cf: ret_style,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum purity {\n     unsafe_fn, // declared with \"unsafe fn\"\n     impure_fn, // declared with \"fn\"\n     extern_fn, // declared with \"extern fn\"\n }\n \n+#[deriving(IterBytes)]\n impl ToStr for purity {\n     fn to_str(&self) -> ~str {\n         match *self {\n@@ -863,26 +792,14 @@ impl ToStr for purity {\n     }\n }\n \n-impl to_bytes::IterBytes for purity {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     return_val, // everything else\n }\n \n-impl to_bytes::IterBytes for ret_style {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum explicit_self_ {\n     sty_static,                                // no self\n     sty_value,                                 // `self`\n@@ -891,27 +808,9 @@ pub enum explicit_self_ {\n     sty_uniq(mutability)                       // `~self`\n }\n \n-impl to_bytes::IterBytes for explicit_self_ {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            sty_static => 0u8.iter_bytes(lsb0, f),\n-            sty_value => 1u8.iter_bytes(lsb0, f),\n-            sty_region(ref lft, ref mutbl) => {\n-                2u8.iter_bytes(lsb0, f) && lft.iter_bytes(lsb0, f) && mutbl.iter_bytes(lsb0, f)\n-            }\n-            sty_box(ref mutbl) => {\n-                3u8.iter_bytes(lsb0, f) && mutbl.iter_bytes(lsb0, f)\n-            }\n-            sty_uniq(ref mutbl) => {\n-                4u8.iter_bytes(lsb0, f) && mutbl.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n pub type explicit_self = spanned<explicit_self_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct method {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -926,42 +825,42 @@ pub struct method {\n     vis: visibility,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct _mod {\n     view_items: ~[@view_item],\n     items: ~[@item],\n }\n \n // Foreign mods can be named or anonymous\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum foreign_mod_sort { named, anonymous }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct foreign_mod {\n     sort: foreign_mod_sort,\n     abis: AbiSet,\n     view_items: ~[@view_item],\n     items: ~[@foreign_item],\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct variant_arg {\n     ty: @Ty,\n     id: node_id,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n     struct_variant_kind(@struct_def),\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct enum_def {\n     variants: ~[variant],\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct variant_ {\n     name: ident,\n     attrs: ~[attribute],\n@@ -973,7 +872,7 @@ pub struct variant_ {\n \n pub type variant = spanned<variant_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct path_list_ident_ {\n     name: ident,\n     id: node_id,\n@@ -983,7 +882,7 @@ pub type path_list_ident = spanned<path_list_ident_>;\n \n pub type view_path = spanned<view_path_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -1000,15 +899,15 @@ pub enum view_path_ {\n     view_path_list(@Path, ~[path_list_ident], node_id)\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct view_item {\n     node: view_item_,\n     attrs: ~[attribute],\n     vis: visibility,\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum view_item_ {\n     view_item_extern_mod(ident, ~[@meta_item], node_id),\n     view_item_use(~[@view_path]),\n@@ -1020,11 +919,11 @@ pub type attribute = spanned<attribute_>;\n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum attr_style { attr_outer, attr_inner, }\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct attribute_ {\n     style: attr_style,\n     value: @meta_item,\n@@ -1038,13 +937,13 @@ pub struct attribute_ {\n   If this impl is an item_impl, the impl_id is redundant (it could be the\n   same as the impl's node id).\n  */\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct trait_ref {\n     path: @Path,\n     ref_id: node_id,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum visibility { public, private, inherited }\n \n impl visibility {\n@@ -1056,7 +955,7 @@ impl visibility {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: node_id,\n@@ -1066,13 +965,13 @@ pub struct struct_field_ {\n \n pub type struct_field = spanned<struct_field_>;\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum struct_field_kind {\n     named_field(ident, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct struct_def {\n     fields: ~[@struct_field], /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n@@ -1084,7 +983,7 @@ pub struct struct_def {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct item {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1094,7 +993,7 @@ pub struct item {\n     span: span,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum item_ {\n     item_static(@Ty, mutability, @expr),\n     item_fn(fn_decl, purity, AbiSet, Generics, blk),\n@@ -1112,7 +1011,7 @@ pub enum item_ {\n     item_mac(mac),\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct foreign_item {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1122,7 +1021,7 @@ pub struct foreign_item {\n     vis: visibility,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, Generics),\n     foreign_item_static(@Ty, /* is_mutbl */ bool),\n@@ -1131,7 +1030,7 @@ pub enum foreign_item_ {\n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),"}, {"sha": "6e21ceb64c431c2d289c0e61da03f14ee7b17a2f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/75b80bad638a40c0a969fabf897f0ef13fe567b7/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b80bad638a40c0a969fabf897f0ef13fe567b7/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=75b80bad638a40c0a969fabf897f0ef13fe567b7", "patch": "@@ -19,7 +19,6 @@ use visit;\n use std::hashmap::HashMap;\n use std::int;\n use std::option;\n-use std::to_bytes;\n use std::cast;\n use std::local_data;\n \n@@ -194,14 +193,6 @@ pub fn is_call_expr(e: @expr) -> bool {\n     match e.node { expr_call(*) => true, _ => false }\n }\n \n-// This makes def_id hashable\n-impl to_bytes::IterBytes for def_id {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.crate.iter_bytes(lsb0, f) && self.node.iter_bytes(lsb0, f)\n-    }\n-}\n-\n pub fn block_from_expr(e: @expr) -> blk {\n     let blk_ = default_block(~[], option::Some::<@expr>(e), e.id);\n     return spanned {node: blk_, span: e.span};"}, {"sha": "bcf617c56ae1eba60aa598eaa0f8f7837a9412fc", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 46, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/75b80bad638a40c0a969fabf897f0ef13fe567b7/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b80bad638a40c0a969fabf897f0ef13fe567b7/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=75b80bad638a40c0a969fabf897f0ef13fe567b7", "patch": "@@ -22,7 +22,6 @@ source code snippets, etc.\n */\n \n use std::cmp;\n-use std::to_bytes;\n use std::uint;\n use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -32,12 +31,12 @@ pub trait Pos {\n }\n \n /// A byte offset\n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct BytePos(uint);\n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct CharPos(uint);\n \n // XXX: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -67,12 +66,6 @@ impl Sub<BytePos, BytePos> for BytePos {\n     }\n }\n \n-impl to_bytes::IterBytes for BytePos {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl Pos for CharPos {\n     fn from_uint(n: uint) -> CharPos { CharPos(n) }\n     fn to_uint(&self) -> uint { **self }\n@@ -85,12 +78,6 @@ impl cmp::Ord for CharPos {\n     fn gt(&self, other: &CharPos) -> bool { **self > **other }\n }\n \n-impl to_bytes::IterBytes for CharPos {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl Add<CharPos,CharPos> for CharPos {\n     fn add(&self, rhs: &CharPos) -> CharPos {\n         CharPos(**self + **rhs)\n@@ -109,13 +96,14 @@ are *absolute* positions from the beginning of the codemap, not positions\n relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n to the original source.\n */\n+#[deriving(IterBytes)]\n pub struct span {\n     lo: BytePos,\n     hi: BytePos,\n     expn_info: Option<@ExpnInfo>\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct spanned<T> { node: T, span: span }\n \n impl cmp::Eq for span {\n@@ -138,14 +126,6 @@ impl<D:Decoder> Decodable<D> for span {\n     }\n }\n \n-impl to_bytes::IterBytes for span {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.lo.iter_bytes(lsb0, f) &&\n-        self.hi.iter_bytes(lsb0, f) &&\n-        self.expn_info.iter_bytes(lsb0, f)\n-    }\n-}\n-\n pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }\n@@ -191,40 +171,21 @@ pub struct LocWithOpt {\n // used to be structural records. Better names, anyone?\n pub struct FileMapAndLine {fm: @FileMap, line: uint}\n pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n+#[deriving(IterBytes)]\n pub struct NameAndSpan {name: @str, span: Option<span>}\n \n-impl to_bytes::IterBytes for NameAndSpan {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.name.iter_bytes(lsb0, f) && self.span.iter_bytes(lsb0, f)\n-    }\n-}\n-\n+#[deriving(IterBytes)]\n pub struct CallInfo {\n     call_site: span,\n     callee: NameAndSpan\n }\n \n-impl to_bytes::IterBytes for CallInfo {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.call_site.iter_bytes(lsb0, f) && self.callee.iter_bytes(lsb0, f)\n-    }\n-}\n-\n /// Extra information for tracking macro expansion of spans\n+#[deriving(IterBytes)]\n pub enum ExpnInfo {\n     ExpandedFrom(CallInfo)\n }\n \n-impl to_bytes::IterBytes for ExpnInfo {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            ExpandedFrom(ref call_info) => {\n-                0u8.iter_bytes(lsb0, f) && call_info.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n pub type FileName = @str;\n \n pub struct FileLines"}, {"sha": "bf8c5ae462bf0284d5f42e5682eb9d080150602c", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75b80bad638a40c0a969fabf897f0ef13fe567b7/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b80bad638a40c0a969fabf897f0ef13fe567b7/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=75b80bad638a40c0a969fabf897f0ef13fe567b7", "patch": "@@ -18,7 +18,7 @@\n \n use std::vec::VecIterator;\n \n-#[deriving(Encodable, Decodable)]\n+#[deriving(Encodable, Decodable,IterBytes)]\n pub enum OptVec<T> {\n     Empty,\n     Vec(~[T])"}, {"sha": "94147825da49c06df46d2f6de5fb3a97627b6d6d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75b80bad638a40c0a969fabf897f0ef13fe567b7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b80bad638a40c0a969fabf897f0ef13fe567b7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=75b80bad638a40c0a969fabf897f0ef13fe567b7", "patch": "@@ -22,7 +22,7 @@ use std::local_data;\n use std::rand;\n use std::rand::RngUtil;\n \n-#[deriving(Encodable, Decodable, Eq)]\n+#[deriving(Encodable, Decodable, Eq, IterBytes)]\n pub enum binop {\n     PLUS,\n     MINUS,\n@@ -36,7 +36,7 @@ pub enum binop {\n     SHR,\n }\n \n-#[deriving(Encodable, Decodable, Eq)]\n+#[deriving(Encodable, Decodable, Eq, IterBytes)]\n pub enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -97,7 +97,7 @@ pub enum Token {\n     EOF,\n }\n \n-#[deriving(Encodable, Decodable, Eq)]\n+#[deriving(Encodable, Decodable, Eq, IterBytes)]\n /// For interpolation during macro expansion.\n pub enum nonterminal {\n     nt_item(@ast::item),"}]}