{"sha": "7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYjM1ZWNmODRjM2ZkNWY5MmMyYWYyODdkNDc4ZWI3MGNiYWNkYmQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-21T00:29:54Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-21T21:37:33Z"}, "message": "Serialize constraints in types (literal arguments still not supported)\n\nThis involved, in part, changing the ast::def type so that a def_fn\nhas a \"purity\" field. This lets the typechecker determine whether\nfunctions defined in other crates are pure.\n\nIt also required updating some error messages in tests. As a test\nfor cross-crate constrained functions, I added a safe_slice function\nto std::str (slice(), with one of the asserts replaced with a\nfunction precondition) and some test cases (various versions of\nfn-constraint.rs) that call it. Also, I changed \"fn\" to \"pred\" for\nsome of the boolean functions in std::uint.", "tree": {"sha": "58823f0d3ba4216b2e0ef5c372bf8a5ec965a7f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58823f0d3ba4216b2e0ef5c372bf8a5ec965a7f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "html_url": "https://github.com/rust-lang/rust/commit/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b6d94d4894e06feeb9b48f291a76ff02d0c31ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b6d94d4894e06feeb9b48f291a76ff02d0c31ff", "html_url": "https://github.com/rust-lang/rust/commit/3b6d94d4894e06feeb9b48f291a76ff02d0c31ff"}], "stats": {"total": 260, "additions": 147, "deletions": 113}, "files": [{"sha": "14bc0e8532e6213d6d1e8f9c0cdde60020d62d42", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -27,7 +27,7 @@ fn local_def(node_id id) -> def_id {\n type ty_param = ident;\n \n tag def {\n-    def_fn(def_id);\n+    def_fn(def_id, purity);\n     def_obj(def_id);\n     def_obj_field(def_id);\n     def_mod(def_id);\n@@ -54,7 +54,7 @@ fn variant_def_ids(&def d) -> tup(def_id, def_id) {\n \n fn def_id_of_def(def d) -> def_id {\n     alt (d) {\n-        case (def_fn(?id)) { ret id; }\n+        case (def_fn(?id,_)) { ret id; }\n         case (def_obj(?id)) { ret id; }\n         case (def_obj_field(?id)) { ret id; }\n         case (def_mod(?id)) { ret id; }"}, {"sha": "b297f062de9d37b74ddfdf5d952eadaa99eb1122", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 55, "deletions": 24, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -56,13 +56,22 @@ fn next(@pstate st) -> u8 {\n }\n \n fn parse_ident(@pstate st, str_def sd, char last) -> ast::ident {\n+    fn is_last(char b, char c) -> bool {\n+        ret c == b;\n+    }\n+    ret parse_ident_(st, sd, bind is_last(last, _));\n+}\n+\n+fn parse_ident_(@pstate st, str_def sd, fn(char) -> bool is_last)\n+    -> ast::ident {\n     auto res = \"\";\n-    while (peek(st) as char != last) {\n+    while (! is_last(peek(st) as char)) {\n         res += str::unsafe_from_byte(next(st));\n     }\n     ret res;\n }\n \n+\n fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len, str_def sd,\n                  ty::ctxt tcx) -> ty::t {\n     auto st =\n@@ -85,40 +94,59 @@ fn parse_constrs(@pstate st, str_def sd) -> vec[@ty::constr_def] {\n             do  {\n                 auto ignore = next(st);\n                 vec::push(res, parse_constr(st, sd));\n-            } while (peek(st) as char == ',')\n+            } while (peek(st) as char == ';')\n         }\n         case (_) { }\n     }\n     ret res;\n }\n \n+fn parse_path(@pstate st, str_def sd) -> ast::path {\n+    let vec[ast::ident] idents = [];\n+    fn is_last(char c) -> bool {\n+        ret (c == '(' || c == ':');\n+    }\n+    idents += [parse_ident_(st, sd, is_last)];\n+    while (true) {\n+        alt (peek(st) as char) {\n+            case (':') {\n+                auto ignore = next(st);\n+                ignore = next(st);\n+            }\n+            case (?c) {\n+                if (c == '(') {\n+                    ret respan(rec(lo=0u, hi=0u),\n+                               rec(idents=idents, types=[]));\n+                }\n+                else {\n+                    idents += [parse_ident_(st, sd, is_last)];\n+                }\n+            }\n+        }\n+    }\n+    fail \"parse_path: ill-formed path\";\n+}\n+\n fn parse_constr(@pstate st, str_def sd) -> @ty::constr_def {\n-    st.tcx.sess.unimpl(\"Reading constraints \" + \" isn't implemented\");\n-    /*\n     let vec[@ast::constr_arg] args = [];\n-    auto sp = rec(lo=0u,hi=0u); // FIXME\n-    let vec[ast::ident] ids = [];\n-    let vec[@ast::ty] tys = [];\n-    let ast::path pth = respan(sp,\n-                               rec(idents=ids, types=tys)); // FIXME\n-    let ast::ident p1 = parse_ident(st, sd, '(');\n-    log_err(\"ignore=\");\n-    log_err(p1);\n+    auto sp = rec(lo=0u,hi=0u); // FIXME: use a real span\n+    let ast::path pth = parse_path(st, sd);\n     let char ignore = next(st) as char;\n     assert(ignore as char == '(');\n     auto def = parse_def(st, sd);\n     do {\n         alt (peek(st) as char) {\n             case ('*') {\n-                auto ignore = next(st);\n+                st.pos += 1u;\n                 args += [@respan(sp, ast::carg_base)];\n             }\n             case (?c) {\n-                log_err(\"c =\");\n-                log_err(str::from_bytes([c as u8]));\n-                if (may_begin_ident(c)) {\n-                    auto id = parse_ident(st, sd, ',');\n-                    args += [@respan(sp, ast::carg_ident(id))];\n+                /* how will we disambiguate between\n+                 an arg index and a lit argument? */\n+                if (c >= '0' && c <= '9') {\n+                    // FIXME\n+                    args += [@respan(sp, ast::carg_ident((c as uint) - 48u))];\n+                    ignore = next(st) as char;\n                 }\n                 else {\n                     log_err(\"Lit args are unimplemented\");\n@@ -132,10 +160,10 @@ fn parse_constr(@pstate st, str_def sd) -> @ty::constr_def {\n                 */\n             }\n         }\n-    } while (next(st) as char == ',');\n-    ignore = next(st) as char;\n-    */\n-\n+        ignore = next(st) as char;\n+    } while (ignore == ';');\n+    assert(ignore == ')');\n+    ret @respan(sp, rec(path=pth, args=args, id=def));\n }\n \n fn parse_ty(@pstate st, str_def sd) -> ty::t {\n@@ -333,7 +361,7 @@ fn parse_ty_fn(@pstate st, str_def sd) ->\n         }\n         inputs += [rec(mode=mode, ty=parse_ty(st, sd))];\n     }\n-    st.pos = st.pos + 1u;\n+    st.pos += 1u; // eat the ']'\n     auto cs = parse_constrs(st, sd);\n     auto res = parse_ty_or_bang(st, sd);\n     alt (res) {\n@@ -641,6 +669,7 @@ fn kind_has_type_params(u8 kind_ch) -> bool {\n     ret alt (kind_ch as char) {\n             case ('c') { false }\n             case ('f') { true }\n+            case ('p') { true }\n             case ('F') { true }\n             case ('y') { true }\n             case ('o') { true }\n@@ -669,7 +698,8 @@ fn lookup_def(int cnum, vec[u8] data, &ast::def_id did_) -> ast::def {\n     auto def =\n         alt (kind_ch as char) {\n             case ('c') { ast::def_const(did) }\n-            case ('f') { ast::def_fn(did) }\n+            case ('f') { ast::def_fn(did, ast::impure_fn) }\n+            case ('p') { ast::def_fn(did, ast::pure_fn) }\n             case ('F') { ast::def_native_fn(did) }\n             case ('y') { ast::def_ty(did) }\n             case ('o') { ast::def_obj(did) }\n@@ -781,6 +811,7 @@ fn item_kind_to_str(u8 kind) -> str {\n     alt (kind as char) {\n         case ('c') { ret \"const\"; }\n         case ('f') { ret \"fn\"; }\n+        case ('p') { ret \"pred\"; }\n         case ('F') { ret \"native fn\"; }\n         case ('y') { ret \"type\"; }\n         case ('o') { ret \"obj\"; }"}, {"sha": "ef3ddcf016c515324c87a77f0e29706dc78649af", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -264,34 +264,37 @@ mod Encode {\n             enc_ty(w, cx, arg.ty);\n         }\n         w.write_char(']');\n-        alt (cf) {\n-            case (noreturn) { w.write_char('!'); }\n-            case (_) { enc_ty(w, cx, out); }\n-        }\n         auto colon = true;\n         for (@ty::constr_def c in constrs) {\n             if (colon) {\n                 w.write_char(':');\n                 colon = false;\n-            } else { w.write_char(','); }\n+            } else { w.write_char(';'); }\n             enc_constr(w, cx, c);\n         }\n+        alt (cf) {\n+            case (noreturn) { w.write_char('!'); }\n+            case (_) { enc_ty(w, cx, out); }\n+        }\n+\n     }\n     fn enc_constr(&io::writer w, &@ctxt cx, &@ty::constr_def c) {\n         w.write_str(path_to_str(c.node.path));\n         w.write_char('(');\n-        // FIXME\n-        //   w.write_str(cx.ds(c.node.id));\n-\n-        auto comma = false;\n+        w.write_str(cx.ds(c.node.id));\n+        w.write_char('|');\n+        auto semi = false;\n         for (@constr_arg a in c.node.args) {\n-            if (comma) { w.write_char(','); } else { comma = true; }\n+            if (semi) { w.write_char(';'); } else { semi = true; }\n             alt (a.node) {\n                 case (carg_base) { w.write_char('*'); }\n-                case (carg_ident(?i)) { w.write_uint(i); }\n+                case (carg_ident(?i)) { \n+                    w.write_uint(i);\n+                }\n                 case (carg_lit(?l)) { w.write_str(lit_to_str(l)); }\n             }\n         }\n+        w.write_char(')');\n     }\n }\n \n@@ -506,10 +509,12 @@ fn encode_info_for_item(@trans::crate_ctxt cx, &ebml::writer ebml_w,\n             encode_symbol(cx, ebml_w, item.id);\n             ebml::end_tag(ebml_w);\n         }\n-        case (item_fn(_, ?tps)) {\n+        case (item_fn(?fd, ?tps)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'f' as u8);\n+            encode_kind(ebml_w, alt (fd.decl.purity) {\n+                                  case (pure_fn) { 'p' }\n+                                  case (impure_fn) { 'f' } } as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(cx, ebml_w, trans::node_id_type(cx, item.id));\n             encode_symbol(cx, ebml_w, item.id);"}, {"sha": "180b422d5e5dd4259bc85b7087d9a2d962f4b45b", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -412,7 +412,7 @@ fn resolve_constr(@env e, node_id id, &@ast::constr c, &scopes sc,\n         lookup_path_strict(*e, sc, c.span, c.node.path.node.idents, ns_value);\n     if (option::is_some(new_def)) {\n         alt (option::get(new_def)) {\n-            case (ast::def_fn(?pred_id)) {\n+            case (ast::def_fn(?pred_id, _)) {\n                 let ty::constr_general[uint] c_ =\n                     rec(path=c.node.path, args=c.node.args, id=pred_id);\n                 let ty::constr_def new_constr = respan(c.span, c_);\n@@ -799,9 +799,9 @@ fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n                 ret some(ast::def_const(local_def(i.id)));\n             }\n         }\n-        case (ast::item_fn(_, _)) {\n+        case (ast::item_fn(?f, _)) {\n             if (ns == ns_value) {\n-                ret some(ast::def_fn(local_def(i.id)));\n+                ret some(ast::def_fn(local_def(i.id), f.decl.purity));\n             }\n         }\n         case (ast::item_mod(_)) {\n@@ -1122,7 +1122,7 @@ fn index_nmod(&ast::native_mod md) -> mod_index {\n // External lookups\n fn ns_for_def(def d) -> namespace {\n     ret alt (d) {\n-            case (ast::def_fn(?id)) { ns_value }\n+            case (ast::def_fn(?id, _)) { ns_value }\n             case (ast::def_obj(?id)) { ns_value }\n             case (ast::def_obj_field(?id)) { ns_value }\n             case (ast::def_mod(?id)) { ns_module }"}, {"sha": "9f6d47b90d4e988aa4526248535ce7567f714bbb", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -4681,7 +4681,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n             assert (cx.fcx.llobjfields.contains_key(did._1));\n             ret lval_mem(cx, cx.fcx.llobjfields.get(did._1));\n         }\n-        case (ast::def_fn(?did)) {\n+        case (ast::def_fn(?did, _)) {\n             auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, did);\n             ret lval_generic_fn(cx, tyt, did, id);\n         }"}, {"sha": "d2b6a2491220b568bcc07ab5b03318c99d68f6da", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -537,7 +537,7 @@ fn node_id_for_constr(ty::ctxt tcx, node_id t) -> node_id {\n         case (none) {\n             tcx.sess.bug(\"node_id_for_constr: bad node_id \" + istr(t));\n         }\n-        case (some(def_fn(?i))) { ret i._1; }\n+        case (some(def_fn(?i,_))) { ret i._1; }\n         case (_) {\n             tcx.sess.bug(\"node_id_for_constr: pred is not a function\");\n         }"}, {"sha": "b38c9237cef6176d160bf9f78edd52b63fb73657", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -2610,7 +2610,7 @@ fn substitute_type_params(&ctxt cx, vec[ty::t] substs, t typ) -> t {\n \n fn def_has_ty_params(&ast::def def) -> bool {\n     alt (def) {\n-        case (ast::def_fn(_)) { ret true; }\n+        case (ast::def_fn(_,_)) { ret true; }\n         case (ast::def_obj(_)) { ret true; }\n         case (ast::def_obj_field(_)) { ret false; }\n         case (ast::def_mod(_)) { ret false; }"}, {"sha": "3a33e64b6b90976a3d433933067a5a514a137edc", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 19, "deletions": 59, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -48,13 +48,10 @@ import middle::tstate::ann::ts_ann;\n \n type ty_table = hashmap[ast::def_id, ty::t];\n \n-type fn_purity_table = hashmap[ast::def_id, ast::purity];\n-\n type obj_info = rec(vec[ast::obj_field] obj_fields, ast::node_id this_obj);\n \n type crate_ctxt =\n     rec(mutable vec[obj_info] obj_infos,\n-        @fn_purity_table fn_purity_table,\n         ty::ctxt tcx);\n \n type fn_ctxt =\n@@ -91,7 +88,9 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn) ->\n             auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id._1));\n             ret tup(0u, typ);\n         }\n-        case (ast::def_fn(?id)) { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n+        case (ast::def_fn(?id, _)) {\n+            ret ty::lookup_item_type(fcx.ccx.tcx, id);\n+        }\n         case (ast::def_native_fn(?id)) {\n             ret ty::lookup_item_type(fcx.ccx.tcx, id);\n         }\n@@ -1271,51 +1270,24 @@ fn require_impure(&session::session sess, &ast::purity f_purity, &span sp) {\n     }\n }\n \n-fn get_function_purity(@crate_ctxt ccx, &ast::def_id d_id) -> ast::purity {\n-    let option::t[ast::purity] o = ccx.fn_purity_table.find(d_id);\n-    ret from_maybe[ast::purity](ast::impure_fn, o);\n-}\n-\n fn require_pure_call(@crate_ctxt ccx, &ast::purity caller_purity,\n                      &@ast::expr callee, &span sp) {\n     alt (caller_purity) {\n         case (ast::impure_fn) { ret; }\n         case (ast::pure_fn) {\n-            alt (callee.node) {\n-                case (ast::expr_path(_)) {\n-                    auto d_id;\n-                    alt (ccx.tcx.def_map.get(callee.id)) {\n-                        case (ast::def_fn(?_d_id)) { d_id = _d_id; }\n-                    }\n-                    alt (get_function_purity(ccx, d_id)) {\n-                        case (ast::pure_fn) { ret; }\n-                        case (_) {\n-                            ccx.tcx.sess.span_fatal(sp,\n-                                                  \"Pure function calls \\\n-                                                   impure function\");\n-                        }\n-                    }\n+            alt (ccx.tcx.def_map.get(callee.id)) {\n+                case (ast::def_fn(_, ast::pure_fn)) {\n+                    ret;\n                 }\n                 case (_) {\n                     ccx.tcx.sess.span_fatal(sp,\n-                                          \"Pure function calls \\\n-                                           unknown function\");\n+                     \"Pure function calls function not known to be pure\");\n                 }\n             }\n         }\n     }\n }\n \n-fn require_pure_function(@crate_ctxt ccx, &ast::def_id d_id, &span sp) {\n-    alt (get_function_purity(ccx, d_id)) {\n-        case (ast::impure_fn) {\n-            ccx.tcx.sess.span_fatal(sp,\n-                                  \"Found non-predicate in check expression\");\n-        }\n-        case (_) { ret; }\n-    }\n-}\n-\n fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     // fcx.ccx.tcx.sess.span_warn(expr.span, \"typechecking expr \" +\n     //                                pretty::pprust::expr_to_str(expr));\n@@ -1428,9 +1400,15 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (ast::expr_call(?operator, ?operands)) {\n                     alt (operator.node) {\n                         case (ast::expr_path(?oper_name)) {\n-                            auto d_id;\n                             alt (fcx.ccx.tcx.def_map.get(operator.id)) {\n-                                case (ast::def_fn(?_d_id)) { d_id = _d_id; }\n+                                case (ast::def_fn(?_d_id, ast::pure_fn)) { \n+                                    // do nothing\n+                                }\n+                                case (_) {\n+                                    fcx.ccx.tcx.sess.span_fatal(operator.span,\n+                                      \"non-predicate as operator \\\n+                                       in constraint\");\n+                                }\n                             }\n                             for (@ast::expr operand in operands) {\n                                 if (!ast::is_constraint_arg(operand)) {\n@@ -1439,7 +1417,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                     fcx.ccx.tcx.sess.span_fatal(e.span, s);\n                                 }\n                             }\n-                            require_pure_function(fcx.ccx, d_id, e.span);\n                         }\n                         case (_) {\n                             auto s = \"In a constraint, expected the \\\n@@ -2193,14 +2170,15 @@ fn get_obj_info(&@crate_ctxt ccx) -> option::t[obj_info] {\n fn ast_constr_to_constr(ty::ctxt tcx, &@ast::constr c)\n     -> @ty::constr_def {\n     alt (tcx.def_map.find(c.node.id)) {\n-        case (some(ast::def_fn(?pred_id))) {\n+        case (some(ast::def_fn(?pred_id, ast::pure_fn))) {\n             ret @respan(c.span, rec(path=c.node.path, args=c.node.args,\n                                     id=pred_id));\n         }\n         case (_) {\n             tcx.sess.span_fatal(c.span, \"Predicate \"\n                               + path_to_str(c.node.path)\n-                              + \" is unbound or bound to a non-function\");\n+                              + \" is unbound or bound to a non-function or an\\\n+                                impure function\");\n         }\n     }\n }\n@@ -2372,30 +2350,12 @@ fn check_item(@crate_ctxt ccx, &@ast::item it) {\n     }\n }\n \n-fn mk_fn_purity_table(&@ast::crate crate) -> @fn_purity_table {\n-    auto res = @new_def_hash[ast::purity]();\n-    fn do_one(@fn_purity_table t, &@ast::item i) {\n-        alt (i.node) {\n-            case (ast::item_fn(?f, _)) {\n-                t.insert(local_def(i.id), f.decl.purity);\n-            }\n-            case (_) { }\n-        }\n-    }\n-    auto do_one_fn = bind do_one(res, _);\n-    auto v = walk::default_visitor();\n-    auto add_fn_entry_visitor = rec(visit_item_post=do_one_fn with v);\n-    walk::walk_crate(add_fn_entry_visitor, *crate);\n-    ret res;\n-}\n-\n fn check_crate(&ty::ctxt tcx, &@ast::crate crate) {\n     collect::collect_item_types(tcx, crate);\n     let vec[obj_info] obj_infos = [];\n-    auto fpt = mk_fn_purity_table(crate); // use a variation on collect\n \n     auto ccx =\n-        @rec(mutable obj_infos=obj_infos, fn_purity_table=fpt, tcx=tcx);\n+        @rec(mutable obj_infos=obj_infos, tcx=tcx);\n     auto visit =\n         rec(visit_item_pre=bind check_item(ccx, _)\n             with walk::default_visitor());"}, {"sha": "3ad63093ddc77085130fd3d461401e717047c261", "filename": "src/lib/str.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -1,6 +1,7 @@\n \n import rustrt::sbuf;\n import vec::rustrt::vbuf;\n+import uint::le;\n export sbuf;\n export rustrt;\n export eq;\n@@ -45,6 +46,7 @@ export split;\n export concat;\n export connect;\n export to_upper;\n+export safe_slice;\n \n native \"rust\" mod rustrt {\n     type sbuf;\n@@ -381,6 +383,12 @@ fn slice(str s, uint begin, uint end) -> str {\n     ret rustrt::str_slice(s, begin, end);\n }\n \n+fn safe_slice(str s, uint begin, uint end) : le(begin, end) -> str {\n+    assert (end <= str::byte_len(s)); // would need some magic to\n+                                      // make this a precondition\n+    ret rustrt::str_slice(s, begin, end);\n+}\n+\n fn shift_byte(&mutable str s) -> u8 {\n     auto len = byte_len(s);\n     assert (len > 0u);"}, {"sha": "ca632914a4592202eba20e843de02331faeffd45", "filename": "src/lib/uint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -10,17 +10,17 @@ fn div(uint x, uint y) -> uint { ret x / y; }\n \n fn rem(uint x, uint y) -> uint { ret x % y; }\n \n-fn lt(uint x, uint y) -> bool { ret x < y; }\n+pred lt(uint x, uint y) -> bool { ret x < y; }\n \n-fn le(uint x, uint y) -> bool { ret x <= y; }\n+pred le(uint x, uint y) -> bool { ret x <= y; }\n \n-fn eq(uint x, uint y) -> bool { ret x == y; }\n+pred eq(uint x, uint y) -> bool { ret x == y; }\n \n-fn ne(uint x, uint y) -> bool { ret x != y; }\n+pred ne(uint x, uint y) -> bool { ret x != y; }\n \n-fn ge(uint x, uint y) -> bool { ret x >= y; }\n+pred ge(uint x, uint y) -> bool { ret x >= y; }\n \n-fn gt(uint x, uint y) -> bool { ret x > y; }\n+pred gt(uint x, uint y) -> bool { ret x > y; }\n \n fn max(uint x, uint y) -> uint { if (x > y) { ret x; } ret y; }\n "}, {"sha": "85f3c8c7988711d0e1f6786498f98fbb4241062d", "filename": "src/test/compile-fail/fn-constraint.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -0,0 +1,9 @@\n+// error-pattern: Unsatisfied precondition constraint (for example, le(a, b)\n+use std;\n+import std::str::*;\n+\n+fn main() {\n+  let uint a = 4u;\n+  let uint b = 1u;\n+  log_err (safe_slice(\"kitties\", a, b));\n+}\n\\ No newline at end of file"}, {"sha": "5c046ed26da08c8c4f0f56dfe55e1b5dbaade082", "filename": "src/test/compile-fail/impure-pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -1,5 +1,5 @@\n // -*- rust -*-\n-// error-pattern: impure function\n+// error-pattern: Pure function calls function not known to be pure\n \n fn g() -> () {}\n "}, {"sha": "0425c1a67e5cbd1ce1ef0494cb19b5754ad4b9dc", "filename": "src/test/compile-fail/not-pred-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -2,7 +2,7 @@\n \n // error-pattern: Constraint args must be\n \n-fn f(int q) -> bool { ret true; }\n+pred f(int q) -> bool { ret true; }\n \n fn main() {\n // should fail to typecheck, as pred args must be slot variables or literals"}, {"sha": "3f7933465b7273d3b40112c0fa2a9038e897ffb1", "filename": "src/test/run-fail/fn-constraint.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -0,0 +1,11 @@\n+// error-pattern:Predicate le(a, b) failed\n+use std;\n+import std::str::*;\n+import std::uint::le;\n+\n+fn main() {\n+  let uint a = 4u;\n+  let uint b = 1u;\n+  check le(a, b);\n+  log_err (safe_slice(\"kitties\", a, b));\n+}\n\\ No newline at end of file"}, {"sha": "1e55fc45445239aea9a507923428b4fb74dc8814", "filename": "src/test/run-pass/fn-constraint.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-constraint.rs?ref=7fb35ecf84c3fd5f92c2af287d478eb70cbacdbd", "patch": "@@ -0,0 +1,10 @@\n+use std;\n+import std::str::*;\n+import std::uint::*;\n+\n+fn main() {\n+  let uint a = 1u;\n+  let uint b = 4u;\n+  check le(a, b);\n+  log (safe_slice(\"kitties\", a, b)); \n+}\n\\ No newline at end of file"}]}