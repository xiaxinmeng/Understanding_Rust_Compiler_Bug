{"sha": "68ebe640b6c99f53fee53671e09c673c8c17726a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZWJlNjQwYjZjOTlmNTNmZWU1MzY3MWUwOWM2NzNjOGMxNzcyNmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-12T15:35:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-18T15:25:12Z"}, "message": "Fallout: port btree to use Unique, some markers.", "tree": {"sha": "7ea42729a1b28f2a17a83ee50b373e1331b69ac0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ea42729a1b28f2a17a83ee50b373e1331b69ac0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68ebe640b6c99f53fee53671e09c673c8c17726a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68ebe640b6c99f53fee53671e09c673c8c17726a", "html_url": "https://github.com/rust-lang/rust/commit/68ebe640b6c99f53fee53671e09c673c8c17726a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68ebe640b6c99f53fee53671e09c673c8c17726a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3c00a69f23b68cba2901eb98b3de7dfc6990396", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3c00a69f23b68cba2901eb98b3de7dfc6990396", "html_url": "https://github.com/rust-lang/rust/commit/b3c00a69f23b68cba2901eb98b3de7dfc6990396"}], "stats": {"total": 84, "additions": 52, "deletions": 32}, "files": [{"sha": "4d10d99421e2285d0ee41ead0298475ad6244054", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 52, "deletions": 32, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/68ebe640b6c99f53fee53671e09c673c8c17726a/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68ebe640b6c99f53fee53671e09c673c8c17726a/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=68ebe640b6c99f53fee53671e09c673c8c17726a", "patch": "@@ -21,10 +21,11 @@ use core::prelude::*;\n use core::borrow::BorrowFrom;\n use core::cmp::Ordering::{Greater, Less, Equal};\n use core::iter::Zip;\n+use core::marker::PhantomData;\n use core::ops::{Deref, DerefMut, Index, IndexMut};\n use core::ptr::Unique;\n use core::{slice, mem, ptr, cmp, num, raw};\n-use alloc::heap;\n+use alloc::heap::{self, EMPTY};\n \n /// Represents the result of an Insertion: either the item fit, or the node had to split\n pub enum InsertionResult<K, V> {\n@@ -57,8 +58,8 @@ pub struct Node<K, V> {\n     keys: Unique<K>,\n     vals: Unique<V>,\n \n-    // In leaf nodes, this will be null, and no space will be allocated for edges.\n-    edges: Unique<Node<K, V>>,\n+    // In leaf nodes, this will be None, and no space will be allocated for edges.\n+    edges: Option<Unique<Node<K, V>>>,\n \n     // At any given time, there will be `_len` keys, `_len` values, and (in an internal node)\n     // `_len + 1` edges. In a leaf node, there will never be any edges.\n@@ -278,8 +279,11 @@ impl<T> Drop for RawItems<T> {\n #[unsafe_destructor]\n impl<K, V> Drop for Node<K, V> {\n     fn drop(&mut self) {\n-        if self.keys.ptr.is_null() {\n-            // We have already cleaned up this node.\n+        if self.keys.is_null() {\n+            // Since we have #[unsafe_no_drop_flag], we have to watch\n+            // out for a null value being stored in self.keys. (Using\n+            // null is technically a violation of the `Unique`\n+            // requirements, though.)\n             return;\n         }\n \n@@ -292,7 +296,7 @@ impl<K, V> Drop for Node<K, V> {\n             self.destroy();\n         }\n \n-        self.keys.ptr = ptr::null_mut();\n+        self.keys = unsafe { Unique::new(0 as *mut K) };\n     }\n }\n \n@@ -308,9 +312,9 @@ impl<K, V> Node<K, V> {\n         let (vals_offset, edges_offset) = calculate_offsets_generic::<K, V>(capacity, false);\n \n         Node {\n-            keys: Unique(buffer as *mut K),\n-            vals: Unique(buffer.offset(vals_offset as isize) as *mut V),\n-            edges: Unique(buffer.offset(edges_offset as isize) as *mut Node<K, V>),\n+            keys: Unique::new(buffer as *mut K),\n+            vals: Unique::new(buffer.offset(vals_offset as isize) as *mut V),\n+            edges: Some(Unique::new(buffer.offset(edges_offset as isize) as *mut Node<K, V>)),\n             _len: 0,\n             _capacity: capacity,\n         }\n@@ -326,9 +330,9 @@ impl<K, V> Node<K, V> {\n         let (vals_offset, _) = calculate_offsets_generic::<K, V>(capacity, true);\n \n         Node {\n-            keys: Unique(buffer as *mut K),\n-            vals: Unique(unsafe { buffer.offset(vals_offset as isize) as *mut V }),\n-            edges: Unique(ptr::null_mut()),\n+            keys: unsafe { Unique::new(buffer as *mut K) },\n+            vals: unsafe { Unique::new(buffer.offset(vals_offset as isize) as *mut V) },\n+            edges: None,\n             _len: 0,\n             _capacity: capacity,\n         }\n@@ -337,18 +341,18 @@ impl<K, V> Node<K, V> {\n     unsafe fn destroy(&mut self) {\n         let (alignment, size) =\n                 calculate_allocation_generic::<K, V>(self.capacity(), self.is_leaf());\n-        heap::deallocate(self.keys.ptr as *mut u8, size, alignment);\n+        heap::deallocate(*self.keys as *mut u8, size, alignment);\n     }\n \n     #[inline]\n     pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n         unsafe {(\n             mem::transmute(raw::Slice {\n-                data: self.keys.ptr,\n+                data: *self.keys as *const K,\n                 len: self.len()\n             }),\n             mem::transmute(raw::Slice {\n-                data: self.vals.ptr,\n+                data: *self.vals as *const V,\n                 len: self.len()\n             })\n         )}\n@@ -367,8 +371,12 @@ impl<K, V> Node<K, V> {\n             &[]\n         } else {\n             unsafe {\n+                let data = match self.edges {\n+                    None => heap::EMPTY as *const Node<K,V>,\n+                    Some(ref p) => **p as *const Node<K,V>,\n+                };\n                 mem::transmute(raw::Slice {\n-                    data: self.edges.ptr,\n+                    data: data,\n                     len: self.len() + 1\n                 })\n             }\n@@ -524,7 +532,8 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n #[derive(Copy)]\n pub struct Handle<NodeRef, Type, NodeType> {\n     node: NodeRef,\n-    index: usize\n+    index: usize,\n+    marker: PhantomData<(Type, NodeType)>,\n }\n \n pub mod handle {\n@@ -548,8 +557,8 @@ impl<K: Ord, V> Node<K, V> {\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for usizes.\n         match node.as_slices_internal().search_linear(key) {\n-            (index, true) => Found(Handle { node: node, index: index }),\n-            (index, false) => GoDown(Handle { node: node, index: index }),\n+            (index, true) => Found(Handle { node: node, index: index, marker: PhantomData }),\n+            (index, false) => GoDown(Handle { node: node, index: index, marker: PhantomData }),\n         }\n     }\n }\n@@ -586,7 +595,7 @@ impl <K, V> Node<K, V> {\n \n     /// If the node has any children\n     pub fn is_leaf(&self) -> bool {\n-        self.edges.ptr.is_null()\n+        self.edges.is_none()\n     }\n \n     /// if the node has too few elements\n@@ -618,7 +627,8 @@ impl<K, V, NodeRef, Type, NodeType> Handle<NodeRef, Type, NodeType> where\n     pub fn as_raw(&mut self) -> Handle<*mut Node<K, V>, Type, NodeType> {\n         Handle {\n             node: &mut *self.node as *mut _,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -630,7 +640,8 @@ impl<K, V, Type, NodeType> Handle<*mut Node<K, V>, Type, NodeType> {\n     pub unsafe fn from_raw<'a>(&'a self) -> Handle<&'a Node<K, V>, Type, NodeType> {\n         Handle {\n             node: &*self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -640,7 +651,8 @@ impl<K, V, Type, NodeType> Handle<*mut Node<K, V>, Type, NodeType> {\n     pub unsafe fn from_raw_mut<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, Type, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -688,12 +700,14 @@ impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type> Handle<NodeRef, Type, handle\n         if self.node.is_leaf() {\n             Leaf(Handle {\n                 node: self.node,\n-                index: self.index\n+                index: self.index,\n+                marker: PhantomData,\n             })\n         } else {\n             Internal(Handle {\n                 node: self.node,\n-                index: self.index\n+                index: self.index,\n+                marker: PhantomData,\n             })\n         }\n     }\n@@ -826,7 +840,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType> where\n     unsafe fn left_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index - 1\n+            index: self.index - 1,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -836,7 +851,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType> where\n     unsafe fn right_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -876,7 +892,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n     pub fn into_left_edge(self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -926,7 +943,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n     pub fn left_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -935,7 +953,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n     pub fn right_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index + 1\n+            index: self.index + 1,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -1044,7 +1063,8 @@ impl<K, V> Node<K, V> {\n         debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n         Handle {\n             node: self,\n-            index: index\n+            index: index,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -1064,7 +1084,7 @@ impl<K, V> Node<K, V> {\n                     vals: RawItems::from_slice(self.vals()),\n                     edges: RawItems::from_slice(self.edges()),\n \n-                    ptr: self.keys.ptr as *mut u8,\n+                    ptr: *self.keys as *mut u8,\n                     capacity: self.capacity(),\n                     is_leaf: self.is_leaf()\n                 },"}]}