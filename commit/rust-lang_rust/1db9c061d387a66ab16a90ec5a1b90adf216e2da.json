{"sha": "1db9c061d387a66ab16a90ec5a1b90adf216e2da", "node_id": "C_kwDOAAsO6NoAKDFkYjljMDYxZDM4N2E2NmFiMTZhOTBlYzVhMWI5MGFkZjIxNmUyZGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T20:56:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T20:56:38Z"}, "message": "Auto merge of #109453 - matthiaskrgr:rollup-odn02wu, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #96391 (Windows: make `Command` prefer non-verbatim paths)\n - #108164 (Drop all messages in bounded channel when destroying the last receiver)\n - #108729 (fix: modify the condition that `resolve_imports` stops)\n - #109336 (Constrain const vars to error if const types are mismatched)\n - #109403 (Avoid ICE of attempt to add with overflow in emitter)\n - #109415 (Refactor `handle_missing_lit`.)\n - #109441 (Only implement Fn* traits for extern \"Rust\" safe function pointers and items)\n - #109446 (Do not suggest bounds restrictions for synthesized RPITITs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7e7a041d9e2da492fd9b6ad2170afa4948a3f0ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e7a041d9e2da492fd9b6ad2170afa4948a3f0ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1db9c061d387a66ab16a90ec5a1b90adf216e2da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1db9c061d387a66ab16a90ec5a1b90adf216e2da", "html_url": "https://github.com/rust-lang/rust/commit/1db9c061d387a66ab16a90ec5a1b90adf216e2da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1db9c061d387a66ab16a90ec5a1b90adf216e2da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77d50a8870a912af1def75760b9638db892717c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/77d50a8870a912af1def75760b9638db892717c5", "html_url": "https://github.com/rust-lang/rust/commit/77d50a8870a912af1def75760b9638db892717c5"}, {"sha": "94d2028abd638366d338c8f24981240415129c90", "url": "https://api.github.com/repos/rust-lang/rust/commits/94d2028abd638366d338c8f24981240415129c90", "html_url": "https://github.com/rust-lang/rust/commit/94d2028abd638366d338c8f24981240415129c90"}], "stats": {"total": 736, "additions": 597, "deletions": 139}, "files": [{"sha": "9866a9bffe0e183dd2c28fa56bb712532a23cb2a", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -331,7 +331,7 @@ impl CodeSuggestion {\n                     });\n                     buf.push_str(&part.snippet);\n                     let cur_hi = sm.lookup_char_pos(part.span.hi());\n-                    if cur_hi.line == cur_lo.line {\n+                    if cur_hi.line == cur_lo.line && !part.snippet.is_empty() {\n                         // Account for the difference between the width of the current code and the\n                         // snippet being suggested, so that the *later* suggestions are correctly\n                         // aligned on the screen."}, {"sha": "4503af03ca341200fadd47c843d6e9c543bcce97", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -189,10 +189,19 @@ impl<'tcx> InferCtxt<'tcx> {\n         // the expected const's type. Specifically, we don't want const infer vars\n         // to do any type shapeshifting before and after resolution.\n         if let Err(guar) = compatible_types {\n-            return Ok(self.tcx.const_error_with_guaranteed(\n-                if relation.a_is_expected() { a.ty() } else { b.ty() },\n-                guar,\n-            ));\n+            // HACK: equating both sides with `[const error]` eagerly prevents us\n+            // from leaving unconstrained inference vars during things like impl\n+            // matching in the solver.\n+            let a_error = self.tcx.const_error_with_guaranteed(a.ty(), guar);\n+            if let ty::ConstKind::Infer(InferConst::Var(vid)) = a.kind() {\n+                return self.unify_const_variable(vid, a_error);\n+            }\n+            let b_error = self.tcx.const_error_with_guaranteed(b.ty(), guar);\n+            if let ty::ConstKind::Infer(InferConst::Var(vid)) = b.kind() {\n+                return self.unify_const_variable(vid, b_error);\n+            }\n+\n+            return Ok(if relation.a_is_expected() { a_error } else { b_error });\n         }\n \n         match (a.kind(), b.kind()) {"}, {"sha": "2a0536a1af72d66e2de2dedb9e14f6ce46f79c13", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -23,7 +23,7 @@ use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n-use rustc_target::spec::abi;\n+use rustc_target::spec::abi::{self, Abi};\n use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::fmt;\n@@ -1403,6 +1403,18 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn abi(&self) -> abi::Abi {\n         self.skip_binder().abi\n     }\n+\n+    pub fn is_fn_trait_compatible(&self) -> bool {\n+        matches!(\n+            self.skip_binder(),\n+            ty::FnSig {\n+                unsafety: rustc_hir::Unsafety::Normal,\n+                abi: Abi::Rust,\n+                c_variadic: false,\n+                ..\n+            }\n+        )\n+    }\n }\n \n pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<'tcx, FnSig<'tcx>>>;"}, {"sha": "8b69b3cb03683fd34beb71478b34ca44e2fec322", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -1843,20 +1843,14 @@ impl<'a> Parser<'a> {\n         &mut self,\n         mk_lit_char: impl FnOnce(Symbol, Span) -> L,\n     ) -> PResult<'a, L> {\n-        if let token::Interpolated(inner) = &self.token.kind {\n-            let expr = match inner.as_ref() {\n-                token::NtExpr(expr) => Some(expr),\n-                token::NtLiteral(expr) => Some(expr),\n-                _ => None,\n-            };\n-            if let Some(expr) = expr {\n-                if matches!(expr.kind, ExprKind::Err) {\n-                    let mut err = errors::InvalidInterpolatedExpression { span: self.token.span }\n-                        .into_diagnostic(&self.sess.span_diagnostic);\n-                    err.downgrade_to_delayed_bug();\n-                    return Err(err);\n-                }\n-            }\n+        if let token::Interpolated(nt) = &self.token.kind\n+            && let token::NtExpr(e) | token::NtLiteral(e) = &**nt\n+            && matches!(e.kind, ExprKind::Err)\n+        {\n+            let mut err = errors::InvalidInterpolatedExpression { span: self.token.span }\n+                .into_diagnostic(&self.sess.span_diagnostic);\n+            err.downgrade_to_delayed_bug();\n+            return Err(err);\n         }\n         let token = self.token.clone();\n         let err = |self_: &Self| {"}, {"sha": "4d4bc1be34973b241a0282fa75a1e184ebc798dd", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -423,13 +423,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n     pub(crate) fn resolve_imports(&mut self) {\n-        let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n-        while self.indeterminate_imports.len() < prev_num_indeterminates {\n-            prev_num_indeterminates = self.indeterminate_imports.len();\n+        let mut prev_indeterminate_count = usize::MAX;\n+        let mut indeterminate_count = self.indeterminate_imports.len() * 3;\n+        while indeterminate_count < prev_indeterminate_count {\n+            prev_indeterminate_count = indeterminate_count;\n+            indeterminate_count = 0;\n             for import in mem::take(&mut self.indeterminate_imports) {\n-                match self.resolve_import(&import) {\n-                    true => self.determined_imports.push(import),\n-                    false => self.indeterminate_imports.push(import),\n+                let import_indeterminate_count = self.resolve_import(&import);\n+                indeterminate_count += import_indeterminate_count;\n+                match import_indeterminate_count {\n+                    0 => self.determined_imports.push(import),\n+                    _ => self.indeterminate_imports.push(import),\n                 }\n             }\n         }\n@@ -581,9 +585,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         diag.emit();\n     }\n \n-    /// Attempts to resolve the given import, returning true if its resolution is determined.\n-    /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, import: &'a Import<'a>) -> bool {\n+    /// Attempts to resolve the given import, returning:\n+    /// - `0` means its resolution is determined.\n+    /// - Other values mean that indeterminate exists under certain namespaces.\n+    ///\n+    /// Meanwhile, if resolve successful, the resolved bindings are written\n+    /// into the module.\n+    fn resolve_import(&mut self, import: &'a Import<'a>) -> usize {\n         debug!(\n             \"(resolving import for module) resolving import `{}::...` in `{}`\",\n             Segment::names_to_string(&import.module_path),\n@@ -601,8 +609,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             match path_res {\n                 PathResult::Module(module) => module,\n-                PathResult::Indeterminate => return false,\n-                PathResult::NonModule(..) | PathResult::Failed { .. } => return true,\n+                PathResult::Indeterminate => return 3,\n+                PathResult::NonModule(..) | PathResult::Failed { .. } => return 0,\n             }\n         };\n \n@@ -618,12 +626,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } => (source, target, source_bindings, target_bindings, type_ns_only),\n             ImportKind::Glob { .. } => {\n                 self.resolve_glob_import(import);\n-                return true;\n+                return 0;\n             }\n             _ => unreachable!(),\n         };\n \n-        let mut indeterminate = false;\n+        let mut indeterminate_count = 0;\n         self.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n                 if let Err(Undetermined) = source_bindings[ns].get() {\n@@ -646,7 +654,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 let parent = import.parent_scope.module;\n                 match source_bindings[ns].get() {\n-                    Err(Undetermined) => indeterminate = true,\n+                    Err(Undetermined) => indeterminate_count += 1,\n                     // Don't update the resolution, because it was never added.\n                     Err(Determined) if target.name == kw::Underscore => {}\n                     Ok(binding) if binding.is_importable() => {\n@@ -670,7 +678,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         });\n \n-        !indeterminate\n+        indeterminate_count\n     }\n \n     /// Performs final import resolution, consistency checks and error reporting."}, {"sha": "9817186b874ccc8ee89987b29a54a1fefe6adabc", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -189,12 +189,28 @@ pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n     goal_kind: ty::ClosureKind,\n ) -> Result<Option<ty::Binder<'tcx, (Ty<'tcx>, Ty<'tcx>)>>, NoSolution> {\n     match *self_ty.kind() {\n-        ty::FnDef(def_id, substs) => Ok(Some(\n-            tcx.fn_sig(def_id)\n-                .subst(tcx, substs)\n-                .map_bound(|sig| (tcx.mk_tup(sig.inputs()), sig.output())),\n-        )),\n-        ty::FnPtr(sig) => Ok(Some(sig.map_bound(|sig| (tcx.mk_tup(sig.inputs()), sig.output())))),\n+        // keep this in sync with assemble_fn_pointer_candidates until the old solver is removed.\n+        ty::FnDef(def_id, substs) => {\n+            let sig = tcx.fn_sig(def_id);\n+            if sig.skip_binder().is_fn_trait_compatible()\n+                && tcx.codegen_fn_attrs(def_id).target_features.is_empty()\n+            {\n+                Ok(Some(\n+                    sig.subst(tcx, substs)\n+                        .map_bound(|sig| (tcx.mk_tup(sig.inputs()), sig.output())),\n+                ))\n+            } else {\n+                Err(NoSolution)\n+            }\n+        }\n+        // keep this in sync with assemble_fn_pointer_candidates until the old solver is removed.\n+        ty::FnPtr(sig) => {\n+            if sig.is_fn_trait_compatible() {\n+                Ok(Some(sig.map_bound(|sig| (tcx.mk_tup(sig.inputs()), sig.output()))))\n+            } else {\n+                Err(NoSolution)\n+            }\n+        }\n         ty::Closure(_, substs) => {\n             let closure_substs = substs.as_closure();\n             match closure_substs.kind_ty().to_opt_closure_kind() {"}, {"sha": "b501840b9260b749bbb444c29849e8569bd2bd57", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -420,6 +420,7 @@ fn suggest_restriction<'tcx>(\n ) {\n     if hir_generics.where_clause_span.from_expansion()\n         || hir_generics.where_clause_span.desugaring_kind().is_some()\n+        || projection.map_or(false, |projection| tcx.opt_rpitit_info(projection.def_id).is_some())\n     {\n         return;\n     }"}, {"sha": "e06eff34df21a4cf6c9cf347d8b7498b872c77aa", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -11,7 +11,6 @@ use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n-use rustc_target::spec::abi::Abi;\n \n use crate::traits;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -291,6 +290,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n+        // Keep this funtion in sync with extract_tupled_inputs_and_output_from_callable\n+        // until the old solver (and thus this function) is removed.\n+\n         // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n         let self_ty = obligation.self_ty().skip_binder();\n         match *self_ty.kind() {\n@@ -299,31 +301,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 candidates.ambiguous = true; // Could wind up being a fn() type.\n             }\n             // Provide an impl, but only for suitable `fn` pointers.\n-            ty::FnPtr(_) => {\n-                if let ty::FnSig {\n-                    unsafety: hir::Unsafety::Normal,\n-                    abi: Abi::Rust,\n-                    c_variadic: false,\n-                    ..\n-                } = self_ty.fn_sig(self.tcx()).skip_binder()\n-                {\n+            ty::FnPtr(sig) => {\n+                if sig.is_fn_trait_compatible() {\n                     candidates.vec.push(FnPointerCandidate { is_const: false });\n                 }\n             }\n             // Provide an impl for suitable functions, rejecting `#[target_feature]` functions (RFC 2396).\n             ty::FnDef(def_id, _) => {\n-                if let ty::FnSig {\n-                    unsafety: hir::Unsafety::Normal,\n-                    abi: Abi::Rust,\n-                    c_variadic: false,\n-                    ..\n-                } = self_ty.fn_sig(self.tcx()).skip_binder()\n+                if self.tcx().fn_sig(def_id).skip_binder().is_fn_trait_compatible()\n+                    && self.tcx().codegen_fn_attrs(def_id).target_features.is_empty()\n                 {\n-                    if self.tcx().codegen_fn_attrs(def_id).target_features.is_empty() {\n-                        candidates\n-                            .vec\n-                            .push(FnPointerCandidate { is_const: self.tcx().is_const_fn(def_id) });\n-                    }\n+                    candidates\n+                        .vec\n+                        .push(FnPointerCandidate { is_const: self.tcx().is_const_fn(def_id) });\n                 }\n             }\n             _ => {}"}, {"sha": "8546bbe52dcc39d369520f97958284dfc79f7225", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -22,7 +22,7 @@ use crate::traits::{\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{error_code, DelayDm, Diagnostic};\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt, TypeVisitableExt};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n@@ -350,6 +350,10 @@ fn report_conflicting_impls<'tcx>(\n         impl_span: Span,\n         err: &mut Diagnostic,\n     ) {\n+        if (overlap.trait_ref, overlap.self_ty).references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n+\n         match tcx.span_of_impl(overlap.with_impl) {\n             Ok(span) => {\n                 err.span_label(span, \"first implementation here\");"}, {"sha": "492e21d9bdb634b737e1a0d15ff2ba16adf1a732", "filename": "library/std/src/sync/mpmc/array.rs", "status": "modified", "additions": 83, "deletions": 24, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -25,7 +25,8 @@ struct Slot<T> {\n     /// The current stamp.\n     stamp: AtomicUsize,\n \n-    /// The message in this slot.\n+    /// The message in this slot. Either read out in `read` or dropped through\n+    /// `discard_all_messages`.\n     msg: UnsafeCell<MaybeUninit<T>>,\n }\n \n@@ -439,21 +440,99 @@ impl<T> Channel<T> {\n         Some(self.cap)\n     }\n \n-    /// Disconnects the channel and wakes up all blocked senders and receivers.\n+    /// Disconnects senders and wakes up all blocked receivers.\n     ///\n     /// Returns `true` if this call disconnected the channel.\n-    pub(crate) fn disconnect(&self) -> bool {\n+    pub(crate) fn disconnect_senders(&self) -> bool {\n         let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n \n         if tail & self.mark_bit == 0 {\n-            self.senders.disconnect();\n             self.receivers.disconnect();\n             true\n         } else {\n             false\n         }\n     }\n \n+    /// Disconnects receivers and wakes up all blocked senders.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    ///\n+    /// # Safety\n+    /// May only be called once upon dropping the last receiver. The\n+    /// destruction of all other receivers must have been observed with acquire\n+    /// ordering or stronger.\n+    pub(crate) unsafe fn disconnect_receivers(&self) -> bool {\n+        let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n+        let disconnected = if tail & self.mark_bit == 0 {\n+            self.senders.disconnect();\n+            true\n+        } else {\n+            false\n+        };\n+\n+        self.discard_all_messages(tail);\n+        disconnected\n+    }\n+\n+    /// Discards all messages.\n+    ///\n+    /// `tail` should be the current (and therefore last) value of `tail`.\n+    ///\n+    /// # Panicking\n+    /// If a destructor panics, the remaining messages are leaked, matching the\n+    /// behaviour of the unbounded channel.\n+    ///\n+    /// # Safety\n+    /// This method must only be called when dropping the last receiver. The\n+    /// destruction of all other receivers must have been observed with acquire\n+    /// ordering or stronger.\n+    unsafe fn discard_all_messages(&self, tail: usize) {\n+        debug_assert!(self.is_disconnected());\n+\n+        // Only receivers modify `head`, so since we are the last one,\n+        // this value will not change and will not be observed (since\n+        // no new messages can be sent after disconnection).\n+        let mut head = self.head.load(Ordering::Relaxed);\n+        let tail = tail & !self.mark_bit;\n+\n+        let backoff = Backoff::new();\n+        loop {\n+            // Deconstruct the head.\n+            let index = head & (self.mark_bit - 1);\n+            let lap = head & !(self.one_lap - 1);\n+\n+            // Inspect the corresponding slot.\n+            debug_assert!(index < self.buffer.len());\n+            let slot = unsafe { self.buffer.get_unchecked(index) };\n+            let stamp = slot.stamp.load(Ordering::Acquire);\n+\n+            // If the stamp is ahead of the head by 1, we may drop the message.\n+            if head + 1 == stamp {\n+                head = if index + 1 < self.cap {\n+                    // Same lap, incremented index.\n+                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n+                    head + 1\n+                } else {\n+                    // One lap forward, index wraps around to zero.\n+                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n+                    lap.wrapping_add(self.one_lap)\n+                };\n+\n+                unsafe {\n+                    (*slot.msg.get()).assume_init_drop();\n+                }\n+            // If the tail equals the head, that means the channel is empty.\n+            } else if tail == head {\n+                return;\n+            // Otherwise, a sender is about to write into the slot, so we need\n+            // to wait for it to update the stamp.\n+            } else {\n+                backoff.spin_heavy();\n+            }\n+        }\n+    }\n+\n     /// Returns `true` if the channel is disconnected.\n     pub(crate) fn is_disconnected(&self) -> bool {\n         self.tail.load(Ordering::SeqCst) & self.mark_bit != 0\n@@ -483,23 +562,3 @@ impl<T> Channel<T> {\n         head.wrapping_add(self.one_lap) == tail & !self.mark_bit\n     }\n }\n-\n-impl<T> Drop for Channel<T> {\n-    fn drop(&mut self) {\n-        // Get the index of the head.\n-        let hix = self.head.load(Ordering::Relaxed) & (self.mark_bit - 1);\n-\n-        // Loop over all slots that hold a message and drop them.\n-        for i in 0..self.len() {\n-            // Compute the index of the next slot holding a message.\n-            let index = if hix + i < self.cap { hix + i } else { hix + i - self.cap };\n-\n-            unsafe {\n-                debug_assert!(index < self.buffer.len());\n-                let slot = self.buffer.get_unchecked_mut(index);\n-                let msg = &mut *slot.msg.get();\n-                msg.as_mut_ptr().drop_in_place();\n-            }\n-        }\n-    }\n-}"}, {"sha": "2068dda393a2b632952b26e10786c181721975c0", "filename": "library/std/src/sync/mpmc/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -227,7 +227,7 @@ impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n         unsafe {\n             match &self.flavor {\n-                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect_senders()),\n                 SenderFlavor::List(chan) => chan.release(|c| c.disconnect_senders()),\n                 SenderFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n             }\n@@ -403,7 +403,7 @@ impl<T> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         unsafe {\n             match &self.flavor {\n-                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect_receivers()),\n                 ReceiverFlavor::List(chan) => chan.release(|c| c.disconnect_receivers()),\n                 ReceiverFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n             }"}, {"sha": "632709fd98d8691e3fcc64cd56f4792422c03d5f", "filename": "library/std/src/sync/mpsc/sync_tests.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use crate::env;\n+use crate::rc::Rc;\n use crate::sync::mpmc::SendTimeoutError;\n use crate::thread;\n use crate::time::Duration;\n@@ -656,3 +657,15 @@ fn issue_15761() {\n         repro()\n     }\n }\n+\n+#[test]\n+fn drop_unreceived() {\n+    let (tx, rx) = sync_channel::<Rc<()>>(1);\n+    let msg = Rc::new(());\n+    let weak = Rc::downgrade(&msg);\n+    assert!(tx.send(msg).is_ok());\n+    drop(rx);\n+    // Messages should be dropped immediately when the last receiver is destroyed.\n+    assert!(weak.upgrade().is_none());\n+    drop(tx);\n+}"}, {"sha": "43c0cdb657ef1d71d9cbf8fbc409fd66835724f8", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -11,10 +11,11 @@ use crate::fmt;\n use crate::io;\n use crate::num::NonZeroU16;\n use crate::os::windows::prelude::*;\n-use crate::path::PathBuf;\n-use crate::sys::c;\n+use crate::path::{Path, PathBuf};\n+use crate::sys::path::get_long_path;\n use crate::sys::process::ensure_no_nuls;\n use crate::sys::windows::os::current_exe;\n+use crate::sys::{c, to_u16s};\n use crate::sys_common::wstr::WStrUnits;\n use crate::vec;\n \n@@ -311,7 +312,7 @@ pub(crate) fn make_bat_command_line(\n /// Takes a path and tries to return a non-verbatim path.\n ///\n /// This is necessary because cmd.exe does not support verbatim paths.\n-pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n+pub(crate) fn to_user_path(path: &Path) -> io::Result<Vec<u16>> {\n     use crate::ptr;\n     use crate::sys::windows::fill_utf16_buf;\n \n@@ -324,6 +325,8 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n     const N: u16 = b'N' as _;\n     const C: u16 = b'C' as _;\n \n+    let mut path = to_u16s(path)?;\n+\n     // Early return if the path is too long to remove the verbatim prefix.\n     const LEGACY_MAX_PATH: usize = 260;\n     if path.len() > LEGACY_MAX_PATH {\n@@ -337,7 +340,13 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n             fill_utf16_buf(\n                 |buffer, size| c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut()),\n                 |full_path: &[u16]| {\n-                    if full_path == &path[4..path.len() - 1] { full_path.into() } else { path }\n+                    if full_path == &path[4..path.len() - 1] {\n+                        let mut path: Vec<u16> = full_path.into();\n+                        path.push(0);\n+                        path\n+                    } else {\n+                        path\n+                    }\n                 },\n             )\n         },\n@@ -350,7 +359,9 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n                 |buffer, size| c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut()),\n                 |full_path: &[u16]| {\n                     if full_path == &path[6..path.len() - 1] {\n-                        full_path.into()\n+                        let mut path: Vec<u16> = full_path.into();\n+                        path.push(0);\n+                        path\n                     } else {\n                         // Restore the 'C' in \"UNC\".\n                         path[6] = b'C' as u16;\n@@ -360,6 +371,6 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n             )\n         },\n         // For everything else, leave the path unchanged.\n-        _ => Ok(path),\n+        _ => get_long_path(path, false),\n     }\n }"}, {"sha": "c3573d14c7f929cb87cc13faf81e1a8a40d615f3", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -220,6 +220,19 @@ fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n ///\n /// This path may or may not have a verbatim prefix.\n pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n+    let path = to_u16s(path)?;\n+    get_long_path(path, true)\n+}\n+\n+/// Get a normalized absolute path that can bypass path length limits.\n+///\n+/// Setting prefer_verbatim to true suggests a stronger preference for verbatim\n+/// paths even when not strictly necessary. This allows the Windows API to avoid\n+/// repeating our work. However, if the path may be given back to users or\n+/// passed to other application then it's preferable to use non-verbatim paths\n+/// when possible. Non-verbatim paths are better understood by users and handled\n+/// by more software.\n+pub(crate) fn get_long_path(mut path: Vec<u16>, prefer_verbatim: bool) -> io::Result<Vec<u16>> {\n     // Normally the MAX_PATH is 260 UTF-16 code units (including the NULL).\n     // However, for APIs such as CreateDirectory[1], the limit is 248.\n     //\n@@ -243,7 +256,6 @@ pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n     // \\\\?\\UNC\\\n     const UNC_PREFIX: &[u16] = &[SEP, SEP, QUERY, SEP, U, N, C, SEP];\n \n-    let mut path = to_u16s(path)?;\n     if path.starts_with(VERBATIM_PREFIX) || path.starts_with(NT_PREFIX) || path == &[0] {\n         // Early return for paths that are already verbatim or empty.\n         return Ok(path);\n@@ -275,29 +287,34 @@ pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n         |mut absolute| {\n             path.clear();\n \n-            // Secondly, add the verbatim prefix. This is easier here because we know the\n-            // path is now absolute and fully normalized (e.g. `/` has been changed to `\\`).\n-            let prefix = match absolute {\n-                // C:\\ => \\\\?\\C:\\\n-                [_, COLON, SEP, ..] => VERBATIM_PREFIX,\n-                // \\\\.\\ => \\\\?\\\n-                [SEP, SEP, DOT, SEP, ..] => {\n-                    absolute = &absolute[4..];\n-                    VERBATIM_PREFIX\n-                }\n-                // Leave \\\\?\\ and \\??\\ as-is.\n-                [SEP, SEP, QUERY, SEP, ..] | [SEP, QUERY, QUERY, SEP, ..] => &[],\n-                // \\\\ => \\\\?\\UNC\\\n-                [SEP, SEP, ..] => {\n-                    absolute = &absolute[2..];\n-                    UNC_PREFIX\n-                }\n-                // Anything else we leave alone.\n-                _ => &[],\n-            };\n-\n-            path.reserve_exact(prefix.len() + absolute.len() + 1);\n-            path.extend_from_slice(prefix);\n+            // Only prepend the prefix if needed.\n+            if prefer_verbatim || absolute.len() + 1 >= LEGACY_MAX_PATH {\n+                // Secondly, add the verbatim prefix. This is easier here because we know the\n+                // path is now absolute and fully normalized (e.g. `/` has been changed to `\\`).\n+                let prefix = match absolute {\n+                    // C:\\ => \\\\?\\C:\\\n+                    [_, COLON, SEP, ..] => VERBATIM_PREFIX,\n+                    // \\\\.\\ => \\\\?\\\n+                    [SEP, SEP, DOT, SEP, ..] => {\n+                        absolute = &absolute[4..];\n+                        VERBATIM_PREFIX\n+                    }\n+                    // Leave \\\\?\\ and \\??\\ as-is.\n+                    [SEP, SEP, QUERY, SEP, ..] | [SEP, QUERY, QUERY, SEP, ..] => &[],\n+                    // \\\\ => \\\\?\\UNC\\\n+                    [SEP, SEP, ..] => {\n+                        absolute = &absolute[2..];\n+                        UNC_PREFIX\n+                    }\n+                    // Anything else we leave alone.\n+                    _ => &[],\n+                };\n+\n+                path.reserve_exact(prefix.len() + absolute.len() + 1);\n+                path.extend_from_slice(prefix);\n+            } else {\n+                path.reserve_exact(absolute.len() + 1);\n+            }\n             path.extend_from_slice(absolute);\n             path.push(0);\n         },"}, {"sha": "1c73b64e250ea76264536420eaec9f291d629ccf", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -266,11 +266,7 @@ impl Command {\n         let (program, mut cmd_str) = if is_batch_file {\n             (\n                 command_prompt()?,\n-                args::make_bat_command_line(\n-                    &args::to_user_path(program)?,\n-                    &self.args,\n-                    self.force_quotes_enabled,\n-                )?,\n+                args::make_bat_command_line(&program, &self.args, self.force_quotes_enabled)?,\n             )\n         } else {\n             let cmd_str = make_command_line(&self.program, &self.args, self.force_quotes_enabled)?;\n@@ -410,7 +406,7 @@ fn resolve_exe<'a>(\n         if has_exe_suffix {\n             // The application name is a path to a `.exe` file.\n             // Let `CreateProcessW` figure out if it exists or not.\n-            return path::maybe_verbatim(Path::new(exe_path));\n+            return args::to_user_path(Path::new(exe_path));\n         }\n         let mut path = PathBuf::from(exe_path);\n \n@@ -422,7 +418,7 @@ fn resolve_exe<'a>(\n             // It's ok to use `set_extension` here because the intent is to\n             // remove the extension that was just added.\n             path.set_extension(\"\");\n-            return path::maybe_verbatim(&path);\n+            return args::to_user_path(&path);\n         }\n     } else {\n         ensure_no_nuls(exe_path)?;\n@@ -510,7 +506,7 @@ where\n /// Check if a file exists without following symlinks.\n fn program_exists(path: &Path) -> Option<Vec<u16>> {\n     unsafe {\n-        let path = path::maybe_verbatim(path).ok()?;\n+        let path = args::to_user_path(path).ok()?;\n         // Getting attributes using `GetFileAttributesW` does not follow symlinks\n         // and it will almost always be successful if the link exists.\n         // There are some exceptions for special system files (e.g. the pagefile)"}, {"sha": "319ed582e2719eae56940b8ce1755c3a95c76d74", "filename": "tests/ui/async-await/in-trait/missing-send-bound.current.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.current.stderr?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/missing-send-bound.rs:3:12\n+  --> $DIR/missing-send-bound.rs:5:12\n    |\n LL | #![feature(async_fn_in_trait)]\n    |            ^^^^^^^^^^^^^^^^^\n@@ -8,19 +8,19 @@ LL | #![feature(async_fn_in_trait)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error: future cannot be sent between threads safely\n-  --> $DIR/missing-send-bound.rs:15:20\n+  --> $DIR/missing-send-bound.rs:17:20\n    |\n LL |     assert_is_send(test::<T>());\n    |                    ^^^^^^^^^^^ future returned by `test` is not `Send`\n    |\n    = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `impl Future<Output = ()>`\n note: future is not `Send` as it awaits another future which is not `Send`\n-  --> $DIR/missing-send-bound.rs:11:5\n+  --> $DIR/missing-send-bound.rs:13:5\n    |\n LL |     T::bar().await;\n    |     ^^^^^^^^ await occurs here on type `impl Future<Output = ()>`, which is not `Send`\n note: required by a bound in `assert_is_send`\n-  --> $DIR/missing-send-bound.rs:19:27\n+  --> $DIR/missing-send-bound.rs:21:27\n    |\n LL | fn assert_is_send(_: impl Send) {}\n    |                           ^^^^ required by this bound in `assert_is_send`", "previous_filename": "tests/ui/async-await/in-trait/missing-send-bound.stderr"}, {"sha": "319ed582e2719eae56940b8ce1755c3a95c76d74", "filename": "tests/ui/async-await/in-trait/missing-send-bound.next.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.next.stderr?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -0,0 +1,29 @@\n+warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/missing-send-bound.rs:5:12\n+   |\n+LL | #![feature(async_fn_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/missing-send-bound.rs:17:20\n+   |\n+LL |     assert_is_send(test::<T>());\n+   |                    ^^^^^^^^^^^ future returned by `test` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `impl Future<Output = ()>`\n+note: future is not `Send` as it awaits another future which is not `Send`\n+  --> $DIR/missing-send-bound.rs:13:5\n+   |\n+LL |     T::bar().await;\n+   |     ^^^^^^^^ await occurs here on type `impl Future<Output = ()>`, which is not `Send`\n+note: required by a bound in `assert_is_send`\n+  --> $DIR/missing-send-bound.rs:21:27\n+   |\n+LL | fn assert_is_send(_: impl Send) {}\n+   |                           ^^^^ required by this bound in `assert_is_send`\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "705fcf322f9eaa5cd09693d47c090715c28145b4", "filename": "tests/ui/async-await/in-trait/missing-send-bound.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fmissing-send-bound.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -1,4 +1,6 @@\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n //~^ WARN the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes"}, {"sha": "e13dfbacd242225c5eb374973abe9b1c3db57ca2", "filename": "tests/ui/const-generics/bad-subst-const-kind.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -0,0 +1,13 @@\n+// incremental\n+#![crate_type = \"lib\"]\n+\n+trait Q {\n+    const ASSOC: usize;\n+}\n+\n+impl<const N: u64> Q for [u8; N] {\n+    //~^ ERROR mismatched types\n+    const ASSOC: usize = 1;\n+}\n+\n+pub fn test() -> [u8; <[u8; 13] as Q>::ASSOC] { todo!() }"}, {"sha": "bd24f9140e4ea72912355109b1f662bb57dfb0cc", "filename": "tests/ui/const-generics/bad-subst-const-kind.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.stderr?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/bad-subst-const-kind.rs:8:31\n+   |\n+LL | impl<const N: u64> Q for [u8; N] {\n+   |                               ^ expected `usize`, found `u64`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "21aa81e80926ead1252b83b6cf06c2295fc3c943", "filename": "tests/ui/macros/nested-use-as.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fmacros%2Fnested-use-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fmacros%2Fnested-use-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fnested-use-as.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -0,0 +1,83 @@\n+// check-pass\n+// edition:2018\n+// issue: https://github.com/rust-lang/rust/issues/97534\n+\n+macro_rules! m {\n+    () => {\n+        macro_rules! foo {\n+            () => {}\n+        }\n+        use foo as bar;\n+    }\n+}\n+\n+m!{}\n+\n+use bar as baz;\n+\n+baz!{}\n+\n+macro_rules! foo2 {\n+    () => {};\n+}\n+\n+macro_rules! m2 {\n+    () => {\n+        use foo2 as bar2;\n+    };\n+}\n+\n+m2! {}\n+\n+use bar2 as baz2;\n+\n+baz2! {}\n+\n+macro_rules! n1 {\n+    () => {\n+        macro_rules! n2 {\n+            () => {\n+                macro_rules! n3 {\n+                    () => {\n+                        macro_rules! n4 {\n+                            () => {}\n+                        }\n+                        use n4 as c4;\n+                    }\n+                }\n+                use n3 as c3;\n+            }\n+        }\n+        use n2 as c2;\n+    }\n+}\n+\n+use n1 as c1;\n+c1!{}\n+use c2 as a2;\n+a2!{}\n+use c3 as a3;\n+a3!{}\n+use c4 as a4;\n+a4!{}\n+\n+// https://github.com/rust-lang/rust/pull/108729#issuecomment-1474750675\n+// reversed\n+use d5 as d6;\n+use d4 as d5;\n+use d3 as d4;\n+use d2 as d3;\n+use d1 as d2;\n+use foo2 as d1;\n+d6! {}\n+\n+// mess\n+use f3 as f4;\n+f5! {}\n+use f1 as f2;\n+use f4 as f5;\n+use f2 as f3;\n+use foo2 as f1;\n+\n+fn main() {\n+}"}, {"sha": "5fd7c647c253111888d7059dfe31f9c626f26fe0", "filename": "tests/ui/specialization/min_specialization/bad-const-wf-doesnt-specialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -2,11 +2,11 @@\n \n // An impl that has an erroneous const substitution should not specialize one\n // that is well-formed.\n-\n+#[derive(Clone)]\n struct S<const L: usize>;\n \n impl<const N: i32> Copy for S<N> {}\n+//~^ ERROR the constant `N` is not of type `usize`\n impl<const M: usize> Copy for S<M> {}\n-//~^ ERROR conflicting implementations of trait `Copy` for type `S<_>`\n \n fn main() {}"}, {"sha": "6d7028c5e7088e18cbf060cfae64233e3be8c857", "filename": "tests/ui/specialization/min_specialization/bad-const-wf-doesnt-specialize.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -1,11 +1,14 @@\n-error[E0119]: conflicting implementations of trait `Copy` for type `S<_>`\n-  --> $DIR/bad-const-wf-doesnt-specialize.rs:9:1\n+error: the constant `N` is not of type `usize`\n+  --> $DIR/bad-const-wf-doesnt-specialize.rs:8:29\n    |\n LL | impl<const N: i32> Copy for S<N> {}\n-   | -------------------------------- first implementation here\n-LL | impl<const M: usize> Copy for S<M> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `S<_>`\n+   |                             ^^^^\n+   |\n+note: required by a bound in `S`\n+  --> $DIR/bad-const-wf-doesnt-specialize.rs:6:10\n+   |\n+LL | struct S<const L: usize>;\n+   |          ^^^^^^^^^^^^^^ required by this bound in `S`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0119`."}, {"sha": "b6c464d45a2e30ad0c5ffb583178952580d58b9c", "filename": "tests/ui/suggestions/issue-109396.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fsuggestions%2Fissue-109396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fsuggestions%2Fissue-109396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-109396.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -0,0 +1,12 @@\n+fn main() {\n+    {\n+        let mut mutex = std::mem::zeroed(\n+            //~^ ERROR this function takes 0 arguments but 4 arguments were supplied\n+            file.as_raw_fd(),\n+            //~^ ERROR expected value, found macro `file`\n+            0,\n+            0,\n+            0,\n+        );\n+    }\n+}"}, {"sha": "eca160e2fab2c763e21a8cad3fb52a99fe3b24a0", "filename": "tests/ui/suggestions/issue-109396.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fsuggestions%2Fissue-109396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Fsuggestions%2Fissue-109396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-109396.stderr?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -0,0 +1,34 @@\n+error[E0423]: expected value, found macro `file`\n+  --> $DIR/issue-109396.rs:5:13\n+   |\n+LL |             file.as_raw_fd(),\n+   |             ^^^^ not a value\n+\n+error[E0061]: this function takes 0 arguments but 4 arguments were supplied\n+  --> $DIR/issue-109396.rs:3:25\n+   |\n+LL |         let mut mutex = std::mem::zeroed(\n+   |                         ^^^^^^^^^^^^^^^^\n+LL |\n+LL |             file.as_raw_fd(),\n+   |             ---------------- unexpected argument\n+LL |\n+LL |             0,\n+   |             - unexpected argument of type `{integer}`\n+LL |             0,\n+   |             - unexpected argument of type `{integer}`\n+LL |             0,\n+   |             - unexpected argument of type `{integer}`\n+   |\n+note: function defined here\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+help: remove the extra arguments\n+   |\n+LL -             file.as_raw_fd(),\n+LL +             ,\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0061, E0423.\n+For more information about an error, try `rustc --explain E0061`."}, {"sha": "0599e51d7ad8cca56a301706ec7365261dda663d", "filename": "tests/ui/traits/new-solver/fn-trait.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -1,13 +1,32 @@\n // compile-flags: -Ztrait-solver=next\n-// check-pass\n \n fn require_fn(_: impl Fn() -> i32) {}\n \n fn f() -> i32 {\n     1i32\n }\n \n+extern \"C\" fn g() -> i32 {\n+    2i32\n+}\n+\n+unsafe fn h() -> i32 {\n+    2i32\n+}\n+\n fn main() {\n     require_fn(f);\n     require_fn(f as fn() -> i32);\n+    require_fn(f as unsafe fn() -> i32);\n+    //~^ ERROR: expected a `Fn<()>` closure, found `unsafe fn() -> i32`\n+    //~| ERROR: type mismatch resolving `<unsafe fn() -> i32 as FnOnce<()>>::Output == i32`\n+    require_fn(g);\n+    //~^ ERROR: expected a `Fn<()>` closure, found `extern \"C\" fn() -> i32 {g}`\n+    //~| ERROR: type mismatch resolving `<extern \"C\" fn() -> i32 {g} as FnOnce<()>>::Output == i32`\n+    require_fn(g as extern \"C\" fn() -> i32);\n+    //~^ ERROR: expected a `Fn<()>` closure, found `extern \"C\" fn() -> i32`\n+    //~| ERROR: type mismatch resolving `<extern \"C\" fn() -> i32 as FnOnce<()>>::Output == i32`\n+    require_fn(h);\n+    //~^ ERROR: expected a `Fn<()>` closure, found `unsafe fn() -> i32 {h}`\n+    //~| ERROR: type mismatch resolving `<unsafe fn() -> i32 {h} as FnOnce<()>>::Output == i32`\n }"}, {"sha": "d52bcaf25b87c14d40a98670fedb42065744537f", "filename": "tests/ui/traits/new-solver/fn-trait.stderr", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1db9c061d387a66ab16a90ec5a1b90adf216e2da/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.stderr?ref=1db9c061d387a66ab16a90ec5a1b90adf216e2da", "patch": "@@ -0,0 +1,124 @@\n+error[E0277]: expected a `Fn<()>` closure, found `unsafe fn() -> i32`\n+  --> $DIR/fn-trait.rs:20:16\n+   |\n+LL |     require_fn(f as unsafe fn() -> i32);\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^ call the function in a closure: `|| unsafe { /* code */ }`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Fn<()>` is not implemented for `unsafe fn() -> i32`\n+   = note: wrap the `unsafe fn() -> i32` in a closure with no arguments: `|| { /* code */ }`\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:23\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                       ^^^^^^^^^^^ required by this bound in `require_fn`\n+\n+error[E0271]: type mismatch resolving `<unsafe fn() -> i32 as FnOnce<()>>::Output == i32`\n+  --> $DIR/fn-trait.rs:20:16\n+   |\n+LL |     require_fn(f as unsafe fn() -> i32);\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^ types differ\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:31\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                               ^^^ required by this bound in `require_fn`\n+\n+error[E0277]: expected a `Fn<()>` closure, found `extern \"C\" fn() -> i32 {g}`\n+  --> $DIR/fn-trait.rs:23:16\n+   |\n+LL |     require_fn(g);\n+   |     ---------- ^ expected an `Fn<()>` closure, found `extern \"C\" fn() -> i32 {g}`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Fn<()>` is not implemented for fn item `extern \"C\" fn() -> i32 {g}`\n+   = note: wrap the `extern \"C\" fn() -> i32 {g}` in a closure with no arguments: `|| { /* code */ }`\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:23\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                       ^^^^^^^^^^^ required by this bound in `require_fn`\n+\n+error[E0271]: type mismatch resolving `<extern \"C\" fn() -> i32 {g} as FnOnce<()>>::Output == i32`\n+  --> $DIR/fn-trait.rs:23:16\n+   |\n+LL |     require_fn(g);\n+   |     ---------- ^ types differ\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:31\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                               ^^^ required by this bound in `require_fn`\n+\n+error[E0277]: expected a `Fn<()>` closure, found `extern \"C\" fn() -> i32`\n+  --> $DIR/fn-trait.rs:26:16\n+   |\n+LL |     require_fn(g as extern \"C\" fn() -> i32);\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `extern \"C\" fn() -> i32`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Fn<()>` is not implemented for `extern \"C\" fn() -> i32`\n+   = note: wrap the `extern \"C\" fn() -> i32` in a closure with no arguments: `|| { /* code */ }`\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:23\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                       ^^^^^^^^^^^ required by this bound in `require_fn`\n+\n+error[E0271]: type mismatch resolving `<extern \"C\" fn() -> i32 as FnOnce<()>>::Output == i32`\n+  --> $DIR/fn-trait.rs:26:16\n+   |\n+LL |     require_fn(g as extern \"C\" fn() -> i32);\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ types differ\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:31\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                               ^^^ required by this bound in `require_fn`\n+\n+error[E0277]: expected a `Fn<()>` closure, found `unsafe fn() -> i32 {h}`\n+  --> $DIR/fn-trait.rs:29:16\n+   |\n+LL |     require_fn(h);\n+   |     ---------- ^ call the function in a closure: `|| unsafe { /* code */ }`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Fn<()>` is not implemented for fn item `unsafe fn() -> i32 {h}`\n+   = note: wrap the `unsafe fn() -> i32 {h}` in a closure with no arguments: `|| { /* code */ }`\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:23\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                       ^^^^^^^^^^^ required by this bound in `require_fn`\n+\n+error[E0271]: type mismatch resolving `<unsafe fn() -> i32 {h} as FnOnce<()>>::Output == i32`\n+  --> $DIR/fn-trait.rs:29:16\n+   |\n+LL |     require_fn(h);\n+   |     ---------- ^ types differ\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `require_fn`\n+  --> $DIR/fn-trait.rs:3:31\n+   |\n+LL | fn require_fn(_: impl Fn() -> i32) {}\n+   |                               ^^^ required by this bound in `require_fn`\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0271, E0277.\n+For more information about an error, try `rustc --explain E0271`."}]}