{"sha": "25aebb5225da91d34a2cb946f93435f9f7e82a47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YWViYjUyMjVkYTkxZDM0YTJjYjk0NmY5MzQzNWY5ZjdlODJhNDc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-12T21:09:30Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-12T21:09:30Z"}, "message": "Refctor", "tree": {"sha": "02ba9d56aea6feb7be7b6f3e7f7634723ae50a47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02ba9d56aea6feb7be7b6f3e7f7634723ae50a47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25aebb5225da91d34a2cb946f93435f9f7e82a47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25aebb5225da91d34a2cb946f93435f9f7e82a47", "html_url": "https://github.com/rust-lang/rust/commit/25aebb5225da91d34a2cb946f93435f9f7e82a47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25aebb5225da91d34a2cb946f93435f9f7e82a47/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "535bd7ccf73bcea549ddb7b01e7b3c4f35c6e856", "url": "https://api.github.com/repos/rust-lang/rust/commits/535bd7ccf73bcea549ddb7b01e7b3c4f35c6e856", "html_url": "https://github.com/rust-lang/rust/commit/535bd7ccf73bcea549ddb7b01e7b3c4f35c6e856"}], "stats": {"total": 199, "additions": 119, "deletions": 80}, "files": [{"sha": "7416de08ad492f01a9859424244b692eae3e5cfa", "filename": "crates/server/src/main.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25aebb5225da91d34a2cb946f93435f9f7e82a47/crates%2Fserver%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25aebb5225da91d34a2cb946f93435f9f7e82a47/crates%2Fserver%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain.rs?ref=25aebb5225da91d34a2cb946f93435f9f7e82a47", "patch": "@@ -31,7 +31,7 @@ use flexi_logger::Logger;\n use libanalysis::WorldState;\n \n use ::{\n-    io::{Io, RawMsg, RawResponse, RawNotification}\n+    io::{Io, RawMsg, RawResponse, RawRequest, RawNotification}\n };\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n@@ -104,6 +104,7 @@ fn initialize(io: &mut Io) -> Result<()> {\n \n enum Task {\n     Respond(RawResponse),\n+    Request(RawRequest),\n     Notify(RawNotification),\n     Die(::failure::Error),\n }"}, {"sha": "3d367f5f6a6de13178fa43d39b370536d777ed10", "filename": "crates/server/src/main_loop/mod.rs", "status": "modified", "additions": 117, "deletions": 79, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/25aebb5225da91d34a2cb946f93435f9f7e82a47/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25aebb5225da91d34a2cb946f93435f9f7e82a47/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs?ref=25aebb5225da91d34a2cb946f93435f9f7e82a47", "patch": "@@ -1,13 +1,16 @@\n mod handlers;\n \n+use std::collections::HashSet;\n+\n use threadpool::ThreadPool;\n use crossbeam_channel::{Sender, Receiver};\n use languageserver_types::Url;\n use libanalysis::{World, WorldState};\n+\n use {\n     req, dispatch,\n     Task, Result,\n-    io::{Io, RawMsg, RawRequest},\n+    io::{Io, RawMsg, RawRequest, RawNotification},\n     util::FilePath,\n     main_loop::handlers::{\n         handle_syntax_tree,\n@@ -27,6 +30,8 @@ pub(super) fn main_loop(\n     receiver: Receiver<Task>,\n ) -> Result<()> {\n     info!(\"server initialized, serving requests\");\n+    let mut next_request_id = 0;\n+    let mut pending_requests: HashSet<u64> = HashSet::new();\n     loop {\n         enum Event {\n             Msg(RawMsg),\n@@ -48,6 +53,12 @@ pub(super) fn main_loop(\n             }\n             Event::Task(task) => {\n                 match task {\n+                    Task::Request(mut request) => {\n+                        request.id = next_request_id;\n+                        pending_requests.insert(next_request_id);\n+                        next_request_id += 1;\n+                        io.send(RawMsg::Request(request));\n+                    }\n                     Task::Respond(response) =>\n                         io.send(RawMsg::Response(response)),\n                     Task::Notify(n) =>\n@@ -58,97 +69,124 @@ pub(super) fn main_loop(\n                 continue;\n             }\n             Event::Msg(msg) => {\n-                if !on_msg(io, world, pool, &sender, msg)? {\n-                    return Ok(());\n+                match msg {\n+                    RawMsg::Request(req) => {\n+                        if !on_request(io, world, pool, &sender, req)? {\n+                            return Ok(());\n+                        }\n+                    }\n+                    RawMsg::Notification(not) => {\n+                        on_notification(io, world, pool, &sender, not)?\n+                    }\n+                    RawMsg::Response(resp) => {\n+                        error!(\"unexpected response: {:?}\", resp)\n+                    }\n                 }\n             }\n         };\n     }\n }\n \n-fn on_msg(\n+fn on_request(\n     io: &mut Io,\n-    world: &mut WorldState,\n-    pool: &mut ThreadPool,\n+    world: &WorldState,\n+    pool: &ThreadPool,\n     sender: &Sender<Task>,\n-    msg: RawMsg,\n+    req: RawRequest,\n ) -> Result<bool> {\n-    match msg {\n-        RawMsg::Request(req) => {\n-            let mut req = Some(req);\n-            handle_request_on_threadpool::<req::SyntaxTree>(\n-                &mut req, pool, world, sender, handle_syntax_tree,\n-            )?;\n-            handle_request_on_threadpool::<req::ExtendSelection>(\n-                &mut req, pool, world, sender, handle_extend_selection,\n-            )?;\n-            handle_request_on_threadpool::<req::DocumentSymbolRequest>(\n-                &mut req, pool, world, sender, handle_document_symbol,\n-            )?;\n-            handle_request_on_threadpool::<req::CodeActionRequest>(\n-                &mut req, pool, world, sender, handle_code_action,\n-            )?;\n+    let mut req = Some(req);\n+    handle_request_on_threadpool::<req::SyntaxTree>(\n+        &mut req, pool, world, sender, handle_syntax_tree,\n+    )?;\n+    handle_request_on_threadpool::<req::ExtendSelection>(\n+        &mut req, pool, world, sender, handle_extend_selection,\n+    )?;\n+    handle_request_on_threadpool::<req::DocumentSymbolRequest>(\n+        &mut req, pool, world, sender, handle_document_symbol,\n+    )?;\n+    handle_request_on_threadpool::<req::CodeActionRequest>(\n+        &mut req, pool, world, sender, handle_code_action,\n+    )?;\n+//    dispatch::handle_request::<req::ExecuteCommand, _>(&mut req, |(), resp| {\n+//        let world = world.snapshot();\n+//        let sender = sender.clone();\n+//        pool.execute(move || {\n+//            let task = match handle_execute_command(world, params) {\n+//                Ok(req) => Task::Request(req),\n+//                Err(e) => Task::Die(e),\n+//            };\n+//            sender.send(task)\n+//        });\n+//\n+//        let resp = resp.into_response(Ok(()))?;\n+//        io.send(RawMsg::Response(resp));\n+//        shutdown = true;\n+//        Ok(())\n+//    })?;\n \n-            let mut shutdown = false;\n-            dispatch::handle_request::<req::Shutdown, _>(&mut req, |(), resp| {\n-                let resp = resp.into_response(Ok(()))?;\n-                io.send(RawMsg::Response(resp));\n-                shutdown = true;\n-                Ok(())\n-            })?;\n-            if shutdown {\n-                info!(\"lifecycle: initiating shutdown\");\n-                return Ok(false);\n-            }\n-            if let Some(req) = req {\n-                error!(\"unknown method: {:?}\", req);\n-                io.send(RawMsg::Response(dispatch::unknown_method(req.id)?));\n-            }\n-        }\n-        RawMsg::Notification(not) => {\n-            let mut not = Some(not);\n-            dispatch::handle_notification::<req::DidOpenTextDocument, _>(&mut not, |params| {\n-                let path = params.text_document.file_path()?;\n-                world.change_overlay(path, Some(params.text_document.text));\n-                update_file_notifications_on_threadpool(\n-                    pool, world.snapshot(), sender.clone(), params.text_document.uri,\n-                );\n-                Ok(())\n-            })?;\n-            dispatch::handle_notification::<req::DidChangeTextDocument, _>(&mut not, |mut params| {\n-                let path = params.text_document.file_path()?;\n-                let text = params.content_changes.pop()\n-                    .ok_or_else(|| format_err!(\"empty changes\"))?\n-                    .text;\n-                world.change_overlay(path, Some(text));\n-                update_file_notifications_on_threadpool(\n-                    pool, world.snapshot(), sender.clone(), params.text_document.uri,\n-                );\n-                Ok(())\n-            })?;\n-            dispatch::handle_notification::<req::DidCloseTextDocument, _>(&mut not, |params| {\n-                let path = params.text_document.file_path()?;\n-                world.change_overlay(path, None);\n-                let not = req::PublishDiagnosticsParams {\n-                    uri: params.text_document.uri,\n-                    diagnostics: Vec::new(),\n-                };\n-                let not = dispatch::send_notification::<req::PublishDiagnostics>(not);\n-                io.send(RawMsg::Notification(not));\n-                Ok(())\n-            })?;\n-\n-            if let Some(not) = not {\n-                error!(\"unhandled notification: {:?}\", not)\n-            }\n-        }\n-        msg => {\n-            eprintln!(\"msg = {:?}\", msg);\n-        }\n-    };\n+    let mut shutdown = false;\n+    dispatch::handle_request::<req::Shutdown, _>(&mut req, |(), resp| {\n+        let resp = resp.into_response(Ok(()))?;\n+        io.send(RawMsg::Response(resp));\n+        shutdown = true;\n+        Ok(())\n+    })?;\n+    if shutdown {\n+        info!(\"lifecycle: initiating shutdown\");\n+        return Ok(false);\n+    }\n+    if let Some(req) = req {\n+        error!(\"unknown method: {:?}\", req);\n+        io.send(RawMsg::Response(dispatch::unknown_method(req.id)?));\n+    }\n     Ok(true)\n }\n \n+fn on_notification(\n+    io: &mut Io,\n+    world: &mut WorldState,\n+    pool: &ThreadPool,\n+    sender: &Sender<Task>,\n+    not: RawNotification,\n+) -> Result<()> {\n+    let mut not = Some(not);\n+    dispatch::handle_notification::<req::DidOpenTextDocument, _>(&mut not, |params| {\n+        let path = params.text_document.file_path()?;\n+        world.change_overlay(path, Some(params.text_document.text));\n+        update_file_notifications_on_threadpool(\n+            pool, world.snapshot(), sender.clone(), params.text_document.uri,\n+        );\n+        Ok(())\n+    })?;\n+    dispatch::handle_notification::<req::DidChangeTextDocument, _>(&mut not, |mut params| {\n+        let path = params.text_document.file_path()?;\n+        let text = params.content_changes.pop()\n+            .ok_or_else(|| format_err!(\"empty changes\"))?\n+            .text;\n+        world.change_overlay(path, Some(text));\n+        update_file_notifications_on_threadpool(\n+            pool, world.snapshot(), sender.clone(), params.text_document.uri,\n+        );\n+        Ok(())\n+    })?;\n+    dispatch::handle_notification::<req::DidCloseTextDocument, _>(&mut not, |params| {\n+        let path = params.text_document.file_path()?;\n+        world.change_overlay(path, None);\n+        let not = req::PublishDiagnosticsParams {\n+            uri: params.text_document.uri,\n+            diagnostics: Vec::new(),\n+        };\n+        let not = dispatch::send_notification::<req::PublishDiagnostics>(not);\n+        io.send(RawMsg::Notification(not));\n+        Ok(())\n+    })?;\n+\n+    if let Some(not) = not {\n+        error!(\"unhandled notification: {:?}\", not);\n+    }\n+    Ok(())\n+}\n+\n fn handle_request_on_threadpool<R: req::ClientRequest>(\n     req: &mut Option<RawRequest>,\n     pool: &ThreadPool,"}]}