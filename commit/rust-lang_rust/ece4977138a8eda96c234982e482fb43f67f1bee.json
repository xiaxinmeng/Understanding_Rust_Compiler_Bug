{"sha": "ece4977138a8eda96c234982e482fb43f67f1bee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZTQ5NzcxMzhhOGVkYTk2YzIzNDk4MmU0ODJmYjQzZjY3ZjFiZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-09T20:29:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-09T20:29:05Z"}, "message": "Auto merge of #65249 - matthewjasper:revert-into-drop, r=nnethercote\n\nRevert \"Make `into` schedule drop for the destination\"\n\nThis was a *very* large perf regression in some cases. I'll undo the revert once I have time to avoid the regression.", "tree": {"sha": "3644cd1e317ddc6af90d9fd433e78a21514e4bb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3644cd1e317ddc6af90d9fd433e78a21514e4bb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ece4977138a8eda96c234982e482fb43f67f1bee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ece4977138a8eda96c234982e482fb43f67f1bee", "html_url": "https://github.com/rust-lang/rust/commit/ece4977138a8eda96c234982e482fb43f67f1bee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ece4977138a8eda96c234982e482fb43f67f1bee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20cc75272619cc452e3ae6c131e61974f6aa9929", "url": "https://api.github.com/repos/rust-lang/rust/commits/20cc75272619cc452e3ae6c131e61974f6aa9929", "html_url": "https://github.com/rust-lang/rust/commit/20cc75272619cc452e3ae6c131e61974f6aa9929"}, {"sha": "a0342c896597e66f8f3c5dbe22850ec6b5003698", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0342c896597e66f8f3c5dbe22850ec6b5003698", "html_url": "https://github.com/rust-lang/rust/commit/a0342c896597e66f8f3c5dbe22850ec6b5003698"}], "stats": {"total": 713, "additions": 247, "deletions": 466}, "files": [{"sha": "7353ca9285ddb10b3cfce5133f24d2f0f8ebf8a4", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 21, "deletions": 49, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -1,22 +1,18 @@\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::matches::ArmHasGuard;\n-use crate::build::scope::DropKind;\n use crate::hair::*;\n-use rustc::middle::region;\n use rustc::mir::*;\n use rustc::hir;\n use syntax_pos::Span;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn ast_block(\n-        &mut self,\n-        destination: &Place<'tcx>,\n-        scope: Option<region::Scope>,\n-        block: BasicBlock,\n-        ast_block: &'tcx hir::Block,\n-        source_info: SourceInfo,\n-    ) -> BlockAnd<()> {\n+    pub fn ast_block(&mut self,\n+                     destination: &Place<'tcx>,\n+                     block: BasicBlock,\n+                     ast_block: &'tcx hir::Block,\n+                     source_info: SourceInfo)\n+                     -> BlockAnd<()> {\n         let Block {\n             region_scope,\n             opt_destruction_scope,\n@@ -25,61 +21,37 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             expr,\n             targeted_by_break,\n             safety_mode\n-        } = self.hir.mirror(ast_block);\n+        } =\n+            self.hir.mirror(ast_block);\n         self.in_opt_scope(opt_destruction_scope.map(|de|(de, source_info)), move |this| {\n             this.in_scope((region_scope, source_info), LintLevel::Inherited, move |this| {\n                 if targeted_by_break {\n                     // This is a `break`-able block\n                     let exit_block = this.cfg.start_new_block();\n-                    if let Some(scope) = scope {\n-                        // Breakable blocks assign to their destination on each\n-                        // `break`, as well as when they exit normally. So we\n-                        // can't schedule the drop in the last expression like\n-                        // normal blocks do.\n-                        let local = destination.as_local()\n-                            .expect(\"cannot schedule drop of non-Local place\");\n-                        this.schedule_drop(span, scope, local, DropKind::Value);\n-                    }\n                     let block_exit = this.in_breakable_scope(\n                         None, exit_block, destination.clone(), |this| {\n-                            this.ast_block_stmts(\n-                                destination,\n-                                None,\n-                                block,\n-                                span,\n-                                stmts,\n-                                expr,\n-                                safety_mode,\n-                            )\n+                            this.ast_block_stmts(destination, block, span, stmts, expr,\n+                                                 safety_mode)\n                         });\n                     this.cfg.terminate(unpack!(block_exit), source_info,\n                                        TerminatorKind::Goto { target: exit_block });\n                     exit_block.unit()\n                 } else {\n-                    this.ast_block_stmts(\n-                        destination,\n-                        scope,\n-                        block,\n-                        span,\n-                        stmts,\n-                        expr,\n-                        safety_mode,\n-                    )\n+                    this.ast_block_stmts(destination, block, span, stmts, expr,\n+                                         safety_mode)\n                 }\n             })\n         })\n     }\n \n-    fn ast_block_stmts(\n-        &mut self,\n-        destination: &Place<'tcx>,\n-        scope: Option<region::Scope>,\n-        mut block: BasicBlock,\n-        span: Span,\n-        stmts: Vec<StmtRef<'tcx>>,\n-        expr: Option<ExprRef<'tcx>>,\n-        safety_mode: BlockSafety,\n-    ) -> BlockAnd<()> {\n+    fn ast_block_stmts(&mut self,\n+                       destination: &Place<'tcx>,\n+                       mut block: BasicBlock,\n+                       span: Span,\n+                       stmts: Vec<StmtRef<'tcx>>,\n+                       expr: Option<ExprRef<'tcx>>,\n+                       safety_mode: BlockSafety)\n+                       -> BlockAnd<()> {\n         let this = self;\n \n         // This convoluted structure is to avoid using recursion as we walk down a list\n@@ -205,7 +177,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.block_context.currently_ignores_tail_results();\n             this.block_context.push(BlockFrame::TailExpr { tail_result_is_ignored });\n \n-            unpack!(block = this.into(destination, scope, block, expr));\n+            unpack!(block = this.into(destination, block, expr));\n             let popped = this.block_context.pop();\n \n             assert!(popped.map_or(false, |bf|bf.is_tail_expr()));"}, {"sha": "87d95a751534d1d54750a6ec7ae3167fdd8bc239", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -136,14 +136,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.cfg\n                     .push_assign(block, source_info, &Place::from(result), box_);\n \n-                // Initialize the box contents. No scope is needed since the\n-                // `Box` is already scheduled to be dropped.\n+                // initialize the box contents:\n                 unpack!(\n                     block = this.into(\n                         &Place::from(result).deref(),\n-                        None,\n-                        block,\n-                        value\n+                        block, value\n                     )\n                 );\n                 block.and(Rvalue::Use(Operand::Move(Place::from(result))))"}, {"sha": "18332ed68f8bd15ae65d7dba2c36fd7121bc5aef", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -109,7 +109,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        unpack!(block = this.into(temp_place, temp_lifetime, block, expr));\n+        unpack!(block = this.into(temp_place, block, expr));\n+\n+        if let Some(temp_lifetime) = temp_lifetime {\n+            this.schedule_drop(\n+                expr_span,\n+                temp_lifetime,\n+                temp,\n+                DropKind::Value,\n+            );\n+        }\n \n         block.and(temp)\n     }"}, {"sha": "8a6bc5a2a764e961986e7bccd6878ce13341c328", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -2,9 +2,7 @@\n \n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use crate::build::scope::DropKind;\n use crate::hair::*;\n-use rustc::middle::region;\n use rustc::mir::*;\n use rustc::ty;\n \n@@ -13,18 +11,15 @@ use rustc_target::spec::abi::Abi;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n-    /// If a `drop_scope` is provided, `destination` is scheduled to be dropped\n-    /// in `scope` once it has been initialized.\n     pub fn into_expr(\n         &mut self,\n         destination: &Place<'tcx>,\n-        scope: Option<region::Scope>,\n         mut block: BasicBlock,\n         expr: Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         debug!(\n-            \"into_expr(destination={:?}, scope={:?}, block={:?}, expr={:?})\",\n-            destination, scope, block, expr\n+            \"into_expr(destination={:?}, block={:?}, expr={:?})\",\n+            destination, block, expr\n         );\n \n         // since we frequently have to reference `self` from within a\n@@ -40,14 +35,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             _ => false,\n         };\n \n-        let schedule_drop = move |this: &mut Self| {\n-            if let Some(drop_scope) = scope {\n-                let local = destination.as_local()\n-                    .expect(\"cannot schedule drop of non-Local place\");\n-                this.schedule_drop(expr_span, drop_scope, local, DropKind::Value);\n-            }\n-        };\n-\n         if !expr_is_block_or_scope {\n             this.block_context.push(BlockFrame::SubExpr);\n         }\n@@ -60,14 +47,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             } => {\n                 let region_scope = (region_scope, source_info);\n                 this.in_scope(region_scope, lint_level, |this| {\n-                    this.into(destination, scope, block, value)\n+                    this.into(destination, block, value)\n                 })\n             }\n             ExprKind::Block { body: ast_block } => {\n-                this.ast_block(destination, scope, block, ast_block, source_info)\n+                this.ast_block(destination, block, ast_block, source_info)\n             }\n             ExprKind::Match { scrutinee, arms } => {\n-                this.match_expr(destination, scope, expr_span, block, scrutinee, arms)\n+                this.match_expr(destination, expr_span, block, scrutinee, arms)\n             }\n             ExprKind::NeverToAny { source } => {\n                 let source = this.hir.mirror(source);\n@@ -80,7 +67,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // This is an optimization. If the expression was a call then we already have an\n                 // unreachable block. Don't bother to terminate it and create a new one.\n-                schedule_drop(this);\n                 if is_call {\n                     block.unit()\n                 } else {\n@@ -178,9 +164,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     TerminatorKind::Goto { target: loop_block },\n                 );\n \n-                // Loops assign to their destination on each `break`. Since we\n-                // can't easily unschedule drops, we schedule the drop now.\n-                schedule_drop(this);\n                 this.in_breakable_scope(\n                     Some(loop_block),\n                     exit_block,\n@@ -202,8 +185,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         // introduce a unit temporary as the destination for the loop body.\n                         let tmp = this.get_unit_temp();\n                         // Execute the body, branching back to the test.\n-                        // No scope is provided, since we've scheduled the drop above.\n-                        let body_block_end = unpack!(this.into(&tmp, None, body_block, body));\n+                        let body_block_end = unpack!(this.into(&tmp, body_block, body));\n                         this.cfg.terminate(\n                             body_block_end,\n                             source_info,\n@@ -252,14 +234,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         is_block_tail: None,\n                     });\n                     let ptr_temp = Place::from(ptr_temp);\n-                    // No need for a scope, ptr_temp doesn't need drop\n-                    let block = unpack!(this.into(&ptr_temp, None, block, ptr));\n-                    // Maybe we should provide a scope here so that\n-                    // `move_val_init` wouldn't leak on panic even with an\n-                    // arbitrary `val` expression, but `schedule_drop`,\n-                    // borrowck and drop elaboration all prevent us from\n-                    // dropping `ptr_temp.deref()`.\n-                    this.into(&ptr_temp.deref(), None, block, val)\n+                    let block = unpack!(this.into(&ptr_temp, block, ptr));\n+                    this.into(&ptr_temp.deref(), block, val)\n                 } else {\n                     let args: Vec<_> = args\n                         .into_iter()\n@@ -289,12 +265,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             from_hir_call,\n                         },\n                     );\n-                    schedule_drop(this);\n                     success.unit()\n                 }\n             }\n             ExprKind::Use { source } => {\n-                this.into(destination, scope, block, source)\n+                this.into(destination, block, source)\n             }\n \n             // These cases don't actually need a destination\n@@ -321,7 +296,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg\n                     .push_assign(block, source_info, destination, rvalue);\n-                schedule_drop(this);\n                 block.unit()\n             }\n             ExprKind::Index { .. } | ExprKind::Deref { .. } | ExprKind::Field { .. } => {\n@@ -341,7 +315,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg\n                     .push_assign(block, source_info, destination, rvalue);\n-                schedule_drop(this);\n                 block.unit()\n             }\n \n@@ -373,7 +346,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 let rvalue = unpack!(block = this.as_local_rvalue(block, expr));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n-                schedule_drop(this);\n                 block.unit()\n             }\n         };"}, {"sha": "077840c9ccf172b1bd6774b821b10bf076cba800", "filename": "src/librustc_mir/build/into.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -6,31 +6,26 @@\n \n use crate::build::{BlockAnd, Builder};\n use crate::hair::*;\n-use rustc::middle::region;\n use rustc::mir::*;\n \n pub(in crate::build) trait EvalInto<'tcx> {\n     fn eval_into(\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: &Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()>;\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn into<E>(\n-        &mut self,\n-        destination: &Place<'tcx>,\n-        scope: Option<region::Scope>,\n-        block: BasicBlock,\n-        expr: E,\n-    ) -> BlockAnd<()>\n-    where\n-        E: EvalInto<'tcx>,\n+    pub fn into<E>(&mut self,\n+                   destination: &Place<'tcx>,\n+                   block: BasicBlock,\n+                   expr: E)\n+                   -> BlockAnd<()>\n+        where E: EvalInto<'tcx>\n     {\n-        expr.eval_into(self, destination, scope, block)\n+        expr.eval_into(self, destination, block)\n     }\n }\n \n@@ -39,11 +34,10 @@ impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: &Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()> {\n         let expr = builder.hir.mirror(self);\n-        builder.into_expr(destination, scope, block, expr)\n+        builder.into_expr(destination, block, expr)\n     }\n }\n \n@@ -52,9 +46,8 @@ impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: &Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()> {\n-        builder.into_expr(destination, scope, block, self)\n+        builder.into_expr(destination, block, self)\n     }\n }"}, {"sha": "2e451fc88d95c37fa29153521d63c074689ca4c5", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -102,7 +102,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn match_expr(\n         &mut self,\n         destination: &Place<'tcx>,\n-        destination_scope: Option<region::Scope>,\n         span: Span,\n         mut block: BasicBlock,\n         scrutinee: ExprRef<'tcx>,\n@@ -229,14 +228,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         };\n \n         // Step 5. Create everything else: the guards and the arms.\n-        if let Some(scope) = destination_scope {\n-            // `match` assigns to its destination in each arm. Since we can't\n-            // easily unschedule drops, we schedule the drop now.\n-            let local = destination.as_local()\n-                .expect(\"cannot schedule drop of non-Local place\");\n-            self.schedule_drop(span, scope, local, DropKind::Value);\n-        }\n-\n         let match_scope = self.scopes.topmost();\n \n         let arm_end_blocks: Vec<_> = arm_candidates.into_iter().map(|(arm, mut candidates)| {\n@@ -284,8 +275,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.source_scope = source_scope;\n                 }\n \n-                // No scope is provided, since we've scheduled the drop above.\n-                this.into(destination, None, arm_block, body)\n+                this.into(destination, arm_block, body)\n             })\n         }).collect();\n \n@@ -321,9 +311,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n-                let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n+                unpack!(block = self.into(&place, block, initializer));\n \n-                unpack!(block = self.into(&place, Some(region_scope), block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let source_info = self.source_info(irrefutable_pat.span);\n@@ -335,6 +324,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     },\n                 );\n \n+                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n \n@@ -362,10 +352,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     user_ty_span,\n                 },\n             } => {\n-                let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n-                unpack!(block = self.into(&place, Some(region_scope), block, initializer));\n+                unpack!(block = self.into(&place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let pattern_source_info = self.source_info(irrefutable_pat.span);\n@@ -411,6 +400,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     },\n                 );\n \n+                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n "}, {"sha": "8c35342d324b7702369394766fa1eaf65f2f3b28", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -616,7 +616,6 @@ where\n     let source_info = builder.source_info(span);\n     let call_site_s = (call_site_scope, source_info);\n     unpack!(block = builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n-        builder.schedule_drop(span, call_site_scope, RETURN_PLACE, DropKind::Value);\n         if should_abort_on_panic(tcx, fn_def_id, abi) {\n             builder.schedule_abort();\n         }\n@@ -647,7 +646,6 @@ where\n             builder.cfg.terminate(unreachable_block, source_info,\n                                   TerminatorKind::Unreachable);\n         }\n-        builder.unschedule_return_place_drop();\n         return_block.unit()\n     }));\n     assert_eq!(block, builder.return_block());\n@@ -689,9 +687,7 @@ fn construct_const<'a, 'tcx>(\n     let mut block = START_BLOCK;\n     let ast_expr = &tcx.hir().body(body_id).value;\n     let expr = builder.hir.mirror(ast_expr);\n-    // We don't provide a scope because we can't unwind in constants, so won't\n-    // need to drop the return place.\n-    unpack!(block = builder.into_expr(&Place::return_place(), None, block, expr));\n+    unpack!(block = builder.into_expr(&Place::return_place(), block, expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -892,9 +888,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        // No scope is provided, since we've scheduled the drop of the return\n-        // place.\n-        self.into(&Place::return_place(), None, block, body)\n+        self.into(&Place::return_place(), block, body)\n     }\n \n     fn set_correct_source_scope_for_arg("}, {"sha": "a749b4263ea64abe73a5e4a5981519ec35995648", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -513,7 +513,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if let Some(value) = value {\n                 debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n                 self.block_context.push(BlockFrame::SubExpr);\n-                unpack!(block = self.into(&destination, None, block, value));\n+                unpack!(block = self.into(&destination, block, value));\n                 self.block_context.pop();\n             } else {\n                 self.cfg.push_assign_unit(block, source_info, &destination)\n@@ -1070,18 +1070,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         success_block\n     }\n \n-    /// Unschedules the drop of the return place.\n-    ///\n-    /// If the return type of a function requires drop, then we schedule it\n-    /// in the outermost scope so that it's dropped if there's a panic while\n-    /// we drop any local variables. But we don't want to drop it if we\n-    /// return normally.\n-    crate fn unschedule_return_place_drop(&mut self) {\n-        assert_eq!(self.scopes.len(), 1);\n-        assert!(self.scopes.scopes[0].drops.len() <= 1);\n-        self.scopes.scopes[0].drops.clear();\n-    }\n-\n     // `match` arm scopes\n     // ==================\n     /// Unschedules any drops in the top scope."}, {"sha": "8dc6b73edf6d473ecd804cdd314597fbdb86dcd9", "filename": "src/test/mir-opt/box_expr.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -41,36 +41,33 @@ impl Drop for S {\n //\n //     bb2: {\n //         _1 = move _2;\n-//         drop(_2) -> [return: bb5, unwind: bb4];\n+//         drop(_2) -> bb4;\n //     }\n //\n //     bb3 (cleanup): {\n //         drop(_2) -> bb1;\n //     }\n //\n-//     bb4 (cleanup): {\n-//         drop(_1) -> bb1;\n-//     }\n-//\n-//     bb5: {\n+//     bb4: {\n //         StorageDead(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         _4 = move _1;\n-//         _3 = const std::mem::drop::<std::boxed::Box<S>>(move _4) -> [return: bb6, unwind: bb7];\n+//         _3 = const std::mem::drop::<std::boxed::Box<S>>(move _4) -> [return: bb5, unwind: bb7];\n //     }\n //\n-//     bb6: {\n+//     bb5: {\n //         StorageDead(_4);\n //         StorageDead(_3);\n //         _0 = ();\n //         drop(_1) -> bb8;\n //     }\n-//\n+//     bb6 (cleanup): {\n+//         drop(_1) -> bb1;\n+//     }\n //     bb7 (cleanup): {\n-//         drop(_4) -> bb4;\n+//         drop(_4) -> bb6;\n //     }\n-//\n //     bb8: {\n //         StorageDead(_1);\n //         return;"}, {"sha": "a3b517e9bca87bfa0cf295af84a7496c3ad5fe65", "filename": "src/test/mir-opt/issue-62289.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Ftest%2Fmir-opt%2Fissue-62289.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Ftest%2Fmir-opt%2Fissue-62289.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-62289.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -24,71 +24,68 @@ fn main() {\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         _4 = std::option::Option::<u32>::None;\n-//         _3 = const <std::option::Option<u32> as std::ops::Try>::into_result(move _4) -> [return: bb2, unwind: bb4];\n+//         _3 = const <std::option::Option<u32> as std::ops::Try>::into_result(move _4) -> [return: bb2, unwind: bb3];\n //     }\n //     bb1 (cleanup): {\n //         resume;\n //     }\n //     bb2: {\n //         StorageDead(_4);\n //         _5 = discriminant(_3);\n-//         switchInt(move _5) -> [0isize: bb11, 1isize: bb6, otherwise: bb5];\n+//         switchInt(move _5) -> [0isize: bb10, 1isize: bb5, otherwise: bb4];\n //     }\n //     bb3 (cleanup): {\n-//         drop(_0) -> bb1;\n+//         drop(_2) -> bb1;\n //     }\n-//     bb4 (cleanup): {\n-//         drop(_2) -> bb3;\n-//     }\n-//     bb5: {\n+//     bb4: {\n //         unreachable;\n //     }\n-//     bb6: {\n+//     bb5: {\n //         StorageLive(_6);\n //         _6 = ((_3 as Err).0: std::option::NoneError);\n //         StorageLive(_8);\n //         StorageLive(_9);\n //         _9 = _6;\n-//         _8 = const <std::option::NoneError as std::convert::From<std::option::NoneError>>::from(move _9) -> [return: bb8, unwind: bb4];\n+//         _8 = const <std::option::NoneError as std::convert::From<std::option::NoneError>>::from(move _9) -> [return: bb7, unwind: bb3];\n //     }\n-//     bb7: {\n+//     bb6: {\n //         return;\n //     }\n-//     bb8: {\n+//     bb7: {\n //         StorageDead(_9);\n-//         _0 = const <std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::from_error(move _8) -> [return: bb9, unwind: bb4];\n+//         _0 = const <std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::from_error(move _8) -> [return: bb8, unwind: bb3];\n //     }\n-//     bb9: {\n+//     bb8: {\n //         StorageDead(_8);\n //         StorageDead(_6);\n-//         drop(_2) -> [return: bb10, unwind: bb3];\n+//         drop(_2) -> bb9;\n //     }\n-//     bb10: {\n+//     bb9: {\n //         StorageDead(_2);\n //         StorageDead(_1);\n //         StorageDead(_3);\n-//         goto -> bb7;\n+//         goto -> bb6;\n //     }\n-//     bb11: {\n+//     bb10: {\n //         StorageLive(_10);\n //         _10 = ((_3 as Ok).0: u32);\n //         (*_2) = _10;\n //         StorageDead(_10);\n //         _1 = move _2;\n-//         drop(_2) -> [return: bb13, unwind: bb12];\n+//         drop(_2) -> [return: bb12, unwind: bb11];\n //     }\n-//     bb12 (cleanup): {\n-//         drop(_1) -> bb3;\n+//     bb11 (cleanup): {\n+//         drop(_1) -> bb1;\n //     }\n-//     bb13: {\n+//     bb12: {\n //         StorageDead(_2);\n //         _0 = std::option::Option::<std::boxed::Box<u32>>::Some(move _1,);\n-//         drop(_1) -> [return: bb14, unwind: bb3];\n+//         drop(_1) -> bb13;\n //     }\n-//     bb14: {\n+//     bb13: {\n //         StorageDead(_1);\n //         StorageDead(_3);\n-//         goto -> bb7;\n+//         goto -> bb6;\n //     }\n // }\n // END rustc.test.ElaborateDrops.before.mir"}, {"sha": "ad20237981c301b1aa265557945ec16a610d1afe", "filename": "src/test/ui/async-await/async-fn-size-uninit-locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-uninit-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-uninit-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-uninit-locals.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -99,5 +99,5 @@ fn main() {\n     assert_eq!(12, std::mem::size_of_val(&single_with_noop()));\n     assert_eq!(3084, std::mem::size_of_val(&joined()));\n     assert_eq!(3084, std::mem::size_of_val(&joined_with_noop()));\n-    assert_eq!(3084, std::mem::size_of_val(&join_retval()));\n+    assert_eq!(3080, std::mem::size_of_val(&join_retval()));\n }"}, {"sha": "91063edf0f6c4badf45a759ad86bcb9722290287", "filename": "src/test/ui/drop/dynamic-drop-async.rs", "status": "modified", "additions": 53, "deletions": 110, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -7,7 +7,7 @@\n // edition:2018\n // ignore-wasm32-bare compiled with panic=abort by default\n \n-#![feature(slice_patterns, arbitrary_self_types)]\n+#![feature(slice_patterns)]\n #![allow(unused)]\n \n use std::{\n@@ -45,7 +45,6 @@ impl<T: Unpin> Future for Defer<T> {\n /// The `failing_op`-th operation will panic.\n struct Allocator {\n     data: RefCell<Vec<bool>>,\n-    name: &'static str,\n     failing_op: usize,\n     cur_ops: Cell<usize>,\n }\n@@ -57,28 +56,23 @@ impl Drop for Allocator {\n     fn drop(&mut self) {\n         let data = self.data.borrow();\n         if data.iter().any(|d| *d) {\n-            panic!(\"missing free in {:?}: {:?}\", self.name, data);\n+            panic!(\"missing free: {:?}\", data);\n         }\n     }\n }\n \n impl Allocator {\n-    fn new(failing_op: usize, name: &'static str) -> Self {\n-        Allocator {\n-            failing_op,\n-            name,\n-            cur_ops: Cell::new(0),\n-            data: RefCell::new(vec![]),\n-        }\n+    fn new(failing_op: usize) -> Self {\n+        Allocator { failing_op, cur_ops: Cell::new(0), data: RefCell::new(vec![]) }\n     }\n-    fn alloc(self: &Rc<Allocator>) -> impl Future<Output = Ptr> + 'static {\n+    fn alloc(&self) -> impl Future<Output = Ptr<'_>> + '_ {\n         self.fallible_operation();\n \n         let mut data = self.data.borrow_mut();\n \n         let addr = data.len();\n         data.push(true);\n-        Defer { ready: false, value: Some(Ptr(addr, self.clone())) }\n+        Defer { ready: false, value: Some(Ptr(addr, self)) }\n     }\n     fn fallible_operation(&self) {\n         self.cur_ops.set(self.cur_ops.get() + 1);\n@@ -91,11 +85,11 @@ impl Allocator {\n \n // Type that tracks whether it was dropped and can panic when it's created or\n // destroyed.\n-struct Ptr(usize, Rc<Allocator>);\n-impl Drop for Ptr {\n+struct Ptr<'a>(usize, &'a Allocator);\n+impl<'a> Drop for Ptr<'a> {\n     fn drop(&mut self) {\n         match self.1.data.borrow_mut()[self.0] {\n-            false => panic!(\"double free in {:?} at index {:?}\", self.1.name, self.0),\n+            false => panic!(\"double free at index {:?}\", self.0),\n             ref mut d => *d = false,\n         }\n \n@@ -119,7 +113,7 @@ async fn dynamic_drop(a: Rc<Allocator>, c: bool) {\n     };\n }\n \n-struct TwoPtrs(Ptr, Ptr);\n+struct TwoPtrs<'a>(Ptr<'a>, Ptr<'a>);\n async fn struct_dynamic_drop(a: Rc<Allocator>, c0: bool, c1: bool, c: bool) {\n     for i in 0..2 {\n         let x;\n@@ -234,62 +228,21 @@ async fn subslice_pattern_reassign(a: Rc<Allocator>) {\n     a.alloc().await;\n }\n \n-async fn panic_after_return(a: Rc<Allocator>, c: bool) -> (Ptr,) {\n-    a.alloc().await;\n-    let p = a.alloc().await;\n-    if c {\n-        a.alloc().await;\n-        let q = a.alloc().await;\n-        // We use a return type that isn't used anywhere else to make sure that\n-        // the return place doesn't incorrectly end up in the generator state.\n-        return (a.alloc().await,);\n-    }\n-    (a.alloc().await,)\n-}\n-\n-\n-async fn panic_after_init_by_loop(a: Rc<Allocator>) {\n-    a.alloc().await;\n-    let p = a.alloc().await;\n-    let q = loop {\n-        a.alloc().await;\n-        let r = a.alloc().await;\n-        break a.alloc().await;\n-    };\n-}\n-\n-async fn panic_after_init_by_match_with_bindings_and_guard(a: Rc<Allocator>, b: bool) {\n-    a.alloc().await;\n-    let p = a.alloc().await;\n-    let q = match a.alloc().await {\n-        ref _x if b => {\n-            a.alloc().await;\n-            let r = a.alloc().await;\n-            a.alloc().await\n-        }\n-        _x => {\n-            a.alloc().await;\n-            let r = a.alloc().await;\n-            a.alloc().await\n-        },\n-    };\n-}\n-\n-fn run_test<F, G, O>(cx: &mut Context<'_>, ref f: F, name: &'static str)\n+fn run_test<F, G>(cx: &mut Context<'_>, ref f: F)\n where\n     F: Fn(Rc<Allocator>) -> G,\n-    G: Future<Output = O>,\n+    G: Future<Output = ()>,\n {\n     for polls in 0.. {\n         // Run without any panics to find which operations happen after the\n         // penultimate `poll`.\n-        let first_alloc = Rc::new(Allocator::new(usize::MAX, name));\n+        let first_alloc = Rc::new(Allocator::new(usize::MAX));\n         let mut fut = Box::pin(f(first_alloc.clone()));\n         let mut ops_before_last_poll = 0;\n         let mut completed = false;\n         for _ in 0..polls {\n             ops_before_last_poll = first_alloc.cur_ops.get();\n-            if let Poll::Ready(_) = fut.as_mut().poll(cx) {\n+            if let Poll::Ready(()) = fut.as_mut().poll(cx) {\n                 completed = true;\n             }\n         }\n@@ -298,7 +251,7 @@ where\n         // Start at `ops_before_last_poll` so that we will always be able to\n         // `poll` the expected number of times.\n         for failing_op in ops_before_last_poll..first_alloc.cur_ops.get() {\n-            let alloc = Rc::new(Allocator::new(failing_op + 1, name));\n+            let alloc = Rc::new(Allocator::new(failing_op + 1));\n             let f = &f;\n             let cx = &mut *cx;\n             let result = panic::catch_unwind(panic::AssertUnwindSafe(move || {\n@@ -328,56 +281,46 @@ fn clone_waker(data: *const ()) -> RawWaker {\n     RawWaker::new(data, &RawWakerVTable::new(clone_waker, drop, drop, drop))\n }\n \n-macro_rules! run_test {\n-    ($ctxt:expr, $e:expr) => { run_test($ctxt, $e, stringify!($e)); };\n-}\n-\n fn main() {\n     let waker = unsafe { Waker::from_raw(clone_waker(ptr::null())) };\n     let context = &mut Context::from_waker(&waker);\n \n-    run_test!(context, |a| dynamic_init(a, false));\n-    run_test!(context, |a| dynamic_init(a, true));\n-    run_test!(context, |a| dynamic_drop(a, false));\n-    run_test!(context, |a| dynamic_drop(a, true));\n-\n-    run_test!(context, |a| assignment(a, false, false));\n-    run_test!(context, |a| assignment(a, false, true));\n-    run_test!(context, |a| assignment(a, true, false));\n-    run_test!(context, |a| assignment(a, true, true));\n-\n-    run_test!(context, |a| array_simple(a));\n-    run_test!(context, |a| vec_simple(a));\n-    run_test!(context, |a| vec_unreachable(a));\n-\n-    run_test!(context, |a| struct_dynamic_drop(a, false, false, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, false, false, true));\n-    run_test!(context, |a| struct_dynamic_drop(a, false, true, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, false, true, true));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, false, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, false, true));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, true, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, true, true));\n-\n-    run_test!(context, |a| field_assignment(a, false));\n-    run_test!(context, |a| field_assignment(a, true));\n-\n-    run_test!(context, |a| mixed_drop_and_nondrop(a));\n-\n-    run_test!(context, |a| slice_pattern_one_of(a, 0));\n-    run_test!(context, |a| slice_pattern_one_of(a, 1));\n-    run_test!(context, |a| slice_pattern_one_of(a, 2));\n-    run_test!(context, |a| slice_pattern_one_of(a, 3));\n-\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, true, true));\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, true, false));\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, false, true));\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, false, false));\n-    run_test!(context, |a| subslice_pattern_reassign(a));\n-\n-    run_test!(context, |a| panic_after_return(a, false));\n-    run_test!(context, |a| panic_after_return(a, true));\n-    run_test!(context, |a| panic_after_init_by_loop(a));\n-    run_test!(context, |a| panic_after_init_by_match_with_bindings_and_guard(a, false));\n-    run_test!(context, |a| panic_after_init_by_match_with_bindings_and_guard(a, true));\n+    run_test(context, |a| dynamic_init(a, false));\n+    run_test(context, |a| dynamic_init(a, true));\n+    run_test(context, |a| dynamic_drop(a, false));\n+    run_test(context, |a| dynamic_drop(a, true));\n+\n+    run_test(context, |a| assignment(a, false, false));\n+    run_test(context, |a| assignment(a, false, true));\n+    run_test(context, |a| assignment(a, true, false));\n+    run_test(context, |a| assignment(a, true, true));\n+\n+    run_test(context, |a| array_simple(a));\n+    run_test(context, |a| vec_simple(a));\n+    run_test(context, |a| vec_unreachable(a));\n+\n+    run_test(context, |a| struct_dynamic_drop(a, false, false, false));\n+    run_test(context, |a| struct_dynamic_drop(a, false, false, true));\n+    run_test(context, |a| struct_dynamic_drop(a, false, true, false));\n+    run_test(context, |a| struct_dynamic_drop(a, false, true, true));\n+    run_test(context, |a| struct_dynamic_drop(a, true, false, false));\n+    run_test(context, |a| struct_dynamic_drop(a, true, false, true));\n+    run_test(context, |a| struct_dynamic_drop(a, true, true, false));\n+    run_test(context, |a| struct_dynamic_drop(a, true, true, true));\n+\n+    run_test(context, |a| field_assignment(a, false));\n+    run_test(context, |a| field_assignment(a, true));\n+\n+    run_test(context, |a| mixed_drop_and_nondrop(a));\n+\n+    run_test(context, |a| slice_pattern_one_of(a, 0));\n+    run_test(context, |a| slice_pattern_one_of(a, 1));\n+    run_test(context, |a| slice_pattern_one_of(a, 2));\n+    run_test(context, |a| slice_pattern_one_of(a, 3));\n+\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test(context, |a| subslice_pattern_reassign(a));\n }"}, {"sha": "8516bc3d96424cb452adb6ccd7051d11d21728b0", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 105, "deletions": 176, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece4977138a8eda96c234982e482fb43f67f1bee/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=ece4977138a8eda96c234982e482fb43f67f1bee", "patch": "@@ -17,7 +17,6 @@ struct InjectedFailure;\n \n struct Allocator {\n     data: RefCell<Vec<bool>>,\n-    name: &'static str,\n     failing_op: usize,\n     cur_ops: Cell<usize>,\n }\n@@ -29,18 +28,17 @@ impl Drop for Allocator {\n     fn drop(&mut self) {\n         let data = self.data.borrow();\n         if data.iter().any(|d| *d) {\n-            panic!(\"missing free in {:?}: {:?}\", self.name, data);\n+            panic!(\"missing free: {:?}\", data);\n         }\n     }\n }\n \n impl Allocator {\n-    fn new(failing_op: usize, name: &'static str) -> Self {\n+    fn new(failing_op: usize) -> Self {\n         Allocator {\n             failing_op: failing_op,\n             cur_ops: Cell::new(0),\n-            data: RefCell::new(vec![]),\n-            name,\n+            data: RefCell::new(vec![])\n         }\n     }\n     fn alloc(&self) -> Ptr<'_> {\n@@ -55,14 +53,28 @@ impl Allocator {\n         data.push(true);\n         Ptr(addr, self)\n     }\n+    // FIXME(#47949) Any use of this indicates a bug in rustc: we should never\n+    // be leaking values in the cases here.\n+    //\n+    // Creates a `Ptr<'_>` and checks that the allocated value is leaked if the\n+    // `failing_op` is in the list of exception.\n+    fn alloc_leaked(&self, exceptions: Vec<usize>) -> Ptr<'_> {\n+        let ptr = self.alloc();\n+\n+        if exceptions.iter().any(|operation| *operation == self.failing_op) {\n+            let mut data = self.data.borrow_mut();\n+            data[ptr.0] = false;\n+        }\n+        ptr\n+    }\n }\n \n struct Ptr<'a>(usize, &'a Allocator);\n impl<'a> Drop for Ptr<'a> {\n     fn drop(&mut self) {\n         match self.1.data.borrow_mut()[self.0] {\n             false => {\n-                panic!(\"double free in {:?} at index {:?}\", self.1.name, self.0)\n+                panic!(\"double free at index {:?}\", self.0)\n             }\n             ref mut d => *d = false\n         }\n@@ -258,148 +270,79 @@ fn subslice_pattern_reassign(a: &Allocator) {\n }\n \n fn panic_after_return(a: &Allocator) -> Ptr<'_> {\n+    // Panic in the drop of `p` or `q` can leak\n+    let exceptions = vec![8, 9];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let p = a.alloc();\n-        a.alloc()\n+        // FIXME (#47949) We leak values when we panic in a destructor after\n+        // evaluating an expression with `rustc_mir::build::Builder::into`.\n+        a.alloc_leaked(exceptions)\n     }\n }\n \n fn panic_after_return_expr(a: &Allocator) -> Ptr<'_> {\n+    // Panic in the drop of `p` or `q` can leak\n+    let exceptions = vec![8, 9];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let q = a.alloc();\n-        return a.alloc();\n+        // FIXME (#47949)\n+        return a.alloc_leaked(exceptions);\n     }\n }\n \n fn panic_after_init(a: &Allocator) {\n+    // Panic in the drop of `r` can leak\n+    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     let q = {\n         a.alloc();\n         let r = a.alloc();\n-        a.alloc()\n+        // FIXME (#47949)\n+        a.alloc_leaked(exceptions)\n     };\n }\n \n fn panic_after_init_temp(a: &Allocator) {\n+    // Panic in the drop of `r` can leak\n+    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let r = a.alloc();\n-        a.alloc()\n+        // FIXME (#47949)\n+        a.alloc_leaked(exceptions)\n     };\n }\n \n fn panic_after_init_by_loop(a: &Allocator) {\n+    // Panic in the drop of `r` can leak\n+    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     let q = loop {\n         a.alloc();\n         let r = a.alloc();\n-        break a.alloc();\n-    };\n-}\n-\n-fn panic_after_init_by_match(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    loop {\n-        let q = match b {\n-            true => {\n-                a.alloc();\n-                let r = a.alloc();\n-                a.alloc()\n-            }\n-            false => {\n-                a.alloc();\n-                let r = a.alloc();\n-                break a.alloc();\n-            }\n-        };\n-        return;\n-    };\n-}\n-\n-fn panic_after_init_by_match_with_guard(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = match a.alloc() {\n-        _ if b => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-        _ => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        },\n-    };\n-}\n-\n-fn panic_after_init_by_match_with_bindings_and_guard(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = match a.alloc() {\n-        _x if b => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-        _x => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        },\n-    };\n-}\n-\n-fn panic_after_init_by_match_with_ref_bindings_and_guard(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = match a.alloc() {\n-        ref _x if b => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-        ref _x => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        },\n-    };\n-}\n-\n-fn panic_after_init_by_break_if(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = loop {\n-        let r = a.alloc();\n-        break if b {\n-            let s = a.alloc();\n-            a.alloc()\n-        } else {\n-            a.alloc()\n-        };\n+        // FIXME (#47949)\n+        break a.alloc_leaked(exceptions);\n     };\n }\n \n-fn run_test<F>(mut f: F, name: &'static str)\n+fn run_test<F>(mut f: F)\n     where F: FnMut(&Allocator)\n {\n-    let first_alloc = Allocator::new(usize::MAX, name);\n+    let first_alloc = Allocator::new(usize::MAX);\n     f(&first_alloc);\n \n     for failing_op in 1..first_alloc.cur_ops.get()+1 {\n-        let alloc = Allocator::new(failing_op, name);\n+        let alloc = Allocator::new(failing_op);\n         let alloc = &alloc;\n         let f = panic::AssertUnwindSafe(&mut f);\n         let result = panic::catch_unwind(move || {\n@@ -417,91 +360,77 @@ fn run_test<F>(mut f: F, name: &'static str)\n     }\n }\n \n-fn run_test_nopanic<F>(mut f: F, name: &'static str)\n+fn run_test_nopanic<F>(mut f: F)\n     where F: FnMut(&Allocator)\n {\n-    let first_alloc = Allocator::new(usize::MAX, name);\n+    let first_alloc = Allocator::new(usize::MAX);\n     f(&first_alloc);\n }\n \n-macro_rules! run_test {\n-    ($e:expr) => { run_test($e, stringify!($e)); }\n-}\n-\n fn main() {\n-    run_test!(|a| dynamic_init(a, false));\n-    run_test!(|a| dynamic_init(a, true));\n-    run_test!(|a| dynamic_drop(a, false));\n-    run_test!(|a| dynamic_drop(a, true));\n-\n-    run_test!(|a| assignment2(a, false, false));\n-    run_test!(|a| assignment2(a, false, true));\n-    run_test!(|a| assignment2(a, true, false));\n-    run_test!(|a| assignment2(a, true, true));\n-\n-    run_test!(|a| assignment1(a, false));\n-    run_test!(|a| assignment1(a, true));\n-\n-    run_test!(|a| array_simple(a));\n-    run_test!(|a| vec_simple(a));\n-    run_test!(|a| vec_unreachable(a));\n-\n-    run_test!(|a| struct_dynamic_drop(a, false, false, false));\n-    run_test!(|a| struct_dynamic_drop(a, false, false, true));\n-    run_test!(|a| struct_dynamic_drop(a, false, true, false));\n-    run_test!(|a| struct_dynamic_drop(a, false, true, true));\n-    run_test!(|a| struct_dynamic_drop(a, true, false, false));\n-    run_test!(|a| struct_dynamic_drop(a, true, false, true));\n-    run_test!(|a| struct_dynamic_drop(a, true, true, false));\n-    run_test!(|a| struct_dynamic_drop(a, true, true, true));\n-\n-    run_test!(|a| field_assignment(a, false));\n-    run_test!(|a| field_assignment(a, true));\n-\n-    run_test!(|a| generator(a, 0));\n-    run_test!(|a| generator(a, 1));\n-    run_test!(|a| generator(a, 2));\n-    run_test!(|a| generator(a, 3));\n-\n-    run_test!(|a| mixed_drop_and_nondrop(a));\n-\n-    run_test!(|a| slice_pattern_first(a));\n-    run_test!(|a| slice_pattern_middle(a));\n-    run_test!(|a| slice_pattern_two(a));\n-    run_test!(|a| slice_pattern_last(a));\n-    run_test!(|a| slice_pattern_one_of(a, 0));\n-    run_test!(|a| slice_pattern_one_of(a, 1));\n-    run_test!(|a| slice_pattern_one_of(a, 2));\n-    run_test!(|a| slice_pattern_one_of(a, 3));\n-\n-    run_test!(|a| subslice_pattern_from_end(a, true));\n-    run_test!(|a| subslice_pattern_from_end(a, false));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, true, true));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, true, false));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, false, true));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, false, false));\n-    run_test!(|a| slice_pattern_reassign(a));\n-    run_test!(|a| subslice_pattern_reassign(a));\n-\n-    run_test!(|a| {\n+    run_test(|a| dynamic_init(a, false));\n+    run_test(|a| dynamic_init(a, true));\n+    run_test(|a| dynamic_drop(a, false));\n+    run_test(|a| dynamic_drop(a, true));\n+\n+    run_test(|a| assignment2(a, false, false));\n+    run_test(|a| assignment2(a, false, true));\n+    run_test(|a| assignment2(a, true, false));\n+    run_test(|a| assignment2(a, true, true));\n+\n+    run_test(|a| assignment1(a, false));\n+    run_test(|a| assignment1(a, true));\n+\n+    run_test(|a| array_simple(a));\n+    run_test(|a| vec_simple(a));\n+    run_test(|a| vec_unreachable(a));\n+\n+    run_test(|a| struct_dynamic_drop(a, false, false, false));\n+    run_test(|a| struct_dynamic_drop(a, false, false, true));\n+    run_test(|a| struct_dynamic_drop(a, false, true, false));\n+    run_test(|a| struct_dynamic_drop(a, false, true, true));\n+    run_test(|a| struct_dynamic_drop(a, true, false, false));\n+    run_test(|a| struct_dynamic_drop(a, true, false, true));\n+    run_test(|a| struct_dynamic_drop(a, true, true, false));\n+    run_test(|a| struct_dynamic_drop(a, true, true, true));\n+\n+    run_test(|a| field_assignment(a, false));\n+    run_test(|a| field_assignment(a, true));\n+\n+    run_test(|a| generator(a, 0));\n+    run_test(|a| generator(a, 1));\n+    run_test(|a| generator(a, 2));\n+    run_test(|a| generator(a, 3));\n+\n+    run_test(|a| mixed_drop_and_nondrop(a));\n+\n+    run_test(|a| slice_pattern_first(a));\n+    run_test(|a| slice_pattern_middle(a));\n+    run_test(|a| slice_pattern_two(a));\n+    run_test(|a| slice_pattern_last(a));\n+    run_test(|a| slice_pattern_one_of(a, 0));\n+    run_test(|a| slice_pattern_one_of(a, 1));\n+    run_test(|a| slice_pattern_one_of(a, 2));\n+    run_test(|a| slice_pattern_one_of(a, 3));\n+\n+    run_test(|a| subslice_pattern_from_end(a, true));\n+    run_test(|a| subslice_pattern_from_end(a, false));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test(|a| slice_pattern_reassign(a));\n+    run_test(|a| subslice_pattern_reassign(a));\n+\n+    run_test(|a| {\n         panic_after_return(a);\n     });\n-    run_test!(|a| {\n+    run_test(|a| {\n         panic_after_return_expr(a);\n     });\n-    run_test!(|a| panic_after_init(a));\n-    run_test!(|a| panic_after_init_temp(a));\n-    run_test!(|a| panic_after_init_by_loop(a));\n-    run_test!(|a| panic_after_init_by_match(a, false));\n-    run_test!(|a| panic_after_init_by_match(a, true));\n-    run_test!(|a| panic_after_init_by_match_with_guard(a, false));\n-    run_test!(|a| panic_after_init_by_match_with_guard(a, true));\n-    run_test!(|a| panic_after_init_by_match_with_bindings_and_guard(a, false));\n-    run_test!(|a| panic_after_init_by_match_with_bindings_and_guard(a, true));\n-    run_test!(|a| panic_after_init_by_match_with_ref_bindings_and_guard(a, false));\n-    run_test!(|a| panic_after_init_by_match_with_ref_bindings_and_guard(a, true));\n-    run_test!(|a| panic_after_init_by_break_if(a, false));\n-    run_test!(|a| panic_after_init_by_break_if(a, true));\n-\n-    run_test_nopanic(|a| union1(a), \"|a| union1(a)\");\n+    run_test(|a| panic_after_init(a));\n+    run_test(|a| panic_after_init_temp(a));\n+    run_test(|a| panic_after_init_by_loop(a));\n+\n+    run_test_nopanic(|a| union1(a));\n }"}]}