{"sha": "a139f73f7762fea8486fb0238ac71965d41ee5e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMzlmNzNmNzc2MmZlYTg0ODZmYjAyMzhhYzcxOTY1ZDQxZWU1ZTM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-10-20T16:41:26Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-10-20T16:41:26Z"}, "message": "Move maybe_create_entry_wrapper to main_shim.rs", "tree": {"sha": "48109f67e5401b8946a0cbb3321667c6e528dfac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48109f67e5401b8946a0cbb3321667c6e528dfac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a139f73f7762fea8486fb0238ac71965d41ee5e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a139f73f7762fea8486fb0238ac71965d41ee5e3", "html_url": "https://github.com/rust-lang/rust/commit/a139f73f7762fea8486fb0238ac71965d41ee5e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a139f73f7762fea8486fb0238ac71965d41ee5e3/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f574e9f7bbf7a5745cfb5ee38d393702341e6be", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f574e9f7bbf7a5745cfb5ee38d393702341e6be", "html_url": "https://github.com/rust-lang/rust/commit/3f574e9f7bbf7a5745cfb5ee38d393702341e6be"}], "stats": {"total": 234, "additions": 120, "deletions": 114}, "files": [{"sha": "32c3827eaa7a6122e0e3bd9c0730363defb95b2e", "filename": "src/lib.rs", "status": "modified", "additions": 16, "deletions": 114, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/a139f73f7762fea8486fb0238ac71965d41ee5e3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a139f73f7762fea8486fb0238ac71965d41ee5e3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a139f73f7762fea8486fb0238ac71965d41ee5e3", "patch": "@@ -53,6 +53,7 @@ mod base;\n mod common;\n mod constant;\n mod intrinsics;\n+mod main_shim;\n mod metadata;\n mod pretty_clif;\n mod vtable;\n@@ -270,11 +271,12 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             .downcast::<OngoingCodegen>()\n             .expect(\"Expected CraneliftCodegenBackend's OngoingCodegen, found Box<Any>\");\n \n-        let mut artifact = ongoing_codegen.product.artifact;\n+        let artifact = ongoing_codegen.product.artifact;\n         let metadata = ongoing_codegen.metadata;\n \n         let metadata_name =\n             \".rustc.clif_metadata\".to_string() + &ongoing_codegen.crate_hash.to_string();\n+        /*\n         artifact\n             .declare_with(\n                 &metadata_name,\n@@ -285,6 +287,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n                 metadata.clone(),\n             )\n             .unwrap();\n+        */\n \n         for &crate_type in sess.opts.crate_types.iter() {\n             match crate_type {\n@@ -313,15 +316,17 @@ impl CodegenBackend for CraneliftCodegenBackend {\n                     // Non object files need to be added after object files, because ranlib will\n                     // try to read the native architecture from the first file, even if it isn't\n                     // an object file\n-                    builder\n-                        .append(\n-                            &ar::Header::new(\n-                                metadata_name.as_bytes().to_vec(),\n-                                metadata.len() as u64,\n-                            ),\n-                            ::std::io::Cursor::new(metadata.clone()),\n-                        )\n-                        .unwrap();\n+                    if crate_type != CrateType::Executable {\n+                        builder\n+                            .append(\n+                                &ar::Header::new(\n+                                    metadata_name.as_bytes().to_vec(),\n+                                    metadata.len() as u64,\n+                                ),\n+                                ::std::io::Cursor::new(metadata.clone()),\n+                            )\n+                            .unwrap();\n+                    }\n \n                     // Finalize archive\n                     std::mem::drop(builder);\n@@ -383,7 +388,7 @@ fn codegen_mono_items<'a, 'tcx: 'a>(\n         }\n     }\n \n-    maybe_create_entry_wrapper(tcx, module);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, module);\n \n     ccx.finalize(tcx, module);\n \n@@ -402,106 +407,3 @@ fn save_incremental<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n pub fn __rustc_codegen_backend() -> Box<CodegenBackend> {\n     Box::new(CraneliftCodegenBackend)\n }\n-\n-/// Create the `main` function which will initialize the rust runtime and call\n-/// users main function.\n-fn maybe_create_entry_wrapper<'a, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    module: &mut Module<impl Backend + 'static>,\n-) {\n-    use crate::rustc::middle::lang_items::StartFnLangItem;\n-    use crate::rustc::session::config::EntryFnType;\n-\n-    let (main_def_id, use_start_lang_item) = match *tcx.sess.entry_fn.borrow() {\n-        Some((id, _, entry_ty)) => (\n-            tcx.hir.local_def_id(id),\n-            match entry_ty {\n-                EntryFnType::Main => true,\n-                EntryFnType::Start => false,\n-            },\n-        ),\n-        None => return,\n-    };\n-\n-    create_entry_fn(tcx, module, main_def_id, use_start_lang_item);;\n-\n-    fn create_entry_fn<'a, 'tcx: 'a>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        m: &mut Module<impl Backend + 'static>,\n-        rust_main_def_id: DefId,\n-        use_start_lang_item: bool,\n-    ) {\n-        let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n-        // Given that `main()` has no arguments,\n-        // then its return type cannot have\n-        // late-bound regions, since late-bound\n-        // regions must appear in the argument\n-        // listing.\n-        let main_ret_ty = tcx.erase_regions(&main_ret_ty.no_late_bound_regions().unwrap());\n-\n-        let cmain_sig = Signature {\n-            params: vec![\n-                AbiParam::new(m.pointer_type()),\n-                AbiParam::new(m.pointer_type()),\n-            ],\n-            returns: vec![AbiParam::new(m.pointer_type() /*isize*/)],\n-            call_conv: CallConv::SystemV,\n-        };\n-\n-        let cmain_func_id = m\n-            .declare_function(\"main\", Linkage::Export, &cmain_sig)\n-            .unwrap();\n-\n-        let instance = Instance::mono(tcx, rust_main_def_id);\n-\n-        let (main_name, main_sig) = get_function_name_and_sig(tcx, instance);\n-\n-        let main_func_id = m\n-            .declare_function(&main_name, Linkage::Import, &main_sig)\n-            .unwrap();\n-\n-        let mut ctx = Context::new();\n-        ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig.clone());\n-        {\n-            let mut func_ctx = FunctionBuilderContext::new();\n-            let mut bcx: FunctionBuilder = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n-\n-            let ebb = bcx.create_ebb();\n-            bcx.switch_to_block(ebb);\n-            let arg_argc = bcx.append_ebb_param(ebb, m.pointer_type());\n-            let arg_argv = bcx.append_ebb_param(ebb, m.pointer_type());\n-\n-            let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n-\n-            let call_inst = if use_start_lang_item {\n-                let start_def_id = tcx.require_lang_item(StartFnLangItem);\n-                let start_instance = Instance::resolve(\n-                    tcx,\n-                    ParamEnv::reveal_all(),\n-                    start_def_id,\n-                    tcx.intern_substs(&[main_ret_ty.into()]),\n-                )\n-                .unwrap();\n-\n-                let (start_name, start_sig) = get_function_name_and_sig(tcx, start_instance);\n-                let start_func_id = m\n-                    .declare_function(&start_name, Linkage::Import, &start_sig)\n-                    .unwrap();\n-\n-                let main_val = bcx.ins().func_addr(m.pointer_type(), main_func_ref);\n-\n-                let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n-                bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])\n-            } else {\n-                // using user-defined start fn\n-                bcx.ins().call(main_func_ref, &[arg_argc, arg_argv])\n-            };\n-\n-            let result = bcx.inst_results(call_inst)[0];\n-            bcx.ins().return_(&[result]);\n-            bcx.seal_all_blocks();\n-            bcx.finalize();\n-        }\n-        m.define_function(cmain_func_id, &mut ctx).unwrap();\n-    }\n-}"}, {"sha": "204a933fb8d6b22fcbce38ad795de6e365701bf9", "filename": "src/main_shim.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a139f73f7762fea8486fb0238ac71965d41ee5e3/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a139f73f7762fea8486fb0238ac71965d41ee5e3/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=a139f73f7762fea8486fb0238ac71965d41ee5e3", "patch": "@@ -0,0 +1,104 @@\n+use crate::prelude::*;\n+\n+/// Create the `main` function which will initialize the rust runtime and call\n+/// users main function.\n+pub fn maybe_create_entry_wrapper<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    module: &mut Module<impl Backend + 'static>,\n+) {\n+    use crate::rustc::middle::lang_items::StartFnLangItem;\n+    use crate::rustc::session::config::EntryFnType;\n+\n+    let (main_def_id, use_start_lang_item) = match *tcx.sess.entry_fn.borrow() {\n+        Some((id, _, entry_ty)) => (\n+            tcx.hir.local_def_id(id),\n+            match entry_ty {\n+                EntryFnType::Main => true,\n+                EntryFnType::Start => false,\n+            },\n+        ),\n+        None => return,\n+    };\n+\n+    create_entry_fn(tcx, module, main_def_id, use_start_lang_item);;\n+\n+    fn create_entry_fn<'a, 'tcx: 'a>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        m: &mut Module<impl Backend + 'static>,\n+        rust_main_def_id: DefId,\n+        use_start_lang_item: bool,\n+    ) {\n+        let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n+        // Given that `main()` has no arguments,\n+        // then its return type cannot have\n+        // late-bound regions, since late-bound\n+        // regions must appear in the argument\n+        // listing.\n+        let main_ret_ty = tcx.erase_regions(&main_ret_ty.no_late_bound_regions().unwrap());\n+\n+        let cmain_sig = Signature {\n+            params: vec![\n+                AbiParam::new(m.pointer_type()),\n+                AbiParam::new(m.pointer_type()),\n+            ],\n+            returns: vec![AbiParam::new(m.pointer_type() /*isize*/)],\n+            call_conv: CallConv::SystemV,\n+        };\n+\n+        let cmain_func_id = m\n+            .declare_function(\"main\", Linkage::Export, &cmain_sig)\n+            .unwrap();\n+\n+        let instance = Instance::mono(tcx, rust_main_def_id);\n+\n+        let (main_name, main_sig) = get_function_name_and_sig(tcx, instance);\n+\n+        let main_func_id = m\n+            .declare_function(&main_name, Linkage::Import, &main_sig)\n+            .unwrap();\n+\n+        let mut ctx = Context::new();\n+        ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig.clone());\n+        {\n+            let mut func_ctx = FunctionBuilderContext::new();\n+            let mut bcx: FunctionBuilder = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n+\n+            let ebb = bcx.create_ebb();\n+            bcx.switch_to_block(ebb);\n+            let arg_argc = bcx.append_ebb_param(ebb, m.pointer_type());\n+            let arg_argv = bcx.append_ebb_param(ebb, m.pointer_type());\n+\n+            let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n+\n+            let call_inst = if use_start_lang_item {\n+                let start_def_id = tcx.require_lang_item(StartFnLangItem);\n+                let start_instance = Instance::resolve(\n+                    tcx,\n+                    ParamEnv::reveal_all(),\n+                    start_def_id,\n+                    tcx.intern_substs(&[main_ret_ty.into()]),\n+                )\n+                .unwrap();\n+\n+                let (start_name, start_sig) = get_function_name_and_sig(tcx, start_instance);\n+                let start_func_id = m\n+                    .declare_function(&start_name, Linkage::Import, &start_sig)\n+                    .unwrap();\n+\n+                let main_val = bcx.ins().func_addr(m.pointer_type(), main_func_ref);\n+\n+                let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n+                bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])\n+            } else {\n+                // using user-defined start fn\n+                bcx.ins().call(main_func_ref, &[arg_argc, arg_argv])\n+            };\n+\n+            let result = bcx.inst_results(call_inst)[0];\n+            bcx.ins().return_(&[result]);\n+            bcx.seal_all_blocks();\n+            bcx.finalize();\n+        }\n+        m.define_function(cmain_func_id, &mut ctx).unwrap();\n+    }\n+}"}]}