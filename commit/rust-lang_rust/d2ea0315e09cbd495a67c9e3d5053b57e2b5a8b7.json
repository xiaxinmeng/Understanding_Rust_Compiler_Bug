{"sha": "d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZWEwMzE1ZTA5Y2JkNDk1YTY3YzllM2Q1MDUzYjU3ZTJiNWE4Yjc=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-02T18:48:07Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-02T18:48:07Z"}, "message": "Revert \"Use slice syntax instead of slice_to, etc.\"\n\nThis reverts commit 40b9f5ded50ac4ce8c9323921ec556ad611af6b7.", "tree": {"sha": "d39de6be5866c0f0f37f9f3219b8217c873d8b52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d39de6be5866c0f0f37f9f3219b8217c873d8b52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "comment_count": 17, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "html_url": "https://github.com/rust-lang/rust/commit/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0c6c895890770d7029324fd9b592f42e0564e8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c6c895890770d7029324fd9b592f42e0564e8b", "html_url": "https://github.com/rust-lang/rust/commit/c0c6c895890770d7029324fd9b592f42e0564e8b"}], "stats": {"total": 694, "additions": 363, "deletions": 331}, "files": [{"sha": "b48ccfc43742d51e839152a9cdea7b7ded08a5a7", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -874,7 +874,7 @@ fn check_error_patterns(props: &TestProps,\n     if done { return; }\n \n     let missing_patterns =\n-        props.error_patterns[next_err_idx..];\n+        props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n     if missing_patterns.len() == 1u {\n         fatal_proc_rec(format!(\"error pattern '{}' not found!\",\n                               missing_patterns[0]).as_slice(),"}, {"sha": "60c9dfcff187c1c03882d8e224130658286af35e", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -194,7 +194,7 @@ impl Bitv {\n         if start > self.storage.len() {\n             start = self.storage.len();\n         }\n-        let mut iter = self.storage[start..].iter();\n+        let mut iter = self.storage.slice_from(start).iter();\n         MaskWords {\n           next_word: iter.next(),\n           iter: iter,"}, {"sha": "02c8af2c470f3f3cb5c7905c2dfa234f03d80ea4", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -271,7 +271,7 @@ impl<T> RingBuf<T> {\n     ///     *num = *num - 2;\n     /// }\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n-    /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n+    /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>().as_slice(), b);\n     /// ```\n     pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n         let start_index = raw_index(self.lo, self.elts.len(), 0);\n@@ -291,7 +291,7 @@ impl<T> RingBuf<T> {\n         } else {\n             // Items to iterate goes from start_index to end_index:\n             let (empty, elts) = self.elts.split_at_mut(0);\n-            let remaining1 = elts[mut start_index..end_index];\n+            let remaining1 = elts.slice_mut(start_index, end_index);\n             MutItems { remaining1: remaining1,\n                                  remaining2: empty,\n                                  nelts: self.nelts }"}, {"sha": "45489bbf84eb4059f93649e6194b24b7de620dc6", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -46,13 +46,12 @@\n //! These traits include `ImmutableSlice`, which is defined for `&[T]` types,\n //! and `MutableSlice`, defined for `&mut [T]` types.\n //!\n-//! An example is the `slice` method which enables slicing syntax `[a..b]` that\n-//! returns an immutable \"view\" into a `Vec` or another slice from the index\n-//! interval `[a, b)`:\n+//! An example is the method `.slice(a, b)` that returns an immutable \"view\" into\n+//! a `Vec` or another slice from the index interval `[a, b)`:\n //!\n //! ```rust\n //! let numbers = [0i, 1i, 2i];\n-//! let last_numbers = numbers[1..3];\n+//! let last_numbers = numbers.slice(1, 3);\n //! // last_numbers is now &[1i, 2i]\n //! ```\n //!\n@@ -611,7 +610,7 @@ impl<'a,T> MutableSliceAllocating<'a, T> for &'a mut [T] {\n \n     #[inline]\n     fn move_from(self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.iter_mut().zip(src[mut start..end].iter_mut()) {\n+        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n@@ -703,7 +702,7 @@ impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n         self.swap(j, i-1);\n \n         // Step 4: Reverse the (previously) weakly decreasing part\n-        self[mut i..].reverse();\n+        self.slice_from_mut(i).reverse();\n \n         true\n     }\n@@ -724,7 +723,7 @@ impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n         }\n \n         // Step 2: Reverse the weakly increasing part\n-        self[mut i..].reverse();\n+        self.slice_from_mut(i).reverse();\n \n         // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n         let mut j = self.len() - 1;\n@@ -991,24 +990,24 @@ mod tests {\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1i, 2, 3, 4];\n-        let v_a = vec_fixed[1u..vec_fixed.len()].to_vec();\n+        let v_a = vec_fixed.slice(1u, vec_fixed.len()).to_vec();\n         assert_eq!(v_a.len(), 3u);\n         let v_a = v_a.as_slice();\n         assert_eq!(v_a[0], 2);\n         assert_eq!(v_a[1], 3);\n         assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n-        let vec_stack: &[_] = &[1i, 2, 3];\n-        let v_b = vec_stack[1u..3u].to_vec();\n+        let vec_stack = &[1i, 2, 3];\n+        let v_b = vec_stack.slice(1u, 3u).to_vec();\n         assert_eq!(v_b.len(), 2u);\n         let v_b = v_b.as_slice();\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n         let vec_unique = vec![1i, 2, 3, 4, 5, 6];\n-        let v_d = vec_unique[1u..6u].to_vec();\n+        let v_d = vec_unique.slice(1u, 6u).to_vec();\n         assert_eq!(v_d.len(), 5u);\n         let v_d = v_d.as_slice();\n         assert_eq!(v_d[0], 2);\n@@ -1021,21 +1020,21 @@ mod tests {\n     #[test]\n     fn test_slice_from() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec[0..], vec);\n+        assert_eq!(vec.slice_from(0), vec);\n         let b: &[int] = &[3, 4];\n-        assert_eq!(vec[2..], b);\n+        assert_eq!(vec.slice_from(2), b);\n         let b: &[int] = &[];\n-        assert_eq!(vec[4..], b);\n+        assert_eq!(vec.slice_from(4), b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec[..4], vec);\n+        assert_eq!(vec.slice_to(4), vec);\n         let b: &[int] = &[1, 2];\n-        assert_eq!(vec[..2], b);\n+        assert_eq!(vec.slice_to(2), b);\n         let b: &[int] = &[];\n-        assert_eq!(vec[..0], b);\n+        assert_eq!(vec.slice_to(0), b);\n     }\n \n \n@@ -1976,7 +1975,7 @@ mod tests {\n         assert!(a == [7i,2,3,4]);\n         let mut a = [1i,2,3,4,5];\n         let b = vec![5i,6,7,8,9,0];\n-        assert_eq!(a[mut 2..4].move_from(b,1,6), 2);\n+        assert_eq!(a.slice_mut(2,4).move_from(b,1,6), 2);\n         assert!(a == [1i,2,6,7,5]);\n     }\n \n@@ -1996,7 +1995,7 @@ mod tests {\n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1i,2,3,4,5];\n-        values[mut 1..4].reverse();\n+        values.slice_mut(1, 4).reverse();\n         assert!(values == [1,4,3,2,5]);\n     }\n \n@@ -2043,9 +2042,9 @@ mod tests {\n     fn test_bytes_set_memory() {\n         use slice::bytes::MutableByteVector;\n         let mut values = [1u8,2,3,4,5];\n-        values[mut 0..5].set_memory(0xAB);\n+        values.slice_mut(0,5).set_memory(0xAB);\n         assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n-        values[mut 2..4].set_memory(0xFF);\n+        values.slice_mut(2,4).set_memory(0xFF);\n         assert!(values == [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n     }\n \n@@ -2071,18 +2070,12 @@ mod tests {\n         let mut values = [1u8,2,3,4,5];\n         {\n             let (left, right) = values.split_at_mut(2);\n-            {\n-                let left: &[_] = left;\n-                assert!(left[0..left.len()] == [1, 2]);\n-            }\n+            assert!(left.slice(0, left.len()) == [1, 2]);\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n-            {\n-                let right: &[_] = right;\n-                assert!(right[0..right.len()] == [3, 4, 5]);\n-            }\n+            assert!(right.slice(0, right.len()) == [3, 4, 5]);\n             for p in right.iter_mut() {\n                 *p += 2;\n             }\n@@ -2106,7 +2099,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 3);\n \n-        for f in v[1..3].iter() {\n+        for f in v.slice(1, 3).iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }"}, {"sha": "d198e948ac83845837f2f04450714c371397f092", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -1680,7 +1680,7 @@ mod tests {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n+            let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n             if Some(c) != s.chars().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }\n@@ -1692,7 +1692,7 @@ mod tests {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n+            let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n             if Some(c) != s.chars().rev().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }"}, {"sha": "d6adbd302645a0ba7777242b2e3c2792e69091ca", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -160,7 +160,7 @@ impl String {\n \n         if i > 0 {\n             unsafe {\n-                res.as_mut_vec().push_all(v.[..i])\n+                res.as_mut_vec().push_all(v.slice_to(i))\n             };\n         }\n \n@@ -177,7 +177,7 @@ impl String {\n             macro_rules! error(() => ({\n                 unsafe {\n                     if subseqidx != i_ {\n-                        res.as_mut_vec().push_all(vv[subseqidx..i_]);\n+                        res.as_mut_vec().push_all(v.slice(subseqidx, i_));\n                     }\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n@@ -246,7 +246,7 @@ impl String {\n         }\n         if subseqidx < total {\n             unsafe {\n-                res.as_mut_vec().push_all(v[subseqidx..total])\n+                res.as_mut_vec().push_all(v.slice(subseqidx, total))\n             };\n         }\n         Owned(res.into_string())"}, {"sha": "e9981790f7dc08689b7e4c13f1ceba4499df7725", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -24,7 +24,6 @@ use core::fmt;\n use core::fmt::Show;\n use core::mem::zeroed;\n use core::mem;\n-use core::ops::{Slice,SliceMut};\n use core::uint;\n use core::iter;\n use std::hash::{Writer, Hash};\n@@ -379,7 +378,7 @@ macro_rules! bound {\n                         }\n                     };\n                     // push to the stack.\n-                    it.stack[it.length] = children.$slice_from(&slice_idx).$iter();\n+                    it.stack[it.length] = children.$slice_from(slice_idx).$iter();\n                     it.length += 1;\n                     if ret { return it }\n                 })\n@@ -393,7 +392,7 @@ impl<T> TrieMap<T> {\n     fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n         bound!(Entries, self = self,\n                key = key, is_upper = upper,\n-               slice_from = slice_from_, iter = iter,\n+               slice_from = slice_from, iter = iter,\n                mutability = )\n     }\n \n@@ -435,7 +434,7 @@ impl<T> TrieMap<T> {\n     fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n         bound!(MutEntries, self = self,\n                key = key, is_upper = upper,\n-               slice_from = slice_from_mut_, iter = iter_mut,\n+               slice_from = slice_from_mut, iter = iter_mut,\n                mutability = mut)\n     }\n "}, {"sha": "280fbdeffa23dfc2644904162a856dc33e318b56", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -438,7 +438,7 @@ impl<T:Clone> Clone for Vec<T> {\n \n         // self.len <= other.len due to the truncate above, so the\n         // slice here is always in-bounds.\n-        let slice = other[self.len()..];\n+        let slice = other.slice_from(self.len());\n         self.push_all(slice);\n     }\n }\n@@ -928,12 +928,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[0..2] == [1, 2]);\n+    /// assert!(vec.slice(0, 2) == [1, 2]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        self[start..end]\n+        self.as_slice().slice(start, end)\n     }\n \n     /// Returns a slice containing all but the first element of the vector.\n@@ -950,7 +949,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn tail<'a>(&'a self) -> &'a [T] {\n-        self[].tail()\n+        self.as_slice().tail()\n     }\n \n     /// Returns all but the first `n' elements of a vector.\n@@ -967,9 +966,9 @@ impl<T> Vec<T> {\n     /// assert!(vec.tailn(2) == [3, 4]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n+    #[deprecated = \"use slice_from\"]\n     pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n-        self[n..]\n+        self.as_slice().slice_from(n)\n     }\n \n     /// Returns a reference to the last element of a vector, or `None` if it is\n@@ -983,7 +982,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn last<'a>(&'a self) -> Option<&'a T> {\n-        self[].last()\n+        self.as_slice().last()\n     }\n \n     /// Deprecated: use `last_mut`.\n@@ -1177,10 +1176,10 @@ impl<T> Vec<T> {\n     }\n \n     /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slicing syntax\"]\n+    #[deprecated = \"use slice_mut\"]\n     pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n-        self[mut start..end]\n+        self.slice_mut(start, end)\n     }\n \n     /// Returns a mutable slice of `self` between `start` and `end`.\n@@ -1194,19 +1193,18 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut 0..2] == [1, 2]);\n+    /// assert!(vec.slice_mut(0, 2) == [1, 2]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_mut<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n-        self[mut start..end]\n+        self.as_mut_slice().slice_mut(start, end)\n     }\n \n     /// Deprecated: use \"slice_from_mut\".\n-    #[deprecated = \"use slicing syntax\"]\n+    #[deprecated = \"use slice_from_mut\"]\n     pub fn mut_slice_from<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self[mut start..]\n+        self.slice_from_mut(start)\n     }\n \n     /// Returns a mutable slice of `self` from `start` to the end of the `Vec`.\n@@ -1219,18 +1217,17 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut 2..] == [3, 4]);\n+    /// assert!(vec.slice_from_mut(2) == [3, 4]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self[mut start..]\n+        self.as_mut_slice().slice_from_mut(start)\n     }\n \n     /// Deprecated: use `slice_to_mut`.\n-    #[deprecated = \"use slicing syntax\"]\n+    #[deprecated = \"use slice_to_mut\"]\n     pub fn mut_slice_to<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self[mut ..end]\n+        self.slice_to_mut(end)\n     }\n \n     /// Returns a mutable slice of `self` from the start of the `Vec` to `end`.\n@@ -1243,12 +1240,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut ..2] == [1, 2]);\n+    /// assert!(vec.slice_to_mut(2) == [1, 2]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self[mut ..end]\n+        self.as_mut_slice().slice_to_mut(end)\n     }\n \n     /// Deprecated: use `split_at_mut`.\n@@ -1293,7 +1289,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        self[mut].split_at_mut(mid)\n+        self.as_mut_slice().split_at_mut(mid)\n     }\n \n     /// Reverses the order of elements in a vector, in place.\n@@ -1307,7 +1303,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn reverse(&mut self) {\n-        self[mut].reverse()\n+        self.as_mut_slice().reverse()\n     }\n \n     /// Returns a slice of `self` from `start` to the end of the vec.\n@@ -1320,12 +1316,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec[1..] == [2, 3]);\n+    /// assert!(vec.slice_from(1) == [2, 3]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        self[start..]\n+        self.as_slice().slice_from(start)\n     }\n \n     /// Returns a slice of self from the start of the vec to `end`.\n@@ -1338,12 +1333,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[..2] == [1, 2]);\n+    /// assert!(vec.slice_to(2) == [1, 2]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        self[..end]\n+        self.as_slice().slice_to(end)\n     }\n \n     /// Returns a slice containing all but the last element of the vector.\n@@ -1360,7 +1354,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn init<'a>(&'a self) -> &'a [T] {\n-        self[0..self.len() - 1]\n+        self.slice(0, self.len() - 1)\n     }\n \n \n@@ -2218,18 +2212,12 @@ mod tests {\n         let mut values = Vec::from_slice([1u8,2,3,4,5]);\n         {\n             let (left, right) = values.split_at_mut(2);\n-            {\n-                let left: &[_] = left;\n-                assert!(left[0..left.len()] == [1, 2]);\n-            }\n+            assert!(left.slice(0, left.len()) == [1, 2]);\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n-            {\n-                let right: &[_] = right;\n-                assert!(right[0..right.len()] == [3, 4, 5]);\n-            }\n+            assert!(right.slice(0, right.len()) == [3, 4, 5]);\n             for p in right.iter_mut() {\n                 *p += 2;\n             }"}, {"sha": "92ef0c281f282eecc5095b4a9d226925e4fc02b5", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -17,7 +17,7 @@ use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n use num::{Zero, One, cast};\n use result::Ok;\n-use slice::MutableSlice;\n+use slice::{ImmutableSlice, MutableSlice};\n use slice;\n use str::StrSlice;\n \n@@ -173,7 +173,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         _ => ()\n     }\n \n-    buf[mut ..end].reverse();\n+    buf.slice_to_mut(end).reverse();\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,\n@@ -310,7 +310,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n \n             impl<'a> fmt::FormatWriter for Filler<'a> {\n                 fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-                    slice::bytes::copy_memory(self.buf[mut *self.end..],\n+                    slice::bytes::copy_memory(self.buf.slice_from_mut(*self.end),\n                                               bytes);\n                     *self.end += bytes.len();\n                     Ok(())\n@@ -328,5 +328,5 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         }\n     }\n \n-    f(buf[..end])\n+    f(buf.slice_to(end))\n }"}, {"sha": "7bab59960b0fea938d1f633a7bbba580ca8f3423", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -423,7 +423,7 @@ impl<'a> Formatter<'a> {\n             for c in sign.into_iter() {\n                 let mut b = [0, ..4];\n                 let n = c.encode_utf8(b).unwrap_or(0);\n-                try!(f.buf.write(b[..n]));\n+                try!(f.buf.write(b.slice_to(n)));\n             }\n             if prefixed { f.buf.write(prefix.as_bytes()) }\n             else { Ok(()) }\n@@ -530,13 +530,13 @@ impl<'a> Formatter<'a> {\n         let len = self.fill.encode_utf8(fill).unwrap_or(0);\n \n         for _ in range(0, pre_pad) {\n-            try!(self.buf.write(fill[..len]));\n+            try!(self.buf.write(fill.slice_to(len)));\n         }\n \n         try!(f(self));\n \n         for _ in range(0, post_pad) {\n-            try!(self.buf.write(fill[..len]));\n+            try!(self.buf.write(fill.slice_to(len)));\n         }\n \n         Ok(())\n@@ -611,7 +611,7 @@ impl Char for char {\n \n         let mut utf8 = [0u8, ..4];\n         let amt = self.encode_utf8(utf8).unwrap_or(0);\n-        let s: &str = unsafe { mem::transmute(utf8[..amt]) };\n+        let s: &str = unsafe { mem::transmute(utf8.slice_to(amt)) };\n         secret_string(&s, f)\n     }\n }"}, {"sha": "afcd0d1d645e6d9e38cf87e626ada16c1b094923", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -18,7 +18,7 @@ use collections::Collection;\n use fmt;\n use iter::DoubleEndedIterator;\n use num::{Int, cast, zero};\n-use slice::{MutableSlice};\n+use slice::{ImmutableSlice, MutableSlice};\n \n /// A type that represents a specific radix\n #[doc(hidden)]\n@@ -60,7 +60,7 @@ trait GenericRadix {\n                 if x == zero() { break; }                 // No more digits left to accumulate.\n             }\n         }\n-        f.pad_integral(is_positive, self.prefix(), buf[curr..])\n+        f.pad_integral(is_positive, self.prefix(), buf.slice_from(curr))\n     }\n }\n "}, {"sha": "1a00107a216321cbfb369038c4d6330da01cea61", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 89, "deletions": 47, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -68,24 +68,23 @@ pub trait ImmutableSlice<'a, T> {\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[unstable = \"waiting on final error conventions\"]\n-    //fn slice(&self, start: uint, end: uint) -> &'a [T];\n+    fn slice(&self, start: uint, end: uint) -> &'a [T];\n \n     /// Returns a subslice from `start` to the end of the slice.\n     ///\n     /// Fails when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[unstable = \"waiting on final error conventions\"]\n-    // TODO\n-    //fn slice_from(&self, start: uint) -> &'a [T];\n+    fn slice_from(&self, start: uint) -> &'a [T];\n \n     /// Returns a subslice from the start of the slice to `end`.\n     ///\n     /// Fails when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[unstable = \"waiting on final error conventions\"]\n-    //fn slice_to(&self, end: uint) -> &'a [T];\n+    fn slice_to(&self, end: uint) -> &'a [T];\n \n     /// Divides one slice into two at an index.\n     ///\n@@ -178,7 +177,7 @@ pub trait ImmutableSlice<'a, T> {\n     fn tail(&self) -> &'a [T];\n \n     /// Returns all but the first `n' elements of a slice.\n-    #[deprecated = \"use slicing syntax\"]\n+    #[deprecated = \"use slice_from\"]\n     fn tailn(&self, n: uint) -> &'a [T];\n \n     /// Returns all but the last element of a slice.\n@@ -187,7 +186,6 @@ pub trait ImmutableSlice<'a, T> {\n \n     /// Returns all but the last `n' elements of a slice.\n     #[deprecated = \"use slice_to but note the arguments are different\"]\n-    #[deprecated = \"use slicing syntax, but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n@@ -242,7 +240,7 @@ pub trait ImmutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None }\n      *     let head = &self[0];\n-     *     *self = self[1..];\n+     *     *self = self.slice_from(1);\n      *     Some(head)\n      * ```\n      *\n@@ -261,7 +259,7 @@ pub trait ImmutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let tail = &self[self.len() - 1];\n-     *     *self = self[..self.len() - 1];\n+     *     *self = self.slice_to(self.len() - 1);\n      *     Some(tail)\n      * ```\n      *\n@@ -273,9 +271,31 @@ pub trait ImmutableSlice<'a, T> {\n \n #[unstable]\n impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n+    #[inline]\n+    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(start as int),\n+                    len: (end - start)\n+                })\n+        }\n+    }\n+\n+    #[inline]\n+    fn slice_from(&self, start: uint) -> &'a [T] {\n+        self.slice(start, self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to(&self, end: uint) -> &'a [T] {\n+        self.slice(0, end)\n+    }\n+\n     #[inline]\n     fn split_at(&self, mid: uint) -> (&'a [T], &'a [T]) {\n-        ((*self)[..mid], (*self)[mid..])\n+        (self.slice(0, mid), self.slice(mid, self.len()))\n     }\n \n     #[inline]\n@@ -344,21 +364,21 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn tail(&self) -> &'a [T] { (*self)[1..] }\n+    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n \n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n-    fn tailn(&self, n: uint) -> &'a [T] { (*self)[n..] }\n+    #[deprecated = \"use slice_from\"]\n+    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n \n     #[inline]\n     fn init(&self) -> &'a [T] {\n-        (*self)[..self.len() - 1]\n+        self.slice(0, self.len() - 1)\n     }\n \n     #[inline]\n-    #[deprecated = \"use slicing syntax but note the arguments are different\"]\n+    #[deprecated = \"use slice_to but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T] {\n-        (*self)[..self.len() - n]\n+        self.slice(0, self.len() - n)\n     }\n \n     #[inline]\n@@ -511,14 +531,13 @@ pub trait MutableSlice<'a, T> {\n     fn get_mut(self, index: uint) -> Option<&'a mut T>;\n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T, ..N].\n-    #[deprecated = \"use slicing syntax\"]\n     fn as_mut_slice(self) -> &'a mut [T];\n \n     /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slicing syntax\"]\n-    //fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n-    //    self[mut start..end]\n-    //}\n+    #[deprecated = \"use slice_mut\"]\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n+        self.slice_mut(start, end)\n+    }\n \n     /// Returns a mutable subslice spanning the interval [`start`, `end`).\n     ///\n@@ -527,35 +546,35 @@ pub trait MutableSlice<'a, T> {\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[unstable = \"waiting on final error conventions\"]\n-    //fn slice_mut(self, start: uint, end: uint) -> &'a mut [T];\n+    fn slice_mut(self, start: uint, end: uint) -> &'a mut [T];\n \n-    /// Deprecated: use `slicing syntax`.\n-    #[deprecated = \"use slicing syntax\"]\n-    //fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n-    //    self[mut start..]\n-    //}\n+    /// Deprecated: use `slice_from_mut`.\n+    #[deprecated = \"use slice_from_mut\"]\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n+        self.slice_from_mut(start)\n+    }\n \n     /// Returns a mutable subslice from `start` to the end of the slice.\n     ///\n     /// Fails when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[unstable = \"waiting on final error conventions\"]\n-    //fn slice_from_mut(self, start: uint) -> &'a mut [T];\n+    fn slice_from_mut(self, start: uint) -> &'a mut [T];\n \n-    /// Deprecated: use `slicing syntax`.\n-    #[deprecated = \"use slicing syntax\"]\n-    //fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n-    //    self[mut ..end]\n-    //}\n+    /// Deprecated: use `slice_to_mut`.\n+    #[deprecated = \"use slice_to_mut\"]\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n+        self.slice_to_mut(end)\n+    }\n \n     /// Returns a mutable subslice from the start of the slice to `end`.\n     ///\n     /// Fails when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[unstable = \"waiting on final error conventions\"]\n-    //fn slice_to_mut(self, end: uint) -> &'a mut [T];\n+    fn slice_to_mut(self, end: uint) -> &'a mut [T];\n \n     /// Deprecated: use `iter_mut`.\n     #[deprecated = \"use iter_mut\"]\n@@ -640,7 +659,7 @@ pub trait MutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let head = &mut self[0];\n-     *     *self = self[mut 1..];\n+     *     *self = self.slice_from_mut(1);\n      *     Some(head)\n      * ```\n      *\n@@ -659,7 +678,7 @@ pub trait MutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let tail = &mut self[self.len() - 1];\n-     *     *self = self[mut ..self.len() - 1];\n+     *     *self = self.slice_to_mut(self.len() - 1);\n      *     Some(tail)\n      * ```\n      *\n@@ -784,11 +803,34 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     #[inline]\n     fn as_mut_slice(self) -> &'a mut [T] { self }\n \n+    fn slice_mut(self, start: uint, end: uint) -> &'a mut [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_mut_ptr().offset(start as int) as *const T,\n+                    len: (end - start)\n+                })\n+        }\n+    }\n+\n+    #[inline]\n+    fn slice_from_mut(self, start: uint) -> &'a mut [T] {\n+        let len = self.len();\n+        self.slice_mut(start, len)\n+    }\n+\n+    #[inline]\n+    fn slice_to_mut(self, end: uint) -> &'a mut [T] {\n+        self.slice_mut(0, end)\n+    }\n+\n     #[inline]\n     fn split_at_mut(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n+            let len = self.len();\n             let self2: &'a mut [T] = mem::transmute_copy(&self);\n-            (self[mut ..mid], self2[mut mid..])\n+            (self.slice_mut(0, mid), self2.slice_mut(mid, len))\n         }\n     }\n \n@@ -978,13 +1020,13 @@ impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n     #[inline]\n     fn starts_with(&self, needle: &[T]) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle == (*self)[..n]\n+        self.len() >= n && needle == self.slice_to(n)\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &[T]) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == (*self)[m-n..]\n+        m >= n && needle == self.slice_from(m - n)\n     }\n }\n \n@@ -1257,8 +1299,8 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n         match self.v.iter().position(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v[..idx]);\n-                self.v = self.v[idx + 1..];\n+                let ret = Some(self.v.slice(0, idx));\n+                self.v = self.v.slice(idx + 1, self.v.len());\n                 ret\n             }\n         }\n@@ -1283,8 +1325,8 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v[idx + 1..]);\n-                self.v = self.v[..idx];\n+                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n+                self.v = self.v.slice(0, idx);\n                 ret\n             }\n         }\n@@ -1334,7 +1376,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n-                self.v = tail[mut 1..];\n+                self.v = tail.slice_from_mut(1);\n                 Some(head)\n             }\n         }\n@@ -1368,7 +1410,7 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n-                Some(tail[mut 1..])\n+                Some(tail.slice_from_mut(1))\n             }\n         }\n     }\n@@ -1416,8 +1458,8 @@ impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n         if self.size > self.v.len() {\n             None\n         } else {\n-            let ret = Some(self.v[..self.size]);\n-            self.v = self.v[1..];\n+            let ret = Some(self.v.slice(0, self.size));\n+            self.v = self.v.slice(1, self.v.len());\n             ret\n         }\n     }\n@@ -1501,7 +1543,7 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n             let mut hi = lo + self.size;\n             if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n \n-            Some(self.v[lo..hi])\n+            Some(self.v.slice(lo, hi))\n         } else {\n             None\n         }"}, {"sha": "fd7c63a6b3262c353f0e4b618c35a0d489cc24b9", "filename": "src/libcore/str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -30,7 +30,7 @@ use iter::range;\n use num::{CheckedMul, Saturating};\n use option::{Option, None, Some};\n use raw::Repr;\n-use slice::ImmutableSlice;\n+use slice::{ImmutableSlice, MutableSlice};\n use slice;\n use uint;\n \n@@ -393,7 +393,7 @@ impl NaiveSearcher {\n \n     fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n         while self.position + needle.len() <= haystack.len() {\n-            if haystack[self.position .. self.position + needle.len()] == needle {\n+            if haystack.slice(self.position, self.position + needle.len()) == needle {\n                 let match_pos = self.position;\n                 self.position += needle.len(); // add 1 for all matches\n                 return Some((match_pos, match_pos + needle.len()));\n@@ -514,10 +514,10 @@ impl TwoWaySearcher {\n         //\n         // What's going on is we have some critical factorization (u, v) of the\n         // needle, and we want to determine whether u is a suffix of\n-        // v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // v.slice_to(period). If it is, we use \"Algorithm CP1\". Otherwise we use\n         // \"Algorithm CP2\", which is optimized for when the period of the needle\n         // is large.\n-        if needle[..crit_pos] == needle[period.. period + crit_pos] {\n+        if needle.slice_to(crit_pos) == needle.slice(period, period + crit_pos) {\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n                 period: period,\n@@ -741,7 +741,7 @@ impl<'a> Iterator<u16> for Utf16CodeUnits<'a> {\n \n         let mut buf = [0u16, ..2];\n         self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(buf[mut]).unwrap_or(0);\n+            let n = ch.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n             if n == 2 { self.extra = buf[1]; }\n             buf[0]\n         })\n@@ -1007,7 +1007,7 @@ pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n         // don't include the 0\n-        Some(i) => v[..i],\n+        Some(i) => v.slice_to(i),\n         None => v\n     }\n }\n@@ -1994,13 +1994,13 @@ impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == self.as_bytes()[..n]\n+        self.len() >= n && needle.as_bytes() == self.as_bytes().slice_to(n)\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == self.as_bytes()[m-n..]\n+        m >= n && needle.as_bytes() == self.as_bytes().slice_from(m - n)\n     }\n \n     #[inline]"}, {"sha": "8c3f4706a3cc57109484f0fce7ad6e85e9c70b6a", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -174,7 +174,7 @@ fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8, ..4];\n         let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf[..n], expect);\n+        assert_eq!(buf.slice_to(n), expect);\n     }\n \n     check('x', [0x78]);\n@@ -188,7 +188,7 @@ fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16, ..2];\n         let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf[..n], expect);\n+        assert_eq!(buf.slice_to(n), expect);\n     }\n \n     check('x', [0x0078]);"}, {"sha": "1aaea19216264709b4cfe450edc9f58718e1a543", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -13,7 +13,6 @@ use core::iter::order::*;\n use core::uint;\n use core::cmp;\n use core::num;\n-use core::ops::Slice;\n \n use test::Bencher;\n \n@@ -229,7 +228,7 @@ fn test_inspect() {\n                .collect::<Vec<uint>>();\n \n     assert_eq!(n, xs.len());\n-    assert_eq!(xs[], ys[]);\n+    assert_eq!(xs.as_slice(), ys.as_slice());\n }\n \n #[test]\n@@ -269,7 +268,7 @@ fn test_cycle() {\n \n #[test]\n fn test_iterator_nth() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4];\n+    let v = &[0i, 1, 2, 3, 4];\n     for i in range(0u, v.len()) {\n         assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n     }\n@@ -278,55 +277,55 @@ fn test_iterator_nth() {\n \n #[test]\n fn test_iterator_last() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4];\n+    let v = &[0i, 1, 2, 3, 4];\n     assert_eq!(v.iter().last().unwrap(), &4);\n-    assert_eq!(v[0..1].iter().last().unwrap(), &0);\n+    assert_eq!(v.slice(0, 1).iter().last().unwrap(), &0);\n }\n \n #[test]\n fn test_iterator_len() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().count(), 4);\n-    assert_eq!(v[0..10].iter().count(), 10);\n-    assert_eq!(v[0..0].iter().count(), 0);\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().count(), 4);\n+    assert_eq!(v.slice(0, 10).iter().count(), 10);\n+    assert_eq!(v.slice(0, 0).iter().count(), 0);\n }\n \n #[test]\n fn test_iterator_sum() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).sum(), 6);\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).sum(), 6);\n     assert_eq!(v.iter().map(|&x| x).sum(), 55);\n-    assert_eq!(v[0..0].iter().map(|&x| x).sum(), 0);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).sum(), 0);\n }\n \n #[test]\n fn test_iterator_product() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).product(), 0);\n-    assert_eq!(v[1..5].iter().map(|&x| x).product(), 24);\n-    assert_eq!(v[0..0].iter().map(|&x| x).product(), 1);\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).product(), 0);\n+    assert_eq!(v.slice(1, 5).iter().map(|&x| x).product(), 24);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).product(), 1);\n }\n \n #[test]\n fn test_iterator_max() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).max(), Some(3));\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).max(), Some(3));\n     assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n-    assert_eq!(v[0..0].iter().map(|&x| x).max(), None);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).max(), None);\n }\n \n #[test]\n fn test_iterator_min() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).min(), Some(0));\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).min(), Some(0));\n     assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n-    assert_eq!(v[0..0].iter().map(|&x| x).min(), None);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).min(), None);\n }\n \n #[test]\n fn test_iterator_size_hint() {\n     let c = count(0i, 1);\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let v2 = &[10i, 11, 12];\n     let vi = v.iter();\n \n@@ -373,7 +372,7 @@ fn test_all() {\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n-    assert!(v.slice_(&0, &0).iter().all(|_| fail!()));\n+    assert!(v.slice(0, 0).iter().all(|_| fail!()));\n }\n \n #[test]\n@@ -382,7 +381,7 @@ fn test_any() {\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n-    assert!(!v.slice_(&0, &0).iter().any(|_| fail!()));\n+    assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n }\n \n #[test]\n@@ -567,7 +566,7 @@ fn check_randacc_iter<A: PartialEq, T: Clone + RandomAccessIterator<A>>(a: T, le\n fn test_double_ended_flat_map() {\n     let u = [0u,1];\n     let v = [5u,6,7,8];\n-    let mut it = u.iter().flat_map(|x| v[*x..v.len()].iter());\n+    let mut it = u.iter().flat_map(|x| v.slice(*x, v.len()).iter());\n     assert_eq!(it.next_back().unwrap(), &8);\n     assert_eq!(it.next().unwrap(),      &5);\n     assert_eq!(it.next_back().unwrap(), &7);"}, {"sha": "419748b75c324c56f47a736ce2942ca035f8a4d4", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -1012,7 +1012,7 @@ pub fn write<T>(fd: sock_t,\n             // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n             // against unforeseen circumstances.\n             let _guard = lock();\n-            let ptr = buf[written..].as_ptr();\n+            let ptr = buf.slice_from(written).as_ptr();\n             let len = buf.len() - written;\n             match retry(|| write(deadline.is_some(), ptr, len)) {\n                 -1 if util::wouldblock() => {}"}, {"sha": "efa3402073f2eff827a091aae9f24487b3f50a8e", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -735,7 +735,7 @@ impl BigUint {\n         let mut power: BigUint  = One::one();\n         loop {\n             let start = cmp::max(end, unit_len) - unit_len;\n-            match uint::parse_bytes(buf[start..end], radix) {\n+            match uint::parse_bytes(buf.slice(start, end), radix) {\n                 Some(d) => {\n                     let d: Option<BigUint> = FromPrimitive::from_uint(d);\n                     match d {\n@@ -1406,7 +1406,7 @@ impl BigInt {\n             sign  = Minus;\n             start = 1;\n         }\n-        return BigUint::parse_bytes(buf[start..], radix)\n+        return BigUint::parse_bytes(buf.slice(start, buf.len()), radix)\n             .map(|bu| BigInt::from_biguint(sign, bu));\n     }\n "}, {"sha": "f8a775478f1f85b88b63454322a5559dd4f2fff9", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -228,7 +228,7 @@ pub trait Rng {\n     /// let choices = [1i, 2, 4, 8, 16, 32];\n     /// let mut rng = task_rng();\n     /// println!(\"{}\", rng.choose(choices));\n-    /// assert_eq!(rng.choose(choices[..0]), None);\n+    /// assert_eq!(rng.choose(choices.slice_to(0)), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {"}, {"sha": "648aa8668144b22610d082ff0d81545c5a769ce8", "filename": "src/librbml/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -94,15 +94,15 @@ impl Writer for SeekableMemWriter {\n             // there (left), and what will be appended on the end (right)\n             let cap = self.buf.len() - self.pos;\n             let (left, right) = if cap <= buf.len() {\n-                (buf[..cap], buf[cap..])\n+                (buf.slice_to(cap), buf.slice_from(cap))\n             } else {\n                 let result: (_, &[_]) = (buf, &[]);\n                 result\n             };\n \n             // Do the necessary writes\n             if left.len() > 0 {\n-                slice::bytes::copy_memory(self.buf[mut self.pos..], left);\n+                slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), left);\n             }\n             if right.len() > 0 {\n                 self.buf.push_all(right);"}, {"sha": "6171a9946b6085702a0328a00074b91c0bdf0660", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -54,7 +54,7 @@ impl<'doc> Doc<'doc> {\n     }\n \n     pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-        str::from_utf8(self.data[self.start..self.end]).unwrap()\n+        str::from_utf8(self.data.slice(self.start, self.end)).unwrap()\n     }\n \n     pub fn as_str(&self) -> String {\n@@ -280,7 +280,7 @@ pub mod reader {\n     }\n \n     pub fn with_doc_data<'a, T>(d: Doc<'a>, f: |x: &'a [u8]| -> T) -> T {\n-        f(d.data[d.start..d.end])\n+        f(d.data.slice(d.start, d.end))\n     }\n \n "}, {"sha": "c3e195af6f90ff896db5997271f90e1f6171fbca", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -102,7 +102,7 @@ impl Program {\n         // This is a bit hacky since we have to skip over the initial\n         // 'Save' instruction.\n         let mut pre = String::with_capacity(5);\n-        for inst in c.insts[1..].iter() {\n+        for inst in c.insts.slice_from(1).iter() {\n             match *inst {\n                 OneChar(c, FLAG_EMPTY) => pre.push(c),\n                 _ => break"}, {"sha": "7f4289b128afeac769bd047362fef6bd2d72a0d2", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -511,7 +511,7 @@ impl<'a> Parser<'a> {\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n         let inner = String::from_chars(\n-            self.chars[start+1..closer]);\n+            self.chars.as_slice().slice(start + 1, closer));\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n@@ -944,7 +944,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        String::from_chars(self.chars[start..end])\n+        String::from_chars(self.chars.as_slice().slice(start, end))\n     }\n }\n "}, {"sha": "48065992bb050f525dd7133f54402f23d8546f5c", "filename": "src/libregex/test/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -130,7 +130,7 @@ macro_rules! mat(\n             // actual capture groups to match test set.\n             let (sexpect, mut sgot) = (expected.as_slice(), got.as_slice());\n             if sgot.len() > sexpect.len() {\n-                sgot = sgot[0..sexpect.len()]\n+                sgot = sgot.slice(0, sexpect.len())\n             }\n             if sexpect != sgot {\n                 fail!(\"For RE '{}' against '{}', expected '{}' but got '{}'\","}, {"sha": "085975580b7579865164037b03294c385419114f", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -145,7 +145,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                 // out early.\n                 if self.prog.prefix.len() > 0 && clist.size == 0 {\n                     let needle = self.prog.prefix.as_slice().as_bytes();\n-                    let haystack = self.input.as_bytes()[self.ic..];\n+                    let haystack = self.input.as_bytes().slice_from(self.ic);\n                     match find_prefix(needle, haystack) {\n                         None => break,\n                         Some(i) => {"}, {"sha": "cc6a8e27cda4aa727bd02e922682958c69549c8a", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -550,7 +550,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n         } else {\n             quote_expr!(self.cx,\n                 if clist.size == 0 {\n-                    let haystack = self.input.as_bytes()[self.ic..];\n+                    let haystack = self.input.as_bytes().slice_from(self.ic);\n                     match find_prefix(prefix_bytes, haystack) {\n                         None => break,\n                         Some(i) => {"}, {"sha": "cd425b5fec170fafad637280fd6c4ffe5c23faed", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -89,9 +89,9 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     if version == 1 {\n                         // The only version existing so far\n                         let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n-                        let compressed_data = bc_encoded[\n-                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n-                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint];\n+                        let compressed_data = bc_encoded.slice(\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET,\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint);\n \n                         match flate::inflate_bytes(compressed_data) {\n                             Some(inflated) => inflated,\n@@ -188,7 +188,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n     let magic_id_byte_count = link::RLIB_BYTECODE_OBJECT_MAGIC.len();\n     return bc.len() > magic_id_byte_count &&\n-           bc[..magic_id_byte_count] == link::RLIB_BYTECODE_OBJECT_MAGIC;\n+           bc.slice(0, magic_id_byte_count) == link::RLIB_BYTECODE_OBJECT_MAGIC;\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n@@ -200,8 +200,8 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n }\n \n fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n-    let byte_data = bytes[position_in_bytes..\n-                          position_in_bytes + mem::size_of::<T>()];\n+    let byte_data = bytes.slice(position_in_bytes,\n+                                position_in_bytes + mem::size_of::<T>());\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)\n     };"}, {"sha": "6d4407f96a7a444bc4c7fd6867e864b3bf59c9c1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -70,7 +70,7 @@ fn lookup_hash<'a>(d: rbml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n-        if eq_fn(elt.data[elt.start + 4 .. elt.end]) {\n+        if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n         } else {\n@@ -84,7 +84,7 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n-            bytes[0u..4u], 0u, 4u) as ast::NodeId\n+            bytes.slice(0u, 4u), 0u, 4u) as ast::NodeId\n             == item_id;\n     }\n     lookup_hash(items,"}, {"sha": "d319559044c4c171e9766142442a4371a2832114", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -91,7 +91,7 @@ fn scan<R>(st: &mut PState, is_last: |char| -> bool, op: |&[u8]| -> R) -> R {\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n-    return op(st.data[start_pos..end_pos]);\n+    return op(st.data.slice(start_pos, end_pos));\n }\n \n pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n@@ -599,8 +599,8 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n         fail!();\n     }\n \n-    let crate_part = buf[0u..colon_idx];\n-    let def_part = buf[colon_idx + 1u..len];\n+    let crate_part = buf.slice(0u, colon_idx);\n+    let def_part = buf.slice(colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as ast::CrateNum,"}, {"sha": "de9125ec44918419319650d7fac240e9a0c44f74", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -870,7 +870,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             None\n         }\n     };\n-    head.map(|head| head.append(r[..col]).append(r[col + 1..]))\n+    head.map(|head| head.append(r.slice_to(col)).append(r.slice_from(col + 1)))\n }\n \n fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {"}, {"sha": "42a98be0fb84e1a93db2f5d78c88128b3bd42133", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -4014,7 +4014,7 @@ impl<'a> Resolver<'a> {\n         for (i, rib) in ribs.iter().enumerate().rev() {\n             match rib.bindings.find_copy(&name) {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs[i + 1..], def_like, span);\n+                    return self.upvarify(ribs.slice_from(i + 1), def_like, span);\n                 }\n                 None => {\n                     // Continue."}, {"sha": "c956c2d2b006b9bd6a26a0ec72e8a9dcd454ebec", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -193,7 +193,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = sub_paths[..len-2];\n+        let sub_paths = sub_paths.slice(0, len-2);\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,"}, {"sha": "68d0bb2d8b49805220a6e796172a7d989c31eed6", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -473,7 +473,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n-            Some(Vec::from_slice(pats[..col]).append(pats[col + 1..]))\n+            Some(Vec::from_slice(pats.slice_to(col)).append(pats.slice_from(col + 1)))\n         } else {\n             None\n         }\n@@ -949,7 +949,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = compile_guard(bcx,\n                                     &**guard_expr,\n                                     m[0].data,\n-                                    m[1..m.len()],\n+                                    m.slice(1, m.len()),\n                                     vals,\n                                     chk,\n                                     has_genuine_default);\n@@ -988,7 +988,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n \n-    let vals_left = Vec::from_slice(vals[0u..col]).append(vals[col + 1u..vals.len()]);\n+    let vals_left = Vec::from_slice(vals.slice(0u, col)).append(vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but"}, {"sha": "e95f640b4486949a9259d07038c8fa19e51ff680", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -550,7 +550,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n-            self.inbounds_gep(base, small_vec[..ixs.len()])\n+            self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");"}, {"sha": "aada90d260e8f2f2b283d44907a78ef714b73235", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -931,7 +931,7 @@ pub fn create_captured_var_metadata(bcx: Block,\n \n     let variable_access = IndirectVariable {\n         alloca: env_pointer,\n-        address_operations: address_operations[..address_op_count]\n+        address_operations: address_operations.slice_to(address_op_count)\n     };\n \n     declare_local(bcx,"}, {"sha": "fa68814ea16fce997370a66af50fa7bd47e438cd", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -330,7 +330,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n         }\n     }\n \n-    for param in ty_param_defs[supplied_ty_param_count..].iter() {\n+    for param in ty_param_defs.slice_from(supplied_ty_param_count).iter() {\n         match param.default {\n             Some(default) => {\n                 // This is a default type parameter."}, {"sha": "c0bb6bb3c6096bfeb580f4f4df8c0f23efc3155a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -3032,7 +3032,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         // Call the generic checker.\n-        let args: Vec<_> = args[1..].iter().map(|x| x).collect();\n+        let args: Vec<_> = args.slice_from(1).iter().map(|x| x).collect();\n         let ret_ty = check_method_argument_types(fcx,\n                                                  method_name.span,\n                                                  fn_ty,"}, {"sha": "638aea10e37952fa1bc9306ffce827e83d27b6db", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -490,7 +490,7 @@ pub fn parameterized(cx: &ctxt,\n         0\n     };\n \n-    for t in tps[..tps.len() - num_defaults].iter() {\n+    for t in tps.slice_to(tps.len() - num_defaults).iter() {\n         strs.push(ty_to_string(cx, *t))\n     }\n "}, {"sha": "8f3dd18c69c59c03a1ab33bdb43efc656da9311d", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -136,14 +136,14 @@ impl FixedBuffer for FixedBuffer64 {\n             let buffer_remaining = size - self.buffer_idx;\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n-                        self.buffer[mut self.buffer_idx..size],\n-                        input[..buffer_remaining]);\n+                        self.buffer.slice_mut(self.buffer_idx, size),\n+                        input.slice_to(buffer_remaining));\n                 self.buffer_idx = 0;\n                 func(self.buffer);\n                 i += buffer_remaining;\n             } else {\n                 copy_memory(\n-                    self.buffer[mut self.buffer_idx..self.buffer_idx + input.len()],\n+                    self.buffer.slice_mut(self.buffer_idx, self.buffer_idx + input.len()),\n                     input);\n                 self.buffer_idx += input.len();\n                 return;\n@@ -153,7 +153,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // While we have at least a full buffer size chunk's worth of data, process that data\n         // without copying it into the buffer\n         while input.len() - i >= size {\n-            func(input[i..i + size]);\n+            func(input.slice(i, i + size));\n             i += size;\n         }\n \n@@ -162,8 +162,8 @@ impl FixedBuffer for FixedBuffer64 {\n         // be empty.\n         let input_remaining = input.len() - i;\n         copy_memory(\n-            self.buffer[mut ..input_remaining],\n-            input[i..]);\n+            self.buffer.slice_mut(0, input_remaining),\n+            input.slice_from(i));\n         self.buffer_idx += input_remaining;\n     }\n \n@@ -173,19 +173,19 @@ impl FixedBuffer for FixedBuffer64 {\n \n     fn zero_until(&mut self, idx: uint) {\n         assert!(idx >= self.buffer_idx);\n-        self.buffer[mut self.buffer_idx..idx].set_memory(0);\n+        self.buffer.slice_mut(self.buffer_idx, idx).set_memory(0);\n         self.buffer_idx = idx;\n     }\n \n     fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n         self.buffer_idx += len;\n-        return self.buffer[mut self.buffer_idx - len..self.buffer_idx];\n+        return self.buffer.slice_mut(self.buffer_idx - len, self.buffer_idx);\n     }\n \n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n         assert!(self.buffer_idx == 64);\n         self.buffer_idx = 0;\n-        return self.buffer[..64];\n+        return self.buffer.slice_to(64);\n     }\n \n     fn position(&self) -> uint { self.buffer_idx }\n@@ -359,7 +359,7 @@ impl Engine256State {\n              )\n         )\n \n-        read_u32v_be(w[mut 0..16], data);\n+        read_u32v_be(w.slice_mut(0, 16), data);\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n@@ -495,14 +495,14 @@ impl Digest for Sha256 {\n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        write_u32_be(out[mut 0..4], self.engine.state.h0);\n-        write_u32_be(out[mut 4..8], self.engine.state.h1);\n-        write_u32_be(out[mut 8..12], self.engine.state.h2);\n-        write_u32_be(out[mut 12..16], self.engine.state.h3);\n-        write_u32_be(out[mut 16..20], self.engine.state.h4);\n-        write_u32_be(out[mut 20..24], self.engine.state.h5);\n-        write_u32_be(out[mut 24..28], self.engine.state.h6);\n-        write_u32_be(out[mut 28..32], self.engine.state.h7);\n+        write_u32_be(out.slice_mut(0, 4), self.engine.state.h0);\n+        write_u32_be(out.slice_mut(4, 8), self.engine.state.h1);\n+        write_u32_be(out.slice_mut(8, 12), self.engine.state.h2);\n+        write_u32_be(out.slice_mut(12, 16), self.engine.state.h3);\n+        write_u32_be(out.slice_mut(16, 20), self.engine.state.h4);\n+        write_u32_be(out.slice_mut(20, 24), self.engine.state.h5);\n+        write_u32_be(out.slice_mut(24, 28), self.engine.state.h6);\n+        write_u32_be(out.slice_mut(28, 32), self.engine.state.h7);\n     }\n \n     fn reset(&mut self) {"}, {"sha": "054fbda73379c2b7c9bc421eeb8c62aafa4cf716", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -698,7 +698,7 @@ impl Clean<Item> for ast::Method {\n         let all_inputs = &self.pe_fn_decl().inputs;\n         let inputs = match self.pe_explicit_self().node {\n             ast::SelfStatic => all_inputs.as_slice(),\n-            _ => all_inputs[1..]\n+            _ => all_inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -737,7 +737,7 @@ impl Clean<Item> for ast::TypeMethod {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => self.decl.inputs.as_slice(),\n-            _ => self.decl.inputs[1..]\n+            _ => self.decl.inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -1009,7 +1009,7 @@ impl Clean<Item> for ty::Method {\n                                                self.fty.sig.clone()),\n             s => {\n                 let sig = ty::FnSig {\n-                    inputs: self.fty.sig.inputs[1..].to_vec(),\n+                    inputs: self.fty.sig.inputs.slice_from(1).to_vec(),\n                     ..self.fty.sig.clone()\n                 };\n                 let s = match s {"}, {"sha": "947d9f05ae2bba0cdc0915b0547ffd36cf809488", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -249,7 +249,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         match rel_root {\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n-                for seg in path.segments[..amt].iter() {\n+                for seg in path.segments.slice_to(amt).iter() {\n                     if \"super\" == seg.name.as_slice() ||\n                             \"self\" == seg.name.as_slice() {\n                         try!(write!(w, \"{}::\", seg.name));\n@@ -264,7 +264,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n                 }\n             }\n             None => {\n-                for seg in path.segments[..amt].iter() {\n+                for seg in path.segments.slice_to(amt).iter() {\n                     try!(write!(w, \"{}::\", seg.name));\n                 }\n             }\n@@ -275,7 +275,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         // This is a documented path, link to it!\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n             let mut url = String::from_str(abs_root.unwrap().as_slice());\n-            let to_link = fqp[..fqp.len() - 1];\n+            let to_link = fqp.slice_to(fqp.len() - 1);\n             for component in to_link.iter() {\n                 url.push_str(component.as_slice());\n                 url.push_str(\"/\");"}, {"sha": "8668e684c2d643bf01105798478398338a4af720", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -394,7 +394,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n                     search_index.push(IndexItem {\n                         ty: shortty(item),\n                         name: item.name.clone().unwrap(),\n-                        path: fqp[..fqp.len() - 1].connect(\"::\"),\n+                        path: fqp.slice_to(fqp.len() - 1).connect(\"::\"),\n                         desc: shorter(item.doc_value()).to_string(),\n                         parent: Some(did),\n                     });\n@@ -549,7 +549,7 @@ fn write_shared(cx: &Context,\n         };\n \n         let mut mydst = dst.clone();\n-        for part in remote_path[..remote_path.len() - 1].iter() {\n+        for part in remote_path.slice_to(remote_path.len() - 1).iter() {\n             mydst.push(part.as_slice());\n             try!(mkdir(&mydst));\n         }\n@@ -829,7 +829,7 @@ impl DocFolder for Cache {\n                     clean::StructFieldItem(..) |\n                     clean::VariantItem(..) => {\n                         ((Some(*self.parent_stack.last().unwrap()),\n-                          Some(self.stack[..self.stack.len() - 1])),\n+                          Some(self.stack.slice_to(self.stack.len() - 1))),\n                           false)\n                     }\n                     clean::MethodItem(..) => {\n@@ -840,13 +840,13 @@ impl DocFolder for Cache {\n                             let did = *last;\n                             let path = match self.paths.find(&did) {\n                                 Some(&(_, item_type::Trait)) =>\n-                                    Some(self.stack[..self.stack.len() - 1]),\n+                                    Some(self.stack.slice_to(self.stack.len() - 1)),\n                                 // The current stack not necessarily has correlation for\n                                 // where the type was defined. On the other hand,\n                                 // `paths` always has the right information if present.\n                                 Some(&(ref fqp, item_type::Struct)) |\n                                 Some(&(ref fqp, item_type::Enum)) =>\n-                                    Some(fqp[..fqp.len() - 1]),\n+                                    Some(fqp.slice_to(fqp.len() - 1)),\n                                 Some(..) => Some(self.stack.as_slice()),\n                                 None => None\n                             };\n@@ -1172,7 +1172,7 @@ impl Context {\n                 let mut url = \"../\".repeat(cx.current.len());\n                 match cache_key.get().unwrap().paths.find(&it.def_id) {\n                     Some(&(ref names, _)) => {\n-                        for name in names[..names.len() - 1].iter() {\n+                        for name in names.slice_to(names.len() - 1).iter() {\n                             url.push_str(name.as_slice());\n                             url.push_str(\"/\");\n                         }"}, {"sha": "1561f428ce5484f84a13ebee6b7ead3c5e5b7c04", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -562,7 +562,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n     let callbacks = unsafe {\n         let amt = CALLBACK_CNT.load(atomic::SeqCst);\n-        CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n+        CALLBACKS.slice_to(cmp::min(amt, MAX_CALLBACKS))\n     };\n     for cb in callbacks.iter() {\n         match cb.load(atomic::SeqCst) {"}, {"sha": "77e3e25eb0e7e9e60d310f6e6bf943f46cd6460c", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -62,8 +62,8 @@ pub fn abort(args: &fmt::Arguments) -> ! {\n     }\n     impl<'a> FormatWriter for BufWriter<'a> {\n         fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-            let left = self.buf[mut self.pos..];\n-            let to_write = bytes[..cmp::min(bytes.len(), left.len())];\n+            let left = self.buf.slice_from_mut(self.pos);\n+            let to_write = bytes.slice_to(cmp::min(bytes.len(), left.len()));\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();\n             Ok(())\n@@ -74,7 +74,7 @@ pub fn abort(args: &fmt::Arguments) -> ! {\n     let mut msg = [0u8, ..512];\n     let mut w = BufWriter { buf: msg, pos: 0 };\n     let _ = write!(&mut w, \"{}\", args);\n-    let msg = str::from_utf8(w.buf[mut ..w.pos]).unwrap_or(\"aborted\");\n+    let msg = str::from_utf8(w.buf.slice_to(w.pos)).unwrap_or(\"aborted\");\n     let msg = if msg.is_empty() {\"aborted\"} else {msg};\n \n     // Give some context to the message"}, {"sha": "3007e160bf8ae536078e643e20078dfb273901d0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -334,7 +334,7 @@ pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError\n         };\n \n         if start < i {\n-            try!(wr.write(bytes[start..i]));\n+            try!(wr.write(bytes.slice(start, i)));\n         }\n \n         try!(wr.write_str(escaped));\n@@ -343,7 +343,7 @@ pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError\n     }\n \n     if start != bytes.len() {\n-        try!(wr.write(bytes[start..]));\n+        try!(wr.write(bytes.slice_from(start)));\n     }\n \n     wr.write_str(\"\\\"\")\n@@ -369,7 +369,7 @@ fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n     }\n \n     if n > 0 {\n-        wr.write(buf[..n])\n+        wr.write(buf.slice_to(n))\n     } else {\n         Ok(())\n     }\n@@ -1149,7 +1149,7 @@ impl Stack {\n             InternalIndex(i) => { Index(i) }\n             InternalKey(start, size) => {\n                 Key(str::from_utf8(\n-                    self.str_buffer[start as uint .. start as uint + size as uint]).unwrap())\n+                    self.str_buffer.slice(start as uint, start as uint + size as uint)).unwrap())\n             }\n         }\n     }\n@@ -1191,7 +1191,7 @@ impl Stack {\n             Some(&InternalIndex(i)) => Some(Index(i)),\n             Some(&InternalKey(start, size)) => {\n                 Some(Key(str::from_utf8(\n-                    self.str_buffer[start as uint .. (start+size) as uint]\n+                    self.str_buffer.slice(start as uint, (start+size) as uint)\n                 ).unwrap()))\n             }\n         }"}, {"sha": "d9543a06b350c83e385fa91401cff37c8ea571ac", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -90,10 +90,10 @@ impl<R: Reader> BufferedReader<R> {\n impl<R: Reader> Buffer for BufferedReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos == self.cap {\n-            self.cap = try!(self.inner.read(self.buf[mut]));\n+            self.cap = try!(self.inner.read(self.buf.as_mut_slice()));\n             self.pos = 0;\n         }\n-        Ok(self.buf[self.pos..self.cap])\n+        Ok(self.buf.slice(self.pos, self.cap))\n     }\n \n     fn consume(&mut self, amt: uint) {\n@@ -107,7 +107,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n         let nread = {\n             let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(buf, available[..nread]);\n+            slice::bytes::copy_memory(buf, available.slice_to(nread));\n             nread\n         };\n         self.pos += nread;\n@@ -162,7 +162,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write(self.buf[..self.pos]);\n+            let ret = self.inner.as_mut().unwrap().write(self.buf.slice_to(self.pos));\n             self.pos = 0;\n             ret\n         } else {\n@@ -195,7 +195,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n         if buf.len() > self.buf.len() {\n             self.inner.as_mut().unwrap().write(buf)\n         } else {\n-            let dst = self.buf[mut self.pos..];\n+            let dst = self.buf.slice_from_mut(self.pos);\n             slice::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n             Ok(())\n@@ -250,9 +250,9 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n-                try!(self.inner.write(buf[..i + 1]));\n+                try!(self.inner.write(buf.slice_to(i + 1)));\n                 try!(self.inner.flush());\n-                try!(self.inner.write(buf[i + 1..]));\n+                try!(self.inner.write(buf.slice_from(i + 1)));\n                 Ok(())\n             }\n             None => self.inner.write(buf),"}, {"sha": "0a969fc37c924aa6dc01c82ce0f4f39f47ad8d27", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -15,7 +15,8 @@ use comm::{Sender, Receiver};\n use io;\n use option::{None, Option, Some};\n use result::{Ok, Err};\n-use slice::{bytes, CloneableVector};\n+use slice::{bytes, MutableSlice, ImmutableSlice, CloneableVector};\n+use str::StrSlice;\n use super::{Reader, Writer, IoResult};\n use vec::Vec;\n \n@@ -61,10 +62,10 @@ impl Reader for ChanReader {\n         loop {\n             match self.buf {\n                 Some(ref prev) => {\n-                    let dst = buf[mut num_read..];\n-                    let src = prev[self.pos..];\n+                    let dst = buf.slice_from_mut(num_read);\n+                    let src = prev.slice_from(self.pos);\n                     let count = cmp::min(dst.len(), src.len());\n-                    bytes::copy_memory(dst, src[..count]);\n+                    bytes::copy_memory(dst, src.slice_to(count));\n                     num_read += count;\n                     self.pos += count;\n                 },"}, {"sha": "f777460e66a4538dca42541e3d238ae7314481d5", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -485,7 +485,7 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => { break }\n             Err(e) => return update_err(Err(e), from, to)\n         };\n-        try!(writer.write(buf[..amt]));\n+        try!(writer.write(buf.slice_to(amt)));\n     }\n \n     chmod(to, try!(update_err(from.stat(), from, to)).perm)\n@@ -1014,7 +1014,7 @@ mod test {\n             let mut read_buf = [0, .. 1028];\n             let read_str = match check!(read_stream.read(read_buf)) {\n                 -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf[..n]).unwrap().to_string()\n+                n => str::from_utf8(read_buf.slice_to(n)).unwrap().to_string()\n             };\n             assert_eq!(read_str.as_slice(), message);\n         }\n@@ -1061,11 +1061,11 @@ mod test {\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             {\n-                let read_buf = read_mem[mut 0..4];\n+                let read_buf = read_mem.slice_mut(0, 4);\n                 check!(read_stream.read(read_buf));\n             }\n             {\n-                let read_buf = read_mem[mut 4..8];\n+                let read_buf = read_mem.slice_mut(4, 8);\n                 check!(read_stream.read(read_buf));\n             }\n         }"}, {"sha": "c826bd16715d6618f3c6f6d422702c676d563278", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -19,7 +19,7 @@ use result::{Err, Ok};\n use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice;\n-use slice::Slice;\n+use slice::{Slice, ImmutableSlice, MutableSlice};\n use vec::Vec;\n \n static BUF_CAPACITY: uint = 128;\n@@ -146,8 +146,8 @@ impl Reader for MemReader {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf[self.pos.. self.pos + write_len];\n-            let output = buf[mut ..write_len];\n+            let input = self.buf.slice(self.pos, self.pos + write_len);\n+            let output = buf.slice_mut(0, write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -174,7 +174,7 @@ impl Buffer for MemReader {\n     #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf[self.pos..])\n+            Ok(self.buf.slice_from(self.pos))\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -232,7 +232,7 @@ impl<'a> Writer for BufWriter<'a> {\n             })\n         }\n \n-        slice::bytes::copy_memory(self.buf[mut self.pos..], buf);\n+        slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), buf);\n         self.pos += buf.len();\n         Ok(())\n     }\n@@ -292,8 +292,8 @@ impl<'a> Reader for BufReader<'a> {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf[self.pos.. self.pos + write_len];\n-            let output = buf[mut ..write_len];\n+            let input = self.buf.slice(self.pos, self.pos + write_len);\n+            let output = buf.slice_mut(0, write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -320,7 +320,7 @@ impl<'a> Buffer for BufReader<'a> {\n     #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf[self.pos..])\n+            Ok(self.buf.slice_from(self.pos))\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -427,7 +427,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf[0..3], b);\n+        assert_eq!(buf.slice(0, 3), b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -454,7 +454,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf[0..3], b);\n+        assert_eq!(buf.slice(0, 3), b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -548,7 +548,7 @@ mod test {\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n         let b: &[_] = &[1, 2, 3];\n         assert_eq!(buf.as_slice(), b);\n-        assert!(r.read_at_least(0, buf[mut ..0]).is_ok());\n+        assert!(r.read_at_least(0, buf.slice_to_mut(0)).is_ok());\n         assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n         let b: &[_] = &[4, 5, 6];"}, {"sha": "b929e7c464df02f0f2e83a09728011ad9353fa0d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -235,7 +235,7 @@ use os;\n use boxed::Box;\n use result::{Ok, Err, Result};\n use rt::rtio;\n-use slice::{Slice, ImmutableSlice};\n+use slice::{Slice, MutableSlice, ImmutableSlice};\n use str::{Str, StrSlice};\n use str;\n use string::String;\n@@ -575,7 +575,7 @@ pub trait Reader {\n         while read < min {\n             let mut zeroes = 0;\n             loop {\n-                match self.read(buf[mut read..]) {\n+                match self.read(buf.slice_from_mut(read)) {\n                     Ok(0) => {\n                         zeroes += 1;\n                         if zeroes >= NO_PROGRESS_LIMIT {\n@@ -1111,8 +1111,8 @@ pub trait Writer {\n     #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8, ..4];\n-        let n = c.encode_utf8(buf[mut]).unwrap_or(0);\n-        self.write(buf[..n])\n+        let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n+        self.write(buf.slice_to(n))\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n@@ -1496,7 +1496,7 @@ pub trait Buffer: Reader {\n                 };\n                 match available.iter().position(|&b| b == byte) {\n                     Some(i) => {\n-                        res.push_all(available[..i + 1]);\n+                        res.push_all(available.slice_to(i + 1));\n                         used = i + 1;\n                         break\n                     }\n@@ -1528,14 +1528,14 @@ pub trait Buffer: Reader {\n         {\n             let mut start = 1;\n             while start < width {\n-                match try!(self.read(buf[mut start..width])) {\n+                match try!(self.read(buf.slice_mut(start, width))) {\n                     n if n == width - start => break,\n                     n if n < width - start => { start += n; }\n                     _ => return Err(standard_error(InvalidInput)),\n                 }\n             }\n         }\n-        match str::from_utf8(buf[..width]) {\n+        match str::from_utf8(buf.slice_to(width)) {\n             Some(s) => Ok(s.char_at(0)),\n             None => Err(standard_error(InvalidInput))\n         }"}, {"sha": "6eb7d1c02fbc7b47942a4fdcd90ce8b4fd11900f", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -21,7 +21,7 @@ use from_str::FromStr;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str::StrSlice;\n-use slice::{MutableCloneableSlice, MutableSlice};\n+use slice::{MutableCloneableSlice, ImmutableSlice, MutableSlice};\n \n pub type Port = u16;\n \n@@ -241,7 +241,7 @@ impl<'a> Parser<'a> {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0u16, ..8];\n             gs.clone_from_slice(head);\n-            gs[mut 8 - tail.len() .. 8].clone_from_slice(tail);\n+            gs.slice_mut(8 - tail.len(), 8).clone_from_slice(tail);\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n \n@@ -303,7 +303,7 @@ impl<'a> Parser<'a> {\n \n         let mut tail = [0u16, ..8];\n         let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n-        Some(ipv6_addr_from_head_tail(head[..head_size], tail[..tail_size]))\n+        Some(ipv6_addr_from_head_tail(head.slice(0, head_size), tail.slice(0, tail_size)))\n     }\n \n     fn read_ipv6_addr(&mut self) -> Option<IpAddr> {"}, {"sha": "3ba8765fc3e215cf7797fc0b544c88eff32e2a8c", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -48,7 +48,7 @@ use rt::rtio;\n /// match socket.recv_from(buf) {\n ///     Ok((amt, src)) => {\n ///         // Send a reply to the socket we received data from\n-///         let buf = buf[mut ..amt];\n+///         let buf = buf.slice_to_mut(amt);\n ///         buf.reverse();\n ///         socket.send_to(buf, src);\n ///     }"}, {"sha": "16ac8c4c265fe09ce7c2edc16de233bd85bd63c5", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -47,7 +47,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n-        let res = self.inner.read(buf[mut ..len]);\n+        let res = self.inner.read(buf.slice_to_mut(len));\n         match res {\n             Ok(len) => self.limit -= len,\n             _ => {}\n@@ -59,7 +59,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n impl<R: Buffer> Buffer for LimitReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n         let amt = try!(self.inner.fill_buf());\n-        let buf = amt[..cmp::min(amt.len(), self.limit)];\n+        let buf = amt.slice_to(cmp::min(amt.len(), self.limit));\n         if buf.len() == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n@@ -216,7 +216,7 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n-            self.writer.write(buf[mut ..len]).map(|()| len)\n+            self.writer.write(buf.slice_to(len)).map(|()| len)\n         })\n     }\n }\n@@ -230,7 +230,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n-        try!(w.write(buf[..len]));\n+        try!(w.write(buf.slice_to(len)));\n     }\n }\n "}, {"sha": "f5b2f31a127d603f25fc09ea5d8513e885d3380a", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};"}, {"sha": "623a10725c826387d8c942b9c0f79efd3e416658", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};"}, {"sha": "ffb1307908c90821941ee8721d7a7ed8c20989f2", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};"}, {"sha": "4fbb7381238dc77569a6a05aafd84e20d1f9ac45", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};"}, {"sha": "7821306f5fc3da122ee4d2f4d027a6920272b1c8", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::int::{BITS, BYTES, MIN, MAX};"}, {"sha": "3c01edf233925986005a4803c3dd1148191fd4e3", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -78,7 +78,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n         (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n         wr.tell().unwrap() as uint\n     };\n-    f(buf[..amt])\n+    f(buf.slice(0, amt))\n }\n \n #[deprecated = \"use fmt::radix\"]"}, {"sha": "b15f334e233e82197863e80b27ea2421146eed89", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -730,7 +730,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n         // parse remaining bytes as decimal integer,\n         // skipping the exponent char\n         let exp: Option<int> = from_str_bytes_common(\n-            buf[i+1..len], 10, true, false, false, ExpNone, false,\n+            buf.slice(i+1, len), 10, true, false, false, ExpNone, false,\n             ignore_underscores);\n \n         match exp {"}, {"sha": "0f00f99e980a2a6c387555fd8ca36bbb7b3cdd33", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};"}, {"sha": "e6c6bc377b7aa304d51cb468c93f06ac091b6768", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};"}, {"sha": "7eb9e1a082fe872abb009e326cc94657d7048a41", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};"}, {"sha": "300dd3bcc01a4cfc69f2f7965bb0f614a024f7ec", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};"}, {"sha": "0adc22e321406ebdce3ef58c05d77dec808c8521", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};"}, {"sha": "cfcaf0fa8daa35d61ebaa203ecaf86446964fa0e", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -79,7 +79,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n         (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n         wr.tell().unwrap() as uint\n     };\n-    f(buf[..amt])\n+    f(buf.slice(0, amt))\n }\n \n #[deprecated = \"use fmt::radix\"]"}, {"sha": "16552daae36b7526b0e109f30c88bc8ae52f187c", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -357,7 +357,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => name,\n                     Some(1) if name == b\"..\" => name,\n-                    Some(pos) => name[..pos]\n+                    Some(pos) => name.slice_to(pos)\n                 }\n             })\n         }\n@@ -404,7 +404,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n                     Some(1) if name == b\"..\" => None,\n-                    Some(pos) => Some(name[pos+1..])\n+                    Some(pos) => Some(name.slice_from(pos+1))\n                 }\n             }\n         }\n@@ -480,7 +480,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(name[..idx].to_vec()),\n+                (Some(idx), 0) => Some(name.slice_to(idx).to_vec()),\n                 (idx, extlen) => {\n                     let idx = match idx {\n                         None | Some(0) => name.len(),\n@@ -489,7 +489,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n                     let mut v;\n                     v = Vec::with_capacity(idx + extlen + 1);\n-                    v.push_all(name[..idx]);\n+                    v.push_all(name.slice_to(idx));\n                     v.push(dot);\n                     v.push_all(extension.container_as_bytes());\n                     Some(v)"}, {"sha": "9c4139853c540b275b44d91f59c7f7a39ad3c51e", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -165,7 +165,7 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n-            Some(idx) if self.repr[idx+1..] == b\"..\" => {\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => {\n                 let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n@@ -175,7 +175,7 @@ impl GenericPathUnsafe for Path {\n             }\n             Some(idx) => {\n                 let mut v = Vec::with_capacity(idx + 1 + filename.len());\n-                v.push_all(self.repr[..idx+1]);\n+                v.push_all(self.repr.slice_to(idx+1));\n                 v.push_all(filename);\n                 // FIXME: this is slow\n                 self.repr = Path::normalize(v.as_slice());\n@@ -216,9 +216,9 @@ impl GenericPath for Path {\n         match self.sepidx {\n             None if b\"..\" == self.repr.as_slice() => self.repr.as_slice(),\n             None => dot_static,\n-            Some(0) => self.repr[..1],\n-            Some(idx) if self.repr[idx+1..] == b\"..\" => self.repr.as_slice(),\n-            Some(idx) => self.repr[..idx]\n+            Some(0) => self.repr.slice_to(1),\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => self.repr.as_slice(),\n+            Some(idx) => self.repr.slice_to(idx)\n         }\n     }\n \n@@ -227,9 +227,9 @@ impl GenericPath for Path {\n             None if b\".\" == self.repr.as_slice() ||\n                 b\"..\" == self.repr.as_slice() => None,\n             None => Some(self.repr.as_slice()),\n-            Some(idx) if self.repr[idx+1..] == b\"..\" => None,\n-            Some(0) if self.repr[1..].is_empty() => None,\n-            Some(idx) => Some(self.repr[idx+1..])\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => None,\n+            Some(0) if self.repr.slice_from(1).is_empty() => None,\n+            Some(idx) => Some(self.repr.slice_from(idx+1))\n         }\n     }\n \n@@ -371,7 +371,7 @@ impl Path {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n-            let v_ = if is_abs { v.as_slice()[1..] } else { v.as_slice() };\n+            let v_ = if is_abs { v.as_slice().slice_from(1) } else { v.as_slice() };\n             let comps = normalize_helper(v_, is_abs);\n             match comps {\n                 None => None,\n@@ -410,7 +410,7 @@ impl Path {\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn components<'a>(&'a self) -> Components<'a> {\n         let v = if self.repr[0] == SEP_BYTE {\n-            self.repr[1..]\n+            self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n         let mut ret = v.split(is_sep_byte);\n         if v.is_empty() {"}, {"sha": "a5458461a8b2562bb9975719491d623a686109b3", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -496,7 +496,7 @@ impl<'ast> Map<'ast> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n-            in_which: parts[..parts.len() - 1],\n+            in_which: parts.slice_to(parts.len() - 1),\n             idx: 0,\n         }\n     }"}, {"sha": "f33c768d647575607a821aad4a6dc364604558bc", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -414,7 +414,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let mut elided = false;\n     let mut display_lines = lines.lines.as_slice();\n     if display_lines.len() > MAX_LINES {\n-        display_lines = display_lines[0u..MAX_LINES];\n+        display_lines = display_lines.slice(0u, MAX_LINES);\n         elided = true;\n     }\n     // Print the offending lines"}, {"sha": "f59a4465e1da4b4ad092e07c23cde8ed826ded95", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -285,13 +285,13 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n \n \n             // Find the offset of the NUL we want to go to\n-            let nulpos = string_table[offset as uint .. string_table_bytes as uint]\n+            let nulpos = string_table.slice(offset as uint, string_table_bytes as uint)\n                 .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_string(),\n-                                      string_table[offset as uint ..\n-                                          offset as uint + len].to_vec())\n+                                      string_table.slice(offset as uint,\n+                                          offset as uint + len).to_vec())\n                 },\n                 None => {\n                     return Err(\"invalid file: missing NUL in \\"}, {"sha": "5e812e500d6e81c6457db93de35e0e8725d73a76", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -50,7 +50,7 @@ fn rotate(x: &mut [i32]) {\n \n fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n     for i in range(1, perm.len()) {\n-        rotate(perm[mut ..i + 1]);\n+        rotate(perm.slice_to_mut(i + 1));\n         let count_i = &mut count[i];\n         if *count_i >= i as i32 {\n             *count_i = 0;\n@@ -99,7 +99,7 @@ impl Perm {\n             let d = idx / self.fact[i] as i32;\n             self.cnt[i] = d;\n             idx %= self.fact[i] as i32;\n-            for (place, val) in pp.iter_mut().zip(self.perm.p[..i+1].iter()) {\n+            for (place, val) in pp.iter_mut().zip(self.perm.p.slice_to(i + 1).iter()) {\n                 *place = (*val) as u8\n             }\n \n@@ -125,7 +125,7 @@ impl Perm {\n \n \n fn reverse(tperm: &mut [i32], mut k: uint) {\n-    tperm[mut ..k].reverse()\n+    tperm.slice_to_mut(k).reverse()\n }\n \n fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {"}, {"sha": "b68404bdd72387e96a908155f5792afba469679c", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -124,8 +124,8 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n \n         copy_memory(buf.as_mut_slice(), alu);\n         let buf_len = buf.len();\n-        copy_memory(buf[mut alu_len..buf_len],\n-                    alu[..LINE_LEN]);\n+        copy_memory(buf.slice_mut(alu_len, buf_len),\n+                    alu.slice_to(LINE_LEN));\n \n         let mut pos = 0;\n         let mut bytes;\n@@ -201,7 +201,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n         for i in range(0u, chars_left) {\n             buf[i] = self.nextc();\n         }\n-        self.out.write(buf[..chars_left])\n+        self.out.write(buf.slice_to(chars_left))\n     }\n }\n "}, {"sha": "e5ddcac1e8fcd1e730523237247de73db5456cc6", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -93,7 +93,7 @@ fn make_fasta<W: Writer, I: Iterator<u8>>(\n         }\n         n -= nb;\n         line[nb] = '\\n' as u8;\n-        wr.write(line[..nb+1]);\n+        wr.write(line.slice_to(nb + 1));\n     }\n }\n "}, {"sha": "f4d1cee5fb4ca11434a1378e3e555e334aeaf161", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -97,11 +97,11 @@ fn windows_with_carry(bb: &[u8], nn: uint, it: |window: &[u8]|) -> Vec<u8> {\n \n    let len = bb.len();\n    while ii < len - (nn - 1u) {\n-      it(bb[ii..ii+nn]);\n+      it(bb.slice(ii, ii+nn));\n       ii += 1u;\n    }\n \n-   return Vec::from_slice(bb[len - (nn - 1u)..len]);\n+   return Vec::from_slice(bb.slice(len - (nn - 1u), len));\n }\n \n fn make_sequence_processor(sz: uint,"}, {"sha": "cecc95354afefece8445db9bfd3940562acc58c4", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -240,14 +240,14 @@ fn generate_frequencies(mut input: &[u8], frame: uint) -> Table {\n     // Pull first frame.\n     for _ in range(0, frame) {\n         code = code.push_char(input[0]);\n-        input = input[1..];\n+        input = input.slice_from(1);\n     }\n     frequencies.lookup(code, BumpCallback);\n \n     while input.len() != 0 && input[0] != ('>' as u8) {\n         code = code.rotate(input[0], frame);\n         frequencies.lookup(code, BumpCallback);\n-        input = input[1..];\n+        input = input.slice_from(1);\n     }\n     frequencies\n }"}, {"sha": "e522bcaf4db7b6e286cdc7d1c925d1fbdfc78ef2", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -81,7 +81,7 @@ fn main() {\n             Some(c) => c\n         };\n         let len = seq.len();\n-        let seq = seq[mut begin+1..len-1];\n+        let seq = seq.slice_mut(begin + 1, len - 1);\n \n         // arrange line breaks\n         let len = seq.len();"}, {"sha": "6cddd8ee9397bc4880c803f9f5cb90ea13b0402f", "filename": "src/test/compile-fail/issue-15730.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -11,5 +11,5 @@\n fn main() {\n     let mut array = [1, 2, 3];\n //~^ ERROR cannot determine a type for this local variable: cannot determine the type of this integ\n-    let pie_slice = array[1..2];\n+    let pie_slice = array.slice(1, 2);\n }"}, {"sha": "ba8c4d249ce7f4d381354677f543c6ffd0fc79ed", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -94,7 +94,7 @@ fn main() {\n     let empty: &[i64] = &[];\n     let singleton: &[i64] = &[1];\n     let multiple: &[i64] = &[2, 3, 4, 5];\n-    let slice_of_slice = multiple[1..3];\n+    let slice_of_slice = multiple.slice(1,3);\n \n     let padded_tuple: &[(i32, i16)] = &[(6, 7), (8, 9)];\n "}, {"sha": "c9f6733fa2587afdf6f0adb686d6cc44d4fc7d2b", "filename": "src/test/run-pass/issue-3888-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn vec_peek<'r, T>(v: &'r [T]) -> &'r [T] {\n-    v[1..5]\n+    v.slice(1, 5)\n }\n \n pub fn main() {}"}, {"sha": "822fda8a18ec825c3f93ca39d6379fe5d99e0305", "filename": "src/test/run-pass/issue-4464.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4464.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { v[i..j] }\n+fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { v.slice(i, j) }\n \n pub fn main() {}"}, {"sha": "dea352833f0edffeb3612967e6cf52e5f9aaf826", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "patch": "@@ -21,7 +21,7 @@ pub fn main() {\n     let abc = [1i, 2, 3];\n     let tf = [true, false];\n     let x  = [(), ()];\n-    let slice = x[0..1];\n+    let slice = x.slice(0,1);\n     let z = box(GC) x;\n \n     assert_repr_eq(abc, \"[1, 2, 3]\".to_string());"}]}