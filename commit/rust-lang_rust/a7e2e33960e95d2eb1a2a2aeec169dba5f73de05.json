{"sha": "a7e2e33960e95d2eb1a2a2aeec169dba5f73de05", "node_id": "C_kwDOAAsO6NoAKGE3ZTJlMzM5NjBlOTVkMmViMWEyYTJhZWVjMTY5ZGJhNWY3M2RlMDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-08T18:32:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-08T18:32:31Z"}, "message": "Auto merge of #91919 - Aaron1011:query-recursive-read, r=michaelwoerister\n\nDon't perform any new queries while reading a query result on disk\n\nIn addition to being very confusing, this can cause us to add dep node edges between two queries that would not otherwise have an edge.\n\nWe now panic if any new dep node edges are created during the deserialization of a query result. This requires serializing the full `AdtDef` to disk, instead of just serializing the `DefId` and invoking the `adt_def` query during deserialization.\n\nI'll probably split this up into several smaller PRs for perf runs.", "tree": {"sha": "5a4bfcba39ed5fe60f9e5e207f71d69d392e4fd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a4bfcba39ed5fe60f9e5e207f71d69d392e4fd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7e2e33960e95d2eb1a2a2aeec169dba5f73de05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7e2e33960e95d2eb1a2a2aeec169dba5f73de05", "html_url": "https://github.com/rust-lang/rust/commit/a7e2e33960e95d2eb1a2a2aeec169dba5f73de05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7e2e33960e95d2eb1a2a2aeec169dba5f73de05/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "488acf86a75c56d30b16822e953c505a9e4901a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/488acf86a75c56d30b16822e953c505a9e4901a7", "html_url": "https://github.com/rust-lang/rust/commit/488acf86a75c56d30b16822e953c505a9e4901a7"}, {"sha": "27ed52c0a2e05d459a25d077d2eec584cb98a591", "url": "https://api.github.com/repos/rust-lang/rust/commits/27ed52c0a2e05d459a25d077d2eec584cb98a591", "html_url": "https://github.com/rust-lang/rust/commit/27ed52c0a2e05d459a25d077d2eec584cb98a591"}], "stats": {"total": 78, "additions": 76, "deletions": 2}, "files": [{"sha": "7c96f68ffb3765e17fc741001784ba3bbd33a521", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2e33960e95d2eb1a2a2aeec169dba5f73de05/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2e33960e95d2eb1a2a2aeec169dba5f73de05/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=a7e2e33960e95d2eb1a2a2aeec169dba5f73de05", "patch": "@@ -177,6 +177,62 @@ impl<K: DepKind> DepGraph<K> {\n         K::with_deps(None, op)\n     }\n \n+    /// Used to wrap the deserialization of a query result from disk,\n+    /// This method enforces that no new `DepNodes` are created during\n+    /// query result deserialization.\n+    ///\n+    /// Enforcing this makes the query dep graph simpler - all nodes\n+    /// must be created during the query execution, and should be\n+    /// created from inside the 'body' of a query (the implementation\n+    /// provided by a particular compiler crate).\n+    ///\n+    /// Consider the case of three queries `A`, `B`, and `C`, where\n+    /// `A` invokes `B` and `B` invokes `C`:\n+    ///\n+    /// `A -> B -> C`\n+    ///\n+    /// Suppose that decoding the result of query `B` required re-computing\n+    /// the query `C`. If we did not create a fresh `TaskDeps` when\n+    /// decoding `B`, we would still be using the `TaskDeps` for query `A`\n+    /// (if we needed to re-execute `A`). This would cause us to create\n+    /// a new edge `A -> C`. If this edge did not previously\n+    /// exist in the `DepGraph`, then we could end up with a different\n+    /// `DepGraph` at the end of compilation, even if there were no\n+    /// meaningful changes to the overall program (e.g. a newline was added).\n+    /// In addition, this edge might cause a subsequent compilation run\n+    /// to try to force `C` before marking other necessary nodes green. If\n+    /// `C` did not exist in the new compilation session, then we could\n+    /// get an ICE. Normally, we would have tried (and failed) to mark\n+    /// some other query green (e.g. `item_children`) which was used\n+    /// to obtain `C`, which would prevent us from ever trying to force\n+    /// a non-existent `D`.\n+    ///\n+    /// It might be possible to enforce that all `DepNode`s read during\n+    /// deserialization already exist in the previous `DepGraph`. In\n+    /// the above example, we would invoke `D` during the deserialization\n+    /// of `B`. Since we correctly create a new `TaskDeps` from the decoding\n+    /// of `B`, this would result in an edge `B -> D`. If that edge already\n+    /// existed (with the same `DepPathHash`es), then it should be correct\n+    /// to allow the invocation of the query to proceed during deserialization\n+    /// of a query result. We would merely assert that the dep-graph fragment\n+    /// that would have been added by invoking `C` while decoding `B`\n+    /// is equivalent to the dep-graph fragment that we already instantiated for B\n+    /// (at the point where we successfully marked B as green).\n+    ///\n+    /// However, this would require additional complexity\n+    /// in the query infrastructure, and is not currently needed by the\n+    /// decoding of any query results. Should the need arise in the future,\n+    /// we should consider extending the query system with this functionality.\n+    pub fn with_query_deserialization<OP, R>(&self, op: OP) -> R\n+    where\n+        OP: FnOnce() -> R,\n+    {\n+        let mut deps = TaskDeps::default();\n+        deps.read_allowed = false;\n+        let deps = Lock::new(deps);\n+        K::with_deps(Some(&deps), op)\n+    }\n+\n     /// Starts a new dep-graph task. Dep-graph tasks are specified\n     /// using a free function (`task`) and **not** a closure -- this\n     /// is intentional because we want to exercise tight control over\n@@ -257,6 +313,7 @@ impl<K: DepKind> DepGraph<K> {\n                 reads: SmallVec::new(),\n                 read_set: Default::default(),\n                 phantom_data: PhantomData,\n+                read_allowed: true,\n             }))\n         };\n         let result = K::with_deps(task_deps.as_ref(), || task(cx, arg));\n@@ -368,6 +425,11 @@ impl<K: DepKind> DepGraph<K> {\n                 if let Some(task_deps) = task_deps {\n                     let mut task_deps = task_deps.lock();\n                     let task_deps = &mut *task_deps;\n+\n+                    if !task_deps.read_allowed {\n+                        panic!(\"Illegal read of: {:?}\", dep_node_index);\n+                    }\n+\n                     if cfg!(debug_assertions) {\n                         data.current.total_read_count.fetch_add(1, Relaxed);\n                     }\n@@ -1129,6 +1191,12 @@ pub struct TaskDeps<K> {\n     reads: EdgesVec,\n     read_set: FxHashSet<DepNodeIndex>,\n     phantom_data: PhantomData<DepNode<K>>,\n+    /// Whether or not we allow `DepGraph::read_index` to run.\n+    /// This is normally true, except inside `with_query_deserialization`,\n+    /// where it set to `false` to enforce that no new `DepNode` edges are\n+    /// created. See the documentation of `with_query_deserialization` for\n+    /// more details.\n+    read_allowed: bool,\n }\n \n impl<K> Default for TaskDeps<K> {\n@@ -1139,6 +1207,7 @@ impl<K> Default for TaskDeps<K> {\n             reads: EdgesVec::new(),\n             read_set: FxHashSet::default(),\n             phantom_data: PhantomData,\n+            read_allowed: true,\n         }\n     }\n }"}, {"sha": "da1f3617647804b835a289dcbb6ca6218ee54326", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2e33960e95d2eb1a2a2aeec169dba5f73de05/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2e33960e95d2eb1a2a2aeec169dba5f73de05/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=a7e2e33960e95d2eb1a2a2aeec169dba5f73de05", "patch": "@@ -9,7 +9,6 @@ use crate::query::job::{\n     report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId,\n };\n use crate::query::{QueryContext, QueryMap, QuerySideEffects, QueryStackFrame};\n-\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHasher};\n #[cfg(parallel_compiler)]\n@@ -515,7 +514,13 @@ where\n     // Some things are never cached on disk.\n     if query.cache_on_disk {\n         let prof_timer = tcx.dep_context().profiler().incr_cache_loading();\n-        let result = query.try_load_from_disk(tcx, prev_dep_node_index);\n+\n+        // The call to `with_query_deserialization` enforces that no new `DepNodes`\n+        // are created during deserialization. See the docs of that method for more\n+        // details.\n+        let result = dep_graph\n+            .with_query_deserialization(|| query.try_load_from_disk(tcx, prev_dep_node_index));\n+\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n         if let Some(result) = result {"}]}