{"sha": "e4b01c7791446b2f79a1b1d517223378df2bf5f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YjAxYzc3OTE0NDZiMmY3OWExYjFkNTE3MjIzMzc4ZGYyYmY1ZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-22T22:36:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-22T22:36:44Z"}, "message": "Auto merge of #69778 - Marwes:dep_graph, r=davidtwco\n\nperf(dep_graph): Avoid allocating a set on when the number reads are \u2026\n\n\u2026small\n\n`reserve_and_rehash` takes up 1.4% of the runtime on the `packed-simd`\nbenchmark which I believe is due to the number of reads are very low in\nmany cases (see https://github.com/rust-lang/rust/pull/50565 for\ninstance).\n\nThis avoids allocating the set until we start allocating the `reads`\n`SmallVec` but it is possible that a lower limit might be better (not\ntested since the improvement will be hard to spot either way).", "tree": {"sha": "fc02a84a46cc3ecc8a826e3b20b173a548c5cc37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc02a84a46cc3ecc8a826e3b20b173a548c5cc37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4b01c7791446b2f79a1b1d517223378df2bf5f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4b01c7791446b2f79a1b1d517223378df2bf5f2", "html_url": "https://github.com/rust-lang/rust/commit/e4b01c7791446b2f79a1b1d517223378df2bf5f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4b01c7791446b2f79a1b1d517223378df2bf5f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1e81ef234ff5c2e0e3a69cb4e8e5f5b0fe1fd83", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1e81ef234ff5c2e0e3a69cb4e8e5f5b0fe1fd83", "html_url": "https://github.com/rust-lang/rust/commit/d1e81ef234ff5c2e0e3a69cb4e8e5f5b0fe1fd83"}, {"sha": "4168c25b0f8aadcfe38c8bdae7cc51c22c2f45d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4168c25b0f8aadcfe38c8bdae7cc51c22c2f45d1", "html_url": "https://github.com/rust-lang/rust/commit/4168c25b0f8aadcfe38c8bdae7cc51c22c2f45d1"}], "stats": {"total": 35, "additions": 24, "deletions": 11}, "files": [{"sha": "dcb53a4fdef51f70fa9d54a167711903a0cb3bbd", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e4b01c7791446b2f79a1b1d517223378df2bf5f2/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4b01c7791446b2f79a1b1d517223378df2bf5f2/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=e4b01c7791446b2f79a1b1d517223378df2bf5f2", "patch": "@@ -328,12 +328,7 @@ impl DepGraph {\n     {\n         if let Some(ref data) = self.data {\n             let (result, task_deps) = ty::tls::with_context(|icx| {\n-                let task_deps = Lock::new(TaskDeps {\n-                    #[cfg(debug_assertions)]\n-                    node: None,\n-                    reads: SmallVec::new(),\n-                    read_set: Default::default(),\n-                });\n+                let task_deps = Lock::new(TaskDeps::default());\n \n                 let r = {\n                     let icx = ty::tls::ImplicitCtxt { task_deps: Some(&task_deps), ..icx.clone() };\n@@ -953,7 +948,7 @@ pub enum WorkProductFileKind {\n #[derive(Clone)]\n struct DepNodeData {\n     node: DepNode,\n-    edges: SmallVec<[DepNodeIndex; 8]>,\n+    edges: EdgesVec,\n     fingerprint: Fingerprint,\n }\n \n@@ -1078,7 +1073,7 @@ impl CurrentDepGraph {\n     fn alloc_node(\n         &self,\n         dep_node: DepNode,\n-        edges: SmallVec<[DepNodeIndex; 8]>,\n+        edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n         debug_assert!(\n@@ -1090,7 +1085,7 @@ impl CurrentDepGraph {\n     fn intern_node(\n         &self,\n         dep_node: DepNode,\n-        edges: SmallVec<[DepNodeIndex; 8]>,\n+        edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n         match self.node_to_node_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n@@ -1113,11 +1108,25 @@ impl DepGraphData {\n             let icx = if let Some(icx) = icx { icx } else { return };\n             if let Some(task_deps) = icx.task_deps {\n                 let mut task_deps = task_deps.lock();\n+                let task_deps = &mut *task_deps;\n                 if cfg!(debug_assertions) {\n                     self.current.total_read_count.fetch_add(1, Relaxed);\n                 }\n-                if task_deps.read_set.insert(source) {\n+\n+                // As long as we only have a low number of reads we can avoid doing a hash\n+                // insert and potentially allocating/reallocating the hashmap\n+                let new_read = if task_deps.reads.len() < TASK_DEPS_READS_CAP {\n+                    task_deps.reads.iter().all(|other| *other != source)\n+                } else {\n+                    task_deps.read_set.insert(source)\n+                };\n+                if new_read {\n                     task_deps.reads.push(source);\n+                    if task_deps.reads.len() == TASK_DEPS_READS_CAP {\n+                        // Fill `read_set` with what we have so far so we can use the hashset next\n+                        // time\n+                        task_deps.read_set.extend(task_deps.reads.iter().copied());\n+                    }\n \n                     #[cfg(debug_assertions)]\n                     {\n@@ -1139,10 +1148,14 @@ impl DepGraphData {\n     }\n }\n \n+/// The capacity of the `reads` field `SmallVec`\n+const TASK_DEPS_READS_CAP: usize = 8;\n+type EdgesVec = SmallVec<[DepNodeIndex; TASK_DEPS_READS_CAP]>;\n+#[derive(Default)]\n pub struct TaskDeps {\n     #[cfg(debug_assertions)]\n     node: Option<DepNode>,\n-    reads: SmallVec<[DepNodeIndex; 8]>,\n+    reads: EdgesVec,\n     read_set: FxHashSet<DepNodeIndex>,\n }\n "}]}