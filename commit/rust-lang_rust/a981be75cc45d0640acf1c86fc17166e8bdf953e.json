{"sha": "a981be75cc45d0640acf1c86fc17166e8bdf953e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ODFiZTc1Y2M0NWQwNjQwYWNmMWM4NmZjMTcxNjZlOGJkZjk1M2U=", "commit": {"author": {"name": "Ian Wahbe", "email": "ian@wahbe.com", "date": "2021-06-29T13:24:01Z"}, "committer": {"name": "Ian Wahbe", "email": "ian@wahbe.com", "date": "2021-06-29T13:24:01Z"}, "message": "add head/tail methods to linked list mutable cursor", "tree": {"sha": "1d17c40351b33f294e7214dd4fc0b410b052866b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d17c40351b33f294e7214dd4fc0b410b052866b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a981be75cc45d0640acf1c86fc17166e8bdf953e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a981be75cc45d0640acf1c86fc17166e8bdf953e", "html_url": "https://github.com/rust-lang/rust/commit/a981be75cc45d0640acf1c86fc17166e8bdf953e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a981be75cc45d0640acf1c86fc17166e8bdf953e/comments", "author": {"login": "iwahbe", "id": 22222529, "node_id": "MDQ6VXNlcjIyMjIyNTI5", "avatar_url": "https://avatars.githubusercontent.com/u/22222529?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iwahbe", "html_url": "https://github.com/iwahbe", "followers_url": "https://api.github.com/users/iwahbe/followers", "following_url": "https://api.github.com/users/iwahbe/following{/other_user}", "gists_url": "https://api.github.com/users/iwahbe/gists{/gist_id}", "starred_url": "https://api.github.com/users/iwahbe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iwahbe/subscriptions", "organizations_url": "https://api.github.com/users/iwahbe/orgs", "repos_url": "https://api.github.com/users/iwahbe/repos", "events_url": "https://api.github.com/users/iwahbe/events{/privacy}", "received_events_url": "https://api.github.com/users/iwahbe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iwahbe", "id": 22222529, "node_id": "MDQ6VXNlcjIyMjIyNTI5", "avatar_url": "https://avatars.githubusercontent.com/u/22222529?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iwahbe", "html_url": "https://github.com/iwahbe", "followers_url": "https://api.github.com/users/iwahbe/followers", "following_url": "https://api.github.com/users/iwahbe/following{/other_user}", "gists_url": "https://api.github.com/users/iwahbe/gists{/gist_id}", "starred_url": "https://api.github.com/users/iwahbe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iwahbe/subscriptions", "organizations_url": "https://api.github.com/users/iwahbe/orgs", "repos_url": "https://api.github.com/users/iwahbe/repos", "events_url": "https://api.github.com/users/iwahbe/events{/privacy}", "received_events_url": "https://api.github.com/users/iwahbe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d0fae5b66ea33e667c8e1f7cceaca0c3653597c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d0fae5b66ea33e667c8e1f7cceaca0c3653597c", "html_url": "https://github.com/rust-lang/rust/commit/5d0fae5b66ea33e667c8e1f7cceaca0c3653597c"}], "stats": {"total": 154, "additions": 154, "deletions": 0}, "files": [{"sha": "a21eedf02f1004318bad0cca389b2099fca35624", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a981be75cc45d0640acf1c86fc17166e8bdf953e/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a981be75cc45d0640acf1c86fc17166e8bdf953e/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=a981be75cc45d0640acf1c86fc17166e8bdf953e", "patch": "@@ -1506,6 +1506,128 @@ impl<'a, T> CursorMut<'a, T> {\n         self.index = 0;\n         unsafe { self.list.split_off_before_node(self.current, split_off_idx) }\n     }\n+\n+    /// Appends an element to the front of the cursor's parent list. The node\n+    /// that the cursor points to is unchanged, even if it is the \"ghost\" node.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    // `push_front` continues to point to \"ghost\" when it addes a node to mimic\n+    // the behavior of `insert_before` on an empty list.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn push_front(&mut self, elt: T) {\n+        // Safety: We know that `push_front` does not change the position in\n+        // memory of other nodes. This ensures that `self.current` remains\n+        // valid.\n+        self.list.push_front(elt);\n+        self.index += 1;\n+    }\n+\n+    /// Appends an element to the back of the cursor's parent list. The node\n+    /// that the cursor points to is unchanged, even if it is the \"ghost\" node.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn push_back(&mut self, elt: T) {\n+        // Safety: We know that `push_back` does not change the position in\n+        // memory of other nodes. This ensures that `self.current` remains\n+        // valid.\n+        self.list.push_back(elt);\n+    }\n+\n+    /// Removes the first element from the cursor's parent list and returns it,\n+    /// or None if the list is empty. The element the cursor points to remains\n+    /// unchanged, unless it was pointing to the front element. In that case, it\n+    /// points to the new front element.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn pop_front(&mut self) -> Option<T> {\n+        // We can't check if current is empty, we must check the list directly.\n+        // It is possible for `self.current == None` and the list to be\n+        // non-empty.\n+        if self.list.is_empty() {\n+            None\n+        } else {\n+            // We can't point to the node that we pop. Copying the behavior of\n+            // `remove_current`, we move on the the next node in the sequence.\n+            // If the list is of length 1 then we end pointing to the \"ghost\"\n+            // node, which is expected.\n+            if self.list.head == self.current {\n+                self.move_next();\n+            }\n+            // We always need to change the index since `head` comes before any\n+            // other element.\n+            self.index.checked_sub(1).unwrap_or(0);\n+            self.list.pop_front()\n+        }\n+    }\n+\n+    /// Removes the last element from the cursor's parent list and returns it,\n+    /// or None if the list is empty. The element the cursor points to remains\n+    /// unchanged, unless it was pointing to the back element. In that case, it\n+    /// points to the new back element.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn pop_back(&mut self) -> Option<T> {\n+        if self.list.is_empty() {\n+            None\n+        } else {\n+            if self.list.tail == self.current {\n+                self.move_prev()\n+            }\n+            // We don't need to change the index since `current` points to a\n+            // node before `tail`.\n+            self.list.pop_back()\n+        }\n+    }\n+\n+    /// Provides a reference to the front element of the cursor's parent list,\n+    /// or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn front(&self) -> Option<&T> {\n+        self.list.front()\n+    }\n+\n+    /// Provides a mutable reference to the front element of the cursor's\n+    /// parent list, or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn front_mut(&mut self) -> Option<&mut T> {\n+        self.list.front_mut()\n+    }\n+\n+    /// Provides a reference to the back element of the cursor's parent list,\n+    /// or None if the list is empty.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn back(&self) -> Option<&T> {\n+        self.list.back()\n+    }\n+\n+    /// Provides a mutable reference to back element of the cursor's parent\n+    /// list, or `None` if the list is empty.\n+    ///\n+    /// # Examples\n+    /// Building and mutating a list with a cursor, then getting the back element:\n+    /// ```\n+    /// #![feature(linked_list_cursors)]\n+    /// use std::collections::LinkedList;\n+    /// let mut dl = LinkedList::new();\n+    /// dl.push_front(3);\n+    /// dl.push_front(2);\n+    /// dl.push_front(1);\n+    /// let mut cursor = dl.cursor_front_mut();\n+    /// *cursor.current().unwrap() = 99;\n+    /// *cursor.back_mut().unwrap() = 0;\n+    /// let mut contents = dl.into_iter();\n+    /// assert_eq!(contents.next(), Some(99));\n+    /// assert_eq!(contents.next(), Some(2));\n+    /// assert_eq!(contents.next(), Some(0));\n+    /// assert_eq!(contents.next(), None);\n+    /// ```\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn back_mut(&mut self) -> Option<&mut T> {\n+        self.list.back_mut()\n+    }\n }\n \n /// An iterator produced by calling `drain_filter` on LinkedList."}, {"sha": "429685260fd77db08e7e4da23c466c6bf89e79a5", "filename": "library/alloc/src/collections/linked_list/tests.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a981be75cc45d0640acf1c86fc17166e8bdf953e/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a981be75cc45d0640acf1c86fc17166e8bdf953e/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs?ref=a981be75cc45d0640acf1c86fc17166e8bdf953e", "patch": "@@ -428,3 +428,35 @@ fn test_cursor_mut_insert() {\n     check_links(&m);\n     assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[200, 201, 202, 203, 1, 100, 101]);\n }\n+\n+#[test]\n+fn test_cursor_push_front_back() {\n+    let mut ll: LinkedList<u32> = LinkedList::new();\n+    ll.extend(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+    let mut c = ll.cursor_front_mut();\n+    assert_eq!(c.current(), Some(&mut 1));\n+    assert_eq!(c.index(), Some(0));\n+    c.push_front(0);\n+    assert_eq!(c.current(), Some(&mut 1));\n+    assert_eq!(c.peek_prev(), Some(&mut 0));\n+    assert_eq!(c.index(), Some(1));\n+    c.push_back(11);\n+    drop(c);\n+    assert_eq!(ll, (0..12).collect());\n+    check_links(&ll);\n+}\n+\n+#[test]\n+fn test_cursor_pop_front_back() {\n+    let mut ll: LinkedList<u32> = LinkedList::new();\n+    ll.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut c = ll.cursor_back_mut();\n+    assert_eq!(c.pop_front(), Some(1));\n+    c.move_prev();\n+    c.move_prev();\n+    c.move_prev();\n+    assert_eq!(c.pop_back(), Some(6));\n+    drop(c);\n+    assert_eq!(ll, (2..6).collect());\n+    check_links(&ll);\n+}"}]}