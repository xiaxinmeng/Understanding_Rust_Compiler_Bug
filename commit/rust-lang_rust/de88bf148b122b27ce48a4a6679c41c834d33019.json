{"sha": "de88bf148b122b27ce48a4a6679c41c834d33019", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlODhiZjE0OGIxMjJiMjdjZTQ4YTRhNjY3OWM0MWM4MzRkMzMwMTk=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-11-17T19:27:44Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-11-26T22:08:35Z"}, "message": "Properly handle attributes on statements\n\nWe now collect tokens for the underlying node wrapped by `StmtKind`\ninstead of storing tokens directly in `Stmt`.\n\n`LazyTokenStream` now supports capturing a trailing semicolon after it\nis initially constructed. This allows us to avoid refactoring statement\nparsing to wrap the parsing of the semicolon in `parse_tokens`.\n\nAttributes on item statements\n(e.g. `fn foo() { #[bar] struct MyStruct; }`) are now treated as\nitem attributes, not statement attributes, which is consistent with how\nwe handle attributes on other kinds of statements. The feature-gating\ncode is adjusted so that proc-macro attributes are still allowed on item\nstatements on stable.\n\nTwo built-in macros (`#[global_allocator]` and `#[test]`) needed to be\nadjusted to support being passed `Annotatable::Stmt`.", "tree": {"sha": "03e4878aa34dfb1dec071adc58e2c494e9f04225", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03e4878aa34dfb1dec071adc58e2c494e9f04225"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de88bf148b122b27ce48a4a6679c41c834d33019", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl/AJ2MACgkQtAh+UQ6Y\nsWT8txAAlp7U5IsMXUmOsOqYqWvwJ3av7poP+NpoST8E45WIQz77isfbbHPJcOwl\nK2YFuOaNk3fKQjZNB1kVIz5Pjje+tU7/NUFXUVGvvlRoReIaen3L6vh0QQ463pwJ\nS8+khCbPpbtm3iba+AXN3IASbfLCzOa6+nKSGe9DsIUN2d1fA1PIeGsn7e9AaBwT\n3Cjla0T+h05cWsX2DIzK6Y/KfsQqWRSxxwVW3JoNYG7ypACbRNMFvlmGDb150s4x\nPs57o4ODlKo+YqI1EixgxT4SaKD0kX0hm1d758Ll1uth/Z1jDB1+ryCrjgaN+DAo\niIfZVKOffAIzfmPMLJCXuku9yMKPCmgi+LwEeiZxGExkoaA7MhuBG6IR/PhI2kOZ\n11wP5gAVwMWLsDo24J8USHKmV0LhySKyKW9F0wGWmIidADNYIlR3CmQbB3SkEK47\nmazQO0E57sh5Ai7OhtqIUfX4TVZ7qqyFu9nQoCqEpf9NkkKA+4GtPm8+fJ9N1N7d\nghPxHxhu2pxteOL/FnpY4Lg6N4aP1vMekXHSJ2lFF27X1jOIzmfFDsRwGgV2pP2p\nqvqR0Gy2cXI02mzzRzKKdoevOKVLvGZ91zNY7/IElBgEvM967EwB2pkyaZi0XBBF\naGvpsPGwuoE74hd0zwDJ2Bz/kiqubtekd3Z035znQ+SgYoEBxJQ=\n=VzmW\n-----END PGP SIGNATURE-----", "payload": "tree 03e4878aa34dfb1dec071adc58e2c494e9f04225\nparent 72da5a9d85a522b11e80d0fdd1fd95247d442604\nauthor Aaron Hill <aa1ronham@gmail.com> 1605641264 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1606428515 -0500\n\nProperly handle attributes on statements\n\nWe now collect tokens for the underlying node wrapped by `StmtKind`\ninstead of storing tokens directly in `Stmt`.\n\n`LazyTokenStream` now supports capturing a trailing semicolon after it\nis initially constructed. This allows us to avoid refactoring statement\nparsing to wrap the parsing of the semicolon in `parse_tokens`.\n\nAttributes on item statements\n(e.g. `fn foo() { #[bar] struct MyStruct; }`) are now treated as\nitem attributes, not statement attributes, which is consistent with how\nwe handle attributes on other kinds of statements. The feature-gating\ncode is adjusted so that proc-macro attributes are still allowed on item\nstatements on stable.\n\nTwo built-in macros (`#[global_allocator]` and `#[test]`) needed to be\nadjusted to support being passed `Annotatable::Stmt`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de88bf148b122b27ce48a4a6679c41c834d33019", "html_url": "https://github.com/rust-lang/rust/commit/de88bf148b122b27ce48a4a6679c41c834d33019", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de88bf148b122b27ce48a4a6679c41c834d33019/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72da5a9d85a522b11e80d0fdd1fd95247d442604", "url": "https://api.github.com/repos/rust-lang/rust/commits/72da5a9d85a522b11e80d0fdd1fd95247d442604", "html_url": "https://github.com/rust-lang/rust/commit/72da5a9d85a522b11e80d0fdd1fd95247d442604"}], "stats": {"total": 670, "additions": 484, "deletions": 186}, "files": [{"sha": "770ee81bcf1470d817238517c7bd5a4fe8bb5b25", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -901,29 +901,65 @@ pub struct Stmt {\n     pub id: NodeId,\n     pub kind: StmtKind,\n     pub span: Span,\n-    pub tokens: Option<LazyTokenStream>,\n }\n \n impl Stmt {\n+    pub fn tokens(&self) -> Option<&LazyTokenStream> {\n+        match self.kind {\n+            StmtKind::Local(ref local) => local.tokens.as_ref(),\n+            StmtKind::Item(ref item) => item.tokens.as_ref(),\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.tokens.as_ref(),\n+            StmtKind::Empty => None,\n+            StmtKind::MacCall(ref mac) => mac.tokens.as_ref(),\n+        }\n+    }\n+\n+    pub fn tokens_mut(&mut self) -> Option<&mut LazyTokenStream> {\n+        match self.kind {\n+            StmtKind::Local(ref mut local) => local.tokens.as_mut(),\n+            StmtKind::Item(ref mut item) => item.tokens.as_mut(),\n+            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => expr.tokens.as_mut(),\n+            StmtKind::Empty => None,\n+            StmtKind::MacCall(ref mut mac) => mac.tokens.as_mut(),\n+        }\n+    }\n+\n+    pub fn set_tokens(&mut self, tokens: Option<LazyTokenStream>) {\n+        match self.kind {\n+            StmtKind::Local(ref mut local) => local.tokens = tokens,\n+            StmtKind::Item(ref mut item) => item.tokens = tokens,\n+            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => expr.tokens = tokens,\n+            StmtKind::Empty => {}\n+            StmtKind::MacCall(ref mut mac) => mac.tokens = tokens,\n+        }\n+    }\n+\n     pub fn has_trailing_semicolon(&self) -> bool {\n         match &self.kind {\n             StmtKind::Semi(_) => true,\n             StmtKind::MacCall(mac) => matches!(mac.style, MacStmtStyle::Semicolon),\n             _ => false,\n         }\n     }\n+\n+    /// Converts a parsed `Stmt` to a `Stmt` with\n+    /// a trailing semicolon.\n+    ///\n+    /// This only modifies the parsed AST struct, not the attached\n+    /// `LazyTokenStream`. The parser is responsible for calling\n+    /// `CreateTokenStream::add_trailing_semi` when there is actually\n+    /// a semicolon in the tokenstream.\n     pub fn add_trailing_semicolon(mut self) -> Self {\n         self.kind = match self.kind {\n             StmtKind::Expr(expr) => StmtKind::Semi(expr),\n             StmtKind::MacCall(mac) => {\n-                StmtKind::MacCall(mac.map(|MacCallStmt { mac, style: _, attrs }| MacCallStmt {\n-                    mac,\n-                    style: MacStmtStyle::Semicolon,\n-                    attrs,\n+                StmtKind::MacCall(mac.map(|MacCallStmt { mac, style: _, attrs, tokens }| {\n+                    MacCallStmt { mac, style: MacStmtStyle::Semicolon, attrs, tokens }\n                 }))\n             }\n             kind => kind,\n         };\n+\n         self\n     }\n \n@@ -963,6 +999,7 @@ pub struct MacCallStmt {\n     pub mac: MacCall,\n     pub style: MacStmtStyle,\n     pub attrs: AttrVec,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n@@ -988,6 +1025,7 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub span: Span,\n     pub attrs: AttrVec,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n /// An arm of a 'match'."}, {"sha": "8dd16ed0fcebe17aa58569dcf842c55911c40989", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -576,13 +576,14 @@ pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(\n }\n \n pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n-    let Local { id, pat, ty, init, span, attrs } = local.deref_mut();\n+    let Local { id, pat, ty, init, span, attrs, tokens } = local.deref_mut();\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     visit_opt(ty, |ty| vis.visit_ty(ty));\n     visit_opt(init, |init| vis.visit_expr(init));\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n@@ -1325,16 +1326,12 @@ pub fn noop_filter_map_expr<T: MutVisitor>(mut e: P<Expr>, vis: &mut T) -> Optio\n }\n \n pub fn noop_flat_map_stmt<T: MutVisitor>(\n-    Stmt { kind, mut span, mut id, mut tokens }: Stmt,\n+    Stmt { kind, mut span, mut id }: Stmt,\n     vis: &mut T,\n ) -> SmallVec<[Stmt; 1]> {\n     vis.visit_id(&mut id);\n     vis.visit_span(&mut span);\n-    visit_lazy_tts(&mut tokens, vis);\n-    noop_flat_map_stmt_kind(kind, vis)\n-        .into_iter()\n-        .map(|kind| Stmt { id, kind, span, tokens: tokens.clone() })\n-        .collect()\n+    noop_flat_map_stmt_kind(kind, vis).into_iter().map(|kind| Stmt { id, kind, span }).collect()\n }\n \n pub fn noop_flat_map_stmt_kind<T: MutVisitor>(\n@@ -1351,9 +1348,10 @@ pub fn noop_flat_map_stmt_kind<T: MutVisitor>(\n         StmtKind::Semi(expr) => vis.filter_map_expr(expr).into_iter().map(StmtKind::Semi).collect(),\n         StmtKind::Empty => smallvec![StmtKind::Empty],\n         StmtKind::MacCall(mut mac) => {\n-            let MacCallStmt { mac: mac_, style: _, attrs } = mac.deref_mut();\n+            let MacCallStmt { mac: mac_, style: _, attrs, tokens } = mac.deref_mut();\n             vis.visit_mac_call(mac_);\n             visit_thin_attrs(attrs, vis);\n+            visit_lazy_tts(tokens, vis);\n             smallvec![StmtKind::MacCall(mac)]\n         }\n     }"}, {"sha": "b2207f22816205f0c11dc16fa5ae7c21da3a65aa", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -121,10 +121,14 @@ where\n }\n \n pub trait CreateTokenStream: sync::Send + sync::Sync {\n+    fn add_trailing_semi(&self) -> Box<dyn CreateTokenStream>;\n     fn create_token_stream(&self) -> TokenStream;\n }\n \n impl CreateTokenStream for TokenStream {\n+    fn add_trailing_semi(&self) -> Box<dyn CreateTokenStream> {\n+        panic!(\"Cannot call `add_trailing_semi` on a `TokenStream`!\");\n+    }\n     fn create_token_stream(&self) -> TokenStream {\n         self.clone()\n     }\n@@ -141,6 +145,13 @@ impl LazyTokenStream {\n         LazyTokenStream(Lrc::new(Box::new(inner)))\n     }\n \n+    /// Extends the captured stream by one token,\n+    /// which must be a trailing semicolon. This\n+    /// affects the `TokenStream` created by `make_tokenstream`.\n+    pub fn add_trailing_semi(&self) -> LazyTokenStream {\n+        LazyTokenStream(Lrc::new(self.0.add_trailing_semi()))\n+    }\n+\n     pub fn create_token_stream(&self) -> TokenStream {\n         self.0.create_token_stream()\n     }"}, {"sha": "857220bde233df8193d43de62dfb6b9839c89676", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -686,7 +686,7 @@ pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n         StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => visitor.visit_expr(expr),\n         StmtKind::Empty => {}\n         StmtKind::MacCall(ref mac) => {\n-            let MacCallStmt { ref mac, style: _, ref attrs } = **mac;\n+            let MacCallStmt { ref mac, style: _, ref attrs, tokens: _ } = **mac;\n             visitor.visit_mac_call(mac);\n             for attr in attrs.iter() {\n                 visitor.visit_attribute(attr);"}, {"sha": "5c21329069bfc7a35fd3b24949bc47de20700931", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -132,6 +132,7 @@ fn stmt_let_underscore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> as\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n         attrs: ast::AttrVec::new(),\n+        tokens: None,\n     });\n-    ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span: sp, tokens: None }\n+    ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span: sp }\n }"}, {"sha": "1651180817b9ddbfa2a2ea3edc94e46658e77151", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -64,7 +64,6 @@ impl MultiItemModifier for BuiltinDerive {\n                             id: ast::DUMMY_NODE_ID,\n                             kind: ast::StmtKind::Item(a.expect_item()),\n                             span,\n-                            tokens: None,\n                         })));\n                     });\n                 } else {"}, {"sha": "b1071bf4308512772669c8ac357495938bf15f9d", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -374,7 +374,6 @@ macro_rules! make_stmts_default {\n                 id: ast::DUMMY_NODE_ID,\n                 span: e.span,\n                 kind: ast::StmtKind::Expr(e),\n-                tokens: None\n             }]\n         })\n     };\n@@ -617,7 +616,6 @@ impl MacResult for DummyResult {\n             id: ast::DUMMY_NODE_ID,\n             kind: ast::StmtKind::Expr(DummyResult::raw_expr(self.span, self.is_error)),\n             span: self.span,\n-            tokens: None\n         }])\n     }\n "}, {"sha": "fe67b401fccf9c4372e7b4d5ed4d9af4a1e61edd", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -140,12 +140,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n-        ast::Stmt {\n-            id: ast::DUMMY_NODE_ID,\n-            span: expr.span,\n-            kind: ast::StmtKind::Expr(expr),\n-            tokens: None,\n-        }\n+        ast::Stmt { id: ast::DUMMY_NODE_ID, span: expr.span, kind: ast::StmtKind::Expr(expr) }\n     }\n \n     pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: Ident, ex: P<ast::Expr>) -> ast::Stmt {\n@@ -162,13 +157,9 @@ impl<'a> ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             attrs: AttrVec::new(),\n-        });\n-        ast::Stmt {\n-            id: ast::DUMMY_NODE_ID,\n-            kind: ast::StmtKind::Local(local),\n-            span: sp,\n             tokens: None,\n-        }\n+        });\n+        ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span: sp }\n     }\n \n     // Generates `let _: Type;`, which is usually used for type assertions.\n@@ -180,17 +171,13 @@ impl<'a> ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span,\n             attrs: AttrVec::new(),\n+            tokens: None,\n         });\n-        ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span, tokens: None }\n+        ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span }\n     }\n \n     pub fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n-        ast::Stmt {\n-            id: ast::DUMMY_NODE_ID,\n-            kind: ast::StmtKind::Item(item),\n-            span: sp,\n-            tokens: None,\n-        }\n+        ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Item(item), span: sp }\n     }\n \n     pub fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n@@ -200,7 +187,6 @@ impl<'a> ExtCtxt<'a> {\n                 id: ast::DUMMY_NODE_ID,\n                 span: expr.span,\n                 kind: ast::StmtKind::Expr(expr),\n-                tokens: None,\n             }],\n         )\n     }"}, {"sha": "4ba75c21cf058a202d29800c5e801a7d57b334e3", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -1274,12 +1274,6 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n             let attr = if stmt.is_item() {\n-                // FIXME: Implement proper token collection for statements\n-                if let StmtKind::Item(item) = &mut stmt.kind {\n-                    stmt.tokens = item.tokens.take()\n-                } else {\n-                    unreachable!()\n-                };\n                 self.take_first_attr(&mut stmt)\n             } else {\n                 // Ignore derives on non-item statements for backwards compatibility.\n@@ -1295,7 +1289,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n \n         if let StmtKind::MacCall(mac) = stmt.kind {\n-            let MacCallStmt { mac, style, attrs } = mac.into_inner();\n+            let MacCallStmt { mac, style, attrs, tokens: _ } = mac.into_inner();\n             self.check_attributes(&attrs);\n             let mut placeholder =\n                 self.collect_bang(mac, stmt.span, AstFragmentKind::Stmts).make_stmts();\n@@ -1312,10 +1306,10 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n \n         // The placeholder expander gives ids to statements, so we avoid folding the id here.\n-        let ast::Stmt { id, kind, span, tokens } = stmt;\n+        let ast::Stmt { id, kind, span } = stmt;\n         noop_flat_map_stmt_kind(kind, self)\n             .into_iter()\n-            .map(|kind| ast::Stmt { id, kind, span, tokens: tokens.clone() })\n+            .map(|kind| ast::Stmt { id, kind, span })\n             .collect()\n     }\n "}, {"sha": "ce19e813bb3a69f507490029da48ea25ee67ffca", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -104,8 +104,9 @@ pub fn placeholder(\n                 mac: mac_placeholder(),\n                 style: ast::MacStmtStyle::Braces,\n                 attrs: ast::AttrVec::new(),\n+                tokens: None,\n             });\n-            ast::Stmt { id, span, kind: ast::StmtKind::MacCall(mac), tokens: None }\n+            ast::Stmt { id, span, kind: ast::StmtKind::MacCall(mac) }\n         }]),\n         AstFragmentKind::Arms => AstFragment::Arms(smallvec![ast::Arm {\n             attrs: Default::default(),\n@@ -331,12 +332,8 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n \n             // FIXME: We will need to preserve the original semicolon token and\n             // span as part of #15701\n-            let empty_stmt = ast::Stmt {\n-                id: ast::DUMMY_NODE_ID,\n-                kind: ast::StmtKind::Empty,\n-                span: DUMMY_SP,\n-                tokens: None,\n-            };\n+            let empty_stmt =\n+                ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Empty, span: DUMMY_SP };\n \n             if let Some(stmt) = stmts.pop() {\n                 if stmt.has_trailing_semicolon() {"}, {"sha": "f34990a1a103757c820f7c19aa7aa18b0a0eb137", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -810,7 +810,6 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n                 id: resolver.next_node_id(),\n                 kind: ast::StmtKind::Expr(expr),\n                 span: rustc_span::DUMMY_SP,\n-                tokens: None,\n             }\n         }\n \n@@ -827,7 +826,6 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n             id: self.resolver.next_node_id(),\n             span: rustc_span::DUMMY_SP,\n             kind: ast::StmtKind::Expr(loop_expr),\n-            tokens: None,\n         };\n \n         if self.within_static_or_const {"}, {"sha": "9f565efec839f3183b8112bec8672e4c0d36b270", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -6,6 +6,7 @@\n #![feature(or_patterns)]\n \n use rustc_ast as ast;\n+use rustc_ast::attr::HasAttrs;\n use rustc_ast::token::{self, DelimToken, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::{self, LazyTokenStream, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n@@ -249,29 +250,23 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     // before we fall back to the stringification.\n \n     let convert_tokens =\n-        |tokens: &Option<LazyTokenStream>| tokens.as_ref().map(|t| t.create_token_stream());\n+        |tokens: Option<&LazyTokenStream>| tokens.as_ref().map(|t| t.create_token_stream());\n \n     let tokens = match *nt {\n         Nonterminal::NtItem(ref item) => prepend_attrs(&item.attrs, item.tokens.as_ref()),\n-        Nonterminal::NtBlock(ref block) => convert_tokens(&block.tokens),\n-        Nonterminal::NtStmt(ref stmt) => {\n-            // FIXME: We currently only collect tokens for `:stmt`\n-            // matchers in `macro_rules!` macros. When we start collecting\n-            // tokens for attributes on statements, we will need to prepend\n-            // attributes here\n-            convert_tokens(&stmt.tokens)\n-        }\n-        Nonterminal::NtPat(ref pat) => convert_tokens(&pat.tokens),\n-        Nonterminal::NtTy(ref ty) => convert_tokens(&ty.tokens),\n+        Nonterminal::NtBlock(ref block) => convert_tokens(block.tokens.as_ref()),\n+        Nonterminal::NtStmt(ref stmt) => prepend_attrs(stmt.attrs(), stmt.tokens()),\n+        Nonterminal::NtPat(ref pat) => convert_tokens(pat.tokens.as_ref()),\n+        Nonterminal::NtTy(ref ty) => convert_tokens(ty.tokens.as_ref()),\n         Nonterminal::NtIdent(ident, is_raw) => {\n             Some(tokenstream::TokenTree::token(token::Ident(ident.name, is_raw), ident.span).into())\n         }\n         Nonterminal::NtLifetime(ident) => {\n             Some(tokenstream::TokenTree::token(token::Lifetime(ident.name), ident.span).into())\n         }\n-        Nonterminal::NtMeta(ref attr) => convert_tokens(&attr.tokens),\n-        Nonterminal::NtPath(ref path) => convert_tokens(&path.tokens),\n-        Nonterminal::NtVis(ref vis) => convert_tokens(&vis.tokens),\n+        Nonterminal::NtMeta(ref attr) => convert_tokens(attr.tokens.as_ref()),\n+        Nonterminal::NtPath(ref path) => convert_tokens(path.tokens.as_ref()),\n+        Nonterminal::NtVis(ref vis) => convert_tokens(vis.tokens.as_ref()),\n         Nonterminal::NtTT(ref tt) => Some(tt.clone().into()),\n         Nonterminal::NtExpr(ref expr) | Nonterminal::NtLiteral(ref expr) => {\n             if expr.tokens.is_none() {"}, {"sha": "2a779c37b89627a10ae897b7c544e1797a919c74", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -1213,39 +1213,54 @@ impl<'a> Parser<'a> {\n         //\n         // This also makes `Parser` very cheap to clone, since\n         // there is no intermediate collection buffer to clone.\n+        #[derive(Clone)]\n         struct LazyTokenStreamImpl {\n             start_token: (Token, Spacing),\n             cursor_snapshot: TokenCursor,\n             num_calls: usize,\n             desugar_doc_comments: bool,\n+            trailing_semi: bool,\n         }\n         impl CreateTokenStream for LazyTokenStreamImpl {\n             fn create_token_stream(&self) -> TokenStream {\n+                let mut num_calls = self.num_calls;\n+                if self.trailing_semi {\n+                    num_calls += 1;\n+                }\n                 // The token produced by the final call to `next` or `next_desugared`\n                 // was not actually consumed by the callback. The combination\n                 // of chaining the initial token and using `take` produces the desired\n                 // result - we produce an empty `TokenStream` if no calls were made,\n                 // and omit the final token otherwise.\n                 let mut cursor_snapshot = self.cursor_snapshot.clone();\n                 let tokens = std::iter::once(self.start_token.clone())\n-                    .chain((0..self.num_calls).map(|_| {\n+                    .chain((0..num_calls).map(|_| {\n                         if self.desugar_doc_comments {\n                             cursor_snapshot.next_desugared()\n                         } else {\n                             cursor_snapshot.next()\n                         }\n                     }))\n-                    .take(self.num_calls);\n+                    .take(num_calls);\n \n                 make_token_stream(tokens)\n             }\n+            fn add_trailing_semi(&self) -> Box<dyn CreateTokenStream> {\n+                if self.trailing_semi {\n+                    panic!(\"Called `add_trailing_semi` twice!\");\n+                }\n+                let mut new = self.clone();\n+                new.trailing_semi = true;\n+                Box::new(new)\n+            }\n         }\n \n         let lazy_impl = LazyTokenStreamImpl {\n             start_token,\n             num_calls: self.token_cursor.num_next_calls - cursor_snapshot.num_next_calls,\n             cursor_snapshot,\n             desugar_doc_comments: self.desugar_doc_comments,\n+            trailing_semi: false,\n         };\n         Ok((ret, Some(LazyTokenStream::new(lazy_impl))))\n     }"}, {"sha": "c007f96a79800cb9b3b8055dc54998748b7ab618", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -117,8 +117,8 @@ impl<'a> Parser<'a> {\n                 let (stmt, tokens) = self.collect_tokens(|this| this.parse_stmt())?;\n                 match stmt {\n                     Some(mut s) => {\n-                        if s.tokens.is_none() {\n-                            s.tokens = tokens;\n+                        if s.tokens().is_none() {\n+                            s.set_tokens(tokens);\n                         }\n                         token::NtStmt(s)\n                     }"}, {"sha": "b41aba9b627e2f2c23840b119671d7bf292d8068", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 83, "deletions": 38, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -7,8 +7,10 @@ use super::{BlockMode, Parser, Restrictions, SemiColonMode};\n use crate::maybe_whole;\n \n use rustc_ast as ast;\n+use rustc_ast::attr::HasAttrs;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, TokenKind};\n+use rustc_ast::tokenstream::LazyTokenStream;\n use rustc_ast::util::classify;\n use rustc_ast::{AttrStyle, AttrVec, Attribute, MacCall, MacCallStmt, MacStmtStyle};\n use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, Local, Stmt, StmtKind, DUMMY_NODE_ID};\n@@ -31,45 +33,75 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_stmt_without_recovery(&mut self) -> PResult<'a, Option<Stmt>> {\n-        maybe_whole!(self, NtStmt, |x| Some(x));\n-\n-        let attrs = self.parse_outer_attributes()?;\n+        let mut attrs = self.parse_outer_attributes()?;\n+        let has_attrs = !attrs.is_empty();\n         let lo = self.token.span;\n \n-        let stmt = if self.eat_keyword(kw::Let) {\n-            self.parse_local_mk(lo, attrs.into())?\n-        } else if self.is_kw_followed_by_ident(kw::Mut) {\n-            self.recover_stmt_local(lo, attrs.into(), \"missing keyword\", \"let mut\")?\n-        } else if self.is_kw_followed_by_ident(kw::Auto) {\n-            self.bump(); // `auto`\n-            let msg = \"write `let` instead of `auto` to introduce a new variable\";\n-            self.recover_stmt_local(lo, attrs.into(), msg, \"let\")?\n-        } else if self.is_kw_followed_by_ident(sym::var) {\n-            self.bump(); // `var`\n-            let msg = \"write `let` instead of `var` to introduce a new variable\";\n-            self.recover_stmt_local(lo, attrs.into(), msg, \"let\")?\n-        } else if self.check_path() && !self.token.is_qpath_start() && !self.is_path_start_item() {\n-            // We have avoided contextual keywords like `union`, items with `crate` visibility,\n-            // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n-            // that starts like a path (1 token), but it fact not a path.\n-            // Also, we avoid stealing syntax from `parse_item_`.\n-            self.parse_stmt_path_start(lo, attrs)?\n-        } else if let Some(item) = self.parse_item_common(attrs.clone(), false, true, |_| true)? {\n-            // FIXME: Bad copy of attrs\n-            self.mk_stmt(lo.to(item.span), StmtKind::Item(P(item)))\n-        } else if self.eat(&token::Semi) {\n-            // Do not attempt to parse an expression if we're done here.\n-            self.error_outer_attrs(&attrs);\n-            self.mk_stmt(lo, StmtKind::Empty)\n-        } else if self.token != token::CloseDelim(token::Brace) {\n-            // Remainder are line-expr stmts.\n-            let e = self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs.into()))?;\n-            self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n+        maybe_whole!(self, NtStmt, |stmt| {\n+            let mut stmt = stmt;\n+            stmt.visit_attrs(|stmt_attrs| {\n+                mem::swap(stmt_attrs, &mut attrs);\n+                stmt_attrs.extend(attrs);\n+            });\n+            Some(stmt)\n+        });\n+\n+        let parse_stmt_inner = |this: &mut Self| {\n+            let stmt = if this.eat_keyword(kw::Let) {\n+                this.parse_local_mk(lo, attrs.into())?\n+            } else if this.is_kw_followed_by_ident(kw::Mut) {\n+                this.recover_stmt_local(lo, attrs.into(), \"missing keyword\", \"let mut\")?\n+            } else if this.is_kw_followed_by_ident(kw::Auto) {\n+                this.bump(); // `auto`\n+                let msg = \"write `let` instead of `auto` to introduce a new variable\";\n+                this.recover_stmt_local(lo, attrs.into(), msg, \"let\")?\n+            } else if this.is_kw_followed_by_ident(sym::var) {\n+                this.bump(); // `var`\n+                let msg = \"write `let` instead of `var` to introduce a new variable\";\n+                this.recover_stmt_local(lo, attrs.into(), msg, \"let\")?\n+            } else if this.check_path()\n+                && !this.token.is_qpath_start()\n+                && !this.is_path_start_item()\n+            {\n+                // We have avoided contextual keywords like `union`, items with `crate` visibility,\n+                // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n+                // that starts like a path (1 token), but it fact not a path.\n+                // Also, we avoid stealing syntax from `parse_item_`.\n+                this.parse_stmt_path_start(lo, attrs)?\n+            } else if let Some(item) =\n+                this.parse_item_common(attrs.clone(), false, true, |_| true)?\n+            {\n+                // FIXME: Bad copy of attrs\n+                this.mk_stmt(lo.to(item.span), StmtKind::Item(P(item)))\n+            } else if this.eat(&token::Semi) {\n+                // Do not attempt to parse an expression if we're done here.\n+                this.error_outer_attrs(&attrs);\n+                this.mk_stmt(lo, StmtKind::Empty)\n+            } else if this.token != token::CloseDelim(token::Brace) {\n+                // Remainder are line-expr stmts.\n+                let e = this.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs.into()))?;\n+                this.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n+            } else {\n+                this.error_outer_attrs(&attrs);\n+                return Ok(None);\n+            };\n+            Ok(Some(stmt))\n+        };\n+\n+        let stmt = if has_attrs {\n+            let (mut stmt, tokens) = self.collect_tokens(parse_stmt_inner)?;\n+            if let Some(stmt) = &mut stmt {\n+                // If we already have tokens (e.g. due to encounting an `NtStmt`),\n+                // use those instead.\n+                if stmt.tokens().is_none() {\n+                    stmt.set_tokens(tokens);\n+                }\n+            }\n+            stmt\n         } else {\n-            self.error_outer_attrs(&attrs);\n-            return Ok(None);\n+            parse_stmt_inner(self)?\n         };\n-        Ok(Some(stmt))\n+        Ok(stmt)\n     }\n \n     fn parse_stmt_path_start(&mut self, lo: Span, attrs: Vec<Attribute>) -> PResult<'a, Stmt> {\n@@ -107,7 +139,7 @@ impl<'a> Parser<'a> {\n \n         let kind = if delim == token::Brace || self.token == token::Semi || self.token == token::Eof\n         {\n-            StmtKind::MacCall(P(MacCallStmt { mac, style, attrs }))\n+            StmtKind::MacCall(P(MacCallStmt { mac, style, attrs, tokens: None }))\n         } else {\n             // Since none of the above applied, this is an expression statement macro.\n             let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac), AttrVec::new());\n@@ -219,7 +251,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n         let hi = if self.token == token::Semi { self.token.span } else { self.prev_token.span };\n-        Ok(P(ast::Local { ty, pat, init, id: DUMMY_NODE_ID, span: lo.to(hi), attrs }))\n+        Ok(P(ast::Local { ty, pat, init, id: DUMMY_NODE_ID, span: lo.to(hi), attrs, tokens: None }))\n     }\n \n     /// Parses the RHS of a local variable declaration (e.g., '= 14;').\n@@ -376,6 +408,12 @@ impl<'a> Parser<'a> {\n             None => return Ok(None),\n         };\n \n+        let add_semi_token = |tokens: Option<&mut LazyTokenStream>| {\n+            if let Some(tokens) = tokens {\n+                *tokens = tokens.add_trailing_semi();\n+            }\n+        };\n+\n         let mut eat_semi = true;\n         match stmt.kind {\n             // Expression without semicolon.\n@@ -417,6 +455,7 @@ impl<'a> Parser<'a> {\n                     *expr = self.mk_expr_err(sp);\n                 }\n             }\n+            StmtKind::Expr(_) | StmtKind::MacCall(_) => {}\n             StmtKind::Local(ref mut local) => {\n                 if let Err(e) = self.expect_semi() {\n                     // We might be at the `,` in `let x = foo<bar, baz>;`. Try to recover.\n@@ -430,13 +469,19 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n                 eat_semi = false;\n+                // We just checked that there's a semicolon in the tokenstream,\n+                // so capture it\n+                add_semi_token(local.tokens.as_mut());\n             }\n             StmtKind::Empty => eat_semi = false,\n             _ => {}\n         }\n \n         if eat_semi && self.eat(&token::Semi) {\n             stmt = stmt.add_trailing_semicolon();\n+            // We just checked that we have a semicolon in the tokenstream,\n+            // so capture it\n+            add_semi_token(stmt.tokens_mut());\n         }\n         stmt.span = stmt.span.to(self.prev_token.span);\n         Ok(Some(stmt))\n@@ -447,7 +492,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn mk_stmt(&self, span: Span, kind: StmtKind) -> Stmt {\n-        Stmt { id: DUMMY_NODE_ID, kind, span, tokens: None }\n+        Stmt { id: DUMMY_NODE_ID, kind, span }\n     }\n \n     pub(super) fn mk_stmt_err(&self, span: Span) -> Stmt {"}, {"sha": "e68c5ea53de492bab5bcc5927ce4a65a6349cb50", "filename": "src/test/ui/proc-macro/allowed-attr-stmt-expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/src%2Ftest%2Fui%2Fproc-macro%2Fallowed-attr-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/src%2Ftest%2Fui%2Fproc-macro%2Fallowed-attr-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fallowed-attr-stmt-expr.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -25,6 +25,8 @@ fn print_str(string: &'static str) {\n \n macro_rules! make_stmt {\n     ($stmt:stmt) => {\n+        #[print_attr]\n+        #[allow(unused)]\n         $stmt\n     }\n }"}, {"sha": "189d2383b7bc1288a4255b4a3f4f2f1eb824209f", "filename": "src/test/ui/proc-macro/allowed-attr-stmt-expr.stdout", "status": "modified", "additions": 149, "deletions": 37, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/src%2Ftest%2Fui%2Fproc-macro%2Fallowed-attr-stmt-expr.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/src%2Ftest%2Fui%2Fproc-macro%2Fallowed-attr-stmt-expr.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fallowed-attr-stmt-expr.stdout?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -1,70 +1,111 @@\n+PRINT-ATTR INPUT (DISPLAY): #[allow(unused)] struct Foo { }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Punct {\n+        ch: '#',\n+        spacing: Alone,\n+        span: $DIR/allowed-attr-stmt-expr.rs:29:9: 29:10 (#12),\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"allow\",\n+                span: $DIR/allowed-attr-stmt-expr.rs:29:11: 29:16 (#12),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"unused\",\n+                        span: $DIR/allowed-attr-stmt-expr.rs:29:17: 29:23 (#12),\n+                    },\n+                ],\n+                span: $DIR/allowed-attr-stmt-expr.rs:29:16: 29:24 (#12),\n+            },\n+        ],\n+        span: $DIR/allowed-attr-stmt-expr.rs:29:10: 29:25 (#12),\n+    },\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/allowed-attr-stmt-expr.rs:42:16: 42:22 (#0),\n+    },\n+    Ident {\n+        ident: \"Foo\",\n+        span: $DIR/allowed-attr-stmt-expr.rs:42:23: 42:26 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/allowed-attr-stmt-expr.rs:42:27: 42:29 (#0),\n+    },\n+]\n PRINT-ATTR INPUT (DISPLAY): #[expect_let] let string = \"Hello, world!\" ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Punct {\n         ch: '#',\n         spacing: Alone,\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:45:5: 45:6 (#0),\n     },\n     Group {\n         delimiter: Bracket,\n         stream: TokenStream [\n             Ident {\n                 ident: \"expect_let\",\n-                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/allowed-attr-stmt-expr.rs:45:7: 45:17 (#0),\n             },\n         ],\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:45:6: 45:18 (#0),\n     },\n     Ident {\n         ident: \"let\",\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:46:5: 46:8 (#0),\n     },\n     Ident {\n         ident: \"string\",\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:46:9: 46:15 (#0),\n     },\n     Punct {\n         ch: '=',\n         spacing: Alone,\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:46:16: 46:17 (#0),\n     },\n     Literal {\n         kind: Str,\n         symbol: \"Hello, world!\",\n         suffix: None,\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:46:18: 46:33 (#0),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:46:33: 46:34 (#0),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): #[expect_print_stmt] println ! (\"{}\", string) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Punct {\n         ch: '#',\n         spacing: Alone,\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:49:5: 49:6 (#0),\n     },\n     Group {\n         delimiter: Bracket,\n         stream: TokenStream [\n             Ident {\n                 ident: \"expect_print_stmt\",\n-                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/allowed-attr-stmt-expr.rs:49:7: 49:24 (#0),\n             },\n         ],\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:49:6: 49:25 (#0),\n     },\n     Ident {\n         ident: \"println\",\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:50:5: 50:12 (#0),\n     },\n     Punct {\n         ch: '!',\n         spacing: Alone,\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:50:12: 50:13 (#0),\n     },\n     Group {\n         delimiter: Parenthesis,\n@@ -73,115 +114,186 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n                 kind: Str,\n                 symbol: \"{}\",\n                 suffix: None,\n-                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/allowed-attr-stmt-expr.rs:50:14: 50:18 (#0),\n             },\n             Punct {\n                 ch: ',',\n                 spacing: Alone,\n-                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/allowed-attr-stmt-expr.rs:50:18: 50:19 (#0),\n             },\n             Ident {\n                 ident: \"string\",\n-                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/allowed-attr-stmt-expr.rs:50:20: 50:26 (#0),\n             },\n         ],\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:50:13: 50:27 (#0),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:50:27: 50:28 (#0),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): second_make_stmt ! (#[allow(dead_code)] struct Bar { }) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"second_make_stmt\",\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:53:5: 53:21 (#0),\n     },\n     Punct {\n         ch: '!',\n         spacing: Alone,\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:53:21: 53:22 (#0),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Punct {\n                 ch: '#',\n                 spacing: Alone,\n-                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/allowed-attr-stmt-expr.rs:53:23: 53:24 (#0),\n             },\n             Group {\n                 delimiter: Bracket,\n                 stream: TokenStream [\n                     Ident {\n                         ident: \"allow\",\n-                        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                        span: $DIR/allowed-attr-stmt-expr.rs:53:25: 53:30 (#0),\n                     },\n                     Group {\n                         delimiter: Parenthesis,\n                         stream: TokenStream [\n                             Ident {\n                                 ident: \"dead_code\",\n-                                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                                span: $DIR/allowed-attr-stmt-expr.rs:53:31: 53:40 (#0),\n                             },\n                         ],\n-                        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                        span: $DIR/allowed-attr-stmt-expr.rs:53:30: 53:41 (#0),\n                     },\n                 ],\n-                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/allowed-attr-stmt-expr.rs:53:24: 53:42 (#0),\n             },\n             Ident {\n                 ident: \"struct\",\n-                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/allowed-attr-stmt-expr.rs:53:43: 53:49 (#0),\n             },\n             Ident {\n                 ident: \"Bar\",\n-                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/allowed-attr-stmt-expr.rs:53:50: 53:53 (#0),\n             },\n             Group {\n                 delimiter: Brace,\n                 stream: TokenStream [],\n-                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/allowed-attr-stmt-expr.rs:53:54: 53:56 (#0),\n             },\n         ],\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:53:22: 53:57 (#0),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:53:57: 53:58 (#0),\n     },\n ]\n-PRINT-ATTR INPUT (DISPLAY): #[rustc_dummy] struct Other { }\n+PRINT-ATTR INPUT (DISPLAY): #[allow(unused)] #[allow(dead_code)] struct Bar { }\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Punct {\n         ch: '#',\n         spacing: Alone,\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:29:9: 29:10 (#34),\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"allow\",\n+                span: $DIR/allowed-attr-stmt-expr.rs:29:11: 29:16 (#34),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"unused\",\n+                        span: $DIR/allowed-attr-stmt-expr.rs:29:17: 29:23 (#34),\n+                    },\n+                ],\n+                span: $DIR/allowed-attr-stmt-expr.rs:29:16: 29:24 (#34),\n+            },\n+        ],\n+        span: $DIR/allowed-attr-stmt-expr.rs:29:10: 29:25 (#34),\n+    },\n+    Punct {\n+        ch: '#',\n+        spacing: Alone,\n+        span: $DIR/allowed-attr-stmt-expr.rs:53:23: 53:24 (#0),\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"allow\",\n+                span: $DIR/allowed-attr-stmt-expr.rs:53:25: 53:30 (#0),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"dead_code\",\n+                        span: $DIR/allowed-attr-stmt-expr.rs:53:31: 53:40 (#0),\n+                    },\n+                ],\n+                span: $DIR/allowed-attr-stmt-expr.rs:53:30: 53:41 (#0),\n+            },\n+        ],\n+        span: $DIR/allowed-attr-stmt-expr.rs:53:24: 53:42 (#0),\n+    },\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/allowed-attr-stmt-expr.rs:53:43: 53:49 (#0),\n+    },\n+    Ident {\n+        ident: \"Bar\",\n+        span: $DIR/allowed-attr-stmt-expr.rs:53:50: 53:53 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/allowed-attr-stmt-expr.rs:53:54: 53:56 (#0),\n+    },\n+]\n+PRINT-ATTR INPUT (DISPLAY): #[rustc_dummy] struct Other { } ;\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Punct {\n+        ch: '#',\n+        spacing: Alone,\n+        span: $DIR/allowed-attr-stmt-expr.rs:56:5: 56:6 (#0),\n     },\n     Group {\n         delimiter: Bracket,\n         stream: TokenStream [\n             Ident {\n                 ident: \"rustc_dummy\",\n-                span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/allowed-attr-stmt-expr.rs:56:7: 56:18 (#0),\n             },\n         ],\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:56:6: 56:19 (#0),\n     },\n     Ident {\n         ident: \"struct\",\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:57:5: 57:11 (#0),\n     },\n     Ident {\n         ident: \"Other\",\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:57:12: 57:17 (#0),\n     },\n     Group {\n         delimiter: Brace,\n         stream: TokenStream [],\n-        span: $DIR/allowed-attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/allowed-attr-stmt-expr.rs:57:18: 57:20 (#0),\n+    },\n+    Punct {\n+        ch: ';',\n+        spacing: Alone,\n+        span: $DIR/allowed-attr-stmt-expr.rs:57:20: 57:21 (#0),\n     },\n ]"}, {"sha": "40e5432185223c281f4cf4f141763bd5c5ecb953", "filename": "src/test/ui/proc-macro/attr-stmt-expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/src%2Ftest%2Fui%2Fproc-macro%2Fattr-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/src%2Ftest%2Fui%2Fproc-macro%2Fattr-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattr-stmt-expr.rs?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -24,6 +24,8 @@ fn print_str(string: &'static str) {\n \n macro_rules! make_stmt {\n     ($stmt:stmt) => {\n+        #[print_attr]\n+        #[allow(unused)]\n         $stmt\n     }\n }"}, {"sha": "1cc7d474fcf162884a8dc77938425461275cd83a", "filename": "src/test/ui/proc-macro/attr-stmt-expr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/src%2Ftest%2Fui%2Fproc-macro%2Fattr-stmt-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/src%2Ftest%2Fui%2Fproc-macro%2Fattr-stmt-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattr-stmt-expr.stderr?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -8,7 +8,7 @@ LL |     #[expect_print_expr]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/attr-stmt-expr.rs:55:5\n+  --> $DIR/attr-stmt-expr.rs:57:5\n    |\n LL |     #[expect_expr]\n    |     ^^^^^^^^^^^^^^"}, {"sha": "59543fb0ca3ffb13b1a421863f4c9d3981e5dc97", "filename": "src/test/ui/proc-macro/attr-stmt-expr.stdout", "status": "modified", "additions": 143, "deletions": 36, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/de88bf148b122b27ce48a4a6679c41c834d33019/src%2Ftest%2Fui%2Fproc-macro%2Fattr-stmt-expr.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/de88bf148b122b27ce48a4a6679c41c834d33019/src%2Ftest%2Fui%2Fproc-macro%2Fattr-stmt-expr.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattr-stmt-expr.stdout?ref=de88bf148b122b27ce48a4a6679c41c834d33019", "patch": "@@ -1,70 +1,111 @@\n+PRINT-ATTR INPUT (DISPLAY): #[allow(unused)] struct Foo { }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Punct {\n+        ch: '#',\n+        spacing: Alone,\n+        span: $DIR/attr-stmt-expr.rs:28:9: 28:10 (#12),\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"allow\",\n+                span: $DIR/attr-stmt-expr.rs:28:11: 28:16 (#12),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"unused\",\n+                        span: $DIR/attr-stmt-expr.rs:28:17: 28:23 (#12),\n+                    },\n+                ],\n+                span: $DIR/attr-stmt-expr.rs:28:16: 28:24 (#12),\n+            },\n+        ],\n+        span: $DIR/attr-stmt-expr.rs:28:10: 28:25 (#12),\n+    },\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/attr-stmt-expr.rs:40:16: 40:22 (#0),\n+    },\n+    Ident {\n+        ident: \"Foo\",\n+        span: $DIR/attr-stmt-expr.rs:40:23: 40:26 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/attr-stmt-expr.rs:40:27: 40:29 (#0),\n+    },\n+]\n PRINT-ATTR INPUT (DISPLAY): #[expect_let] let string = \"Hello, world!\" ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Punct {\n         ch: '#',\n         spacing: Alone,\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:43:5: 43:6 (#0),\n     },\n     Group {\n         delimiter: Bracket,\n         stream: TokenStream [\n             Ident {\n                 ident: \"expect_let\",\n-                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/attr-stmt-expr.rs:43:7: 43:17 (#0),\n             },\n         ],\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:43:6: 43:18 (#0),\n     },\n     Ident {\n         ident: \"let\",\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:44:5: 44:8 (#0),\n     },\n     Ident {\n         ident: \"string\",\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:44:9: 44:15 (#0),\n     },\n     Punct {\n         ch: '=',\n         spacing: Alone,\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:44:16: 44:17 (#0),\n     },\n     Literal {\n         kind: Str,\n         symbol: \"Hello, world!\",\n         suffix: None,\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:44:18: 44:33 (#0),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:44:33: 44:34 (#0),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): #[expect_print_stmt] println ! (\"{}\", string) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Punct {\n         ch: '#',\n         spacing: Alone,\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:47:5: 47:6 (#0),\n     },\n     Group {\n         delimiter: Bracket,\n         stream: TokenStream [\n             Ident {\n                 ident: \"expect_print_stmt\",\n-                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/attr-stmt-expr.rs:47:7: 47:24 (#0),\n             },\n         ],\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:47:6: 47:25 (#0),\n     },\n     Ident {\n         ident: \"println\",\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:48:5: 48:12 (#0),\n     },\n     Punct {\n         ch: '!',\n         spacing: Alone,\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:48:12: 48:13 (#0),\n     },\n     Group {\n         delimiter: Parenthesis,\n@@ -73,115 +114,181 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n                 kind: Str,\n                 symbol: \"{}\",\n                 suffix: None,\n-                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/attr-stmt-expr.rs:48:14: 48:18 (#0),\n             },\n             Punct {\n                 ch: ',',\n                 spacing: Alone,\n-                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/attr-stmt-expr.rs:48:18: 48:19 (#0),\n             },\n             Ident {\n                 ident: \"string\",\n-                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/attr-stmt-expr.rs:48:20: 48:26 (#0),\n             },\n         ],\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:48:13: 48:27 (#0),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:48:27: 48:28 (#0),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): second_make_stmt ! (#[allow(dead_code)] struct Bar { }) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"second_make_stmt\",\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:51:5: 51:21 (#0),\n     },\n     Punct {\n         ch: '!',\n         spacing: Alone,\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:51:21: 51:22 (#0),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Punct {\n                 ch: '#',\n                 spacing: Alone,\n-                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/attr-stmt-expr.rs:51:23: 51:24 (#0),\n             },\n             Group {\n                 delimiter: Bracket,\n                 stream: TokenStream [\n                     Ident {\n                         ident: \"allow\",\n-                        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                        span: $DIR/attr-stmt-expr.rs:51:25: 51:30 (#0),\n                     },\n                     Group {\n                         delimiter: Parenthesis,\n                         stream: TokenStream [\n                             Ident {\n                                 ident: \"dead_code\",\n-                                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                                span: $DIR/attr-stmt-expr.rs:51:31: 51:40 (#0),\n                             },\n                         ],\n-                        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                        span: $DIR/attr-stmt-expr.rs:51:30: 51:41 (#0),\n                     },\n                 ],\n-                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/attr-stmt-expr.rs:51:24: 51:42 (#0),\n             },\n             Ident {\n                 ident: \"struct\",\n-                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/attr-stmt-expr.rs:51:43: 51:49 (#0),\n             },\n             Ident {\n                 ident: \"Bar\",\n-                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/attr-stmt-expr.rs:51:50: 51:53 (#0),\n             },\n             Group {\n                 delimiter: Brace,\n                 stream: TokenStream [],\n-                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/attr-stmt-expr.rs:51:54: 51:56 (#0),\n             },\n         ],\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:51:22: 51:57 (#0),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:51:57: 51:58 (#0),\n+    },\n+]\n+PRINT-ATTR INPUT (DISPLAY): #[allow(unused)] #[allow(dead_code)] struct Bar { }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Punct {\n+        ch: '#',\n+        spacing: Alone,\n+        span: $DIR/attr-stmt-expr.rs:28:9: 28:10 (#34),\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"allow\",\n+                span: $DIR/attr-stmt-expr.rs:28:11: 28:16 (#34),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"unused\",\n+                        span: $DIR/attr-stmt-expr.rs:28:17: 28:23 (#34),\n+                    },\n+                ],\n+                span: $DIR/attr-stmt-expr.rs:28:16: 28:24 (#34),\n+            },\n+        ],\n+        span: $DIR/attr-stmt-expr.rs:28:10: 28:25 (#34),\n+    },\n+    Punct {\n+        ch: '#',\n+        spacing: Alone,\n+        span: $DIR/attr-stmt-expr.rs:51:23: 51:24 (#0),\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"allow\",\n+                span: $DIR/attr-stmt-expr.rs:51:25: 51:30 (#0),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"dead_code\",\n+                        span: $DIR/attr-stmt-expr.rs:51:31: 51:40 (#0),\n+                    },\n+                ],\n+                span: $DIR/attr-stmt-expr.rs:51:30: 51:41 (#0),\n+            },\n+        ],\n+        span: $DIR/attr-stmt-expr.rs:51:24: 51:42 (#0),\n+    },\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/attr-stmt-expr.rs:51:43: 51:49 (#0),\n+    },\n+    Ident {\n+        ident: \"Bar\",\n+        span: $DIR/attr-stmt-expr.rs:51:50: 51:53 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/attr-stmt-expr.rs:51:54: 51:56 (#0),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): #[rustc_dummy] struct Other { }\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Punct {\n         ch: '#',\n         spacing: Alone,\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:54:5: 54:6 (#0),\n     },\n     Group {\n         delimiter: Bracket,\n         stream: TokenStream [\n             Ident {\n                 ident: \"rustc_dummy\",\n-                span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+                span: $DIR/attr-stmt-expr.rs:54:7: 54:18 (#0),\n             },\n         ],\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:54:6: 54:19 (#0),\n     },\n     Ident {\n         ident: \"struct\",\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:55:5: 55:11 (#0),\n     },\n     Ident {\n         ident: \"Other\",\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:55:12: 55:17 (#0),\n     },\n     Group {\n         delimiter: Brace,\n         stream: TokenStream [],\n-        span: $DIR/attr-stmt-expr.rs:1:1: 1:1 (#0),\n+        span: $DIR/attr-stmt-expr.rs:55:18: 55:20 (#0),\n     },\n ]"}]}