{"sha": "3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYjQwYzFkOTVkZDNhMTRhZDE0ZDcxZTNlYzg0N2EwYTEwMmJkNDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-28T21:42:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-06T16:42:46Z"}, "message": "add code to persist graph and for unit-testing", "tree": {"sha": "473f22d781cb174039fa85e7206b866f5218128f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/473f22d781cb174039fa85e7206b866f5218128f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "html_url": "https://github.com/rust-lang/rust/commit/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8263c4758e8821d87d4fc300fd30e78457c769f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8263c4758e8821d87d4fc300fd30e78457c769f", "html_url": "https://github.com/rust-lang/rust/commit/d8263c4758e8821d87d4fc300fd30e78457c769f"}], "stats": {"total": 742, "additions": 742, "deletions": 0}, "files": [{"sha": "67c52bb6c36d780eb73719cf3b3a1693edb3bf11", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "patch": "@@ -829,6 +829,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                index,\n                                name,\n                                |tcx| {\n+        time(time_passes,\n+             \"load_dep_graph\",\n+             || rustc_incremental::load_dep_graph(tcx));\n+\n         // passes are timed inside typeck\n         try_with_f!(typeck::check_crate(tcx, trait_map), (tcx, None, analysis));\n \n@@ -962,6 +966,10 @@ pub fn phase_4_translate_to_llvm<'tcx>(tcx: &TyCtxt<'tcx>,\n          \"assert dep graph\",\n          move || rustc_incremental::assert_dep_graph(tcx));\n \n+    time(time_passes,\n+         \"serialize dep graph\",\n+         move || rustc_incremental::save_dep_graph(tcx));\n+\n     translation\n }\n "}, {"sha": "8be8bd60b23673e231ab842cc186e6a5437a4974", "filename": "src/librustc_incremental/persist/data.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The data that we will serialize and deserialize.\n+\n+use rustc::dep_graph::DepNode;\n+use rustc_serialize::{Decoder as RustcDecoder,\n+                      Encodable as RustcEncodable, Encoder as RustcEncoder};\n+\n+use super::directory::DefPathIndex;\n+\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedDepGraph {\n+    pub nodes: Vec<DepNode<DefPathIndex>>,\n+    pub edges: Vec<SerializedEdge>,\n+    pub hashes: Vec<SerializedHash>,\n+}\n+\n+pub type SerializedEdge = (DepNode<DefPathIndex>, DepNode<DefPathIndex>);\n+\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedHash {\n+    pub index: DefPathIndex,\n+\n+    /// the hash itself, computed by `calculate_item_hash`\n+    pub hash: u64,\n+}\n+"}, {"sha": "f4d155962d1f2456706b6dea0667a8d6722ec738", "filename": "src/librustc_incremental/persist/directory.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "patch": "@@ -0,0 +1,118 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code to convert a DefId into a DefPath (when serializing) and then\n+//! back again (when deserializing). Note that the new DefId\n+//! necessarily will not be the same as the old (and of course the\n+//! item might even be removed in the meantime).\n+\n+use rustc::dep_graph::DepNode;\n+use rustc::front::map::DefPath;\n+use rustc::middle::def_id::DefId;\n+use rustc::ty;\n+use rustc::util::nodemap::DefIdMap;\n+use rustc_serialize::{Decoder as RustcDecoder,\n+                      Encodable as RustcEncodable, Encoder as RustcEncoder};\n+use std::fmt::{self, Debug};\n+\n+/// Index into the DefIdDirectory\n+#[derive(Copy, Clone, Debug, PartialOrd, Ord, Hash, PartialEq, Eq,\n+         RustcEncodable, RustcDecodable)]\n+pub struct DefPathIndex {\n+    index: u32\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct DefIdDirectory {\n+    // N.B. don't use Removable here because these def-ids are loaded\n+    // directly without remapping, so loading them should not fail.\n+    paths: Vec<DefPath>\n+}\n+\n+impl DefIdDirectory {\n+    pub fn new() -> DefIdDirectory {\n+        DefIdDirectory { paths: vec![] }\n+    }\n+\n+    pub fn retrace(&self, tcx: &ty::TyCtxt) -> RetracedDefIdDirectory {\n+        let ids = self.paths.iter()\n+                            .map(|path| tcx.map.retrace_path(path))\n+                            .collect();\n+        RetracedDefIdDirectory { ids: ids }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct RetracedDefIdDirectory {\n+    ids: Vec<Option<DefId>>\n+}\n+\n+impl RetracedDefIdDirectory {\n+    pub fn def_id(&self, index: DefPathIndex) -> Option<DefId> {\n+        self.ids[index.index as usize]\n+    }\n+\n+    pub fn map(&self, node: DepNode<DefPathIndex>) -> Option<DepNode<DefId>> {\n+        node.map_def(|&index| self.def_id(index))\n+    }\n+}\n+\n+pub struct DefIdDirectoryBuilder<'a,'tcx:'a> {\n+    tcx: &'a ty::TyCtxt<'tcx>,\n+    hash: DefIdMap<Option<DefPathIndex>>,\n+    directory: DefIdDirectory,\n+}\n+\n+impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n+    pub fn new(tcx: &'a ty::TyCtxt<'tcx>) -> DefIdDirectoryBuilder<'a, 'tcx> {\n+        DefIdDirectoryBuilder {\n+            tcx: tcx,\n+            hash: DefIdMap(),\n+            directory: DefIdDirectory::new()\n+        }\n+    }\n+\n+    pub fn add(&mut self, def_id: DefId) -> Option<DefPathIndex> {\n+        if !def_id.is_local() {\n+            // FIXME(#32015) clarify story about cross-crate dep tracking\n+            return None;\n+        }\n+\n+        let tcx = self.tcx;\n+        let paths = &mut self.directory.paths;\n+        self.hash.entry(def_id)\n+                 .or_insert_with(|| {\n+                     let def_path = tcx.def_path(def_id);\n+                     if !def_path.is_local() {\n+                         return None;\n+                     }\n+                     let index = paths.len() as u32;\n+                     paths.push(def_path);\n+                     Some(DefPathIndex { index: index })\n+                 })\n+                 .clone()\n+    }\n+\n+    pub fn map(&mut self, node: DepNode<DefId>) -> Option<DepNode<DefPathIndex>> {\n+        node.map_def(|&def_id| self.add(def_id))\n+    }\n+\n+    pub fn into_directory(self) -> DefIdDirectory {\n+        self.directory\n+    }\n+}\n+\n+impl Debug for DefIdDirectory {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        fmt.debug_list()\n+           .entries(self.paths.iter().enumerate())\n+           .finish()\n+    }\n+}"}, {"sha": "0aeddd5b7c87944345ea91daa65e7a37f46e71bd", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "patch": "@@ -0,0 +1,151 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Debugging code to test the state of the dependency graph just\n+//! after it is loaded from disk. For each node marked with\n+//! `#[rustc_clean]` or `#[rustc_dirty]`, we will check that a\n+//! suitable node for that item either appears or does not appear in\n+//! the dep-graph, as appropriate:\n+//!\n+//! - `#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rev2\")]` if we are\n+//!   in `#[cfg(rev2)]`, then there MUST NOT be a node\n+//!   `DepNode::TypeckItemBody(X)` where `X` is the def-id of the\n+//!   current node.\n+//! - `#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rev2\")]` same as above,\n+//!   except that the node MUST exist.\n+//!\n+//! Errors are reported if we are in the suitable configuration but\n+//! the required condition is not met.\n+\n+use rustc::dep_graph::{DepGraphQuery, DepNode};\n+use rustc::middle::def_id::DefId;\n+use rustc_front::hir;\n+use rustc_front::intravisit::Visitor;\n+use syntax::ast::{self, Attribute, MetaItem};\n+use syntax::attr::AttrMetaMethods;\n+use syntax::parse::token::InternedString;\n+use rustc::ty;\n+\n+const DIRTY: &'static str = \"rustc_dirty\";\n+const CLEAN: &'static str = \"rustc_clean\";\n+const LABEL: &'static str = \"label\";\n+const CFG: &'static str = \"cfg\";\n+\n+pub fn check_dirty_clean_annotations(tcx: &ty::TyCtxt) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+    let query = tcx.dep_graph.query();\n+    let krate = tcx.map.krate();\n+    krate.visit_all_items(&mut DirtyCleanVisitor {\n+        tcx: tcx,\n+        query: &query,\n+    });\n+}\n+\n+pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n+    tcx: &'a ty::TyCtxt<'tcx>,\n+    query: &'a DepGraphQuery<DefId>,\n+}\n+\n+impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n+    fn expect_associated_value(&self, item: &MetaItem) -> InternedString {\n+        if let Some(value) = item.value_str() {\n+            value\n+        } else {\n+            self.tcx.sess.span_fatal(\n+                item.span,\n+                &format!(\"associated value expected for `{}`\", item.name()));\n+        }\n+    }\n+\n+    /// Given a `#[rustc_dirty]` or `#[rustc_clean]` attribute, scan\n+    /// for a `cfg=\"foo\"` attribute and check whether we have a cfg\n+    /// flag called `foo`.\n+    fn check_config(&self, attr: &ast::Attribute) -> bool {\n+        debug!(\"check_config(attr={:?})\", attr);\n+        let config = &self.tcx.map.krate().config;\n+        debug!(\"check_config: config={:?}\", config);\n+        for item in attr.meta_item_list().unwrap_or(&[]) {\n+            if item.check_name(CFG) {\n+                let value = self.expect_associated_value(item);\n+                debug!(\"check_config: searching for cfg {:?}\", value);\n+                for cfg in &config[..] {\n+                    if cfg.check_name(&value[..]) {\n+                        debug!(\"check_config: matched {:?}\", cfg);\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        debug!(\"check_config: no match found\");\n+        return false;\n+    }\n+\n+    fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode<DefId> {\n+        for item in attr.meta_item_list().unwrap_or(&[]) {\n+            if item.check_name(LABEL) {\n+                let value = self.expect_associated_value(item);\n+                match DepNode::from_label_string(&value[..], def_id) {\n+                    Ok(def_id) => return def_id,\n+                    Err(()) => {\n+                        self.tcx.sess.span_fatal(\n+                            item.span,\n+                            &format!(\"dep-node label `{}` not recognized\", value));\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.tcx.sess.span_fatal(attr.span, \"no `label` found\");\n+    }\n+\n+    fn dep_node_str(&self, dep_node: DepNode<DefId>) -> DepNode<String> {\n+        dep_node.map_def(|&def_id| Some(self.tcx.item_path_str(def_id))).unwrap()\n+    }\n+\n+    fn assert_dirty(&self, item: &hir::Item, dep_node: DepNode<DefId>) {\n+        debug!(\"assert_dirty({:?})\", dep_node);\n+\n+        if self.query.contains_node(&dep_node) {\n+            let dep_node_str = self.dep_node_str(dep_node);\n+            self.tcx.sess.span_err(\n+                item.span,\n+                &format!(\"`{:?}` found in dep graph, but should be dirty\", dep_node_str));\n+        }\n+    }\n+\n+    fn assert_clean(&self, item: &hir::Item, dep_node: DepNode<DefId>) {\n+        debug!(\"assert_clean({:?})\", dep_node);\n+\n+        if !self.query.contains_node(&dep_node) {\n+            let dep_node_str = self.dep_node_str(dep_node);\n+            self.tcx.sess.span_err(\n+                item.span,\n+                &format!(\"`{:?}` not found in dep graph, but should be clean\", dep_node_str));\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let def_id = self.tcx.map.local_def_id(item.id);\n+        for attr in self.tcx.get_attrs(def_id).iter() {\n+            if attr.check_name(DIRTY) {\n+                if self.check_config(attr) {\n+                    self.assert_dirty(item, self.dep_node(attr, def_id));\n+                }\n+            } else if attr.check_name(CLEAN) {\n+                if self.check_config(attr) {\n+                    self.assert_clean(item, self.dep_node(attr, def_id));\n+                }\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "588113e2eaaad05a723146da292d21dfd60df9f1", "filename": "src/librustc_incremental/persist/load.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "patch": "@@ -0,0 +1,221 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code to save/load the dep-graph from files.\n+\n+\n+use calculate_svh::SvhCalculate;\n+use rbml::{self, Doc};\n+use rbml::reader::{self, DecodeResult, Decoder};\n+use rustc::dep_graph::DepNode;\n+use rustc::middle::def_id::DefId;\n+use rustc::ty;\n+use rustc_data_structures::fnv::FnvHashSet;\n+use rustc_serialize::Decodable as RustcDecodable;\n+use std::io::Read;\n+use std::fs::File;\n+use std::path::Path;\n+\n+use super::data::*;\n+use super::directory::*;\n+use super::dirty_clean;\n+use super::util::*;\n+\n+type DirtyNodes = FnvHashSet<DepNode<DefId>>;\n+\n+type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n+\n+pub fn load_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n+    if let Some(dep_graph) = dep_graph_path(tcx) {\n+        load_dep_graph_if_exists(tcx, &dep_graph);\n+        dirty_clean::check_dirty_clean_annotations(tcx);\n+    }\n+}\n+\n+pub fn load_dep_graph_if_exists<'tcx>(tcx: &ty::TyCtxt<'tcx>, path: &Path) {\n+    if !path.exists() {\n+        return;\n+    }\n+\n+    let mut data = vec![];\n+    match\n+        File::open(path)\n+        .and_then(|mut file| file.read_to_end(&mut data))\n+    {\n+        Ok(_) => { }\n+        Err(err) => {\n+            tcx.sess.err(\n+                &format!(\"could not load dep-graph from `{}`: {}\",\n+                         path.display(), err));\n+            return;\n+        }\n+    }\n+\n+    match decode_dep_graph(tcx, Doc::new(&data)) {\n+        Ok(dirty) => dirty,\n+        Err(err) => {\n+            tcx.sess.bug(\n+                &format!(\"decoding error in dep-graph from `{}`: {}\",\n+                         path.display(), err));\n+        }\n+    }\n+}\n+\n+pub fn decode_dep_graph<'tcx, 'doc>(tcx: &ty::TyCtxt<'tcx>, doc: rbml::Doc<'doc>)\n+                                    -> DecodeResult<()>\n+{\n+    // First load the directory, which maps the def-ids found\n+    // elsewhere into `DefPath`. We can then refresh the `DefPath` to\n+    // obtain updated def-ids.\n+    let directory = {\n+        let directory_doc = reader::get_doc(doc, DIRECTORY_TAG);\n+        let mut decoder = Decoder::new(directory_doc);\n+        try!(DefIdDirectory::decode(&mut decoder))\n+    };\n+\n+    debug!(\"decode_dep_graph: directory = {:#?}\", directory);\n+\n+    // Retrace those paths to find their current location (if any).\n+    let retraced = directory.retrace(tcx);\n+\n+    debug!(\"decode_dep_graph: retraced = {:#?}\", retraced);\n+\n+    // Deserialize the dep-graph (which will include DefPathIndex entries)\n+    let serialized_dep_graph = {\n+        let dep_graph_doc = reader::get_doc(doc, DEP_GRAPH_TAG);\n+        let mut decoder = Decoder::new(dep_graph_doc);\n+        try!(SerializedDepGraph::decode(&mut decoder))\n+    };\n+\n+    debug!(\"decode_dep_graph: serialized_dep_graph = {:#?}\", serialized_dep_graph);\n+\n+    // Compute the set of Hir nodes whose data has changed.\n+    let mut dirty_nodes =\n+        initial_dirty_nodes(tcx, &serialized_dep_graph.hashes, &retraced);\n+\n+    debug!(\"decode_dep_graph: initial dirty_nodes = {:#?}\", dirty_nodes);\n+\n+    // Find all DepNodes reachable from that core set. This loop\n+    // iterates repeatedly over the list of edges whose source is not\n+    // known to be dirty (`clean_edges`). If it finds an edge whose\n+    // source is dirty, it removes it from that list and adds the\n+    // target to `dirty_nodes`. It stops when it reaches a fixed\n+    // point.\n+    let clean_edges = compute_clean_edges(&serialized_dep_graph.edges,\n+                                          &retraced,\n+                                          &mut dirty_nodes);\n+\n+    // Add synthetic `foo->foo` edges for each clean node `foo` that\n+    // we had before. This is sort of a hack to create clean nodes in\n+    // the graph, since the existence of a node is a signal that the\n+    // work it represents need not be repeated.\n+    let clean_nodes =\n+        serialized_dep_graph.nodes\n+                            .iter()\n+                            .filter_map(|&node| retraced.map(node))\n+                            .filter(|node| !dirty_nodes.contains(node))\n+                            .map(|node| (node, node));\n+\n+    // Add nodes and edges that are not dirty into our main graph.\n+    let dep_graph = tcx.dep_graph.clone();\n+    for (source, target) in clean_edges.into_iter().chain(clean_nodes) {\n+        let _task = dep_graph.in_task(target);\n+        dep_graph.read(source);\n+\n+        debug!(\"decode_dep_graph: clean edge: {:?} -> {:?}\", source, target);\n+    }\n+\n+    Ok(())\n+}\n+\n+fn initial_dirty_nodes<'tcx>(tcx: &ty::TyCtxt<'tcx>,\n+                             hashed_items: &[SerializedHash],\n+                             retraced: &RetracedDefIdDirectory)\n+                             -> DirtyNodes {\n+    let mut items_removed = false;\n+    let mut dirty_nodes = FnvHashSet();\n+    for hashed_item in hashed_items {\n+        match retraced.def_id(hashed_item.index) {\n+            Some(def_id) => {\n+                let current_hash = tcx.calculate_item_hash(def_id);\n+                debug!(\"initial_dirty_nodes: hash of {:?} is {:?}, was {:?}\",\n+                       def_id, current_hash, hashed_item.hash);\n+                if current_hash != hashed_item.hash {\n+                    dirty_nodes.insert(DepNode::Hir(def_id));\n+                }\n+            }\n+            None => {\n+                items_removed = true;\n+            }\n+        }\n+    }\n+\n+    // If any of the items in the krate have changed, then we consider\n+    // the meta-node `Krate` to be dirty, since that means something\n+    // which (potentially) read the contents of every single item.\n+    if items_removed || !dirty_nodes.is_empty() {\n+        dirty_nodes.insert(DepNode::Krate);\n+    }\n+\n+    dirty_nodes\n+}\n+\n+fn compute_clean_edges(serialized_edges: &[(SerializedEdge)],\n+                       retraced: &RetracedDefIdDirectory,\n+                       dirty_nodes: &mut DirtyNodes)\n+                       -> CleanEdges {\n+    // Build up an initial list of edges. Include an edge (source,\n+    // target) if neither node has been removed. If the source has\n+    // been removed, add target to the list of dirty nodes.\n+    let mut clean_edges = Vec::with_capacity(serialized_edges.len());\n+    for &(serialized_source, serialized_target) in serialized_edges {\n+        if let Some(target) = retraced.map(serialized_target) {\n+            if let Some(source) = retraced.map(serialized_source) {\n+                clean_edges.push((source, target))\n+            } else {\n+                // source removed, target must be dirty\n+                dirty_nodes.insert(target);\n+            }\n+        } else {\n+            // target removed, ignore the edge\n+        }\n+    }\n+\n+    debug!(\"compute_clean_edges: dirty_nodes={:#?}\", dirty_nodes);\n+\n+    // Propagate dirty marks by iterating repeatedly over\n+    // `clean_edges`. If we find an edge `(source, target)` where\n+    // `source` is dirty, add `target` to the list of dirty nodes and\n+    // remove it. Keep doing this until we find no more dirty nodes.\n+    let mut previous_size = 0;\n+    while dirty_nodes.len() > previous_size {\n+        debug!(\"compute_clean_edges: previous_size={}\", previous_size);\n+        previous_size = dirty_nodes.len();\n+        let mut i = 0;\n+        while i < clean_edges.len() {\n+            if dirty_nodes.contains(&clean_edges[i].0) {\n+                let (source, target) = clean_edges.swap_remove(i);\n+                debug!(\"compute_clean_edges: dirty source {:?} -> {:?}\",\n+                       source, target);\n+                dirty_nodes.insert(target);\n+            } else if dirty_nodes.contains(&clean_edges[i].1) {\n+                let (source, target) = clean_edges.swap_remove(i);\n+                debug!(\"compute_clean_edges: dirty target {:?} -> {:?}\",\n+                       source, target);\n+            } else {\n+                i += 1;\n+            }\n+        }\n+    }\n+\n+    clean_edges\n+}"}, {"sha": "8d04fd30a1920e0bab4a74e4345bfbe6aa4e06f8", "filename": "src/librustc_incremental/persist/mod.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! When in incremental mode, this pass dumps out the dependency graph\n+//! into the given directory. At the same time, it also hashes the\n+//! various HIR nodes.\n+\n+mod data;\n+mod directory;\n+mod dirty_clean;\n+mod load;\n+mod save;\n+mod util;\n+\n+pub use self::load::load_dep_graph;\n+pub use self::save::save_dep_graph;"}, {"sha": "23889c7bbfc1bfba05c174025cb195c5601fe214", "filename": "src/librustc_incremental/persist/save.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use calculate_svh::SvhCalculate;\n+use rbml::writer::{EncodeResult, Encoder};\n+use rustc::dep_graph::DepNode;\n+use rustc::ty;\n+use rustc_serialize::{Encodable as RustcEncodable};\n+use std::io::{Cursor, Write};\n+use std::fs::{self, File};\n+\n+use super::data::*;\n+use super::directory::*;\n+use super::util::*;\n+\n+pub fn save_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n+    if let Some(dep_graph) = dep_graph_path(tcx) {\n+        // delete the old dep-graph, if any\n+        if dep_graph.exists() {\n+            match fs::remove_file(&dep_graph) {\n+                Ok(()) => { }\n+                Err(err) => {\n+                    tcx.sess.err(\n+                        &format!(\"unable to delete old dep-graph at `{}`: {}\",\n+                                 dep_graph.display(), err));\n+                    return;\n+                }\n+            }\n+        }\n+\n+        // generate the data in a memory buffer\n+        let mut wr = Cursor::new(Vec::new());\n+        match encode_dep_graph(tcx, &mut Encoder::new(&mut wr)) {\n+            Ok(()) => { }\n+            Err(err) => {\n+                tcx.sess.err(\n+                    &format!(\"could not encode dep-graph to `{}`: {}\",\n+                             dep_graph.display(), err));\n+                return;\n+            }\n+        }\n+\n+        // write the data out\n+        let data = wr.into_inner();\n+        match\n+            File::create(&dep_graph)\n+            .and_then(|mut file| file.write_all(&data))\n+        {\n+            Ok(_) => { }\n+            Err(err) => {\n+                tcx.sess.err(\n+                    &format!(\"failed to write dep-graph to `{}`: {}\",\n+                             dep_graph.display(), err));\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n+pub fn encode_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>,\n+                              encoder: &mut Encoder)\n+                              -> EncodeResult\n+{\n+    // Here we take advantage of how RBML allows us to skip around\n+    // and encode the depgraph as a two-part structure:\n+    //\n+    // ```\n+    // <dep-graph>[SerializedDepGraph]</dep-graph> // tag 0\n+    // <directory>[DefIdDirectory]</directory>     // tag 1\n+    // ```\n+    //\n+    // Then later we can load the directory by skipping to find tag 1.\n+\n+    let query = tcx.dep_graph.query();\n+\n+    let mut builder = DefIdDirectoryBuilder::new(tcx);\n+\n+    // Create hashes for things we can persist.\n+    let hashes =\n+        query.nodes()\n+             .into_iter()\n+             .filter_map(|dep_node| match dep_node {\n+                 DepNode::Hir(def_id) => {\n+                     assert!(def_id.is_local());\n+                     builder.add(def_id)\n+                            .map(|index| {\n+                                let hash = tcx.calculate_item_hash(def_id);\n+                                SerializedHash { index: index, hash: hash }\n+                            })\n+                 }\n+                 _ => None\n+             })\n+             .collect();\n+\n+    // Create the serialized dep-graph, dropping nodes that are\n+    // from other crates or from inlined items.\n+    //\n+    // FIXME(#32015) fix handling of other crates\n+    let graph = SerializedDepGraph {\n+        nodes: query.nodes().into_iter()\n+                            .flat_map(|node| builder.map(node))\n+                            .collect(),\n+        edges: query.edges().into_iter()\n+                            .flat_map(|(source_node, target_node)| {\n+                                builder.map(source_node)\n+                                       .and_then(|source| {\n+                                           builder.map(target_node)\n+                                                  .map(|target| (source, target))\n+                                       })\n+                            })\n+                            .collect(),\n+        hashes: hashes,\n+    };\n+\n+    debug!(\"graph = {:#?}\", graph);\n+\n+    // Encode the graph data into RBML.\n+    try!(encoder.start_tag(DEP_GRAPH_TAG));\n+    try!(graph.encode(encoder));\n+    try!(encoder.end_tag());\n+\n+    // Now encode the directory.\n+    let directory = builder.into_directory();\n+\n+    debug!(\"directory = {:#?}\", directory);\n+\n+    try!(encoder.start_tag(DIRECTORY_TAG));\n+    try!(directory.encode(encoder));\n+    try!(encoder.end_tag());\n+\n+    Ok(())\n+}\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/librustc_incremental/persist/serialize.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fserialize.rs?ref=3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49"}, {"sha": "11cc55950ca7a4e2991a58f007432a150278d495", "filename": "src/librustc_incremental/persist/util.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Futil.rs?ref=3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty;\n+use std::fs;\n+use std::path::PathBuf;\n+\n+pub const DEP_GRAPH_TAG: usize = 0x100;\n+\n+pub const DIRECTORY_TAG: usize = DEP_GRAPH_TAG + 1;\n+\n+pub fn dep_graph_path<'tcx>(tcx: &ty::TyCtxt<'tcx>) -> Option<PathBuf> {\n+    // For now, just save/load dep-graph from\n+    // directory/dep_graph.rbml\n+    tcx.sess.opts.incremental.as_ref().and_then(|incr_dir| {\n+        match fs::create_dir_all(&incr_dir){\n+            Ok(()) => {}\n+            Err(err) => {\n+                tcx.sess.err(\n+                    &format!(\"could not create the directory `{}`: {}\",\n+                             incr_dir.display(), err));\n+                return None;\n+            }\n+        }\n+\n+        Some(incr_dir.join(\"dep_graph.rbml\"))\n+    })\n+}\n+"}, {"sha": "f08d3c685bb55a48e1ad02af0fbdf069d8b60708", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3fb40c1d95dd3a14ad14d71e3ec847a0a102bd49", "patch": "@@ -356,6 +356,14 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                        \"the `#[rustc_if_this_changed]` attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\")),\n+    (\"rustc_dirty\", Whitelisted, Gated(\"rustc_attrs\",\n+                                       \"the `#[rustc_dirty]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\")),\n+    (\"rustc_clean\", Whitelisted, Gated(\"rustc_attrs\",\n+                                       \"the `#[rustc_clean]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\")),\n     (\"rustc_symbol_name\", Whitelisted, Gated(\"rustc_attrs\",\n                                        \"internal rustc attributes will never be stable\")),\n     (\"rustc_item_path\", Whitelisted, Gated(\"rustc_attrs\","}]}