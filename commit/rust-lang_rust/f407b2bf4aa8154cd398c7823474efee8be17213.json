{"sha": "f407b2bf4aa8154cd398c7823474efee8be17213", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MDdiMmJmNGFhODE1NGNkMzk4Yzc4MjM0NzRlZmVlOGJlMTcyMTM=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-09-29T23:58:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-29T23:58:51Z"}, "message": "Rollup merge of #44124 - gaurikholkar:return_self, r=arielb1\n\nadding E0623 for return types - both parameters are anonymous\n\nThis is a fix for #44018\n```\nerror[E0621]: explicit lifetime required in the type of `self`\n  --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:17:5\n   |\n16 |   fn foo<'a>(&self, x: &i32) -> &i32 {\n   |                        ----     ----\n   |                        |\n   |                        this parameter and the return type are\n                            declared with different lifetimes...\n17 |     x\n   |     ^ ...but data from `x` is returned here\n\nerror: aborting due to previous error\n```\nIt also works for the below case where we have self as anonymous\n\n```\nerror[E0623]: lifetime mismatch\n  --> src/test/ui/lifetime-errors/ex3-both-anon-regions-self-is-anon.rs:17:19\n   |\n16 |     fn foo<'a>(&self, x: &Foo) -> &Foo {\n   |                          ----     ----\n   |                          |\n   |                          this parameter and the return type are\n                            declared with different lifetimes...\n17 |         if true { x } else { self }\n   |                   ^ ...but data from `x` is returned here\n\nerror: aborting due to previous error\n```\nr? @nikomatsakis\n\nCurrently, I have enabled E0621 where return type and self are anonymous, hence WIP.", "tree": {"sha": "e363a7b8f2a255bb7d8645ca94c461917fcc84c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e363a7b8f2a255bb7d8645ca94c461917fcc84c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f407b2bf4aa8154cd398c7823474efee8be17213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f407b2bf4aa8154cd398c7823474efee8be17213", "html_url": "https://github.com/rust-lang/rust/commit/f407b2bf4aa8154cd398c7823474efee8be17213", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f407b2bf4aa8154cd398c7823474efee8be17213/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f87d20a7cce70b8cc59a1adf3037d14bc83f237", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f87d20a7cce70b8cc59a1adf3037d14bc83f237", "html_url": "https://github.com/rust-lang/rust/commit/6f87d20a7cce70b8cc59a1adf3037d14bc83f237"}, {"sha": "73543d53cd01899df38ce71b883ed820c5822fba", "url": "https://api.github.com/repos/rust-lang/rust/commits/73543d53cd01899df38ce71b883ed820c5822fba", "html_url": "https://github.com/rust-lang/rust/commit/73543d53cd01899df38ce71b883ed820c5822fba"}], "stats": {"total": 390, "additions": 141, "deletions": 249}, "files": [{"sha": "26f56ffacae7fd5c7a53968045d39991678488bc", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 68, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -1351,74 +1351,6 @@ struct Foo<T: 'static> {\n ```\n \"##,\n \n-E0312: r##\"\n-A lifetime of reference outlives lifetime of borrowed content.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0312\n-fn make_child<'tree, 'human>(\n-  x: &'human i32,\n-  y: &'tree i32\n-) -> &'human i32 {\n-    if x > y\n-       { x }\n-    else\n-       { y }\n-       // error: lifetime of reference outlives lifetime of borrowed content\n-}\n-```\n-\n-The function declares that it returns a reference with the `'human`\n-lifetime, but it may return data with the `'tree` lifetime. As neither\n-lifetime is declared longer than the other, this results in an\n-error. Sometimes, this error is because the function *body* is\n-incorrect -- that is, maybe you did not *mean* to return data from\n-`y`. In that case, you should fix the function body.\n-\n-Often, however, the body is correct. In that case, the function\n-signature needs to be altered to match the body, so that the caller\n-understands that data from either `x` or `y` may be returned. The\n-simplest way to do this is to give both function parameters the *same*\n-named lifetime:\n-\n-```\n-fn make_child<'human>(\n-  x: &'human i32,\n-  y: &'human i32\n-) -> &'human i32 {\n-    if x > y\n-       { x }\n-    else\n-       { y } // ok!\n-}\n-```\n-\n-However, in some cases, you may prefer to explicitly declare that one lifetime\n-outlives another using a `where` clause:\n-\n-```\n-fn make_child<'tree, 'human>(\n-  x: &'human i32,\n-  y: &'tree i32\n-) -> &'human i32\n-where\n-  'tree: 'human\n-{\n-    if x > y\n-       { x }\n-    else\n-       { y } // ok!\n-}\n-```\n-\n-Here, the where clause `'tree: 'human` can be read as \"the lifetime\n-'tree outlives the lifetime 'human\" -- meaning, references with the\n-`'tree` lifetime live *at least as long as* references with the\n-`'human` lifetime. Therefore, it is safe to return data with lifetime\n-`'tree` when data with the lifetime `'human` is needed.\n-\"##,\n-\n E0317: r##\"\n This error occurs when an `if` expression without an `else` block is used in a\n context where a type other than `()` is expected, for example a `let`\n@@ -2028,6 +1960,7 @@ register_diagnostics! {\n //  E0304, // expected signed integer constant\n //  E0305, // expected constant\n     E0311, // thing may not live long enough\n+    E0312, // lifetime of reference outlives lifetime of borrowed content\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime"}, {"sha": "ee30db26255198ad1b3b361b17b06fd1ad5aa587", "filename": "src/librustc/infer/error_reporting/different_lifetimes.rs", "status": "modified", "additions": 71, "deletions": 51, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -18,6 +18,7 @@ use infer::region_inference::RegionResolutionError;\n use hir::map as hir_map;\n use middle::resolve_lifetime as rl;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use infer::error_reporting::util::AnonymousArgInfo;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // This method prints the error message for lifetime errors when both the concerned regions\n@@ -57,6 +58,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let ty_sup = or_false!(self.find_anon_type(sup, &bregion_sup));\n \n         let ty_sub = or_false!(self.find_anon_type(sub, &bregion_sub));\n+\n         debug!(\"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n                ty_sub,\n                sup,\n@@ -66,56 +68,70 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                sub,\n                bregion_sub);\n \n-        let (main_label, label1, label2) = if let (Some(sup_arg), Some(sub_arg)) =\n-            (self.find_arg_with_region(sup, sup), self.find_arg_with_region(sub, sub)) {\n+        let (ty_sup, ty_fndecl_sup) = ty_sup;\n+        let (ty_sub, ty_fndecl_sub) = ty_sub;\n \n-            let (anon_arg_sup, is_first_sup, anon_arg_sub, is_first_sub) =\n-                (sup_arg.arg, sup_arg.is_first, sub_arg.arg, sub_arg.is_first);\n-            if self.is_self_anon(is_first_sup, scope_def_id_sup) ||\n-               self.is_self_anon(is_first_sub, scope_def_id_sub) {\n-                return false;\n-            }\n+        let AnonymousArgInfo { arg: anon_arg_sup, .. } =\n+            or_false!(self.find_arg_with_region(sup, sup));\n+        let AnonymousArgInfo { arg: anon_arg_sub, .. } =\n+            or_false!(self.find_arg_with_region(sub, sub));\n \n-            if self.is_return_type_anon(scope_def_id_sup, bregion_sup) ||\n-               self.is_return_type_anon(scope_def_id_sub, bregion_sub) {\n-                return false;\n-            }\n+        let sup_is_ret_type =\n+            self.is_return_type_anon(scope_def_id_sup, bregion_sup, ty_fndecl_sup);\n+        let sub_is_ret_type =\n+            self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-            if anon_arg_sup == anon_arg_sub {\n-                (format!(\"this type was declared with multiple lifetimes...\"),\n-                 format!(\" with one lifetime\"),\n-                 format!(\" into the other\"))\n-            } else {\n-                let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n-                    format!(\" from `{}`\", simple_name)\n-                } else {\n-                    format!(\"\")\n-                };\n+        let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n+            format!(\" from `{}`\", simple_name)\n+        } else {\n+            format!(\"\")\n+        };\n+\n+        let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n+            format!(\" into `{}`\", simple_name)\n+        } else {\n+            format!(\"\")\n+        };\n+\n+\n+        let (span_1, span_2, main_label, span_label) = match (sup_is_ret_type, sub_is_ret_type) {\n+            (None, None) => {\n+                let (main_label_1, span_label_1) = if ty_sup == ty_sub {\n \n-                let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n-                    format!(\" into `{}`\", simple_name)\n+                    (format!(\"this type is declared with multiple lifetimes...\"),\n+                     format!(\"...but data{} flows{} here\",\n+                             format!(\" with one lifetime\"),\n+                             format!(\" into the other\")))\n                 } else {\n-                    format!(\"\")\n+                    (format!(\"these two types are declared with different lifetimes...\"),\n+                     format!(\"...but data{} flows{} here\",\n+                             span_label_var1,\n+                             span_label_var2))\n                 };\n+                (ty_sup.span, ty_sub.span, main_label_1, span_label_1)\n+            }\n \n-                let span_label =\n-                    format!(\"these two types are declared with different lifetimes...\",);\n-\n-                (span_label, span_label_var1, span_label_var2)\n+            (Some(ret_span), _) => {\n+                (ty_sub.span,\n+                 ret_span,\n+                 format!(\"this parameter and the return type are declared \\\n+                          with different lifetimes...\",),\n+                 format!(\"...but data{} is returned here\", span_label_var1))\n+            }\n+            (_, Some(ret_span)) => {\n+                (ty_sup.span,\n+                 ret_span,\n+                 format!(\"this parameter and the return type are declared \\\n+                          with different lifetimes...\",),\n+                 format!(\"...but data{} is returned here\", span_label_var1))\n             }\n-        } else {\n-            debug!(\"no arg with anon region found\");\n-            debug!(\"try_report_anon_anon_conflict: is_suitable(sub) = {:?}\",\n-                   self.is_suitable_region(sub));\n-            debug!(\"try_report_anon_anon_conflict: is_suitable(sup) = {:?}\",\n-                   self.is_suitable_region(sup));\n-            return false;\n         };\n \n+\n         struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n-            .span_label(ty_sup.span, main_label)\n-            .span_label(ty_sub.span, format!(\"\"))\n-            .span_label(span, format!(\"...but data{} flows{} here\", label1, label2))\n+            .span_label(span_1, main_label)\n+            .span_label(span_2, format!(\"\"))\n+            .span_label(span, span_label)\n             .emit();\n         return true;\n     }\n@@ -135,28 +151,32 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// ```\n     /// The function returns the nested type corresponding to the anonymous region\n     /// for e.g. `&u8` and Vec<`&u8`.\n-    pub fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n+    pub fn find_anon_type(&self,\n+                          region: Region<'tcx>,\n+                          br: &ty::BoundRegion)\n+                          -> Option<(&hir::Ty, &hir::FnDecl)> {\n         if let Some(anon_reg) = self.is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let inputs: &[_] = match self.tcx.hir.get(node_id) {\n+                let fndecl = match self.tcx.hir.get(node_id) {\n                     hir_map::NodeItem(&hir::Item { node: hir::ItemFn(ref fndecl, ..), .. }) => {\n-                        &fndecl.inputs\n+                        &fndecl\n                     }\n                     hir_map::NodeTraitItem(&hir::TraitItem {\n-                                               node: hir::TraitItemKind::Method(ref fndecl, ..), ..\n-                                           }) => &fndecl.decl.inputs,\n+                                               node: hir::TraitItemKind::Method(ref m, ..), ..\n+                                           }) |\n                     hir_map::NodeImplItem(&hir::ImplItem {\n-                                              node: hir::ImplItemKind::Method(ref fndecl, ..), ..\n-                                          }) => &fndecl.decl.inputs,\n-\n-                    _ => &[],\n+                                              node: hir::ImplItemKind::Method(ref m, ..), ..\n+                                          }) => &m.decl,\n+                    _ => return None,\n                 };\n \n-                return inputs\n+                return fndecl\n+                           .inputs\n                            .iter()\n-                           .filter_map(|arg| self.find_component_for_bound_region(&**arg, br))\n-                           .next();\n+                           .filter_map(|arg| self.find_component_for_bound_region(arg, br))\n+                           .next()\n+                           .map(|ty| (ty, &**fndecl));\n             }\n         }\n         None"}, {"sha": "80fb4ce8e039260fc7933e0b4bfd37bcc94d2193", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -35,15 +35,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n-        let (named, anon_arg_info, region_info) =\n+        let (named, anon, anon_arg_info, region_info) =\n             if self.is_named_region(sub) && self.is_suitable_region(sup).is_some() &&\n                self.find_arg_with_region(sup, sub).is_some() {\n                 (sub,\n+                 sup,\n                  self.find_arg_with_region(sup, sub).unwrap(),\n                  self.is_suitable_region(sup).unwrap())\n             } else if self.is_named_region(sup) && self.is_suitable_region(sub).is_some() &&\n                       self.find_arg_with_region(sub, sup).is_some() {\n                 (sup,\n+                 sub,\n                  self.find_arg_with_region(sub, sup).unwrap(),\n                  self.is_suitable_region(sub).unwrap())\n             } else {\n@@ -76,33 +78,29 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             return false;\n         }\n \n-        if self.is_return_type_anon(scope_def_id, br) {\n-            debug!(\"try_report_named_anon_conflict: is_return_type_anon({:?}, {:?}) = true\",\n-                   scope_def_id,\n-                   br);\n-            return false;\n-        } else if self.is_self_anon(is_first, scope_def_id) {\n-            debug!(\"try_report_named_anon_conflict: is_self_anon({:?}, {:?}) = true\",\n-                   is_first,\n-                   scope_def_id);\n-            return false;\n+        if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n+            if self.is_return_type_anon(scope_def_id, br, fndecl).is_some() ||\n+               self.is_self_anon(is_first, scope_def_id) {\n+                return false;\n+            }\n+        }\n+\n+        let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n+            (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n         } else {\n-            let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n-                (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n-            } else {\n-                (\"parameter type\".to_owned(), \"type\".to_owned())\n-            };\n+            (\"parameter type\".to_owned(), \"type\".to_owned())\n+        };\n+\n+        struct_span_err!(self.tcx.sess,\n+                         span,\n+                         E0621,\n+                         \"explicit lifetime required in {}\",\n+                         error_var)\n+                .span_label(arg.pat.span,\n+                            format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n+                .span_label(span, format!(\"lifetime `{}` required\", named))\n+                .emit();\n+        return true;\n \n-            struct_span_err!(self.tcx.sess,\n-                             span,\n-                             E0621,\n-                             \"explicit lifetime required in {}\",\n-                             error_var)\n-                    .span_label(arg.pat.span,\n-                                format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n-                    .span_label(span, format!(\"lifetime `{}` required\", named))\n-                    .emit();\n-            return true;\n-        }\n     }\n }"}, {"sha": "47db3f1b7926af1aa38c3b0991edb795cfe6f987", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -15,6 +15,7 @@ use infer::InferCtxt;\n use ty::{self, Region, Ty};\n use hir::def_id::DefId;\n use hir::map as hir_map;\n+use syntax_pos::Span;\n \n macro_rules! or_false {\n      ($v:expr) => {\n@@ -163,20 +164,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // Here, we check for the case where the anonymous region\n     // is in the return type.\n     // FIXME(#42703) - Need to handle certain cases here.\n-    pub fn is_return_type_anon(&self, scope_def_id: DefId, br: ty::BoundRegion) -> bool {\n+    pub fn is_return_type_anon(&self,\n+                               scope_def_id: DefId,\n+                               br: ty::BoundRegion,\n+                               decl: &hir::FnDecl)\n+                               -> Option<Span> {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n         match ret_ty.sty {\n             ty::TyFnDef(_, _) => {\n                 let sig = ret_ty.fn_sig(self.tcx);\n                 let late_bound_regions = self.tcx\n                     .collect_referenced_late_bound_regions(&sig.output());\n                 if late_bound_regions.iter().any(|r| *r == br) {\n-                    return true;\n+                    return Some(decl.output.span());\n                 }\n             }\n             _ => {}\n         }\n-        false\n+        None\n     }\n     // Here we check for the case where anonymous region\n     // corresponds to self and if yes, we display E0312."}, {"sha": "54657e76e97022be4e70a5ce58d7c1eab073a334", "filename": "src/test/compile-fail/object-lifetime-default-mybox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -34,7 +34,7 @@ fn load1<'a,'b>(a: &'a MyBox<SomeTrait>,\n                 b: &'b MyBox<SomeTrait>)\n                 -> &'b MyBox<SomeTrait>\n {\n-    a //~ ERROR E0312\n+    a //~ ERROR lifetime mismatch\n }\n \n fn load2<'a>(ss: &MyBox<SomeTrait+'a>) -> MyBox<SomeTrait+'a> {"}, {"sha": "cb9a1edf1ddf9a8551e12f42c5599ead69bd0190", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-using-impl.stderr", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl.stderr?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -1,27 +1,13 @@\n-error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+error[E0623]: lifetime mismatch\n   --> $DIR/ex1-return-one-existing-name-if-else-using-impl.rs:21:20\n    |\n+19 |     fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n+   |                   ----                 -------\n+   |                   |\n+   |                   this parameter and the return type are declared with different lifetimes...\n+20 | \n 21 |         if x > y { x } else { y }\n-   |                    ^\n-   |\n-note: ...the reference is valid for the lifetime 'a as defined on the method body at 19:5...\n-  --> $DIR/ex1-return-one-existing-name-if-else-using-impl.rs:19:5\n-   |\n-19 | /     fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n-20 | |\n-21 | |         if x > y { x } else { y }\n-22 | |\n-23 | |     }\n-   | |_____^\n-note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the method body at 19:5\n-  --> $DIR/ex1-return-one-existing-name-if-else-using-impl.rs:19:5\n-   |\n-19 | /     fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n-20 | |\n-21 | |         if x > y { x } else { y }\n-22 | |\n-23 | |     }\n-   | |_____^\n+   |                    ^ ...but data from `x` is returned here\n \n error: aborting due to previous error\n "}, {"sha": "8af6acc62c43649c58a468104180409f50135ec7", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-return-type-is-anon.stderr", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -1,27 +1,13 @@\n-error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+error[E0623]: lifetime mismatch\n   --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:18:5\n    |\n+16 |   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n+   |                        -------     ----\n+   |                        |\n+   |                        this parameter and the return type are declared with different lifetimes...\n+17 | \n 18 |     x\n-   |     ^\n-   |\n-note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:3...\n-  --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:16:3\n-   |\n-16 | /   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n-17 | |\n-18 | |     x\n-19 | |\n-20 | |   }\n-   | |___^\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the method body at 16:3\n-  --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:16:3\n-   |\n-16 | /   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n-17 | |\n-18 | |     x\n-19 | |\n-20 | |   }\n-   | |___^\n+   |     ^ ...but data from `x` is returned here\n \n error: aborting due to previous error\n "}, {"sha": "c09de0c33af7a455fbdfd31bbf21db1261072043", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-self-is-anon.stderr", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -1,27 +1,13 @@\n-error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+error[E0623]: lifetime mismatch\n   --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:18:30\n    |\n+16 |     fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n+   |                -----                 -------\n+   |                |\n+   |                this parameter and the return type are declared with different lifetimes...\n+17 | \n 18 |         if true { x } else { self }\n-   |                              ^^^^\n-   |\n-note: ...the reference is valid for the lifetime 'a as defined on the method body at 16:5...\n-  --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:16:5\n-   |\n-16 | /     fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n-17 | |\n-18 | |         if true { x } else { self }\n-19 | |\n-20 | |     }\n-   | |_____^\n-note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the method body at 16:5\n-  --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:16:5\n-   |\n-16 | /     fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n-17 | |\n-18 | |         if true { x } else { self }\n-19 | |\n-20 | |     }\n-   | |_____^\n+   |                              ^^^^ ...but data from `self` is returned here\n \n error: aborting due to previous error\n "}, {"sha": "73460277de44cb9294eab94d883a1298fd2a9f8c", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -4,7 +4,7 @@ error[E0623]: lifetime mismatch\n 15 | fn foo(mut x: Ref) {\n    |               ---\n    |               |\n-   |               this type was declared with multiple lifetimes...\n+   |               this type is declared with multiple lifetimes...\n 16 |     x.a = x.b;\n    |           ^^^ ...but data with one lifetime flows into the other here\n "}, {"sha": "fb524ae62c57ae9e4c19361f6e734ca9cb1a571f", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.stderr?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -4,7 +4,7 @@ error[E0623]: lifetime mismatch\n 15 | fn foo(mut x: Ref) {\n    |               ---\n    |               |\n-   |               this type was declared with multiple lifetimes...\n+   |               this type is declared with multiple lifetimes...\n 16 |     x.a = x.b;\n    |           ^^^ ...but data with one lifetime flows into the other here\n "}, {"sha": "1409b2161330b6615fca9bcbbbfd4afaf676c345", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-return-type-is-anon.stderr", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -1,23 +1,12 @@\n-error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:17:5\n    |\n+16 |   fn foo<'a>(&self, x: &i32) -> &i32 {\n+   |                        ----     ----\n+   |                        |\n+   |                        this parameter and the return type are declared with different lifetimes...\n 17 |     x\n-   |     ^\n-   |\n-note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:3...\n-  --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:16:3\n-   |\n-16 | /   fn foo<'a>(&self, x: &i32) -> &i32 {\n-17 | |     x\n-18 | |   }\n-   | |___^\n-note: ...but the borrowed content is only valid for the anonymous lifetime #2 defined on the method body at 16:3\n-  --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:16:3\n-   |\n-16 | /   fn foo<'a>(&self, x: &i32) -> &i32 {\n-17 | |     x\n-18 | |   }\n-   | |___^\n+   |     ^ ...but data from `x` is returned here\n \n error: aborting due to previous error\n "}, {"sha": "cae45023e26b209526446f9350ac79d5a5ea2579", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-self-is-anon.stderr", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f407b2bf4aa8154cd398c7823474efee8be17213/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr?ref=f407b2bf4aa8154cd398c7823474efee8be17213", "patch": "@@ -1,23 +1,12 @@\n-error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions-self-is-anon.rs:17:19\n    |\n+16 |     fn foo<'a>(&self, x: &Foo) -> &Foo {\n+   |                          ----     ----\n+   |                          |\n+   |                          this parameter and the return type are declared with different lifetimes...\n 17 |         if true { x } else { self }\n-   |                   ^\n-   |\n-note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:5...\n-  --> $DIR/ex3-both-anon-regions-self-is-anon.rs:16:5\n-   |\n-16 | /     fn foo<'a>(&self, x: &Foo) -> &Foo {\n-17 | |         if true { x } else { self }\n-18 | |     }\n-   | |_____^\n-note: ...but the borrowed content is only valid for the anonymous lifetime #2 defined on the method body at 16:5\n-  --> $DIR/ex3-both-anon-regions-self-is-anon.rs:16:5\n-   |\n-16 | /     fn foo<'a>(&self, x: &Foo) -> &Foo {\n-17 | |         if true { x } else { self }\n-18 | |     }\n-   | |_____^\n+   |                   ^ ...but data from `x` is returned here\n \n error: aborting due to previous error\n "}]}