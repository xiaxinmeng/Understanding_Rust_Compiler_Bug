{"sha": "c76222f732f55a77141b9a36710a4be37be9dec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NjIyMmY3MzJmNTVhNzcxNDFiOWEzNjcxMGE0YmUzN2JlOWRlYzA=", "commit": {"author": {"name": "reedlepee", "email": "reedlepee123@gmail.com", "date": "2013-10-22T19:51:03Z"}, "committer": {"name": "reedlepee", "email": "reedlepee123@gmail.com", "date": "2013-10-22T19:51:03Z"}, "message": "Removed the file src/libstd/unstable/extfmt.r", "tree": {"sha": "7e34d987ec9254ca7dfbabcc88089c239371b674", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e34d987ec9254ca7dfbabcc88089c239371b674"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c76222f732f55a77141b9a36710a4be37be9dec0", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c76222f732f55a77141b9a36710a4be37be9dec0", "html_url": "https://github.com/rust-lang/rust/commit/c76222f732f55a77141b9a36710a4be37be9dec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c76222f732f55a77141b9a36710a4be37be9dec0/comments", "author": {"login": "reedlepee123", "id": 5721031, "node_id": "MDQ6VXNlcjU3MjEwMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/5721031?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reedlepee123", "html_url": "https://github.com/reedlepee123", "followers_url": "https://api.github.com/users/reedlepee123/followers", "following_url": "https://api.github.com/users/reedlepee123/following{/other_user}", "gists_url": "https://api.github.com/users/reedlepee123/gists{/gist_id}", "starred_url": "https://api.github.com/users/reedlepee123/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reedlepee123/subscriptions", "organizations_url": "https://api.github.com/users/reedlepee123/orgs", "repos_url": "https://api.github.com/users/reedlepee123/repos", "events_url": "https://api.github.com/users/reedlepee123/events{/privacy}", "received_events_url": "https://api.github.com/users/reedlepee123/received_events", "type": "User", "site_admin": false}, "committer": {"login": "reedlepee123", "id": 5721031, "node_id": "MDQ6VXNlcjU3MjEwMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/5721031?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reedlepee123", "html_url": "https://github.com/reedlepee123", "followers_url": "https://api.github.com/users/reedlepee123/followers", "following_url": "https://api.github.com/users/reedlepee123/following{/other_user}", "gists_url": "https://api.github.com/users/reedlepee123/gists{/gist_id}", "starred_url": "https://api.github.com/users/reedlepee123/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reedlepee123/subscriptions", "organizations_url": "https://api.github.com/users/reedlepee123/orgs", "repos_url": "https://api.github.com/users/reedlepee123/repos", "events_url": "https://api.github.com/users/reedlepee123/events{/privacy}", "received_events_url": "https://api.github.com/users/reedlepee123/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "930ded404ae2e78c15ee0429b82dd7af35db7ce7", "url": "https://api.github.com/repos/rust-lang/rust/commits/930ded404ae2e78c15ee0429b82dd7af35db7ce7", "html_url": "https://github.com/rust-lang/rust/commit/930ded404ae2e78c15ee0429b82dd7af35db7ce7"}], "stats": {"total": 703, "additions": 0, "deletions": 703}, "files": [{"sha": "0131f2c603cdac5c72392bb50e0a5010a5ecfab3", "filename": "src/libstd/unstable/extfmt.rs", "status": "removed", "additions": 0, "deletions": 703, "changes": 703, "blob_url": "https://github.com/rust-lang/rust/blob/930ded404ae2e78c15ee0429b82dd7af35db7ce7/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/930ded404ae2e78c15ee0429b82dd7af35db7ce7/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=930ded404ae2e78c15ee0429b82dd7af35db7ce7", "patch": "@@ -1,703 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Support for fmt! expressions.\n-//!\n-//! The syntax is close to that of Posix format strings:\n-//!\n-//! ~~~~~~\n-//! Format := '%' Parameter? Flag* Width? Precision? Type\n-//! Parameter := [0-9]+ '$'\n-//! Flag := [ 0#+-]\n-//! Width := Parameter | [0-9]+\n-//! Precision := '.' [0-9]+\n-//! Type := [bcdfiostuxX?]\n-//! ~~~~~~\n-//!\n-//! * Parameter is the 1-based argument to apply the format to. Currently not\n-//! implemented.\n-//! * Flag 0 causes leading zeros to be used for padding when converting\n-//! numbers.\n-//! * Flag # causes the conversion to be done in an *alternative* manner.\n-//! Currently not implemented.\n-//! * Flag + causes signed numbers to always be prepended with a sign\n-//! character.\n-//! * Flag - left justifies the result\n-//! * Width specifies the minimum field width of the result. By default\n-//! leading spaces are added.\n-//! * Precision specifies the minimum number of digits for integral types\n-//! and the minimum number\n-//! of decimal places for float.\n-//!\n-//! The types currently supported are:\n-//!\n-//! * b - bool\n-//! * c - char\n-//! * d - int\n-//! * f - float\n-//! * i - int (same as d)\n-//! * o - uint as octal\n-//! * t - uint as binary\n-//! * u - uint\n-//! * x - uint as lower-case hexadecimal\n-//! * X - uint as upper-case hexadecimal\n-//! * s - str (any flavor)\n-//! * ? - arbitrary type (does not use the to_str trait)\n-\n-/*\n-Syntax Extension: fmt\n-\n-Format a string\n-\n-The 'fmt' extension is modeled on the posix printf system.\n-\n-A posix conversion ostensibly looks like this\n-\n-> %~[parameter]~[flags]~[width]~[.precision]~[length]type\n-\n-Given the different numeric type bestiary we have, we omit the 'length'\n-parameter and support slightly different conversions for 'type'\n-\n-> %~[parameter]~[flags]~[width]~[.precision]type\n-\n-we also only support translating-to-rust a tiny subset of the possible\n-combinations at the moment.\n-\n-Example:\n-\n-debug!(\"hello, %s!\", \"world\");\n-\n-*/\n-\n-use prelude::*;\n-\n-/*\n- * We have a 'ct' (compile-time) module that parses format strings into a\n- * sequence of conversions. From those conversions AST fragments are built\n- * that call into properly-typed functions in the 'rt' (run-time) module.\n- * Each of those run-time conversion functions accepts another conversion\n- * description that specifies how to format its output.\n- *\n- * The building of the AST is currently done in a module inside the compiler,\n- * but should migrate over here as the plugin interface is defined.\n- */\n-\n-// Functions used by the fmt extension at compile time\n-#[doc(hidden)]\n-pub mod ct {\n-    use char;\n-    use container::Container;\n-    use prelude::*;\n-    use str;\n-\n-    #[deriving(Eq)]\n-    pub enum Signedness { Signed, Unsigned, }\n-\n-    #[deriving(Eq)]\n-    pub enum Caseness { CaseUpper, CaseLower, }\n-\n-    #[deriving(Eq)]\n-    pub enum Ty {\n-        TyBool,\n-        TyStr,\n-        TyChar,\n-        TyInt(Signedness),\n-        TyBits,\n-        TyHex(Caseness),\n-        TyOctal,\n-        TyFloat,\n-        TyPointer,\n-        TyPoly,\n-    }\n-\n-    #[deriving(Eq)]\n-    pub enum Flag {\n-        FlagLeftJustify,\n-        FlagLeftZeroPad,\n-        FlagSpaceForSign,\n-        FlagSignAlways,\n-        FlagAlternate,\n-    }\n-\n-    #[deriving(Eq)]\n-    pub enum Count {\n-        CountIs(uint),\n-        CountIsParam(uint),\n-        CountIsNextParam,\n-        CountImplied,\n-    }\n-\n-    #[deriving(Eq)]\n-    struct Parsed<T> {\n-        val: T,\n-        next: uint\n-    }\n-\n-    impl<T> Parsed<T> {\n-        pub fn new(val: T, next: uint) -> Parsed<T> {\n-            Parsed {val: val, next: next}\n-        }\n-    }\n-\n-    // A formatted conversion from an expression to a string\n-    #[deriving(Eq)]\n-    pub struct Conv {\n-        param: Option<uint>,\n-        flags: ~[Flag],\n-        width: Count,\n-        precision: Count,\n-        ty: Ty\n-    }\n-\n-    // A fragment of the output sequence\n-    #[deriving(Eq)]\n-    pub enum Piece {\n-        PieceString(~str),\n-        PieceConv(Conv),\n-    }\n-\n-    pub type ErrorFn<'self> = &'self fn(&str) -> !;\n-\n-    pub fn parse_fmt_string<'a>(s: &str, err: ErrorFn<'a>) -> ~[Piece] {\n-        fn push_slice(ps: &mut ~[Piece], s: &str, from: uint, to: uint) {\n-            if to > from {\n-                ps.push(PieceString(s.slice(from, to).to_owned()));\n-            }\n-        }\n-\n-        let lim = s.len();\n-        let mut h = 0;\n-        let mut i = 0;\n-        let mut pieces = ~[];\n-\n-        while i < lim {\n-            if s[i] == '%' as u8 {\n-                i += 1;\n-\n-                if i >= lim {\n-                    err(\"unterminated conversion at end of string\");\n-                } else if s[i] == '%' as u8 {\n-                    push_slice(&mut pieces, s, h, i);\n-                    i += 1;\n-                } else {\n-                    push_slice(&mut pieces, s, h, i - 1);\n-                    let Parsed {\n-                        val,\n-                        next\n-                    } = parse_conversion(s, i, lim, |s| err(s));\n-                    pieces.push(val);\n-                    i = next;\n-                }\n-\n-                h = i;\n-            } else {\n-                i += str::utf8_char_width(s[i]);\n-            }\n-        }\n-\n-        push_slice(&mut pieces, s, h, i);\n-        pieces\n-    }\n-\n-    pub fn peek_num(s: &str, i: uint, lim: uint) -> Option<Parsed<uint>> {\n-        let mut i = i;\n-        let mut accum = 0;\n-        let mut found = false;\n-\n-        while i < lim {\n-            match char::to_digit(s[i] as char, 10) {\n-                Some(x) => {\n-                    found = true;\n-                    accum *= 10;\n-                    accum += x;\n-                    i += 1;\n-                }\n-                None => break\n-            }\n-        }\n-\n-        if found {\n-            Some(Parsed::new(accum, i))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn parse_conversion<'a>(s: &str, i: uint, lim: uint, err: ErrorFn<'a>)\n-                                -> Parsed<Piece> {\n-        let param = parse_parameter(s, i, lim);\n-        // avoid copying ~[Flag] by destructuring\n-        let Parsed {val: flags_val, next: flags_next} = parse_flags(s,\n-            param.next, lim);\n-        let width = parse_count(s, flags_next, lim);\n-        let prec = parse_precision(s, width.next, lim);\n-        let ty = parse_type(s, prec.next, lim, err);\n-\n-        Parsed::new(PieceConv(Conv {\n-            param: param.val,\n-            flags: flags_val,\n-            width: width.val,\n-            precision: prec.val,\n-            ty: ty.val}), ty.next)\n-    }\n-\n-    pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n-        Parsed<Option<uint>> {\n-        if i >= lim { return Parsed::new(None, i); }\n-\n-        match peek_num(s, i, lim) {\n-            Some(num) if num.next < lim && s[num.next] == '$' as u8 =>\n-                Parsed::new(Some(num.val), num.next + 1),\n-            _ => Parsed::new(None, i)\n-        }\n-    }\n-\n-    pub fn parse_flags(s: &str, i: uint, lim: uint) -> Parsed<~[Flag]> {\n-        let mut i = i;\n-        let mut flags = ~[];\n-\n-        while i < lim {\n-            let f = match s[i] as char {\n-                '-' => FlagLeftJustify,\n-                '0' => FlagLeftZeroPad,\n-                ' ' => FlagSpaceForSign,\n-                '+' => FlagSignAlways,\n-                '#' => FlagAlternate,\n-                _ => break\n-            };\n-\n-            flags.push(f);\n-            i += 1;\n-        }\n-\n-        Parsed::new(flags, i)\n-    }\n-\n-    pub fn parse_count(s: &str, i: uint, lim: uint) -> Parsed<Count> {\n-        if i >= lim {\n-            Parsed::new(CountImplied, i)\n-        } else if s[i] == '*' as u8 {\n-            let param = parse_parameter(s, i + 1, lim);\n-            let j = param.next;\n-\n-            match param.val {\n-                None => Parsed::new(CountIsNextParam, j),\n-                Some(n) => Parsed::new(CountIsParam(n), j)\n-            }\n-        } else {\n-            match peek_num(s, i, lim) {\n-                None => Parsed::new(CountImplied, i),\n-                Some(num) => Parsed::new(CountIs(num.val), num.next)\n-            }\n-        }\n-    }\n-\n-    pub fn parse_precision(s: &str, i: uint, lim: uint) -> Parsed<Count> {\n-        if i < lim && s[i] == '.' as u8 {\n-            let count = parse_count(s, i + 1, lim);\n-\n-            // If there were no digits specified, i.e. the precision\n-            // was \".\", then the precision is 0\n-            match count.val {\n-                CountImplied => Parsed::new(CountIs(0), count.next),\n-                _ => count\n-            }\n-        } else {\n-            Parsed::new(CountImplied, i)\n-        }\n-    }\n-\n-    pub fn parse_type<'a>(s: &str, i: uint, lim: uint, err: ErrorFn<'a>)\n-                          -> Parsed<Ty> {\n-        if i >= lim { err(\"missing type in conversion\"); }\n-\n-        // FIXME (#2249): Do we really want two signed types here?\n-        // How important is it to be printf compatible?\n-        let t = match s[i] as char {\n-            'b' => TyBool,\n-            's' => TyStr,\n-            'c' => TyChar,\n-            'd' | 'i' => TyInt(Signed),\n-            'u' => TyInt(Unsigned),\n-            'x' => TyHex(CaseLower),\n-            'X' => TyHex(CaseUpper),\n-            't' => TyBits,\n-            'o' => TyOctal,\n-            'f' => TyFloat,\n-            'p' => TyPointer,\n-            '?' => TyPoly,\n-            _ => err(format!(\"unknown type in conversion: {}\", s.char_at(i)))\n-        };\n-\n-        Parsed::new(t, i + 1)\n-    }\n-\n-    #[cfg(test)]\n-    fn die(s: &str) -> ! { fail2!(s.to_owned()) }\n-\n-    #[test]\n-    fn test_parse_count() {\n-        fn test(s: &str, count: Count, next: uint) -> bool {\n-            parse_count(s, 0, s.len()) == Parsed::new(count, next)\n-        }\n-\n-        assert!(test(\"\", CountImplied, 0));\n-        assert!(test(\"*\", CountIsNextParam, 1));\n-        assert!(test(\"*1\", CountIsNextParam, 1));\n-        assert!(test(\"*1$\", CountIsParam(1), 3));\n-        assert!(test(\"123\", CountIs(123), 3));\n-    }\n-\n-    #[test]\n-    fn test_parse_flags() {\n-        fn pack(fs: &[Flag]) -> uint {\n-            fs.iter().fold(0, |p, &f| p | (1 << f as uint))\n-        }\n-\n-        fn test(s: &str, flags: &[Flag], next: uint) {\n-            let f = parse_flags(s, 0, s.len());\n-            assert_eq!(pack(f.val), pack(flags));\n-            assert_eq!(f.next, next);\n-        }\n-\n-        test(\"\", [], 0);\n-        test(\"!#-+ 0\", [], 0);\n-        test(\"#-+\", [FlagAlternate, FlagLeftJustify, FlagSignAlways], 3);\n-        test(\" 0\", [FlagSpaceForSign, FlagLeftZeroPad], 2);\n-    }\n-\n-    #[test]\n-    fn test_parse_fmt_string() {\n-        assert!(parse_fmt_string(\"foo %s bar\", die) == ~[\n-            PieceString(~\"foo \"),\n-            PieceConv(Conv {\n-                param: None,\n-                flags: ~[],\n-                width: CountImplied,\n-                precision: CountImplied,\n-                ty: TyStr,\n-            }),\n-            PieceString(~\" bar\")]);\n-\n-        assert!(parse_fmt_string(\"%s\", die) == ~[\n-            PieceConv(Conv {\n-                param: None,\n-                flags: ~[],\n-                width: CountImplied,\n-                precision: CountImplied,\n-                ty: TyStr,\n-            })]);\n-\n-        assert!(parse_fmt_string(\"%%%%\", die) == ~[\n-            PieceString(~\"%\"), PieceString(~\"%\")]);\n-    }\n-\n-    #[test]\n-    fn test_parse_parameter() {\n-        fn test(s: &str, param: Option<uint>, next: uint) -> bool {\n-            parse_parameter(s, 0, s.len()) == Parsed::new(param, next)\n-        }\n-\n-        assert!(test(\"\", None, 0));\n-        assert!(test(\"foo\", None, 0));\n-        assert!(test(\"123\", None, 0));\n-        assert!(test(\"123$\", Some(123), 4));\n-    }\n-\n-    #[test]\n-    fn test_parse_precision() {\n-        fn test(s: &str, count: Count, next: uint) -> bool {\n-            parse_precision(s, 0, s.len()) == Parsed::new(count, next)\n-        }\n-\n-        assert!(test(\"\", CountImplied, 0));\n-        assert!(test(\".\", CountIs(0), 1));\n-        assert!(test(\".*\", CountIsNextParam, 2));\n-        assert!(test(\".*1\", CountIsNextParam, 2));\n-        assert!(test(\".*1$\", CountIsParam(1), 4));\n-        assert!(test(\".123\", CountIs(123), 4));\n-    }\n-\n-    #[test]\n-    fn test_parse_type() {\n-        fn test(s: &str, ty: Ty) -> bool {\n-            parse_type(s, 0, s.len(), die) == Parsed::new(ty, 1)\n-        }\n-\n-        assert!(test(\"b\", TyBool));\n-        assert!(test(\"c\", TyChar));\n-        assert!(test(\"d\", TyInt(Signed)));\n-        assert!(test(\"f\", TyFloat));\n-        assert!(test(\"i\", TyInt(Signed)));\n-        assert!(test(\"o\", TyOctal));\n-        assert!(test(\"s\", TyStr));\n-        assert!(test(\"t\", TyBits));\n-        assert!(test(\"x\", TyHex(CaseLower)));\n-        assert!(test(\"X\", TyHex(CaseUpper)));\n-        assert!(test(\"p\", TyPointer));\n-        assert!(test(\"?\", TyPoly));\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_parse_type_missing() {\n-        parse_type(\"\", 0, 0, die);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_parse_type_unknown() {\n-        parse_type(\"!\", 0, 1, die);\n-    }\n-\n-    #[test]\n-    fn test_peek_num() {\n-        let s1 = \"\";\n-        assert!(peek_num(s1, 0, s1.len()).is_none());\n-\n-        let s2 = \"foo\";\n-        assert!(peek_num(s2, 0, s2.len()).is_none());\n-\n-        let s3 = \"123\";\n-        assert_eq!(peek_num(s3, 0, s3.len()), Some(Parsed::new(123, 3)));\n-\n-        let s4 = \"123foo\";\n-        assert_eq!(peek_num(s4, 0, s4.len()), Some(Parsed::new(123, 3)));\n-    }\n-}\n-\n-// Functions used by the fmt extension at runtime. For now there are a lot of\n-// decisions made a runtime. If it proves worthwhile then some of these\n-// conditions can be evaluated at compile-time. For now though it's cleaner to\n-// implement it this way, I think.\n-#[doc(hidden)]\n-#[allow(non_uppercase_statics)]\n-pub mod rt {\n-    use f64;\n-    use str;\n-    use sys;\n-    use num;\n-    use vec;\n-    use option::{Some, None, Option};\n-\n-    pub static flag_none : u32 = 0u32;\n-    pub static flag_left_justify   : u32 = 0b00000000000001u32;\n-    pub static flag_left_zero_pad  : u32 = 0b00000000000010u32;\n-    pub static flag_space_for_sign : u32 = 0b00000000000100u32;\n-    pub static flag_sign_always    : u32 = 0b00000000001000u32;\n-    pub static flag_alternate      : u32 = 0b00000000010000u32;\n-\n-    pub enum Count { CountIs(uint), CountImplied, }\n-\n-    pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n-\n-    pub struct Conv {\n-        flags: u32,\n-        width: Count,\n-        precision: Count,\n-        ty: Ty,\n-    }\n-\n-    pub fn conv_int(cv: Conv, i: int, buf: &mut ~str) {\n-        let radix = 10;\n-        let prec = get_int_precision(cv);\n-        let s : ~str = uint_to_str_prec(num::abs(i) as uint, radix, prec);\n-\n-        let head = if i >= 0 {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                Some('+')\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                Some(' ')\n-            } else {\n-                None\n-            }\n-        } else { Some('-') };\n-        pad(cv, s, head, PadSigned, buf);\n-    }\n-    pub fn conv_uint(cv: Conv, u: uint, buf: &mut ~str) {\n-        let prec = get_int_precision(cv);\n-        let rs =\n-            match cv.ty {\n-              TyDefault => uint_to_str_prec(u, 10, prec),\n-              TyHexLower => uint_to_str_prec(u, 16, prec),\n-\n-              // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-              // to_ascii_move and to_str_move to not do a unnecessary copy.\n-              TyHexUpper => {\n-                let s = uint_to_str_prec(u, 16, prec);\n-                s.to_ascii().to_upper().to_str_ascii()\n-              }\n-              TyBits => uint_to_str_prec(u, 2, prec),\n-              TyOctal => uint_to_str_prec(u, 8, prec)\n-            };\n-        pad(cv, rs, None, PadUnsigned, buf);\n-    }\n-    pub fn conv_bool(cv: Conv, b: bool, buf: &mut ~str) {\n-        let s = if b { \"true\" } else { \"false\" };\n-        // run the boolean conversion through the string conversion logic,\n-        // giving it the same rules for precision, etc.\n-        conv_str(cv, s, buf);\n-    }\n-    pub fn conv_char(cv: Conv, c: char, buf: &mut ~str) {\n-        pad(cv, \"\", Some(c), PadNozero, buf);\n-    }\n-    pub fn conv_str(cv: Conv, s: &str, buf: &mut ~str) {\n-        // For strings, precision is the maximum characters\n-        // displayed\n-        let unpadded = match cv.precision {\n-            CountImplied => s,\n-            CountIs(max) => {\n-                if (max as uint) < s.char_len() {\n-                    s.slice(0, max as uint)\n-                } else {\n-                    s\n-                }\n-            }\n-        };\n-        pad(cv, unpadded, None, PadNozero, buf);\n-    }\n-    pub fn conv_float(cv: Conv, f: f64, buf: &mut ~str) {\n-        let (to_str, digits) = match cv.precision {\n-              CountIs(c) => (f64::to_str_exact, c as uint),\n-              CountImplied => (f64::to_str_digits, 6u)\n-        };\n-        let s = to_str(f, digits);\n-        let head = if 0.0 <= f {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                Some('+')\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                Some(' ')\n-            } else {\n-                None\n-            }\n-        } else { None };\n-        pad(cv, s, head, PadFloat, buf);\n-    }\n-    pub fn conv_pointer<T>(cv: Conv, ptr: *T, buf: &mut ~str) {\n-        let s = ~\"0x\" + uint_to_str_prec(ptr as uint, 16, 1u);\n-        pad(cv, s, None, PadNozero, buf);\n-    }\n-    pub fn conv_poly<T>(cv: Conv, v: &T, buf: &mut ~str) {\n-        let s = sys::log_str(v);\n-        conv_str(cv, s, buf);\n-    }\n-\n-    // Convert a uint to string with a minimum number of digits.  If precision\n-    // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to uint: but it doesn't seem all that useful.\n-    pub fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n-        return if prec == 0u && num == 0u {\n-                ~\"\"\n-            } else {\n-                let s = num.to_str_radix(radix);\n-                let len = s.char_len();\n-                if len < prec {\n-                    let diff = prec - len;\n-                    let pad = str::from_chars(vec::from_elem(diff, '0'));\n-                    pad + s\n-                } else { s }\n-            };\n-    }\n-    pub fn get_int_precision(cv: Conv) -> uint {\n-        return match cv.precision {\n-              CountIs(c) => c as uint,\n-              CountImplied => 1u\n-            };\n-    }\n-\n-    #[deriving(Eq)]\n-    pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n-\n-    pub fn pad(cv: Conv, s: &str, head: Option<char>, mode: PadMode,\n-               buf: &mut ~str) {\n-        let headsize = match head { Some(_) => 1, _ => 0 };\n-        let uwidth : uint = match cv.width {\n-            CountImplied => {\n-                for &c in head.iter() {\n-                    buf.push_char(c);\n-                }\n-                return buf.push_str(s);\n-            }\n-            CountIs(width) => { width as uint }\n-        };\n-        let strlen = s.char_len() + headsize;\n-        if uwidth <= strlen {\n-            for &c in head.iter() {\n-                buf.push_char(c);\n-            }\n-            return buf.push_str(s);\n-        }\n-        let mut padchar = ' ';\n-        let diff = uwidth - strlen;\n-        if have_flag(cv.flags, flag_left_justify) {\n-            for &c in head.iter() {\n-                buf.push_char(c);\n-            }\n-            buf.push_str(s);\n-            do diff.times {\n-                buf.push_char(padchar);\n-            }\n-            return;\n-        }\n-        let (might_zero_pad, signed) = match mode {\n-          PadNozero   => (false, true),\n-          PadSigned   => (true, true),\n-          PadFloat    => (true, true),\n-          PadUnsigned => (true, false)\n-        };\n-        fn have_precision(cv: Conv) -> bool {\n-            return match cv.precision { CountImplied => false, _ => true };\n-        }\n-        let zero_padding = {\n-            if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n-                (!have_precision(cv) || mode == PadFloat) {\n-                padchar = '0';\n-                true\n-            } else {\n-                false\n-            }\n-        };\n-        let padstr = str::from_chars(vec::from_elem(diff, padchar));\n-        // This is completely heinous. If we have a signed value then\n-        // potentially rip apart the intermediate result and insert some\n-        // zeros. It may make sense to convert zero padding to a precision\n-        // instead.\n-\n-        if signed && zero_padding {\n-            for &head in head.iter() {\n-                if head == '+' || head == '-' || head == ' ' {\n-                    buf.push_char(head);\n-                    buf.push_str(padstr);\n-                    buf.push_str(s);\n-                    return;\n-                }\n-            }\n-        }\n-        buf.push_str(padstr);\n-        for &c in head.iter() {\n-            buf.push_char(c);\n-        }\n-        buf.push_str(s);\n-    }\n-    #[inline]\n-    pub fn have_flag(flags: u32, f: u32) -> bool {\n-        flags & f != 0\n-    }\n-}\n-\n-// Bulk of the tests are in src/test/run-pass/syntax-extension-fmt.rs\n-#[cfg(test)]\n-mod test {\n-    #[test]\n-    fn fmt_slice() {\n-        let s = \"abc\";\n-        let _s = format!(\"{}\", s);\n-    }\n-}"}]}