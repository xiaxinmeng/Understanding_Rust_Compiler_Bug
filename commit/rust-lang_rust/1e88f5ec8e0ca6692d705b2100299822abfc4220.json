{"sha": "1e88f5ec8e0ca6692d705b2100299822abfc4220", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlODhmNWVjOGUwY2E2NjkyZDcwNWIyMTAwMjk5ODIyYWJmYzQyMjA=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-23T15:19:46Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-23T15:27:18Z"}, "message": "Simplify highlight token match guards", "tree": {"sha": "693884735a4ea8ae065e4e08bf3528c5c1f61b8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/693884735a4ea8ae065e4e08bf3528c5c1f61b8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e88f5ec8e0ca6692d705b2100299822abfc4220", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e88f5ec8e0ca6692d705b2100299822abfc4220", "html_url": "https://github.com/rust-lang/rust/commit/1e88f5ec8e0ca6692d705b2100299822abfc4220", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e88f5ec8e0ca6692d705b2100299822abfc4220/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef6f596b4b9782406246008b0c49e1101c101fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef6f596b4b9782406246008b0c49e1101c101fc4", "html_url": "https://github.com/rust-lang/rust/commit/ef6f596b4b9782406246008b0c49e1101c101fc4"}], "stats": {"total": 194, "additions": 92, "deletions": 102}, "files": [{"sha": "8731699dc991f602c2ddb4f853c952f92300d5a3", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 74, "deletions": 102, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/1e88f5ec8e0ca6692d705b2100299822abfc4220/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e88f5ec8e0ca6692d705b2100299822abfc4220/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=1e88f5ec8e0ca6692d705b2100299822abfc4220", "patch": "@@ -1,6 +1,6 @@\n //! Computes color for a single element.\n \n-use hir::{AsAssocItem, AssocItemContainer, Semantics, VariantDef};\n+use hir::{AsAssocItem, Semantics};\n use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n     RootDatabase, SymbolKind,\n@@ -45,36 +45,34 @@ pub(super) fn element(\n             };\n \n             match name_kind {\n-                Some(NameClass::ExternCrate(_)) => HlTag::Symbol(SymbolKind::Module).into(),\n+                Some(NameClass::ExternCrate(_)) => SymbolKind::Module.into(),\n                 Some(NameClass::Definition(def)) => highlight_def(db, def) | HlMod::Definition,\n                 Some(NameClass::ConstReference(def)) => highlight_def(db, def),\n                 Some(NameClass::PatFieldShorthand { field_ref, .. }) => {\n                     let mut h = HlTag::Symbol(SymbolKind::Field).into();\n                     if let Definition::Field(field) = field_ref {\n-                        if let VariantDef::Union(_) = field.parent_def(db) {\n+                        if let hir::VariantDef::Union(_) = field.parent_def(db) {\n                             h |= HlMod::Unsafe;\n                         }\n                     }\n-\n                     h\n                 }\n                 None => highlight_name_by_syntax(name) | HlMod::Definition,\n             }\n         }\n-\n         // Highlight references like the definitions they resolve to\n         NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => {\n             // even though we track whether we are in an attribute or not we still need this special case\n             // as otherwise we would emit unresolved references for name refs inside attributes\n-            Highlight::from(HlTag::Symbol(SymbolKind::Function))\n+            SymbolKind::Function.into()\n         }\n         NAME_REF => {\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n             highlight_func_by_name_ref(sema, &name_ref).unwrap_or_else(|| {\n                 let is_self = name_ref.self_token().is_some();\n                 let h = match NameRefClass::classify(sema, &name_ref) {\n                     Some(name_kind) => match name_kind {\n-                        NameRefClass::ExternCrate(_) => HlTag::Symbol(SymbolKind::Module).into(),\n+                        NameRefClass::ExternCrate(_) => SymbolKind::Module.into(),\n                         NameRefClass::Definition(def) => {\n                             if let Definition::Local(local) = &def {\n                                 if let Some(name) = local.name(db) {\n@@ -95,7 +93,7 @@ pub(super) fn element(\n                             if let Some(parent) = name_ref.syntax().parent() {\n                                 if matches!(parent.kind(), FIELD_EXPR | RECORD_PAT_FIELD) {\n                                     if let Definition::Field(field) = def {\n-                                        if let VariantDef::Union(_) = field.parent_def(db) {\n+                                        if let hir::VariantDef::Union(_) = field.parent_def(db) {\n                                             h |= HlMod::Unsafe;\n                                         }\n                                     }\n@@ -104,17 +102,15 @@ pub(super) fn element(\n \n                             h\n                         }\n-                        NameRefClass::FieldShorthand { .. } => {\n-                            HlTag::Symbol(SymbolKind::Field).into()\n-                        }\n+                        NameRefClass::FieldShorthand { .. } => SymbolKind::Field.into(),\n                     },\n                     None if syntactic_name_ref_highlighting => {\n                         highlight_name_ref_by_syntax(name_ref, sema)\n                     }\n                     None => HlTag::UnresolvedReference.into(),\n                 };\n                 if h.tag == HlTag::Symbol(SymbolKind::Module) && is_self {\n-                    HlTag::Symbol(SymbolKind::SelfParam).into()\n+                    SymbolKind::SelfParam.into()\n                 } else {\n                     h\n                 }\n@@ -135,65 +131,52 @@ pub(super) fn element(\n         INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n         BYTE => HlTag::ByteLiteral.into(),\n         CHAR => HlTag::CharLiteral.into(),\n-        QUESTION => Highlight::new(HlTag::Operator(HlOperator::Other)) | HlMod::ControlFlow,\n+        QUESTION => HlTag::Operator(HlOperator::Other) | HlMod::ControlFlow,\n         LIFETIME => {\n             let lifetime = element.into_node().and_then(ast::Lifetime::cast).unwrap();\n \n             match NameClass::classify_lifetime(sema, &lifetime) {\n                 Some(NameClass::Definition(def)) => highlight_def(db, def) | HlMod::Definition,\n                 None => match NameRefClass::classify_lifetime(sema, &lifetime) {\n                     Some(NameRefClass::Definition(def)) => highlight_def(db, def),\n-                    _ => Highlight::new(HlTag::Symbol(SymbolKind::LifetimeParam)),\n+                    _ => SymbolKind::LifetimeParam.into(),\n                 },\n-                _ => Highlight::new(HlTag::Symbol(SymbolKind::LifetimeParam)) | HlMod::Definition,\n+                _ => Highlight::from(SymbolKind::LifetimeParam) | HlMod::Definition,\n             }\n         }\n         p if p.is_punct() => match p {\n-            T![&] if element.parent().and_then(ast::BinExpr::cast).is_some() => {\n-                HlTag::Operator(HlOperator::Bitwise).into()\n-            }\n+            T![&] if parent_matches::<ast::BinExpr>(&element) => HlOperator::Bitwise.into(),\n             T![&] => {\n                 let h = HlTag::Operator(HlOperator::Other).into();\n                 let is_unsafe = element\n                     .parent()\n                     .and_then(ast::RefExpr::cast)\n-                    .map(|ref_expr| sema.is_unsafe_ref_expr(&ref_expr))\n-                    .unwrap_or(false);\n+                    .map_or(false, |ref_expr| sema.is_unsafe_ref_expr(&ref_expr));\n                 if is_unsafe {\n                     h | HlMod::Unsafe\n                 } else {\n                     h\n                 }\n             }\n-            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.] => {\n-                HlTag::Operator(HlOperator::Other).into()\n-            }\n-            T![!] if element.parent().and_then(ast::MacroCall::cast).is_some() => {\n-                HlTag::Symbol(SymbolKind::Macro).into()\n-            }\n-            T![!] if element.parent().and_then(ast::NeverType::cast).is_some() => {\n-                HlTag::BuiltinType.into()\n-            }\n-            T![!] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n-                HlTag::Operator(HlOperator::Logical).into()\n-            }\n-            T![*] if element.parent().and_then(ast::PtrType::cast).is_some() => {\n-                HlTag::Keyword.into()\n-            }\n-            T![*] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n+            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.] => HlOperator::Other.into(),\n+            T![!] if parent_matches::<ast::MacroCall>(&element) => SymbolKind::Macro.into(),\n+            T![!] if parent_matches::<ast::NeverType>(&element) => HlTag::BuiltinType.into(),\n+            T![!] if parent_matches::<ast::PrefixExpr>(&element) => HlOperator::Logical.into(),\n+            T![*] if parent_matches::<ast::PtrType>(&element) => HlTag::Keyword.into(),\n+            T![*] if parent_matches::<ast::PrefixExpr>(&element) => {\n                 let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n \n                 let expr = prefix_expr.expr()?;\n                 let ty = sema.type_of_expr(&expr)?;\n                 if ty.is_raw_ptr() {\n                     HlTag::Operator(HlOperator::Other) | HlMod::Unsafe\n                 } else if let Some(ast::PrefixOp::Deref) = prefix_expr.op_kind() {\n-                    HlTag::Operator(HlOperator::Other).into()\n+                    HlOperator::Other.into()\n                 } else {\n-                    HlTag::Punctuation(HlPunct::Other).into()\n+                    HlPunct::Other.into()\n                 }\n             }\n-            T![-] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n+            T![-] if parent_matches::<ast::PrefixExpr>(&element) => {\n                 let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n \n                 let expr = prefix_expr.expr()?;\n@@ -203,41 +186,31 @@ pub(super) fn element(\n                 }\n                 .into()\n             }\n-            _ if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n-                HlTag::Operator(HlOperator::Other).into()\n-            }\n+            _ if parent_matches::<ast::PrefixExpr>(&element) => HlOperator::Other.into(),\n             T![+] | T![-] | T![*] | T![/] | T![+=] | T![-=] | T![*=] | T![/=]\n-                if element.parent().and_then(ast::BinExpr::cast).is_some() =>\n+                if parent_matches::<ast::BinExpr>(&element) =>\n             {\n-                HlTag::Operator(HlOperator::Arithmetic).into()\n+                HlOperator::Arithmetic.into()\n             }\n             T![|] | T![&] | T![!] | T![^] | T![|=] | T![&=] | T![^=]\n-                if element.parent().and_then(ast::BinExpr::cast).is_some() =>\n+                if parent_matches::<ast::BinExpr>(&element) =>\n             {\n-                HlTag::Operator(HlOperator::Bitwise).into()\n+                HlOperator::Bitwise.into()\n             }\n-            T![&&] | T![||] if element.parent().and_then(ast::BinExpr::cast).is_some() => {\n-                HlTag::Operator(HlOperator::Logical).into()\n+            T![&&] | T![||] if parent_matches::<ast::BinExpr>(&element) => {\n+                HlOperator::Logical.into()\n             }\n             T![>] | T![<] | T![==] | T![>=] | T![<=] | T![!=]\n-                if element.parent().and_then(ast::BinExpr::cast).is_some() =>\n+                if parent_matches::<ast::BinExpr>(&element) =>\n             {\n-                HlTag::Operator(HlOperator::Comparison).into()\n-            }\n-            _ if element.parent().and_then(ast::BinExpr::cast).is_some() => {\n-                HlTag::Operator(HlOperator::Other).into()\n+                HlOperator::Comparison.into()\n             }\n-            _ if element.parent().and_then(ast::RangeExpr::cast).is_some() => {\n-                HlTag::Operator(HlOperator::Other).into()\n-            }\n-            _ if element.parent().and_then(ast::RangePat::cast).is_some() => {\n-                HlTag::Operator(HlOperator::Other).into()\n-            }\n-            _ if element.parent().and_then(ast::RestPat::cast).is_some() => {\n-                HlTag::Operator(HlOperator::Other).into()\n-            }\n-            _ if element.parent().and_then(ast::Attr::cast).is_some() => HlTag::Attribute.into(),\n-            kind => HlTag::Punctuation(match kind {\n+            _ if parent_matches::<ast::BinExpr>(&element) => HlOperator::Other.into(),\n+            _ if parent_matches::<ast::RangeExpr>(&element) => HlOperator::Other.into(),\n+            _ if parent_matches::<ast::RangePat>(&element) => HlOperator::Other.into(),\n+            _ if parent_matches::<ast::RestPat>(&element) => HlOperator::Other.into(),\n+            _ if parent_matches::<ast::Attr>(&element) => HlTag::Attribute.into(),\n+            kind => match kind {\n                 T!['['] | T![']'] => HlPunct::Bracket,\n                 T!['{'] | T!['}'] => HlPunct::Brace,\n                 T!['('] | T![')'] => HlPunct::Parenthesis,\n@@ -247,7 +220,7 @@ pub(super) fn element(\n                 T![;] => HlPunct::Semi,\n                 T![.] => HlPunct::Dot,\n                 _ => HlPunct::Other,\n-            })\n+            }\n             .into(),\n         },\n \n@@ -303,7 +276,6 @@ pub(super) fn element(\n         hash((name, shadow_count))\n     }\n }\n-\n fn highlight_def(db: &RootDatabase, def: Definition) -> Highlight {\n     match def {\n         Definition::Macro(_) => HlTag::Symbol(SymbolKind::Macro),\n@@ -319,12 +291,12 @@ fn highlight_def(db: &RootDatabase, def: Definition) -> Highlight {\n                     }\n \n                     match item.container(db) {\n-                        AssocItemContainer::Impl(i) => {\n+                        hir::AssocItemContainer::Impl(i) => {\n                             if i.trait_(db).is_some() {\n                                 h |= HlMod::Trait;\n                             }\n                         }\n-                        AssocItemContainer::Trait(_t) => {\n+                        hir::AssocItemContainer::Trait(_t) => {\n                             h |= HlMod::Trait;\n                         }\n                     }\n@@ -344,12 +316,12 @@ fn highlight_def(db: &RootDatabase, def: Definition) -> Highlight {\n                 if let Some(item) = konst.as_assoc_item(db) {\n                     h |= HlMod::Associated;\n                     match item.container(db) {\n-                        AssocItemContainer::Impl(i) => {\n+                        hir::AssocItemContainer::Impl(i) => {\n                             if i.trait_(db).is_some() {\n                                 h |= HlMod::Trait;\n                             }\n                         }\n-                        AssocItemContainer::Trait(_t) => {\n+                        hir::AssocItemContainer::Trait(_t) => {\n                             h |= HlMod::Trait;\n                         }\n                     }\n@@ -363,12 +335,12 @@ fn highlight_def(db: &RootDatabase, def: Definition) -> Highlight {\n                 if let Some(item) = type_.as_assoc_item(db) {\n                     h |= HlMod::Associated;\n                     match item.container(db) {\n-                        AssocItemContainer::Impl(i) => {\n+                        hir::AssocItemContainer::Impl(i) => {\n                             if i.trait_(db).is_some() {\n                                 h |= HlMod::Trait;\n                             }\n                         }\n-                        AssocItemContainer::Trait(_t) => {\n+                        hir::AssocItemContainer::Trait(_t) => {\n                             h |= HlMod::Trait;\n                         }\n                     }\n@@ -427,7 +399,7 @@ fn highlight_method_call(\n     method_call: &ast::MethodCallExpr,\n ) -> Option<Highlight> {\n     let func = sema.resolve_method_call(&method_call)?;\n-    let mut h = HlTag::Symbol(SymbolKind::Function).into();\n+    let mut h = SymbolKind::Function.into();\n     h |= HlMod::Associated;\n     if func.is_unsafe(sema.db) || sema.is_unsafe_method_call(&method_call) {\n         h |= HlMod::Unsafe;\n@@ -463,20 +435,20 @@ fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n     };\n \n     let tag = match parent.kind() {\n-        STRUCT => HlTag::Symbol(SymbolKind::Struct),\n-        ENUM => HlTag::Symbol(SymbolKind::Enum),\n-        VARIANT => HlTag::Symbol(SymbolKind::Variant),\n-        UNION => HlTag::Symbol(SymbolKind::Union),\n-        TRAIT => HlTag::Symbol(SymbolKind::Trait),\n-        TYPE_ALIAS => HlTag::Symbol(SymbolKind::TypeAlias),\n-        TYPE_PARAM => HlTag::Symbol(SymbolKind::TypeParam),\n-        RECORD_FIELD => HlTag::Symbol(SymbolKind::Field),\n-        MODULE => HlTag::Symbol(SymbolKind::Module),\n-        FN => HlTag::Symbol(SymbolKind::Function),\n-        CONST => HlTag::Symbol(SymbolKind::Const),\n-        STATIC => HlTag::Symbol(SymbolKind::Static),\n-        IDENT_PAT => HlTag::Symbol(SymbolKind::Local),\n-        _ => default,\n+        STRUCT => SymbolKind::Struct,\n+        ENUM => SymbolKind::Enum,\n+        VARIANT => SymbolKind::Variant,\n+        UNION => SymbolKind::Union,\n+        TRAIT => SymbolKind::Trait,\n+        TYPE_ALIAS => SymbolKind::TypeAlias,\n+        TYPE_PARAM => SymbolKind::TypeParam,\n+        RECORD_FIELD => SymbolKind::Field,\n+        MODULE => SymbolKind::Module,\n+        FN => SymbolKind::Function,\n+        CONST => SymbolKind::Const,\n+        STATIC => SymbolKind::Static,\n+        IDENT_PAT => SymbolKind::Local,\n+        _ => return default.into(),\n     };\n \n     tag.into()\n@@ -494,20 +466,15 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n         METHOD_CALL_EXPR => {\n             return ast::MethodCallExpr::cast(parent)\n                 .and_then(|it| highlight_method_call(sema, &it))\n-                .unwrap_or_else(|| HlTag::Symbol(SymbolKind::Function).into());\n+                .unwrap_or_else(|| SymbolKind::Function.into());\n         }\n         FIELD_EXPR => {\n             let h = HlTag::Symbol(SymbolKind::Field);\n             let is_union = ast::FieldExpr::cast(parent)\n-                .and_then(|field_expr| {\n-                    let field = sema.resolve_field(&field_expr)?;\n-                    Some(if let VariantDef::Union(_) = field.parent_def(sema.db) {\n-                        true\n-                    } else {\n-                        false\n-                    })\n-                })\n-                .unwrap_or(false);\n+                .and_then(|field_expr| sema.resolve_field(&field_expr))\n+                .map_or(false, |field| {\n+                    matches!(field.parent_def(sema.db), hir::VariantDef::Union(_))\n+                });\n             if is_union {\n                 h | HlMod::Unsafe\n             } else {\n@@ -524,9 +491,9 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n                 _ => {\n                     // within path, decide whether it is module or adt by checking for uppercase name\n                     return if name.text().chars().next().unwrap_or_default().is_uppercase() {\n-                        HlTag::Symbol(SymbolKind::Struct)\n+                        SymbolKind::Struct\n                     } else {\n-                        HlTag::Symbol(SymbolKind::Module)\n+                        SymbolKind::Module\n                     }\n                     .into();\n                 }\n@@ -537,11 +504,11 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n             };\n \n             match parent.kind() {\n-                CALL_EXPR => HlTag::Symbol(SymbolKind::Function).into(),\n+                CALL_EXPR => SymbolKind::Function.into(),\n                 _ => if name.text().chars().next().unwrap_or_default().is_uppercase() {\n-                    HlTag::Symbol(SymbolKind::Struct)\n+                    SymbolKind::Struct\n                 } else {\n-                    HlTag::Symbol(SymbolKind::Const)\n+                    SymbolKind::Const\n                 }\n                 .into(),\n             }\n@@ -576,6 +543,11 @@ fn parents_match(mut node: NodeOrToken<SyntaxNode, SyntaxToken>, mut kinds: &[Sy\n     kinds.len() == 0\n }\n \n+#[inline]\n+fn parent_matches<N: AstNode>(element: &SyntaxElement) -> bool {\n+    element.parent().map_or(false, |it| N::can_cast(it.kind()))\n+}\n+\n fn is_child_of_impl(element: &SyntaxElement) -> bool {\n     match element.parent() {\n         Some(e) => e.kind() == IMPL,"}, {"sha": "a304b325064fc1a18ce12b56e5e6b270ebf7ab25", "filename": "crates/ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1e88f5ec8e0ca6692d705b2100299822abfc4220/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e88f5ec8e0ca6692d705b2100299822abfc4220/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=1e88f5ec8e0ca6692d705b2100299822abfc4220", "patch": "@@ -234,6 +234,24 @@ impl From<HlTag> for Highlight {\n     }\n }\n \n+impl From<HlOperator> for Highlight {\n+    fn from(op: HlOperator) -> Highlight {\n+        Highlight::new(HlTag::Operator(op))\n+    }\n+}\n+\n+impl From<HlPunct> for Highlight {\n+    fn from(punct: HlPunct) -> Highlight {\n+        Highlight::new(HlTag::Punctuation(punct))\n+    }\n+}\n+\n+impl From<SymbolKind> for Highlight {\n+    fn from(sym: SymbolKind) -> Highlight {\n+        Highlight::new(HlTag::Symbol(sym))\n+    }\n+}\n+\n impl Highlight {\n     pub(crate) fn new(tag: HlTag) -> Highlight {\n         Highlight { tag, mods: HlMods::default() }"}]}