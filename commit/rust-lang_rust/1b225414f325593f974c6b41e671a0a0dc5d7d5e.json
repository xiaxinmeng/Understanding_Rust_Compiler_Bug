{"sha": "1b225414f325593f974c6b41e671a0a0dc5d7d5e", "node_id": "C_kwDOAAsO6NoAKDFiMjI1NDE0ZjMyNTU5M2Y5NzRjNmI0MWU2NzFhMGEwZGM1ZDdkNWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-09T15:07:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-09T15:07:10Z"}, "message": "Auto merge of #93668 - SUPERCILEX:path_alloc, r=joshtriplett\n\nReduce CString allocations in std as much as possible\n\nCurrently, every operation involving paths in `fs` allocates memory to hold the path before sending it through the syscall. This PR instead uses a stack allocation (chosen size is somewhat arbitrary) when the path is short before falling back to heap allocations for long paths.\n\nBenchmarks show that the stack allocation is ~2x faster for short paths:\n\n```\ntest sys::unix::fd::tests::bench_heap_path_alloc                  ... bench:          34 ns/iter (+/- 2)\ntest sys::unix::fd::tests::bench_stack_path_alloc                 ... bench:          15 ns/iter (+/- 1)\n```\n\nFor long paths, I couldn't find any measurable difference.\n\n---\n\nI'd be surprised if I was the first to think of this, so I didn't fully flush out the PR. If this change is desirable, I'll make use of `run_with_cstr` across all platforms in every fs method (currently just unix open for testing). I also added an `impl From<FromBytesWithNulError>` which is presumably a no-no (or at least needs to be done in another PR).\n\n---\n\nAlso see https://github.com/nix-rust/nix/pull/1655 with a bunch of discussion where I'm doing something similar.", "tree": {"sha": "679e5d7d035d1f7ccc21ce222e92d4ffd47b0caf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/679e5d7d035d1f7ccc21ce222e92d4ffd47b0caf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b225414f325593f974c6b41e671a0a0dc5d7d5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b225414f325593f974c6b41e671a0a0dc5d7d5e", "html_url": "https://github.com/rust-lang/rust/commit/1b225414f325593f974c6b41e671a0a0dc5d7d5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b225414f325593f974c6b41e671a0a0dc5d7d5e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79a664d8b00505a76b53cfe017b9c80bcee7e080", "url": "https://api.github.com/repos/rust-lang/rust/commits/79a664d8b00505a76b53cfe017b9c80bcee7e080", "html_url": "https://github.com/rust-lang/rust/commit/79a664d8b00505a76b53cfe017b9c80bcee7e080"}, {"sha": "86974b83af48ee9e196da42730ec96ad646009c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/86974b83af48ee9e196da42730ec96ad646009c4", "html_url": "https://github.com/rust-lang/rust/commit/86974b83af48ee9e196da42730ec96ad646009c4"}], "stats": {"total": 683, "additions": 397, "deletions": 286}, "files": [{"sha": "29fc0835d76669d2f4050bce4752b8e6d759b6ab", "filename": "library/std/src/sys/common/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -11,3 +11,7 @@\n #![allow(dead_code)]\n \n pub mod alloc;\n+pub mod small_c_string;\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "01acd5191351c489a4defd4e753df9ac69fc7706", "filename": "library/std/src/sys/common/small_c_string.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -0,0 +1,58 @@\n+use crate::ffi::{CStr, CString};\n+use crate::mem::MaybeUninit;\n+use crate::path::Path;\n+use crate::slice;\n+use crate::{io, ptr};\n+\n+// Make sure to stay under 4096 so the compiler doesn't insert a probe frame:\n+// https://docs.rs/compiler_builtins/latest/compiler_builtins/probestack/index.html\n+#[cfg(not(target_os = \"espidf\"))]\n+const MAX_STACK_ALLOCATION: usize = 384;\n+#[cfg(target_os = \"espidf\")]\n+const MAX_STACK_ALLOCATION: usize = 32;\n+\n+const NUL_ERR: io::Error =\n+    io::const_io_error!(io::ErrorKind::InvalidInput, \"file name contained an unexpected NUL byte\");\n+\n+#[inline]\n+pub fn run_path_with_cstr<T, F>(path: &Path, f: F) -> io::Result<T>\n+where\n+    F: FnOnce(&CStr) -> io::Result<T>,\n+{\n+    run_with_cstr(path.as_os_str().bytes(), f)\n+}\n+\n+#[inline]\n+pub fn run_with_cstr<T, F>(bytes: &[u8], f: F) -> io::Result<T>\n+where\n+    F: FnOnce(&CStr) -> io::Result<T>,\n+{\n+    if bytes.len() >= MAX_STACK_ALLOCATION {\n+        return run_with_cstr_allocating(bytes, f);\n+    }\n+\n+    let mut buf = MaybeUninit::<[u8; MAX_STACK_ALLOCATION]>::uninit();\n+    let buf_ptr = buf.as_mut_ptr() as *mut u8;\n+\n+    unsafe {\n+        ptr::copy_nonoverlapping(bytes.as_ptr(), buf_ptr, bytes.len());\n+        buf_ptr.add(bytes.len()).write(0);\n+    }\n+\n+    match CStr::from_bytes_with_nul(unsafe { slice::from_raw_parts(buf_ptr, bytes.len() + 1) }) {\n+        Ok(s) => f(s),\n+        Err(_) => Err(NUL_ERR),\n+    }\n+}\n+\n+#[cold]\n+#[inline(never)]\n+fn run_with_cstr_allocating<T, F>(bytes: &[u8], f: F) -> io::Result<T>\n+where\n+    F: FnOnce(&CStr) -> io::Result<T>,\n+{\n+    match CString::new(bytes) {\n+        Ok(s) => f(&s),\n+        Err(_) => Err(NUL_ERR),\n+    }\n+}"}, {"sha": "fb6f5d6af8371d582b001b07713c9467fe02d376", "filename": "library/std/src/sys/common/tests.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -0,0 +1,66 @@\n+use crate::ffi::CString;\n+use crate::hint::black_box;\n+use crate::path::Path;\n+use crate::sys::common::small_c_string::run_path_with_cstr;\n+use core::iter::repeat;\n+\n+#[test]\n+fn stack_allocation_works() {\n+    let path = Path::new(\"abc\");\n+    let result = run_path_with_cstr(path, |p| {\n+        assert_eq!(p, &*CString::new(path.as_os_str().bytes()).unwrap());\n+        Ok(42)\n+    });\n+    assert_eq!(result.unwrap(), 42);\n+}\n+\n+#[test]\n+fn stack_allocation_fails() {\n+    let path = Path::new(\"ab\\0\");\n+    assert!(run_path_with_cstr::<(), _>(path, |_| unreachable!()).is_err());\n+}\n+\n+#[test]\n+fn heap_allocation_works() {\n+    let path = repeat(\"a\").take(384).collect::<String>();\n+    let path = Path::new(&path);\n+    let result = run_path_with_cstr(path, |p| {\n+        assert_eq!(p, &*CString::new(path.as_os_str().bytes()).unwrap());\n+        Ok(42)\n+    });\n+    assert_eq!(result.unwrap(), 42);\n+}\n+\n+#[test]\n+fn heap_allocation_fails() {\n+    let mut path = repeat(\"a\").take(384).collect::<String>();\n+    path.push('\\0');\n+    let path = Path::new(&path);\n+    assert!(run_path_with_cstr::<(), _>(path, |_| unreachable!()).is_err());\n+}\n+\n+#[bench]\n+fn bench_stack_path_alloc(b: &mut test::Bencher) {\n+    let path = repeat(\"a\").take(383).collect::<String>();\n+    let p = Path::new(&path);\n+    b.iter(|| {\n+        run_path_with_cstr(p, |cstr| {\n+            black_box(cstr);\n+            Ok(())\n+        })\n+        .unwrap();\n+    });\n+}\n+\n+#[bench]\n+fn bench_heap_path_alloc(b: &mut test::Bencher) {\n+    let path = repeat(\"a\").take(384).collect::<String>();\n+    let p = Path::new(&path);\n+    b.iter(|| {\n+        run_path_with_cstr(p, |cstr| {\n+            black_box(cstr);\n+            Ok(())\n+        })\n+        .unwrap();\n+    });\n+}"}, {"sha": "af297ff1ec75b413766da4cdc620c8917a8e7a28", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -1,10 +1,12 @@\n+use crate::convert::TryFrom;\n use crate::ffi::{CStr, CString, OsString};\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n use crate::io::{self, Error, ErrorKind};\n use crate::io::{BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n use crate::os::unix::ffi::OsStrExt;\n use crate::path::{Path, PathBuf};\n+use crate::sys::common::small_c_string::run_path_with_cstr;\n use crate::sys::cvt;\n use crate::sys::hermit::abi;\n use crate::sys::hermit::abi::{O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY};\n@@ -15,10 +17,6 @@ use crate::sys::unsupported;\n pub use crate::sys_common::fs::{copy, try_exists};\n //pub use crate::sys_common::fs::remove_dir_all;\n \n-fn cstr(path: &Path) -> io::Result<CString> {\n-    Ok(CString::new(path.as_os_str().as_bytes())?)\n-}\n-\n #[derive(Debug)]\n pub struct File(FileDesc);\n \n@@ -272,8 +270,7 @@ impl OpenOptions {\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let path = cstr(path)?;\n-        File::open_c(&path, opts)\n+        run_path_with_cstr(path, |path| File::open_c(&path, opts))\n     }\n \n     pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n@@ -373,9 +370,7 @@ pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(path: &Path) -> io::Result<()> {\n-    let name = cstr(path)?;\n-    let _ = unsafe { cvt(abi::unlink(name.as_ptr()))? };\n-    Ok(())\n+    run_path_with_cstr(path, |path| cvt(unsafe { abi::unlink(path.as_ptr()) }).map(|_| ()))\n }\n \n pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {"}, {"sha": "c080c176a2acef8ad0ecae01e008779ebaaa0789", "filename": "library/std/src/sys/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -22,7 +22,7 @@\n \n #![allow(missing_debug_implementations)]\n \n-mod common;\n+pub mod common;\n \n cfg_if::cfg_if! {\n     if #[cfg(unix)] {"}, {"sha": "4906c62689d4c27671398aafd86862e7832274bb", "filename": "library/std/src/sys/solid/os.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -1,4 +1,5 @@\n use super::unsupported;\n+use crate::convert::TryFrom;\n use crate::error::Error as StdError;\n use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n@@ -9,6 +10,7 @@ use crate::os::{\n };\n use crate::path::{self, PathBuf};\n use crate::sync::RwLock;\n+use crate::sys::common::small_c_string::run_with_cstr;\n use crate::vec;\n \n use super::{error, itron, memchr};\n@@ -139,35 +141,33 @@ pub fn env() -> Env {\n pub fn getenv(k: &OsStr) -> Option<OsString> {\n     // environment variables with a nul byte can't be set, so their value is\n     // always None as well\n-    let k = CString::new(k.as_bytes()).ok()?;\n-    unsafe {\n+    let s = run_with_cstr(k.as_bytes(), |k| {\n         let _guard = ENV_LOCK.read();\n-        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n-        if s.is_null() {\n-            None\n-        } else {\n-            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n-        }\n+        Ok(unsafe { libc::getenv(k.as_ptr()) } as *const libc::c_char)\n+    })\n+    .ok()?;\n+\n+    if s.is_null() {\n+        None\n+    } else {\n+        Some(OsStringExt::from_vec(unsafe { CStr::from_ptr(s) }.to_bytes().to_vec()))\n     }\n }\n \n pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n-    let k = CString::new(k.as_bytes())?;\n-    let v = CString::new(v.as_bytes())?;\n-\n-    unsafe {\n-        let _guard = ENV_LOCK.write();\n-        cvt_env(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n-    }\n+    run_with_cstr(k.as_bytes(), |k| {\n+        run_with_cstr(v.as_bytes(), |v| {\n+            let _guard = ENV_LOCK.write();\n+            cvt_env(unsafe { libc::setenv(k.as_ptr(), v.as_ptr(), 1) }).map(drop)\n+        })\n+    })\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n-    let nbuf = CString::new(n.as_bytes())?;\n-\n-    unsafe {\n+    run_with_cstr(n.as_bytes(), |nbuf| {\n         let _guard = ENV_LOCK.write();\n-        cvt_env(libc::unsetenv(nbuf.as_ptr())).map(drop)\n-    }\n+        cvt_env(unsafe { libc::unsetenv(nbuf.as_ptr()) }).map(drop)\n+    })\n }\n \n /// In kmclib, `setenv` and `unsetenv` don't always set `errno`, so this"}, {"sha": "fa03233c86ba89b9e7fc206af6a46636a35fc8d7", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 142, "deletions": 150, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -1,13 +1,14 @@\n use crate::os::unix::prelude::*;\n \n-use crate::ffi::{CStr, CString, OsStr, OsString};\n+use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io::{self, BorrowedCursor, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::sync::Arc;\n+use crate::sys::common::small_c_string::run_path_with_cstr;\n use crate::sys::fd::FileDesc;\n use crate::sys::time::SystemTime;\n use crate::sys::{cvt, cvt_r};\n@@ -260,7 +261,7 @@ pub struct DirEntry {\n     // We need to store an owned copy of the entry name on platforms that use\n     // readdir() (not readdir_r()), because a) struct dirent may use a flexible\n     // array to store the name, b) it lives only until the next readdir() call.\n-    name: CString,\n+    name: crate::ffi::CString,\n }\n \n // Define a minimal subset of fields we need from `dirent64`, especially since\n@@ -900,8 +901,7 @@ impl OpenOptions {\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let path = cstr(path)?;\n-        File::open_c(&path, opts)\n+        run_path_with_cstr(path, |path| File::open_c(path, opts))\n     }\n \n     pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n@@ -1114,20 +1114,14 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let p = cstr(p)?;\n-        cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) })?;\n-        Ok(())\n+        run_path_with_cstr(p, |p| cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) }).map(|_| ()))\n     }\n \n     pub fn set_mode(&mut self, mode: u32) {\n         self.mode = mode as mode_t;\n     }\n }\n \n-fn cstr(path: &Path) -> io::Result<CString> {\n-    Ok(CString::new(path.as_os_str().as_bytes())?)\n-}\n-\n impl AsInner<FileDesc> for File {\n     fn as_inner(&self) -> &FileDesc {\n         &self.0\n@@ -1273,173 +1267,170 @@ impl fmt::Debug for File {\n     }\n }\n \n-pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n-    let root = p.to_path_buf();\n-    let p = cstr(p)?;\n-    unsafe {\n-        let ptr = libc::opendir(p.as_ptr());\n-        if ptr.is_null() {\n-            Err(Error::last_os_error())\n-        } else {\n-            let inner = InnerReadDir { dirp: Dir(ptr), root };\n-            Ok(ReadDir {\n-                inner: Arc::new(inner),\n-                #[cfg(not(any(\n-                    target_os = \"android\",\n-                    target_os = \"linux\",\n-                    target_os = \"solaris\",\n-                    target_os = \"illumos\",\n-                    target_os = \"fuchsia\",\n-                    target_os = \"redox\",\n-                )))]\n-                end_of_stream: false,\n-            })\n-        }\n+pub fn readdir(path: &Path) -> io::Result<ReadDir> {\n+    let ptr = run_path_with_cstr(path, |p| unsafe { Ok(libc::opendir(p.as_ptr())) })?;\n+    if ptr.is_null() {\n+        Err(Error::last_os_error())\n+    } else {\n+        let root = path.to_path_buf();\n+        let inner = InnerReadDir { dirp: Dir(ptr), root };\n+        Ok(ReadDir {\n+            inner: Arc::new(inner),\n+            #[cfg(not(any(\n+                target_os = \"android\",\n+                target_os = \"linux\",\n+                target_os = \"solaris\",\n+                target_os = \"illumos\",\n+                target_os = \"fuchsia\",\n+                target_os = \"redox\",\n+            )))]\n+            end_of_stream: false,\n+        })\n     }\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let p = cstr(p)?;\n-    cvt(unsafe { libc::unlink(p.as_ptr()) })?;\n-    Ok(())\n+    run_path_with_cstr(p, |p| cvt(unsafe { libc::unlink(p.as_ptr()) }).map(|_| ()))\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let old = cstr(old)?;\n-    let new = cstr(new)?;\n-    cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) })?;\n-    Ok(())\n+    run_path_with_cstr(old, |old| {\n+        run_path_with_cstr(new, |new| {\n+            cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) }).map(|_| ())\n+        })\n+    })\n }\n \n pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    let p = cstr(p)?;\n-    cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) })?;\n-    Ok(())\n+    run_path_with_cstr(p, |p| cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) }).map(|_| ()))\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let p = cstr(p)?;\n-    cvt(unsafe { libc::rmdir(p.as_ptr()) })?;\n-    Ok(())\n+    run_path_with_cstr(p, |p| cvt(unsafe { libc::rmdir(p.as_ptr()) }).map(|_| ()))\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let c_path = cstr(p)?;\n-    let p = c_path.as_ptr();\n+    run_path_with_cstr(p, |c_path| {\n+        let p = c_path.as_ptr();\n \n-    let mut buf = Vec::with_capacity(256);\n+        let mut buf = Vec::with_capacity(256);\n \n-    loop {\n-        let buf_read =\n-            cvt(unsafe { libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity()) })? as usize;\n+        loop {\n+            let buf_read =\n+                cvt(unsafe { libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity()) })?\n+                    as usize;\n \n-        unsafe {\n-            buf.set_len(buf_read);\n-        }\n+            unsafe {\n+                buf.set_len(buf_read);\n+            }\n \n-        if buf_read != buf.capacity() {\n-            buf.shrink_to_fit();\n+            if buf_read != buf.capacity() {\n+                buf.shrink_to_fit();\n \n-            return Ok(PathBuf::from(OsString::from_vec(buf)));\n-        }\n+                return Ok(PathBuf::from(OsString::from_vec(buf)));\n+            }\n \n-        // Trigger the internal buffer resizing logic of `Vec` by requiring\n-        // more space than the current capacity. The length is guaranteed to be\n-        // the same as the capacity due to the if statement above.\n-        buf.reserve(1);\n-    }\n+            // Trigger the internal buffer resizing logic of `Vec` by requiring\n+            // more space than the current capacity. The length is guaranteed to be\n+            // the same as the capacity due to the if statement above.\n+            buf.reserve(1);\n+        }\n+    })\n }\n \n pub fn symlink(original: &Path, link: &Path) -> io::Result<()> {\n-    let original = cstr(original)?;\n-    let link = cstr(link)?;\n-    cvt(unsafe { libc::symlink(original.as_ptr(), link.as_ptr()) })?;\n-    Ok(())\n+    run_path_with_cstr(original, |original| {\n+        run_path_with_cstr(link, |link| {\n+            cvt(unsafe { libc::symlink(original.as_ptr(), link.as_ptr()) }).map(|_| ())\n+        })\n+    })\n }\n \n pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n-    let original = cstr(original)?;\n-    let link = cstr(link)?;\n-    cfg_if::cfg_if! {\n-        if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\", target_os = \"espidf\", target_os = \"horizon\"))] {\n-            // VxWorks, Redox and ESP-IDF lack `linkat`, so use `link` instead. POSIX leaves\n-            // it implementation-defined whether `link` follows symlinks, so rely on the\n-            // `symlink_hard_link` test in library/std/src/fs/tests.rs to check the behavior.\n-            // Android has `linkat` on newer versions, but we happen to know `link`\n-            // always has the correct behavior, so it's here as well.\n-            cvt(unsafe { libc::link(original.as_ptr(), link.as_ptr()) })?;\n-        } else if #[cfg(target_os = \"macos\")] {\n-            // On MacOS, older versions (<=10.9) lack support for linkat while newer\n-            // versions have it. We want to use linkat if it is available, so we use weak!\n-            // to check. `linkat` is preferable to `link` because it gives us a flag to\n-            // specify how symlinks should be handled. We pass 0 as the flags argument,\n-            // meaning it shouldn't follow symlinks.\n-            weak!(fn linkat(c_int, *const c_char, c_int, *const c_char, c_int) -> c_int);\n-\n-            if let Some(f) = linkat.get() {\n-                cvt(unsafe { f(libc::AT_FDCWD, original.as_ptr(), libc::AT_FDCWD, link.as_ptr(), 0) })?;\n-            } else {\n-                cvt(unsafe { libc::link(original.as_ptr(), link.as_ptr()) })?;\n-            };\n-        } else {\n-            // Where we can, use `linkat` instead of `link`; see the comment above\n-            // this one for details on why.\n-            cvt(unsafe { libc::linkat(libc::AT_FDCWD, original.as_ptr(), libc::AT_FDCWD, link.as_ptr(), 0) })?;\n-        }\n-    }\n-    Ok(())\n+    run_path_with_cstr(original, |original| {\n+        run_path_with_cstr(link, |link| {\n+            cfg_if::cfg_if! {\n+                if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\", target_os = \"espidf\", target_os = \"horizon\"))] {\n+                    // VxWorks, Redox and ESP-IDF lack `linkat`, so use `link` instead. POSIX leaves\n+                    // it implementation-defined whether `link` follows symlinks, so rely on the\n+                    // `symlink_hard_link` test in library/std/src/fs/tests.rs to check the behavior.\n+                    // Android has `linkat` on newer versions, but we happen to know `link`\n+                    // always has the correct behavior, so it's here as well.\n+                    cvt(unsafe { libc::link(original.as_ptr(), link.as_ptr()) })?;\n+                } else if #[cfg(target_os = \"macos\")] {\n+                    // On MacOS, older versions (<=10.9) lack support for linkat while newer\n+                    // versions have it. We want to use linkat if it is available, so we use weak!\n+                    // to check. `linkat` is preferable to `link` because it gives us a flag to\n+                    // specify how symlinks should be handled. We pass 0 as the flags argument,\n+                    // meaning it shouldn't follow symlinks.\n+                    weak!(fn linkat(c_int, *const c_char, c_int, *const c_char, c_int) -> c_int);\n+\n+                    if let Some(f) = linkat.get() {\n+                        cvt(unsafe { f(libc::AT_FDCWD, original.as_ptr(), libc::AT_FDCWD, link.as_ptr(), 0) })?;\n+                    } else {\n+                        cvt(unsafe { libc::link(original.as_ptr(), link.as_ptr()) })?;\n+                    };\n+                } else {\n+                    // Where we can, use `linkat` instead of `link`; see the comment above\n+                    // this one for details on why.\n+                    cvt(unsafe { libc::linkat(libc::AT_FDCWD, original.as_ptr(), libc::AT_FDCWD, link.as_ptr(), 0) })?;\n+                }\n+            }\n+            Ok(())\n+        })\n+    })\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let p = cstr(p)?;\n-\n-    cfg_has_statx! {\n-        if let Some(ret) = unsafe { try_statx(\n-            libc::AT_FDCWD,\n-            p.as_ptr(),\n-            libc::AT_STATX_SYNC_AS_STAT,\n-            libc::STATX_ALL,\n-        ) } {\n-            return ret;\n+    run_path_with_cstr(p, |p| {\n+        cfg_has_statx! {\n+            if let Some(ret) = unsafe { try_statx(\n+                libc::AT_FDCWD,\n+                p.as_ptr(),\n+                libc::AT_STATX_SYNC_AS_STAT,\n+                libc::STATX_ALL,\n+            ) } {\n+                return ret;\n+            }\n         }\n-    }\n \n-    let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe { stat64(p.as_ptr(), &mut stat) })?;\n-    Ok(FileAttr::from_stat64(stat))\n+        let mut stat: stat64 = unsafe { mem::zeroed() };\n+        cvt(unsafe { stat64(p.as_ptr(), &mut stat) })?;\n+        Ok(FileAttr::from_stat64(stat))\n+    })\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let p = cstr(p)?;\n-\n-    cfg_has_statx! {\n-        if let Some(ret) = unsafe { try_statx(\n-            libc::AT_FDCWD,\n-            p.as_ptr(),\n-            libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,\n-            libc::STATX_ALL,\n-        ) } {\n-            return ret;\n+    run_path_with_cstr(p, |p| {\n+        cfg_has_statx! {\n+            if let Some(ret) = unsafe { try_statx(\n+                libc::AT_FDCWD,\n+                p.as_ptr(),\n+                libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,\n+                libc::STATX_ALL,\n+            ) } {\n+                return ret;\n+            }\n         }\n-    }\n \n-    let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe { lstat64(p.as_ptr(), &mut stat) })?;\n-    Ok(FileAttr::from_stat64(stat))\n+        let mut stat: stat64 = unsafe { mem::zeroed() };\n+        cvt(unsafe { lstat64(p.as_ptr(), &mut stat) })?;\n+        Ok(FileAttr::from_stat64(stat))\n+    })\n }\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n-    let path = CString::new(p.as_os_str().as_bytes())?;\n-    let buf;\n-    unsafe {\n-        let r = libc::realpath(path.as_ptr(), ptr::null_mut());\n-        if r.is_null() {\n-            return Err(io::Error::last_os_error());\n-        }\n-        buf = CStr::from_ptr(r).to_bytes().to_vec();\n-        libc::free(r as *mut _);\n+    let r = run_path_with_cstr(p, |path| unsafe {\n+        Ok(libc::realpath(path.as_ptr(), ptr::null_mut()))\n+    })?;\n+    if r.is_null() {\n+        return Err(io::Error::last_os_error());\n     }\n-    Ok(PathBuf::from(OsString::from_vec(buf)))\n+    Ok(PathBuf::from(OsString::from_vec(unsafe {\n+        let buf = CStr::from_ptr(r).to_bytes().to_vec();\n+        libc::free(r as *mut _);\n+        buf\n+    })))\n }\n \n fn open_from(from: &Path) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n@@ -1589,9 +1580,9 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     // Opportunistically attempt to create a copy-on-write clone of `from`\n     // using `fclonefileat`.\n     if HAS_FCLONEFILEAT.load(Ordering::Relaxed) {\n-        let to = cstr(to)?;\n-        let clonefile_result =\n-            cvt(unsafe { fclonefileat(reader.as_raw_fd(), libc::AT_FDCWD, to.as_ptr(), 0) });\n+        let clonefile_result = run_path_with_cstr(to, |to| {\n+            cvt(unsafe { fclonefileat(reader.as_raw_fd(), libc::AT_FDCWD, to.as_ptr(), 0) })\n+        });\n         match clonefile_result {\n             Ok(_) => return Ok(reader_metadata.len()),\n             Err(err) => match err.raw_os_error() {\n@@ -1635,9 +1626,10 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n }\n \n pub fn chown(path: &Path, uid: u32, gid: u32) -> io::Result<()> {\n-    let path = cstr(path)?;\n-    cvt(unsafe { libc::chown(path.as_ptr(), uid as libc::uid_t, gid as libc::gid_t) })?;\n-    Ok(())\n+    run_path_with_cstr(path, |path| {\n+        cvt(unsafe { libc::chown(path.as_ptr(), uid as libc::uid_t, gid as libc::gid_t) })\n+            .map(|_| ())\n+    })\n }\n \n pub fn fchown(fd: c_int, uid: u32, gid: u32) -> io::Result<()> {\n@@ -1646,16 +1638,15 @@ pub fn fchown(fd: c_int, uid: u32, gid: u32) -> io::Result<()> {\n }\n \n pub fn lchown(path: &Path, uid: u32, gid: u32) -> io::Result<()> {\n-    let path = cstr(path)?;\n-    cvt(unsafe { libc::lchown(path.as_ptr(), uid as libc::uid_t, gid as libc::gid_t) })?;\n-    Ok(())\n+    run_path_with_cstr(path, |path| {\n+        cvt(unsafe { libc::lchown(path.as_ptr(), uid as libc::uid_t, gid as libc::gid_t) })\n+            .map(|_| ())\n+    })\n }\n \n #[cfg(not(any(target_os = \"fuchsia\", target_os = \"vxworks\")))]\n pub fn chroot(dir: &Path) -> io::Result<()> {\n-    let dir = cstr(dir)?;\n-    cvt(unsafe { libc::chroot(dir.as_ptr()) })?;\n-    Ok(())\n+    run_path_with_cstr(dir, |dir| cvt(unsafe { libc::chroot(dir.as_ptr()) }).map(|_| ()))\n }\n \n pub use remove_dir_impl::remove_dir_all;\n@@ -1669,13 +1660,14 @@ mod remove_dir_impl {\n // Modern implementation using openat(), unlinkat() and fdopendir()\n #[cfg(not(any(target_os = \"redox\", target_os = \"espidf\", target_os = \"horizon\", miri)))]\n mod remove_dir_impl {\n-    use super::{cstr, lstat, Dir, DirEntry, InnerReadDir, ReadDir};\n+    use super::{lstat, Dir, DirEntry, InnerReadDir, ReadDir};\n     use crate::ffi::CStr;\n     use crate::io;\n     use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n     use crate::os::unix::prelude::{OwnedFd, RawFd};\n     use crate::path::{Path, PathBuf};\n     use crate::sync::Arc;\n+    use crate::sys::common::small_c_string::run_path_with_cstr;\n     use crate::sys::{cvt, cvt_r};\n \n     #[cfg(not(all(target_os = \"macos\", not(target_arch = \"aarch64\")),))]\n@@ -1842,7 +1834,7 @@ mod remove_dir_impl {\n         if attr.file_type().is_symlink() {\n             crate::fs::remove_file(p)\n         } else {\n-            remove_dir_all_recursive(None, &cstr(p)?)\n+            run_path_with_cstr(p, |p| remove_dir_all_recursive(None, &p))\n         }\n     }\n "}, {"sha": "2f2663db60769d0f2a6d39736af661dc4f803350", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -7,6 +7,7 @@ mod tests;\n \n use crate::os::unix::prelude::*;\n \n+use crate::convert::TryFrom;\n use crate::error::Error as StdError;\n use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n@@ -18,6 +19,7 @@ use crate::ptr;\n use crate::slice;\n use crate::str;\n use crate::sync::{PoisonError, RwLock};\n+use crate::sys::common::small_c_string::{run_path_with_cstr, run_with_cstr};\n use crate::sys::cvt;\n use crate::sys::fd;\n use crate::sys::memchr;\n@@ -170,12 +172,8 @@ pub fn chdir(p: &path::Path) -> io::Result<()> {\n \n #[cfg(not(target_os = \"espidf\"))]\n pub fn chdir(p: &path::Path) -> io::Result<()> {\n-    let p: &OsStr = p.as_ref();\n-    let p = CString::new(p.as_bytes())?;\n-    if unsafe { libc::chdir(p.as_ptr()) } != 0 {\n-        return Err(io::Error::last_os_error());\n-    }\n-    Ok(())\n+    let result = run_path_with_cstr(p, |p| unsafe { Ok(libc::chdir(p.as_ptr())) })?;\n+    if result == 0 { Ok(()) } else { Err(io::Error::last_os_error()) }\n }\n \n pub struct SplitPaths<'a> {\n@@ -548,35 +546,32 @@ pub fn env() -> Env {\n pub fn getenv(k: &OsStr) -> Option<OsString> {\n     // environment variables with a nul byte can't be set, so their value is\n     // always None as well\n-    let k = CString::new(k.as_bytes()).ok()?;\n-    unsafe {\n+    let s = run_with_cstr(k.as_bytes(), |k| {\n         let _guard = env_read_lock();\n-        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n-        if s.is_null() {\n-            None\n-        } else {\n-            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n-        }\n+        Ok(unsafe { libc::getenv(k.as_ptr()) } as *const libc::c_char)\n+    })\n+    .ok()?;\n+    if s.is_null() {\n+        None\n+    } else {\n+        Some(OsStringExt::from_vec(unsafe { CStr::from_ptr(s) }.to_bytes().to_vec()))\n     }\n }\n \n pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n-    let k = CString::new(k.as_bytes())?;\n-    let v = CString::new(v.as_bytes())?;\n-\n-    unsafe {\n-        let _guard = ENV_LOCK.write();\n-        cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n-    }\n+    run_with_cstr(k.as_bytes(), |k| {\n+        run_with_cstr(v.as_bytes(), |v| {\n+            let _guard = ENV_LOCK.write();\n+            cvt(unsafe { libc::setenv(k.as_ptr(), v.as_ptr(), 1) }).map(drop)\n+        })\n+    })\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n-    let nbuf = CString::new(n.as_bytes())?;\n-\n-    unsafe {\n+    run_with_cstr(n.as_bytes(), |nbuf| {\n         let _guard = ENV_LOCK.write();\n-        cvt(libc::unsetenv(nbuf.as_ptr())).map(drop)\n-    }\n+        cvt(unsafe { libc::unsetenv(nbuf.as_ptr()) }).map(drop)\n+    })\n }\n \n #[cfg(not(target_os = \"espidf\"))]"}, {"sha": "7df4add8ce112e7aec9a7dd411ed0e2c103f5615", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -154,9 +154,8 @@ impl Thread {\n \n     #[cfg(target_os = \"netbsd\")]\n     pub fn set_name(name: &CStr) {\n-        use crate::ffi::CString;\n-        let cname = CString::new(&b\"%s\"[..]).unwrap();\n         unsafe {\n+            let cname = CStr::from_bytes_with_nul_unchecked(b\"%s\\0\".as_slice());\n             libc::pthread_setname_np(\n                 libc::pthread_self(),\n                 cname.as_ptr(),"}, {"sha": "d4866bbc32badddc7320eb51ca7809a8d3bfa07f", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -1,7 +1,7 @@\n #![deny(unsafe_op_in_unsafe_fn)]\n \n use super::fd::WasiFd;\n-use crate::ffi::{CStr, CString, OsStr, OsString};\n+use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n use crate::iter;\n@@ -12,6 +12,7 @@ use crate::os::wasi::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::sync::Arc;\n+use crate::sys::common::small_c_string::run_path_with_cstr;\n use crate::sys::time::SystemTime;\n use crate::sys::unsupported;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -694,51 +695,52 @@ fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n /// Note that this can fail if `p` doesn't look like it can be opened relative\n /// to any pre-opened file descriptor.\n fn open_parent(p: &Path) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n-    let p = CString::new(p.as_os_str().as_bytes())?;\n-    let mut buf = Vec::<u8>::with_capacity(512);\n-    loop {\n-        unsafe {\n-            let mut relative_path = buf.as_ptr().cast();\n-            let mut abs_prefix = ptr::null();\n-            let fd = __wasilibc_find_relpath(\n-                p.as_ptr(),\n-                &mut abs_prefix,\n-                &mut relative_path,\n-                buf.capacity(),\n-            );\n-            if fd == -1 {\n-                if io::Error::last_os_error().raw_os_error() == Some(libc::ENOMEM) {\n-                    // Trigger the internal buffer resizing logic of `Vec` by requiring\n-                    // more space than the current capacity.\n-                    let cap = buf.capacity();\n-                    buf.set_len(cap);\n-                    buf.reserve(1);\n-                    continue;\n-                }\n-                let msg = format!(\n-                    \"failed to find a pre-opened file descriptor \\\n-                     through which {:?} could be opened\",\n-                    p\n+    run_path_with_cstr(p, |p| {\n+        let mut buf = Vec::<u8>::with_capacity(512);\n+        loop {\n+            unsafe {\n+                let mut relative_path = buf.as_ptr().cast();\n+                let mut abs_prefix = ptr::null();\n+                let fd = __wasilibc_find_relpath(\n+                    p.as_ptr(),\n+                    &mut abs_prefix,\n+                    &mut relative_path,\n+                    buf.capacity(),\n                 );\n-                return Err(io::Error::new(io::ErrorKind::Uncategorized, msg));\n-            }\n-            let relative = CStr::from_ptr(relative_path).to_bytes().to_vec();\n+                if fd == -1 {\n+                    if io::Error::last_os_error().raw_os_error() == Some(libc::ENOMEM) {\n+                        // Trigger the internal buffer resizing logic of `Vec` by requiring\n+                        // more space than the current capacity.\n+                        let cap = buf.capacity();\n+                        buf.set_len(cap);\n+                        buf.reserve(1);\n+                        continue;\n+                    }\n+                    let msg = format!(\n+                        \"failed to find a pre-opened file descriptor \\\n+                     through which {:?} could be opened\",\n+                        p\n+                    );\n+                    return Err(io::Error::new(io::ErrorKind::Uncategorized, msg));\n+                }\n+                let relative = CStr::from_ptr(relative_path).to_bytes().to_vec();\n \n-            return Ok((\n-                ManuallyDrop::new(WasiFd::from_raw_fd(fd as c_int)),\n-                PathBuf::from(OsString::from_vec(relative)),\n-            ));\n+                return Ok((\n+                    ManuallyDrop::new(WasiFd::from_raw_fd(fd as c_int)),\n+                    PathBuf::from(OsString::from_vec(relative)),\n+                ));\n+            }\n         }\n-    }\n \n-    extern \"C\" {\n-        pub fn __wasilibc_find_relpath(\n-            path: *const libc::c_char,\n-            abs_prefix: *mut *const libc::c_char,\n-            relative_path: *mut *const libc::c_char,\n-            relative_path_len: libc::size_t,\n-        ) -> libc::c_int;\n-    }\n+        extern \"C\" {\n+            pub fn __wasilibc_find_relpath(\n+                path: *const libc::c_char,\n+                abs_prefix: *mut *const libc::c_char,\n+                relative_path: *mut *const libc::c_char,\n+                relative_path_len: libc::size_t,\n+            ) -> libc::c_int;\n+        }\n+    })\n }\n \n pub fn osstr2str(f: &OsStr) -> io::Result<&str> {"}, {"sha": "cab2887dfcf1497be568ee4d73af63d02a7aa312", "filename": "library/std/src/sys/wasi/os.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fos.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -2,13 +2,14 @@\n \n use crate::any::Any;\n use crate::error::Error as StdError;\n-use crate::ffi::{CStr, CString, OsStr, OsString};\n+use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::marker::PhantomData;\n use crate::os::wasi::prelude::*;\n use crate::path::{self, PathBuf};\n use crate::str;\n+use crate::sys::common::small_c_string::{run_path_with_cstr, run_with_cstr};\n use crate::sys::memchr;\n use crate::sys::unsupported;\n use crate::vec;\n@@ -77,13 +78,10 @@ pub fn getcwd() -> io::Result<PathBuf> {\n }\n \n pub fn chdir(p: &path::Path) -> io::Result<()> {\n-    let p: &OsStr = p.as_ref();\n-    let p = CString::new(p.as_bytes())?;\n-    unsafe {\n-        match libc::chdir(p.as_ptr()) == (0 as libc::c_int) {\n-            true => Ok(()),\n-            false => Err(io::Error::last_os_error()),\n-        }\n+    let result = run_path_with_cstr(p, |p| unsafe { Ok(libc::chdir(p.as_ptr())) })?;\n+    match result == (0 as libc::c_int) {\n+        true => Ok(()),\n+        false => Err(io::Error::last_os_error()),\n     }\n }\n \n@@ -176,35 +174,32 @@ pub fn env() -> Env {\n }\n \n pub fn getenv(k: &OsStr) -> Option<OsString> {\n-    let k = CString::new(k.as_bytes()).ok()?;\n-    unsafe {\n+    let s = run_with_cstr(k.as_bytes(), |k| unsafe {\n         let _guard = env_lock();\n-        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n-        if s.is_null() {\n-            None\n-        } else {\n-            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n-        }\n+        Ok(libc::getenv(k.as_ptr()) as *const libc::c_char)\n+    })\n+    .ok()?;\n+    if s.is_null() {\n+        None\n+    } else {\n+        Some(OsStringExt::from_vec(unsafe { CStr::from_ptr(s) }.to_bytes().to_vec()))\n     }\n }\n \n pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n-    let k = CString::new(k.as_bytes())?;\n-    let v = CString::new(v.as_bytes())?;\n-\n-    unsafe {\n-        let _guard = env_lock();\n-        cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n-    }\n+    run_with_cstr(k.as_bytes(), |k| {\n+        run_with_cstr(v.as_bytes(), |v| unsafe {\n+            let _guard = env_lock();\n+            cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n+        })\n+    })\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n-    let nbuf = CString::new(n.as_bytes())?;\n-\n-    unsafe {\n+    run_with_cstr(n.as_bytes(), |nbuf| unsafe {\n         let _guard = env_lock();\n         cvt(libc::unsetenv(nbuf.as_ptr())).map(drop)\n-    }\n+    })\n }\n \n pub fn temp_dir() -> PathBuf {"}, {"sha": "fad4a63331b5976b11c57dfddf04a1aaea890e3d", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -2,12 +2,13 @@\n mod tests;\n \n use crate::cmp;\n-use crate::ffi::CString;\n+use crate::convert::{TryFrom, TryInto};\n use crate::fmt;\n use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::ptr;\n+use crate::sys::common::small_c_string::run_with_cstr;\n use crate::sys::net::netc as c;\n use crate::sys::net::{cvt, cvt_gai, cvt_r, init, wrlen_t, Socket};\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -197,14 +198,15 @@ impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n     fn try_from((host, port): (&'a str, u16)) -> io::Result<LookupHost> {\n         init();\n \n-        let c_host = CString::new(host)?;\n-        let mut hints: c::addrinfo = unsafe { mem::zeroed() };\n-        hints.ai_socktype = c::SOCK_STREAM;\n-        let mut res = ptr::null_mut();\n-        unsafe {\n-            cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res))\n-                .map(|_| LookupHost { original: res, cur: res, port })\n-        }\n+        run_with_cstr(host.as_bytes(), |c_host| {\n+            let mut hints: c::addrinfo = unsafe { mem::zeroed() };\n+            hints.ai_socktype = c::SOCK_STREAM;\n+            let mut res = ptr::null_mut();\n+            unsafe {\n+                cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res))\n+                    .map(|_| LookupHost { original: res, cur: res, port })\n+            }\n+        })\n     }\n }\n "}, {"sha": "269b1383aad68312bd2848831ce7cc25fd2bfb5b", "filename": "src/tools/miri/tests/fail/shims/fs/isolated_file.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b225414f325593f974c6b41e671a0a0dc5d7d5e/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fshims%2Ffs%2Fisolated_file.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b225414f325593f974c6b41e671a0a0dc5d7d5e/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fshims%2Ffs%2Fisolated_file.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fshims%2Ffs%2Fisolated_file.stderr?ref=1b225414f325593f974c6b41e671a0a0dc5d7d5e", "patch": "@@ -10,6 +10,9 @@ LL |         let fd = cvt_r(|| unsafe { open64(path.as_ptr(), flags, opts.mode a\n    = note: inside closure at RUSTLIB/std/src/sys/PLATFORM/fs.rs:LL:CC\n    = note: inside `std::sys::PLATFORM::cvt_r::<i32, [closure@std::sys::PLATFORM::fs::File::open_c::{closure#0}]>` at RUSTLIB/std/src/sys/PLATFORM/mod.rs:LL:CC\n    = note: inside `std::sys::PLATFORM::fs::File::open_c` at RUSTLIB/std/src/sys/PLATFORM/fs.rs:LL:CC\n+   = note: inside closure at RUSTLIB/std/src/sys/PLATFORM/fs.rs:LL:CC\n+   = note: inside `std::sys::PLATFORM::small_c_string::run_with_cstr::<std::sys::PLATFORM::fs::File, [closure@std::sys::PLATFORM::fs::File::open::{closure#0}]>` at RUSTLIB/std/src/sys/PLATFORM/small_c_string.rs:LL:CC\n+   = note: inside `std::sys::PLATFORM::small_c_string::run_path_with_cstr::<std::sys::PLATFORM::fs::File, [closure@std::sys::PLATFORM::fs::File::open::{closure#0}]>` at RUSTLIB/std/src/sys/PLATFORM/small_c_string.rs:LL:CC\n    = note: inside `std::sys::PLATFORM::fs::File::open` at RUSTLIB/std/src/sys/PLATFORM/fs.rs:LL:CC\n    = note: inside `std::fs::OpenOptions::_open` at RUSTLIB/std/src/fs.rs:LL:CC\n    = note: inside `std::fs::OpenOptions::open::<&std::path::Path>` at RUSTLIB/std/src/fs.rs:LL:CC"}]}