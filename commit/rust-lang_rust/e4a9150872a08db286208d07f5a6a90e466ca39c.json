{"sha": "e4a9150872a08db286208d07f5a6a90e466ca39c", "node_id": "C_kwDOAAsO6NoAKGU0YTkxNTA4NzJhMDhkYjI4NjIwOGQwN2Y1YTZhOTBlNDY2Y2EzOWM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-23T04:39:42Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-28T04:18:49Z"}, "message": "Rename `ast::Lit` as `ast::MetaItemLit`.", "tree": {"sha": "4ccd691623b0747027b11cebbadb2804ee9ee0e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ccd691623b0747027b11cebbadb2804ee9ee0e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4a9150872a08db286208d07f5a6a90e466ca39c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4a9150872a08db286208d07f5a6a90e466ca39c", "html_url": "https://github.com/rust-lang/rust/commit/e4a9150872a08db286208d07f5a6a90e466ca39c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4a9150872a08db286208d07f5a6a90e466ca39c/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa10aad1ac5058e8278d8871c1cb4473134d3d54", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa10aad1ac5058e8278d8871c1cb4473134d3d54", "html_url": "https://github.com/rust-lang/rust/commit/aa10aad1ac5058e8278d8871c1cb4473134d3d54"}], "stats": {"total": 187, "additions": 103, "deletions": 84}, "files": [{"sha": "5d470f1c453fe46e67514144555cdd364146d632", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -13,7 +13,7 @@\n //! - [`FnDecl`], [`FnHeader`] and [`Param`]: Metadata associated with a function declaration.\n //! - [`Generics`], [`GenericParam`], [`WhereClause`]: Metadata associated with generic parameters.\n //! - [`EnumDef`] and [`Variant`]: Enum declaration.\n-//! - [`Lit`] and [`LitKind`]: Literal expressions.\n+//! - [`MetaItemLit`] and [`LitKind`]: Literal expressions.\n //! - [`MacroDef`], [`MacStmtStyle`], [`MacCall`], [`MacDelimiter`]: Macro definition and invocation.\n //! - [`Attribute`]: Metadata associated with item.\n //! - [`UnOp`], [`BinOp`], and [`BinOpKind`]: Unary and binary operators.\n@@ -489,7 +489,7 @@ pub enum NestedMetaItem {\n     /// A literal.\n     ///\n     /// E.g., `\"foo\"`, `64`, `true`.\n-    Literal(Lit),\n+    Literal(MetaItemLit),\n }\n \n /// A spanned compile-time attribute item.\n@@ -518,7 +518,7 @@ pub enum MetaItemKind {\n     /// Name value meta item.\n     ///\n     /// E.g., `feature = \"foo\"` as in `#[feature = \"foo\"]`.\n-    NameValue(Lit),\n+    NameValue(MetaItemLit),\n }\n \n /// A block (`{ .. }`).\n@@ -1599,12 +1599,12 @@ pub enum AttrArgs {\n }\n \n // The RHS of an `AttrArgs::Eq` starts out as an expression. Once macro\n-// expansion is completed, all cases end up either as a literal, which is the\n-// form used after lowering to HIR, or as an error.\n+// expansion is completed, all cases end up either as a meta item literal,\n+// which is the form used after lowering to HIR, or as an error.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AttrArgsEq {\n     Ast(P<Expr>),\n-    Hir(Lit),\n+    Hir(MetaItemLit),\n }\n \n impl AttrArgs {\n@@ -1726,14 +1726,13 @@ pub enum StrStyle {\n     Raw(u8),\n }\n \n-/// An AST literal.\n+/// A literal in a meta item.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n-pub struct Lit {\n+pub struct MetaItemLit {\n     /// The original literal token as written in source code.\n     pub token_lit: token::Lit,\n     /// The \"semantic\" representation of the literal lowered from the original tokens.\n     /// Strings are unescaped, hexadecimal forms are eliminated, etc.\n-    /// FIXME: Remove this and only create the semantic representation during lowering to HIR.\n     pub kind: LitKind,\n     pub span: Span,\n }\n@@ -1783,6 +1782,8 @@ pub enum LitFloatType {\n     Unsuffixed,\n }\n \n+/// This type is used within both `ast::MetaItemLit` and `hir::Lit`.\n+///\n /// Note that the entire literal (including the suffix) is considered when\n /// deciding the `LitKind`. This means that float literals like `1f32` are\n /// classified by this type as `Float`. This is different to `token::LitKind`\n@@ -3096,9 +3097,9 @@ mod size_asserts {\n     static_assert_size!(Impl, 184);\n     static_assert_size!(Item, 184);\n     static_assert_size!(ItemKind, 112);\n-    static_assert_size!(Lit, 48);\n     static_assert_size!(LitKind, 24);\n     static_assert_size!(Local, 72);\n+    static_assert_size!(MetaItemLit, 48);\n     static_assert_size!(Param, 40);\n     static_assert_size!(Pat, 88);\n     static_assert_size!(Path, 24);"}, {"sha": "a31fe36dac70540d94b63b12a81dda2295b53c28", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -2,7 +2,7 @@\n \n use crate::ast;\n use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n-use crate::ast::{DelimArgs, Lit, LitKind};\n+use crate::ast::{DelimArgs, LitKind, MetaItemLit};\n use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Path, PathSegment};\n use crate::ptr::P;\n@@ -50,8 +50,8 @@ impl NestedMetaItem {\n         }\n     }\n \n-    /// Returns the `Lit` if `self` is a `NestedMetaItem::Literal`s.\n-    pub fn literal(&self) -> Option<&Lit> {\n+    /// Returns the `MetaItemLit` if `self` is a `NestedMetaItem::Literal`s.\n+    pub fn literal(&self) -> Option<&MetaItemLit> {\n         match self {\n             NestedMetaItem::Literal(lit) => Some(lit),\n             _ => None,\n@@ -78,7 +78,7 @@ impl NestedMetaItem {\n     }\n \n     /// Returns a name and single literal value tuple of the `MetaItem`.\n-    pub fn name_value_literal(&self) -> Option<(Symbol, &Lit)> {\n+    pub fn name_value_literal(&self) -> Option<(Symbol, &MetaItemLit)> {\n         self.meta_item().and_then(|meta_item| {\n             meta_item.meta_item_list().and_then(|meta_item_list| {\n                 if meta_item_list.len() == 1\n@@ -179,7 +179,7 @@ impl MetaItem {\n     ///     #[attribute(name = \"value\")]\n     ///                 ^^^^^^^^^^^^^^\n     /// ```\n-    pub fn name_value_literal(&self) -> Option<&Lit> {\n+    pub fn name_value_literal(&self) -> Option<&MetaItemLit> {\n         match &self.kind {\n             MetaItemKind::NameValue(v) => Some(v),\n             _ => None,\n@@ -334,7 +334,7 @@ pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> Meta\n }\n \n pub fn mk_name_value_item(ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n-    let lit = Lit::from_lit_kind(lit_kind, lit_span);\n+    let lit = MetaItemLit::from_lit_kind(lit_kind, lit_span);\n     let span = ident.span.to(lit_span);\n     MetaItem { path: Path::from_ident(ident), span, kind: MetaItemKind::NameValue(lit) }\n }\n@@ -604,7 +604,7 @@ impl MetaItemKind {\n                 MetaItemKind::name_value_from_tokens(&mut inner_tokens.into_trees())\n             }\n             Some(TokenTree::Token(token, _)) => {\n-                Lit::from_token(&token).map(MetaItemKind::NameValue)\n+                MetaItemLit::from_token(&token).map(MetaItemKind::NameValue)\n             }\n             _ => None,\n         }\n@@ -622,7 +622,7 @@ impl MetaItemKind {\n             AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n                 ast::ExprKind::Lit(token_lit) => {\n                     // Turn failures to `None`, we'll get parse errors elsewhere.\n-                    Lit::from_token_lit(token_lit, expr.span)\n+                    MetaItemLit::from_token_lit(token_lit, expr.span)\n                         .ok()\n                         .map(|lit| MetaItemKind::NameValue(lit))\n                 }\n@@ -674,7 +674,7 @@ impl NestedMetaItem {\n     {\n         match tokens.peek() {\n             Some(TokenTree::Token(token, _))\n-                if let Some(lit) = Lit::from_token(token) =>\n+                if let Some(lit) = MetaItemLit::from_token(token) =>\n             {\n                 tokens.next();\n                 return Some(NestedMetaItem::Literal(lit));"}, {"sha": "42cba07fcef8d41c6044d15f8e4571b97aeb00c7", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -1,6 +1,6 @@\n //! Code related to parsing literals.\n \n-use crate::ast::{self, Lit, LitKind};\n+use crate::ast::{self, LitKind, MetaItemLit};\n use crate::token::{self, Token};\n use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -195,26 +195,26 @@ impl LitKind {\n     }\n }\n \n-impl Lit {\n-    /// Converts literal token into an AST literal.\n-    pub fn from_token_lit(token_lit: token::Lit, span: Span) -> Result<Lit, LitError> {\n-        Ok(Lit { token_lit, kind: LitKind::from_token_lit(token_lit)?, span })\n+impl MetaItemLit {\n+    /// Converts token literal into a meta item literal.\n+    pub fn from_token_lit(token_lit: token::Lit, span: Span) -> Result<MetaItemLit, LitError> {\n+        Ok(MetaItemLit { token_lit, kind: LitKind::from_token_lit(token_lit)?, span })\n     }\n \n-    /// Converts an arbitrary token into an AST literal.\n-    pub fn from_token(token: &Token) -> Option<Lit> {\n+    /// Converts an arbitrary token into meta item literal.\n+    pub fn from_token(token: &Token) -> Option<MetaItemLit> {\n         token::Lit::from_token(token)\n-            .and_then(|token_lit| Lit::from_token_lit(token_lit, token.span).ok())\n+            .and_then(|token_lit| MetaItemLit::from_token_lit(token_lit, token.span).ok())\n     }\n \n-    /// Attempts to recover an AST literal from semantic literal.\n+    /// Attempts to create a meta item literal from a `LitKind`.\n     /// This function is used when the original token doesn't exist (e.g. the literal is created\n     /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n-    pub fn from_lit_kind(kind: LitKind, span: Span) -> Lit {\n-        Lit { token_lit: kind.to_token_lit(), kind, span }\n+    pub fn from_lit_kind(kind: LitKind, span: Span) -> MetaItemLit {\n+        MetaItemLit { token_lit: kind.to_token_lit(), kind, span }\n     }\n \n-    /// Losslessly convert an AST literal into a token.\n+    /// Losslessly convert a meta item literal into a token.\n     pub fn to_token(&self) -> Token {\n         let kind = match self.token_lit.kind {\n             token::Bool => token::Ident(self.token_lit.symbol, false),"}, {"sha": "ad6e72d015695efd1f2934881bf795f8074434d0", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -948,12 +948,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => {\n                 // In valid code the value always ends up as a single literal. Otherwise, a dummy\n                 // literal suffices because the error is handled elsewhere.\n-                let lit = if let ExprKind::Lit(token_lit) = expr.kind \n-                    && let Ok(lit) = Lit::from_token_lit(token_lit, expr.span)\n+                let lit = if let ExprKind::Lit(token_lit) = expr.kind\n+                    && let Ok(lit) = MetaItemLit::from_token_lit(token_lit, expr.span)\n                 {\n                     lit\n                 } else {\n-                    Lit {\n+                    MetaItemLit {\n                         token_lit: token::Lit::new(token::LitKind::Err, kw::Empty, None),\n                         kind: LitKind::Err,\n                         span: DUMMY_SP,"}, {"sha": "27faef25e67457604697af1b558ba63b166799c6", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -371,7 +371,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         }\n     }\n \n-    fn print_literal(&mut self, lit: &ast::Lit) {\n+    fn print_meta_item_lit(&mut self, lit: &ast::MetaItemLit) {\n         self.print_token_literal(lit.token_lit, lit.span)\n     }\n \n@@ -488,7 +488,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n-                let token_str = self.literal_to_string(lit);\n+                let token_str = self.meta_item_lit_to_string(lit);\n                 self.word(token_str);\n             }\n         }\n@@ -498,7 +498,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_meta_list_item(&mut self, item: &ast::NestedMetaItem) {\n         match item {\n             ast::NestedMetaItem::MetaItem(ref mi) => self.print_meta_item(mi),\n-            ast::NestedMetaItem::Literal(ref lit) => self.print_literal(lit),\n+            ast::NestedMetaItem::Literal(ref lit) => self.print_meta_item_lit(lit),\n         }\n     }\n \n@@ -510,7 +510,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n-                self.print_literal(value);\n+                self.print_meta_item_lit(value);\n             }\n             ast::MetaItemKind::List(ref items) => {\n                 self.print_path(&item.path, false, 0);\n@@ -825,8 +825,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         Self::to_string(|s| s.print_expr(e))\n     }\n \n-    fn literal_to_string(&self, lit: &ast::Lit) -> String {\n-        Self::to_string(|s| s.print_literal(lit))\n+    fn meta_item_lit_to_string(&self, lit: &ast::MetaItemLit) -> String {\n+        Self::to_string(|s| s.print_meta_item_lit(lit))\n     }\n \n     fn tt_to_string(&self, tt: &TokenTree) -> String {"}, {"sha": "ee2498a5724a122250718d1d4c5057ed12ae7291", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -1,7 +1,7 @@\n //! Parsing and validation of builtin attributes\n \n use rustc_ast as ast;\n-use rustc_ast::{Attribute, Lit, LitKind, MetaItem, MetaItemKind, NestedMetaItem, NodeId};\n+use rustc_ast::{Attribute, LitKind, MetaItem, MetaItemKind, MetaItemLit, NestedMetaItem, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n@@ -658,11 +658,13 @@ pub fn eval_condition(\n         ast::MetaItemKind::List(ref mis) if cfg.name_or_empty() == sym::version => {\n             try_gate_cfg(sym::version, cfg.span, sess, features);\n             let (min_version, span) = match &mis[..] {\n-                [NestedMetaItem::Literal(Lit { kind: LitKind::Str(sym, ..), span, .. })] => {\n-                    (sym, span)\n-                }\n                 [\n-                    NestedMetaItem::Literal(Lit { span, .. })\n+                    NestedMetaItem::Literal(MetaItemLit {\n+                        kind: LitKind::Str(sym, ..), span, ..\n+                    }),\n+                ] => (sym, span),\n+                [\n+                    NestedMetaItem::Literal(MetaItemLit { span, .. })\n                     | NestedMetaItem::MetaItem(MetaItem { span, .. }),\n                 ] => {\n                     sess.emit_err(session_diagnostics::ExpectedVersionLiteral { span: *span });"}, {"sha": "b9b3163acca6ae2d502cf6a0b5ef546cc9d96d95", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -50,7 +50,7 @@ impl MultiItemModifier for Expander {\n                         NestedMetaItem::MetaItem(meta) => Some(meta),\n                         NestedMetaItem::Literal(lit) => {\n                             // Reject `#[derive(\"Debug\")]`.\n-                            report_unexpected_literal(sess, &lit);\n+                            report_unexpected_meta_item_lit(sess, &lit);\n                             None\n                         }\n                     })\n@@ -127,7 +127,7 @@ fn report_bad_target(sess: &Session, item: &Annotatable, span: Span) -> bool {\n     bad_target\n }\n \n-fn report_unexpected_literal(sess: &Session, lit: &ast::Lit) {\n+fn report_unexpected_meta_item_lit(sess: &Session, lit: &ast::MetaItemLit) {\n     let help_msg = match lit.token_lit.kind {\n         token::Str if rustc_lexer::is_ident(lit.token_lit.symbol.as_str()) => {\n             format!(\"try using `#[derive({})]`\", lit.token_lit.symbol)"}, {"sha": "7616579611711984161c740745240ab4a9bac203", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -527,10 +527,7 @@ impl server::TokenStream for Rustc<'_, '_> {\n             }\n             ast::ExprKind::IncludedBytes(bytes) => {\n                 let lit = ast::LitKind::ByteStr(bytes.clone()).to_token_lit();\n-                Ok(tokenstream::TokenStream::token_alone(\n-                    token::TokenKind::Literal(lit),\n-                    expr.span,\n-                ))\n+                Ok(tokenstream::TokenStream::token_alone(token::TokenKind::Literal(lit), expr.span))\n             }\n             ast::ExprKind::Unary(ast::UnOp::Neg, e) => match &e.kind {\n                 ast::ExprKind::Lit(token_lit) => match token_lit {"}, {"sha": "9e92ca8243cc3d78d200bce6505f4d357d4e7ded", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -2145,7 +2145,7 @@ fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n }\n \n fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n-    use rustc_ast::{Lit, LitIntType, LitKind};\n+    use rustc_ast::{LitIntType, LitKind, MetaItemLit};\n     if !tcx.features().raw_dylib && tcx.sess.target.arch == \"x86\" {\n         feature_err(\n             &tcx.sess.parse_sess,\n@@ -2168,7 +2168,9 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n         }\n         _ => None,\n     };\n-    if let Some(Lit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) = sole_meta_list {\n+    if let Some(MetaItemLit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) =\n+        sole_meta_list\n+    {\n         // According to the table at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-header,\n         // the ordinal must fit into 16 bits.  Similarly, the Ordinal field in COFFShortExport (defined\n         // in llvm/include/llvm/Object/COFFImportFile.h), which we use to communicate import information"}, {"sha": "74c58e4fc4821c729936ef5a4af15f05cd9914bf", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -1191,8 +1191,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             debug!(\"layout_scalar_valid_range: attr={:?}\", attr);\n             if let Some(\n                 &[\n-                    ast::NestedMetaItem::Literal(ast::Lit {\n-                        kind: ast::LitKind::Int(a, _), ..\n+                    ast::NestedMetaItem::Literal(ast::MetaItemLit {\n+                        kind: ast::LitKind::Int(a, _),\n+                        ..\n                     }),\n                 ],\n             ) = attr.meta_item_list().as_deref()"}, {"sha": "c825554e2ffd2cf4a018d650bf916f409c8abeaf", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -315,8 +315,9 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    pub(crate) fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n-        let lit = self.parse_ast_lit()?;\n+    // Note: must be unsuffixed.\n+    pub(crate) fn parse_unsuffixed_meta_item_lit(&mut self) -> PResult<'a, ast::MetaItemLit> {\n+        let lit = self.parse_meta_item_lit()?;\n         debug!(\"checking if {:?} is unsuffixed\", lit);\n \n         if !lit.kind.is_unsuffixed() {\n@@ -391,7 +392,7 @@ impl<'a> Parser<'a> {\n \n     pub(crate) fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n         Ok(if self.eat(&token::Eq) {\n-            ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n+            ast::MetaItemKind::NameValue(self.parse_unsuffixed_meta_item_lit()?)\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             // Matches `meta_seq = ( COMMASEP(meta_item_inner) )`.\n             let (list, _) = self.parse_paren_comma_seq(|p| p.parse_meta_item_inner())?;\n@@ -403,7 +404,7 @@ impl<'a> Parser<'a> {\n \n     /// Matches `meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;`.\n     fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n-        match self.parse_unsuffixed_lit() {\n+        match self.parse_unsuffixed_meta_item_lit() {\n             Ok(lit) => return Ok(ast::NestedMetaItem::Literal(lit)),\n             Err(err) => err.cancel(),\n         }"}, {"sha": "e0443a697b50415fc950376706034f3aacdb9085", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -33,10 +33,10 @@ use rustc_ast::util::case::Case;\n use rustc_ast::util::classify;\n use rustc_ast::util::parser::{prec_let_scrutinee_needs_par, AssocOp, Fixity};\n use rustc_ast::visit::Visitor;\n-use rustc_ast::{self as ast, AttrStyle, AttrVec, CaptureBy, ExprField, Lit, UnOp, DUMMY_NODE_ID};\n+use rustc_ast::{self as ast, AttrStyle, AttrVec, CaptureBy, ExprField, UnOp, DUMMY_NODE_ID};\n use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty, TyKind};\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n-use rustc_ast::{ClosureBinder, StmtKind};\n+use rustc_ast::{ClosureBinder, MetaItemLit, StmtKind};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{\n     Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n@@ -1631,7 +1631,7 @@ impl<'a> Parser<'a> {\n         &self,\n         lifetime: Ident,\n         err: impl FnOnce(&Self) -> DiagnosticBuilder<'a, ErrorGuaranteed>,\n-    ) -> ast::Lit {\n+    ) -> ast::MetaItemLit {\n         if let Some(mut diag) =\n             self.sess.span_diagnostic.steal_diagnostic(lifetime.span, StashKey::LifetimeIsChar)\n         {\n@@ -1653,7 +1653,7 @@ impl<'a> Parser<'a> {\n                 .emit();\n         }\n         let name = lifetime.without_first_quote().name;\n-        ast::Lit {\n+        ast::MetaItemLit {\n             token_lit: token::Lit::new(token::LitKind::Char, name, None),\n             kind: ast::LitKind::Char(name.as_str().chars().next().unwrap_or('_')),\n             span: lifetime.span,\n@@ -1768,8 +1768,8 @@ impl<'a> Parser<'a> {\n     /// Returns a string literal if the next token is a string literal.\n     /// In case of error returns `Some(lit)` if the next token is a literal with a wrong kind,\n     /// and returns `None` if the next token is not literal at all.\n-    pub fn parse_str_lit(&mut self) -> Result<ast::StrLit, Option<Lit>> {\n-        match self.parse_opt_ast_lit() {\n+    pub fn parse_str_lit(&mut self) -> Result<ast::StrLit, Option<MetaItemLit>> {\n+        match self.parse_opt_meta_item_lit() {\n             Some(lit) => match lit.kind {\n                 ast::LitKind::Str(symbol_unescaped, style) => Ok(ast::StrLit {\n                     style,\n@@ -1784,7 +1784,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn handle_missing_lit(&mut self) -> PResult<'a, Lit> {\n+    fn handle_missing_lit(&mut self) -> PResult<'a, MetaItemLit> {\n         if let token::Interpolated(inner) = &self.token.kind {\n             let expr = match inner.as_ref() {\n                 token::NtExpr(expr) => Some(expr),\n@@ -1820,8 +1820,8 @@ impl<'a> Parser<'a> {\n             .or_else(|()| self.handle_missing_lit().map(|lit| (lit.token_lit, lit.span)))\n     }\n \n-    pub(super) fn parse_ast_lit(&mut self) -> PResult<'a, Lit> {\n-        self.parse_opt_ast_lit().ok_or(()).or_else(|()| self.handle_missing_lit())\n+    pub(super) fn parse_meta_item_lit(&mut self) -> PResult<'a, MetaItemLit> {\n+        self.parse_opt_meta_item_lit().ok_or(()).or_else(|()| self.handle_missing_lit())\n     }\n \n     fn recover_after_dot(&mut self) -> Option<Token> {\n@@ -1867,12 +1867,12 @@ impl<'a> Parser<'a> {\n \n     /// Matches `lit = true | false | token_lit`.\n     /// Returns `None` if the next token is not a literal.\n-    pub(super) fn parse_opt_ast_lit(&mut self) -> Option<Lit> {\n+    pub(super) fn parse_opt_meta_item_lit(&mut self) -> Option<MetaItemLit> {\n         let recovered = self.recover_after_dot();\n         let token = recovered.as_ref().unwrap_or(&self.token);\n         match token::Lit::from_token(token) {\n             Some(token_lit) => {\n-                match Lit::from_token_lit(token_lit, token.span) {\n+                match MetaItemLit::from_token_lit(token_lit, token.span) {\n                     Ok(lit) => {\n                         self.bump();\n                         Some(lit)\n@@ -1889,7 +1889,10 @@ impl<'a> Parser<'a> {\n                         let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n                         let symbol = Symbol::intern(&suffixless_lit.to_string());\n                         let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n-                        Some(Lit::from_token_lit(lit, span).unwrap_or_else(|_| unreachable!()))\n+                        Some(\n+                            MetaItemLit::from_token_lit(lit, span)\n+                                .unwrap_or_else(|_| unreachable!()),\n+                        )\n                     }\n                 }\n             }"}, {"sha": "ff1ddfd97dfc62dc52e183f64fb1280433d44ce7", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -358,7 +358,7 @@ impl<'a> Parser<'a> {\n     /// report error for `let 1x = 123`\n     pub fn report_invalid_identifier_error(&mut self) -> PResult<'a, ()> {\n         if let token::Literal(lit) = self.token.uninterpolate().kind &&\n-            rustc_ast::Lit::from_token(&self.token).is_none() &&\n+            rustc_ast::MetaItemLit::from_token(&self.token).is_none() &&\n             (lit.kind == token::LitKind::Integer || lit.kind == token::LitKind::Float) &&\n             self.look_ahead(1, |t| matches!(t.kind, token::Eq) || matches!(t.kind, token::Colon ) ) {\n                 return Err(self.sess.create_err(InvalidIdentiferStartsWithNumber { span: self.token.span }));"}, {"sha": "59e564114e5cf0e390ed38585e5f83c0c2026425", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -51,7 +51,7 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n             }\n             AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => {\n                 if let ast::ExprKind::Lit(token_lit) = expr.kind\n-                    && let Ok(lit) = ast::Lit::from_token_lit(token_lit, expr.span)\n+                    && let Ok(lit) = ast::MetaItemLit::from_token_lit(token_lit, expr.span)\n                 {\n                     if token_lit.suffix.is_some() {\n                         let mut err = sess.span_diagnostic.struct_span_err("}, {"sha": "c3794660d5c94957a575df348bb97c7de1915a1f", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -8,7 +8,7 @@ use crate::errors::{\n     self, AttrApplication, DebugVisualizerUnreadable, InvalidAttrAtCrateLevel, ObjectLifetimeErr,\n     OnlyHasEffectOn, TransparentIncompatible, UnrecognizedReprHint,\n };\n-use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{ast, AttrStyle, Attribute, LitKind, MetaItemKind, MetaItemLit, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{fluent, Applicability, MultiSpan};\n use rustc_expand::base::resolve_path;\n@@ -1355,7 +1355,10 @@ impl CheckAttrVisitor<'_> {\n             return false;\n         };\n \n-        if matches!(&list[..], &[NestedMetaItem::Literal(Lit { kind: LitKind::Int(..), .. })]) {\n+        if matches!(\n+            &list[..],\n+            &[NestedMetaItem::Literal(MetaItemLit { kind: LitKind::Int(..), .. })]\n+        ) {\n             true\n         } else {\n             self.tcx.sess.emit_err(errors::RustcLayoutScalarValidRangeArg { attr_span: attr.span });"}, {"sha": "018f10f258867872816e22b5f9604ee0cbc57a0f", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -6,7 +6,7 @@ use clippy_utils::msrvs;\n use clippy_utils::source::{first_line_of_span, is_present_in_source, snippet_opt, without_block_comments};\n use clippy_utils::{extract_msrv_attr, meets_msrv};\n use if_chain::if_chain;\n-use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{AttrKind, AttrStyle, Attribute, LitKind, MetaItemKind, MetaItemLit, NestedMetaItem};\n use rustc_errors::Applicability;\n use rustc_hir::{\n     Block, Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, StmtKind, TraitFn, TraitItem, TraitItemKind,\n@@ -576,7 +576,7 @@ fn check_attrs(cx: &LateContext<'_>, span: Span, name: Symbol, attrs: &[Attribut\n     }\n }\n \n-fn check_semver(cx: &LateContext<'_>, span: Span, lit: &Lit) {\n+fn check_semver(cx: &LateContext<'_>, span: Span, lit: &MetaItemLit) {\n     if let LitKind::Str(is, _) = lit.kind {\n         if Version::parse(is.as_str()).is_ok() {\n             return;"}, {"sha": "8cba2a850e5bc266c91288c31896c19da860df4a", "filename": "src/tools/rustfmt/src/attr.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -527,14 +527,19 @@ pub(crate) trait MetaVisitor<'ast> {\n \n     fn visit_meta_word(&mut self, _meta_item: &'ast ast::MetaItem) {}\n \n-    fn visit_meta_name_value(&mut self, _meta_item: &'ast ast::MetaItem, _lit: &'ast ast::Lit) {}\n+    fn visit_meta_name_value(\n+        &mut self,\n+        _meta_item: &'ast ast::MetaItem,\n+        _lit: &'ast ast::MetaItemLit,\n+    ) {\n+    }\n \n     fn visit_nested_meta_item(&mut self, nm: &'ast ast::NestedMetaItem) {\n         match nm {\n             ast::NestedMetaItem::MetaItem(ref meta_item) => self.visit_meta_item(meta_item),\n-            ast::NestedMetaItem::Literal(ref lit) => self.visit_literal(lit),\n+            ast::NestedMetaItem::Literal(ref lit) => self.visit_meta_item_lit(lit),\n         }\n     }\n \n-    fn visit_literal(&mut self, _lit: &'ast ast::Lit) {}\n+    fn visit_meta_item_lit(&mut self, _lit: &'ast ast::MetaItemLit) {}\n }"}, {"sha": "48431693332a619211a269c29da2669ed3d78ae3", "filename": "src/tools/rustfmt/src/modules/visitor.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4a9150872a08db286208d07f5a6a90e466ca39c/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a9150872a08db286208d07f5a6a90e466ca39c/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs?ref=e4a9150872a08db286208d07f5a6a90e466ca39c", "patch": "@@ -84,23 +84,27 @@ impl PathVisitor {\n }\n \n impl<'ast> MetaVisitor<'ast> for PathVisitor {\n-    fn visit_meta_name_value(&mut self, meta_item: &'ast ast::MetaItem, lit: &'ast ast::Lit) {\n+    fn visit_meta_name_value(\n+        &mut self,\n+        meta_item: &'ast ast::MetaItem,\n+        lit: &'ast ast::MetaItemLit,\n+    ) {\n         if meta_item.has_name(Symbol::intern(\"path\")) && lit.kind.is_str() {\n-            self.paths.push(lit_to_str(lit));\n+            self.paths.push(meta_item_lit_to_str(lit));\n         }\n     }\n }\n \n #[cfg(not(windows))]\n-fn lit_to_str(lit: &ast::Lit) -> String {\n+fn meta_item_lit_to_str(lit: &ast::MetaItemLit) -> String {\n     match lit.kind {\n         ast::LitKind::Str(symbol, ..) => symbol.to_string(),\n         _ => unreachable!(),\n     }\n }\n \n #[cfg(windows)]\n-fn lit_to_str(lit: &ast::Lit) -> String {\n+fn meta_item_lit_to_str(lit: &ast::MetaItemLit) -> String {\n     match lit.kind {\n         ast::LitKind::Str(symbol, ..) => symbol.as_str().replace(\"/\", \"\\\\\"),\n         _ => unreachable!(),"}]}