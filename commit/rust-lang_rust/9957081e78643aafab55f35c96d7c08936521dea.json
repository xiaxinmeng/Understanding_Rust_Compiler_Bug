{"sha": "9957081e78643aafab55f35c96d7c08936521dea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NTcwODFlNzg2NDNhYWZhYjU1ZjM1Yzk2ZDdjMDg5MzY1MjFkZWE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-30T23:34:59Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-30T23:34:59Z"}, "message": "Rollup merge of #32259 - oli-obk:move_const_eval, r=alexcrichton\n\nmove `const_eval` and `check_match` out of `librustc` into their own crate\n\nr? @arielb1", "tree": {"sha": "92dbdbd7c0a12ba4af11a7470c6dcfe085a7d5db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92dbdbd7c0a12ba4af11a7470c6dcfe085a7d5db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9957081e78643aafab55f35c96d7c08936521dea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9957081e78643aafab55f35c96d7c08936521dea", "html_url": "https://github.com/rust-lang/rust/commit/9957081e78643aafab55f35c96d7c08936521dea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9957081e78643aafab55f35c96d7c08936521dea/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfacabc6a2b59771aa336ff420c363d9695a6ad2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfacabc6a2b59771aa336ff420c363d9695a6ad2", "html_url": "https://github.com/rust-lang/rust/commit/bfacabc6a2b59771aa336ff420c363d9695a6ad2"}, {"sha": "3eac64747f520ec29195c9040348e028f22058aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eac64747f520ec29195c9040348e028f22058aa", "html_url": "https://github.com/rust-lang/rust/commit/3eac64747f520ec29195c9040348e028f22058aa"}], "stats": {"total": 1708, "additions": 922, "deletions": 786}, "files": [{"sha": "8c80335e772bb8145f301dbaaa4396cbfe897f38", "filename": "mk/crates.mk", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -58,7 +58,7 @@ RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_front rustc_platform_intrinsics \\\n                 rustc_plugin rustc_metadata rustc_passes rustc_save_analysis \\\n-                rustc_const_eval\n+                rustc_const_eval rustc_const_math\n HOST_CRATES := syntax syntax_ext $(RUSTC_CRATES) rustdoc fmt_macros \\\n \t\tflate arena graphviz rbml log serialize\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n@@ -92,36 +92,39 @@ DEPS_test := std getopts term native:rust_test_helpers\n DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode\n DEPS_syntax_ext := syntax fmt_macros\n \n-DEPS_rustc_const_eval := std syntax\n+DEPS_rustc_const_math := std syntax log serialize\n+DEPS_rustc_const_eval := rustc_const_math rustc syntax log serialize rustc_front \\\n+\t\t\t\t\t     rustc_back graphviz\n \n DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml rustc_front\\\n               log graphviz rustc_back rustc_data_structures\\\n-\t\t  \t  rustc_const_eval\n+\t\t  \t  rustc_const_math\n DEPS_rustc_back := std syntax rustc_front flate log libc\n DEPS_rustc_borrowck := rustc rustc_front rustc_mir log graphviz syntax\n DEPS_rustc_data_structures := std log serialize\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\\n \t             rustc_trans rustc_privacy rustc_lint rustc_front rustc_plugin \\\n-                     rustc_metadata syntax_ext rustc_passes rustc_save_analysis\n+                     rustc_metadata syntax_ext rustc_passes rustc_save_analysis rustc_const_eval\n DEPS_rustc_front := std syntax log serialize\n-DEPS_rustc_lint := rustc log syntax\n+DEPS_rustc_lint := rustc log syntax rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n-DEPS_rustc_metadata := rustc rustc_front syntax rbml rustc_const_eval\n-DEPS_rustc_passes := syntax rustc core rustc_front\n-DEPS_rustc_mir := rustc rustc_front syntax rustc_const_eval\n+DEPS_rustc_metadata := rustc rustc_front syntax rbml rustc_const_math\n+DEPS_rustc_passes := syntax rustc core rustc_front rustc_const_eval\n+DEPS_rustc_mir := rustc rustc_front syntax rustc_const_math rustc_const_eval\n DEPS_rustc_resolve := arena rustc rustc_front log syntax\n DEPS_rustc_platform_intrinsics := std\n DEPS_rustc_plugin := rustc rustc_metadata syntax rustc_mir\n DEPS_rustc_privacy := rustc rustc_front log syntax\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back rustc_mir \\\n                     log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics \\\n-\t\t\t\t\trustc_const_eval\n+                    rustc_const_math rustc_const_eval\n DEPS_rustc_save_analysis := rustc log syntax rustc_front\n-DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics rustc_const_eval\n+DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics rustc_const_math \\\n+                     rustc_const_eval\n \n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n-                test rustc_lint rustc_front\n+                test rustc_lint rustc_front rustc_const_eval\n \n \n TOOL_DEPS_compiletest := test getopts log"}, {"sha": "cdbe8696a90d471de9c8288d1ad7f028542ec726", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -18,7 +18,7 @@ log = { path = \"../liblog\" }\n rbml = { path = \"../librbml\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_front = { path = \"../librustc_front\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "117b1119c0a99eb073560023a2c9a08a4bac39a9", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 521, "changes": 521, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -14,273 +14,6 @@\n // Each message should start and end with a new line, and be wrapped to 80 characters.\n // In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n register_long_diagnostics! {\n-\n-E0001: r##\"\n-This error suggests that the expression arm corresponding to the noted pattern\n-will never be reached as for all possible values of the expression being\n-matched, one of the preceding patterns will match.\n-\n-This means that perhaps some of the preceding patterns are too general, this\n-one is too specific or the ordering is incorrect.\n-\n-For example, the following `match` block has too many arms:\n-\n-```compile_fail\n-match foo {\n-    Some(bar) => {/* ... */}\n-    None => {/* ... */}\n-    _ => {/* ... */} // All possible cases have already been handled\n-}\n-```\n-\n-`match` blocks have their patterns matched in order, so, for example, putting\n-a wildcard arm above a more specific arm will make the latter arm irrelevant.\n-\n-Ensure the ordering of the match arm is correct and remove any superfluous\n-arms.\n-\"##,\n-\n-E0002: r##\"\n-This error indicates that an empty match expression is invalid because the type\n-it is matching on is non-empty (there exist values of this type). In safe code\n-it is impossible to create an instance of an empty type, so empty match\n-expressions are almost never desired. This error is typically fixed by adding\n-one or more cases to the match expression.\n-\n-An example of an empty type is `enum Empty { }`. So, the following will work:\n-\n-```\n-enum Empty {}\n-\n-fn foo(x: Empty) {\n-    match x {\n-        // empty\n-    }\n-}\n-```\n-\n-However, this won't:\n-\n-```compile_fail\n-enum Empty {}\n-\n-fn foo(x: Option<String>) {\n-    match x {\n-        // empty\n-    }\n-}\n-```\n-\"##,\n-\n-E0003: r##\"\n-Not-a-Number (NaN) values cannot be compared for equality and hence can never\n-match the input to a match expression. So, the following will not compile:\n-\n-```compile_fail\n-const NAN: f32 = 0.0 / 0.0;\n-\n-let number = 0.1f32;\n-\n-match number {\n-    NAN => { /* ... */ },\n-    _ => {}\n-}\n-```\n-\n-To match against NaN values, you should instead use the `is_nan()` method in a\n-guard, like so:\n-\n-```\n-let number = 0.1f32;\n-\n-match number {\n-    x if x.is_nan() => { /* ... */ }\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0004: r##\"\n-This error indicates that the compiler cannot guarantee a matching pattern for\n-one or more possible inputs to a match expression. Guaranteed matches are\n-required in order to assign values to match expressions, or alternatively,\n-determine the flow of execution. Erroneous code example:\n-\n-```compile_fail\n-enum Terminator {\n-    HastaLaVistaBaby,\n-    TalkToMyHand,\n-}\n-\n-let x = Terminator::HastaLaVistaBaby;\n-\n-match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n-    Terminator::TalkToMyHand => {}\n-}\n-```\n-\n-If you encounter this error you must alter your patterns so that every possible\n-value of the input type is matched. For types with a small number of variants\n-(like enums) you should probably cover all cases explicitly. Alternatively, the\n-underscore `_` wildcard pattern can be added after all other patterns to match\n-\"anything else\". Example:\n-\n-```\n-enum Terminator {\n-    HastaLaVistaBaby,\n-    TalkToMyHand,\n-}\n-\n-let x = Terminator::HastaLaVistaBaby;\n-\n-match x {\n-    Terminator::TalkToMyHand => {}\n-    Terminator::HastaLaVistaBaby => {}\n-}\n-\n-// or:\n-\n-match x {\n-    Terminator::TalkToMyHand => {}\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0005: r##\"\n-Patterns used to bind names must be irrefutable, that is, they must guarantee\n-that a name will be extracted in all cases. Erroneous code example:\n-\n-```compile_fail\n-let x = Some(1);\n-let Some(y) = x;\n-// error: refutable pattern in local binding: `None` not covered\n-```\n-\n-If you encounter this error you probably need to use a `match` or `if let` to\n-deal with the possibility of failure. Example:\n-\n-```compile_fail\n-let x = Some(1);\n-\n-match x {\n-    Some(y) => {\n-        // do something\n-    },\n-    None => {}\n-}\n-\n-// or:\n-\n-if let Some(y) = x {\n-    // do something\n-}\n-```\n-\"##,\n-\n-E0007: r##\"\n-This error indicates that the bindings in a match arm would require a value to\n-be moved into more than one location, thus violating unique ownership. Code\n-like the following is invalid as it requires the entire `Option<String>` to be\n-moved into a variable called `op_string` while simultaneously requiring the\n-inner `String` to be moved into a variable called `s`.\n-\n-```compile_fail\n-let x = Some(\"s\".to_string());\n-\n-match x {\n-    op_string @ Some(s) => {},\n-    None => {},\n-}\n-```\n-\n-See also the error E0303.\n-\"##,\n-\n-E0008: r##\"\n-Names bound in match arms retain their type in pattern guards. As such, if a\n-name is bound by move in a pattern, it should also be moved to wherever it is\n-referenced in the pattern guard code. Doing so however would prevent the name\n-from being available in the body of the match arm. Consider the following:\n-\n-```compile_fail\n-match Some(\"hi\".to_string()) {\n-    Some(s) if s.len() == 0 => {}, // use s.\n-    _ => {},\n-}\n-```\n-\n-The variable `s` has type `String`, and its use in the guard is as a variable of\n-type `String`. The guard code effectively executes in a separate scope to the\n-body of the arm, so the value would be moved into this anonymous scope and\n-therefore become unavailable in the body of the arm. Although this example seems\n-innocuous, the problem is most clear when considering functions that take their\n-argument by value.\n-\n-```compile_fail\n-match Some(\"hi\".to_string()) {\n-    Some(s) if { drop(s); false } => (),\n-    Some(s) => {}, // use s.\n-    _ => {},\n-}\n-```\n-\n-The value would be dropped in the guard then become unavailable not only in the\n-body of that arm but also in all subsequent arms! The solution is to bind by\n-reference when using guards or refactor the entire expression, perhaps by\n-putting the condition inside the body of the arm.\n-\"##,\n-\n-E0009: r##\"\n-In a pattern, all values that don't implement the `Copy` trait have to be bound\n-the same way. The goal here is to avoid binding simultaneously by-move and\n-by-ref.\n-\n-This limitation may be removed in a future version of Rust.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((y, ref z)) => {},\n-    None => panic!()\n-}\n-```\n-\n-You have two solutions:\n-\n-Solution #1: Bind the pattern's values the same way.\n-\n-```\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((ref y, ref z)) => {},\n-    // or Some((y, z)) => {}\n-    None => panic!()\n-}\n-```\n-\n-Solution #2: Implement the `Copy` trait for the `X` structure.\n-\n-However, please keep in mind that the first solution should be preferred.\n-\n-```\n-#[derive(Clone, Copy)]\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((y, ref z)) => {},\n-    None => panic!()\n-}\n-```\n-\"##,\n-\n E0020: r##\"\n This error indicates that an attempt was made to divide by zero (or take the\n remainder of a zero divisor) in a static or constant expression. Erroneous\n@@ -762,128 +495,6 @@ attributes:\n See also https://doc.rust-lang.org/book/no-stdlib.html\n \"##,\n \n-E0158: r##\"\n-`const` and `static` mean different things. A `const` is a compile-time\n-constant, an alias for a literal value. This property means you can match it\n-directly within a pattern.\n-\n-The `static` keyword, on the other hand, guarantees a fixed location in memory.\n-This does not always mean that the value is constant. For example, a global\n-mutex can be declared `static` as well.\n-\n-If you want to match against a `static`, consider using a guard instead:\n-\n-```\n-static FORTY_TWO: i32 = 42;\n-\n-match Some(42) {\n-    Some(x) if x == FORTY_TWO => {}\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0162: r##\"\n-An if-let pattern attempts to match the pattern, and enters the body if the\n-match was successful. If the match is irrefutable (when it cannot fail to\n-match), use a regular `let`-binding instead. For instance:\n-\n-```compile_fail\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-// This fails to compile because the match is irrefutable.\n-if let Irrefutable(x) = irr {\n-    // This body will always be executed.\n-    foo(x);\n-}\n-```\n-\n-Try this instead:\n-\n-```ignore\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-let Irrefutable(x) = irr;\n-foo(x);\n-```\n-\"##,\n-\n-E0165: r##\"\n-A while-let pattern attempts to match the pattern, and enters the body if the\n-match was successful. If the match is irrefutable (when it cannot fail to\n-match), use a regular `let`-binding inside a `loop` instead. For instance:\n-\n-```compile_fail\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-// This fails to compile because the match is irrefutable.\n-while let Irrefutable(x) = irr {\n-    ...\n-}\n-\n-Try this instead:\n-\n-```\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-loop {\n-    let Irrefutable(x) = irr;\n-    ...\n-}\n-```\n-\"##,\n-\n-E0170: r##\"\n-Enum variants are qualified by default. For example, given this type:\n-\n-```\n-enum Method {\n-    GET,\n-    POST,\n-}\n-```\n-\n-You would match it using:\n-\n-```\n-enum Method {\n-    GET,\n-    POST,\n-}\n-\n-let m = Method::GET;\n-\n-match m {\n-    Method::GET => {},\n-    Method::POST => {},\n-}\n-```\n-\n-If you don't qualify the names, the code will bind new variables named \"GET\" and\n-\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n-that happens.\n-\n-Qualified names are good practice, and most code works well with them. But if\n-you prefer them unqualified, you can import the variants into scope:\n-\n-```ignore\n-use Method::*;\n-enum Method { GET, POST }\n-```\n-\n-If you want others to be able to import variants from your module directly, use\n-`pub use`:\n-\n-```ignore\n-pub use Method::*;\n-enum Method { GET, POST }\n-```\n-\"##,\n-\n E0229: r##\"\n An associated type binding was done outside of the type parameter declaration\n and `where` clause. Erroneous code example:\n@@ -1573,135 +1184,6 @@ that the value provided is a positive integer between quotes, like so:\n ```\n \"##,\n \n-E0297: r##\"\n-Patterns used to bind names must be irrefutable. That is, they must guarantee\n-that a name will be extracted in all cases. Instead of pattern matching the\n-loop variable, consider using a `match` or `if let` inside the loop body. For\n-instance:\n-\n-```compile_fail\n-let xs : Vec<Option<i32>> = vec!(Some(1), None);\n-\n-// This fails because `None` is not covered.\n-for Some(x) in xs {\n-    // ...\n-}\n-```\n-\n-Match inside the loop instead:\n-\n-```\n-let xs : Vec<Option<i32>> = vec!(Some(1), None);\n-\n-for item in xs {\n-    match item {\n-        Some(x) => {},\n-        None => {},\n-    }\n-}\n-```\n-\n-Or use `if let`:\n-\n-```\n-let xs : Vec<Option<i32>> = vec!(Some(1), None);\n-\n-for item in xs {\n-    if let Some(x) = item {\n-        // ...\n-    }\n-}\n-```\n-\"##,\n-\n-E0301: r##\"\n-Mutable borrows are not allowed in pattern guards, because matching cannot have\n-side effects. Side effects could alter the matched object or the environment\n-on which the match depends in such a way, that the match would not be\n-exhaustive. For instance, the following would not match any arm if mutable\n-borrows were allowed:\n-\n-```compile_fail\n-match Some(()) {\n-    None => { },\n-    option if option.take().is_none() => {\n-        /* impossible, option is `Some` */\n-    },\n-    Some(_) => { } // When the previous match failed, the option became `None`.\n-}\n-```\n-\"##,\n-\n-E0302: r##\"\n-Assignments are not allowed in pattern guards, because matching cannot have\n-side effects. Side effects could alter the matched object or the environment\n-on which the match depends in such a way, that the match would not be\n-exhaustive. For instance, the following would not match any arm if assignments\n-were allowed:\n-\n-```compile_fail\n-match Some(()) {\n-    None => { },\n-    option if { option = None; false } { },\n-    Some(_) => { } // When the previous match failed, the option became `None`.\n-}\n-```\n-\"##,\n-\n-E0303: r##\"\n-In certain cases it is possible for sub-bindings to violate memory safety.\n-Updates to the borrow checker in a future version of Rust may remove this\n-restriction, but for now patterns must be rewritten without sub-bindings.\n-\n-```ignore\n-// Before.\n-match Some(\"hi\".to_string()) {\n-    ref op_string_ref @ Some(s) => {},\n-    None => {},\n-}\n-\n-// After.\n-match Some(\"hi\".to_string()) {\n-    Some(ref s) => {\n-        let op_string_ref = &Some(s);\n-        // ...\n-    },\n-    None => {},\n-}\n-```\n-\n-The `op_string_ref` binding has type `&Option<&String>` in both cases.\n-\n-See also https://github.com/rust-lang/rust/issues/14587\n-\"##,\n-\n-E0306: r##\"\n-In an array literal `[x; N]`, `N` is the number of elements in the array. This\n-must be an unsigned integer. Erroneous code example:\n-\n-```compile_fail\n-let x = [0i32; true]; // error: expected positive integer for repeat count,\n-                      //        found boolean\n-```\n-\n-Working example:\n-\n-```\n-let x = [0i32; 2];\n-```\n-\"##,\n-\n-E0307: r##\"\n-The length of an array is part of its type. For this reason, this length must\n-be a compile-time constant. Erroneous code example:\n-\n-```compile_fail\n-    let len = 10;\n-    let x = [0i32; len]; // error: expected constant integer for repeat count,\n-                         //        found variable\n-```\n-\"##,\n-\n E0308: r##\"\n This error occurs when the compiler was unable to infer the concrete type of a\n variable. It can occur for several cases, the most common of which is a\n@@ -1991,8 +1473,6 @@ register_diagnostics! {\n     E0280, // requirement is not satisfied\n     E0284, // cannot resolve type\n //  E0285, // overflow evaluation builtin bounds\n-    E0298, // mismatched types between arms\n-    E0299, // mismatched types between arms\n //  E0300, // unexpanded macro\n //  E0304, // expected signed integer constant\n //  E0305, // expected constant\n@@ -2003,7 +1483,6 @@ register_diagnostics! {\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n     E0453, // overruled by outer forbid\n-    E0471, // constant evaluation error: ..\n     E0473, // dereference of reference outside its lifetime\n     E0474, // captured variable `..` does not outlive the enclosing closure\n     E0475, // index of slice outside its lifetime"}, {"sha": "03a08231c74335df807737342a01832fba556067", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -55,7 +55,7 @@ extern crate rustc_front;\n extern crate rustc_data_structures;\n extern crate serialize;\n extern crate collections;\n-extern crate rustc_const_eval;\n+extern crate rustc_const_math;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n@@ -91,8 +91,7 @@ pub mod lint;\n pub mod middle {\n     pub mod astconv_util;\n     pub mod expr_use_visitor; // STAGE0: increase glitch immunity\n-    pub mod check_match;\n-    pub mod const_eval;\n+    pub mod const_val;\n     pub mod const_qualif;\n     pub mod cstore;\n     pub mod dataflow;"}, {"sha": "a939389c460ea71d4dd65b5dfe00ba6b12b98c9e", "filename": "src/librustc/middle/const_val.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::parse::token::InternedString;\n+use syntax::ast;\n+use std::rc::Rc;\n+use middle::def_id::DefId;\n+use std::hash;\n+use std::mem::transmute;\n+use rustc_const_math::*;\n+use self::ConstVal::*;\n+\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum ConstVal {\n+    Float(f64),\n+    Integral(ConstInt),\n+    Str(InternedString),\n+    ByteStr(Rc<Vec<u8>>),\n+    Bool(bool),\n+    Struct(ast::NodeId),\n+    Tuple(ast::NodeId),\n+    Function(DefId),\n+    Array(ast::NodeId, u64),\n+    Repeat(ast::NodeId, u64),\n+    Char(char),\n+    /// A value that only occurs in case `eval_const_expr` reported an error. You should never\n+    /// handle this case. Its sole purpose is to allow more errors to be reported instead of\n+    /// causing a fatal error.\n+    Dummy,\n+}\n+\n+impl hash::Hash for ConstVal {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        match *self {\n+            Float(a) => unsafe { transmute::<_,u64>(a) }.hash(state),\n+            Integral(a) => a.hash(state),\n+            Str(ref a) => a.hash(state),\n+            ByteStr(ref a) => a.hash(state),\n+            Bool(a) => a.hash(state),\n+            Struct(a) => a.hash(state),\n+            Tuple(a) => a.hash(state),\n+            Function(a) => a.hash(state),\n+            Array(a, n) => { a.hash(state); n.hash(state) },\n+            Repeat(a, n) => { a.hash(state); n.hash(state) },\n+            Char(c) => c.hash(state),\n+            Dummy => ().hash(state),\n+        }\n+    }\n+}\n+\n+/// Note that equality for `ConstVal` means that the it is the same\n+/// constant, not that the rust values are equal. In particular, `NaN\n+/// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n+/// are considering unequal).\n+impl PartialEq for ConstVal {\n+    fn eq(&self, other: &ConstVal) -> bool {\n+        match (self, other) {\n+            (&Float(a), &Float(b)) => unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)},\n+            (&Integral(a), &Integral(b)) => a == b,\n+            (&Str(ref a), &Str(ref b)) => a == b,\n+            (&ByteStr(ref a), &ByteStr(ref b)) => a == b,\n+            (&Bool(a), &Bool(b)) => a == b,\n+            (&Struct(a), &Struct(b)) => a == b,\n+            (&Tuple(a), &Tuple(b)) => a == b,\n+            (&Function(a), &Function(b)) => a == b,\n+            (&Array(a, an), &Array(b, bn)) => (a == b) && (an == bn),\n+            (&Repeat(a, an), &Repeat(b, bn)) => (a == b) && (an == bn),\n+            (&Char(a), &Char(b)) => a == b,\n+            (&Dummy, &Dummy) => true, // FIXME: should this be false?\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Eq for ConstVal { }\n+\n+impl ConstVal {\n+    pub fn description(&self) -> &'static str {\n+        match *self {\n+            Float(_) => \"float\",\n+            Integral(i) => i.description(),\n+            Str(_) => \"string literal\",\n+            ByteStr(_) => \"byte string literal\",\n+            Bool(_) => \"boolean\",\n+            Struct(_) => \"struct\",\n+            Tuple(_) => \"tuple\",\n+            Function(_) => \"function definition\",\n+            Array(..) => \"array\",\n+            Repeat(..) => \"repeat\",\n+            Char(..) => \"char\",\n+            Dummy => \"dummy value\",\n+        }\n+    }\n+}"}, {"sha": "bc10d0c90ef063a55984015b5deb5167662b34e7", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use graphviz::IntoCow;\n-use middle::const_eval::ConstVal;\n-use rustc_const_eval::{ConstUsize, ConstInt};\n+use middle::const_val::ConstVal;\n+use rustc_const_math::{ConstUsize, ConstInt};\n use middle::def_id::DefId;\n use ty::subst::Substs;\n use ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n@@ -999,7 +999,7 @@ impl<'tcx> Debug for Literal<'tcx> {\n \n /// Write a `ConstVal` in a way closer to the original source code than the `Debug` output.\n fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n-    use middle::const_eval::ConstVal::*;\n+    use middle::const_val::ConstVal::*;\n     match *const_val {\n         Float(f) => write!(fmt, \"{:?}\", f),\n         Integral(n) => write!(fmt, \"{}\", n),"}, {"sha": "403c749fe4bcba674075b26d6793bc922a14096d", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::const_eval::ConstVal;\n+use middle::const_val::ConstVal;\n use middle::def_id::DefId;\n use ty::subst::Substs;\n use ty::{ClosureSubsts, FnOutput, Region, Ty};\n use mir::repr::*;\n-use rustc_const_eval::ConstUsize;\n+use rustc_const_math::ConstUsize;\n use rustc_data_structures::tuple_slice::TupleSlice;\n use syntax::codemap::Span;\n "}, {"sha": "5c754fc12d7d8cc29a1e5a91b4b04669658071dc", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -50,7 +50,7 @@ use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n \n-use rustc_const_eval::ConstInt;\n+use rustc_const_math::ConstInt;\n \n use rustc_front::hir;\n use rustc_front::hir::{ItemImpl, ItemTrait, PatKind};"}, {"sha": "a3aa3f31cd1f25b7f4c2579de07f8733380b8266", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -11,8 +11,6 @@\n //! misc. type-system utilities too small to deserve their own file\n \n use back::svh::Svh;\n-use middle::const_eval::{self, ConstVal, ErrKind};\n-use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def_id::DefId;\n use ty::subst;\n use infer;\n@@ -22,7 +20,7 @@ use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n use ty::TypeVariants::*;\n \n-use rustc_const_eval::{ConstInt, ConstIsize, ConstUsize};\n+use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n \n use std::cmp;\n use std::hash::{Hash, SipHasher, Hasher};\n@@ -269,41 +267,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         (a, b)\n     }\n \n-    /// Returns the repeat count for a repeating vector expression.\n-    pub fn eval_repeat_count(&self, count_expr: &hir::Expr) -> usize {\n-        let hint = UncheckedExprHint(self.types.usize);\n-        match const_eval::eval_const_expr_partial(self, count_expr, hint, None) {\n-            Ok(ConstVal::Integral(ConstInt::Usize(count))) => {\n-                let val = count.as_u64(self.sess.target.uint_type);\n-                assert_eq!(val as usize as u64, val);\n-                val as usize\n-            },\n-            Ok(const_val) => {\n-                span_err!(self.sess, count_expr.span, E0306,\n-                          \"expected positive integer for repeat count, found {}\",\n-                          const_val.description());\n-                0\n-            }\n-            Err(err) => {\n-                let err_msg = match count_expr.node {\n-                    hir::ExprPath(None, hir::Path {\n-                        global: false,\n-                        ref segments,\n-                        ..\n-                    }) if segments.len() == 1 =>\n-                        format!(\"found variable\"),\n-                    _ => match err.kind {\n-                        ErrKind::MiscCatchAll => format!(\"but found {}\", err.description()),\n-                        _ => format!(\"but {}\", err.description())\n-                    }\n-                };\n-                span_err!(self.sess, count_expr.span, E0307,\n-                    \"expected constant integer for repeat count, {}\", err_msg);\n-                0\n-            }\n-        }\n-    }\n-\n     /// Given a set of predicates that apply to an object type, returns\n     /// the region bounds that the (erased) `Self` type must\n     /// outlive. Precisely *because* the `Self` type is erased, the"}, {"sha": "f38c60cd1fae31bc7876991b18f6db9b70333cc9", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -11,4 +11,9 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = { path = \"../liblog\" }\n serialize = { path = \"../libserialize\" }\n+rustc = { path = \"../librustc\" }\n+rustc_front = { path = \"../librustc_front\" }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_const_math = { path = \"../librustc_const_math\" }\n syntax = { path = \"../libsyntax\" }\n+graphviz = { path = \"../libgraphviz\" }"}, {"sha": "f00df1f671f8c50292487120de530c723d5ae296", "filename": "src/librustc_const_eval/check_match.rs", "status": "renamed", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,22 +12,22 @@ pub use self::Constructor::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n-use dep_graph::DepNode;\n-use middle::const_eval::{compare_const_vals, ConstVal};\n-use middle::const_eval::{eval_const_expr, eval_const_expr_partial};\n-use middle::const_eval::{const_expr_to_pat, lookup_const_by_id};\n-use middle::const_eval::EvalHint::ExprTypeChecked;\n-use middle::def::*;\n-use middle::def_id::{DefId};\n-use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n-use middle::expr_use_visitor::{LoanCause, MutateMode};\n-use middle::expr_use_visitor as euv;\n-use infer;\n-use middle::mem_categorization::{cmt};\n-use middle::pat_util::*;\n-use traits::ProjectionMode;\n-use ty::*;\n-use ty;\n+use rustc::dep_graph::DepNode;\n+use rustc::middle::const_val::ConstVal;\n+use ::{eval_const_expr, eval_const_expr_partial, compare_const_vals};\n+use ::{const_expr_to_pat, lookup_const_by_id};\n+use ::EvalHint::ExprTypeChecked;\n+use rustc::middle::def::*;\n+use rustc::middle::def_id::{DefId};\n+use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n+use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n+use rustc::middle::expr_use_visitor as euv;\n+use rustc::infer;\n+use rustc::middle::mem_categorization::{cmt};\n+use rustc::middle::pat_util::*;\n+use rustc::traits::ProjectionMode;\n+use rustc::ty::*;\n+use rustc::ty;\n use std::cmp::Ordering;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator, repeat};\n@@ -44,7 +44,7 @@ use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use rustc_front::fold::{Folder, noop_fold_pat};\n use rustc_front::print::pprust::pat_to_string;\n use syntax::ptr::P;\n-use util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n@@ -546,7 +546,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n         ty::TyTuple(_) => PatKind::Tup(pats.collect()),\n \n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n-            let v = adt.variant_of_ctor(ctor);\n+            let v = ctor.variant_for_adt(adt);\n             match v.kind() {\n                 VariantKind::Struct => {\n                     let field_pats: hir::HirVec<_> = v.fields.iter()\n@@ -617,13 +617,13 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     })\n }\n \n-impl<'tcx, 'container> ty::AdtDefData<'tcx, 'container> {\n-    fn variant_of_ctor(&self,\n-                       ctor: &Constructor)\n-                       -> &VariantDefData<'tcx, 'container> {\n-        match ctor {\n-            &Variant(vid) => self.variant_with_id(vid),\n-            _ => self.struct_variant()\n+impl Constructor {\n+    fn variant_for_adt<'tcx, 'container, 'a>(&self,\n+                                             adt: &'a ty::AdtDefData<'tcx, 'container>)\n+                                             -> &'a VariantDefData<'tcx, 'container> {\n+        match self {\n+            &Variant(vid) => adt.variant_with_id(vid),\n+            _ => adt.struct_variant()\n         }\n     }\n }\n@@ -843,7 +843,7 @@ pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> us\n             _ => 1\n         },\n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _) => {\n-            adt.variant_of_ctor(ctor).fields.len()\n+            ctor.variant_for_adt(adt).fields.len()\n         }\n         ty::TyArray(_, n) => n,\n         _ => 0\n@@ -924,7 +924,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         PatKind::Struct(_, ref pattern_fields, _) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n-            let variant = adt.variant_of_ctor(constructor);\n+            let variant = constructor.variant_for_adt(adt);\n             let def_variant = adt.variant_of_def(def);\n             if variant.did == def_variant.did {\n                 Some(variant.fields.iter().map(|sf| {", "previous_filename": "src/librustc/middle/check_match.rs"}, {"sha": "4f5176f6b0be536d0eb1145dcd6b785e33e3df76", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "added", "additions": 545, "deletions": 0, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -0,0 +1,545 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+// Error messages for EXXXX errors.\n+// Each message should start and end with a new line, and be wrapped to 80 characters.\n+// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n+register_long_diagnostics! {\n+\n+E0001: r##\"\n+This error suggests that the expression arm corresponding to the noted pattern\n+will never be reached as for all possible values of the expression being\n+matched, one of the preceding patterns will match.\n+\n+This means that perhaps some of the preceding patterns are too general, this\n+one is too specific or the ordering is incorrect.\n+\n+For example, the following `match` block has too many arms:\n+\n+```compile_fail\n+match foo {\n+    Some(bar) => {/* ... */}\n+    None => {/* ... */}\n+    _ => {/* ... */} // All possible cases have already been handled\n+}\n+```\n+\n+`match` blocks have their patterns matched in order, so, for example, putting\n+a wildcard arm above a more specific arm will make the latter arm irrelevant.\n+\n+Ensure the ordering of the match arm is correct and remove any superfluous\n+arms.\n+\"##,\n+\n+E0002: r##\"\n+This error indicates that an empty match expression is invalid because the type\n+it is matching on is non-empty (there exist values of this type). In safe code\n+it is impossible to create an instance of an empty type, so empty match\n+expressions are almost never desired. This error is typically fixed by adding\n+one or more cases to the match expression.\n+\n+An example of an empty type is `enum Empty { }`. So, the following will work:\n+\n+```\n+enum Empty {}\n+\n+fn foo(x: Empty) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n+\n+However, this won't:\n+\n+```compile_fail\n+enum Empty {}\n+\n+fn foo(x: Option<String>) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n+\"##,\n+\n+\n+E0003: r##\"\n+Not-a-Number (NaN) values cannot be compared for equality and hence can never\n+match the input to a match expression. So, the following will not compile:\n+\n+```compile_fail\n+const NAN: f32 = 0.0 / 0.0;\n+\n+let number = 0.1f32;\n+\n+match number {\n+    NAN => { /* ... */ },\n+    _ => {}\n+}\n+```\n+\n+To match against NaN values, you should instead use the `is_nan()` method in a\n+guard, like so:\n+\n+```\n+let number = 0.1f32;\n+\n+match number {\n+    x if x.is_nan() => { /* ... */ }\n+    _ => {}\n+}\n+```\n+\"##,\n+\n+\n+E0004: r##\"\n+This error indicates that the compiler cannot guarantee a matching pattern for\n+one or more possible inputs to a match expression. Guaranteed matches are\n+required in order to assign values to match expressions, or alternatively,\n+determine the flow of execution. Erroneous code example:\n+\n+```compile_fail\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n+    Terminator::TalkToMyHand => {}\n+}\n+```\n+\n+If you encounter this error you must alter your patterns so that every possible\n+value of the input type is matched. For types with a small number of variants\n+(like enums) you should probably cover all cases explicitly. Alternatively, the\n+underscore `_` wildcard pattern can be added after all other patterns to match\n+\"anything else\". Example:\n+\n+```\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    Terminator::HastaLaVistaBaby => {}\n+}\n+\n+// or:\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    _ => {}\n+}\n+```\n+\"##,\n+\n+E0005: r##\"\n+Patterns used to bind names must be irrefutable, that is, they must guarantee\n+that a name will be extracted in all cases. Erroneous code example:\n+\n+```compile_fail\n+let x = Some(1);\n+let Some(y) = x;\n+// error: refutable pattern in local binding: `None` not covered\n+```\n+\n+If you encounter this error you probably need to use a `match` or `if let` to\n+deal with the possibility of failure. Example:\n+\n+```compile_fail\n+let x = Some(1);\n+\n+match x {\n+    Some(y) => {\n+        // do something\n+    },\n+    None => {}\n+}\n+\n+// or:\n+\n+if let Some(y) = x {\n+    // do something\n+}\n+```\n+\"##,\n+\n+E0007: r##\"\n+This error indicates that the bindings in a match arm would require a value to\n+be moved into more than one location, thus violating unique ownership. Code\n+like the following is invalid as it requires the entire `Option<String>` to be\n+moved into a variable called `op_string` while simultaneously requiring the\n+inner `String` to be moved into a variable called `s`.\n+\n+```compile_fail\n+let x = Some(\"s\".to_string());\n+\n+match x {\n+    op_string @ Some(s) => {},\n+    None => {},\n+}\n+```\n+\n+See also the error E0303.\n+\"##,\n+\n+E0008: r##\"\n+Names bound in match arms retain their type in pattern guards. As such, if a\n+name is bound by move in a pattern, it should also be moved to wherever it is\n+referenced in the pattern guard code. Doing so however would prevent the name\n+from being available in the body of the match arm. Consider the following:\n+\n+```compile_fail\n+match Some(\"hi\".to_string()) {\n+    Some(s) if s.len() == 0 => {}, // use s.\n+    _ => {},\n+}\n+```\n+\n+The variable `s` has type `String`, and its use in the guard is as a variable of\n+type `String`. The guard code effectively executes in a separate scope to the\n+body of the arm, so the value would be moved into this anonymous scope and\n+therefore become unavailable in the body of the arm. Although this example seems\n+innocuous, the problem is most clear when considering functions that take their\n+argument by value.\n+\n+```compile_fail\n+match Some(\"hi\".to_string()) {\n+    Some(s) if { drop(s); false } => (),\n+    Some(s) => {}, // use s.\n+    _ => {},\n+}\n+```\n+\n+The value would be dropped in the guard then become unavailable not only in the\n+body of that arm but also in all subsequent arms! The solution is to bind by\n+reference when using guards or refactor the entire expression, perhaps by\n+putting the condition inside the body of the arm.\n+\"##,\n+\n+E0009: r##\"\n+In a pattern, all values that don't implement the `Copy` trait have to be bound\n+the same way. The goal here is to avoid binding simultaneously by-move and\n+by-ref.\n+\n+This limitation may be removed in a future version of Rust.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {},\n+    None => panic!()\n+}\n+```\n+\n+You have two solutions:\n+\n+Solution #1: Bind the pattern's values the same way.\n+\n+```\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((ref y, ref z)) => {},\n+    // or Some((y, z)) => {}\n+    None => panic!()\n+}\n+```\n+\n+Solution #2: Implement the `Copy` trait for the `X` structure.\n+\n+However, please keep in mind that the first solution should be preferred.\n+\n+```\n+#[derive(Clone, Copy)]\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {},\n+    None => panic!()\n+}\n+```\n+\"##,\n+\n+E0158: r##\"\n+`const` and `static` mean different things. A `const` is a compile-time\n+constant, an alias for a literal value. This property means you can match it\n+directly within a pattern.\n+\n+The `static` keyword, on the other hand, guarantees a fixed location in memory.\n+This does not always mean that the value is constant. For example, a global\n+mutex can be declared `static` as well.\n+\n+If you want to match against a `static`, consider using a guard instead:\n+\n+```\n+static FORTY_TWO: i32 = 42;\n+\n+match Some(42) {\n+    Some(x) if x == FORTY_TWO => {}\n+    _ => {}\n+}\n+```\n+\"##,\n+\n+E0162: r##\"\n+An if-let pattern attempts to match the pattern, and enters the body if the\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding instead. For instance:\n+\n+```compile_fail\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+// This fails to compile because the match is irrefutable.\n+if let Irrefutable(x) = irr {\n+    // This body will always be executed.\n+    foo(x);\n+}\n+```\n+\n+Try this instead:\n+\n+```ignore\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+let Irrefutable(x) = irr;\n+foo(x);\n+```\n+\"##,\n+\n+E0165: r##\"\n+A while-let pattern attempts to match the pattern, and enters the body if the\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding inside a `loop` instead. For instance:\n+\n+```compile_fail\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+// This fails to compile because the match is irrefutable.\n+while let Irrefutable(x) = irr {\n+    ...\n+}\n+\n+Try this instead:\n+\n+```\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+loop {\n+    let Irrefutable(x) = irr;\n+    ...\n+}\n+```\n+\"##,\n+\n+E0170: r##\"\n+Enum variants are qualified by default. For example, given this type:\n+\n+```\n+enum Method {\n+    GET,\n+    POST,\n+}\n+```\n+\n+You would match it using:\n+\n+```\n+enum Method {\n+    GET,\n+    POST,\n+}\n+\n+let m = Method::GET;\n+\n+match m {\n+    Method::GET => {},\n+    Method::POST => {},\n+}\n+```\n+\n+If you don't qualify the names, the code will bind new variables named \"GET\" and\n+\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n+that happens.\n+\n+Qualified names are good practice, and most code works well with them. But if\n+you prefer them unqualified, you can import the variants into scope:\n+\n+```ignore\n+use Method::*;\n+enum Method { GET, POST }\n+```\n+\n+If you want others to be able to import variants from your module directly, use\n+`pub use`:\n+\n+```ignore\n+pub use Method::*;\n+enum Method { GET, POST }\n+```\n+\"##,\n+\n+\n+E0297: r##\"\n+Patterns used to bind names must be irrefutable. That is, they must guarantee\n+that a name will be extracted in all cases. Instead of pattern matching the\n+loop variable, consider using a `match` or `if let` inside the loop body. For\n+instance:\n+\n+```compile_fail\n+let xs : Vec<Option<i32>> = vec!(Some(1), None);\n+\n+// This fails because `None` is not covered.\n+for Some(x) in xs {\n+    // ...\n+}\n+```\n+\n+Match inside the loop instead:\n+\n+```\n+let xs : Vec<Option<i32>> = vec!(Some(1), None);\n+\n+for item in xs {\n+    match item {\n+        Some(x) => {},\n+        None => {},\n+    }\n+}\n+```\n+\n+Or use `if let`:\n+\n+```\n+let xs : Vec<Option<i32>> = vec!(Some(1), None);\n+\n+for item in xs {\n+    if let Some(x) = item {\n+        // ...\n+    }\n+}\n+```\n+\"##,\n+\n+E0301: r##\"\n+Mutable borrows are not allowed in pattern guards, because matching cannot have\n+side effects. Side effects could alter the matched object or the environment\n+on which the match depends in such a way, that the match would not be\n+exhaustive. For instance, the following would not match any arm if mutable\n+borrows were allowed:\n+\n+```compile_fail\n+match Some(()) {\n+    None => { },\n+    option if option.take().is_none() => {\n+        /* impossible, option is `Some` */\n+    },\n+    Some(_) => { } // When the previous match failed, the option became `None`.\n+}\n+```\n+\"##,\n+\n+E0302: r##\"\n+Assignments are not allowed in pattern guards, because matching cannot have\n+side effects. Side effects could alter the matched object or the environment\n+on which the match depends in such a way, that the match would not be\n+exhaustive. For instance, the following would not match any arm if assignments\n+were allowed:\n+\n+```compile_fail\n+match Some(()) {\n+    None => { },\n+    option if { option = None; false } { },\n+    Some(_) => { } // When the previous match failed, the option became `None`.\n+}\n+```\n+\"##,\n+\n+E0303: r##\"\n+In certain cases it is possible for sub-bindings to violate memory safety.\n+Updates to the borrow checker in a future version of Rust may remove this\n+restriction, but for now patterns must be rewritten without sub-bindings.\n+\n+```ignore\n+// Before.\n+match Some(\"hi\".to_string()) {\n+    ref op_string_ref @ Some(s) => {},\n+    None => {},\n+}\n+\n+// After.\n+match Some(\"hi\".to_string()) {\n+    Some(ref s) => {\n+        let op_string_ref = &Some(s);\n+        // ...\n+    },\n+    None => {},\n+}\n+```\n+\n+The `op_string_ref` binding has type `&Option<&String>` in both cases.\n+\n+See also https://github.com/rust-lang/rust/issues/14587\n+\"##,\n+\n+E0306: r##\"\n+In an array literal `[x; N]`, `N` is the number of elements in the array. This\n+must be an unsigned integer. Erroneous code example:\n+\n+```compile_fail\n+let x = [0i32; true]; // error: expected positive integer for repeat count,\n+                      //        found boolean\n+```\n+\n+Working example:\n+\n+```\n+let x = [0i32; 2];\n+```\n+\"##,\n+\n+E0307: r##\"\n+The length of an array is part of its type. For this reason, this length must\n+be a compile-time constant. Erroneous code example:\n+\n+```compile_fail\n+    let len = 10;\n+    let x = [0i32; len]; // error: expected constant integer for repeat count,\n+                         //        found variable\n+```\n+\"##,\n+\n+}\n+\n+\n+register_diagnostics! {\n+E0298, // mismatched types between arms\n+E0299, // mismatched types between arms\n+E0471, // constant evaluation error: ..\n+}"}, {"sha": "a36d0b3fcff22646bdf860ff33ac5708bfca89cc", "filename": "src/librustc_const_eval/eval.rs", "status": "renamed", "additions": 53, "deletions": 104, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,43 +10,40 @@\n \n //#![allow(non_camel_case_types)]\n \n-use self::ConstVal::*;\n+use rustc::middle::const_val::ConstVal::*;\n+use rustc::middle::const_val::ConstVal;\n use self::ErrKind::*;\n use self::EvalHint::*;\n \n-use front::map as ast_map;\n-use front::map::blocks::FnLikeNode;\n-use lint;\n-use middle::cstore::{self, CrateStore, InlinedItem};\n-use {infer, traits};\n-use middle::def::Def;\n-use middle::def_id::DefId;\n-use middle::pat_util::def_to_path;\n-use ty::{self, subst, Ty, TyCtxt};\n-use ty::util::IntTypeExt;\n-use traits::ProjectionMode;\n-use middle::astconv_util::ast_ty_to_prim_ty;\n-use util::nodemap::NodeMap;\n+use rustc::front::map as ast_map;\n+use rustc::front::map::blocks::FnLikeNode;\n+use rustc::middle::cstore::{self, CrateStore, InlinedItem};\n+use rustc::{infer, traits};\n+use rustc::middle::def::Def;\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::pat_util::def_to_path;\n+use rustc::ty::{self, Ty, TyCtxt, subst};\n+use rustc::ty::util::IntTypeExt;\n+use rustc::traits::ProjectionMode;\n+use rustc::middle::astconv_util::ast_ty_to_prim_ty;\n+use rustc::util::nodemap::NodeMap;\n+use rustc::lint;\n \n use graphviz::IntoCow;\n use syntax::ast;\n use rustc_front::hir::{Expr, PatKind};\n use rustc_front::hir;\n use rustc_front::intravisit::FnKind;\n use syntax::codemap::Span;\n-use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::codemap;\n use syntax::attr::IntType;\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n-use std::hash;\n-use std::mem::transmute;\n-use std::rc::Rc;\n \n-use rustc_const_eval::*;\n+use rustc_const_math::*;\n \n macro_rules! math {\n     ($e:expr, $op:expr) => {\n@@ -241,89 +238,6 @@ pub fn lookup_const_fn_by_id<'tcx>(tcx: &TyCtxt<'tcx>, def_id: DefId)\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub enum ConstVal {\n-    Float(f64),\n-    Integral(ConstInt),\n-    Str(InternedString),\n-    ByteStr(Rc<Vec<u8>>),\n-    Bool(bool),\n-    Struct(ast::NodeId),\n-    Tuple(ast::NodeId),\n-    Function(DefId),\n-    Array(ast::NodeId, u64),\n-    Repeat(ast::NodeId, u64),\n-    Char(char),\n-    /// A value that only occurs in case `eval_const_expr` reported an error. You should never\n-    /// handle this case. Its sole purpose is to allow more errors to be reported instead of\n-    /// causing a fatal error.\n-    Dummy,\n-}\n-\n-impl hash::Hash for ConstVal {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        match *self {\n-            Float(a) => unsafe { transmute::<_,u64>(a) }.hash(state),\n-            Integral(a) => a.hash(state),\n-            Str(ref a) => a.hash(state),\n-            ByteStr(ref a) => a.hash(state),\n-            Bool(a) => a.hash(state),\n-            Struct(a) => a.hash(state),\n-            Tuple(a) => a.hash(state),\n-            Function(a) => a.hash(state),\n-            Array(a, n) => { a.hash(state); n.hash(state) },\n-            Repeat(a, n) => { a.hash(state); n.hash(state) },\n-            Char(c) => c.hash(state),\n-            Dummy => ().hash(state),\n-        }\n-    }\n-}\n-\n-/// Note that equality for `ConstVal` means that the it is the same\n-/// constant, not that the rust values are equal. In particular, `NaN\n-/// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n-/// are considering unequal).\n-impl PartialEq for ConstVal {\n-    fn eq(&self, other: &ConstVal) -> bool {\n-        match (self, other) {\n-            (&Float(a), &Float(b)) => unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)},\n-            (&Integral(a), &Integral(b)) => a == b,\n-            (&Str(ref a), &Str(ref b)) => a == b,\n-            (&ByteStr(ref a), &ByteStr(ref b)) => a == b,\n-            (&Bool(a), &Bool(b)) => a == b,\n-            (&Struct(a), &Struct(b)) => a == b,\n-            (&Tuple(a), &Tuple(b)) => a == b,\n-            (&Function(a), &Function(b)) => a == b,\n-            (&Array(a, an), &Array(b, bn)) => (a == b) && (an == bn),\n-            (&Repeat(a, an), &Repeat(b, bn)) => (a == b) && (an == bn),\n-            (&Char(a), &Char(b)) => a == b,\n-            (&Dummy, &Dummy) => true, // FIXME: should this be false?\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl Eq for ConstVal { }\n-\n-impl ConstVal {\n-    pub fn description(&self) -> &'static str {\n-        match *self {\n-            Float(_) => \"float\",\n-            Integral(i) => i.description(),\n-            Str(_) => \"string literal\",\n-            ByteStr(_) => \"byte string literal\",\n-            Bool(_) => \"boolean\",\n-            Struct(_) => \"struct\",\n-            Tuple(_) => \"tuple\",\n-            Function(_) => \"function definition\",\n-            Array(..) => \"array\",\n-            Repeat(..) => \"repeat\",\n-            Char(..) => \"char\",\n-            Dummy => \"dummy value\",\n-        }\n-    }\n-}\n-\n pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, span: Span)\n                          -> Result<P<hir::Pat>, DefId> {\n     let pat_ty = tcx.expr_ty(expr);\n@@ -352,7 +266,6 @@ pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, spa\n         }\n         _ => { }\n     }\n-\n     let pat = match expr.node {\n         hir::ExprTup(ref exprs) =>\n             PatKind::Tup(try!(exprs.iter()\n@@ -1275,3 +1188,39 @@ pub fn compare_lit_exprs<'tcx>(tcx: &TyCtxt<'tcx>,\n     };\n     compare_const_vals(&a, &b)\n }\n+\n+\n+/// Returns the repeat count for a repeating vector expression.\n+pub fn eval_repeat_count(tcx: &TyCtxt, count_expr: &hir::Expr) -> usize {\n+    let hint = UncheckedExprHint(tcx.types.usize);\n+    match eval_const_expr_partial(tcx, count_expr, hint, None) {\n+        Ok(Integral(Usize(count))) => {\n+            let val = count.as_u64(tcx.sess.target.uint_type);\n+            assert_eq!(val as usize as u64, val);\n+            val as usize\n+        },\n+        Ok(const_val) => {\n+            span_err!(tcx.sess, count_expr.span, E0306,\n+                      \"expected positive integer for repeat count, found {}\",\n+                      const_val.description());\n+            0\n+        }\n+        Err(err) => {\n+            let err_msg = match count_expr.node {\n+                hir::ExprPath(None, hir::Path {\n+                    global: false,\n+                    ref segments,\n+                    ..\n+                }) if segments.len() == 1 =>\n+                    format!(\"found variable\"),\n+                _ => match err.kind {\n+                    MiscCatchAll => format!(\"but found {}\", err.description()),\n+                    _ => format!(\"but {}\", err.description())\n+                }\n+            };\n+            span_err!(tcx.sess, count_expr.span, E0307,\n+                \"expected constant integer for repeat count, {}\", err_msg);\n+            0\n+        }\n+    }\n+}", "previous_filename": "src/librustc/middle/const_eval.rs"}, {"sha": "558ae71756b8b1133e04c3e1ee56ecdc53cba83d", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Rusty Mathematics\n+//! constant evaluation on the HIR and code to validate patterns/matches\n //!\n //! # Note\n //!\n@@ -25,19 +25,29 @@\n \n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(slice_patterns)]\n+#![feature(iter_arith)]\n #![feature(question_mark)]\n \n-#[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n+#[macro_use] extern crate log;\n+extern crate rustc;\n+extern crate rustc_front;\n+extern crate rustc_back;\n+extern crate rustc_const_math;\n+extern crate graphviz;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n-mod int;\n-mod us;\n-mod is;\n-mod err;\n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostics;\n+\n+mod eval;\n+pub mod check_match;\n+\n+pub use eval::*;\n \n-pub use int::*;\n-pub use us::*;\n-pub use is::*;\n-pub use err::ConstMathErr;\n+// Build the diagnostics array at the end so that the metadata includes error use sites.\n+__build_diagnostic_array! { librustc_const_eval, DIAGNOSTICS }"}, {"sha": "10aadabe22ed7d35c9a32c99757e0d01575a2208", "filename": "src/librustc_const_math/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2FCargo.toml?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_const_math\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_const_math\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+serialize = { path = \"../libserialize\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "126b3824efec6940c4cd6c0949765bcbdd822a65", "filename": "src/librustc_const_math/err.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ferr.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "previous_filename": "src/librustc_const_eval/err.rs"}, {"sha": "658d4d9a6d2fa3dc64730cd77b33ef79e0e7ccd6", "filename": "src/librustc_const_math/int.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -326,7 +326,7 @@ macro_rules! impl_binop {\n         impl ::std::ops::$op for ConstInt {\n             type Output = Result<Self, ConstMathErr>;\n             fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match try!(self.infer(rhs)) {\n+                match self.infer(rhs)? {\n                     (I8(a), I8(b)) => a.$checked_func(b).map(I8),\n                     (I16(a), I16(b)) => a.$checked_func(b).map(I16),\n                     (I32(a), I32(b)) => a.$checked_func(b).map(I32),\n@@ -353,7 +353,7 @@ macro_rules! derive_binop {\n         impl ::std::ops::$op for ConstInt {\n             type Output = Result<Self, ConstMathErr>;\n             fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match try!(self.infer(rhs)) {\n+                match self.infer(rhs)? {\n                     (I8(a), I8(b)) => Ok(I8(a.$func(b))),\n                     (I16(a), I16(b)) => Ok(I16(a.$func(b))),\n                     (I32(a), I32(b)) => Ok(I32(a.$func(b))),", "previous_filename": "src/librustc_const_eval/int.rs"}, {"sha": "082c6510f8bc961308387571b40c2e2c71ffc5ce", "filename": "src/librustc_const_math/is.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2Fis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2Fis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fis.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "previous_filename": "src/librustc_const_eval/is.rs"}, {"sha": "9f66aac6e3899e4b07c13d0bab40474e5153f01b", "filename": "src/librustc_const_math/lib.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Rusty Mathematics\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![crate_name = \"rustc_const_math\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+\n+\n+#![feature(rustc_private)]\n+#![feature(staged_api)]\n+#![feature(question_mark)]\n+\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n+\n+extern crate serialize as rustc_serialize; // used by deriving\n+\n+mod int;\n+mod us;\n+mod is;\n+mod err;\n+\n+pub use int::*;\n+pub use us::*;\n+pub use is::*;\n+pub use err::ConstMathErr;"}, {"sha": "e5a7086d43663c1ba93b889c5891ee0b8228bac1", "filename": "src/librustc_const_math/us.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2Fus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_const_math%2Fus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fus.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "previous_filename": "src/librustc_const_eval/us.rs"}, {"sha": "803b919058da672dc499e0e6bc3cf7c1536a7a2f", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -17,6 +17,7 @@ log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_borrowck = { path = \"../librustc_borrowck\" }\n+rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_front = { path = \"../librustc_front\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_llvm = { path = \"../librustc_llvm\" }"}, {"sha": "61f8c9bcc4f4d3bae45ec430e729747181e351f3", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -38,6 +38,7 @@ use rustc_plugin as plugin;\n use rustc_front::hir;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_passes::{no_asm, loops, consts, const_fn, rvalues, static_recursion};\n+use rustc_const_eval::check_match;\n use super::Compilation;\n \n use serialize::json;\n@@ -851,7 +852,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         time(time_passes,\n              \"match checking\",\n-             || middle::check_match::check_crate(tcx));\n+             || check_match::check_crate(tcx));\n \n         // this must run before MIR dump, because\n         // \"not all control paths return a value\" is reported here."}, {"sha": "516c55e1020ea34df1ccb72010d1a51450db1aff", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -40,6 +40,7 @@ extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_borrowck;\n+extern crate rustc_const_eval;\n extern crate rustc_passes;\n extern crate rustc_front;\n extern crate rustc_lint;\n@@ -1090,6 +1091,7 @@ pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_trans::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n \n     Registry::new(&all_errors)\n }"}, {"sha": "4821a72327978670905ad103031652eac2e905be", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -12,5 +12,6 @@ crate-type = [\"dylib\"]\n log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n+rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_front = { path = \"../librustc_front\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "6e3a961cacae7869f99b522f65c0b150430bdf3e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -46,6 +46,7 @@ extern crate rustc;\n extern crate log;\n extern crate rustc_front;\n extern crate rustc_back;\n+extern crate rustc_const_eval;\n \n pub use rustc::lint as lint;\n pub use rustc::middle as middle;"}, {"sha": "80733bccf8ec3887b54bf133d40f21bea4b760b8", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -14,8 +14,9 @@ use middle::def_id::DefId;\n use rustc::infer;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use middle::const_eval::{eval_const_expr_partial, ConstVal};\n-use middle::const_eval::EvalHint::ExprTypeChecked;\n+use middle::const_val::ConstVal;\n+use rustc_const_eval::eval_const_expr_partial;\n+use rustc_const_eval::EvalHint::ExprTypeChecked;\n use util::nodemap::{FnvHashSet};\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};"}, {"sha": "65c2c2d1480a84de0819a55bc33de3ff98d0e372", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -15,7 +15,7 @@ rbml = { path = \"../librbml\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_front = { path = \"../librustc_front\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "b9ebd3c3afabfc9775ba51a55fccd9122d7773a9", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -36,7 +36,7 @@ use rustc::ty::subst;\n use rustc::ty::{ImplContainer, TraitContainer};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, VariantKind};\n \n-use rustc_const_eval::ConstInt;\n+use rustc_const_math::ConstInt;\n \n use rustc::mir;\n use rustc::mir::visit::MutVisitor;"}, {"sha": "674106dd82ad8c6365b1717f41cef96c8ddc21f7", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -37,7 +37,7 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_front;\n extern crate rustc_llvm;\n-extern crate rustc_const_eval;\n+extern crate rustc_const_math;\n \n pub use rustc::middle;\n "}, {"sha": "f136618b1c9e2eb1f0511274f790ae20a992475e", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -14,6 +14,7 @@ log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_front = { path = \"../librustc_front\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "685631970146f5e042293c5b5a18ddf3c0b4fce4", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -15,7 +15,7 @@\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use rustc_data_structures::fnv::FnvHashMap;\n-use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::const_val::ConstVal;\n use rustc::ty::{AdtDef, Ty};\n use rustc::mir::repr::*;\n use hair::*;"}, {"sha": "dc70cf4ffb93a602e8faf2dd3a07d46305743006", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -19,7 +19,7 @@ use build::Builder;\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n use rustc_data_structures::fnv::FnvHashMap;\n-use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use syntax::codemap::Span;"}, {"sha": "e3093eab22bc02748c32e5c880640d907ee5a1ad", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -94,8 +94,8 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::mir::repr::*;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token::intern_and_get_ident;\n-use rustc::middle::const_eval::ConstVal;\n-use rustc_const_eval::ConstInt;\n+use rustc::middle::const_val::ConstVal;\n+use rustc_const_math::ConstInt;\n \n pub struct Scope<'tcx> {\n     /// the scope-id within the scope_datas"}, {"sha": "451cdea35a7f6775b20d9e742af7af0c095bdd45", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -10,13 +10,14 @@\n \n use hair::*;\n use rustc_data_structures::fnv::FnvHashMap;\n-use rustc_const_eval::ConstInt;\n+use rustc_const_math::ConstInt;\n use hair::cx::Cx;\n use hair::cx::block;\n use hair::cx::to_ref::ToRef;\n use rustc::front::map;\n use rustc::middle::def::Def;\n-use rustc::middle::const_eval::{self, ConstVal};\n+use rustc::middle::const_val::ConstVal;\n+use rustc_const_eval as const_eval;\n use rustc::middle::region::CodeExtent;\n use rustc::middle::pat_util;\n use rustc::ty::{self, VariantDef, Ty};"}, {"sha": "e4a8363051b78b938a4a1ac0eb05eb501ea4f2c7", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -18,15 +18,16 @@\n use hair::*;\n use rustc::mir::repr::*;\n \n-use rustc::middle::const_eval::{self, ConstVal};\n+use rustc::middle::const_val::ConstVal;\n+use rustc_const_eval as const_eval;\n use rustc::middle::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use syntax::codemap::Span;\n use syntax::parse::token;\n use rustc_front::hir;\n-use rustc_const_eval::{ConstInt, ConstUsize};\n+use rustc_const_math::{ConstInt, ConstUsize};\n \n #[derive(Copy, Clone)]\n pub struct Cx<'a, 'tcx: 'a> {"}, {"sha": "c6132a71eefd567694c32ff5d25aae15c64f2549", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -11,7 +11,7 @@\n use hair::*;\n use hair::cx::Cx;\n use rustc_data_structures::fnv::FnvHashMap;\n-use rustc::middle::const_eval;\n+use rustc_const_eval as const_eval;\n use rustc::middle::def::Def;\n use rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n use rustc::ty::{self, Ty};"}, {"sha": "affc187298715e4fd1272c212256a9ca9dbb3e32", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -16,7 +16,7 @@\n \n use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp,\n     TypedConstVal};\n-use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::const_val::ConstVal;\n use rustc::middle::def_id::DefId;\n use rustc::middle::region::CodeExtent;\n use rustc::ty::subst::Substs;"}, {"sha": "e024fa94fb7728be24940e7db5c42bc1b32619c0", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -32,6 +32,7 @@ extern crate rustc_data_structures;\n extern crate rustc_front;\n extern crate rustc_back;\n extern crate syntax;\n+extern crate rustc_const_math;\n extern crate rustc_const_eval;\n \n pub mod build;"}, {"sha": "00b8f5c093043485c7ae3a217d531fa4a11d2541", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::const_val::ConstVal;\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, Pass};"}, {"sha": "02303aa7130ea4f090749fcb16062e20d9525323", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -11,5 +11,6 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n+rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_front = { path = \"../librustc_front\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "a33b8caee2e12d91eafecfe309a7cea021c8c0fb", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -26,9 +26,10 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::ty::cast::{CastKind};\n-use rustc::middle::const_eval::{self, ConstEvalErr};\n-use rustc::middle::const_eval::ErrKind::IndexOpFeatureGated;\n-use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, compare_lit_exprs};\n+use rustc_const_eval::{eval_const_expr_partial, lookup_const_by_id};\n+use rustc_const_eval::ErrKind::IndexOpFeatureGated;\n+use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc::middle::def::Def;\n use rustc::middle::def_id::DefId;\n use rustc::middle::expr_use_visitor as euv;\n@@ -169,7 +170,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                             def_id: DefId,\n                             ret_ty: Ty<'tcx>)\n                             -> bool {\n-        if let Some(fn_like) = const_eval::lookup_const_fn_by_id(self.tcx, def_id) {\n+        if let Some(fn_like) = lookup_const_fn_by_id(self.tcx, def_id) {\n             if\n                 // we are in a static/const initializer\n                 self.mode != Mode::Var &&\n@@ -335,7 +336,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 self.global_expr(Mode::Const, &start);\n                 self.global_expr(Mode::Const, &end);\n \n-                match const_eval::compare_lit_exprs(self.tcx, start, end) {\n+                match compare_lit_exprs(self.tcx, start, end) {\n                     Some(Ordering::Less) |\n                     Some(Ordering::Equal) => {}\n                     Some(Ordering::Greater) => {\n@@ -431,7 +432,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 match node_ty.sty {\n                     ty::TyUint(_) | ty::TyInt(_) if div_or_rem => {\n                         if !self.qualif.intersects(ConstQualif::NOT_CONST) {\n-                            match const_eval::eval_const_expr_partial(\n+                            match eval_const_expr_partial(\n                                     self.tcx, ex, ExprTypeChecked, None) {\n                                 Ok(_) => {}\n                                 Err(ConstEvalErr { kind: IndexOpFeatureGated, ..}) => {},\n@@ -611,7 +612,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 Some(Def::Const(did)) |\n                 Some(Def::AssociatedConst(did)) => {\n                     let substs = Some(v.tcx.node_id_item_substs(e.id).substs);\n-                    if let Some((expr, _)) = const_eval::lookup_const_by_id(v.tcx, did, substs) {\n+                    if let Some((expr, _)) = lookup_const_by_id(v.tcx, did, substs) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n                     }"}, {"sha": "6d217040316c9b10bffa829399c01d158da5149d", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -30,6 +30,7 @@\n extern crate core;\n extern crate rustc;\n extern crate rustc_front;\n+extern crate rustc_const_eval;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "b798afe25edb78667a8a94058438f32333ed3689", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -17,6 +17,7 @@ log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_front = { path = \"../librustc_front\" }\n rustc_llvm = { path = \"../librustc_llvm\" }"}, {"sha": "f545ba2cbe056ee33ab0b3fa74b2bda49df3d9b2", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -189,9 +189,8 @@ use self::Opt::*;\n use self::FailureHandler::*;\n \n use llvm::{ValueRef, BasicBlockRef};\n-use middle::check_match::StaticInliner;\n-use middle::check_match;\n-use middle::const_eval;\n+use rustc_const_eval::check_match::{self, StaticInliner};\n+use rustc_const_eval::{compare_lit_exprs, eval_const_expr};\n use middle::def::{Def, DefMap};\n use middle::def_id::DefId;\n use middle::expr_use_visitor as euv;\n@@ -241,7 +240,7 @@ struct ConstantExpr<'a>(&'a hir::Expr);\n \n impl<'a> ConstantExpr<'a> {\n     fn eq(self, other: ConstantExpr<'a>, tcx: &TyCtxt) -> bool {\n-        match const_eval::compare_lit_exprs(tcx, self.0, other.0) {\n+        match compare_lit_exprs(tcx, self.0, other.0) {\n             Some(result) => result == Ordering::Equal,\n             None => panic!(\"compare_list_exprs: type mismatch\"),\n         }\n@@ -611,11 +610,11 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n \n     let ctor = match opt {\n         &ConstantValue(ConstantExpr(expr), _) => check_match::ConstantValue(\n-            const_eval::eval_const_expr(bcx.tcx(), &expr)\n+            eval_const_expr(bcx.tcx(), &expr)\n         ),\n         &ConstantRange(ConstantExpr(lo), ConstantExpr(hi), _) => check_match::ConstantRange(\n-            const_eval::eval_const_expr(bcx.tcx(), &lo),\n-            const_eval::eval_const_expr(bcx.tcx(), &hi)\n+            eval_const_expr(bcx.tcx(), &lo),\n+            eval_const_expr(bcx.tcx(), &hi)\n         ),\n         &SliceLengthEqual(n, _) =>\n             check_match::Slice(n),"}, {"sha": "555c12807baf2d96a941bc36cdea81e77babfe91", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -13,7 +13,8 @@ use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::const_qualif::ConstQualif;\n-use middle::const_eval::{self, ConstEvalErr};\n+use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, lookup_const_by_id, ErrKind};\n+use rustc_const_eval::eval_repeat_count;\n use middle::def::Def;\n use middle::def_id::DefId;\n use rustc::front::map as hir_map;\n@@ -38,7 +39,7 @@ use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::cast::{CastTy,IntTy};\n use util::nodemap::NodeMap;\n-use rustc_const_eval::{ConstInt, ConstMathErr, ConstUsize, ConstIsize};\n+use rustc_const_math::{ConstInt, ConstMathErr, ConstUsize, ConstIsize};\n \n use rustc_front::hir;\n \n@@ -197,7 +198,7 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            arg_vals: &[ValueRef],\n                            param_substs: &'tcx Substs<'tcx>,\n                            trueconst: TrueConst) -> Result<ValueRef, ConstEvalFailure> {\n-    let fn_like = const_eval::lookup_const_fn_by_id(ccx.tcx(), def_id);\n+    let fn_like = lookup_const_fn_by_id(ccx.tcx(), def_id);\n     let fn_like = fn_like.expect(\"lookup_const_fn_by_id failed in const_fn_call\");\n \n     let body = match fn_like.body().expr {\n@@ -228,7 +229,7 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let substs = monomorphize::apply_param_substs(ccx.tcx(),\n                                                   param_substs,\n                                                   &substs.erase_regions());\n-    match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(substs)) {\n+    match lookup_const_by_id(ccx.tcx(), def_id, Some(substs)) {\n         Some((ref expr, _ty)) => expr,\n         None => {\n             ccx.sess().span_bug(ref_expr.span, \"constant item not found\")\n@@ -534,12 +535,12 @@ fn const_err(cx: &CrateContext,\n             Ok(())\n         },\n         (Err(err), TrueConst::Yes) => {\n-            let err = ConstEvalErr{ span: e.span, kind: const_eval::ErrKind::Math(err) };\n+            let err = ConstEvalErr{ span: e.span, kind: ErrKind::Math(err) };\n             cx.tcx().sess.span_err(e.span, &err.description());\n             Err(Compiletime(err))\n         },\n         (Err(err), TrueConst::No) => {\n-            let err = ConstEvalErr{ span: e.span, kind: const_eval::ErrKind::Math(err) };\n+            let err = ConstEvalErr{ span: e.span, kind: ErrKind::Math(err) };\n             cx.tcx().sess.span_warn(e.span, &err.description());\n             Err(Runtime(err))\n         },\n@@ -883,7 +884,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprRepeat(ref elem, ref count) => {\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = cx.tcx().eval_repeat_count(count);\n+            let n = eval_repeat_count(cx.tcx(), count);\n             let unit_val = const_expr(cx, &elem, param_substs, fn_args, trueconst)?.0;\n             let vs = vec![unit_val; n];\n             if val_ty(unit_val) != llunitty {"}, {"sha": "e9687935538879251fbdd534e4219c7fce8f3270", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -51,6 +51,7 @@ pub extern crate rustc_llvm as llvm;\n extern crate rustc_mir;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate serialize;\n+extern crate rustc_const_math;\n extern crate rustc_const_eval;\n \n #[macro_use] extern crate log;"}, {"sha": "2e154c40875f1ef4b701def255563d054b6baeb5", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -10,8 +10,9 @@\n \n use llvm::ValueRef;\n use rustc::ty::{Ty, TypeFoldable};\n-use rustc::middle::const_eval::{self, ConstVal};\n-use rustc_const_eval::ConstInt::*;\n+use rustc::middle::const_val::ConstVal;\n+use rustc_const_math::ConstInt::*;\n+use rustc_const_eval::lookup_const_by_id;\n use rustc::mir::repr as mir;\n use abi;\n use common::{self, BlockAndBuilder, C_bool, C_bytes, C_floating_f64, C_integral,\n@@ -114,7 +115,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n \n                 let substs = Some(bcx.monomorphize(substs));\n-                let expr = const_eval::lookup_const_by_id(bcx.tcx(), def_id, substs)\n+                let expr = lookup_const_by_id(bcx.tcx(), def_id, substs)\n                             .expect(\"def was const, but lookup_const_by_id failed\").0;\n                 // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n                 // because we would have somehow adapt const_eval to work on MIR rather than HIR."}, {"sha": "1396883120b8620fc4c9da6113e5b2e873ab8b60", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -11,8 +11,8 @@\n use llvm::ValueRef;\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n-use middle::const_eval::ConstVal;\n-use rustc_const_eval::ConstInt;\n+use middle::const_val::ConstVal;\n+use rustc_const_math::ConstInt;\n use rustc::mir::repr as mir;\n \n use asm;"}, {"sha": "56ba1b024260959909c5457c14e0878a334174f8", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -30,6 +30,7 @@ use value::Value;\n use rustc::ty::{self, Ty};\n \n use rustc_front::hir;\n+use rustc_const_eval::eval_repeat_count;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -218,7 +219,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     return expr::trans_into(bcx, &element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    match bcx.tcx().eval_repeat_count(&count_expr) {\n+                    match eval_repeat_count(bcx.tcx(), &count_expr) {\n                         0 => expr::trans_into(bcx, &element, Ignore),\n                         1 => expr::trans_into(bcx, &element, SaveIn(lldest)),\n                         count => {\n@@ -270,7 +271,7 @@ fn elements_required(bcx: Block, content_expr: &hir::Expr) -> usize {\n         },\n         hir::ExprVec(ref es) => es.len(),\n         hir::ExprRepeat(_, ref count_expr) => {\n-            bcx.tcx().eval_repeat_count(&count_expr)\n+            eval_repeat_count(bcx.tcx(), &count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n                                      \"unexpected vec content\")"}, {"sha": "6f46686feb5c874ab0a5909529aab70e5c33d84b", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -16,5 +16,6 @@ fmt_macros = { path = \"../libfmt_macros\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_front = { path = \"../librustc_front\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }"}, {"sha": "b7d00716f02230b69c5a7bebc15f2aec1016f107", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -49,8 +49,9 @@\n //! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n use middle::astconv_util::{prim_ty_to_ty, prohibit_type_params, prohibit_projection};\n-use middle::const_eval::{self, ConstVal};\n-use middle::const_eval::EvalHint::UncheckedExprHint;\n+use middle::const_val::ConstVal;\n+use rustc_const_eval::eval_const_expr_partial;\n+use rustc_const_eval::EvalHint::UncheckedExprHint;\n use middle::def::{self, Def};\n use middle::def_id::DefId;\n use middle::resolve_lifetime as rl;\n@@ -65,7 +66,7 @@ use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::FnvHashSet;\n \n-use rustc_const_eval::ConstInt;\n+use rustc_const_math::ConstInt;\n \n use syntax::{abi, ast};\n use syntax::codemap::{Span, Pos};\n@@ -1681,7 +1682,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         hir::TyFixedLengthVec(ref ty, ref e) => {\n             let hint = UncheckedExprHint(tcx.types.usize);\n-            match const_eval::eval_const_expr_partial(tcx, &e, hint, None) {\n+            match eval_const_expr_partial(tcx, &e, hint, None) {\n                 Ok(ConstVal::Integral(ConstInt::Usize(i))) => {\n                     let i = i.as_u64(tcx.sess.target.uint_type);\n                     assert_eq!(i as usize as u64, i);"}, {"sha": "d90ba03abd40e7d9cc6632efd3eca9a6647cab44", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -130,6 +130,7 @@ use rustc_front::hir;\n use rustc_front::hir::{Visibility, PatKind};\n use rustc_front::print::pprust;\n use rustc_back::slice;\n+use rustc_const_eval::eval_repeat_count;\n \n mod assoc;\n pub mod dropck;\n@@ -3592,7 +3593,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       hir::ExprRepeat(ref element, ref count_expr) => {\n         check_expr_has_type(fcx, &count_expr, tcx.types.usize);\n-        let count = fcx.tcx().eval_repeat_count(&count_expr);\n+        let count = eval_repeat_count(fcx.tcx(), &count_expr);\n \n         let uty = match expected {\n             ExpectHasType(uty) => {"}, {"sha": "a9ef0fce88091210111fd92f0f09bd0005e90d2a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -66,8 +66,9 @@ use constrained_type_params as ctp;\n use coherence;\n use middle::lang_items::SizedTraitLangItem;\n use middle::resolve_lifetime;\n-use middle::const_eval::{self, ConstVal};\n-use middle::const_eval::EvalHint::UncheckedExprHint;\n+use middle::const_val::ConstVal;\n+use rustc_const_eval::EvalHint::UncheckedExprHint;\n+use rustc_const_eval::eval_const_expr_partial;\n use rustc::ty::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n@@ -81,7 +82,7 @@ use util::common::{ErrorReported, MemoizationMap};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use write_ty_to_tcx;\n \n-use rustc_const_eval::ConstInt;\n+use rustc_const_math::ConstInt;\n \n use std::cell::RefCell;\n use std::collections::HashSet;\n@@ -1045,7 +1046,7 @@ fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n \n         let ty_hint = repr_ty.to_ty(tcx);\n         let hint = UncheckedExprHint(ty_hint);\n-        match const_eval::eval_const_expr_partial(tcx, e, hint, None) {\n+        match eval_const_expr_partial(tcx, e, hint, None) {\n             Ok(ConstVal::Integral(i)) => {\n                 // FIXME: eval_const_expr_partial should return an error if the hint is wrong\n                 match (repr_ty, i) {"}, {"sha": "c3ba91823434a750bb0d294f0261a9d076b56bfd", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -92,6 +92,7 @@ extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_front;\n extern crate rustc_back;\n+extern crate rustc_const_math;\n extern crate rustc_const_eval;\n \n pub use rustc::dep_graph;"}, {"sha": "3950131129ca75b3e19a4116a80d762c840b2a05", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -14,6 +14,7 @@ arena = { path = \"../libarena\" }\n getopts = { path = \"../libgetopts\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n+rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_driver = { path = \"../librustc_driver\" }\n rustc_front = { path = \"../librustc_front\" }\n rustc_lint = { path = \"../librustc_lint\" }"}, {"sha": "3e4ba47ce4cd2aa55da7907c8c0a5e0f1c982f5b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -22,7 +22,8 @@ use rustc::middle::def_id::DefId;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::subst;\n use rustc::middle::stability;\n-use rustc::middle::const_eval;\n+\n+use rustc_const_eval::lookup_const_by_id;\n \n use core::DocContext;\n use doctree;\n@@ -336,7 +337,7 @@ pub fn build_impl(cx: &DocContext,\n                 let did = assoc_const.def_id;\n                 let type_scheme = tcx.lookup_item_type(did);\n                 let default = if assoc_const.has_value {\n-                    Some(const_eval::lookup_const_by_id(tcx, did, None)\n+                    Some(lookup_const_by_id(tcx, did, None)\n                          .unwrap().0.span.to_src(cx))\n                 } else {\n                     None\n@@ -483,10 +484,9 @@ fn build_module(cx: &DocContext, tcx: &TyCtxt,\n \n fn build_const(cx: &DocContext, tcx: &TyCtxt,\n                did: DefId) -> clean::Constant {\n-    use rustc::middle::const_eval;\n     use rustc_front::print::pprust;\n \n-    let (expr, ty) = const_eval::lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n+    let (expr, ty) = lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n     debug!(\"converting constant expr {:?} to snippet\", expr);"}, {"sha": "a35fe20b6b6f4225db14736f87c51369ff653a28", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -35,6 +35,7 @@ extern crate arena;\n extern crate getopts;\n extern crate libc;\n extern crate rustc;\n+extern crate rustc_const_eval;\n extern crate rustc_trans;\n extern crate rustc_driver;\n extern crate rustc_resolve;"}, {"sha": "fc1ef4d41a8553b6afa1d19e5f7d46109c6e2ffa", "filename": "src/test/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9957081e78643aafab55f35c96d7c08936521dea/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9957081e78643aafab55f35c96d7c08936521dea/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs?ref=9957081e78643aafab55f35c96d7c08936521dea", "patch": "@@ -16,15 +16,15 @@\n #[macro_use] extern crate rustc;\n extern crate rustc_front;\n extern crate rustc_plugin;\n-extern crate rustc_const_eval;\n+extern crate rustc_const_math;\n extern crate syntax;\n \n use rustc::mir::transform::{self, MirPass};\n use rustc::mir::repr::{Mir, Literal};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty;\n-use rustc::middle::const_eval::ConstVal;\n-use rustc_const_eval::ConstInt;\n+use rustc::middle::const_val::ConstVal;\n+use rustc_const_math::ConstInt;\n use rustc_plugin::Registry;\n \n use syntax::ast::NodeId;"}]}