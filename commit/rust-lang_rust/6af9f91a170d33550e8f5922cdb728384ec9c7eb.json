{"sha": "6af9f91a170d33550e8f5922cdb728384ec9c7eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZjlmOTFhMTcwZDMzNTUwZThmNTkyMmNkYjcyODM4NGVjOWM3ZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-01T15:49:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-01T15:49:48Z"}, "message": "Auto merge of #51536 - davidtwco:nll-dyn-trait-underscore-error-improvements, r=nikomatsakis\n\nNLL: bad error message when converting anonymous lifetime to `'static`\n\nContributes to #46983. This PR doesn't introduce fantastic errors, but it should hopefully lay some groundwork for diagnostic improvements.\nr? @nikomatsakis", "tree": {"sha": "2b282dbc8d2eb1adca98d060848bf9cfc9d99a6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b282dbc8d2eb1adca98d060848bf9cfc9d99a6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6af9f91a170d33550e8f5922cdb728384ec9c7eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6af9f91a170d33550e8f5922cdb728384ec9c7eb", "html_url": "https://github.com/rust-lang/rust/commit/6af9f91a170d33550e8f5922cdb728384ec9c7eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6af9f91a170d33550e8f5922cdb728384ec9c7eb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef9a322843fa9f1d6eb6f05b3ba8f9f96ef1de46", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9a322843fa9f1d6eb6f05b3ba8f9f96ef1de46", "html_url": "https://github.com/rust-lang/rust/commit/ef9a322843fa9f1d6eb6f05b3ba8f9f96ef1de46"}, {"sha": "c0c4741ef794d707a4378ace1547e8a41961016a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c4741ef794d707a4378ace1547e8a41961016a", "html_url": "https://github.com/rust-lang/rust/commit/c0c4741ef794d707a4378ace1547e8a41961016a"}], "stats": {"total": 958, "additions": 559, "deletions": 399}, "files": [{"sha": "68aa9aeabf811ae75a2bcd3429edd8947f5ef4ec", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -10,9 +10,10 @@\n \n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n+use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n-use borrow_check::nll::ToRegionVid;\n+use borrow_check::nll::type_check::AtLocation;\n use rustc::hir;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n@@ -310,12 +311,10 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n                         ty::TyRef(ref_region, _, mutbl) => {\n-                            let span = self.mir.source_info(location).span;\n                             self.regioncx.add_outlives(\n-                                span,\n+                                location.boring(),\n                                 ref_region.to_region_vid(),\n                                 borrow_region.to_region_vid(),\n-                                location.successor_within_block(),\n                             );\n \n                             if let Some(all_facts) = self.all_facts {"}, {"sha": "3bdf78ff3db54dc323ee1c178d22689ae887d464", "filename": "src/librustc_mir/borrow_check/nll/constraint_set.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::mir::Location;\n use rustc::ty::RegionVid;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use borrow_check::nll::type_check::Locations;\n \n use std::fmt;\n-use syntax_pos::Span;\n use std::ops::Deref;\n \n #[derive(Clone, Default)]\n@@ -24,8 +23,8 @@ crate struct ConstraintSet {\n impl ConstraintSet {\n     pub fn push(&mut self, constraint: OutlivesConstraint) {\n         debug!(\n-            \"add_outlives({:?}: {:?} @ {:?}\",\n-            constraint.sup, constraint.sub, constraint.point\n+            \"add_outlives({:?}: {:?} @ {:?})\",\n+            constraint.sup, constraint.sub, constraint.locations\n         );\n         if constraint.sup == constraint.sub {\n             // 'a: 'a is pretty uninteresting\n@@ -86,9 +85,6 @@ pub struct OutlivesConstraint {\n     /// Region that must be outlived.\n     pub sub: RegionVid,\n \n-    /// At this location.\n-    pub point: Location,\n-\n     /// Later on, we thread the constraints onto a linked list\n     /// grouped by their `sub` field. So if you had:\n     ///\n@@ -100,15 +96,15 @@ pub struct OutlivesConstraint {\n     pub next: Option<ConstraintIndex>,\n \n     /// Where did this constraint arise?\n-    pub span: Span,\n+    pub locations: Locations,\n }\n \n impl fmt::Debug for OutlivesConstraint {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n         write!(\n             formatter,\n-            \"({:?}: {:?} @ {:?}) due to {:?}\",\n-            self.sup, self.sub, self.point, self.span\n+            \"({:?}: {:?}) due to {:?}\",\n+            self.sup, self.sub, self.locations\n         )\n     }\n }"}, {"sha": "88d9f46e340d33e204753915ecfbaec18790a45e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -82,16 +82,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let OutlivesConstraint {\n                 sup,\n                 sub,\n-                point,\n-                span,\n+                locations,\n                 next: _,\n             } = constraint;\n             with_msg(&format!(\n-                \"{:?}: {:?} @ {:?} due to {:?}\",\n+                \"{:?}: {:?} due to {:?}\",\n                 sup,\n                 sub,\n-                point,\n-                span\n+                locations,\n             ))?;\n         }\n "}, {"sha": "970652d8872cd71f4b4b220487fa1a90136f6249", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting.rs", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -0,0 +1,340 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+use borrow_check::nll::region_infer::{Cause, ConstraintIndex, RegionInferenceContext};\n+use borrow_check::nll::region_infer::values::ToElementIndex;\n+use borrow_check::nll::type_check::Locations;\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::InferCtxt;\n+use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n+use rustc::mir::{self, Location, Mir, Place, StatementKind, TerminatorKind, Rvalue};\n+use rustc::ty::RegionVid;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use syntax_pos::Span;\n+\n+/// Constraints that are considered interesting can be categorized to\n+/// determine why they are interesting. Order of variants indicates\n+/// sort order of the category, thereby influencing diagnostic output.\n+#[derive(Debug, Eq, PartialEq, PartialOrd, Ord)]\n+enum ConstraintCategory {\n+    Cast,\n+    Assignment,\n+    Return,\n+    CallArgument,\n+    Other,\n+    Boring,\n+}\n+\n+impl fmt::Display for ConstraintCategory {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            ConstraintCategory::Assignment => write!(f, \"assignment\"),\n+            ConstraintCategory::Return => write!(f, \"return\"),\n+            ConstraintCategory::Cast => write!(f, \"cast\"),\n+            ConstraintCategory::CallArgument => write!(f, \"argument\"),\n+            _ => write!(f, \"free region\"),\n+        }\n+    }\n+}\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// When reporting an error, it is useful to be able to determine which constraints influenced\n+    /// the region being reported as an error. This function finds all of the paths from the\n+    /// constraint.\n+    fn find_constraint_paths_from_region(\n+        &self,\n+        r0: RegionVid\n+    ) -> Vec<Vec<ConstraintIndex>> {\n+        let constraints = self.constraints.clone();\n+\n+        // Mapping of regions to the previous region and constraint index that led to it.\n+        let mut previous = FxHashMap();\n+        // Regions yet to be visited.\n+        let mut next = vec! [ r0 ];\n+        // Regions that have been visited.\n+        let mut visited = FxHashSet();\n+        // Ends of paths.\n+        let mut end_regions = FxHashSet();\n+\n+        // When we've still got points to visit...\n+        while let Some(current) = next.pop() {\n+            // ...take the next point...\n+            debug!(\"find_constraint_paths_from_region: current={:?} visited={:?} next={:?}\",\n+                   current, visited, next);\n+            // ...but make sure not to visit this point again...\n+            visited.insert(current);\n+\n+            // ...find the edges containing it...\n+            let mut upcoming = Vec::new();\n+            for (index, constraint) in constraints.iter_enumerated() {\n+                if constraint.sub == current {\n+                    // ...add the regions that join us with to the path we've taken...\n+                    debug!(\"find_constraint_paths_from_region: index={:?} constraint={:?}\",\n+                           index, constraint);\n+                    let next_region = constraint.sup.clone();\n+\n+                    // ...unless we've visited it since this was added...\n+                    if visited.contains(&next_region) {\n+                        debug!(\"find_constraint_paths_from_region: skipping as visited\");\n+                        continue;\n+                    }\n+\n+                    previous.insert(next_region, (index, Some(current)));\n+                    upcoming.push(next_region);\n+                }\n+            }\n+\n+            if upcoming.is_empty() {\n+                // If we didn't find any edges then this is the end of a path...\n+                debug!(\"find_constraint_paths_from_region: new end region current={:?}\", current);\n+                end_regions.insert(current);\n+            } else {\n+                // ...but, if we did find edges, then add these to the regions yet to visit.\n+                debug!(\"find_constraint_paths_from_region: extend next upcoming={:?}\", upcoming);\n+                next.extend(upcoming);\n+            }\n+\n+        }\n+\n+        // Now we've visited each point, compute the final paths.\n+        let mut paths: Vec<Vec<ConstraintIndex>> = Vec::new();\n+        debug!(\"find_constraint_paths_from_region: end_regions={:?}\", end_regions);\n+        for end_region in end_regions {\n+            debug!(\"find_constraint_paths_from_region: end_region={:?}\", end_region);\n+\n+            // Get the constraint and region that led to this end point.\n+            // We can unwrap as we know if end_point was in the vector that it\n+            // must also be in our previous map.\n+            let (mut index, mut region) = previous.get(&end_region).unwrap();\n+            debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n+\n+            // Keep track of the indices.\n+            let mut path: Vec<ConstraintIndex> = vec![index];\n+\n+            while region.is_some() && region != Some(r0) {\n+                let p = previous.get(&region.unwrap()).unwrap();\n+                index = p.0;\n+                region = p.1;\n+\n+                debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n+                path.push(index);\n+            }\n+\n+            // Add to our paths.\n+            paths.push(path);\n+        }\n+\n+        debug!(\"find_constraint_paths_from_region: paths={:?}\", paths);\n+        paths\n+    }\n+\n+    /// This function will return true if a constraint is interesting and false if a constraint\n+    /// is not. It is useful in filtering constraint paths to only interesting points.\n+    fn constraint_is_interesting(&self, index: &ConstraintIndex) -> bool {\n+        self.constraints.get(*index).filter(|constraint| {\n+            debug!(\"constraint_is_interesting: locations={:?} constraint={:?}\",\n+                   constraint.locations, constraint);\n+            if let Locations::Interesting(_) = constraint.locations { true } else { false }\n+        }).is_some()\n+    }\n+\n+    /// This function classifies a constraint from a location.\n+    fn classify_constraint(&self, index: &ConstraintIndex,\n+                           mir: &Mir<'tcx>) -> Option<(ConstraintCategory, Span)> {\n+        let constraint = self.constraints.get(*index)?;\n+        let span = constraint.locations.span(mir);\n+        let location = constraint.locations.from_location()?;\n+\n+        if !self.constraint_is_interesting(index) {\n+            return Some((ConstraintCategory::Boring, span));\n+        }\n+\n+        let data = &mir[location.block];\n+        let category = if location.statement_index == data.statements.len() {\n+            if let Some(ref terminator) = data.terminator {\n+                match terminator.kind {\n+                    TerminatorKind::DropAndReplace { .. } => ConstraintCategory::Assignment,\n+                    TerminatorKind::Call { .. } => ConstraintCategory::CallArgument,\n+                    _ => ConstraintCategory::Other,\n+                }\n+            } else {\n+                ConstraintCategory::Other\n+            }\n+        } else {\n+            let statement = &data.statements[location.statement_index];\n+            match statement.kind {\n+                StatementKind::Assign(ref place, ref rvalue) => {\n+                    if *place == Place::Local(mir::RETURN_PLACE) {\n+                        ConstraintCategory::Return\n+                    } else {\n+                        match rvalue {\n+                            Rvalue::Cast(..) => ConstraintCategory::Cast,\n+                            Rvalue::Use(..) => ConstraintCategory::Assignment,\n+                            _ => ConstraintCategory::Other,\n+                        }\n+                    }\n+                },\n+                _ => ConstraintCategory::Other,\n+            }\n+        };\n+\n+        Some((category, span))\n+    }\n+\n+    /// Report an error because the universal region `fr` was required to outlive\n+    /// `outlived_fr` but it is not known to do so. For example:\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+    /// ```\n+    ///\n+    /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n+    pub(super) fn report_error(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir_def_id: DefId,\n+        fr: RegionVid,\n+        outlived_fr: RegionVid,\n+        blame_span: Span,\n+    ) {\n+        // Obviously uncool error reporting.\n+\n+        let fr_name = self.to_error_region(fr);\n+        let outlived_fr_name = self.to_error_region(outlived_fr);\n+\n+        if let (Some(f), Some(o)) = (fr_name, outlived_fr_name) {\n+            let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n+            let nice = NiceRegionError::new_from_span(infcx.tcx, blame_span, o, f, Some(tables));\n+            if let Some(_error_reported) = nice.try_report() {\n+                return;\n+            }\n+        }\n+\n+        let fr_string = match fr_name {\n+            Some(r) => format!(\"free region `{}`\", r),\n+            None => format!(\"free region `{:?}`\", fr),\n+        };\n+\n+        let outlived_fr_string = match outlived_fr_name {\n+            Some(r) => format!(\"free region `{}`\", r),\n+            None => format!(\"free region `{:?}`\", outlived_fr),\n+        };\n+\n+        let constraints = self.find_constraint_paths_from_region(fr.clone());\n+        let path = constraints.iter().min_by_key(|p| p.len()).unwrap();\n+        debug!(\"report_error: shortest_path={:?}\", path);\n+\n+        let mut categorized_path = path.iter().filter_map(|index| {\n+            self.classify_constraint(index, mir)\n+        }).collect::<Vec<(ConstraintCategory, Span)>>();\n+        debug!(\"report_error: categorized_path={:?}\", categorized_path);\n+\n+        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n+        debug!(\"report_error: sorted_path={:?}\", categorized_path);\n+\n+        if let Some((category, span)) = &categorized_path.first() {\n+            let mut diag = infcx.tcx.sess.struct_span_err(\n+                *span, &format!(\"{} requires that data must outlive {}\",\n+                                category, outlived_fr_string),\n+            );\n+\n+            diag.emit();\n+        } else {\n+            let mut diag = infcx.tcx.sess.struct_span_err(\n+                blame_span,\n+                &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n+            );\n+\n+            diag.emit();\n+        }\n+    }\n+\n+    crate fn why_region_contains_point(&self, fr1: RegionVid, elem: Location) -> Option<Cause> {\n+        // Find some constraint `X: Y` where:\n+        // - `fr1: X` transitively\n+        // - and `Y` is live at `elem`\n+        let index = self.blame_constraint(fr1, elem);\n+        let region_sub = self.constraints[index].sub;\n+\n+        // then return why `Y` was live at `elem`\n+        self.liveness_constraints.cause(region_sub, elem)\n+    }\n+\n+    /// Tries to finds a good span to blame for the fact that `fr1`\n+    /// contains `fr2`.\n+    pub(super) fn blame_constraint(&self, fr1: RegionVid,\n+                                   elem: impl ToElementIndex) -> ConstraintIndex {\n+        // Find everything that influenced final value of `fr`.\n+        let influenced_fr1 = self.dependencies(fr1);\n+\n+        // Try to find some outlives constraint `'X: fr2` where `'X`\n+        // influenced `fr1`. Blame that.\n+        //\n+        // NB, this is a pretty bad choice most of the time. In\n+        // particular, the connection between `'X` and `fr1` may not\n+        // be obvious to the user -- not to mention the naive notion\n+        // of dependencies, which doesn't account for the locations of\n+        // contraints at all. But it will do for now.\n+        let relevant_constraint = self.constraints\n+            .iter_enumerated()\n+            .filter_map(|(i, constraint)| {\n+                if !self.liveness_constraints.contains(constraint.sub, elem) {\n+                    None\n+                } else {\n+                    influenced_fr1[constraint.sup]\n+                        .map(|distance| (distance, i))\n+                }\n+            })\n+            .min() // constraining fr1 with fewer hops *ought* to be more obvious\n+            .map(|(_dist, i)| i);\n+\n+        relevant_constraint.unwrap_or_else(|| {\n+            bug!(\n+                \"could not find any constraint to blame for {:?}: {:?}\",\n+                fr1,\n+                elem,\n+            );\n+        })\n+    }\n+\n+    /// Finds all regions whose values `'a` may depend on in some way.\n+    /// For each region, returns either `None` (does not influence\n+    /// `'a`) or `Some(d)` which indicates that it influences `'a`\n+    /// with distinct `d` (minimum number of edges that must be\n+    /// traversed).\n+    ///\n+    /// Used during error reporting, extremely naive and inefficient.\n+    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, Option<usize>> {\n+        let mut result_set = IndexVec::from_elem(None, &self.definitions);\n+        let mut changed = true;\n+        result_set[r0] = Some(0); // distance 0 from `r0`\n+\n+        while changed {\n+            changed = false;\n+            for constraint in &*self.constraints {\n+                if let Some(n) = result_set[constraint.sup] {\n+                    let m = n + 1;\n+                    if result_set[constraint.sub]\n+                        .map(|distance| m < distance)\n+                        .unwrap_or(true)\n+                    {\n+                        result_set[constraint.sub] = Some(m);\n+                        changed = true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        result_set\n+    }\n+}"}, {"sha": "0116fbcfc8860d39e648cb4b7cf7e774985624be", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -44,7 +44,7 @@ impl<'this, 'tcx> dot::Labeller<'this> for RegionInferenceContext<'tcx> {\n         dot::LabelText::LabelStr(format!(\"{:?}\", n).into_cow())\n     }\n     fn edge_label(&'this self, e: &OutlivesConstraint) -> dot::LabelText<'this> {\n-        dot::LabelText::LabelStr(format!(\"{:?}\", e.point).into_cow())\n+        dot::LabelText::LabelStr(format!(\"{:?}\", e.locations).into_cow())\n     }\n }\n "}, {"sha": "09e425ff55508c7c7179badce5f2849499f86c22", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 33, "deletions": 159, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -9,28 +9,28 @@\n // except according to those terms.\n \n use super::universal_regions::UniversalRegions;\n-use borrow_check::nll::region_infer::values::ToElementIndex;\n use borrow_check::nll::constraint_set::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n-use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::region_constraints::{GenericKind, VarInfos};\n use rustc::infer::InferCtxt;\n use rustc::infer::NLLRegionVariableOrigin;\n use rustc::infer::RegionVariableOrigin;\n use rustc::mir::{\n     ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n-    Mir,\n+    Mir\n };\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n-use rustc::util::common::{self, ErrorReported};\n+use rustc::util::common;\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+\n use std::rc::Rc;\n-use syntax_pos::Span;\n \n mod annotation;\n mod dump_mir;\n+mod error_reporting;\n mod graphviz;\n mod values;\n use self::values::{RegionValueElements, RegionValues};\n@@ -154,11 +154,8 @@ pub struct TypeTest<'tcx> {\n     /// The region `'x` that the type must outlive.\n     pub lower_bound: RegionVid,\n \n-    /// The point where the outlives relation must hold.\n-    pub point: Location,\n-\n-    /// Where did this constraint arise?\n-    pub span: Span,\n+    /// Where did this constraint arise and why?\n+    pub locations: Locations,\n \n     /// A test which, if met by the region `'x`, proves that this type\n     /// constraint is satisfied.\n@@ -356,17 +353,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n     pub(super) fn add_outlives(\n         &mut self,\n-        span: Span,\n+        locations: Locations,\n         sup: RegionVid,\n         sub: RegionVid,\n-        point: Location,\n     ) {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n         self.constraints.push(OutlivesConstraint {\n-            span,\n+            locations,\n             sup,\n             sub,\n-            point,\n             next: None,\n         })\n     }\n@@ -410,7 +405,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         self.check_type_tests(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n \n-        self.check_universal_regions(infcx, mir_def_id, outlives_requirements.as_mut());\n+        self.check_universal_regions(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n \n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n@@ -503,12 +498,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n-            if self.eval_region_test(mir, type_test.point, type_test.lower_bound, &type_test.test) {\n+            if self.eval_region_test(mir, type_test.lower_bound, &type_test.test) {\n                 continue;\n             }\n \n             if let Some(propagated_outlives_requirements) = &mut propagated_outlives_requirements {\n-                if self.try_promote_type_test(infcx, type_test, propagated_outlives_requirements) {\n+                if self.try_promote_type_test(infcx, mir, type_test,\n+                                              propagated_outlives_requirements) {\n                     continue;\n                 }\n             }\n@@ -517,9 +513,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let lower_bound_region = self.to_error_region(type_test.lower_bound);\n             if let Some(lower_bound_region) = lower_bound_region {\n                 let region_scope_tree = &tcx.region_scope_tree(mir_def_id);\n+                let type_test_span = type_test.locations.span(mir);\n                 infcx.report_generic_bound_failure(\n                     region_scope_tree,\n-                    type_test.span,\n+                    type_test_span,\n                     None,\n                     type_test.generic_kind,\n                     lower_bound_region,\n@@ -534,8 +531,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // to report it; we could probably handle it by\n                 // iterating over the universal regions and reporting\n                 // an error that multiple bounds are required.\n+                let type_test_span = type_test.locations.span(mir);\n                 tcx.sess.span_err(\n-                    type_test.span,\n+                    type_test_span,\n                     &format!(\"`{}` does not live long enough\", type_test.generic_kind,),\n                 );\n             }\n@@ -568,6 +566,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn try_promote_type_test<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n         type_test: &TypeTest<'tcx>,\n         propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'gcx>>,\n     ) -> bool {\n@@ -576,8 +575,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let TypeTest {\n             generic_kind,\n             lower_bound,\n-            point: _,\n-            span,\n+            locations,\n             test: _,\n         } = type_test;\n \n@@ -601,7 +599,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n             subject,\n             outlived_free_region: lower_bound_plus,\n-            blame_span: *span,\n+            blame_span: locations.span(mir),\n         });\n         true\n     }\n@@ -765,31 +763,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn eval_region_test(\n         &self,\n         mir: &Mir<'tcx>,\n-        point: Location,\n         lower_bound: RegionVid,\n         test: &RegionTest,\n     ) -> bool {\n         debug!(\n-            \"eval_region_test(point={:?}, lower_bound={:?}, test={:?})\",\n-            point, lower_bound, test\n+            \"eval_region_test(lower_bound={:?}, test={:?})\",\n+            lower_bound, test\n         );\n \n         match test {\n             RegionTest::IsOutlivedByAllRegionsIn(regions) => regions\n                 .iter()\n-                .all(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n+                .all(|&r| self.eval_outlives(mir, r, lower_bound)),\n \n             RegionTest::IsOutlivedByAnyRegionIn(regions) => regions\n                 .iter()\n-                .any(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n+                .any(|&r| self.eval_outlives(mir, r, lower_bound)),\n \n             RegionTest::Any(tests) => tests\n                 .iter()\n-                .any(|test| self.eval_region_test(mir, point, lower_bound, test)),\n+                .any(|test| self.eval_region_test(mir, lower_bound, test)),\n \n             RegionTest::All(tests) => tests\n                 .iter()\n-                .all(|test| self.eval_region_test(mir, point, lower_bound, test)),\n+                .all(|test| self.eval_region_test(mir, lower_bound, test)),\n         }\n     }\n \n@@ -799,11 +796,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         _mir: &Mir<'tcx>,\n         sup_region: RegionVid,\n         sub_region: RegionVid,\n-        point: Location,\n     ) -> bool {\n         debug!(\n-            \"eval_outlives({:?}: {:?} @ {:?})\",\n-            sup_region, sub_region, point\n+            \"eval_outlives({:?}: {:?})\",\n+            sup_region, sub_region\n         );\n \n         let inferred_values = self\n@@ -869,6 +865,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_regions<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n@@ -885,6 +882,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for (fr, _) in universal_definitions {\n             self.check_universal_region(\n                 infcx,\n+                mir,\n                 mir_def_id,\n                 fr,\n                 &mut propagated_outlives_requirements,\n@@ -903,6 +901,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_region<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n@@ -925,7 +924,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             );\n \n             let blame_index = self.blame_constraint(longer_fr, shorter_fr);\n-            let blame_span = self.constraints[blame_index].span;\n+            let blame_span = self.constraints[blame_index].locations.span(mir);\n \n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do).\n@@ -960,134 +959,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Note: in this case, we use the unapproximated regions\n             // to report the error. This gives better error messages\n             // in some cases.\n-            self.report_error(infcx, mir_def_id, longer_fr, shorter_fr, blame_span);\n+            self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, blame_span);\n         }\n     }\n-\n-    /// Report an error because the universal region `fr` was required to outlive\n-    /// `outlived_fr` but it is not known to do so. For example:\n-    ///\n-    /// ```\n-    /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n-    /// ```\n-    ///\n-    /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n-    fn report_error(\n-        &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir_def_id: DefId,\n-        fr: RegionVid,\n-        outlived_fr: RegionVid,\n-        blame_span: Span,\n-    ) {\n-        // Obviously uncool error reporting.\n-\n-        let fr_name = self.to_error_region(fr);\n-        let outlived_fr_name = self.to_error_region(outlived_fr);\n-\n-        if let (Some(f), Some(o)) = (fr_name, outlived_fr_name) {\n-            let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n-            let nice = NiceRegionError::new_from_span(infcx.tcx, blame_span, o, f, Some(tables));\n-            if let Some(ErrorReported) = nice.try_report() {\n-                return;\n-            }\n-        }\n-\n-        let fr_string = match fr_name {\n-            Some(r) => format!(\"free region `{}`\", r),\n-            None => format!(\"free region `{:?}`\", fr),\n-        };\n-\n-        let outlived_fr_string = match outlived_fr_name {\n-            Some(r) => format!(\"free region `{}`\", r),\n-            None => format!(\"free region `{:?}`\", outlived_fr),\n-        };\n-\n-        let mut diag = infcx.tcx.sess.struct_span_err(\n-            blame_span,\n-            &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n-        );\n-\n-        diag.emit();\n-    }\n-\n-    crate fn why_region_contains_point(&self, fr1: RegionVid, elem: Location) -> Option<Cause> {\n-        // Find some constraint `X: Y` where:\n-        // - `fr1: X` transitively\n-        // - and `Y` is live at `elem`\n-        let index = self.blame_constraint(fr1, elem);\n-        let region_sub = self.constraints[index].sub;\n-\n-        // then return why `Y` was live at `elem`\n-        self.liveness_constraints.cause(region_sub, elem)\n-    }\n-\n-    /// Tries to finds a good span to blame for the fact that `fr1`\n-    /// contains `fr2`.\n-    fn blame_constraint(&self, fr1: RegionVid, elem: impl ToElementIndex) -> ConstraintIndex {\n-        // Find everything that influenced final value of `fr`.\n-        let influenced_fr1 = self.dependencies(fr1);\n-\n-        // Try to find some outlives constraint `'X: fr2` where `'X`\n-        // influenced `fr1`. Blame that.\n-        //\n-        // NB, this is a pretty bad choice most of the time. In\n-        // particular, the connection between `'X` and `fr1` may not\n-        // be obvious to the user -- not to mention the naive notion\n-        // of dependencies, which doesn't account for the locations of\n-        // contraints at all. But it will do for now.\n-        let relevant_constraint = self.constraints\n-            .iter_enumerated()\n-            .filter_map(|(i, constraint)| {\n-                if !self.liveness_constraints.contains(constraint.sub, elem) {\n-                    None\n-                } else {\n-                    influenced_fr1[constraint.sup]\n-                        .map(|distance| (distance, i))\n-                }\n-            })\n-            .min() // constraining fr1 with fewer hops *ought* to be more obvious\n-            .map(|(_dist, i)| i);\n-\n-        relevant_constraint.unwrap_or_else(|| {\n-            bug!(\n-                \"could not find any constraint to blame for {:?}: {:?}\",\n-                fr1,\n-                elem,\n-            );\n-        })\n-    }\n-\n-    /// Finds all regions whose values `'a` may depend on in some way.\n-    /// For each region, returns either `None` (does not influence\n-    /// `'a`) or `Some(d)` which indicates that it influences `'a`\n-    /// with distinct `d` (minimum number of edges that must be\n-    /// traversed).\n-    ///\n-    /// Used during error reporting, extremely naive and inefficient.\n-    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, Option<usize>> {\n-        let mut result_set = IndexVec::from_elem(None, &self.definitions);\n-        let mut changed = true;\n-        result_set[r0] = Some(0); // distance 0 from `r0`\n-\n-        while changed {\n-            changed = false;\n-            for constraint in self.constraints.iter() {\n-                if let Some(n) = result_set[constraint.sup] {\n-                    let m = n + 1;\n-                    if result_set[constraint.sub]\n-                        .map(|distance| m < distance)\n-                        .unwrap_or(true)\n-                    {\n-                        result_set[constraint.sub] = Some(m);\n-                        changed = true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        result_set\n-    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {"}, {"sha": "27bd50427772df4a465f5dadac14d7af27488c4b", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -19,14 +19,12 @@ use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc::infer::{self, SubregionOrigin};\n-use rustc::mir::{Location, Mir};\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, TyCtxt};\n-use syntax::codemap::Span;\n+use syntax_pos::DUMMY_SP;\n \n crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     location_table: &'a LocationTable,\n     region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n@@ -41,7 +39,6 @@ crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     crate fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        mir: &'a Mir<'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         location_table: &'a LocationTable,\n         region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n@@ -54,7 +51,6 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     ) -> Self {\n         Self {\n             tcx,\n-            mir,\n             universal_regions,\n             location_table,\n             region_bound_pairs,\n@@ -91,8 +87,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         // will start to fail.\n         let ty::OutlivesPredicate(k1, r2) =\n             query_constraint.no_late_bound_regions().unwrap_or_else(|| {\n-                span_bug!(\n-                    self.span(),\n+                bug!(\n                     \"query_constraint {:?} contained bound regions\",\n                     query_constraint,\n                 );\n@@ -125,7 +120,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n             UnpackedKind::Type(t1) => {\n                 // we don't actually use this for anything, but\n                 // the `TypeOutlives` code needs an origin.\n-                let origin = infer::RelateParamBound(self.span(), t1);\n+                let origin = infer::RelateParamBound(DUMMY_SP, t1);\n \n                 TypeOutlives::new(\n                     &mut *self,\n@@ -146,15 +141,12 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     ) -> TypeTest<'tcx> {\n         let lower_bound = self.to_region_vid(region);\n \n-        let point = self.locations.at_location().unwrap_or(Location::START);\n-\n         let test = self.verify_bound_to_region_test(&bound);\n \n         TypeTest {\n             generic_kind,\n             lower_bound,\n-            point,\n-            span: self.span(),\n+            locations: self.locations,\n             test,\n         }\n     }\n@@ -189,21 +181,11 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         self.universal_regions.to_region_vid(r)\n     }\n \n-    fn span(&self) -> Span {\n-        self.mir\n-            .source_info(self.locations.from_location().unwrap_or(Location::START))\n-            .span\n-    }\n-\n     fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n-        let span = self.span();\n-        let point = self.locations.at_location().unwrap_or(Location::START);\n-\n         self.outlives_constraints.push(OutlivesConstraint {\n-            span,\n+            locations: self.locations,\n             sub,\n             sup,\n-            point,\n             next: None,\n         });\n     }"}, {"sha": "d84dcc5678279a918a545e914832c2c989e59454", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -199,7 +199,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         });\n \n         if let Some(data) = &drop_data.region_constraint_data {\n-            self.cx.push_region_constraints(location.at_self(), data);\n+            self.cx.push_region_constraints(location.boring(), data);\n         }\n \n         drop_data.dropck_result.report_overflows("}, {"sha": "e3d20d9a8dbcbe812a44b0fb3326bc3e41bccdc2", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 99, "deletions": 122, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -147,7 +147,6 @@ fn type_check_internal<'gcx, 'tcx>(\n         region_bound_pairs,\n         implicit_region_bound,\n         borrowck_context,\n-        mir,\n     );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, mir);\n@@ -288,7 +287,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         tcx.predicates_of(def_id).instantiate(tcx, substs);\n                     type_checker.normalize_and_prove_instantiated_predicates(\n                         instantiated_predicates,\n-                        location,\n+                        location.boring(),\n                     );\n                 }\n \n@@ -313,10 +312,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n         debug!(\"sanitize_constant: expected_ty={:?}\", expected_ty);\n \n-        if let Err(terr) = self\n-            .cx\n-            .eq_types(expected_ty, constant.ty, location.at_self())\n-        {\n+        if let Err(terr) = self.cx.eq_types(expected_ty, constant.ty, location.boring()) {\n             span_mirbug!(\n                 self,\n                 constant,\n@@ -346,7 +342,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(ty, location);\n-                if let Err(terr) = self.cx.eq_types(ty, sty, location.at_self()) {\n+                if let Err(terr) = self.cx.eq_types(ty, sty, location.boring()) {\n                     span_mirbug!(\n                         self,\n                         place,\n@@ -390,7 +386,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             // (e.g., #29149). Note that we decide to use Copy before knowing whether the bounds\n             // fully apply: in effect, the rule is that if a value of some type could implement\n             // Copy, then it must.\n-            self.cx.prove_trait_ref(trait_ref, location);\n+            self.cx.prove_trait_ref(trait_ref, location.interesting());\n         }\n         place_ty\n     }\n@@ -489,7 +485,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ProjectionElem::Field(field, fty) => {\n                 let fty = self.sanitize_type(place, fty);\n                 match self.field_ty(place, base, field, location) {\n-                    Ok(ty) => if let Err(terr) = self.cx.eq_types(ty, fty, location.at_self()) {\n+                    Ok(ty) => if let Err(terr) = self.cx.eq_types(ty, fty, location.boring()) {\n                         span_mirbug!(\n                             self,\n                             place,\n@@ -600,7 +596,6 @@ struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     constraints: MirTypeckRegionConstraints<'tcx>,\n     borrowck_context: Option<BorrowCheckContext<'a, 'tcx>>,\n-    mir: &'a Mir<'tcx>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n@@ -631,7 +626,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n /// required to hold. Normally, this is at a particular point which\n /// created the obligation, but for constraints that the user gave, we\n /// want the constraint to hold at all points.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub enum Locations {\n     /// Indicates that a type constraint should always be true. This\n     /// is particularly important in the new borrowck analysis for\n@@ -666,32 +661,41 @@ pub enum Locations {\n     /// assigned to `x` are of `'static` lifetime.\n     All,\n \n-    Pair {\n-        /// The location in the MIR that generated these constraints.\n-        /// This is intended for error reporting and diagnosis; the\n-        /// constraints may *take effect* at a distinct spot.\n-        from_location: Location,\n-\n-        /// The constraints must be met at this location. In terms of the\n-        /// NLL RFC, when you have a constraint `R1: R2 @ P`, this field\n-        /// is the `P` value.\n-        at_location: Location,\n-    },\n+    /// A \"boring\" constraint (caused by the given location) is one that\n+    /// the user probably doesn't want to see described in diagnostics,\n+    /// because it is kind of an artifact of the type system setup.\n+    ///\n+    /// Example: `x = Foo { field: y }` technically creates\n+    /// intermediate regions representing the \"type of `Foo { field: y\n+    /// }`\", and data flows from `y` into those variables, but they\n+    /// are not very interesting. The assignment into `x` on the other\n+    /// hand might be.\n+    Boring(Location),\n+\n+    /// An *important* outlives constraint (caused by the given\n+    /// location) is one that would be useful to highlight in\n+    /// diagnostics, because it represents a point where references\n+    /// flow from one spot to another (e.g., `x = y`)\n+    Interesting(Location),\n }\n \n impl Locations {\n     pub fn from_location(&self) -> Option<Location> {\n         match self {\n             Locations::All => None,\n-            Locations::Pair { from_location, .. } => Some(*from_location),\n+            Locations::Boring(from_location) | Locations::Interesting(from_location) => {\n+                Some(*from_location)\n+            }\n         }\n     }\n \n-    pub fn at_location(&self) -> Option<Location> {\n-        match self {\n-            Locations::All => None,\n-            Locations::Pair { at_location, .. } => Some(*at_location),\n-        }\n+    /// Gets a span representing the location.\n+    pub fn span(&self, mir: &Mir<'_>) -> Span {\n+        let span_location = match self {\n+            Locations::All => Location::START,\n+            Locations::Boring(l) | Locations::Interesting(l) => *l,\n+        };\n+        mir.source_info(span_location).span\n     }\n }\n \n@@ -703,7 +707,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         borrowck_context: Option<BorrowCheckContext<'a, 'tcx>>,\n-        mir: &'a Mir<'tcx>,\n     ) -> Self {\n         TypeChecker {\n             infcx,\n@@ -713,7 +716,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             region_bound_pairs,\n             implicit_region_bound,\n             borrowck_context,\n-            mir,\n             reported_errors: FxHashSet(),\n             constraints: MirTypeckRegionConstraints::default(),\n         }\n@@ -756,7 +758,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         if let Some(borrowck_context) = &mut self.borrowck_context {\n             constraint_conversion::ConstraintConversion::new(\n                 self.infcx.tcx,\n-                self.mir,\n                 borrowck_context.universal_regions,\n                 borrowck_context.location_table,\n                 self.region_bound_pairs,\n@@ -797,11 +798,21 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n         match stmt.kind {\n             StatementKind::Assign(ref place, ref rv) => {\n+                // Assignments to temporaries are not \"interesting\";\n+                // they are not caused by the user, but rather artifacts\n+                // of lowering. Assignments to other sorts of places *are* interesting\n+                // though.\n+                let is_temp = if let Place::Local(l) = place {\n+                    !mir.local_decls[*l].is_user_variable.is_some()\n+                } else {\n+                    false\n+                };\n+\n+                let locations = if is_temp { location.boring() } else { location.interesting() };\n+\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) =\n-                    self.sub_types(rv_ty, place_ty, location.at_successor_within_block())\n-                {\n+                if let Err(terr) = self.sub_types(rv_ty, place_ty, locations) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -816,7 +827,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     def_id: tcx.lang_items().sized_trait().unwrap(),\n                     substs: tcx.mk_substs_trait(place_ty, &[]),\n                 };\n-                self.prove_trait_ref(trait_ref, location);\n+                self.prove_trait_ref(trait_ref, location.interesting());\n             }\n             StatementKind::SetDiscriminant {\n                 ref place,\n@@ -897,16 +908,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             TerminatorKind::DropAndReplace {\n                 ref location,\n                 ref value,\n-                target,\n-                unwind,\n+                target: _,\n+                unwind: _,\n             } => {\n                 let place_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n \n-                let locations = Locations::Pair {\n-                    from_location: term_location,\n-                    at_location: target.start_location(),\n-                };\n+                let locations = term_location.interesting();\n                 if let Err(terr) = self.sub_types(rv_ty, place_ty, locations) {\n                     span_mirbug!(\n                         self,\n@@ -917,34 +925,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         terr\n                     );\n                 }\n-\n-                // Subtle: this assignment occurs at the start of\n-                // *both* blocks, so we need to ensure that it holds\n-                // at both locations.\n-                if let Some(unwind) = unwind {\n-                    let locations = Locations::Pair {\n-                        from_location: term_location,\n-                        at_location: unwind.start_location(),\n-                    };\n-                    if let Err(terr) = self.sub_types(rv_ty, place_ty, locations) {\n-                        span_mirbug!(\n-                            self,\n-                            term,\n-                            \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n-                            place_ty,\n-                            rv_ty,\n-                            terr\n-                        );\n-                    }\n-                }\n             }\n             TerminatorKind::SwitchInt {\n                 ref discr,\n                 switch_ty,\n                 ..\n             } => {\n                 let discr_ty = discr.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(discr_ty, switch_ty, term_location.at_self()) {\n+                if let Err(terr) = self.sub_types(discr_ty, switch_ty, term_location.boring()) {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -984,7 +972,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 self.prove_predicates(\n                     sig.inputs().iter().map(|ty| ty::Predicate::WellFormed(ty)),\n-                    term_location,\n+                    term_location.boring(),\n                 );\n \n                 // The ordinary liveness rules will ensure that all\n@@ -1026,7 +1014,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 match mir.yield_ty {\n                     None => span_mirbug!(self, term, \"yield in non-generator\"),\n                     Some(ty) => {\n-                        if let Err(terr) = self.sub_types(value_ty, ty, term_location.at_self()) {\n+                        if let Err(terr) = self.sub_types(value_ty, ty, term_location.interesting())\n+                        {\n                             span_mirbug!(\n                                 self,\n                                 term,\n@@ -1052,12 +1041,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     ) {\n         let tcx = self.tcx();\n         match *destination {\n-            Some((ref dest, target_block)) => {\n+            Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                let locations = Locations::Pair {\n-                    from_location: term_location,\n-                    at_location: target_block.start_location(),\n-                };\n+                let locations = term_location.interesting();\n                 if let Err(terr) = self.sub_types(sig.output(), dest_ty, locations) {\n                     span_mirbug!(\n                         self,\n@@ -1092,7 +1078,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n-            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg, term_location.at_self()) {\n+            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg, term_location.interesting()) {\n                 span_mirbug!(\n                     self,\n                     term,\n@@ -1320,7 +1306,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     substs: tcx.mk_substs_trait(operand_ty, &[]),\n                 };\n \n-                self.prove_trait_ref(trait_ref, location);\n+                self.prove_trait_ref(trait_ref, location.interesting());\n             },\n \n             Rvalue::NullaryOp(_, ty) => {\n@@ -1329,7 +1315,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     substs: tcx.mk_substs_trait(ty, &[]),\n                 };\n \n-                self.prove_trait_ref(trait_ref, location);\n+                self.prove_trait_ref(trait_ref, location.interesting());\n             }\n \n             Rvalue::Cast(cast_kind, op, ty) => match cast_kind {\n@@ -1345,7 +1331,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                     let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n                         span_mirbug!(\n                             self,\n                             rvalue,\n@@ -1366,7 +1352,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     };\n                     let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n                         span_mirbug!(\n                             self,\n                             rvalue,\n@@ -1390,7 +1376,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                     let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n                         span_mirbug!(\n                             self,\n                             rvalue,\n@@ -1409,7 +1395,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         substs: tcx.mk_substs_trait(op.ty(mir, tcx), &[ty.into()]),\n                     };\n \n-                    self.prove_trait_ref(trait_ref, location);\n+                    self.prove_trait_ref(trait_ref, location.interesting());\n                 }\n \n                 CastKind::Misc => {}\n@@ -1458,7 +1444,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             };\n             let operand_ty = operand.ty(mir, tcx);\n-            if let Err(terr) = self.sub_types(operand_ty, field_ty, location.at_self()) {\n+\n+            if let Err(terr) = self.sub_types(operand_ty, field_ty, location.boring()) {\n                 span_mirbug!(\n                     self,\n                     rvalue,\n@@ -1519,8 +1506,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         *substs,\n                     );\n \n+                    // Hmm, are these constraints *really* boring?\n                     self.push_region_constraints(\n-                        location.at_self(),\n+                        location.boring(),\n                         &closure_constraints,\n                     );\n                 }\n@@ -1535,53 +1523,56 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             AggregateKind::Array(_) | AggregateKind::Tuple => ty::InstantiatedPredicates::empty(),\n         };\n \n-        self.normalize_and_prove_instantiated_predicates(instantiated_predicates, location);\n+        self.normalize_and_prove_instantiated_predicates(\n+            instantiated_predicates,\n+            location.boring(),\n+        );\n     }\n \n-    fn prove_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>, location: Location) {\n+    fn prove_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>, locations: Locations) {\n         self.prove_predicates(\n             Some(ty::Predicate::Trait(\n                 trait_ref.to_poly_trait_ref().to_poly_trait_predicate(),\n             )),\n-            location,\n+            locations,\n         );\n     }\n \n     fn normalize_and_prove_instantiated_predicates(\n         &mut self,\n         instantiated_predicates: ty::InstantiatedPredicates<'tcx>,\n-        location: Location,\n+        locations: Locations,\n     ) {\n         for predicate in instantiated_predicates.predicates {\n-            let predicate = self.normalize(predicate, location);\n-            self.prove_predicate(predicate, location);\n+            let predicate = self.normalize(predicate, locations);\n+            self.prove_predicate(predicate, locations);\n         }\n     }\n \n     fn prove_predicates(\n         &mut self,\n         predicates: impl IntoIterator<Item = ty::Predicate<'tcx>>,\n-        location: Location,\n+        locations: Locations,\n     ) {\n         for predicate in predicates {\n             debug!(\n-                \"prove_predicates(predicate={:?}, location={:?})\",\n-                predicate, location,\n+                \"prove_predicates(predicate={:?}, locations={:?})\",\n+                predicate, locations,\n             );\n \n-            self.prove_predicate(predicate, location);\n+            self.prove_predicate(predicate, locations);\n         }\n     }\n \n-    fn prove_predicate(&mut self, predicate: ty::Predicate<'tcx>, location: Location) {\n+    fn prove_predicate(&mut self, predicate: ty::Predicate<'tcx>, locations: Locations) {\n         debug!(\n             \"prove_predicate(predicate={:?}, location={:?})\",\n-            predicate, location,\n+            predicate, locations,\n         );\n \n         let param_env = self.param_env;\n         self.fully_perform_op(\n-            location.at_self(),\n+            locations,\n             param_env.and(type_op::prove_predicate::ProvePredicate::new(predicate)),\n         ).unwrap_or_else(|NoSolution| {\n             span_mirbug!(self, NoSolution, \"could not prove {:?}\", predicate);\n@@ -1614,7 +1605,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn normalize<T>(&mut self, value: T, location: impl ToLocations) -> T\n+    fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n     where\n         T: type_op::normalize::Normalizable<'gcx, 'tcx> + Copy,\n     {\n@@ -1667,52 +1658,38 @@ impl MirPass for TypeckMir {\n     }\n }\n \n-trait AtLocation {\n-    /// Creates a `Locations` where `self` is both the from-location\n-    /// and the at-location. This means that any required region\n-    /// relationships must hold upon entering the statement/terminator\n-    /// indicated by `self`. This is typically used when processing\n-    /// \"inputs\" to the given location.\n-    fn at_self(self) -> Locations;\n-\n-    /// Creates a `Locations` where `self` is the from-location and\n-    /// its successor within the block is the at-location. This means\n-    /// that any required region relationships must hold only upon\n-    /// **exiting** the statement/terminator indicated by `self`. This\n-    /// is for example used when you have a `place = rv` statement: it\n-    /// indicates that the `typeof(rv) <: typeof(place)` as of the\n-    /// **next** statement.\n-    fn at_successor_within_block(self) -> Locations;\n+pub trait AtLocation {\n+    /// Indicates a \"boring\" constraint that the user probably\n+    /// woudln't want to see highlights.\n+    fn boring(self) -> Locations;\n+\n+    /// Indicates an \"interesting\" edge, which is of significance only\n+    /// for diagnostics.\n+    fn interesting(self) -> Locations;\n }\n \n impl AtLocation for Location {\n-    fn at_self(self) -> Locations {\n-        Locations::Pair {\n-            from_location: self,\n-            at_location: self,\n-        }\n+    fn boring(self) -> Locations {\n+        Locations::Boring(self)\n     }\n \n-    fn at_successor_within_block(self) -> Locations {\n-        Locations::Pair {\n-            from_location: self,\n-            at_location: self.successor_within_block(),\n-        }\n+    fn interesting(self) -> Locations {\n+        Locations::Interesting(self)\n     }\n }\n \n-trait ToLocations: fmt::Debug + Copy {\n+trait NormalizeLocation: fmt::Debug + Copy {\n     fn to_locations(self) -> Locations;\n }\n \n-impl ToLocations for Locations {\n+impl NormalizeLocation for Locations {\n     fn to_locations(self) -> Locations {\n         self\n     }\n }\n \n-impl ToLocations for Location {\n+impl NormalizeLocation for Location {\n     fn to_locations(self) -> Locations {\n-        self.at_self()\n+        self.boring()\n     }\n }"}, {"sha": "5a71e75d4b2cd7e3d86f4af2adfa28896deb40b3", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -31,7 +31,7 @@ fn case1() {\n     foo(cell, |cell_a, cell_x| {\n         //~^ WARNING not reporting region error due to nll\n         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-        //~^ ERROR does not outlive free region\n+        //~^ ERROR argument requires that data must outlive free region\n     })\n }\n "}, {"sha": "656c1b46a3ce5341c55ecf0cd0dfd841d50ae0c5", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -4,11 +4,11 @@ warning: not reporting region error due to nll\n LL |     foo(cell, |cell_a, cell_x| {\n    |     ^^^\n \n-error: free region `ReFree(DefId(0/1:12 ~ propagate_approximated_shorter_to_static_comparing_against_free[317d]::case1[0]::{{closure}}[0]), BrAnon(1))` does not outlive free region `'_#1r`\n-  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:9\n+error: argument requires that data must outlive free region `'_#1r`\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:20\n    |\n LL |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-   |         ^^^^^^\n+   |                    ^^^^^^^^^^^^\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:31:15\n@@ -17,7 +17,7 @@ LL |       foo(cell, |cell_a, cell_x| {\n    |  _______________^\n LL | |         //~^ WARNING not reporting region error due to nll\n LL | |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-LL | |         //~^ ERROR does not outlive free region\n+LL | |         //~^ ERROR argument requires that data must outlive free region\n LL | |     })\n    | |_____^\n    |"}, {"sha": "b25b0e25df2111ccad22c867b8a1d3a5993ed49c", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -43,7 +43,7 @@ fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u3\n #[rustc_regions]\n fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-        //~^ ERROR does not outlive free region\n+        //~^ ERROR argument requires that data must outlive free region\n \n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll"}, {"sha": "40f215619c68904994ef8eff152bad23a7d577c0", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -9,7 +9,7 @@ note: External requirements\n    |\n LL |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n    |  _______________________________________________^\n-LL | |         //~^ ERROR does not outlive free region\n+LL | |         //~^ ERROR argument requires that data must outlive free region\n LL | |\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n@@ -23,24 +23,23 @@ LL | |     });\n    = note: number of external vids: 2\n    = note: where '_#1r: '_#0r\n \n-error: free region `ReFree(DefId(0/0:6 ~ propagate_approximated_shorter_to_static_no_bound[317d]::supply[0]), BrNamed(crate0:DefIndex(1:16), 'a))` does not outlive free region `ReStatic`\n-  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:47\n+error: argument requires that data must outlive free region `ReStatic`\n+  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:5\n    |\n-LL |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-   |  _______________________________________________^\n-LL | |         //~^ ERROR does not outlive free region\n+LL | /     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+LL | |         //~^ ERROR argument requires that data must outlive free region\n LL | |\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n LL | |     });\n-   | |_____^\n+   | |______^\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:44:1\n    |\n LL | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n LL | |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-LL | |         //~^ ERROR does not outlive free region\n+LL | |         //~^ ERROR argument requires that data must outlive free region\n LL | |\n ...  |\n LL | |     });"}, {"sha": "db9951bcc0f213f7b774646f5ccda247908a5311", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -46,7 +46,7 @@ fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u3\n #[rustc_regions]\n fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-        //~^ ERROR does not outlive free region\n+        //~^ ERROR argument requires that data must outlive free region\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n         //~^ WARNING not reporting region error due to nll"}, {"sha": "d89ff028a504293fd01a6d71fb98eff02cc8e48e", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -9,7 +9,7 @@ note: External requirements\n    |\n LL |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n    |  _______________________________________________^\n-LL | |         //~^ ERROR does not outlive free region\n+LL | |         //~^ ERROR argument requires that data must outlive free region\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n LL | |         //~^ WARNING not reporting region error due to nll\n@@ -23,24 +23,23 @@ LL | |     });\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#0r\n \n-error: free region `ReFree(DefId(0/0:6 ~ propagate_approximated_shorter_to_static_wrong_bound[317d]::supply[0]), BrNamed(crate0:DefIndex(1:16), 'a))` does not outlive free region `ReStatic`\n-  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:47\n+error: argument requires that data must outlive free region `ReStatic`\n+  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:5\n    |\n-LL |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-   |  _______________________________________________^\n-LL | |         //~^ ERROR does not outlive free region\n+LL | /     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+LL | |         //~^ ERROR argument requires that data must outlive free region\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     });\n-   | |_____^\n+   | |______^\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:47:1\n    |\n LL | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n LL | |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-LL | |         //~^ ERROR does not outlive free region\n+LL | |         //~^ ERROR argument requires that data must outlive free region\n LL | |         // Only works if 'x: 'y:\n ...  |\n LL | |     });"}, {"sha": "316268e7e726dffcc69eaf59e76320e3a857eeb5", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -46,7 +46,7 @@ fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n         //~^ WARN not reporting region error due to nll\n-        //~| ERROR does not outlive free region\n+        //~| ERROR argument requires that data must outlive free region\n     });\n }\n "}, {"sha": "74c0576e03b628f5055a3926f9b88a4057988ec4", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -4,11 +4,11 @@ warning: not reporting region error due to nll\n LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: free region `ReFree(DefId(0/1:18 ~ propagate_fail_to_approximate_longer_no_bounds[317d]::supply[0]::{{closure}}[0]), BrAnon(4))` does not outlive free region `ReFree(DefId(0/1:18 ~ propagate_fail_to_approximate_longer_no_bounds[317d]::supply[0]::{{closure}}[0]), BrAnon(2))`\n-  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:18\n+error: argument requires that data must outlive free region `ReFree(DefId(0/1:18 ~ propagate_fail_to_approximate_longer_no_bounds[317d]::supply[0]::{{closure}}[0]), BrAnon(2))`\n+  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:9\n    |\n LL |         demand_y(x, y, x.get())\n-   |                  ^\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:45:47\n@@ -18,7 +18,7 @@ LL |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n LL | |         //~^ WARN not reporting region error due to nll\n-LL | |         //~| ERROR does not outlive free region\n+LL | |         //~| ERROR argument requires that data must outlive free region\n LL | |     });\n    | |_____^\n    |"}, {"sha": "a41af168c3e4e5ef2d936290536a6cae0a95ef8c", "filename": "src/test/ui/nll/issue-50716.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fissue-50716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fissue-50716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-50716.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -22,7 +22,7 @@ where\n     for<'b> &'b T: A,\n     <&'static T as A>::X: Sized\n {\n-    let _x = *s; //~ ERROR free region `'a` does not outlive free region `'static`\n+    let _x = *s; //~ ERROR assignment requires that data must outlive free region `'static`\n }\n \n fn main() {}"}, {"sha": "de69f8cfbcb6e07878ae7927059e8e6bdd485464", "filename": "src/test/ui/nll/issue-50716.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -1,7 +1,7 @@\n-error: free region `'a` does not outlive free region `'static`\n+error: assignment requires that data must outlive free region `'static`\n   --> $DIR/issue-50716.rs:25:14\n    |\n-LL |     let _x = *s; //~ ERROR free region `'a` does not outlive free region `'static`\n+LL |     let _x = *s; //~ ERROR assignment requires that data must outlive free region `'static`\n    |              ^^\n \n error: aborting due to previous error"}, {"sha": "3832be6288aef3965da8af08fc9bcffcd7dc6f2c", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -55,7 +55,7 @@ where\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n-    //~| ERROR does not outlive free region\n+    //~| ERROR argument requires that data must outlive free region\n }\n \n #[rustc_regions]\n@@ -67,7 +67,7 @@ where\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n-    //~| ERROR does not outlive free region\n+    //~| ERROR argument requires that data must outlive free region\n }\n \n #[rustc_regions]\n@@ -89,7 +89,7 @@ where\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n-    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+    //~| ERROR argument requires that data must outlive free region\n }\n \n #[rustc_regions]"}, {"sha": "898c995e09b9d6b3269457d230672bdb0d1bf4dc", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -40,11 +40,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |\n    = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`...\n \n-error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`\n-  --> $DIR/projection-one-region-closure.rs:55:20\n+error: argument requires that data must outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`\n+  --> $DIR/projection-one-region-closure.rs:55:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                    ^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n note: No external requirements\n   --> $DIR/projection-one-region-closure.rs:51:1\n@@ -54,7 +54,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | | {\n ...  |\n-LL | |     //~| ERROR does not outlive free region\n+LL | |     //~| ERROR argument requires that data must outlive free region\n LL | | }\n    | |_^\n    |\n@@ -88,11 +88,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |\n    = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n \n-error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n-  --> $DIR/projection-one-region-closure.rs:67:20\n+error: argument requires that data must outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-closure.rs:67:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                    ^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n note: No external requirements\n   --> $DIR/projection-one-region-closure.rs:62:1\n@@ -102,7 +102,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | |     'a: 'a,\n ...  |\n-LL | |     //~| ERROR does not outlive free region\n+LL | |     //~| ERROR argument requires that data must outlive free region\n LL | | }\n    | |_^\n    |\n@@ -137,11 +137,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |\n    = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n \n-error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n-  --> $DIR/projection-one-region-closure.rs:89:20\n+error: argument requires that data must outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-closure.rs:89:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                    ^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n note: No external requirements\n   --> $DIR/projection-one-region-closure.rs:74:1\n@@ -151,7 +151,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | |     T::AssocType: 'a,\n ...  |\n-LL | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+LL | |     //~| ERROR argument requires that data must outlive free region\n LL | | }\n    | |_^\n    |"}, {"sha": "da76193459b30a54b47524ae06071d1ddbe5d0f5", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -46,7 +46,7 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR does not outlive free region\n+    //~| ERROR argument requires that data must outlive free region\n }\n \n #[rustc_regions]\n@@ -57,7 +57,7 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR does not outlive free region\n+    //~| ERROR argument requires that data must outlive free region\n }\n \n #[rustc_regions]\n@@ -78,7 +78,7 @@ where\n \n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR does not outlive free region\n+    //~| ERROR argument requires that data must outlive free region\n }\n \n #[rustc_regions]"}, {"sha": "be11c6249f0ba0dfb04bc96536ef04bee2d5564c", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -31,11 +31,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#2r\n \n-error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:47:20\n+error: argument requires that data must outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:47:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                    ^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:43:1\n@@ -45,7 +45,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | | {\n ...  |\n-LL | |     //~| ERROR does not outlive free region\n+LL | |     //~| ERROR argument requires that data must outlive free region\n LL | | }\n    | |_^\n    |\n@@ -70,11 +70,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 4\n    = note: where '_#2r: '_#3r\n \n-error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:58:20\n+error: argument requires that data must outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:58:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                    ^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:53:1\n@@ -84,7 +84,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | |     'a: 'a,\n ...  |\n-LL | |     //~| ERROR does not outlive free region\n+LL | |     //~| ERROR argument requires that data must outlive free region\n LL | | }\n    | |_^\n    |\n@@ -110,11 +110,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 4\n    = note: where '_#2r: '_#3r\n \n-error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:79:20\n+error: argument requires that data must outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:79:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                    ^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:64:1\n@@ -124,7 +124,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | |     T::AssocType: 'a,\n ...  |\n-LL | |     //~| ERROR does not outlive free region\n+LL | |     //~| ERROR argument requires that data must outlive free region\n LL | | }\n    | |_^\n    |"}, {"sha": "5e481a9626f08166ff50ac80ce86775041be1a2f", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -107,7 +107,7 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR does not outlive free region\n+    //~| ERROR argument requires that data must outlive free region\n }\n \n #[rustc_regions]"}, {"sha": "546384e8545e3fa357693fdb593d944a68bb72c2", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -239,11 +239,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 3\n    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n \n-error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:13 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]), BrNamed(crate0:DefIndex(1:43), 'a))`\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:108:20\n+error: argument requires that data must outlive free region `ReFree(DefId(0/0:13 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]), BrNamed(crate0:DefIndex(1:43), 'a))`\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:108:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                    ^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n note: No external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:104:1\n@@ -253,7 +253,7 @@ LL | | where\n LL | |     T: Anything<'b, 'b>,\n LL | | {\n ...  |\n-LL | |     //~| ERROR does not outlive free region\n+LL | |     //~| ERROR argument requires that data must outlive free region\n LL | | }\n    | |_^\n    |"}, {"sha": "49f9044b19b248c13836a364263640eee72a4c65", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.nll.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af9f91a170d33550e8f5922cdb728384ec9c7eb/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr?ref=6af9f91a170d33550e8f5922cdb728384ec9c7eb", "patch": "@@ -22,15 +22,11 @@ warning: not reporting region error due to nll\n LL |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: free region `` does not outlive free region `'static`\n-  --> $DIR/dyn-trait-underscore.rs:16:52\n+error: cast requires that data must outlive free region `'static`\n+  --> $DIR/dyn-trait-underscore.rs:18:5\n    |\n-LL |   fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n-   |  ____________________________________________________^\n-LL | |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n-LL | |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n-LL | | }\n-   | |_^\n+LL |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}]}