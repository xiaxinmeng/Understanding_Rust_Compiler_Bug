{"sha": "51323a852a8979a71c21725b3b2771224132b85f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMzIzYTg1MmE4OTc5YTcxYzIxNzI1YjNiMjc3MTIyNDEzMmI4NWY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-21T16:43:52Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-21T16:43:52Z"}, "message": "Merge #1011\n\n1011: cleanup r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "6d40e6984a6d91a015d9b876ff56df648352eb72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d40e6984a6d91a015d9b876ff56df648352eb72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51323a852a8979a71c21725b3b2771224132b85f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51323a852a8979a71c21725b3b2771224132b85f", "html_url": "https://github.com/rust-lang/rust/commit/51323a852a8979a71c21725b3b2771224132b85f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51323a852a8979a71c21725b3b2771224132b85f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "48472f55c3eba0746c088613888a163b48d07398", "url": "https://api.github.com/repos/rust-lang/rust/commits/48472f55c3eba0746c088613888a163b48d07398", "html_url": "https://github.com/rust-lang/rust/commit/48472f55c3eba0746c088613888a163b48d07398"}, {"sha": "1b58e3e410187470b1993114f9557b2181efb75a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b58e3e410187470b1993114f9557b2181efb75a", "html_url": "https://github.com/rust-lang/rust/commit/1b58e3e410187470b1993114f9557b2181efb75a"}], "stats": {"total": 599, "additions": 298, "deletions": 301}, "files": [{"sha": "0690925284eff85b15cad05acc3eaa4d544952aa", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 298, "deletions": 53, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/51323a852a8979a71c21725b3b2771224132b85f/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51323a852a8979a71c21725b3b2771224132b85f/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=51323a852a8979a71c21725b3b2771224132b85f", "patch": "@@ -1,65 +1,310 @@\n+use itertools::Itertools;\n use hir::{Problem, source_binder};\n use ra_ide_api_light::Severity;\n use ra_db::SourceDatabase;\n+use ra_syntax::{\n+    Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n+    ast::{self, AstNode},\n \n-use crate::{Diagnostic, FileId, FileSystemEdit, SourceChange, db::RootDatabase};\n+};\n+use ra_text_edit::{TextEdit, TextEditBuilder};\n+\n+use crate::{Diagnostic, FileId, FileSystemEdit, SourceChange, SourceFileEdit, db::RootDatabase};\n \n pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic> {\n-    let syntax = db.parse(file_id);\n-\n-    let mut res = ra_ide_api_light::diagnostics(&syntax)\n-        .into_iter()\n-        .map(|d| Diagnostic {\n-            range: d.range,\n-            message: d.msg,\n-            severity: d.severity,\n-            fix: d.fix.map(|fix| SourceChange::from_local_edit(file_id, fix)),\n-        })\n-        .collect::<Vec<_>>();\n+    let source_file = db.parse(file_id);\n+    let mut res = Vec::new();\n+\n+    syntax_errors(&mut res, &source_file);\n+\n+    for node in source_file.syntax().descendants() {\n+        check_unnecessary_braces_in_use_statement(&mut res, file_id, node);\n+        check_struct_shorthand_initialization(&mut res, file_id, node);\n+    }\n+\n     if let Some(m) = source_binder::module_from_file_id(db, file_id) {\n-        for (name_node, problem) in m.problems(db) {\n-            let source_root = db.file_source_root(file_id);\n-            let diag = match problem {\n-                Problem::UnresolvedModule { candidate } => {\n-                    let create_file =\n-                        FileSystemEdit::CreateFile { source_root, path: candidate.clone() };\n-                    let fix = SourceChange {\n-                        label: \"create module\".to_string(),\n-                        source_file_edits: Vec::new(),\n-                        file_system_edits: vec![create_file],\n+        check_module(&mut res, db, file_id, m);\n+    };\n+    res\n+}\n+\n+fn syntax_errors(acc: &mut Vec<Diagnostic>, source_file: &SourceFile) {\n+    fn location_to_range(location: Location) -> TextRange {\n+        match location {\n+            Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n+            Location::Range(range) => range,\n+        }\n+    }\n+\n+    acc.extend(source_file.errors().into_iter().map(|err| Diagnostic {\n+        range: location_to_range(err.location()),\n+        message: format!(\"Syntax Error: {}\", err),\n+        severity: Severity::Error,\n+        fix: None,\n+    }));\n+}\n+\n+fn check_unnecessary_braces_in_use_statement(\n+    acc: &mut Vec<Diagnostic>,\n+    file_id: FileId,\n+    node: &SyntaxNode,\n+) -> Option<()> {\n+    let use_tree_list = ast::UseTreeList::cast(node)?;\n+    if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n+        let range = use_tree_list.syntax().range();\n+        let edit =\n+            text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(single_use_tree)\n+                .unwrap_or_else(|| {\n+                    let to_replace = single_use_tree.syntax().text().to_string();\n+                    let mut edit_builder = TextEditBuilder::default();\n+                    edit_builder.delete(range);\n+                    edit_builder.insert(range.start(), to_replace);\n+                    edit_builder.finish()\n+                });\n+\n+        acc.push(Diagnostic {\n+            range,\n+            message: format!(\"Unnecessary braces in use statement\"),\n+            severity: Severity::WeakWarning,\n+            fix: Some(SourceChange {\n+                label: \"Remove unnecessary braces\".to_string(),\n+                source_file_edits: vec![SourceFileEdit { file_id, edit }],\n+                file_system_edits: Vec::new(),\n+                cursor_position: None,\n+            }),\n+        });\n+    }\n+\n+    Some(())\n+}\n+\n+fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n+    single_use_tree: &ast::UseTree,\n+) -> Option<TextEdit> {\n+    let use_tree_list_node = single_use_tree.syntax().parent()?;\n+    if single_use_tree.path()?.segment()?.syntax().first_child()?.kind() == SyntaxKind::SELF_KW {\n+        let start = use_tree_list_node.prev_sibling()?.range().start();\n+        let end = use_tree_list_node.range().end();\n+        let range = TextRange::from_to(start, end);\n+        let mut edit_builder = TextEditBuilder::default();\n+        edit_builder.delete(range);\n+        return Some(edit_builder.finish());\n+    }\n+    None\n+}\n+\n+fn check_struct_shorthand_initialization(\n+    acc: &mut Vec<Diagnostic>,\n+    file_id: FileId,\n+    node: &SyntaxNode,\n+) -> Option<()> {\n+    let struct_lit = ast::StructLit::cast(node)?;\n+    let named_field_list = struct_lit.named_field_list()?;\n+    for named_field in named_field_list.fields() {\n+        if let (Some(name_ref), Some(expr)) = (named_field.name_ref(), named_field.expr()) {\n+            let field_name = name_ref.syntax().text().to_string();\n+            let field_expr = expr.syntax().text().to_string();\n+            if field_name == field_expr {\n+                let mut edit_builder = TextEditBuilder::default();\n+                edit_builder.delete(named_field.syntax().range());\n+                edit_builder.insert(named_field.syntax().range().start(), field_name);\n+                let edit = edit_builder.finish();\n+\n+                acc.push(Diagnostic {\n+                    range: named_field.syntax().range(),\n+                    message: format!(\"Shorthand struct initialization\"),\n+                    severity: Severity::WeakWarning,\n+                    fix: Some(SourceChange {\n+                        label: \"use struct shorthand initialization\".to_string(),\n+                        source_file_edits: vec![SourceFileEdit { file_id, edit }],\n+                        file_system_edits: Vec::new(),\n                         cursor_position: None,\n-                    };\n-                    Diagnostic {\n-                        range: name_node.range(),\n-                        message: \"unresolved module\".to_string(),\n-                        severity: Severity::Error,\n-                        fix: Some(fix),\n-                    }\n+                    }),\n+                });\n+            }\n+        }\n+    }\n+    Some(())\n+}\n+\n+fn check_module(\n+    acc: &mut Vec<Diagnostic>,\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    module: hir::Module,\n+) {\n+    let source_root = db.file_source_root(file_id);\n+    for (name_node, problem) in module.problems(db) {\n+        let diag = match problem {\n+            Problem::UnresolvedModule { candidate } => {\n+                let create_file =\n+                    FileSystemEdit::CreateFile { source_root, path: candidate.clone() };\n+                let fix = SourceChange {\n+                    label: \"create module\".to_string(),\n+                    source_file_edits: Vec::new(),\n+                    file_system_edits: vec![create_file],\n+                    cursor_position: None,\n+                };\n+                Diagnostic {\n+                    range: name_node.range(),\n+                    message: \"unresolved module\".to_string(),\n+                    severity: Severity::Error,\n+                    fix: Some(fix),\n                 }\n-                Problem::NotDirOwner { move_to, candidate } => {\n-                    let move_file = FileSystemEdit::MoveFile {\n-                        src: file_id,\n-                        dst_source_root: source_root,\n-                        dst_path: move_to.clone(),\n-                    };\n-                    let create_file =\n-                        FileSystemEdit::CreateFile { source_root, path: move_to.join(candidate) };\n-                    let fix = SourceChange {\n-                        label: \"move file and create module\".to_string(),\n-                        source_file_edits: Vec::new(),\n-                        file_system_edits: vec![move_file, create_file],\n-                        cursor_position: None,\n-                    };\n-                    Diagnostic {\n-                        range: name_node.range(),\n-                        message: \"can't declare module at this location\".to_string(),\n-                        severity: Severity::Error,\n-                        fix: Some(fix),\n-                    }\n+            }\n+            Problem::NotDirOwner { move_to, candidate } => {\n+                let move_file = FileSystemEdit::MoveFile {\n+                    src: file_id,\n+                    dst_source_root: source_root,\n+                    dst_path: move_to.clone(),\n+                };\n+                let create_file =\n+                    FileSystemEdit::CreateFile { source_root, path: move_to.join(candidate) };\n+                let fix = SourceChange {\n+                    label: \"move file and create module\".to_string(),\n+                    source_file_edits: Vec::new(),\n+                    file_system_edits: vec![move_file, create_file],\n+                    cursor_position: None,\n+                };\n+                Diagnostic {\n+                    range: name_node.range(),\n+                    message: \"can't declare module at this location\".to_string(),\n+                    severity: Severity::Error,\n+                    fix: Some(fix),\n                 }\n-            };\n-            res.push(diag)\n+            }\n+        };\n+        acc.push(diag)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::assert_eq_text;\n+\n+    use super::*;\n+\n+    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, FileId, &SyntaxNode) -> Option<()>;\n+\n+    fn check_not_applicable(code: &str, func: DiagnosticChecker) {\n+        let file = SourceFile::parse(code);\n+        let mut diagnostics = Vec::new();\n+        for node in file.syntax().descendants() {\n+            func(&mut diagnostics, FileId(0), node);\n         }\n-    };\n-    res\n+        assert!(diagnostics.is_empty());\n+    }\n+\n+    fn check_apply(before: &str, after: &str, func: DiagnosticChecker) {\n+        let file = SourceFile::parse(before);\n+        let mut diagnostics = Vec::new();\n+        for node in file.syntax().descendants() {\n+            func(&mut diagnostics, FileId(0), node);\n+        }\n+        let diagnostic =\n+            diagnostics.pop().unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n+        let mut fix = diagnostic.fix.unwrap();\n+        let edit = fix.source_file_edits.pop().unwrap().edit;\n+        let actual = edit.apply(&before);\n+        assert_eq_text!(after, &actual);\n+    }\n+\n+    #[test]\n+    fn test_check_unnecessary_braces_in_use_statement() {\n+        check_not_applicable(\n+            \"\n+            use a;\n+            use a::{c, d::e};\n+        \",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+        check_apply(\"use {b};\", \"use b;\", check_unnecessary_braces_in_use_statement);\n+        check_apply(\"use a::{c};\", \"use a::c;\", check_unnecessary_braces_in_use_statement);\n+        check_apply(\"use a::{self};\", \"use a;\", check_unnecessary_braces_in_use_statement);\n+        check_apply(\n+            \"use a::{c, d::{e}};\",\n+            \"use a::{c, d::e};\",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_check_struct_shorthand_initialization() {\n+        check_not_applicable(\n+            r#\"\n+            struct A {\n+                a: &'static str\n+            }\n+\n+            fn main() {\n+                A {\n+                    a: \"hello\"\n+                }\n+            }\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+\n+        check_apply(\n+            r#\"\n+struct A {\n+    a: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    A {\n+        a: a\n+    }\n+}\n+        \"#,\n+            r#\"\n+struct A {\n+    a: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    A {\n+        a\n+    }\n+}\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+\n+        check_apply(\n+            r#\"\n+struct A {\n+    a: &'static str,\n+    b: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    let b = \"bb\";\n+    A {\n+        a: a,\n+        b\n+    }\n+}\n+        \"#,\n+            r#\"\n+struct A {\n+    a: &'static str,\n+    b: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    let b = \"bb\";\n+    A {\n+        a,\n+        b\n+    }\n+}\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+    }\n }"}, {"sha": "7c383ca2af69f575ba4bab3adf8dc89baf714405", "filename": "crates/ra_ide_api_light/src/diagnostics.rs", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/48472f55c3eba0746c088613888a163b48d07398/crates%2Fra_ide_api_light%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48472f55c3eba0746c088613888a163b48d07398/crates%2Fra_ide_api_light%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fdiagnostics.rs?ref=48472f55c3eba0746c088613888a163b48d07398", "patch": "@@ -1,246 +0,0 @@\n-use itertools::Itertools;\n-\n-use ra_syntax::{\n-    Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n-    ast::{self, AstNode},\n-\n-};\n-use ra_text_edit::{TextEdit, TextEditBuilder};\n-\n-use crate::{Diagnostic, LocalEdit, Severity};\n-\n-pub fn diagnostics(file: &SourceFile) -> Vec<Diagnostic> {\n-    fn location_to_range(location: Location) -> TextRange {\n-        match location {\n-            Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n-            Location::Range(range) => range,\n-        }\n-    }\n-\n-    let mut errors: Vec<Diagnostic> = file\n-        .errors()\n-        .into_iter()\n-        .map(|err| Diagnostic {\n-            range: location_to_range(err.location()),\n-            msg: format!(\"Syntax Error: {}\", err),\n-            severity: Severity::Error,\n-            fix: None,\n-        })\n-        .collect();\n-\n-    for node in file.syntax().descendants() {\n-        check_unnecessary_braces_in_use_statement(&mut errors, node);\n-        check_struct_shorthand_initialization(&mut errors, node);\n-    }\n-\n-    errors\n-}\n-\n-fn check_unnecessary_braces_in_use_statement(\n-    acc: &mut Vec<Diagnostic>,\n-    node: &SyntaxNode,\n-) -> Option<()> {\n-    let use_tree_list = ast::UseTreeList::cast(node)?;\n-    if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n-        let range = use_tree_list.syntax().range();\n-        let edit =\n-            text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(single_use_tree)\n-                .unwrap_or_else(|| {\n-                    let to_replace = single_use_tree.syntax().text().to_string();\n-                    let mut edit_builder = TextEditBuilder::default();\n-                    edit_builder.delete(range);\n-                    edit_builder.insert(range.start(), to_replace);\n-                    edit_builder.finish()\n-                });\n-\n-        acc.push(Diagnostic {\n-            range,\n-            msg: format!(\"Unnecessary braces in use statement\"),\n-            severity: Severity::WeakWarning,\n-            fix: Some(LocalEdit {\n-                label: \"Remove unnecessary braces\".to_string(),\n-                edit,\n-                cursor_position: None,\n-            }),\n-        });\n-    }\n-\n-    Some(())\n-}\n-\n-fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n-    single_use_tree: &ast::UseTree,\n-) -> Option<TextEdit> {\n-    let use_tree_list_node = single_use_tree.syntax().parent()?;\n-    if single_use_tree.path()?.segment()?.syntax().first_child()?.kind() == SyntaxKind::SELF_KW {\n-        let start = use_tree_list_node.prev_sibling()?.range().start();\n-        let end = use_tree_list_node.range().end();\n-        let range = TextRange::from_to(start, end);\n-        let mut edit_builder = TextEditBuilder::default();\n-        edit_builder.delete(range);\n-        return Some(edit_builder.finish());\n-    }\n-    None\n-}\n-\n-fn check_struct_shorthand_initialization(\n-    acc: &mut Vec<Diagnostic>,\n-    node: &SyntaxNode,\n-) -> Option<()> {\n-    let struct_lit = ast::StructLit::cast(node)?;\n-    let named_field_list = struct_lit.named_field_list()?;\n-    for named_field in named_field_list.fields() {\n-        if let (Some(name_ref), Some(expr)) = (named_field.name_ref(), named_field.expr()) {\n-            let field_name = name_ref.syntax().text().to_string();\n-            let field_expr = expr.syntax().text().to_string();\n-            if field_name == field_expr {\n-                let mut edit_builder = TextEditBuilder::default();\n-                edit_builder.delete(named_field.syntax().range());\n-                edit_builder.insert(named_field.syntax().range().start(), field_name);\n-                let edit = edit_builder.finish();\n-\n-                acc.push(Diagnostic {\n-                    range: named_field.syntax().range(),\n-                    msg: format!(\"Shorthand struct initialization\"),\n-                    severity: Severity::WeakWarning,\n-                    fix: Some(LocalEdit {\n-                        label: \"use struct shorthand initialization\".to_string(),\n-                        edit,\n-                        cursor_position: None,\n-                    }),\n-                });\n-            }\n-        }\n-    }\n-    Some(())\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::test_utils::assert_eq_text;\n-\n-    use super::*;\n-\n-    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, &SyntaxNode) -> Option<()>;\n-\n-    fn check_not_applicable(code: &str, func: DiagnosticChecker) {\n-        let file = SourceFile::parse(code);\n-        let mut diagnostics = Vec::new();\n-        for node in file.syntax().descendants() {\n-            func(&mut diagnostics, node);\n-        }\n-        assert!(diagnostics.is_empty());\n-    }\n-\n-    fn check_apply(before: &str, after: &str, func: DiagnosticChecker) {\n-        let file = SourceFile::parse(before);\n-        let mut diagnostics = Vec::new();\n-        for node in file.syntax().descendants() {\n-            func(&mut diagnostics, node);\n-        }\n-        let diagnostic =\n-            diagnostics.pop().unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n-        let fix = diagnostic.fix.unwrap();\n-        let actual = fix.edit.apply(&before);\n-        assert_eq_text!(after, &actual);\n-    }\n-\n-    #[test]\n-    fn test_check_unnecessary_braces_in_use_statement() {\n-        check_not_applicable(\n-            \"\n-            use a;\n-            use a::{c, d::e};\n-        \",\n-            check_unnecessary_braces_in_use_statement,\n-        );\n-        check_apply(\"use {b};\", \"use b;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\"use a::{c};\", \"use a::c;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\"use a::{self};\", \"use a;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\n-            \"use a::{c, d::{e}};\",\n-            \"use a::{c, d::e};\",\n-            check_unnecessary_braces_in_use_statement,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_check_struct_shorthand_initialization() {\n-        check_not_applicable(\n-            r#\"\n-            struct A {\n-                a: &'static str\n-            }\n-\n-            fn main() {\n-                A {\n-                    a: \"hello\"\n-                }\n-            }\n-        \"#,\n-            check_struct_shorthand_initialization,\n-        );\n-\n-        check_apply(\n-            r#\"\n-struct A {\n-    a: &'static str\n-}\n-\n-fn main() {\n-    let a = \"haha\";\n-    A {\n-        a: a\n-    }\n-}\n-        \"#,\n-            r#\"\n-struct A {\n-    a: &'static str\n-}\n-\n-fn main() {\n-    let a = \"haha\";\n-    A {\n-        a\n-    }\n-}\n-        \"#,\n-            check_struct_shorthand_initialization,\n-        );\n-\n-        check_apply(\n-            r#\"\n-struct A {\n-    a: &'static str,\n-    b: &'static str\n-}\n-\n-fn main() {\n-    let a = \"haha\";\n-    let b = \"bb\";\n-    A {\n-        a: a,\n-        b\n-    }\n-}\n-        \"#,\n-            r#\"\n-struct A {\n-    a: &'static str,\n-    b: &'static str\n-}\n-\n-fn main() {\n-    let a = \"haha\";\n-    let b = \"bb\";\n-    A {\n-        a,\n-        b\n-    }\n-}\n-        \"#,\n-            check_struct_shorthand_initialization,\n-        );\n-    }\n-}"}, {"sha": "47b30255b9c14f547d9d38573a7e1eac428fb0fa", "filename": "crates/ra_ide_api_light/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51323a852a8979a71c21725b3b2771224132b85f/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51323a852a8979a71c21725b3b2771224132b85f/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs?ref=51323a852a8979a71c21725b3b2771224132b85f", "patch": "@@ -11,7 +11,6 @@ mod structure;\n mod test_utils;\n mod join_lines;\n mod typing;\n-mod diagnostics;\n \n use rustc_hash::FxHashSet;\n use ra_text_edit::TextEditBuilder;\n@@ -27,7 +26,6 @@ pub use crate::{\n     line_index::{LineCol, LineIndex},\n     line_index_utils::translate_offset_with_edit,\n     structure::{file_structure, StructureNode},\n-    diagnostics::diagnostics,\n     join_lines::join_lines,\n     typing::{on_enter, on_dot_typed, on_eq_typed},\n };"}]}