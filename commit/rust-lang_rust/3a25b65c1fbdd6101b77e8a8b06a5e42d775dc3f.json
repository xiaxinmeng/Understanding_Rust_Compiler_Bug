{"sha": "3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMjViNjVjMWZiZGQ2MTAxYjc3ZThhOGIwNmE1ZTQyZDc3NWRjM2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-26T18:43:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-26T18:43:32Z"}, "message": "Auto merge of #37315 - bluss:fold-more, r=alexcrichton\n\nImplement Iterator::fold for .chain(), .cloned(), .map() and the VecDeque iterators.\n\nChain can do something interesting here where it passes on the fold\ninto its inner iterators.\n\nThe lets the underlying iterator's custom fold() be used, and skips the\nregular chain logic in next.\n\nAlso implement .fold() specifically for .map() and .cloned() so that any\ninner fold improvements are available through map and cloned.\n\nThe same way, a VecDeque iterator fold can be turned into two slice folds.\n\nThese changes lend the power of the slice iterator's loop codegen to\nVecDeque, and to chains of slice iterators, and so on.\nIt's an improvement for .sum() and .product(), and other uses of fold.", "tree": {"sha": "4e2a55a6f3807b9411a74bdb25978c4f87d3baf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e2a55a6f3807b9411a74bdb25978c4f87d3baf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f", "html_url": "https://github.com/rust-lang/rust/commit/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745", "html_url": "https://github.com/rust-lang/rust/commit/a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745"}, {"sha": "a16626fc422f9fdcd1d02f56b628f764d5282261", "url": "https://api.github.com/repos/rust-lang/rust/commits/a16626fc422f9fdcd1d02f56b628f764d5282261", "html_url": "https://github.com/rust-lang/rust/commit/a16626fc422f9fdcd1d02f56b628f764d5282261"}], "stats": {"total": 118, "additions": 98, "deletions": 20}, "files": [{"sha": "5397193cab40f476bf843fd2229f21cbf6eb7bce", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 54, "deletions": 20, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f", "patch": "@@ -743,16 +743,8 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n         unsafe {\n-            let contiguous = self.is_contiguous();\n             let buf = self.buffer_as_slice();\n-            if contiguous {\n-                let (empty, buf) = buf.split_at(0);\n-                (&buf[self.tail..self.head], empty)\n-            } else {\n-                let (mid, right) = buf.split_at(self.tail);\n-                let (left, _) = mid.split_at(self.head);\n-                (right, left)\n-            }\n+            RingSlices::ring_slices(buf, self.head, self.tail)\n         }\n     }\n \n@@ -780,20 +772,10 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n         unsafe {\n-            let contiguous = self.is_contiguous();\n             let head = self.head;\n             let tail = self.tail;\n             let buf = self.buffer_as_mut_slice();\n-\n-            if contiguous {\n-                let (empty, buf) = buf.split_at_mut(0);\n-                (&mut buf[tail..head], empty)\n-            } else {\n-                let (mid, right) = buf.split_at_mut(tail);\n-                let (left, _) = mid.split_at_mut(head);\n-\n-                (right, left)\n-            }\n+            RingSlices::ring_slices(buf, head, tail)\n         }\n     }\n \n@@ -1829,6 +1811,42 @@ fn wrap_index(index: usize, size: usize) -> usize {\n     index & (size - 1)\n }\n \n+/// Returns the two slices that cover the VecDeque's valid range\n+trait RingSlices : Sized {\n+    fn slice(self, from: usize, to: usize) -> Self;\n+    fn split_at(self, i: usize) -> (Self, Self);\n+\n+    fn ring_slices(buf: Self, head: usize, tail: usize) -> (Self, Self) {\n+        let contiguous = tail <= head;\n+        if contiguous {\n+            let (empty, buf) = buf.split_at(0);\n+            (buf.slice(tail, head), empty)\n+        } else {\n+            let (mid, right) = buf.split_at(tail);\n+            let (left, _) = mid.split_at(head);\n+            (right, left)\n+        }\n+    }\n+}\n+\n+impl<'a, T> RingSlices for &'a [T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        &self[from..to]\n+    }\n+    fn split_at(self, i: usize) -> (Self, Self) {\n+        (*self).split_at(i)\n+    }\n+}\n+\n+impl<'a, T> RingSlices for &'a mut [T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        &mut self[from..to]\n+    }\n+    fn split_at(self, i: usize) -> (Self, Self) {\n+        (*self).split_at_mut(i)\n+    }\n+}\n+\n /// Calculate the number of elements left to be read in the buffer\n #[inline]\n fn count(tail: usize, head: usize, size: usize) -> usize {\n@@ -1875,6 +1893,14 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         let len = count(self.tail, self.head, self.ring.len());\n         (len, Some(len))\n     }\n+\n+    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        accum = front.iter().fold(accum, &mut f);\n+        back.iter().fold(accum, &mut f)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1927,6 +1953,14 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         let len = count(self.tail, self.head, self.ring.len());\n         (len, Some(len))\n     }\n+\n+    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        accum = front.iter_mut().fold(accum, &mut f);\n+        back.iter_mut().fold(accum, &mut f)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "df4f5e5c5764335d1cc53cde45caa840bb14ad27", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f", "patch": "@@ -399,6 +399,12 @@ impl<'a, I, T: 'a> Iterator for Cloned<I>\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.it.size_hint()\n     }\n+\n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.fold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n }\n \n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n@@ -544,6 +550,25 @@ impl<A, B> Iterator for Chain<A, B> where\n         }\n     }\n \n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.fold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.fold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        accum\n+    }\n+\n     #[inline]\n     fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n         match self.state {\n@@ -939,6 +964,13 @@ impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+        where G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "58b6444ef88cd95f278d4c0b458516573b1cc5c4", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=3a25b65c1fbdd6101b77e8a8b06a5e42d775dc3f", "patch": "@@ -985,6 +985,18 @@ fn test_empty() {\n     assert_eq!(it.next(), None);\n }\n \n+#[test]\n+fn test_chain_fold() {\n+    let xs = [1, 2, 3];\n+    let ys = [1, 2, 0];\n+\n+    let mut iter = xs.iter().chain(&ys);\n+    iter.next();\n+    let mut result = Vec::new();\n+    iter.fold((), |(), &elt| result.push(elt));\n+    assert_eq!(&[2, 3, 1, 2, 0], &result[..]);\n+}\n+\n #[bench]\n fn bench_rposition(b: &mut Bencher) {\n     let it: Vec<usize> = (0..300).collect();"}]}