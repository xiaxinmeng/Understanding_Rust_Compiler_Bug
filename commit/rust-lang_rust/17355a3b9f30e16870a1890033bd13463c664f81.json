{"sha": "17355a3b9f30e16870a1890033bd13463c664f81", "node_id": "C_kwDOAAsO6NoAKDE3MzU1YTNiOWYzMGUxNjg3MGExODkwMDMzYmQxMzQ2M2M2NjRmODE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-09T22:37:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-09T22:37:56Z"}, "message": "Auto merge of #98950 - ChrisDenton:getoverlapped-io, r=thomcc\n\nWindows: Fallback for overlapped I/O\n\nFixes #98947", "tree": {"sha": "7c7d47a1a3536544a6f653b5fce402091c7caddf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c7d47a1a3536544a6f653b5fce402091c7caddf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17355a3b9f30e16870a1890033bd13463c664f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17355a3b9f30e16870a1890033bd13463c664f81", "html_url": "https://github.com/rust-lang/rust/commit/17355a3b9f30e16870a1890033bd13463c664f81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17355a3b9f30e16870a1890033bd13463c664f81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dba4ed215e7a60f0a2a19c04f3f73691f89c509", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dba4ed215e7a60f0a2a19c04f3f73691f89c509", "html_url": "https://github.com/rust-lang/rust/commit/6dba4ed215e7a60f0a2a19c04f3f73691f89c509"}, {"sha": "91a640176af5b164b62aa867beaf0b02fd2d93da", "url": "https://api.github.com/repos/rust-lang/rust/commits/91a640176af5b164b62aa867beaf0b02fd2d93da", "html_url": "https://github.com/rust-lang/rust/commit/91a640176af5b164b62aa867beaf0b02fd2d93da"}], "stats": {"total": 142, "additions": 134, "deletions": 8}, "files": [{"sha": "c7a42ef9a93823a86815c0da7e04cd0575b9e2ba", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/17355a3b9f30e16870a1890033bd13463c664f81/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17355a3b9f30e16870a1890033bd13463c664f81/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=17355a3b9f30e16870a1890033bd13463c664f81", "patch": "@@ -326,7 +326,9 @@ union IO_STATUS_BLOCK_union {\n }\n impl Default for IO_STATUS_BLOCK_union {\n     fn default() -> Self {\n-        Self { Pointer: ptr::null_mut() }\n+        let mut this = Self { Pointer: ptr::null_mut() };\n+        this.Status = STATUS_PENDING;\n+        this\n     }\n }\n #[repr(C)]\n@@ -335,6 +337,16 @@ pub struct IO_STATUS_BLOCK {\n     u: IO_STATUS_BLOCK_union,\n     pub Information: usize,\n }\n+impl IO_STATUS_BLOCK {\n+    pub fn status(&self) -> NTSTATUS {\n+        // SAFETY: If `self.u.Status` was set then this is obviously safe.\n+        // If `self.u.Pointer` was set then this is the equivalent to converting\n+        // the pointer to an integer, which is also safe.\n+        // Currently the only safe way to construct `IO_STATUS_BLOCK` outside of\n+        // this module is to call the `default` method, which sets the `Status`.\n+        unsafe { self.u.Status }\n+    }\n+}\n \n pub type LPOVERLAPPED_COMPLETION_ROUTINE = unsafe extern \"system\" fn(\n     dwErrorCode: DWORD,"}, {"sha": "e24b09cc96ec822742b10a1de05c4e75eda2869e", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/17355a3b9f30e16870a1890033bd13463c664f81/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17355a3b9f30e16870a1890033bd13463c664f81/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=17355a3b9f30e16870a1890033bd13463c664f81", "patch": "@@ -1,5 +1,8 @@\n #![unstable(issue = \"none\", feature = \"windows_handle\")]\n \n+#[cfg(test)]\n+mod tests;\n+\n use crate::cmp;\n use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, Read, ReadBuf};\n use crate::mem;\n@@ -248,14 +251,18 @@ impl Handle {\n             offset.map(|n| n as _).as_ref(),\n             None,\n         );\n+\n+        let status = if status == c::STATUS_PENDING {\n+            c::WaitForSingleObject(self.as_raw_handle(), c::INFINITE);\n+            io_status.status()\n+        } else {\n+            status\n+        };\n         match status {\n             // If the operation has not completed then abort the process.\n             // Doing otherwise means that the buffer and stack may be written to\n             // after this function returns.\n-            c::STATUS_PENDING => {\n-                eprintln!(\"I/O error: operation failed to complete synchronously\");\n-                crate::process::abort();\n-            }\n+            c::STATUS_PENDING => rtabort!(\"I/O error: operation failed to complete synchronously\"),\n \n             // Return `Ok(0)` when there's nothing more to read.\n             c::STATUS_END_OF_FILE => Ok(0),\n@@ -294,13 +301,17 @@ impl Handle {\n                 None,\n             )\n         };\n+        let status = if status == c::STATUS_PENDING {\n+            unsafe { c::WaitForSingleObject(self.as_raw_handle(), c::INFINITE) };\n+            io_status.status()\n+        } else {\n+            status\n+        };\n         match status {\n             // If the operation has not completed then abort the process.\n             // Doing otherwise means that the buffer may be read and the stack\n             // written to after this function returns.\n-            c::STATUS_PENDING => {\n-                rtabort!(\"I/O error: operation failed to complete synchronously\");\n-            }\n+            c::STATUS_PENDING => rtabort!(\"I/O error: operation failed to complete synchronously\"),\n \n             // Success!\n             status if c::nt_success(status) => Ok(io_status.Information),"}, {"sha": "d836dae4c305b72b97c5e3d7a613c94d4f7c6799", "filename": "library/std/src/sys/windows/handle/tests.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/17355a3b9f30e16870a1890033bd13463c664f81/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17355a3b9f30e16870a1890033bd13463c664f81/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle%2Ftests.rs?ref=17355a3b9f30e16870a1890033bd13463c664f81", "patch": "@@ -0,0 +1,22 @@\n+use crate::sys::pipe::{anon_pipe, Pipes};\n+use crate::{thread, time};\n+\n+/// Test the synchronous fallback for overlapped I/O.\n+#[test]\n+fn overlapped_handle_fallback() {\n+    // Create some pipes. `ours` will be asynchronous.\n+    let Pipes { ours, theirs } = anon_pipe(true, false).unwrap();\n+\n+    let async_readable = ours.into_handle();\n+    let sync_writeable = theirs.into_handle();\n+\n+    thread::scope(|_| {\n+        thread::sleep(time::Duration::from_millis(100));\n+        sync_writeable.write(b\"hello world!\").unwrap();\n+    });\n+\n+    // The pipe buffer starts empty so reading won't complete synchronously unless\n+    // our fallback path works.\n+    let mut buffer = [0u8; 1024];\n+    async_readable.read(&mut buffer).unwrap();\n+}"}, {"sha": "fdf1150f8d25a7fb22f499a48cd033453819bcd8", "filename": "src/test/ui-fulldeps/issue-81357-unsound-file-methods.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/17355a3b9f30e16870a1890033bd13463c664f81/src%2Ftest%2Fui-fulldeps%2Fissue-81357-unsound-file-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17355a3b9f30e16870a1890033bd13463c664f81/src%2Ftest%2Fui-fulldeps%2Fissue-81357-unsound-file-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-81357-unsound-file-methods.rs?ref=17355a3b9f30e16870a1890033bd13463c664f81", "patch": "@@ -0,0 +1,81 @@\n+// run-fail\n+// only-windows\n+\n+fn main() {\n+    use std::fs;\n+    use std::io::prelude::*;\n+    use std::os::windows::prelude::*;\n+    use std::ptr;\n+    use std::sync::Arc;\n+    use std::thread;\n+    use std::time::Duration;\n+\n+    const FILE_FLAG_OVERLAPPED: u32 = 0x40000000;\n+\n+    fn create_pipe_server(path: &str) -> fs::File {\n+        let mut path0 = path.as_bytes().to_owned();\n+        path0.push(0);\n+        extern \"system\" {\n+            fn CreateNamedPipeA(\n+                lpName: *const u8,\n+                dwOpenMode: u32,\n+                dwPipeMode: u32,\n+                nMaxInstances: u32,\n+                nOutBufferSize: u32,\n+                nInBufferSize: u32,\n+                nDefaultTimeOut: u32,\n+                lpSecurityAttributes: *mut u8,\n+            ) -> RawHandle;\n+        }\n+\n+        unsafe {\n+            let h = CreateNamedPipeA(path0.as_ptr(), 3, 0, 1, 0, 0, 0, ptr::null_mut());\n+            assert_ne!(h as isize, -1);\n+            fs::File::from_raw_handle(h)\n+        }\n+    }\n+\n+    let path = \"\\\\\\\\.\\\\pipe\\\\repro\";\n+    let mut server = create_pipe_server(path);\n+\n+    let client = Arc::new(\n+        fs::OpenOptions::new().custom_flags(FILE_FLAG_OVERLAPPED).read(true).open(path).unwrap(),\n+    );\n+\n+    let spawn_read = |is_first: bool| {\n+        thread::spawn({\n+            let f = client.clone();\n+            move || {\n+                let mut buf = [0xcc; 1];\n+                let mut f = f.as_ref();\n+                f.read(&mut buf).unwrap();\n+                if is_first {\n+                    assert_ne!(buf[0], 0xcc);\n+                } else {\n+                    let b = buf[0]; // capture buf[0]\n+                    thread::sleep(Duration::from_millis(200));\n+\n+                    // Check the buffer hasn't been written to after read.\n+                    dbg!(buf[0], b);\n+                    assert_eq!(buf[0], b);\n+                }\n+            }\n+        })\n+    };\n+\n+    let t1 = spawn_read(true);\n+    thread::sleep(Duration::from_millis(20));\n+    let t2 = spawn_read(false);\n+    thread::sleep(Duration::from_millis(100));\n+    let _ = server.write(b\"x\");\n+    thread::sleep(Duration::from_millis(100));\n+    let _ = server.write(b\"y\");\n+\n+    // This is run fail because we need to test for the `abort`.\n+    // That failing to run is the success case.\n+    if t1.join().is_err() || t2.join().is_err() {\n+        return;\n+    } else {\n+        panic!(\"success\");\n+    }\n+}"}]}