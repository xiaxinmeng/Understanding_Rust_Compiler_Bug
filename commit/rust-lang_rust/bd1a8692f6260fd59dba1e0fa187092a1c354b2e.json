{"sha": "bd1a8692f6260fd59dba1e0fa187092a1c354b2e", "node_id": "C_kwDOAAsO6NoAKGJkMWE4NjkyZjYyNjBmZDU5ZGJhMWUwZmExODcwOTJhMWMzNTRiMmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-31T15:20:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-31T15:20:59Z"}, "message": "Auto merge of #90204 - cjgillot:owner-pull, r=michaelwoerister\n\nMake lowering pull-based\n\n~Based on https://github.com/rust-lang/rust/pull/90451~\nPart of https://github.com/rust-lang/rust/pull/88186\n\nThe current lowering code visits all the item-likes in the AST in order, and lowers them one by one.\nThis PR changes it to index the AST and then proceed to lowering on-demand. This is closer to the logic of query-based lowering.", "tree": {"sha": "1de4f925cd61aa8053cf2255465a93ec736f546f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1de4f925cd61aa8053cf2255465a93ec736f546f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd1a8692f6260fd59dba1e0fa187092a1c354b2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1a8692f6260fd59dba1e0fa187092a1c354b2e", "html_url": "https://github.com/rust-lang/rust/commit/bd1a8692f6260fd59dba1e0fa187092a1c354b2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd1a8692f6260fd59dba1e0fa187092a1c354b2e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03314912f1361af6b39383958b5aa1b4aed61c26", "url": "https://api.github.com/repos/rust-lang/rust/commits/03314912f1361af6b39383958b5aa1b4aed61c26", "html_url": "https://github.com/rust-lang/rust/commit/03314912f1361af6b39383958b5aa1b4aed61c26"}, {"sha": "6b099db18cbf252e84ec7035c6f8917a61c3c231", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b099db18cbf252e84ec7035c6f8917a61c3c231", "html_url": "https://github.com/rust-lang/rust/commit/6b099db18cbf252e84ec7035c6f8917a61c3c231"}], "stats": {"total": 523, "additions": 273, "deletions": 250}, "files": [{"sha": "c8fd96309a6cd3bac49a1e8ed7729880465ca6d2", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 132, "deletions": 116, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/bd1a8692f6260fd59dba1e0fa187092a1c354b2e/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1a8692f6260fd59dba1e0fa187092a1c354b2e/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=bd1a8692f6260fd59dba1e0fa187092a1c354b2e", "patch": "@@ -1,16 +1,19 @@\n use super::{AnonymousLifetimeMode, LoweringContext, ParamMode};\n-use super::{ImplTraitContext, ImplTraitPosition};\n+use super::{AstOwner, ImplTraitContext, ImplTraitPosition, ResolverAstLowering};\n use crate::{Arena, FnDeclKind};\n \n use rustc_ast::ptr::P;\n-use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n+use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sorted_map::SortedMap;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::LocalDefId;\n-use rustc_index::vec::Idx;\n+use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_session::utils::NtToTokenstream;\n+use rustc_session::Session;\n use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n@@ -19,10 +22,14 @@ use smallvec::{smallvec, SmallVec};\n use tracing::debug;\n \n use std::iter;\n-use std::mem;\n \n-pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n-    pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,\n+pub(super) struct ItemLowerer<'a, 'hir> {\n+    pub(super) sess: &'a Session,\n+    pub(super) resolver: &'a mut dyn ResolverAstLowering,\n+    pub(super) nt_to_tokenstream: NtToTokenstream,\n+    pub(super) arena: &'hir Arena<'hir>,\n+    pub(super) ast_index: &'a IndexVec<LocalDefId, AstOwner<'a>>,\n+    pub(super) owners: &'a mut IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n }\n \n /// When we have a ty alias we *may* have two where clauses. To give the best diagnostics, we set the span\n@@ -45,130 +52,140 @@ fn add_ty_alias_where_clause(\n     }\n }\n \n-impl ItemLowerer<'_, '_, '_> {\n-    fn with_trait_impl_ref<T>(\n+impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n+    fn with_lctx(\n         &mut self,\n-        impl_ref: &Option<TraitRef>,\n-        f: impl FnOnce(&mut Self) -> T,\n-    ) -> T {\n-        let old = self.lctx.is_in_trait_impl;\n-        self.lctx.is_in_trait_impl = impl_ref.is_some();\n-        let ret = f(self);\n-        self.lctx.is_in_trait_impl = old;\n-        ret\n-    }\n-}\n-\n-impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n-    fn visit_attribute(&mut self, _: &'a Attribute) {\n-        // We do not want to lower expressions that appear in attributes,\n-        // as they are not accessible to the rest of the HIR.\n-    }\n+        owner: NodeId,\n+        f: impl FnOnce(&mut LoweringContext<'_, 'hir>) -> hir::OwnerNode<'hir>,\n+    ) {\n+        let mut lctx = LoweringContext {\n+            // Pseudo-globals.\n+            sess: &self.sess,\n+            resolver: self.resolver,\n+            nt_to_tokenstream: self.nt_to_tokenstream,\n+            arena: self.arena,\n+\n+            // HirId handling.\n+            bodies: Vec::new(),\n+            attrs: SortedMap::default(),\n+            children: FxHashMap::default(),\n+            current_hir_id_owner: CRATE_DEF_ID,\n+            item_local_id_counter: hir::ItemLocalId::new(0),\n+            node_id_to_local_id: Default::default(),\n+            local_id_to_def_id: SortedMap::new(),\n+            trait_map: Default::default(),\n+\n+            // Lowering state.\n+            catch_scope: None,\n+            loop_scope: None,\n+            is_in_loop_condition: false,\n+            is_in_trait_impl: false,\n+            is_in_dyn_type: false,\n+            anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n+            generator_kind: None,\n+            task_context: None,\n+            current_item: None,\n+            lifetimes_to_define: Vec::new(),\n+            is_collecting_anonymous_lifetimes: None,\n+            in_scope_lifetimes: Vec::new(),\n+            allow_try_trait: Some([sym::try_trait_v2][..].into()),\n+            allow_gen_future: Some([sym::gen_future][..].into()),\n+            allow_into_future: Some([sym::into_future][..].into()),\n+        };\n+        lctx.with_hir_id_owner(owner, |lctx| f(lctx));\n \n-    fn visit_item(&mut self, item: &'a Item) {\n-        let hir_id = self.lctx.with_hir_id_owner(item.id, |lctx| {\n-            let node = lctx.without_in_scope_lifetime_defs(|lctx| lctx.lower_item(item));\n-            hir::OwnerNode::Item(node)\n-        });\n-\n-        self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n-            let this = &mut ItemLowerer { lctx: this };\n-            match item.kind {\n-                ItemKind::Impl(box Impl { ref of_trait, .. }) => {\n-                    this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n-                }\n-                _ => visit::walk_item(this, item),\n-            }\n-        });\n+        for (def_id, info) in lctx.children {\n+            self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+            debug_assert!(matches!(self.owners[def_id], hir::MaybeOwner::Phantom));\n+            self.owners[def_id] = info;\n+        }\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'a>, sp: Span, _: NodeId) {\n-        match fk {\n-            FnKind::Fn(FnCtxt::Foreign, _, sig, _, _) => {\n-                self.visit_fn_header(&sig.header);\n-                visit::walk_fn_decl(self, &sig.decl);\n-                // Don't visit the foreign function body even if it has one, since lowering the\n-                // body would have no meaning and will have already been caught as a parse error.\n+    pub(super) fn lower_node(\n+        &mut self,\n+        def_id: LocalDefId,\n+    ) -> hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>> {\n+        self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+        if let hir::MaybeOwner::Phantom = self.owners[def_id] {\n+            let node = self.ast_index[def_id];\n+            match node {\n+                AstOwner::NonOwner => {}\n+                AstOwner::Crate(c) => self.lower_crate(c),\n+                AstOwner::Item(item) => self.lower_item(item),\n+                AstOwner::AssocItem(item, ctxt) => self.lower_assoc_item(item, ctxt),\n+                AstOwner::ForeignItem(item) => self.lower_foreign_item(item),\n             }\n-            _ => visit::walk_fn(self, fk, sp),\n         }\n-    }\n-\n-    fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n-        debug!(in_scope_lifetimes = ?self.lctx.in_scope_lifetimes);\n-        self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n-            AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n-            AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n-        });\n \n-        visit::walk_assoc_item(self, item, ctxt);\n+        self.owners[def_id]\n     }\n \n-    fn visit_foreign_item(&mut self, item: &'a ForeignItem) {\n-        self.lctx.with_hir_id_owner(item.id, |lctx| {\n-            hir::OwnerNode::ForeignItem(lctx.lower_foreign_item(item))\n-        });\n+    fn lower_crate(&mut self, c: &Crate) {\n+        debug_assert_eq!(self.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n \n-        visit::walk_foreign_item(self, item);\n+        self.with_lctx(CRATE_NODE_ID, |lctx| {\n+            let module = lctx.lower_mod(&c.items, c.spans.inner_span);\n+            lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n+            hir::OwnerNode::Crate(lctx.arena.alloc(module))\n+        })\n     }\n-}\n \n-impl<'hir> LoweringContext<'_, 'hir> {\n-    // Same as the method above, but accepts `hir::GenericParam`s\n-    // instead of `ast::GenericParam`s.\n-    // This should only be used with generics that have already had their\n-    // in-band lifetimes added. In practice, this means that this function is\n-    // only used when lowering a child item of a trait or impl.\n-    #[tracing::instrument(level = \"debug\", skip(self, f))]\n-    fn with_parent_item_lifetime_defs<T>(\n-        &mut self,\n-        parent_hir_id: LocalDefId,\n-        f: impl FnOnce(&mut Self) -> T,\n-    ) -> T {\n-        let parent_generics = match self.owners[parent_hir_id].unwrap().node().expect_item().kind {\n-            hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n-            | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n-            _ => &[],\n-        };\n-        let lt_def_names = parent_generics\n-            .iter()\n-            .filter_map(|param| match param.kind {\n-                hir::GenericParamKind::Lifetime { .. } => {\n-                    Some(param.name.normalize_to_macros_2_0())\n-                }\n-                _ => None,\n-            })\n-            .collect();\n-        let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, lt_def_names);\n-        debug!(in_scope_lifetimes = ?self.in_scope_lifetimes);\n-\n-        let res = f(self);\n-\n-        self.in_scope_lifetimes = old_in_scope_lifetimes;\n-        res\n+    fn lower_item(&mut self, item: &Item) {\n+        self.with_lctx(item.id, |lctx| hir::OwnerNode::Item(lctx.lower_item(item)))\n     }\n \n-    // Clears (and restores) the `in_scope_lifetimes` field. Used when\n-    // visiting nested items, which never inherit in-scope lifetimes\n-    // from their surrounding environment.\n-    #[tracing::instrument(level = \"debug\", skip(self, f))]\n-    fn without_in_scope_lifetime_defs<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, vec![]);\n-        debug!(?old_in_scope_lifetimes);\n+    fn lower_assoc_item(&mut self, item: &AssocItem, ctxt: AssocCtxt) {\n+        let def_id = self.resolver.local_def_id(item.id);\n \n-        // this vector is only used when walking over impl headers,\n-        // input types, and the like, and should not be non-empty in\n-        // between items\n-        assert!(self.lifetimes_to_define.is_empty());\n+        let parent_id = {\n+            let parent = self.resolver.definitions().def_key(def_id).parent;\n+            let local_def_index = parent.unwrap();\n+            LocalDefId { local_def_index }\n+        };\n \n-        let res = f(self);\n+        let parent_hir = self.lower_node(parent_id).unwrap().node().expect_item();\n+        self.with_lctx(item.id, |lctx| {\n+            // Evaluate with the lifetimes in `params` in-scope.\n+            // This is used to track which lifetimes have already been defined,\n+            // and which need to be replicated when lowering an async fn.\n+            match parent_hir.kind {\n+                hir::ItemKind::Impl(hir::Impl { ref of_trait, ref generics, .. }) => {\n+                    lctx.is_in_trait_impl = of_trait.is_some();\n+                    lctx.in_scope_lifetimes = generics\n+                        .params\n+                        .iter()\n+                        .filter(|param| {\n+                            matches!(param.kind, hir::GenericParamKind::Lifetime { .. })\n+                        })\n+                        .map(|param| param.name)\n+                        .collect();\n+                }\n+                hir::ItemKind::Trait(_, _, ref generics, ..) => {\n+                    lctx.in_scope_lifetimes = generics\n+                        .params\n+                        .iter()\n+                        .filter(|param| {\n+                            matches!(param.kind, hir::GenericParamKind::Lifetime { .. })\n+                        })\n+                        .map(|param| param.name)\n+                        .collect();\n+                }\n+                _ => {}\n+            };\n \n-        assert!(self.in_scope_lifetimes.is_empty());\n-        self.in_scope_lifetimes = old_in_scope_lifetimes;\n+            match ctxt {\n+                AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n+                AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n+            }\n+        })\n+    }\n \n-        res\n+    fn lower_foreign_item(&mut self, item: &ForeignItem) {\n+        self.with_lctx(item.id, |lctx| hir::OwnerNode::ForeignItem(lctx.lower_foreign_item(item)))\n     }\n+}\n \n+impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_mod(&mut self, items: &[P<Item>], inner: Span) -> hir::Mod<'hir> {\n         hir::Mod {\n             inner: self.lower_span(inner),\n@@ -548,12 +565,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let new_id = self.resolver.local_def_id(new_node_id);\n                     let Some(res) = resolutions.next() else {\n                         // Associate an HirId to both ids even if there is no resolution.\n-                        self.owners.ensure_contains_elem(new_id, || hir::MaybeOwner::Phantom);\n-                        let _old = std::mem::replace(\n-                            &mut self.owners[new_id],\n+                        let _old = self.children.insert(\n+                            new_id,\n                             hir::MaybeOwner::NonOwner(hir::HirId::make_owner(new_id)),\n                         );\n-                        debug_assert!(matches!(_old, hir::MaybeOwner::Phantom));\n+                        debug_assert!(_old.is_none());\n                         continue;\n                     };\n                     let ident = *ident;"}, {"sha": "e4ed48d4b530d673e0adca9c5038c4bcc67fa112", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 110, "deletions": 93, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/bd1a8692f6260fd59dba1e0fa187092a1c354b2e/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1a8692f6260fd59dba1e0fa187092a1c354b2e/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=bd1a8692f6260fd59dba1e0fa187092a1c354b2e", "patch": "@@ -57,7 +57,6 @@ use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::lint::LintBuffer;\n use rustc_session::parse::feature_err;\n use rustc_session::utils::{FlattenNonterminals, NtToTokenstream};\n use rustc_session::Session;\n@@ -100,12 +99,12 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// Used to allocate HIR nodes.\n     arena: &'hir Arena<'hir>,\n \n-    /// The items being lowered are collected here.\n-    owners: IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n     /// Bodies inside the owner being lowered.\n     bodies: Vec<(hir::ItemLocalId, &'hir hir::Body<'hir>)>,\n     /// Attributes inside the owner being lowered.\n     attrs: SortedMap<hir::ItemLocalId, &'hir [Attribute]>,\n+    /// Collect items that were created by lowering the current owner.\n+    children: FxHashMap<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n@@ -159,7 +158,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n }\n \n pub trait ResolverAstLowering {\n-    fn def_key(&mut self, id: DefId) -> DefKey;\n+    fn def_key(&self, id: DefId) -> DefKey;\n \n     fn def_span(&self, id: LocalDefId) -> Span;\n \n@@ -171,18 +170,14 @@ pub trait ResolverAstLowering {\n     fn get_partial_res(&self, id: NodeId) -> Option<PartialRes>;\n \n     /// Obtains per-namespace resolutions for `use` statement with the given `NodeId`.\n-    fn get_import_res(&mut self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n+    fn get_import_res(&self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n \n     /// Obtains resolution for a label with the given `NodeId`.\n-    fn get_label_res(&mut self, id: NodeId) -> Option<NodeId>;\n-\n-    /// We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n-    /// This should only return `None` during testing.\n-    fn definitions(&mut self) -> &mut Definitions;\n+    fn get_label_res(&self, id: NodeId) -> Option<NodeId>;\n \n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_>;\n \n-    fn lint_buffer(&mut self) -> &mut LintBuffer;\n+    fn definitions(&self) -> &Definitions;\n \n     fn next_node_id(&mut self) -> NodeId;\n \n@@ -337,6 +332,81 @@ impl FnDeclKind {\n     }\n }\n \n+#[derive(Copy, Clone)]\n+enum AstOwner<'a> {\n+    NonOwner,\n+    Crate(&'a ast::Crate),\n+    Item(&'a ast::Item),\n+    AssocItem(&'a ast::AssocItem, visit::AssocCtxt),\n+    ForeignItem(&'a ast::ForeignItem),\n+}\n+\n+fn index_crate<'a>(\n+    resolver: &dyn ResolverAstLowering,\n+    krate: &'a Crate,\n+) -> IndexVec<LocalDefId, AstOwner<'a>> {\n+    let mut indexer = Indexer { resolver, index: IndexVec::new() };\n+    indexer.index.ensure_contains_elem(CRATE_DEF_ID, || AstOwner::NonOwner);\n+    indexer.index[CRATE_DEF_ID] = AstOwner::Crate(krate);\n+    visit::walk_crate(&mut indexer, krate);\n+    return indexer.index;\n+\n+    struct Indexer<'s, 'a> {\n+        resolver: &'s dyn ResolverAstLowering,\n+        index: IndexVec<LocalDefId, AstOwner<'a>>,\n+    }\n+\n+    impl<'a> visit::Visitor<'a> for Indexer<'_, 'a> {\n+        fn visit_attribute(&mut self, _: &'a Attribute) {\n+            // We do not want to lower expressions that appear in attributes,\n+            // as they are not accessible to the rest of the HIR.\n+        }\n+\n+        fn visit_item(&mut self, item: &'a ast::Item) {\n+            let def_id = self.resolver.local_def_id(item.id);\n+            self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n+            self.index[def_id] = AstOwner::Item(item);\n+            visit::walk_item(self, item)\n+        }\n+\n+        fn visit_assoc_item(&mut self, item: &'a ast::AssocItem, ctxt: visit::AssocCtxt) {\n+            let def_id = self.resolver.local_def_id(item.id);\n+            self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n+            self.index[def_id] = AstOwner::AssocItem(item, ctxt);\n+            visit::walk_assoc_item(self, item, ctxt);\n+        }\n+\n+        fn visit_foreign_item(&mut self, item: &'a ast::ForeignItem) {\n+            let def_id = self.resolver.local_def_id(item.id);\n+            self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n+            self.index[def_id] = AstOwner::ForeignItem(item);\n+            visit::walk_foreign_item(self, item);\n+        }\n+    }\n+}\n+\n+/// Compute the hash for the HIR of the full crate.\n+/// This hash will then be part of the crate_hash which is stored in the metadata.\n+fn compute_hir_hash(\n+    resolver: &mut dyn ResolverAstLowering,\n+    owners: &IndexVec<LocalDefId, hir::MaybeOwner<&hir::OwnerInfo<'_>>>,\n+) -> Fingerprint {\n+    let mut hir_body_nodes: Vec<_> = owners\n+        .iter_enumerated()\n+        .filter_map(|(def_id, info)| {\n+            let info = info.as_owner()?;\n+            let def_path_hash = resolver.definitions().def_path_hash(def_id);\n+            Some((def_path_hash, info))\n+        })\n+        .collect();\n+    hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n+\n+    let mut stable_hasher = StableHasher::new();\n+    let mut hcx = resolver.create_stable_hashing_context();\n+    hir_body_nodes.hash_stable(&mut hcx, &mut stable_hasher);\n+    stable_hasher.finish()\n+}\n+\n pub fn lower_crate<'a, 'hir>(\n     sess: &'a Session,\n     krate: &'a Crate,\n@@ -346,38 +416,26 @@ pub fn lower_crate<'a, 'hir>(\n ) -> &'hir hir::Crate<'hir> {\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n-    let owners =\n+    let ast_index = index_crate(resolver, krate);\n+\n+    let mut owners =\n         IndexVec::from_fn_n(|_| hir::MaybeOwner::Phantom, resolver.definitions().def_index_count());\n-    LoweringContext {\n-        sess,\n-        resolver,\n-        nt_to_tokenstream,\n-        arena,\n-        owners,\n-        bodies: Vec::new(),\n-        attrs: SortedMap::new(),\n-        catch_scope: None,\n-        loop_scope: None,\n-        is_in_loop_condition: false,\n-        is_in_trait_impl: false,\n-        is_in_dyn_type: false,\n-        anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n-        current_hir_id_owner: CRATE_DEF_ID,\n-        item_local_id_counter: hir::ItemLocalId::new(0),\n-        node_id_to_local_id: FxHashMap::default(),\n-        local_id_to_def_id: SortedMap::new(),\n-        trait_map: FxHashMap::default(),\n-        generator_kind: None,\n-        task_context: None,\n-        current_item: None,\n-        lifetimes_to_define: Vec::new(),\n-        is_collecting_anonymous_lifetimes: None,\n-        in_scope_lifetimes: Vec::new(),\n-        allow_try_trait: Some([sym::try_trait_v2][..].into()),\n-        allow_gen_future: Some([sym::gen_future][..].into()),\n-        allow_into_future: Some([sym::into_future][..].into()),\n-    }\n-    .lower_crate(krate)\n+\n+    for def_id in ast_index.indices() {\n+        item::ItemLowerer {\n+            sess,\n+            resolver,\n+            nt_to_tokenstream,\n+            arena,\n+            ast_index: &ast_index,\n+            owners: &mut owners,\n+        }\n+        .lower_node(def_id);\n+    }\n+\n+    let hir_hash = compute_hir_hash(resolver, &owners);\n+    let krate = hir::Crate { owners, hir_hash };\n+    arena.alloc(krate)\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -446,49 +504,11 @@ enum AnonymousLifetimeMode {\n }\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    fn lower_crate(mut self, c: &Crate) -> &'hir hir::Crate<'hir> {\n-        debug_assert_eq!(self.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n-\n-        visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n-\n-        self.with_hir_id_owner(CRATE_NODE_ID, |lctx| {\n-            let module = lctx.lower_mod(&c.items, c.spans.inner_span);\n-            lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n-            hir::OwnerNode::Crate(lctx.arena.alloc(module))\n-        });\n-\n-        let hir_hash = self.compute_hir_hash();\n-\n-        let krate = hir::Crate { owners: self.owners, hir_hash };\n-        self.arena.alloc(krate)\n-    }\n-\n-    /// Compute the hash for the HIR of the full crate.\n-    /// This hash will then be part of the crate_hash which is stored in the metadata.\n-    fn compute_hir_hash(&mut self) -> Fingerprint {\n-        let definitions = self.resolver.definitions();\n-        let mut hir_body_nodes: Vec<_> = self\n-            .owners\n-            .iter_enumerated()\n-            .filter_map(|(def_id, info)| {\n-                let info = info.as_owner()?;\n-                let def_path_hash = definitions.def_path_hash(def_id);\n-                Some((def_path_hash, info))\n-            })\n-            .collect();\n-        hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n-\n-        let mut stable_hasher = StableHasher::new();\n-        let mut hcx = self.resolver.create_stable_hashing_context();\n-        hir_body_nodes.hash_stable(&mut hcx, &mut stable_hasher);\n-        stable_hasher.finish()\n-    }\n-\n     fn with_hir_id_owner(\n         &mut self,\n         owner: NodeId,\n         f: impl FnOnce(&mut Self) -> hir::OwnerNode<'hir>,\n-    ) -> LocalDefId {\n+    ) {\n         let def_id = self.resolver.local_def_id(owner);\n \n         let current_attrs = std::mem::take(&mut self.attrs);\n@@ -516,15 +536,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.current_hir_id_owner = current_owner;\n         self.item_local_id_counter = current_local_counter;\n \n-        self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n-        self.owners[def_id] = hir::MaybeOwner::Owner(self.arena.alloc(info));\n-\n-        def_id\n+        let _old = self.children.insert(def_id, hir::MaybeOwner::Owner(info));\n+        debug_assert!(_old.is_none())\n     }\n \n-    fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> hir::OwnerInfo<'hir> {\n+    fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> &'hir hir::OwnerInfo<'hir> {\n         let attrs = std::mem::take(&mut self.attrs);\n         let mut bodies = std::mem::take(&mut self.bodies);\n+        let local_id_to_def_id = std::mem::take(&mut self.local_id_to_def_id);\n+        let trait_map = std::mem::take(&mut self.trait_map);\n \n         #[cfg(debug_assertions)]\n         for (id, attrs) in attrs.iter() {\n@@ -544,7 +564,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hash_without_bodies,\n             nodes,\n             bodies,\n-            local_id_to_def_id: std::mem::take(&mut self.local_id_to_def_id),\n+            local_id_to_def_id,\n         };\n         let attrs = {\n             let mut hcx = self.resolver.create_stable_hashing_context();\n@@ -554,7 +574,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir::AttributeMap { map: attrs, hash }\n         };\n \n-        hir::OwnerInfo { nodes, parenting, attrs, trait_map: std::mem::take(&mut self.trait_map) }\n+        self.arena.alloc(hir::OwnerInfo { nodes, parenting, attrs, trait_map })\n     }\n \n     /// Hash the HIR node twice, one deep and one shallow hash.  This allows to differentiate\n@@ -602,11 +622,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 assert_ne!(local_id, hir::ItemLocalId::new(0));\n                 if let Some(def_id) = self.resolver.opt_local_def_id(ast_node_id) {\n-                    self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n-                    if let o @ hir::MaybeOwner::Phantom = &mut self.owners[def_id] {\n-                        // Do not override a `MaybeOwner::Owner` that may already here.\n-                        *o = hir::MaybeOwner::NonOwner(hir_id);\n-                    }\n+                    // Do not override a `MaybeOwner::Owner` that may already here.\n+                    self.children.entry(def_id).or_insert(hir::MaybeOwner::NonOwner(hir_id));\n                     self.local_id_to_def_id.insert(local_id, def_id);\n                 }\n "}, {"sha": "c62d3b9be2fcc327aea251ee4c89b39188e43ca3", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd1a8692f6260fd59dba1e0fa187092a1c354b2e/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1a8692f6260fd59dba1e0fa187092a1c354b2e/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=bd1a8692f6260fd59dba1e0fa187092a1c354b2e", "patch": "@@ -99,6 +99,7 @@ impl DefPathTable {\n #[derive(Clone, Debug)]\n pub struct Definitions {\n     table: DefPathTable,\n+    next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n \n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     expansions_that_defined: FxHashMap<LocalDefId, ExpnId>,\n@@ -340,6 +341,7 @@ impl Definitions {\n \n         Definitions {\n             table,\n+            next_disambiguator: Default::default(),\n             expansions_that_defined: Default::default(),\n             def_id_to_span,\n             stable_crate_id,\n@@ -357,15 +359,20 @@ impl Definitions {\n         parent: LocalDefId,\n         data: DefPathData,\n         expn_id: ExpnId,\n-        mut next_disambiguator: impl FnMut(LocalDefId, DefPathData) -> u32,\n         span: Span,\n     ) -> LocalDefId {\n         debug!(\"create_def(parent={:?}, data={:?}, expn_id={:?})\", parent, data, expn_id);\n \n         // The root node must be created with `create_root_def()`.\n         assert!(data != DefPathData::CrateRoot);\n \n-        let disambiguator = next_disambiguator(parent, data);\n+        // Find the next free disambiguator for this key.\n+        let disambiguator = {\n+            let next_disamb = self.next_disambiguator.entry((parent, data)).or_insert(0);\n+            let disambiguator = *next_disamb;\n+            *next_disamb = next_disamb.checked_add(1).expect(\"disambiguator overflow\");\n+            disambiguator\n+        };\n         let key = DefKey {\n             parent: Some(parent.local_def_index),\n             disambiguated_data: DisambiguatedDefPathData { data, disambiguator },"}, {"sha": "f2164bccc3e9b1855ac6a3eb24120f75755ad893", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bd1a8692f6260fd59dba1e0fa187092a1c354b2e/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1a8692f6260fd59dba1e0fa187092a1c354b2e/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=bd1a8692f6260fd59dba1e0fa187092a1c354b2e", "patch": "@@ -487,12 +487,24 @@ pub fn configure_and_expand(\n         }\n     });\n \n+    sess.time(\"early_lint_checks\", || {\n+        let lint_buffer = Some(std::mem::take(resolver.lint_buffer()));\n+        rustc_lint::check_ast_node(\n+            sess,\n+            false,\n+            lint_store,\n+            resolver.registered_tools(),\n+            lint_buffer,\n+            rustc_lint::BuiltinCombinedEarlyLintPass::new(),\n+            &krate,\n+        )\n+    });\n+\n     Ok(krate)\n }\n \n pub fn lower_to_hir<'res, 'tcx>(\n     sess: &'tcx Session,\n-    lint_store: &LintStore,\n     resolver: &'res mut Resolver<'_>,\n     krate: Rc<ast::Crate>,\n     arena: &'tcx rustc_ast_lowering::Arena<'tcx>,\n@@ -506,19 +518,6 @@ pub fn lower_to_hir<'res, 'tcx>(\n         arena,\n     );\n \n-    sess.time(\"early_lint_checks\", || {\n-        let lint_buffer = Some(std::mem::take(resolver.lint_buffer()));\n-        rustc_lint::check_ast_node(\n-            sess,\n-            false,\n-            lint_store,\n-            resolver.registered_tools(),\n-            lint_buffer,\n-            rustc_lint::BuiltinCombinedEarlyLintPass::new(),\n-            &*krate,\n-        )\n-    });\n-\n     // Drop AST to free memory\n     sess.time(\"drop_ast\", || std::mem::drop(krate));\n \n@@ -852,9 +851,8 @@ pub fn create_global_ctxt<'tcx>(\n     dep_graph.assert_ignored();\n \n     let sess = &compiler.session();\n-    let krate = resolver\n-        .borrow_mut()\n-        .access(|resolver| lower_to_hir(sess, &lint_store, resolver, krate, hir_arena));\n+    let krate =\n+        resolver.borrow_mut().access(|resolver| lower_to_hir(sess, resolver, krate, hir_arena));\n     let resolver_outputs = BoxedResolver::to_resolver_outputs(resolver);\n \n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);"}, {"sha": "1f0a6e5ce9716263b3b7e67d9256b8a0b89030fd", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bd1a8692f6260fd59dba1e0fa187092a1c354b2e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1a8692f6260fd59dba1e0fa187092a1c354b2e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=bd1a8692f6260fd59dba1e0fa187092a1c354b2e", "patch": "@@ -1061,7 +1061,6 @@ pub struct Resolver<'a> {\n     /// and how the `impl Trait` fragments were introduced.\n     invocation_parents: FxHashMap<LocalExpnId, (LocalDefId, ImplTraitContext)>,\n \n-    next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n     /// Some way to know that we are in a *trait* impl in `visit_assoc_item`.\n     /// FIXME: Replace with a more general AST map (together with some other fields).\n     trait_impl_items: FxHashSet<LocalDefId>,\n@@ -1160,9 +1159,9 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n impl ResolverAstLowering for Resolver<'_> {\n-    fn def_key(&mut self, id: DefId) -> DefKey {\n+    fn def_key(&self, id: DefId) -> DefKey {\n         if let Some(id) = id.as_local() {\n-            self.definitions().def_key(id)\n+            self.definitions.def_key(id)\n         } else {\n             self.cstore().def_key(id)\n         }\n@@ -1189,24 +1188,20 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.partial_res_map.get(&id).cloned()\n     }\n \n-    fn get_import_res(&mut self, id: NodeId) -> PerNS<Option<Res>> {\n+    fn get_import_res(&self, id: NodeId) -> PerNS<Option<Res>> {\n         self.import_res_map.get(&id).cloned().unwrap_or_default()\n     }\n \n-    fn get_label_res(&mut self, id: NodeId) -> Option<NodeId> {\n+    fn get_label_res(&self, id: NodeId) -> Option<NodeId> {\n         self.label_res_map.get(&id).cloned()\n     }\n \n-    fn definitions(&mut self) -> &mut Definitions {\n-        &mut self.definitions\n-    }\n-\n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n         StableHashingContext::new(self.session, &self.definitions, self.crate_loader.cstore())\n     }\n \n-    fn lint_buffer(&mut self) -> &mut LintBuffer {\n-        &mut self.lint_buffer\n+    fn definitions(&self) -> &Definitions {\n+        &self.definitions\n     }\n \n     fn next_node_id(&mut self) -> NodeId {\n@@ -1249,16 +1244,7 @@ impl ResolverAstLowering for Resolver<'_> {\n             self.definitions.def_key(self.node_id_to_def_id[&node_id]),\n         );\n \n-        // Find the next free disambiguator for this key.\n-        let next_disambiguator = &mut self.next_disambiguator;\n-        let next_disambiguator = |parent, data| {\n-            let next_disamb = next_disambiguator.entry((parent, data)).or_insert(0);\n-            let disambiguator = *next_disamb;\n-            *next_disamb = next_disamb.checked_add(1).expect(\"disambiguator overflow\");\n-            disambiguator\n-        };\n-\n-        let def_id = self.definitions.create_def(parent, data, expn_id, next_disambiguator, span);\n+        let def_id = self.definitions.create_def(parent, data, expn_id, span);\n \n         // Some things for which we allocate `LocalDefId`s don't correspond to\n         // anything in the AST, so they don't have a `NodeId`. For these cases\n@@ -1430,7 +1416,6 @@ impl<'a> Resolver<'a> {\n             def_id_to_node_id,\n             placeholder_field_indices: Default::default(),\n             invocation_parents,\n-            next_disambiguator: Default::default(),\n             trait_impl_items: Default::default(),\n             legacy_const_generic_args: Default::default(),\n             item_generics_num_lifetimes: Default::default(),"}]}