{"sha": "39e8cb6df32afcba3de9a146192046400754d4ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZThjYjZkZjMyYWZjYmEzZGU5YTE0NjE5MjA0NjQwMDc1NGQ0ZWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-24T01:40:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-24T06:38:04Z"}, "message": "Don't copy metadata after loading", "tree": {"sha": "55be8424ab86137e7aa2c49d619068737bec02b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55be8424ab86137e7aa2c49d619068737bec02b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39e8cb6df32afcba3de9a146192046400754d4ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39e8cb6df32afcba3de9a146192046400754d4ea", "html_url": "https://github.com/rust-lang/rust/commit/39e8cb6df32afcba3de9a146192046400754d4ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39e8cb6df32afcba3de9a146192046400754d4ea/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "041d8e899f5eecd435844ce5ad86dd2aadea3a46", "url": "https://api.github.com/repos/rust-lang/rust/commits/041d8e899f5eecd435844ce5ad86dd2aadea3a46", "html_url": "https://github.com/rust-lang/rust/commit/041d8e899f5eecd435844ce5ad86dd2aadea3a46"}], "stats": {"total": 215, "additions": 132, "deletions": 83}, "files": [{"sha": "560bcccae8056acd535a52a52913a0b8cc6d48b4", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=39e8cb6df32afcba3de9a146192046400754d4ea", "patch": "@@ -12,6 +12,8 @@\n \n \n use std::str;\n+use std::cast;\n+use std::vec;\n \n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n@@ -29,9 +31,42 @@ struct EbmlState {\n     data_pos: uint,\n }\n \n+#[deriving(Clone)]\n+pub enum EbmlData {\n+    SafeData(@~[u8]),\n+    UnsafeData(*u8, uint)\n+}\n+\n+impl EbmlData {\n+    #[inline]\n+    pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [u8] {\n+        match *self {\n+            SafeData(@ref v) => v.slice(start, end),\n+            UnsafeData(buf, len) => unsafe {\n+                do vec::raw::buf_as_slice(buf, len) |s| {\n+                    cast::transmute(s.slice(start, end))\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+        self.slice(0, self.len())\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> uint {\n+        match *self {\n+            SafeData(@ref v) => v.len(),\n+            UnsafeData(_, len) => len\n+        }\n+    }\n+}\n+\n #[deriving(Clone)]\n pub struct Doc {\n-    data: @~[u8],\n+    data: EbmlData,\n     start: uint,\n     end: uint,\n }\n@@ -185,24 +220,28 @@ pub mod reader {\n     }\n \n     pub fn Doc(data: @~[u8]) -> Doc {\n-        Doc { data: data, start: 0u, end: data.len() }\n+        Doc { data: SafeData(data), start: 0u, end: data.len() }\n+    }\n+\n+    pub fn unsafe_Doc(buf: *u8, len: uint) -> Doc {\n+        Doc { data: UnsafeData(buf, len), start: 0u, end: len }\n     }\n \n-    pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n-        let elt_tag = vuint_at(*data, start);\n-        let elt_size = vuint_at(*data, elt_tag.next);\n+    pub fn doc_at(data: &EbmlData, start: uint) -> TaggedDoc {\n+        let elt_tag = vuint_at(data.as_slice(), start);\n+        let elt_size = vuint_at(data.as_slice(), elt_tag.next);\n         let end = elt_size.next + elt_size.val;\n         TaggedDoc {\n             tag: elt_tag.val,\n-            doc: Doc { data: data, start: elt_size.next, end: end }\n+            doc: Doc { data: data.clone(), start: elt_size.next, end: end }\n         }\n     }\n \n     pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(*d.data, pos);\n-            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            let elt_tag = vuint_at(d.data.as_slice(), pos);\n+            let elt_size = vuint_at(d.data.as_slice(), elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 return Some(Doc { data: d.data, start: elt_size.next,\n@@ -225,8 +264,8 @@ pub mod reader {\n     pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(*d.data, pos);\n-            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            let elt_tag = vuint_at(d.data.as_slice(), pos);\n+            let elt_size = vuint_at(d.data.as_slice(), elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n             if !it(elt_tag.val, doc) {\n@@ -239,8 +278,8 @@ pub mod reader {\n     pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(*d.data, pos);\n-            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            let elt_tag = vuint_at(d.data.as_slice(), pos);\n+            let elt_size = vuint_at(d.data.as_slice(), elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 let doc = Doc { data: d.data, start: elt_size.next,\n@@ -260,22 +299,22 @@ pub mod reader {\n \n     pub fn doc_as_u8(d: Doc) -> u8 {\n         assert_eq!(d.end, d.start + 1u);\n-        (*d.data)[d.start]\n+        d.data.as_slice()[d.start]\n     }\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n         assert_eq!(d.end, d.start + 2u);\n-        io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n+        io::u64_from_be_bytes(d.data.as_slice(), d.start, 2u) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n         assert_eq!(d.end, d.start + 4u);\n-        io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n+        io::u64_from_be_bytes(d.data.as_slice(), d.start, 4u) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n         assert_eq!(d.end, d.start + 8u);\n-        io::u64_from_be_bytes(*d.data, d.start, 8u)\n+        io::u64_from_be_bytes(d.data.as_slice(), d.start, 8u)\n     }\n \n     pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n@@ -298,8 +337,7 @@ pub mod reader {\n     impl Decoder {\n         fn _check_label(&mut self, lbl: &str) {\n             if self.pos < self.parent.end {\n-                let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                    doc_at(self.parent.data, self.pos);\n+                let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(&self.parent.data, self.pos);\n \n                 if r_tag == (EsLabel as uint) {\n                     self.pos = r_doc.end;\n@@ -316,8 +354,7 @@ pub mod reader {\n             if self.pos >= self.parent.end {\n                 fail!(\"no more documents in current node!\");\n             }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                doc_at(self.parent.data, self.pos);\n+            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(&self.parent.data, self.pos);\n             debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n                    self.parent.start,\n                    self.parent.end,"}, {"sha": "f43c089d331eb256299153bfba00c128a07890fb", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=39e8cb6df32afcba3de9a146192046400754d4ea", "patch": "@@ -15,6 +15,7 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::filesearch::FileSearch;\n use metadata::loader;\n+use metadata::loader::MetadataSection;\n \n use std::hashmap::HashMap;\n use syntax::ast;\n@@ -308,7 +309,7 @@ fn resolve_crate(e: @mut Env,\n }\n \n // Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n+fn resolve_crate_deps(e: @mut Env, cdata: MetadataSection) -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers"}, {"sha": "bc6b3d30d4325ff35096514cc86cadc2d7f25f34", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=39e8cb6df32afcba3de9a146192046400754d4ea", "patch": "@@ -188,7 +188,7 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                       def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n-    let all_items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n+    let all_items = reader::get_doc(decoder::section_to_ebml_doc(cdata.data), tag_items);\n     debug!(\"Looking up %?\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),"}, {"sha": "4150894e1d2b7b975adb22554cc29f80e665e814", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=39e8cb6df32afcba3de9a146192046400754d4ea", "patch": "@@ -15,6 +15,7 @@\n \n use metadata::cstore;\n use metadata::decoder;\n+use metadata::loader::MetadataSection;\n \n use std::hashmap::HashMap;\n use extra;\n@@ -29,7 +30,7 @@ pub type cnum_map = @mut HashMap<ast::CrateNum, ast::CrateNum>;\n \n pub struct crate_metadata {\n     name: @str,\n-    data: @~[u8],\n+    data: MetadataSection,\n     cnum_map: cnum_map,\n     cnum: ast::CrateNum\n }"}, {"sha": "47ec96ca97e2429add5fa9ef752b871e48d3b167", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=39e8cb6df32afcba3de9a146192046400754d4ea", "patch": "@@ -20,6 +20,7 @@ use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n+use metadata::loader::{MetadataSection, CopiedSection, UnsafeSection};\n use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n@@ -56,16 +57,16 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: u64) ->\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n-    let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n-    let tagged_doc = reader::doc_at(d.data, pos);\n+    let pos = io::u64_from_be_bytes(d.data.as_slice(), hash_pos, 4) as uint;\n+    let tagged_doc = reader::doc_at(&d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     do reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n-        let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n+        let pos = io::u64_from_be_bytes(elt.data.as_slice(), elt.start, 4) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n-            ret = Some(reader::doc_at(d.data, pos).doc);\n+            ret = Some(reader::doc_at(&d.data, pos).doc);\n             false\n         } else {\n             true\n@@ -96,8 +97,8 @@ fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n-    let items = reader::get_doc(reader::Doc(data), tag_items);\n+fn lookup_item(item_id: int, data: MetadataSection) -> ebml::Doc {\n+    let items = reader::get_doc(section_to_ebml_doc(data), tag_items);\n     find_item(item_id, items)\n }\n \n@@ -215,13 +216,13 @@ fn variant_disr_val(d: ebml::Doc) -> Option<uint> {\n \n fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n-    parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n+    parse_ty_data(tp.data.as_slice(), cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::BareFnTy {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n-    parse_bare_fn_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n+    parse_bare_fn_ty_data(tp.data.as_slice(), cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n@@ -230,7 +231,7 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n                            cdata: cmd) -> Option<ty::t>\n {\n     do reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map |tp| {\n-        parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n+        parse_ty_data(tp.data.as_slice(), cdata.cnum, tp.start, tcx,\n                       |_, did| translate_def_id(cdata, did))\n     }\n }\n@@ -241,7 +242,7 @@ pub fn item_type(_item_id: ast::def_id, item: ebml::Doc,\n }\n \n fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n-    parse_trait_ref_data(*doc.data, cdata.cnum, doc.start, tcx,\n+    parse_trait_ref_data(doc.data.as_slice(), cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n@@ -256,7 +257,7 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n     let mut bounds = ~[];\n     do reader::tagged_docs(item, tag) |p| {\n         let bd = parse_type_param_def_data(\n-            *p.data, p.start, cdata.cnum, tcx,\n+            p.data.as_slice(), p.start, cdata.cnum, tcx,\n             |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n         true\n@@ -359,7 +360,7 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::CrateNum)\n     }\n }\n \n-pub fn lookup_def(cnum: ast::CrateNum, data: @~[u8], did_: ast::def_id) ->\n+pub fn lookup_def(cnum: ast::CrateNum, data: MetadataSection, did_: ast::def_id) ->\n    ast::def {\n     let item = lookup_item(did_.node, data);\n     let did = ast::def_id { crate: cnum, node: did_.node };\n@@ -406,7 +407,7 @@ pub fn get_region_param(cdata: cmd, id: ast::NodeId)\n     return item_ty_region_param(item);\n }\n \n-pub fn get_type_param_count(data: @~[u8], id: ast::NodeId) -> uint {\n+pub fn get_type_param_count(data: MetadataSection, id: ast::NodeId) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n@@ -437,7 +438,7 @@ pub fn get_impl_vtables(cdata: cmd,\n \n pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n                        name: ast::ident) -> Option<ast::def_id> {\n-    let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n+    let items = reader::get_doc(section_to_ebml_doc(cdata.data), tag_items);\n     let mut found = None;\n     do reader::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n         let m_did = reader::with_doc_data(mid, parse_def_id);\n@@ -449,7 +450,7 @@ pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n     found\n }\n \n-pub fn get_symbol(data: @~[u8], id: ast::NodeId) -> ~str {\n+pub fn get_symbol(data: MetadataSection, id: ast::NodeId) -> ~str {\n     return item_symbol(lookup_item(id, data));\n }\n \n@@ -470,7 +471,7 @@ fn def_like_to_def(def_like: def_like) -> ast::def {\n \n /// Iterates over the language items in the given crate.\n pub fn each_lang_item(cdata: cmd, f: &fn(ast::NodeId, uint) -> bool) -> bool {\n-    let root = reader::Doc(cdata.data);\n+    let root = section_to_ebml_doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     do reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n@@ -565,10 +566,10 @@ impl<'self> EachItemContext<'self> {\n     fn each_item_of_module(&mut self, def_id: ast::def_id) -> bool {\n         // This item might not be in this crate. If it's not, look it up.\n         let items = if def_id.crate == self.cdata.cnum {\n-            reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n+            reader::get_doc(section_to_ebml_doc(self.cdata.data), tag_items)\n         } else {\n             let crate_data = (self.get_crate_data)(def_id.crate);\n-            let root = reader::Doc(crate_data.data);\n+            let root = section_to_ebml_doc(crate_data.data);\n             reader::get_doc(root, tag_items)\n         };\n \n@@ -594,10 +595,10 @@ impl<'self> EachItemContext<'self> {\n             // a reexport.\n             let other_crates_items = if child_def_id.crate ==\n                     self.cdata.cnum {\n-                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n+                reader::get_doc(section_to_ebml_doc(self.cdata.data), tag_items)\n             } else {\n                 let crate_data = (self.get_crate_data)(child_def_id.crate);\n-                let root = reader::Doc(crate_data.data);\n+                let root = section_to_ebml_doc(crate_data.data);\n                 reader::get_doc(root, tag_items)\n             };\n \n@@ -661,10 +662,10 @@ impl<'self> EachItemContext<'self> {\n \n             // This reexport may be in yet another crate.\n             let other_crates_items = if def_id.crate == self.cdata.cnum {\n-                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n+                reader::get_doc(section_to_ebml_doc(self.cdata.data), tag_items)\n             } else {\n                 let crate_data = (self.get_crate_data)(def_id.crate);\n-                let root = reader::Doc(crate_data.data);\n+                let root = section_to_ebml_doc(crate_data.data);\n                 reader::get_doc(root, tag_items)\n             };\n \n@@ -696,7 +697,7 @@ pub fn each_path(intr: @ident_interner,\n     // make fast. It's the source of most of the performance problems when\n     // compiling small crates.\n \n-    let root_doc = reader::Doc(cdata.data);\n+    let root_doc = section_to_ebml_doc(cdata.data);\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n                                           tag_misc_info_crate_items);\n@@ -756,7 +757,7 @@ pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n                      tcx: ty::ctxt) -> ~[@ty::VariantInfo] {\n     let data = cdata.data;\n-    let items = reader::get_doc(reader::Doc(data), tag_items);\n+    let items = reader::get_doc(section_to_ebml_doc(data), tag_items);\n     let item = find_item(id, items);\n     let mut infos: ~[@ty::VariantInfo] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n@@ -1188,8 +1189,15 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n     out.write_str(\"\\n\\n\");\n }\n \n-pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::Attribute] {\n-    return get_attributes(reader::Doc(data));\n+pub fn get_crate_attributes(data: MetadataSection) -> ~[ast::Attribute] {\n+    return get_attributes(section_to_ebml_doc(data));\n+}\n+\n+pub fn section_to_ebml_doc(data: MetadataSection) -> ebml::Doc {\n+    match data {\n+        CopiedSection(data) => reader::Doc(data),\n+        UnsafeSection(_, buf, len) => reader::unsafe_Doc(buf, len)\n+    }\n }\n \n #[deriving(Clone)]\n@@ -1200,9 +1208,9 @@ pub struct crate_dep {\n     hash: @str\n }\n \n-pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n+pub fn get_crate_deps(data: MetadataSection) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n-    let cratedoc = reader::Doc(data);\n+    let cratedoc = section_to_ebml_doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n     fn docstr(doc: ebml::Doc, tag_: uint) -> @str {\n@@ -1220,7 +1228,7 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     return deps;\n }\n \n-fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n+fn list_crate_deps(data: MetadataSection, out: @io::Writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n     let r = get_crate_deps(data);\n@@ -1233,13 +1241,13 @@ fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n     out.write_str(\"\\n\");\n }\n \n-pub fn get_crate_hash(data: @~[u8]) -> @str {\n-    let cratedoc = reader::Doc(data);\n+pub fn get_crate_hash(data: MetadataSection) -> @str {\n+    let cratedoc = section_to_ebml_doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n     hashdoc.as_str_slice().to_managed()\n }\n \n-pub fn get_crate_vers(data: @~[u8]) -> @str {\n+pub fn get_crate_vers(data: MetadataSection) -> @str {\n     let attrs = decoder::get_crate_attributes(data);\n     let linkage_attrs = attr::find_linkage_metas(attrs);\n \n@@ -1264,10 +1272,10 @@ fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n     };\n }\n \n-pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n+pub fn list_crate_metadata(intr: @ident_interner, bytes: MetadataSection,\n                            out: @io::Writer) {\n     let hash = get_crate_hash(bytes);\n-    let md = reader::Doc(bytes);\n+    let md = section_to_ebml_doc(bytes);\n     list_crate_attributes(intr, md, hash, out);\n     list_crate_deps(bytes, out);\n }\n@@ -1289,7 +1297,7 @@ pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n }\n \n pub fn get_link_args_for_crate(cdata: cmd) -> ~[~str] {\n-    let link_args = reader::get_doc(reader::Doc(cdata.data), tag_link_args);\n+    let link_args = reader::get_doc(section_to_ebml_doc(cdata.data), tag_link_args);\n     let mut result = ~[];\n     do reader::tagged_docs(link_args, tag_link_args_arg) |arg_doc| {\n         result.push(arg_doc.as_str());"}, {"sha": "5f73888bb7ddaf4df3dfec4b818d4d4020cadd85", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=39e8cb6df32afcba3de9a146192046400754d4ea", "patch": "@@ -11,7 +11,7 @@\n //! Finds crate binaries and loads their metadata\n \n \n-use lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n+use lib::llvm::{False, llvm, mk_object_file, mk_section_iter, ObjectFile};\n use metadata::decoder;\n use metadata::encoder;\n use metadata::filesearch::FileSearch;\n@@ -54,7 +54,13 @@ pub struct Context {\n     intr: @ident_interner\n }\n \n-pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n+#[deriving(Clone)]\n+pub enum MetadataSection {\n+    CopiedSection(@~[u8]),\n+    UnsafeSection(@ObjectFile, *u8, uint)\n+}\n+\n+pub fn load_library_crate(cx: &Context) -> (~str, MetadataSection) {\n     match find_library_crate(cx) {\n       Some(t) => t,\n       None => {\n@@ -65,7 +71,7 @@ pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n     }\n }\n \n-fn find_library_crate(cx: &Context) -> Option<(~str, @~[u8])> {\n+fn find_library_crate(cx: &Context) -> Option<(~str, MetadataSection)> {\n     attr::require_unique_names(cx.diag, cx.metas);\n     find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n@@ -87,7 +93,7 @@ fn find_library_crate_aux(\n     cx: &Context,\n     (prefix, suffix): (~str, ~str),\n     filesearch: @filesearch::FileSearch\n-) -> Option<(~str, @~[u8])> {\n+) -> Option<(~str, MetadataSection)> {\n     let crate_name = crate_name_from_metas(cx.metas);\n     // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n     let prefix = fmt!(\"%s%s-\", prefix, crate_name);\n@@ -171,7 +177,7 @@ pub fn note_linkage_attrs(intr: @ident_interner,\n     }\n }\n \n-fn crate_matches(crate_data: @~[u8],\n+fn crate_matches(crate_data: MetadataSection,\n                  metas: &[@ast::MetaItem],\n                  hash: @str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n@@ -197,17 +203,17 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n }\n \n fn get_metadata_section(os: os,\n-                        filename: &Path) -> Option<@~[u8]> {\n+                        filename: &Path) -> Option<MetadataSection> {\n     unsafe {\n         let mb = do filename.with_c_str |buf| {\n             llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n         };\n-        if mb as int == 0 { return option::None::<@~[u8]>; }\n-        let of = match mk_object_file(mb) {\n+        if mb as int == 0 { return None; }\n+        let of = @match mk_object_file(mb) {\n             option::Some(of) => of,\n-            _ => return option::None::<@~[u8]>\n+            _ => return None\n         };\n-        let si = mk_section_iter(of.llof);\n+        let si = mk_section_iter((*of).llof);\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let name_buf = llvm::LLVMGetSectionName(si.llsi);\n             let name = str::raw::from_c_str(name_buf);\n@@ -233,28 +239,24 @@ fn get_metadata_section(os: os,\n                 let must_decompress = *ptr::offset(cvbuf, vlen as int) == 1;\n                 let cvbuf1 = ptr::offset(cvbuf, vlen as int + 1);\n \n-                do vec::raw::buf_as_slice(cvbuf1, csz-vlen-1) |bytes| {\n-                    if must_decompress {\n+                if must_decompress {\n+                    do vec::raw::buf_as_slice(cvbuf1, csz-vlen-1) |bytes| {\n                         debug!(\"inflating %u bytes of compressed metadata\",\n                                csz - vlen);\n                         let inflated = flate::inflate_bytes(bytes);\n-                        found = Some(@(inflated));\n-                    } else {\n-                        // Copy the byte vector as fast as possible\n-                        let mut buf = vec::with_capacity(bytes.len());\n-                        vec::raw::set_len(&mut buf, bytes.len());\n-                        vec::raw::copy_memory(buf, bytes, bytes.len());\n-                        found = Some(@buf)\n+                        found = Some(CopiedSection(@inflated));\n                     }\n+                } else {\n+                    found = Some(UnsafeSection(of, cvbuf1, csz-vlen-1))\n                 }\n \n-                if found != None {\n+                if !found.is_none() {\n                     return found;\n                 }\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        return option::None::<@~[u8]>;\n+        return None;\n     }\n }\n "}, {"sha": "791be656d4bcb04de2413f41be269cc0a9710859", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e8cb6df32afcba3de9a146192046400754d4ea/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=39e8cb6df32afcba3de9a146192046400754d4ea", "patch": "@@ -1022,7 +1022,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                      tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n         do self.read_opaque |_, doc| {\n             tydecode::parse_ty_data(\n-                *doc.data,\n+                doc.data.as_slice(),\n                 cdata.cnum,\n                 doc.start,\n                 tcx,\n@@ -1044,7 +1044,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n \n         return do self.read_opaque |this, doc| {\n             let ty = tydecode::parse_ty_data(\n-                *doc.data,\n+                doc.data.as_slice(),\n                 xcx.dcx.cdata.cnum,\n                 doc.start,\n                 xcx.dcx.tcx,\n@@ -1060,7 +1060,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         fn type_string(doc: ebml::Doc) -> ~str {\n             let mut str = ~\"\";\n             for i in range(doc.start, doc.end) {\n-                str.push_char(doc.data[i] as char);\n+                str.push_char(doc.data.as_slice()[i] as char);\n             }\n             str\n         }\n@@ -1074,7 +1074,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                            -> ty::TypeParameterDef {\n         do self.read_opaque |this, doc| {\n             tydecode::parse_type_param_def_data(\n-                *doc.data,\n+                doc.data.as_slice(),\n                 doc.start,\n                 xcx.dcx.cdata.cnum,\n                 xcx.dcx.tcx,"}]}