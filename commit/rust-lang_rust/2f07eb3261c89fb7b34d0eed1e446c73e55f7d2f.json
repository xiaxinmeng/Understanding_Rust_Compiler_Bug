{"sha": "2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMDdlYjMyNjFjODlmYjdiMzRkMGVlZDFlNDQ2YzczZTU1ZjdkMmY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-12T15:37:58Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-13T11:28:16Z"}, "message": "trans: Internalize symbols at the trans-item level, without relying on LLVM.", "tree": {"sha": "46dd467523f3b4ada4d4b08e33181b72f95029b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46dd467523f3b4ada4d4b08e33181b72f95029b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "html_url": "https://github.com/rust-lang/rust/commit/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ebfab5104ba354d5d3283fd16e086d0a8549623", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ebfab5104ba354d5d3283fd16e086d0a8549623", "html_url": "https://github.com/rust-lang/rust/commit/1ebfab5104ba354d5d3283fd16e086d0a8549623"}], "stats": {"total": 648, "additions": 383, "deletions": 265}, "files": [{"sha": "a178695cba97e0c5670e43ac7daa2f40dd770a72", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "patch": "@@ -19,7 +19,7 @@ use std::process::Command;\n use context::SharedCrateContext;\n \n use back::archive;\n-use back::symbol_export::{self, ExportedSymbols};\n+use back::symbol_export::ExportedSymbols;\n use rustc::middle::dependency_format::Linkage;\n use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n use rustc_back::LinkerFlavor;\n@@ -687,10 +687,8 @@ fn exported_symbols(scx: &SharedCrateContext,\n                     exported_symbols: &ExportedSymbols,\n                     crate_type: CrateType)\n                     -> Vec<String> {\n-    let export_threshold = symbol_export::crate_export_threshold(crate_type);\n-\n     let mut symbols = Vec::new();\n-    exported_symbols.for_each_exported_symbol(LOCAL_CRATE, export_threshold, |name, _| {\n+    exported_symbols.for_each_exported_symbol(LOCAL_CRATE, |name, _, _| {\n         symbols.push(name.to_owned());\n     });\n \n@@ -702,7 +700,7 @@ fn exported_symbols(scx: &SharedCrateContext,\n         // For each dependency that we are linking to statically ...\n         if *dep_format == Linkage::Static {\n             // ... we add its symbol list to our export list.\n-            exported_symbols.for_each_exported_symbol(cnum, export_threshold, |name, _| {\n+            exported_symbols.for_each_exported_symbol(cnum, |name, _, _| {\n                 symbols.push(name.to_owned());\n             })\n         }"}, {"sha": "feed127b0b60b690d51df6b1ec2770812df31e14", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "patch": "@@ -66,7 +66,7 @@ pub fn run(cgcx: &CodegenContext,\n     let export_threshold =\n         symbol_export::crates_export_threshold(&cgcx.crate_types);\n \n-    let symbol_filter = &|&(ref name, level): &(String, _)| {\n+    let symbol_filter = &|&(ref name, _, level): &(String, _, _)| {\n         if symbol_export::is_below_threshold(level, export_threshold) {\n             let mut bytes = Vec::with_capacity(name.len() + 1);\n             bytes.extend(name.bytes());"}, {"sha": "72071f8cec99006793a4a5df09d9c7f246fa95d7", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 72, "deletions": 40, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use context::SharedCrateContext;\n use monomorphize::Instance;\n-use rustc::util::nodemap::FxHashMap;\n-use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n+use rustc::util::nodemap::{FxHashMap, NodeSet};\n+use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE, INVALID_CRATE, CRATE_DEF_INDEX};\n use rustc::session::config;\n use rustc::ty::TyCtxt;\n use syntax::attr;\n@@ -28,59 +27,87 @@ pub enum SymbolExportLevel {\n }\n \n /// The set of symbols exported from each crate in the crate graph.\n+#[derive(Debug)]\n pub struct ExportedSymbols {\n-    exports: FxHashMap<CrateNum, Vec<(String, SymbolExportLevel)>>,\n+    pub export_threshold: SymbolExportLevel,\n+    exports: FxHashMap<CrateNum, Vec<(String, DefId, SymbolExportLevel)>>,\n+    local_exports: NodeSet,\n }\n \n impl ExportedSymbols {\n     pub fn empty() -> ExportedSymbols {\n         ExportedSymbols {\n+            export_threshold: SymbolExportLevel::C,\n             exports: FxHashMap(),\n+            local_exports: NodeSet(),\n         }\n     }\n \n-    pub fn compute<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>) -> ExportedSymbols {\n-        let mut local_crate: Vec<_> = scx\n-            .exported_symbols()\n+    pub fn compute<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             local_exported_symbols: &NodeSet)\n+                             -> ExportedSymbols {\n+        let export_threshold = crates_export_threshold(&tcx.sess.crate_types.borrow());\n+\n+        let mut local_crate: Vec<_> = local_exported_symbols\n             .iter()\n             .map(|&node_id| {\n-                scx.tcx().hir.local_def_id(node_id)\n+                tcx.hir.local_def_id(node_id)\n             })\n             .map(|def_id| {\n-                let name = scx.tcx().symbol_name(Instance::mono(scx.tcx(), def_id));\n-                let export_level = export_level(scx, def_id);\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n+                let export_level = export_level(tcx, def_id);\n                 debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n-                (str::to_owned(&name), export_level)\n+                (str::to_owned(&name), def_id, export_level)\n             })\n             .collect();\n \n-        if scx.sess().entry_fn.borrow().is_some() {\n-            local_crate.push((\"main\".to_string(), SymbolExportLevel::C));\n+        let mut local_exports = local_crate\n+            .iter()\n+            .filter_map(|&(_, def_id, level)| {\n+                if is_below_threshold(level, export_threshold) {\n+                    tcx.hir.as_local_node_id(def_id)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect::<NodeSet>();\n+\n+        const INVALID_DEF_ID: DefId = DefId {\n+            krate: INVALID_CRATE,\n+            index: CRATE_DEF_INDEX,\n+        };\n+\n+        if let Some(_) = *tcx.sess.entry_fn.borrow() {\n+            local_crate.push((\"main\".to_string(),\n+                              INVALID_DEF_ID,\n+                              SymbolExportLevel::C));\n         }\n \n-        if let Some(id) = scx.sess().derive_registrar_fn.get() {\n-            let def_id = scx.tcx().hir.local_def_id(id);\n+        if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n+            let def_id = tcx.hir.local_def_id(id);\n             let idx = def_id.index;\n-            let disambiguator = scx.sess().local_crate_disambiguator();\n-            let registrar = scx.sess().generate_derive_registrar_symbol(disambiguator, idx);\n-            local_crate.push((registrar, SymbolExportLevel::C));\n+            let disambiguator = tcx.sess.local_crate_disambiguator();\n+            let registrar = tcx.sess.generate_derive_registrar_symbol(disambiguator, idx);\n+            local_crate.push((registrar, def_id, SymbolExportLevel::C));\n+            local_exports.insert(id);\n         }\n \n-        if scx.sess().crate_types.borrow().contains(&config::CrateTypeDylib) {\n-            local_crate.push((metadata_symbol_name(scx.tcx()),\n+        if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n+            local_crate.push((metadata_symbol_name(tcx),\n+                              INVALID_DEF_ID,\n                               SymbolExportLevel::Rust));\n         }\n \n         let mut exports = FxHashMap();\n         exports.insert(LOCAL_CRATE, local_crate);\n \n-        for cnum in scx.sess().cstore.crates() {\n+        for cnum in tcx.sess.cstore.crates() {\n             debug_assert!(cnum != LOCAL_CRATE);\n \n             // If this crate is a plugin and/or a custom derive crate, then\n             // we're not even going to link those in so we skip those crates.\n-            if scx.sess().cstore.plugin_registrar_fn(cnum).is_some() ||\n-               scx.sess().cstore.derive_registrar_fn(cnum).is_some() {\n+            if tcx.sess.cstore.plugin_registrar_fn(cnum).is_some() ||\n+               tcx.sess.cstore.derive_registrar_fn(cnum).is_some() {\n                 continue;\n             }\n \n@@ -92,16 +119,16 @@ impl ExportedSymbols {\n             // Down below we'll hardwire all of the symbols to the `Rust` export\n             // level instead.\n             let special_runtime_crate =\n-                scx.tcx().is_panic_runtime(cnum.as_def_id()) ||\n-                scx.sess().cstore.is_compiler_builtins(cnum);\n+                tcx.is_panic_runtime(cnum.as_def_id()) ||\n+                tcx.sess.cstore.is_compiler_builtins(cnum);\n \n-            let crate_exports = scx\n-                .sess()\n+            let crate_exports = tcx\n+                .sess\n                 .cstore\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {\n-                    let name = scx.tcx().symbol_name(Instance::mono(scx.tcx(), def_id));\n+                    let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n                     let export_level = if special_runtime_crate {\n                         // We can probably do better here by just ensuring that\n                         // it has hidden visibility rather than public\n@@ -118,35 +145,41 @@ impl ExportedSymbols {\n                             SymbolExportLevel::Rust\n                         }\n                     } else {\n-                        export_level(scx, def_id)\n+                        export_level(tcx, def_id)\n                     };\n                     debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n-                    (str::to_owned(&name), export_level)\n+                    (str::to_owned(&name), def_id, export_level)\n                 })\n                 .collect();\n \n             exports.insert(cnum, crate_exports);\n         }\n \n         return ExportedSymbols {\n-            exports: exports\n+            export_threshold,\n+            exports,\n+            local_exports,\n         };\n \n-        fn export_level(scx: &SharedCrateContext,\n+        fn export_level(tcx: TyCtxt,\n                         sym_def_id: DefId)\n                         -> SymbolExportLevel {\n-            let attrs = scx.tcx().get_attrs(sym_def_id);\n-            if attr::contains_extern_indicator(scx.sess().diagnostic(), &attrs) {\n+            let attrs = tcx.get_attrs(sym_def_id);\n+            if attr::contains_extern_indicator(tcx.sess.diagnostic(), &attrs) {\n                 SymbolExportLevel::C\n             } else {\n                 SymbolExportLevel::Rust\n             }\n         }\n     }\n \n+    pub fn local_exports(&self) -> &NodeSet {\n+        &self.local_exports\n+    }\n+\n     pub fn exported_symbols(&self,\n                             cnum: CrateNum)\n-                            -> &[(String, SymbolExportLevel)] {\n+                            -> &[(String, DefId, SymbolExportLevel)] {\n         match self.exports.get(&cnum) {\n             Some(exports) => exports,\n             None => &[]\n@@ -155,13 +188,12 @@ impl ExportedSymbols {\n \n     pub fn for_each_exported_symbol<F>(&self,\n                                        cnum: CrateNum,\n-                                       export_threshold: SymbolExportLevel,\n                                        mut f: F)\n-        where F: FnMut(&str, SymbolExportLevel)\n+        where F: FnMut(&str, DefId, SymbolExportLevel)\n     {\n-        for &(ref name, export_level) in self.exported_symbols(cnum) {\n-            if is_below_threshold(export_level, export_threshold) {\n-                f(&name, export_level)\n+        for &(ref name, def_id, export_level) in self.exported_symbols(cnum) {\n+            if is_below_threshold(export_level, self.export_threshold) {\n+                f(&name, def_id, export_level)\n             }\n         }\n     }"}, {"sha": "3443160bded76646472593ea63c2650d23b6984f", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 27, "deletions": 162, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "patch": "@@ -77,6 +77,7 @@ use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::str;\n+use std::sync::Arc;\n use std::i32;\n use syntax_pos::Span;\n use syntax::attr;\n@@ -796,131 +797,6 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     return (metadata_llcx, metadata_llmod, metadata);\n }\n \n-/// Find any symbols that are defined in one compilation unit, but not declared\n-/// in any other compilation unit.  Give these symbols internal linkage.\n-fn internalize_symbols<'a, 'tcx>(sess: &Session,\n-                                 scx: &SharedCrateContext<'a, 'tcx>,\n-                                 translation_items: &FxHashSet<TransItem<'tcx>>,\n-                                 llvm_modules: &[ModuleLlvm],\n-                                 exported_symbols: &ExportedSymbols) {\n-    let export_threshold =\n-        symbol_export::crates_export_threshold(&sess.crate_types.borrow());\n-\n-    let exported_symbols = exported_symbols\n-        .exported_symbols(LOCAL_CRATE)\n-        .iter()\n-        .filter(|&&(_, export_level)| {\n-            symbol_export::is_below_threshold(export_level, export_threshold)\n-        })\n-        .map(|&(ref name, _)| &name[..])\n-        .collect::<FxHashSet<&str>>();\n-\n-    let tcx = scx.tcx();\n-\n-    let incr_comp = sess.opts.debugging_opts.incremental.is_some();\n-\n-    // 'unsafe' because we are holding on to CStr's from the LLVM module within\n-    // this block.\n-    unsafe {\n-        let mut referenced_somewhere = FxHashSet();\n-\n-        // Collect all symbols that need to stay externally visible because they\n-        // are referenced via a declaration in some other codegen unit. In\n-        // incremental compilation, we don't need to collect. See below for more\n-        // information.\n-        if !incr_comp {\n-            for ll in llvm_modules {\n-                for val in iter_globals(ll.llmod).chain(iter_functions(ll.llmod)) {\n-                    let linkage = llvm::LLVMRustGetLinkage(val);\n-                    // We only care about external declarations (not definitions)\n-                    // and available_externally definitions.\n-                    let is_available_externally =\n-                        linkage == llvm::Linkage::AvailableExternallyLinkage;\n-                    let is_decl = llvm::LLVMIsDeclaration(val) == llvm::True;\n-\n-                    if is_decl || is_available_externally {\n-                        let symbol_name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                        referenced_somewhere.insert(symbol_name);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Also collect all symbols for which we cannot adjust linkage, because\n-        // it is fixed by some directive in the source code.\n-        let (locally_defined_symbols, linkage_fixed_explicitly) = {\n-            let mut locally_defined_symbols = FxHashSet();\n-            let mut linkage_fixed_explicitly = FxHashSet();\n-\n-            for trans_item in translation_items {\n-                let symbol_name = str::to_owned(&trans_item.symbol_name(tcx));\n-                if trans_item.explicit_linkage(tcx).is_some() {\n-                    linkage_fixed_explicitly.insert(symbol_name.clone());\n-                }\n-                locally_defined_symbols.insert(symbol_name);\n-            }\n-\n-            (locally_defined_symbols, linkage_fixed_explicitly)\n-        };\n-\n-        // Examine each external definition.  If the definition is not used in\n-        // any other compilation unit, and is not reachable from other crates,\n-        // then give it internal linkage.\n-        for ll in llvm_modules {\n-            for val in iter_globals(ll.llmod).chain(iter_functions(ll.llmod)) {\n-                let linkage = llvm::LLVMRustGetLinkage(val);\n-\n-                let is_externally_visible = (linkage == llvm::Linkage::ExternalLinkage) ||\n-                                            (linkage == llvm::Linkage::LinkOnceODRLinkage) ||\n-                                            (linkage == llvm::Linkage::WeakODRLinkage);\n-\n-                if !is_externally_visible {\n-                    // This symbol is not visible outside of its codegen unit,\n-                    // so there is nothing to do for it.\n-                    continue;\n-                }\n-\n-                let name_cstr = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                let name_str = name_cstr.to_str().unwrap();\n-\n-                if exported_symbols.contains(&name_str) {\n-                    // This symbol is explicitly exported, so we can't\n-                    // mark it as internal or hidden.\n-                    continue;\n-                }\n-\n-                let is_declaration = llvm::LLVMIsDeclaration(val) == llvm::True;\n-\n-                if is_declaration {\n-                    if locally_defined_symbols.contains(name_str) {\n-                        // Only mark declarations from the current crate as hidden.\n-                        // Otherwise we would mark things as hidden that are\n-                        // imported from other crates or native libraries.\n-                        llvm::LLVMRustSetVisibility(val, llvm::Visibility::Hidden);\n-                    }\n-                } else {\n-                    let has_fixed_linkage = linkage_fixed_explicitly.contains(name_str);\n-\n-                    if !has_fixed_linkage {\n-                        // In incremental compilation mode, we can't be sure that\n-                        // we saw all references because we don't know what's in\n-                        // cached compilation units, so we always assume that the\n-                        // given item has been referenced.\n-                        if incr_comp || referenced_somewhere.contains(&name_cstr) {\n-                            llvm::LLVMRustSetVisibility(val, llvm::Visibility::Hidden);\n-                        } else {\n-                            llvm::LLVMRustSetLinkage(val, llvm::Linkage::InternalLinkage);\n-                        }\n-\n-                        llvm::LLVMSetDLLStorageClass(val, llvm::DLLStorageClass::Default);\n-                        llvm::UnsetComdat(val);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n // Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n // This is required to satisfy `dllimport` references to static data in .rlibs\n // when using MSVC linker.  We do this only for data, as linker can fix up\n@@ -992,15 +868,6 @@ fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n     }\n }\n \n-fn iter_functions(llmod: llvm::ModuleRef) -> ValueIter {\n-    unsafe {\n-        ValueIter {\n-            cur: llvm::LLVMGetFirstFunction(llmod),\n-            step: llvm::LLVMGetNextFunction,\n-        }\n-    }\n-}\n-\n /// The context provided lists a set of reachable ids as calculated by\n /// middle::reachable, but this contains far more ids and symbols than we're\n /// actually exposing from the object file. This function will filter the set in\n@@ -1063,20 +930,19 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let krate = tcx.hir.krate();\n \n     let ty::CrateAnalysis { reachable, .. } = analysis;\n-    let exported_symbols = find_exported_symbols(tcx, &reachable);\n \n     let check_overflow = tcx.sess.overflow_checks();\n \n     let link_meta = link::build_link_meta(incremental_hashes_map);\n \n+    let exported_symbol_node_ids = find_exported_symbols(tcx, &reachable);\n     let shared_ccx = SharedCrateContext::new(tcx,\n-                                             exported_symbols,\n                                              check_overflow,\n                                              output_filenames);\n     // Translate the metadata.\n     let (metadata_llcx, metadata_llmod, metadata) =\n         time(tcx.sess.time_passes(), \"write metadata\", || {\n-            write_metadata(tcx, &link_meta, shared_ccx.exported_symbols())\n+            write_metadata(tcx, &link_meta, &exported_symbol_node_ids)\n         });\n \n     let metadata_module = ModuleTranslation {\n@@ -1090,7 +956,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n-\n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n        !tcx.sess.opts.output_types.should_trans() {\n@@ -1110,10 +975,15 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n     }\n \n+    let exported_symbols = Arc::new(ExportedSymbols::compute(tcx,\n+                                                             &exported_symbol_node_ids));\n+\n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n     let (translation_items, codegen_units) =\n-        collect_and_partition_translation_items(&shared_ccx);\n+        collect_and_partition_translation_items(&shared_ccx, &exported_symbols);\n+\n+    let translation_items = Arc::new(translation_items);\n \n     let mut all_stats = Stats::default();\n     let modules: Vec<ModuleTranslation> = codegen_units\n@@ -1123,7 +993,9 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let ((stats, module), _) =\n                 tcx.dep_graph.with_task(dep_node,\n                                         AssertDepGraphSafe(&shared_ccx),\n-                                        AssertDepGraphSafe(cgu),\n+                                        AssertDepGraphSafe((cgu,\n+                                                            translation_items.clone(),\n+                                                            exported_symbols.clone())),\n                                         module_translation);\n             all_stats.extend(stats);\n             module\n@@ -1132,16 +1004,18 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     fn module_translation<'a, 'tcx>(\n         scx: AssertDepGraphSafe<&SharedCrateContext<'a, 'tcx>>,\n-        args: AssertDepGraphSafe<CodegenUnit<'tcx>>)\n+        args: AssertDepGraphSafe<(CodegenUnit<'tcx>,\n+                                  Arc<FxHashSet<TransItem<'tcx>>>,\n+                                  Arc<ExportedSymbols>)>)\n         -> (Stats, ModuleTranslation)\n     {\n         // FIXME(#40304): We ought to be using the id as a key and some queries, I think.\n         let AssertDepGraphSafe(scx) = scx;\n-        let AssertDepGraphSafe(cgu) = args;\n+        let AssertDepGraphSafe((cgu, crate_trans_items, exported_symbols)) = args;\n \n         let cgu_name = String::from(cgu.name());\n         let cgu_id = cgu.work_product_id();\n-        let symbol_name_hash = cgu.compute_symbol_name_hash(scx);\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &exported_symbols);\n \n         // Check whether there is a previous work-product we can\n         // re-use.  Not only must the file exist, and the inputs not\n@@ -1176,13 +1050,13 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Instantiate translation items without filling out definitions yet...\n-        let lcx = LocalCrateContext::new(scx, cgu);\n+        let lcx = LocalCrateContext::new(scx, cgu, crate_trans_items, exported_symbols);\n         let module = {\n             let ccx = CrateContext::new(scx, &lcx);\n             let trans_items = ccx.codegen_unit()\n                                  .items_in_deterministic_order(ccx.tcx());\n-            for &(trans_item, linkage) in &trans_items {\n-                trans_item.predefine(&ccx, linkage);\n+            for &(trans_item, (linkage, visibility)) in &trans_items {\n+                trans_item.predefine(&ccx, linkage, visibility);\n             }\n \n             // ... and now that we have everything pre-defined, fill out those definitions.\n@@ -1272,8 +1146,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let sess = shared_ccx.sess();\n \n-    let exported_symbols = ExportedSymbols::compute(&shared_ccx);\n-\n     // Get the list of llvm modules we created. We'll do a few wacky\n     // transforms on them now.\n \n@@ -1285,16 +1157,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                })\n                .collect();\n \n-    // Now that we have all symbols that are exported from the CGUs of this\n-    // crate, we can run the `internalize_symbols` pass.\n-    time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n-        internalize_symbols(sess,\n-                            &shared_ccx,\n-                            &translation_items,\n-                            &llvm_modules,\n-                            &exported_symbols);\n-    });\n-\n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n         create_imps(sess, &llvm_modules);\n@@ -1355,7 +1217,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         allocator_module: allocator_module,\n         link: link_meta,\n         metadata: metadata,\n-        exported_symbols: exported_symbols,\n+        exported_symbols: Arc::try_unwrap(exported_symbols)\n+            .expect(\"There's still a reference to exported_symbols?\"),\n         no_builtins: no_builtins,\n         linker_info: linker_info,\n         windows_subsystem: windows_subsystem,\n@@ -1410,7 +1273,8 @@ fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_i\n     }\n }\n \n-fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n+fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                                     exported_symbols: &ExportedSymbols)\n                                                      -> (FxHashSet<TransItem<'tcx>>,\n                                                          Vec<CodegenUnit<'tcx>>) {\n     let time_passes = scx.sess().time_passes();\n@@ -1452,7 +1316,8 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         partitioning::partition(scx,\n                                 items.iter().cloned(),\n                                 strategy,\n-                                &inlining_map)\n+                                &inlining_map,\n+                                exported_symbols)\n     });\n \n     assert!(scx.tcx().sess.opts.cg.codegen_units == codegen_units.len() ||\n@@ -1480,7 +1345,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n                 let mut cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n                 cgus.as_mut_slice().sort_by_key(|&(ref name, _)| name.clone());\n                 cgus.dedup();\n-                for &(ref cgu_name, linkage) in cgus.iter() {\n+                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n                     output.push_str(\" \");\n                     output.push_str(&cgu_name);\n "}, {"sha": "76f94565bae515cebdad2e6550c827cc908f8de1", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "patch": "@@ -23,6 +23,7 @@ use monomorphize::{self, Instance};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TypeFoldable;\n use rustc::ty::subst::Substs;\n+use trans_item::TransItem;\n use type_of;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n@@ -99,19 +100,32 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let attrs = instance.def.attrs(ccx.tcx());\n         attributes::from_fn_attrs(ccx, &attrs, llfn);\n \n+        let instance_def_id = instance.def_id();\n+\n         // Perhaps questionable, but we assume that anything defined\n         // *in Rust code* may unwind. Foreign items like `extern \"C\" {\n         // fn foo(); }` are assumed not to unwind **unless** they have\n         // a `#[unwind]` attribute.\n-        if !tcx.is_foreign_item(instance.def_id()) {\n+        if !tcx.is_foreign_item(instance_def_id) {\n             attributes::unwind(llfn, true);\n-            unsafe {\n-                llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n+        }\n+\n+        unsafe {\n+            llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n+\n+            if ccx.crate_trans_items().contains(&TransItem::Fn(instance)) {\n+                if let Some(node_id) = tcx.hir.as_local_node_id(instance_def_id) {\n+                    if !ccx.exported_symbols().local_exports().contains(&node_id) {\n+                        llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+                    }\n+                } else {\n+                    llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+                }\n             }\n         }\n \n         if ccx.use_dll_storage_attrs() &&\n-            ccx.sess().cstore.is_dllimport_foreign_item(instance.def_id())\n+            ccx.sess().cstore.is_dllimport_foreign_item(instance_def_id)\n         {\n             unsafe {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);"}, {"sha": "4e1870be5613250113a9c54042815624b7414593", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "patch": "@@ -243,21 +243,19 @@ impl<'tcx> InliningMap<'tcx> {\n \n     fn record_accesses<I>(&mut self,\n                           source: TransItem<'tcx>,\n-                          targets: I)\n-        where I: Iterator<Item=(TransItem<'tcx>, bool)>\n+                          new_targets: I)\n+        where I: Iterator<Item=(TransItem<'tcx>, bool)> + ExactSizeIterator\n     {\n         assert!(!self.index.contains_key(&source));\n \n         let start_index = self.targets.len();\n-        let (targets_size_hint, targets_size_hint_max) = targets.size_hint();\n-        debug_assert_eq!(targets_size_hint_max, Some(targets_size_hint));\n-        let new_items_count = targets_size_hint;\n+        let new_items_count = new_targets.len();\n         let new_items_count_total = new_items_count + self.targets.len();\n \n         self.targets.reserve(new_items_count);\n         self.inlines.grow(new_items_count_total);\n \n-        for (i, (target, inline)) in targets.enumerate() {\n+        for (i, (target, inline)) in new_targets.enumerate() {\n             self.targets.push(target);\n             if inline {\n                 self.inlines.insert(i + start_index);"}, {"sha": "da2a58398634e05c26dc03ae2aae09dc551afa35", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "patch": "@@ -104,6 +104,12 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n                 let g = declare::define_global(ccx, &sym[..], llty).unwrap();\n \n+                if !ccx.exported_symbols().local_exports().contains(&id) {\n+                    unsafe {\n+                        llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n+                    }\n+                }\n+\n                 (g, attrs)\n             }\n \n@@ -243,8 +249,16 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n             let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n             llvm::LLVMSetValueName(g, empty_string.as_ptr());\n+\n+            let linkage = llvm::LLVMRustGetLinkage(g);\n+            let visibility = llvm::LLVMRustGetVisibility(g);\n+\n             let new_g = llvm::LLVMRustGetOrInsertGlobal(\n                 ccx.llmod(), name_string.as_ptr(), val_llty.to_ref());\n+\n+            llvm::LLVMRustSetLinkage(new_g, linkage);\n+            llvm::LLVMRustSetVisibility(new_g, visibility);\n+\n             // To avoid breaking any invariants, we leave around the old\n             // global for the moment; we'll replace all references to it\n             // with the new global later. (See base::trans_crate.)"}, {"sha": "bec39e3cde6d0d2f935d3b7f063222389288c49c", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "patch": "@@ -16,25 +16,28 @@ use rustc::hir::def_id::DefId;\n use rustc::traits;\n use debuginfo;\n use callee;\n+use back::symbol_export::ExportedSymbols;\n use base;\n use declare;\n use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n+use trans_item::TransItem;\n use type_::Type;\n use rustc_data_structures::base_n;\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames};\n use rustc::session::Session;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{LayoutCx, LayoutError, LayoutTyper, TyLayout};\n-use rustc::util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::ptr;\n use std::iter;\n use std::str;\n+use std::sync::Arc;\n use std::marker::PhantomData;\n use syntax::ast;\n use syntax::symbol::InternedString;\n@@ -76,7 +79,6 @@ impl Stats {\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n pub struct SharedCrateContext<'a, 'tcx: 'a> {\n-    exported_symbols: NodeSet,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_overflow: bool,\n \n@@ -94,6 +96,13 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     llcx: ContextRef,\n     stats: Stats,\n     codegen_unit: CodegenUnit<'tcx>,\n+\n+    /// The translation items of the whole crate.\n+    crate_trans_items: Arc<FxHashSet<TransItem<'tcx>>>,\n+\n+    /// Information about which symbols are exported from the crate.\n+    exported_symbols: Arc<ExportedSymbols>,\n+\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n@@ -265,7 +274,6 @@ pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (Cont\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-               exported_symbols: NodeSet,\n                check_overflow: bool,\n                output_filenames: &'b OutputFilenames)\n                -> SharedCrateContext<'b, 'tcx> {\n@@ -315,7 +323,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_msvc;\n \n         SharedCrateContext {\n-            exported_symbols: exported_symbols,\n             tcx: tcx,\n             check_overflow: check_overflow,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n@@ -335,10 +342,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         ty.is_freeze(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n     }\n \n-    pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n-        &self.exported_symbols\n-    }\n-\n     pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }\n@@ -362,7 +365,9 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n \n impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n     pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: CodegenUnit<'tcx>)\n+               codegen_unit: CodegenUnit<'tcx>,\n+               crate_trans_items: Arc<FxHashSet<TransItem<'tcx>>>,\n+               exported_symbols: Arc<ExportedSymbols>,)\n                -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n@@ -394,6 +399,8 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 llcx: llcx,\n                 stats: Stats::default(),\n                 codegen_unit: codegen_unit,\n+                crate_trans_items,\n+                exported_symbols,\n                 instances: RefCell::new(FxHashMap()),\n                 vtables: RefCell::new(FxHashMap()),\n                 const_cstr_cache: RefCell::new(FxHashMap()),\n@@ -504,6 +511,14 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().codegen_unit\n     }\n \n+    pub fn crate_trans_items(&self) -> &FxHashSet<TransItem<'tcx>> {\n+        &self.local().crate_trans_items\n+    }\n+\n+    pub fn exported_symbols(&self) -> &ExportedSymbols {\n+        &self.local().exported_symbols\n+    }\n+\n     pub fn td(&self) -> llvm::TargetDataRef {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }"}, {"sha": "6df509f34a472d16a93dbb5572f6aa16ee52ac85", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "patch": "@@ -37,7 +37,7 @@ pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    !cx.shared().exported_symbols().contains(&node_id)\n+    !cx.exported_symbols().local_exports().contains(&node_id)\n }\n \n #[allow(non_snake_case)]"}, {"sha": "5e445652dc4735018203130b47409a5d24629d17", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 205, "deletions": 33, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "patch": "@@ -102,6 +102,7 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n+use back::symbol_export::ExportedSymbols;\n use collector::InliningMap;\n use common;\n use context::SharedCrateContext;\n@@ -110,14 +111,15 @@ use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_incremental::IchHasher;\n+use std::collections::hash_map::Entry;\n use std::hash::Hash;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use trans_item::{TransItem, InstantiationMode};\n-use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n pub enum PartitioningStrategy {\n     /// Generate one codegen unit per source-level module.\n@@ -134,16 +136,16 @@ pub struct CodegenUnit<'tcx> {\n     /// as well as the crate name and disambiguator.\n     name: InternedString,\n \n-    items: FxHashMap<TransItem<'tcx>, llvm::Linkage>,\n+    items: FxHashMap<TransItem<'tcx>, (llvm::Linkage, llvm::Visibility)>,\n }\n \n impl<'tcx> CodegenUnit<'tcx> {\n     pub fn new(name: InternedString,\n-               items: FxHashMap<TransItem<'tcx>, llvm::Linkage>)\n+               items: FxHashMap<TransItem<'tcx>, (llvm::Linkage, llvm::Visibility)>)\n                -> Self {\n         CodegenUnit {\n-            name: name,\n-            items: items,\n+            name,\n+            items,\n         }\n     }\n \n@@ -159,7 +161,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         &self.name\n     }\n \n-    pub fn items(&self) -> &FxHashMap<TransItem<'tcx>, llvm::Linkage> {\n+    pub fn items(&self) -> &FxHashMap<TransItem<'tcx>, (llvm::Linkage, llvm::Visibility)> {\n         &self.items\n     }\n \n@@ -172,10 +174,11 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn compute_symbol_name_hash<'a>(&self,\n-                                        scx: &SharedCrateContext<'a, 'tcx>)\n+                                        scx: &SharedCrateContext<'a, 'tcx>,\n+                                        exported_symbols: &ExportedSymbols)\n                                         -> u64 {\n         let mut state = IchHasher::new();\n-        let exported_symbols = scx.exported_symbols();\n+        let exported_symbols = exported_symbols.local_exports();\n         let all_items = self.items_in_deterministic_order(scx.tcx());\n         for (item, _) in all_items {\n             let symbol_name = item.symbol_name(scx.tcx());\n@@ -200,7 +203,8 @@ impl<'tcx> CodegenUnit<'tcx> {\n \n     pub fn items_in_deterministic_order<'a>(&self,\n                                             tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                            -> Vec<(TransItem<'tcx>, llvm::Linkage)> {\n+                                            -> Vec<(TransItem<'tcx>,\n+                                                   (llvm::Linkage, llvm::Visibility))> {\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n         #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -233,7 +237,8 @@ const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                               trans_items: I,\n                               strategy: PartitioningStrategy,\n-                              inlining_map: &InliningMap<'tcx>)\n+                              inlining_map: &InliningMap<'tcx>,\n+                              exported_symbols: &ExportedSymbols)\n                               -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n@@ -243,6 +248,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // respective 'home' codegen unit. Regular translation items are all\n     // functions and statics defined in the local crate.\n     let mut initial_partitioning = place_root_translation_items(scx,\n+                                                                exported_symbols,\n                                                                 trans_items);\n \n     debug_dump(tcx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n@@ -259,13 +265,22 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // translation items have to go into each codegen unit. These additional\n     // translation items can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with #[inline].\n-    let post_inlining = place_inlined_translation_items(initial_partitioning,\n-                                                        inlining_map);\n+    let mut post_inlining = place_inlined_translation_items(initial_partitioning,\n+                                                            inlining_map);\n+\n+    debug_dump(tcx, \"POST INLINING:\", post_inlining.codegen_units.iter());\n \n-    debug_dump(tcx, \"POST INLINING:\", post_inlining.0.iter());\n+    // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n+    // more freedom to optimize.\n+    internalize_symbols(tcx, &mut post_inlining, inlining_map);\n \n     // Finally, sort by codegen unit name, so that we get deterministic results\n-    let mut result = post_inlining.0;\n+    let PostInliningPartitioning {\n+        codegen_units: mut result,\n+        trans_item_placements: _,\n+        internalization_candidates: _,\n+    } = post_inlining;\n+\n     result.sort_by(|cgu1, cgu2| {\n         (&cgu1.name[..]).cmp(&cgu2.name[..])\n     });\n@@ -284,19 +299,37 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n struct PreInliningPartitioning<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n     roots: FxHashSet<TransItem<'tcx>>,\n+    internalization_candidates: FxHashSet<TransItem<'tcx>>,\n }\n \n-struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n+/// For symbol internalization, we need to know whether a symbol/trans-item is\n+/// accessed from outside the codegen unit it is defined in. This type is used\n+/// to keep track of that.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+enum TransItemPlacement {\n+    SingleCgu { cgu_name: InternedString },\n+    MultipleCgus,\n+}\n+\n+struct PostInliningPartitioning<'tcx> {\n+    codegen_units: Vec<CodegenUnit<'tcx>>,\n+    trans_item_placements: FxHashMap<TransItem<'tcx>, TransItemPlacement>,\n+    internalization_candidates: FxHashSet<TransItem<'tcx>>,\n+}\n \n fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                             exported_symbols: &ExportedSymbols,\n                                              trans_items: I)\n                                              -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     let tcx = scx.tcx();\n+    let exported_symbols = exported_symbols.local_exports();\n+\n     let mut roots = FxHashSet();\n     let mut codegen_units = FxHashMap();\n     let is_incremental_build = tcx.sess.opts.incremental.is_some();\n+    let mut internalization_candidates = FxHashSet();\n \n     for trans_item in trans_items {\n         let is_root = trans_item.instantiation_mode(tcx) == InstantiationMode::GloballyShared;\n@@ -318,18 +351,52 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n             let mut codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n                                                 .or_insert_with(make_codegen_unit);\n \n-            let linkage = match trans_item.explicit_linkage(tcx) {\n-                Some(explicit_linkage) => explicit_linkage,\n+            let (linkage, visibility) = match trans_item.explicit_linkage(tcx) {\n+                Some(explicit_linkage) => (explicit_linkage, llvm::Visibility::Default),\n                 None => {\n                     match trans_item {\n-                        TransItem::Fn(..) |\n-                        TransItem::Static(..) |\n-                        TransItem::GlobalAsm(..) => llvm::ExternalLinkage,\n+                        TransItem::Fn(ref instance) => {\n+                            let visibility = match instance.def {\n+                                InstanceDef::Item(def_id) => {\n+                                    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+                                        if exported_symbols.contains(&node_id) {\n+                                            llvm::Visibility::Default\n+                                        } else {\n+                                            internalization_candidates.insert(trans_item);\n+                                            llvm::Visibility::Hidden\n+                                        }\n+                                    } else {\n+                                        internalization_candidates.insert(trans_item);\n+                                        llvm::Visibility::Hidden\n+                                    }\n+                                }\n+                                InstanceDef::FnPtrShim(..) |\n+                                InstanceDef::Virtual(..) |\n+                                InstanceDef::Intrinsic(..) |\n+                                InstanceDef::ClosureOnceShim { .. } |\n+                                InstanceDef::DropGlue(..) => {\n+                                    bug!(\"partitioning: Encountered unexpected\n+                                          root translation item: {:?}\",\n+                                          trans_item)\n+                                }\n+                            };\n+                            (llvm::ExternalLinkage, visibility)\n+                        }\n+                        TransItem::Static(node_id) |\n+                        TransItem::GlobalAsm(node_id) => {\n+                            let visibility = if exported_symbols.contains(&node_id) {\n+                                llvm::Visibility::Default\n+                            } else {\n+                                internalization_candidates.insert(trans_item);\n+                                llvm::Visibility::Hidden\n+                            };\n+                            (llvm::ExternalLinkage, visibility)\n+                        }\n                     }\n                 }\n             };\n \n-            codegen_unit.items.insert(trans_item, linkage);\n+            codegen_unit.items.insert(trans_item, (linkage, visibility));\n             roots.insert(trans_item);\n         }\n     }\n@@ -338,15 +405,16 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // crate with just types (for example), we could wind up with no CGU\n     if codegen_units.is_empty() {\n         let codegen_unit_name = Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str();\n-        codegen_units.entry(codegen_unit_name.clone())\n-                     .or_insert_with(|| CodegenUnit::empty(codegen_unit_name.clone()));\n+        codegen_units.insert(codegen_unit_name.clone(),\n+                             CodegenUnit::empty(codegen_unit_name.clone()));\n     }\n \n     PreInliningPartitioning {\n         codegen_units: codegen_units.into_iter()\n                                     .map(|(_, codegen_unit)| codegen_unit)\n                                     .collect(),\n-        roots: roots,\n+        roots,\n+        internalization_candidates,\n     }\n }\n \n@@ -388,37 +456,75 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n                                          inlining_map: &InliningMap<'tcx>)\n                                          -> PostInliningPartitioning<'tcx> {\n     let mut new_partitioning = Vec::new();\n+    let mut trans_item_placements = FxHashMap();\n+\n+    let PreInliningPartitioning {\n+        codegen_units: initial_cgus,\n+        roots,\n+        internalization_candidates,\n+    } = initial_partitioning;\n \n-    for codegen_unit in &initial_partitioning.codegen_units[..] {\n+    let single_codegen_unit = initial_cgus.len() == 1;\n+\n+    for old_codegen_unit in initial_cgus {\n         // Collect all items that need to be available in this codegen unit\n         let mut reachable = FxHashSet();\n-        for root in codegen_unit.items.keys() {\n+        for root in old_codegen_unit.items.keys() {\n             follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n-        let mut new_codegen_unit =\n-            CodegenUnit::empty(codegen_unit.name.clone());\n+        let mut new_codegen_unit = CodegenUnit {\n+            name: old_codegen_unit.name,\n+            items: FxHashMap(),\n+        };\n \n         // Add all translation items that are not already there\n         for trans_item in reachable {\n-            if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n+            if let Some(linkage) = old_codegen_unit.items.get(&trans_item) {\n                 // This is a root, just copy it over\n                 new_codegen_unit.items.insert(trans_item, *linkage);\n             } else {\n-                if initial_partitioning.roots.contains(&trans_item) {\n+                if roots.contains(&trans_item) {\n                     bug!(\"GloballyShared trans-item inlined into other CGU: \\\n                           {:?}\", trans_item);\n                 }\n \n                 // This is a cgu-private copy\n-                new_codegen_unit.items.insert(trans_item, llvm::InternalLinkage);\n+                new_codegen_unit.items.insert(trans_item,\n+                                              (llvm::InternalLinkage, llvm::Visibility::Default));\n+            }\n+\n+            if !single_codegen_unit {\n+                // If there is more than one codegen unit, we need to keep track\n+                // in which codegen units each translation item is placed:\n+                match trans_item_placements.entry(trans_item) {\n+                    Entry::Occupied(e) => {\n+                        let placement = e.into_mut();\n+                        debug_assert!(match *placement {\n+                            TransItemPlacement::SingleCgu { ref cgu_name } => {\n+                                *cgu_name != new_codegen_unit.name\n+                            }\n+                            TransItemPlacement::MultipleCgus => true,\n+                        });\n+                        *placement = TransItemPlacement::MultipleCgus;\n+                    }\n+                    Entry::Vacant(e) => {\n+                        e.insert(TransItemPlacement::SingleCgu {\n+                            cgu_name: new_codegen_unit.name.clone()\n+                        });\n+                    }\n+                }\n             }\n         }\n \n         new_partitioning.push(new_codegen_unit);\n     }\n \n-    return PostInliningPartitioning(new_partitioning);\n+    return PostInliningPartitioning {\n+        codegen_units: new_partitioning,\n+        trans_item_placements,\n+        internalization_candidates,\n+    };\n \n     fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n                              inlining_map: &InliningMap<'tcx>,\n@@ -433,6 +539,72 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n     }\n }\n \n+fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 partitioning: &mut PostInliningPartitioning<'tcx>,\n+                                 inlining_map: &InliningMap<'tcx>) {\n+    if partitioning.codegen_units.len() == 1 {\n+        // Fast path for when there is only one codegen unit. In this case we\n+        // can internalize all candidates, since there is nowhere else they\n+        // could be accessed from.\n+        for cgu in &mut partitioning.codegen_units {\n+            for candidate in &partitioning.internalization_candidates {\n+                cgu.items.insert(*candidate, (llvm::InternalLinkage,\n+                                              llvm::Visibility::Default));\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    // Build a map from every translation item to all the translation items that\n+    // reference it.\n+    let mut accessor_map: FxHashMap<TransItem<'tcx>, Vec<TransItem<'tcx>>> = FxHashMap();\n+    inlining_map.iter_accesses(|accessor, accessees| {\n+        for accessee in accessees {\n+            accessor_map.entry(*accessee)\n+                        .or_insert(Vec::new())\n+                        .push(accessor);\n+        }\n+    });\n+\n+    let trans_item_placements = &partitioning.trans_item_placements;\n+\n+    // For each internalization candidates in each codegen unit, check if it is\n+    // accessed from outside its defining codegen unit.\n+    for cgu in &mut partitioning.codegen_units {\n+        let home_cgu = TransItemPlacement::SingleCgu {\n+            cgu_name: cgu.name.clone()\n+        };\n+\n+        'item:\n+        for (accessee, &mut (ref mut linkage, _)) in &mut cgu.items {\n+            if !partitioning.internalization_candidates.contains(accessee) {\n+                // This item is no candidate for internalizing, so skip it.\n+                continue\n+            }\n+            debug_assert_eq!(trans_item_placements[accessee], home_cgu);\n+\n+            if let Some(accessors) = accessor_map.get(accessee) {\n+                if accessors.iter()\n+                            .filter_map(|accessor| {\n+                                // Some accessors might not have been\n+                                // instantiated. We can safely ignore those.\n+                                trans_item_placements.get(accessor)\n+                            })\n+                            .any(|placement| *placement != home_cgu) {\n+                    // Found an accessor from another CGU, so skip to the next\n+                    // item without marking this one as internal.\n+                    continue 'item;\n+                }\n+            }\n+\n+            // If we got here, we did not find any accesses from other CGUs,\n+            // so it's fine to make this translation item internal.\n+            *linkage = llvm::InternalLinkage;\n+        }\n+    }\n+}\n+\n fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                  trans_item: TransItem<'tcx>)\n                                                  -> Option<DefId> {"}, {"sha": "b94fd13c3a4a29e84f7fdcfd8d5451a732338601", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=2f07eb3261c89fb7b34d0eed1e446c73e55f7d2f", "patch": "@@ -99,7 +99,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn predefine(&self,\n                      ccx: &CrateContext<'a, 'tcx>,\n-                     linkage: llvm::Linkage) {\n+                     linkage: llvm::Linkage,\n+                     visibility: llvm::Visibility) {\n         debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx()),\n                self.to_raw_string(),\n@@ -111,10 +112,10 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         match *self {\n             TransItem::Static(node_id) => {\n-                TransItem::predefine_static(ccx, node_id, linkage, &symbol_name);\n+                TransItem::predefine_static(ccx, node_id, linkage, visibility, &symbol_name);\n             }\n             TransItem::Fn(instance) => {\n-                TransItem::predefine_fn(ccx, instance, linkage, &symbol_name);\n+                TransItem::predefine_fn(ccx, instance, linkage, visibility, &symbol_name);\n             }\n             TransItem::GlobalAsm(..) => {}\n         }\n@@ -128,6 +129,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     fn predefine_static(ccx: &CrateContext<'a, 'tcx>,\n                         node_id: ast::NodeId,\n                         linkage: llvm::Linkage,\n+                        visibility: llvm::Visibility,\n                         symbol_name: &str) {\n         let def_id = ccx.tcx().hir.local_def_id(node_id);\n         let instance = Instance::mono(ccx.tcx(), def_id);\n@@ -139,7 +141,10 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                 &format!(\"symbol `{}` is already defined\", symbol_name))\n         });\n \n-        unsafe { llvm::LLVMRustSetLinkage(g, linkage) };\n+        unsafe {\n+            llvm::LLVMRustSetLinkage(g, linkage);\n+            llvm::LLVMRustSetVisibility(g, visibility);\n+        }\n \n         ccx.instances().borrow_mut().insert(instance, g);\n         ccx.statics().borrow_mut().insert(g, def_id);\n@@ -148,6 +153,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     fn predefine_fn(ccx: &CrateContext<'a, 'tcx>,\n                     instance: Instance<'tcx>,\n                     linkage: llvm::Linkage,\n+                    visibility: llvm::Visibility,\n                     symbol_name: &str) {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n@@ -172,6 +178,10 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             unsafe {\n                 llvm::LLVMRustSetVisibility(lldecl, llvm::Visibility::Hidden);\n             }\n+        } else {\n+            unsafe {\n+                llvm::LLVMRustSetVisibility(lldecl, visibility);\n+            }\n         }\n \n         debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);"}]}