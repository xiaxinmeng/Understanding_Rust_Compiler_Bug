{"sha": "1c0b45785387529c1f8d6313d4b632fae53188c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMGI0NTc4NTM4NzUyOWMxZjhkNjMxM2Q0YjYzMmZhZTUzMTg4YzE=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-13T23:11:18Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-14T00:13:53Z"}, "message": "Workaround #2912: Implement existential TLS and cheat with taskgroup key", "tree": {"sha": "c927419eba2d4da2b77b9ec3350e469516955ae5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c927419eba2d4da2b77b9ec3350e469516955ae5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c0b45785387529c1f8d6313d4b632fae53188c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c0b45785387529c1f8d6313d4b632fae53188c1", "html_url": "https://github.com/rust-lang/rust/commit/1c0b45785387529c1f8d6313d4b632fae53188c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c0b45785387529c1f8d6313d4b632fae53188c1/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d338879ba5fef07890930abce6c8dd3549fe6fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d338879ba5fef07890930abce6c8dd3549fe6fd4", "html_url": "https://github.com/rust-lang/rust/commit/d338879ba5fef07890930abce6c8dd3549fe6fd4"}], "stats": {"total": 80, "additions": 41, "deletions": 39}, "files": [{"sha": "2f6c07f0199fec30db3b8301a23e511a434f1440", "filename": "src/libcore/task.rs", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1c0b45785387529c1f8d6313d4b632fae53188c1/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c0b45785387529c1f8d6313d4b632fae53188c1/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=1c0b45785387529c1f8d6313d4b632fae53188c1", "patch": "@@ -613,8 +613,6 @@ class taskgroup {\n     }\n }\n \n-fn taskgroup_key(+_group: @taskgroup) { } // For TLS\n-\n fn enlist_in_taskgroup(group_arc: taskgroup_arc,\n                        me: *rust_task) -> option<uint> {\n     do group_arc.with |_c, state| {\n@@ -682,9 +680,16 @@ fn kill_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint,\n     };\n }\n \n+// FIXME (#2912): Work around core-vs-coretest function duplication. Can't use\n+// a proper closure because the #[test]s won't understand. Have to fake it.\n+unsafe fn taskgroup_key() -> local_data_key<taskgroup> {\n+    // Use a \"code pointer\" value that will never be a real code pointer.\n+    unsafe::transmute((-2 as uint, 0u))\n+}\n+\n fn share_parent_taskgroup() -> (taskgroup_arc, bool) {\n     let me = rustrt::rust_get_task();\n-    alt unsafe { local_get(me, taskgroup_key) } {\n+    alt unsafe { local_get(me, taskgroup_key()) } {\n         some(group) {\n             // Clone the shared state for the child; propagate main-ness.\n             (group.tasks.clone(), group.is_main)\n@@ -693,7 +698,7 @@ fn share_parent_taskgroup() -> (taskgroup_arc, bool) {\n             // Main task, doing first spawn ever.\n             let tasks = arc::exclusive(some(dvec::from_elem(some(me))));\n             let group = @taskgroup(tasks.clone(), me, 0, true);\n-            unsafe { local_set(me, taskgroup_key, group); }\n+            unsafe { local_set(me, taskgroup_key(), group); }\n             // Tell child task it's also in the main group.\n             (tasks, true)\n         }\n@@ -764,12 +769,13 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n                 some(my_index) {\n                     let group =\n                         @taskgroup(child_tg, child_task, my_index, is_main);\n-                    unsafe { local_set(child_task, taskgroup_key, group); }\n+                    unsafe { local_set(child_task, taskgroup_key(), group); }\n                     // Run the child's body.\n                     f();\n                     // TLS cleanup code will exit the taskgroup.\n                 }\n-                none { }\n+                none {\n+                }\n             }\n         }\n     }\n@@ -820,34 +826,30 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n  ****************************************************************************/\n \n /**\n- * Indexes a task-local data slot. The function itself is used to\n- * automatically finalise stored values; also, its code pointer is used for\n+ * Indexes a task-local data slot. The function's code pointer is used for\n  * comparison. Recommended use is to write an empty function for each desired\n- * task-local data slot (and use class destructors, instead of code inside the\n- * finaliser, if specific teardown is needed). DO NOT use multiple\n+ * task-local data slot (and use class destructors, not code inside the\n+ * function, if specific teardown is needed). DO NOT use multiple\n  * instantiations of a single polymorphic function to index data of different\n  * types; arbitrary type coercion is possible this way. The interface is safe\n  * as long as all key functions are monomorphic.\n  */\n type local_data_key<T> = fn@(+@T);\n \n+iface local_data { }\n+impl<T> of local_data for @T { }\n+\n // We use dvec because it's the best data structure in core. If TLS is used\n // heavily in future, this could be made more efficient with a proper map.\n-type task_local_element = (*libc::c_void, *libc::c_void, fn@(+*libc::c_void));\n+type task_local_element = (*libc::c_void, *libc::c_void, local_data);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n type task_local_map = @dvec::dvec<option<task_local_element>>;\n \n extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n     assert !map_ptr.is_null();\n     // Get and keep the single reference that was created at the beginning.\n-    let map: task_local_map = unsafe::reinterpret_cast(map_ptr);\n-    for (*map).each |entry| {\n-        alt entry {\n-            // Finaliser drops data. We drop the finaliser implicitly here.\n-            some((_key, data, finalise_fn)) { finalise_fn(data); }\n-            none { }\n-        }\n-    }\n+    let _map: task_local_map = unsafe::reinterpret_cast(map_ptr);\n+    // All local_data will be destroyed along with the map.\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n@@ -881,15 +883,15 @@ unsafe fn key_to_key_value<T>(key: local_data_key<T>) -> *libc::c_void {\n \n // If returning some(..), returns with @T with the map's reference. Careful!\n unsafe fn local_data_lookup<T>(map: task_local_map, key: local_data_key<T>)\n-        -> option<(uint, *libc::c_void, fn@(+*libc::c_void))> {\n+        -> option<(uint, *libc::c_void)> {\n     let key_value = key_to_key_value(key);\n     let map_pos = (*map).position(|entry|\n         alt entry { some((k,_,_)) { k == key_value } none { false } }\n     );\n     do map_pos.map |index| {\n         // .get() is guaranteed because of \"none { false }\" above.\n-        let (_, data_ptr, finaliser) = (*map)[index].get();\n-        (index, data_ptr, finaliser)\n+        let (_, data_ptr, _) = (*map)[index].get();\n+        (index, data_ptr)\n     }\n }\n \n@@ -898,15 +900,15 @@ unsafe fn local_get_helper<T>(task: *rust_task, key: local_data_key<T>,\n     let map = get_task_local_map(task);\n     // Interpret our findings from the map\n     do local_data_lookup(map, key).map |result| {\n-        // A reference count magically appears on 'data' out of thin air.\n-        // 'data' has the reference we originally stored it with. We either\n-        // need to erase it from the map or artificially bump the count.\n-        let (index, data_ptr, _) = result;\n+        // A reference count magically appears on 'data' out of thin air. It\n+        // was referenced in the local_data box, though, not here, so before\n+        // overwriting the local_data_box we need to give an extra reference.\n+        // We must also give an extra reference when not removing.\n+        let (index, data_ptr) = result;\n         let data: @T = unsafe::transmute(data_ptr);\n+        unsafe::bump_box_refcount(data);\n         if do_pop {\n             (*map).set_elt(index, none);\n-        } else {\n-            unsafe::bump_box_refcount(data);\n         }\n         data\n     }\n@@ -926,20 +928,20 @@ unsafe fn local_set<T>(task: *rust_task, key: local_data_key<T>, +data: @T) {\n     let map = get_task_local_map(task);\n     // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n     let keyval = key_to_key_value(key);\n-    let data_ptr = unsafe::transmute(data);\n-    // Finaliser is called at task exit to de-reference up remaining entries.\n-    let finaliser: fn@(+*libc::c_void) = unsafe::reinterpret_cast(key);\n+    // We keep the data in two forms: one as an unsafe pointer, so we can get\n+    // it back by casting; another in an existential box, so the reference we\n+    // own on it can be dropped when the box is destroyed. The unsafe pointer\n+    // does not have a reference associated with it, so it may become invalid\n+    // when the box is destroyed.\n+    let data_ptr = unsafe::reinterpret_cast(data);\n+    let data_box = data as local_data;\n     // Construct new entry to store in the map.\n-    let new_entry = some((keyval, data_ptr, finaliser));\n+    let new_entry = some((keyval, data_ptr, data_box));\n     // Find a place to put it.\n     alt local_data_lookup(map, key) {\n-        some((index, old_data_ptr, old_finaliser)) {\n-            // Key already had a value set, old_data_ptr, whose reference we\n-            // need to drop. After that, overwriting its slot will be safe.\n-            // (The heap-allocated finaliser will be freed in the overwrite.)\n-            // FIXME(#2734): just transmuting old_data_ptr to @T doesn't work,\n-            // similarly to the sample there (but more our/unsafety's fault?).\n-            old_finaliser(old_data_ptr);\n+        some((index, _old_data_ptr)) {\n+            // Key already had a value set, _old_data_ptr, whose reference\n+            // will get dropped when the local_data box is overwritten.\n             (*map).set_elt(index, new_entry);\n         }\n         none {"}]}