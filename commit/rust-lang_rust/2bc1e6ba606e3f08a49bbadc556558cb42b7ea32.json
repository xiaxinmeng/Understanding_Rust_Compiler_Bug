{"sha": "2bc1e6ba606e3f08a49bbadc556558cb42b7ea32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYzFlNmJhNjA2ZTNmMDhhNDliYmFkYzU1NjU1OGNiNDJiN2VhMzI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-14T02:14:14Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-15T19:19:16Z"}, "message": "core::rt: Copy many of the old io extensions to the new io\n\nSome resolve problem is keeping the tests from working", "tree": {"sha": "353648e2a0811c1f7850ebf05a5fc6d561ed4fe7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/353648e2a0811c1f7850ebf05a5fc6d561ed4fe7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bc1e6ba606e3f08a49bbadc556558cb42b7ea32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc1e6ba606e3f08a49bbadc556558cb42b7ea32", "html_url": "https://github.com/rust-lang/rust/commit/2bc1e6ba606e3f08a49bbadc556558cb42b7ea32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bc1e6ba606e3f08a49bbadc556558cb42b7ea32/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d45dc8df7278649d101ce28fae1d934559e0e3c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d45dc8df7278649d101ce28fae1d934559e0e3c2", "html_url": "https://github.com/rust-lang/rust/commit/d45dc8df7278649d101ce28fae1d934559e0e3c2"}], "stats": {"total": 340, "additions": 334, "deletions": 6}, "files": [{"sha": "a3804d2d6ef1ac361e5d5f2f03cceed27d5b1f62", "filename": "src/libcore/rt/io/extensions.rs", "status": "modified", "additions": 334, "deletions": 6, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/2bc1e6ba606e3f08a49bbadc556558cb42b7ea32/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc1e6ba606e3f08a49bbadc556558cb42b7ea32/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fextensions.rs?ref=2bc1e6ba606e3f08a49bbadc556558cb42b7ea32", "patch": "@@ -13,11 +13,16 @@\n // XXX: Not sure how this should be structured\n // XXX: Iteration should probably be considered separately\n \n+use uint;\n+use int;\n use vec;\n-use rt::io::{Reader, read_error, standard_error, EndOfFile, DEFAULT_BUF_SIZE};\n+use rt::io::{Reader, Writer};\n+use rt::io::{read_error, standard_error, EndOfFile, DEFAULT_BUF_SIZE};\n use option::{Option, Some, None};\n use unstable::finally::Finally;\n use util;\n+use cast;\n+use io::{u64_to_le_bytes, u64_to_be_bytes};\n \n pub trait ReaderUtil {\n \n@@ -212,7 +217,7 @@ pub trait WriterByteConversions {\n     fn write_be_int(&mut self, n: int);\n \n     /// Write a big-endian u64 (8 bytes).\n-    fn write_be_u64(&mut self, n: u64);\n+    fn write_be_u64_(&mut self, n: u64);\n \n     /// Write a big-endian u32 (4 bytes).\n     fn write_be_u32(&mut self, n: u32);\n@@ -236,7 +241,7 @@ pub trait WriterByteConversions {\n     fn write_be_f32(&mut self, f: f32);\n \n     /// Write a little-endian u64 (8 bytes).\n-    fn write_le_u64(&mut self, n: u64);\n+    fn write_le_u64_(&mut self, n: u64);\n \n     /// Write a little-endian u32 (4 bytes).\n     fn write_le_u32(&mut self, n: u32);\n@@ -333,13 +338,262 @@ impl<T: Reader> ReaderUtil for T {\n     }\n }\n \n+impl<T: Reader> ReaderByteConversions for T {\n+    fn read_le_uint_n(&mut self, nbytes: uint) -> u64 {\n+        assert!(nbytes > 0 && nbytes <= 8);\n+\n+        let mut val = 0u64, pos = 0, i = nbytes;\n+        while i > 0 {\n+            val += (self.read_u8() as u64) << pos;\n+            pos += 8;\n+            i -= 1;\n+        }\n+        val\n+    }\n+\n+    fn read_le_int_n(&mut self, nbytes: uint) -> i64 {\n+        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n+    }\n+\n+    fn read_be_uint_n(&mut self, nbytes: uint) -> u64 {\n+        assert!(nbytes > 0 && nbytes <= 8);\n+\n+        let mut val = 0u64, i = nbytes;\n+        while i > 0 {\n+            i -= 1;\n+            val += (self.read_u8() as u64) << i * 8;\n+        }\n+        val\n+    }\n+\n+    fn read_be_int_n(&mut self, nbytes: uint) -> i64 {\n+        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n+    }\n+\n+    fn read_le_uint(&mut self) -> uint {\n+        self.read_le_uint_n(uint::bytes) as uint\n+    }\n+\n+    fn read_le_int(&mut self) -> int {\n+        self.read_le_int_n(int::bytes) as int\n+    }\n+\n+    fn read_be_uint(&mut self) -> uint {\n+        self.read_be_uint_n(uint::bytes) as uint\n+    }\n+\n+    fn read_be_int(&mut self) -> int {\n+        self.read_be_int_n(int::bytes) as int\n+    }\n+\n+    fn read_be_u64(&mut self) -> u64 {\n+        self.read_be_uint_n(8) as u64\n+    }\n+\n+    fn read_be_u32(&mut self) -> u32 {\n+        self.read_be_uint_n(4) as u32\n+    }\n+\n+    fn read_be_u16(&mut self) -> u16 {\n+        self.read_be_uint_n(2) as u16\n+    }\n+\n+    fn read_be_i64(&mut self) -> i64 {\n+        self.read_be_int_n(8) as i64\n+    }\n+\n+    fn read_be_i32(&mut self) -> i32 {\n+        self.read_be_int_n(4) as i32\n+    }\n+\n+    fn read_be_i16(&mut self) -> i16 {\n+        self.read_be_int_n(2) as i16\n+    }\n+\n+    fn read_be_f64(&mut self) -> f64 {\n+        unsafe {\n+            cast::transmute::<u64, f64>(self.read_be_u64())\n+        }\n+    }\n+\n+    fn read_be_f32(&mut self) -> f32 {\n+        unsafe {\n+            cast::transmute::<u32, f32>(self.read_be_u32())\n+        }\n+    }\n+\n+    fn read_le_u64(&mut self) -> u64 {\n+        self.read_le_uint_n(8) as u64\n+    }\n+\n+    fn read_le_u32(&mut self) -> u32 {\n+        self.read_le_uint_n(4) as u32\n+    }\n+\n+    fn read_le_u16(&mut self) -> u16 {\n+        self.read_le_uint_n(2) as u16\n+    }\n+\n+    fn read_le_i64(&mut self) -> i64 {\n+        self.read_le_int_n(8) as i64\n+    }\n+\n+    fn read_le_i32(&mut self) -> i32 {\n+        self.read_le_int_n(4) as i32\n+    }\n+\n+    fn read_le_i16(&mut self) -> i16 {\n+        self.read_le_int_n(2) as i16\n+    }\n+\n+    fn read_le_f64(&mut self) -> f64 {\n+        unsafe {\n+            cast::transmute::<u64, f64>(self.read_le_u64())\n+        }\n+    }\n+\n+    fn read_le_f32(&mut self) -> f32 {\n+        unsafe {\n+            cast::transmute::<u32, f32>(self.read_le_u32())\n+        }\n+    }\n+\n+    fn read_u8(&mut self) -> u8 {\n+        match self.read_byte() {\n+            Some(b) => b as u8,\n+            None => 0\n+        }\n+    }\n+\n+    fn read_i8(&mut self) -> i8 {\n+        match self.read_byte() {\n+            Some(b) => b as i8,\n+            None => 0\n+        }\n+    }\n+\n+}\n+\n+impl<T: Writer> WriterByteConversions for T {\n+    fn write_int(&mut self, n: int) {\n+        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n+    }\n+\n+    fn write_uint(&mut self, n: uint) {\n+        uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n+    }\n+\n+    fn write_le_uint(&mut self, n: uint) {\n+        u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_le_int(&mut self, n: int) {\n+        u64_to_le_bytes(n as u64, int::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_be_uint(&mut self, n: uint) {\n+        u64_to_be_bytes(n as u64, uint::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_be_int(&mut self, n: int) {\n+        u64_to_be_bytes(n as u64, int::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_be_u64_(&mut self, n: u64) {\n+        u64_to_be_bytes(n, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_be_u32(&mut self, n: u32) {\n+        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_be_u16(&mut self, n: u16) {\n+        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_be_i64(&mut self, n: i64) {\n+        u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_be_i32(&mut self, n: i32) {\n+        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_be_i16(&mut self, n: i16) {\n+        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_be_f64(&mut self, f: f64) {\n+        unsafe {\n+            self.write_be_u64_(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_be_f32(&mut self, f: f32) {\n+        unsafe {\n+            self.write_be_u32(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_le_u64_(&mut self, n: u64) {\n+        u64_to_le_bytes(n, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_le_u32(&mut self, n: u32) {\n+        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_le_u16(&mut self, n: u16) {\n+        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_le_i64(&mut self, n: i64) {\n+        u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_le_i32(&mut self, n: i32) {\n+        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_le_i16(&mut self, n: i16) {\n+        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_le_f64(&mut self, f: f64) {\n+        unsafe {\n+            self.write_le_u64_(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_le_f32(&mut self, f: f32) {\n+        unsafe {\n+            self.write_le_u32(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_u8(&mut self, n: u8) {\n+        self.write([n]) \n+    }\n+\n+    fn write_i8(&mut self, n: i8) {\n+        self.write([n as u8]) \n+    }\n+}\n+\n+fn extend_sign(val: u64, nbytes: uint) -> i64 {\n+    let shift = (8 - nbytes) * 8;\n+    (val << shift) as i64 >> shift\n+}\n+\n #[cfg(test)]\n mod test {\n-    use super::*;\n+    use super::{ReaderUtil, ReaderByteConversions, WriterByteConversions};\n+    use u64;\n+    use i32;\n     use option::{Some, None};\n     use cell::Cell;\n-    use rt::io::mem::MemReader;\n-    use rt::io::mock::*;\n+    use rt::io::mem::{MemReader, MemWriter};\n+    use rt::io::mock::MockReader;\n     use rt::io::{read_error, placeholder_error};\n \n     #[test]\n@@ -572,4 +826,78 @@ mod test {\n         assert!(buf == ~[10, 11]);\n     }\n \n+    // XXX: Some problem with resolve here\n+    /*#[test]\n+    fn test_read_write_le() {\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+\n+        let mut writer = MemWriter::new();\n+        for uints.each |i| {\n+            writer.write_le_u64(*i);\n+        }\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        for uints.each |i| {\n+            assert!(reader.read_le_u64() == *i);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_write_be() {\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+\n+        let mut writer = MemWriter::new();\n+        for uints.each |i| {\n+            writer.write_be_u64(*i);\n+        }\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        for uints.each |i| {\n+            assert!(reader.read_be_u64() == *i);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_be_int_n() {\n+        let ints = [i32::min_value, -123456, -42, -5, 0, 1, i32::max_value];\n+\n+        let mut writer = MemWriter::new();\n+        for ints.each |i| {\n+            writer.write_be_i32(*i);\n+        }\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        for ints.each |i| {\n+            // this tests that the sign extension is working\n+            // (comparing the values as i32 would not test this)\n+            assert!(reader.read_be_int_n(4) == *i as i64);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_f32() {\n+        //big-endian floating-point 8.1250\n+        let buf = ~[0x41, 0x02, 0x00, 0x00];\n+\n+        let mut writer = MemWriter::new();\n+        writer.write(buf);\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        let f = reader.read_be_f32();\n+        assert!(f == 8.1250);\n+    }\n+\n+    #[test]\n+    fn test_read_write_f32() {\n+        let f:f32 = 8.1250;\n+\n+        let mut writer = MemWriter::new();\n+        writer.write_be_f32(f);\n+        writer.write_le_f32(f);\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        assert!(reader.read_be_f32() == 8.1250);\n+        assert!(reader.read_le_f32() == 8.1250);\n+    }*/\n+\n }"}]}