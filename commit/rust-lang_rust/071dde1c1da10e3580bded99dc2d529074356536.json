{"sha": "071dde1c1da10e3580bded99dc2d529074356536", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MWRkZTFjMWRhMTBlMzU4MGJkZWQ5OWRjMmQ1MjkwNzQzNTY1MzY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-08T17:37:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-08T17:37:43Z"}, "message": "Merge #7921\n\n7921: Don't punish every crate with serde-json r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "360aae1dc872b22a71014f253e3a98f21a3502a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/360aae1dc872b22a71014f253e3a98f21a3502a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/071dde1c1da10e3580bded99dc2d529074356536", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgRmDnCRBK7hj4Ov3rIwAAdHIIAAZrK0urlm5FTFx4jpupxRAz\nOIGH8i3TNj6Xr1wO82OCa2qc5WPB+FrV6LsjQ5njW34o+9tol3ZVP104RmfEakTo\n3vnI09BFYulYAvbVwkVb2kfX5r+b1fxVz3sCQPTADacBpvNEJjklVGjBGQhYzMZg\ncL5+cwxd39Tgkf/XfrdOpdoL2iZOE/UvEcUNgBpP1zg01DWlPUPljC8x8rDPJ8C8\nhw3bDtVWwDo6mwe5xHOxpQ0WoJsELDEl8M8ovKNrCQBIE6+agALdcqJttktPzeeo\nvrIxeDaeyuPqdSyG9ttc/7AO3BFWT2y9LM3tEoUYQiabsLAK7eIPlYNA1TVUFQQ=\n=/5gf\n-----END PGP SIGNATURE-----\n", "payload": "tree 360aae1dc872b22a71014f253e3a98f21a3502a6\nparent d57c9f79801762aa23adc21adbb638678268e96b\nparent da73c93c7f6d841496e75a16531d9be4aa23cada\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615225063 +0000\ncommitter GitHub <noreply@github.com> 1615225063 +0000\n\nMerge #7921\n\n7921: Don't punish every crate with serde-json r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/071dde1c1da10e3580bded99dc2d529074356536", "html_url": "https://github.com/rust-lang/rust/commit/071dde1c1da10e3580bded99dc2d529074356536", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/071dde1c1da10e3580bded99dc2d529074356536/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d57c9f79801762aa23adc21adbb638678268e96b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d57c9f79801762aa23adc21adbb638678268e96b", "html_url": "https://github.com/rust-lang/rust/commit/d57c9f79801762aa23adc21adbb638678268e96b"}, {"sha": "da73c93c7f6d841496e75a16531d9be4aa23cada", "url": "https://api.github.com/repos/rust-lang/rust/commits/da73c93c7f6d841496e75a16531d9be4aa23cada", "html_url": "https://github.com/rust-lang/rust/commit/da73c93c7f6d841496e75a16531d9be4aa23cada"}], "stats": {"total": 195, "additions": 96, "deletions": 99}, "files": [{"sha": "15ed1da8e9d91c9632e8833aa61a56811b7f0071", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/071dde1c1da10e3580bded99dc2d529074356536/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/071dde1c1da10e3580bded99dc2d529074356536/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=071dde1c1da10e3580bded99dc2d529074356536", "patch": "@@ -1612,7 +1612,6 @@ dependencies = [\n  \"dissimilar\",\n  \"profile\",\n  \"rustc-hash\",\n- \"serde_json\",\n  \"stdx\",\n  \"text-size\",\n ]"}, {"sha": "cd0c914817e644978cfdb873abe8b831d71f336a", "filename": "crates/rust-analyzer/tests/rust-analyzer/support.rs", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/071dde1c1da10e3580bded99dc2d529074356536/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071dde1c1da10e3580bded99dc2d529074356536/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs?ref=071dde1c1da10e3580bded99dc2d529074356536", "patch": "@@ -13,7 +13,7 @@ use project_model::ProjectManifest;\n use rust_analyzer::{config::Config, lsp_ext, main_loop};\n use serde::Serialize;\n use serde_json::{json, to_string_pretty, Value};\n-use test_utils::{find_mismatch, Fixture};\n+use test_utils::Fixture;\n use vfs::AbsPathBuf;\n \n use crate::testdir::TestDir;\n@@ -279,3 +279,98 @@ fn recv_timeout(receiver: &Receiver<Message>) -> Result<Option<Message>, Timeout\n         recv(after(timeout)) -> _ => Err(Timeout),\n     }\n }\n+\n+// Comparison functionality borrowed from cargo:\n+\n+/// Compares JSON object for approximate equality.\n+/// You can use `[..]` wildcard in strings (useful for OS dependent things such\n+/// as paths). You can use a `\"{...}\"` string literal as a wildcard for\n+/// arbitrary nested JSON. Arrays are sorted before comparison.\n+fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a Value, &'a Value)> {\n+    match (expected, actual) {\n+        (Value::Number(l), Value::Number(r)) if l == r => None,\n+        (Value::Bool(l), Value::Bool(r)) if l == r => None,\n+        (Value::String(l), Value::String(r)) if lines_match(l, r) => None,\n+        (Value::Array(l), Value::Array(r)) => {\n+            if l.len() != r.len() {\n+                return Some((expected, actual));\n+            }\n+\n+            let mut l = l.iter().collect::<Vec<_>>();\n+            let mut r = r.iter().collect::<Vec<_>>();\n+\n+            l.retain(|l| match r.iter().position(|r| find_mismatch(l, r).is_none()) {\n+                Some(i) => {\n+                    r.remove(i);\n+                    false\n+                }\n+                None => true,\n+            });\n+\n+            if !l.is_empty() {\n+                assert!(!r.is_empty());\n+                Some((&l[0], &r[0]))\n+            } else {\n+                assert_eq!(r.len(), 0);\n+                None\n+            }\n+        }\n+        (Value::Object(l), Value::Object(r)) => {\n+            fn sorted_values(obj: &serde_json::Map<String, Value>) -> Vec<&Value> {\n+                let mut entries = obj.iter().collect::<Vec<_>>();\n+                entries.sort_by_key(|it| it.0);\n+                entries.into_iter().map(|(_k, v)| v).collect::<Vec<_>>()\n+            }\n+\n+            let same_keys = l.len() == r.len() && l.keys().all(|k| r.contains_key(k));\n+            if !same_keys {\n+                return Some((expected, actual));\n+            }\n+\n+            let l = sorted_values(l);\n+            let r = sorted_values(r);\n+\n+            l.into_iter().zip(r).filter_map(|(l, r)| find_mismatch(l, r)).next()\n+        }\n+        (Value::Null, Value::Null) => None,\n+        // magic string literal \"{...}\" acts as wildcard for any sub-JSON\n+        (Value::String(l), _) if l == \"{...}\" => None,\n+        _ => Some((expected, actual)),\n+    }\n+}\n+\n+/// Compare a line with an expected pattern.\n+/// - Use `[..]` as a wildcard to match 0 or more characters on the same line\n+///   (similar to `.*` in a regex).\n+fn lines_match(expected: &str, actual: &str) -> bool {\n+    // Let's not deal with / vs \\ (windows...)\n+    // First replace backslash-escaped backslashes with forward slashes\n+    // which can occur in, for example, JSON output\n+    let expected = expected.replace(r\"\\\\\", \"/\").replace(r\"\\\", \"/\");\n+    let mut actual: &str = &actual.replace(r\"\\\\\", \"/\").replace(r\"\\\", \"/\");\n+    for (i, part) in expected.split(\"[..]\").enumerate() {\n+        match actual.find(part) {\n+            Some(j) => {\n+                if i == 0 && j != 0 {\n+                    return false;\n+                }\n+                actual = &actual[j + part.len()..];\n+            }\n+            None => return false,\n+        }\n+    }\n+    actual.is_empty() || expected.ends_with(\"[..]\")\n+}\n+\n+#[test]\n+fn lines_match_works() {\n+    assert!(lines_match(\"a b\", \"a b\"));\n+    assert!(lines_match(\"a[..]b\", \"a b\"));\n+    assert!(lines_match(\"a[..]\", \"a b\"));\n+    assert!(lines_match(\"[..]\", \"a b\"));\n+    assert!(lines_match(\"[..]b\", \"a b\"));\n+\n+    assert!(!lines_match(\"[..]b\", \"c\"));\n+    assert!(!lines_match(\"b\", \"c\"));\n+    assert!(!lines_match(\"b\", \"cb\"));\n+}"}, {"sha": "87bab7a08620e2f48824ae170d471cfa883abe0b", "filename": "crates/test_utils/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/071dde1c1da10e3580bded99dc2d529074356536/crates%2Ftest_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/071dde1c1da10e3580bded99dc2d529074356536/crates%2Ftest_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2FCargo.toml?ref=071dde1c1da10e3580bded99dc2d529074356536", "patch": "@@ -13,7 +13,6 @@ doctest = false\n # Avoid adding deps here, this crate is widely used in tests it should compile fast!\n dissimilar = \"1.0.2\"\n text-size = \"1.0.0\"\n-serde_json = \"1.0.48\"\n rustc-hash = \"1.1.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "27b05e34b0c7f89bcac42c652867abfba37b2ae3", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/071dde1c1da10e3580bded99dc2d529074356536/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071dde1c1da10e3580bded99dc2d529074356536/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=071dde1c1da10e3580bded99dc2d529074356536", "patch": "@@ -18,7 +18,6 @@ use std::{\n };\n \n use profile::StopWatch;\n-use serde_json::Value;\n use stdx::lines_with_ends;\n use text_size::{TextRange, TextSize};\n \n@@ -281,101 +280,6 @@ fn main() {\n     );\n }\n \n-// Comparison functionality borrowed from cargo:\n-\n-/// Compare a line with an expected pattern.\n-/// - Use `[..]` as a wildcard to match 0 or more characters on the same line\n-///   (similar to `.*` in a regex).\n-pub fn lines_match(expected: &str, actual: &str) -> bool {\n-    // Let's not deal with / vs \\ (windows...)\n-    // First replace backslash-escaped backslashes with forward slashes\n-    // which can occur in, for example, JSON output\n-    let expected = expected.replace(r\"\\\\\", \"/\").replace(r\"\\\", \"/\");\n-    let mut actual: &str = &actual.replace(r\"\\\\\", \"/\").replace(r\"\\\", \"/\");\n-    for (i, part) in expected.split(\"[..]\").enumerate() {\n-        match actual.find(part) {\n-            Some(j) => {\n-                if i == 0 && j != 0 {\n-                    return false;\n-                }\n-                actual = &actual[j + part.len()..];\n-            }\n-            None => return false,\n-        }\n-    }\n-    actual.is_empty() || expected.ends_with(\"[..]\")\n-}\n-\n-#[test]\n-fn lines_match_works() {\n-    assert!(lines_match(\"a b\", \"a b\"));\n-    assert!(lines_match(\"a[..]b\", \"a b\"));\n-    assert!(lines_match(\"a[..]\", \"a b\"));\n-    assert!(lines_match(\"[..]\", \"a b\"));\n-    assert!(lines_match(\"[..]b\", \"a b\"));\n-\n-    assert!(!lines_match(\"[..]b\", \"c\"));\n-    assert!(!lines_match(\"b\", \"c\"));\n-    assert!(!lines_match(\"b\", \"cb\"));\n-}\n-\n-/// Compares JSON object for approximate equality.\n-/// You can use `[..]` wildcard in strings (useful for OS dependent things such\n-/// as paths). You can use a `\"{...}\"` string literal as a wildcard for\n-/// arbitrary nested JSON. Arrays are sorted before comparison.\n-pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a Value, &'a Value)> {\n-    match (expected, actual) {\n-        (Value::Number(l), Value::Number(r)) if l == r => None,\n-        (Value::Bool(l), Value::Bool(r)) if l == r => None,\n-        (Value::String(l), Value::String(r)) if lines_match(l, r) => None,\n-        (Value::Array(l), Value::Array(r)) => {\n-            if l.len() != r.len() {\n-                return Some((expected, actual));\n-            }\n-\n-            let mut l = l.iter().collect::<Vec<_>>();\n-            let mut r = r.iter().collect::<Vec<_>>();\n-\n-            l.retain(|l| match r.iter().position(|r| find_mismatch(l, r).is_none()) {\n-                Some(i) => {\n-                    r.remove(i);\n-                    false\n-                }\n-                None => true,\n-            });\n-\n-            if !l.is_empty() {\n-                assert!(!r.is_empty());\n-                Some((&l[0], &r[0]))\n-            } else {\n-                assert_eq!(r.len(), 0);\n-                None\n-            }\n-        }\n-        (Value::Object(l), Value::Object(r)) => {\n-            fn sorted_values(obj: &serde_json::Map<String, Value>) -> Vec<&Value> {\n-                let mut entries = obj.iter().collect::<Vec<_>>();\n-                entries.sort_by_key(|it| it.0);\n-                entries.into_iter().map(|(_k, v)| v).collect::<Vec<_>>()\n-            }\n-\n-            let same_keys = l.len() == r.len() && l.keys().all(|k| r.contains_key(k));\n-            if !same_keys {\n-                return Some((expected, actual));\n-            }\n-\n-            let l = sorted_values(l);\n-            let r = sorted_values(r);\n-\n-            l.into_iter().zip(r).filter_map(|(l, r)| find_mismatch(l, r)).next()\n-        }\n-        (Value::Null, Value::Null) => None,\n-        // magic string literal \"{...}\" acts as wildcard for any sub-JSON\n-        (Value::String(l), _) if l == \"{...}\" => None,\n-        _ => Some((expected, actual)),\n-    }\n-}\n-\n /// Returns `false` if slow tests should not run, otherwise returns `true` and\n /// also creates a file at `./target/.slow_tests_cookie` which serves as a flag\n /// that slow tests did run."}]}