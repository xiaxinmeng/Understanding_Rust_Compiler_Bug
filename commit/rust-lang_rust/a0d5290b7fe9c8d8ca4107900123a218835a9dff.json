{"sha": "a0d5290b7fe9c8d8ca4107900123a218835a9dff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZDUyOTBiN2ZlOWM4ZDhjYTQxMDc5MDAxMjNhMjE4ODM1YTlkZmY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-19T16:53:25Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-21T20:21:27Z"}, "message": "Show try operator propogated types on ranged hover", "tree": {"sha": "2ab0bf72634ae42ebe8ef69530244d6d65cd157f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ab0bf72634ae42ebe8ef69530244d6d65cd157f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0d5290b7fe9c8d8ca4107900123a218835a9dff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0d5290b7fe9c8d8ca4107900123a218835a9dff", "html_url": "https://github.com/rust-lang/rust/commit/a0d5290b7fe9c8d8ca4107900123a218835a9dff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0d5290b7fe9c8d8ca4107900123a218835a9dff/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95923c7b2997f479d36a2712ead123123fd962d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/95923c7b2997f479d36a2712ead123123fd962d8", "html_url": "https://github.com/rust-lang/rust/commit/95923c7b2997f479d36a2712ead123123fd962d8"}], "stats": {"total": 209, "additions": 198, "deletions": 11}, "files": [{"sha": "016d38b1eb8d35ba011de091ffb0a6ddf5fa2220", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 198, "deletions": 11, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/a0d5290b7fe9c8d8ca4107900123a218835a9dff/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d5290b7fe9c8d8ca4107900123a218835a9dff/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=a0d5290b7fe9c8d8ca4107900123a218835a9dff", "patch": "@@ -12,8 +12,8 @@ use ide_db::{\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n-    algo, ast, display::fn_as_proc_macro_label, match_ast, AstNode, AstToken, Direction,\n-    SyntaxKind::*, SyntaxNode, SyntaxToken, T,\n+    algo, ast, display::fn_as_proc_macro_label, match_ast, AstNode, Direction, SyntaxKind::*,\n+    SyntaxNode, SyntaxToken, T,\n };\n \n use crate::{\n@@ -112,9 +112,8 @@ pub(crate) fn hover(\n         _ => 1,\n     })?;\n     let token = sema.descend_into_macros(token);\n-\n-    let mut range_override = None;\n     let node = token.parent()?;\n+    let mut range_override = None;\n     let definition = match_ast! {\n         match node {\n             ast::Name(name) => NameClass::classify(&sema, &name).map(|class| match class {\n@@ -138,7 +137,7 @@ pub(crate) fn hover(\n             ),\n             _ => {\n                 // intra-doc links\n-                if ast::Comment::cast(token.clone()).is_some() {\n+                if token.kind() == COMMENT {\n                     cov_mark::hit!(no_highlight_on_comment_hover);\n                     let (attributes, def) = doc_attributes(&sema, &node)?;\n                     let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n@@ -233,7 +232,7 @@ fn hover_ranged(\n     sema: &Semantics<RootDatabase>,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n-    let expr = file.covering_element(range).ancestors().find_map(|it| {\n+    let expr_or_pat = file.covering_element(range).ancestors().find_map(|it| {\n         match_ast! {\n             match it {\n                 ast::Expr(expr) => Some(Either::Left(expr)),\n@@ -242,15 +241,110 @@ fn hover_ranged(\n             }\n         }\n     })?;\n-    hover_type_info(sema, config, &expr).map(|it| {\n-        let range = match expr {\n+    let res = match &expr_or_pat {\n+        Either::Left(ast::Expr::TryExpr(try_expr)) => hover_try_expr(sema, config, try_expr),\n+        _ => None,\n+    };\n+    let res = res.or_else(|| hover_type_info(sema, config, &expr_or_pat));\n+    res.map(|it| {\n+        let range = match expr_or_pat {\n             Either::Left(it) => it.syntax().text_range(),\n             Either::Right(it) => it.syntax().text_range(),\n         };\n         RangeInfo::new(range, it)\n     })\n }\n \n+fn hover_try_expr(\n+    sema: &Semantics<RootDatabase>,\n+    config: &HoverConfig,\n+    try_expr: &ast::TryExpr,\n+) -> Option<HoverResult> {\n+    let inner_ty = sema.type_of_expr(&try_expr.expr()?)?.original;\n+    let mut ancestors = try_expr.syntax().ancestors();\n+    let mut body_ty = loop {\n+        let next = ancestors.next()?;\n+        break match_ast! {\n+            match next {\n+                ast::Fn(fn_) => sema.to_def(&fn_)?.ret_type(sema.db),\n+                ast::Item(__) => return None,\n+                ast::ClosureExpr(closure) => sema.type_of_expr(&closure.body()?)?.original,\n+                ast::EffectExpr(effect) => if matches!(effect.effect(), ast::Effect::Async(_) | ast::Effect::Try(_)| ast::Effect::Const(_)) {\n+                    sema.type_of_expr(&effect.block_expr()?.into())?.original\n+                } else {\n+                    continue;\n+                },\n+                _ => continue,\n+            }\n+        };\n+    };\n+\n+    if inner_ty == body_ty {\n+        return None;\n+    }\n+\n+    let mut inner_ty = inner_ty;\n+    let mut s = \"Try Target\".to_owned();\n+\n+    let adts = inner_ty.as_adt().zip(body_ty.as_adt());\n+    if let Some((hir::Adt::Enum(inner), hir::Adt::Enum(body))) = adts {\n+        let famous_defs = FamousDefs(sema, sema.scope(&try_expr.syntax()).krate());\n+        // special case for two options, there is no value in showing them\n+        if let Some(option_enum) = famous_defs.core_option_Option() {\n+            if inner == option_enum && body == option_enum {\n+                return None;\n+            }\n+        }\n+\n+        // special case two results to show the error variants only\n+        if let Some(result_enum) = famous_defs.core_result_Result() {\n+            if inner == result_enum && body == result_enum {\n+                let error_type_args =\n+                    inner_ty.type_arguments().nth(1).zip(body_ty.type_arguments().nth(1));\n+                if let Some((inner, body)) = error_type_args {\n+                    inner_ty = inner;\n+                    body_ty = body;\n+                    s = \"Try Error\".to_owned();\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut res = HoverResult::default();\n+\n+    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+    let mut push_new_def = |item: hir::ModuleDef| {\n+        if !targets.contains(&item) {\n+            targets.push(item);\n+        }\n+    };\n+    walk_and_push_ty(sema.db, &inner_ty, &mut push_new_def);\n+    walk_and_push_ty(sema.db, &body_ty, &mut push_new_def);\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n+\n+    let inner_ty = inner_ty.display(sema.db).to_string();\n+    let body_ty = body_ty.display(sema.db).to_string();\n+    let ty_len_max = inner_ty.len().max(body_ty.len());\n+\n+    // \"Propagated as: \".len() - \" Type: \".len() = 8\n+    let static_test_len_diff = 8 - s.len() as isize;\n+    let tpad = static_test_len_diff.max(0) as usize;\n+    let ppad = static_test_len_diff.min(0).abs() as usize;\n+\n+    res.markup = format!(\n+        \"{bt_start}{} Type: {:>pad0$}\\nPropagated as: {:>pad1$}\\n{bt_end}\",\n+        s,\n+        inner_ty,\n+        body_ty,\n+        pad0 = ty_len_max + tpad,\n+        pad1 = ty_len_max + ppad,\n+        bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n+        bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n+    )\n+    .into();\n+    Some(res)\n+}\n+\n fn hover_type_info(\n     sema: &Semantics<RootDatabase>,\n     config: &HoverConfig,\n@@ -275,12 +369,14 @@ fn hover_type_info(\n         let original = original.display(sema.db).to_string();\n         let adjusted = adjusted_ty.display(sema.db).to_string();\n         format!(\n-            \"```text\\nType: {:>apad$}\\nCoerced to: {:>opad$}\\n```\\n\",\n-            uncoerced = original,\n-            coerced = adjusted,\n+            \"{bt_start}Type: {:>apad$}\\nCoerced to: {:>opad$}\\n{bt_end}\",\n+            original,\n+            adjusted,\n             // 6 base padding for difference of length of the two text prefixes\n             apad = 6 + adjusted.len().max(original.len()),\n             opad = original.len(),\n+            bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n+            bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n         )\n         .into()\n     } else {\n@@ -4257,4 +4353,95 @@ fn foo() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hover_try_expr_res() {\n+        check_hover_range(\n+            r#\"\n+//- minicore:result\n+struct FooError;\n+\n+fn foo() -> Result<(), FooError> {\n+    Ok($0Result::<(), FooError>::Ok(())?$0)\n+}\n+\"#,\n+            expect![[r#\"\n+                ```rust\n+                ()\n+                ```\"#]],\n+        );\n+        check_hover_range(\n+            r#\"\n+//- minicore:result\n+struct FooError;\n+struct BarError;\n+\n+fn foo() -> Result<(), FooError> {\n+    Ok($0Result::<(), BarError>::Ok(())?$0)\n+}\n+\"#,\n+            expect![[r#\"\n+                ```text\n+                Try Error Type: BarError\n+                Propagated as:  FooError\n+                ```\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn hover_try_expr() {\n+        check_hover_range(\n+            r#\"\n+struct NotResult<T, U>(T, U);\n+struct Short;\n+struct Looooong;\n+\n+fn foo() -> NotResult<(), Looooong> {\n+    $0NotResult((), Short)?$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                ```text\n+                Try Target Type:    NotResult<(), Short>\n+                Propagated as:   NotResult<(), Looooong>\n+                ```\n+            \"#]],\n+        );\n+        check_hover_range(\n+            r#\"\n+struct NotResult<T, U>(T, U);\n+struct Short;\n+struct Looooong;\n+\n+fn foo() -> NotResult<(), Short> {\n+    $0NotResult((), Looooong)?$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                ```text\n+                Try Target Type: NotResult<(), Looooong>\n+                Propagated as:      NotResult<(), Short>\n+                ```\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn hover_try_expr_option() {\n+        check_hover_range(\n+            r#\"\n+//- minicore: option, try\n+\n+fn foo() -> Option<()> {\n+    $0Some(0)?$0;\n+    None\n+}\n+\"#,\n+            expect![[r#\"\n+                ```rust\n+                <Option<i32> as Try>::Output\n+                ```\"#]],\n+        );\n+    }\n }"}]}