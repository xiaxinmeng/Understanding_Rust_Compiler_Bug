{"sha": "06ff3f8b4b81dc84721cbddd1f480786f40f43fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZmYzZjhiNGI4MWRjODQ3MjFjYmRkZDFmNDgwNzg2ZjQwZjQzZmE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-25T02:53:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-25T03:31:27Z"}, "message": "std: Use more concise code in uv::hl", "tree": {"sha": "dd06adf3d0233fa9a1b8c8b30be9ad8127a42290", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd06adf3d0233fa9a1b8c8b30be9ad8127a42290"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06ff3f8b4b81dc84721cbddd1f480786f40f43fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06ff3f8b4b81dc84721cbddd1f480786f40f43fa", "html_url": "https://github.com/rust-lang/rust/commit/06ff3f8b4b81dc84721cbddd1f480786f40f43fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06ff3f8b4b81dc84721cbddd1f480786f40f43fa/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77bbd72171631223464057f79fcd82e81787e84c", "url": "https://api.github.com/repos/rust-lang/rust/commits/77bbd72171631223464057f79fcd82e81787e84c", "html_url": "https://github.com/rust-lang/rust/commit/77bbd72171631223464057f79fcd82e81787e84c"}], "stats": {"total": 127, "additions": 43, "deletions": 84}, "files": [{"sha": "7a20b1abc6c7bd9275eae978c101fd80b479d1d7", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06ff3f8b4b81dc84721cbddd1f480786f40f43fa/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ff3f8b4b81dc84721cbddd1f480786f40f43fa/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=06ff3f8b4b81dc84721cbddd1f480786f40f43fa", "patch": "@@ -58,7 +58,7 @@ fn get_monitor_task_gl() -> hl::high_level_loop {\n                 let hl_loop_data = spawn_libuv_weak_task();\n                 let hl_loop = alt hl_loop_data {\n                   (async, msg_ch) {\n-                    hl::simple_task_loop({async_handle:async, op_chan:msg_ch})\n+                    hl::high_level_loop({async_handle:async, op_chan:msg_ch})\n                   }\n                 };\n                 loop {"}, {"sha": "81684b96a3a45dcb8a841c474da1cab12da6c8a8", "filename": "src/libstd/uv_hl.rs", "status": "modified", "additions": 42, "deletions": 83, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/06ff3f8b4b81dc84721cbddd1f480786f40f43fa/src%2Flibstd%2Fuv_hl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ff3f8b4b81dc84721cbddd1f480786f40f43fa/src%2Flibstd%2Fuv_hl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_hl.rs?ref=06ff3f8b4b81dc84721cbddd1f480786f40f43fa", "patch": "@@ -9,22 +9,18 @@ libuv functionality.\n export high_level_loop, high_level_msg;\n export run_high_level_loop, interact;\n \n+import libc::c_void;\n+import ptr::addr_of;\n+import comm::{port, chan, methods};\n import ll = uv_ll;\n \n-// FIXME: Newtype syntax\n #[doc = \"\n Used to abstract-away direct interaction with a libuv loop.\n \"]\n-enum high_level_loop {\n-    #[doc=\"\n-    `high_level_loop` variant that carries a `comm::chan` and\n-    a `*ll::uv_async_t`.\n-    \"]\n-    simple_task_loop({\n-        async_handle: *ll::uv_async_t,\n-        op_chan: comm::chan<high_level_msg>\n-    })\n-}\n+enum high_level_loop = {\n+    async_handle: *ll::uv_async_t,\n+    op_chan: chan<high_level_msg>\n+};\n \n #[doc=\"\n Represents the range of interactions with a `high_level_loop`\n@@ -64,29 +60,28 @@ the loop's msg port\n * before_tear_down - called just before the loop invokes `uv_close()` on the\n provided `async_handle`. `uv_run` should return shortly after\n \"]\n-unsafe fn run_high_level_loop(loop_ptr: *libc::c_void,\n-                              msg_po: comm::port<high_level_msg>,\n+unsafe fn run_high_level_loop(loop_ptr: *c_void,\n+                              msg_po: port<high_level_msg>,\n                               before_run: fn~(*ll::uv_async_t),\n                               before_msg_process:\n                                 fn~(*ll::uv_async_t, bool) -> bool,\n                               before_tear_down: fn~(*ll::uv_async_t)) {\n     // set up the special async handle we'll use to allow multi-task\n     // communication with this loop\n     let async = ll::async_t();\n-    let async_handle = ptr::addr_of(async);\n+    let async_handle = addr_of(async);\n     // associate the async handle with the loop\n     ll::async_init(loop_ptr, async_handle, high_level_wake_up_cb);\n \n     // initialize our loop data and store it in the loop\n-    let data: hl_loop_data = default_gl_data({\n+    let data: hl_loop_data = {\n         async_handle: async_handle,\n         mut active: true,\n         before_msg_process: before_msg_process,\n         before_tear_down: before_tear_down,\n-        msg_po_ptr: ptr::addr_of(msg_po)\n-    });\n-    let data_ptr = ptr::addr_of(data);\n-    ll::set_data_for_uv_handle(async_handle, data_ptr);\n+        msg_po_ptr: addr_of(msg_po)\n+    };\n+    ll::set_data_for_uv_handle(async_handle, addr_of(data));\n \n     // call before_run\n     before_run(async_handle);\n@@ -120,41 +115,25 @@ module. It is not safe to send the `loop_ptr` param to this callback out\n via ports/chans.\n \"]\n unsafe fn interact(hl_loop: high_level_loop,\n-                      -cb: fn~(*libc::c_void)) {\n+                   -cb: fn~(*c_void)) {\n     send_high_level_msg(hl_loop, interaction(cb));\n }\n \n // INTERNAL API\n \n-// FIXME: Newtype syntax\n // data that lives for the lifetime of the high-evel oo\n-enum hl_loop_data {\n-    // FIXME: hl, not gl?\n-    default_gl_data({\n-        async_handle: *ll::uv_async_t,\n-        mut active: bool,\n-        before_msg_process: fn~(*ll::uv_async_t, bool) -> bool,\n-        before_tear_down: fn~(*ll::uv_async_t),\n-        msg_po_ptr: *comm::port<high_level_msg>})\n-}\n+type hl_loop_data = {\n+    async_handle: *ll::uv_async_t,\n+    mut active: bool,\n+    before_msg_process: fn~(*ll::uv_async_t, bool) -> bool,\n+    before_tear_down: fn~(*ll::uv_async_t),\n+    msg_po_ptr: *port<high_level_msg>\n+};\n \n-// FIXME: This function can be much simpler\n unsafe fn send_high_level_msg(hl_loop: high_level_loop,\n                               -msg: high_level_msg) {\n-    let op_chan = alt hl_loop{simple_task_loop({async_handle, op_chan}){\n-      op_chan}};\n-    comm::send(op_chan, msg);\n-\n-    // if the global async handle == 0, then that means\n-    // the loop isn't active, so we don't need to wake it up,\n-    // (the loop's enclosing task should be blocking on a message\n-    // receive on this port)\n-    alt hl_loop {\n-      simple_task_loop({async_handle, op_chan}) {\n-        log(debug,\"simple async handle != 0, waking up loop..\");\n-        ll::async_send((async_handle));\n-      }\n-    }\n+    comm::send(hl_loop.op_chan, msg);\n+    ll::async_send(hl_loop.async_handle);\n }\n \n // this will be invoked by a call to uv::hl::interact() with\n@@ -169,43 +148,27 @@ crust fn high_level_wake_up_cb(async_handle: *ll::uv_async_t,\n     let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n     let data = ll::get_data_for_uv_handle(async_handle) as *hl_loop_data;\n     // FIXME: What is this checking?\n-    // FIXME: Use if not alt\n-    alt (*data).active {\n-      true {\n+    if (*data).active {\n         let msg_po = *((*data).msg_po_ptr);\n-        // FIXME: Convert to while loop\n-        alt comm::peek(msg_po) {\n-          true {\n-            loop {\n-                let msg = comm::recv(msg_po);\n-                alt (*data).active {\n-                  true {\n-                    alt msg {\n-                      interaction(cb) {\n-                        (*data).before_msg_process(async_handle,\n-                                                   (*data).active);\n-                        cb(loop_ptr);\n-                      }\n-                      teardown_loop {\n-                        begin_teardown(data);\n-                      }\n-                    }\n+        while msg_po.peek() {\n+            let msg = msg_po.recv();\n+            if (*data).active {\n+                alt msg {\n+                  interaction(cb) {\n+                    (*data).before_msg_process(async_handle,\n+                                               (*data).active);\n+                    cb(loop_ptr);\n                   }\n-                  false {\n-                    // drop msg ?\n+                  teardown_loop {\n+                    begin_teardown(data);\n                   }\n                 }\n-                if !comm::peek(msg_po) { break; }\n+            } else {\n+                // FIXME: drop msg ?\n             }\n-          }\n-          false {\n-            // no pending msgs\n-          }\n         }\n-      }\n-      false {\n+    } else {\n         // loop not active\n-      }\n     }\n }\n \n@@ -222,7 +185,7 @@ fn begin_teardown(data: *hl_loop_data) unsafe {\n     // call user-suppled before_tear_down cb\n     let async_handle = (*data).async_handle;\n     (*data).before_tear_down(async_handle);\n-    ll::close(async_handle as *libc::c_void, tear_down_close_cb);\n+    ll::close(async_handle as *c_void, tear_down_close_cb);\n }\n \n #[cfg(test)]\n@@ -278,7 +241,7 @@ mod test {\n                                   async_handle));\n                     // do an async_send with it\n                     ll::async_send(async_handle);\n-                    comm::send(hl_loop_ch, simple_task_loop({\n+                    comm::send(hl_loop_ch, high_level_loop({\n                        async_handle: async_handle,\n                        op_chan: msg_ch\n                     }));\n@@ -339,12 +302,8 @@ mod test {\n         // anyone rolling their own high_level_loop can decide when to\n         // send the msg. it's assert and barf, though, if all of your\n         // handles aren't uv_close'd first\n-        alt hl_loop {\n-          simple_task_loop({async_handle, op_chan}) {\n-            comm::send(op_chan, teardown_loop);\n-            ll::async_send(async_handle);\n-          }\n-        }\n+        comm::send(hl_loop.op_chan, teardown_loop);\n+        ll::async_send(hl_loop.async_handle);\n         comm::recv(exit_po);\n         log(debug, \"after recv on exit_po.. exiting..\");\n     }"}]}