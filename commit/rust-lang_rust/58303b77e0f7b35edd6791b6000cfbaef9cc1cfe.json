{"sha": "58303b77e0f7b35edd6791b6000cfbaef9cc1cfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MzAzYjc3ZTBmN2IzNWVkZDY3OTFiNjAwMGNmYmFlZjljYzFjZmU=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-03-06T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-03-09T01:05:22Z"}, "message": "Use slices in preference to 0-terminated strings\n\nAdditionally whenever possible match C API provided by the LLVM.", "tree": {"sha": "d37ce0ecefecce821ff487d1d3235389b0376fe8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d37ce0ecefecce821ff487d1d3235389b0376fe8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe", "html_url": "https://github.com/rust-lang/rust/commit/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cb0b8582ebbf9784db9cec06fff517badbf4553", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cb0b8582ebbf9784db9cec06fff517badbf4553", "html_url": "https://github.com/rust-lang/rust/commit/2cb0b8582ebbf9784db9cec06fff517badbf4553"}], "stats": {"total": 453, "additions": 266, "deletions": 187}, "files": [{"sha": "5cf3d74f243cd8101941514c9c4d6bdc5b4289e9", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 140, "deletions": 107, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=58303b77e0f7b35edd6791b6000cfbaef9cc1cfe", "patch": "@@ -37,7 +37,6 @@ use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::const_cstr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_fs_util::path_to_c_string;\n use rustc_hir::def::CtorKind;\n@@ -49,7 +48,6 @@ use rustc_target::abi::HasDataLayout;\n \n use libc::{c_longlong, c_uint};\n use std::collections::hash_map::Entry;\n-use std::ffi::CString;\n use std::fmt::{self, Write};\n use std::hash::{Hash, Hasher};\n use std::iter;\n@@ -227,11 +225,14 @@ impl TypeMap<'ll, 'tcx> {\n     /// Gets the unique type ID string for an enum variant part.\n     /// Variant parts are not types and shouldn't really have their own ID,\n     /// but it makes `set_members_of_composite_type()` simpler.\n-    fn get_unique_type_id_str_of_enum_variant_part(&mut self, enum_type_id: UniqueTypeId) -> &str {\n+    fn get_unique_type_id_str_of_enum_variant_part(\n+        &mut self,\n+        enum_type_id: UniqueTypeId,\n+    ) -> String {\n         let variant_part_type_id =\n             format!(\"{}_variant_part\", self.get_unique_type_id_as_string(enum_type_id));\n-        let interner_key = self.unique_id_interner.intern(&variant_part_type_id);\n-        self.unique_id_interner.get(interner_key)\n+        self.unique_id_interner.intern(&variant_part_type_id);\n+        variant_part_type_id\n     }\n }\n \n@@ -640,9 +641,11 @@ pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Sp\n                     // type is going to see *something* weird - the only\n                     // question is what exactly it will see.\n                     let (size, align) = cx.size_and_align_of(t);\n+                    let name = \"<recur_type>\";\n                     llvm::LLVMRustDIBuilderCreateBasicType(\n                         DIB(cx),\n-                        SmallCStr::new(\"<recur_type>\").as_ptr(),\n+                        name.as_ptr().cast(),\n+                        name.len(),\n                         size.bits(),\n                         align.bits() as u32,\n                         DW_ATE_unsigned,\n@@ -786,16 +789,17 @@ fn file_metadata_raw(\n             let (file_name, directory) = v.key();\n             debug!(\"file_metadata: file_name: {:?}, directory: {:?}\", file_name, directory);\n \n-            let file_name = SmallCStr::new(if let Some(file_name) = file_name {\n-                &file_name\n-            } else {\n-                \"<unknown>\"\n-            });\n-            let directory =\n-                SmallCStr::new(if let Some(directory) = directory { &directory } else { \"\" });\n+            let file_name = file_name.as_deref().unwrap_or(\"<unknown>\");\n+            let directory = directory.as_deref().unwrap_or(\"\");\n \n             let file_metadata = unsafe {\n-                llvm::LLVMRustDIBuilderCreateFile(DIB(cx), file_name.as_ptr(), directory.as_ptr())\n+                llvm::LLVMRustDIBuilderCreateFile(\n+                    DIB(cx),\n+                    file_name.as_ptr().cast(),\n+                    file_name.len(),\n+                    directory.as_ptr().cast(),\n+                    directory.len(),\n+                )\n             };\n \n             v.insert(file_metadata);\n@@ -819,11 +823,11 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     };\n \n     let (size, align) = cx.size_and_align_of(t);\n-    let name = SmallCStr::new(name);\n     let ty_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateBasicType(\n             DIB(cx),\n-            name.as_ptr(),\n+            name.as_ptr().cast(),\n+            name.len(),\n             size.bits(),\n             align.bits() as u32,\n             encoding,\n@@ -851,14 +855,15 @@ fn pointer_type_metadata(\n ) -> &'ll DIType {\n     let (pointer_size, pointer_align) = cx.size_and_align_of(pointer_type);\n     let name = compute_debuginfo_type_name(cx.tcx, pointer_type, false);\n-    let name = SmallCStr::new(&name);\n     unsafe {\n         llvm::LLVMRustDIBuilderCreatePointerType(\n             DIB(cx),\n             pointee_type_metadata,\n             pointer_size.bits(),\n             pointer_align.bits() as u32,\n-            name.as_ptr(),\n+            0, // Ignore DWARF address space.\n+            name.as_ptr().cast(),\n+            name.len(),\n         )\n     }\n }\n@@ -889,11 +894,9 @@ pub fn compile_unit_metadata(\n     let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n-    let name_in_debuginfo = SmallCStr::new(&name_in_debuginfo);\n-    let work_dir = SmallCStr::new(&tcx.sess.working_dir.0.to_string_lossy());\n-    let producer = CString::new(producer).unwrap();\n+    let work_dir = tcx.sess.working_dir.0.to_string_lossy();\n     let flags = \"\\0\";\n-    let split_name = \"\\0\";\n+    let split_name = \"\";\n \n     // FIXME(#60020):\n     //\n@@ -916,19 +919,23 @@ pub fn compile_unit_metadata(\n     unsafe {\n         let file_metadata = llvm::LLVMRustDIBuilderCreateFile(\n             debug_context.builder,\n-            name_in_debuginfo.as_ptr(),\n-            work_dir.as_ptr(),\n+            name_in_debuginfo.as_ptr().cast(),\n+            name_in_debuginfo.len(),\n+            work_dir.as_ptr().cast(),\n+            work_dir.len(),\n         );\n \n         let unit_metadata = llvm::LLVMRustDIBuilderCreateCompileUnit(\n             debug_context.builder,\n             DW_LANG_RUST,\n             file_metadata,\n-            producer.as_ptr(),\n+            producer.as_ptr().cast(),\n+            producer.len(),\n             tcx.sess.opts.optimize != config::OptLevel::No,\n             flags.as_ptr().cast(),\n             0,\n             split_name.as_ptr().cast(),\n+            split_name.len(),\n             kind,\n         );\n \n@@ -1021,12 +1028,12 @@ impl<'ll> MemberDescription<'ll> {\n         cx: &CodegenCx<'ll, '_>,\n         composite_type_metadata: &'ll DIScope,\n     ) -> &'ll DIType {\n-        let member_name = CString::new(self.name).unwrap();\n         unsafe {\n             llvm::LLVMRustDIBuilderCreateVariantMemberType(\n                 DIB(cx),\n                 composite_type_metadata,\n-                member_name.as_ptr(),\n+                self.name.as_ptr().cast(),\n+                self.name.len(),\n                 unknown_file_metadata(cx),\n                 UNKNOWN_LINE_NUMBER,\n                 self.size.bits(),\n@@ -1827,17 +1834,22 @@ fn prepare_enum_metadata(\n                 let discriminant_base_type_metadata =\n                     type_metadata(cx, discr.to_ty(cx.tcx), rustc_span::DUMMY_SP);\n \n+                let item_name;\n                 let discriminant_name = match enum_type.kind {\n-                    ty::Adt(..) => SmallCStr::new(&cx.tcx.item_name(enum_def_id).as_str()),\n-                    ty::Generator(..) => SmallCStr::new(&enum_name),\n+                    ty::Adt(..) => {\n+                        item_name = cx.tcx.item_name(enum_def_id).as_str();\n+                        &*item_name\n+                    }\n+                    ty::Generator(..) => enum_name.as_str(),\n                     _ => bug!(),\n                 };\n \n                 let discriminant_type_metadata = unsafe {\n                     llvm::LLVMRustDIBuilderCreateEnumerationType(\n                         DIB(cx),\n                         containing_scope,\n-                        discriminant_name.as_ptr(),\n+                        discriminant_name.as_ptr().cast(),\n+                        discriminant_name.len(),\n                         file_metadata,\n                         UNKNOWN_LINE_NUMBER,\n                         discriminant_size.bits(),\n@@ -1872,11 +1884,6 @@ fn prepare_enum_metadata(\n         _ => {}\n     }\n \n-    let enum_name = SmallCStr::new(&enum_name);\n-    let unique_type_id_str = SmallCStr::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id),\n-    );\n-\n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n             layout::Variants::Single { .. }\n@@ -1891,20 +1898,27 @@ fn prepare_enum_metadata(\n             } => Some(discriminant_type_metadata(discr.value)),\n         };\n \n-        let enum_metadata = unsafe {\n-            llvm::LLVMRustDIBuilderCreateUnionType(\n-                DIB(cx),\n-                containing_scope,\n-                enum_name.as_ptr(),\n-                file_metadata,\n-                UNKNOWN_LINE_NUMBER,\n-                layout.size.bits(),\n-                layout.align.abi.bits() as u32,\n-                DIFlags::FlagZero,\n-                None,\n-                0, // RuntimeLang\n-                unique_type_id_str.as_ptr(),\n-            )\n+        let enum_metadata = {\n+            let type_map = debug_context(cx).type_map.borrow();\n+            let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n+\n+            unsafe {\n+                llvm::LLVMRustDIBuilderCreateUnionType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    enum_name.as_ptr().cast(),\n+                    enum_name.len(),\n+                    file_metadata,\n+                    UNKNOWN_LINE_NUMBER,\n+                    layout.size.bits(),\n+                    layout.align.abi.bits() as u32,\n+                    DIFlags::FlagZero,\n+                    None,\n+                    0, // RuntimeLang\n+                    unique_type_id_str.as_ptr().cast(),\n+                    unique_type_id_str.len(),\n+                )\n+            }\n         };\n \n         return create_and_register_recursive_type_forward_declaration(\n@@ -1924,10 +1938,9 @@ fn prepare_enum_metadata(\n     }\n \n     let discriminator_name = match &enum_type.kind {\n-        ty::Generator(..) => Some(SmallCStr::new(&\"__state\")),\n-        _ => None,\n+        ty::Generator(..) => \"__state\",\n+        _ => \"\",\n     };\n-    let discriminator_name = discriminator_name.map(|n| n.as_ptr()).unwrap_or(ptr::null_mut());\n     let discriminator_metadata = match layout.variants {\n         // A single-variant enum has no discriminant.\n         layout::Variants::Single { .. } => None,\n@@ -1955,7 +1968,8 @@ fn prepare_enum_metadata(\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n                     containing_scope,\n-                    discriminator_name,\n+                    discriminator_name.as_ptr().cast(),\n+                    discriminator_name.len(),\n                     file_metadata,\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n@@ -1981,7 +1995,8 @@ fn prepare_enum_metadata(\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n                     containing_scope,\n-                    discriminator_name,\n+                    discriminator_name.as_ptr().cast(),\n+                    discriminator_name.len(),\n                     file_metadata,\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n@@ -2010,48 +2025,57 @@ fn prepare_enum_metadata(\n         }\n     };\n \n-    let variant_part_unique_type_id_str = SmallCStr::new(\n-        debug_context(cx)\n-            .type_map\n-            .borrow_mut()\n-            .get_unique_type_id_str_of_enum_variant_part(unique_type_id),\n-    );\n+    let variant_part_unique_type_id_str = debug_context(cx)\n+        .type_map\n+        .borrow_mut()\n+        .get_unique_type_id_str_of_enum_variant_part(unique_type_id);\n     let empty_array = create_DIArray(DIB(cx), &[]);\n+    let name = \"\";\n     let variant_part = unsafe {\n         llvm::LLVMRustDIBuilderCreateVariantPart(\n             DIB(cx),\n             containing_scope,\n-            ptr::null_mut(),\n+            name.as_ptr().cast(),\n+            name.len(),\n             file_metadata,\n             UNKNOWN_LINE_NUMBER,\n             layout.size.bits(),\n             layout.align.abi.bits() as u32,\n             DIFlags::FlagZero,\n             discriminator_metadata,\n             empty_array,\n-            variant_part_unique_type_id_str.as_ptr(),\n+            variant_part_unique_type_id_str.as_ptr().cast(),\n+            variant_part_unique_type_id_str.len(),\n         )\n     };\n     outer_fields.push(Some(variant_part));\n \n-    // The variant part must be wrapped in a struct according to DWARF.\n-    let type_array = create_DIArray(DIB(cx), &outer_fields);\n-    let struct_wrapper = unsafe {\n-        llvm::LLVMRustDIBuilderCreateStructType(\n-            DIB(cx),\n-            Some(containing_scope),\n-            enum_name.as_ptr(),\n-            file_metadata,\n-            UNKNOWN_LINE_NUMBER,\n-            layout.size.bits(),\n-            layout.align.abi.bits() as u32,\n-            DIFlags::FlagZero,\n-            None,\n-            type_array,\n-            0,\n-            None,\n-            unique_type_id_str.as_ptr(),\n-        )\n+    let struct_wrapper = {\n+        // The variant part must be wrapped in a struct according to DWARF.\n+        let type_array = create_DIArray(DIB(cx), &outer_fields);\n+\n+        let type_map = debug_context(cx).type_map.borrow();\n+        let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n+\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateStructType(\n+                DIB(cx),\n+                Some(containing_scope),\n+                enum_name.as_ptr().cast(),\n+                enum_name.len(),\n+                file_metadata,\n+                UNKNOWN_LINE_NUMBER,\n+                layout.size.bits(),\n+                layout.align.abi.bits() as u32,\n+                DIFlags::FlagZero,\n+                None,\n+                type_array,\n+                0,\n+                None,\n+                unique_type_id_str.as_ptr().cast(),\n+                unique_type_id_str.len(),\n+            )\n+        }\n     };\n \n     return create_and_register_recursive_type_forward_declaration(\n@@ -2156,12 +2180,13 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'\n                             cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                         let actual_type_metadata =\n                             type_metadata(cx, actual_type, rustc_span::DUMMY_SP);\n-                        let name = SmallCStr::new(&name.as_str());\n+                        let name = &name.as_str();\n                         Some(unsafe {\n                             Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                                 DIB(cx),\n                                 None,\n-                                name.as_ptr(),\n+                                name.as_ptr().cast(),\n+                                name.len(),\n                                 actual_type_metadata,\n                                 unknown_file_metadata(cx),\n                                 0,\n@@ -2200,10 +2225,9 @@ fn create_struct_stub(\n ) -> &'ll DICompositeType {\n     let (struct_size, struct_align) = cx.size_and_align_of(struct_type);\n \n-    let name = SmallCStr::new(struct_type_name);\n-    let unique_type_id = SmallCStr::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id),\n-    );\n+    let type_map = debug_context(cx).type_map.borrow();\n+    let unique_type_id = type_map.get_unique_type_id_as_string(unique_type_id);\n+\n     let metadata_stub = unsafe {\n         // `LLVMRustDIBuilderCreateStructType()` wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n@@ -2213,7 +2237,8 @@ fn create_struct_stub(\n         llvm::LLVMRustDIBuilderCreateStructType(\n             DIB(cx),\n             containing_scope,\n-            name.as_ptr(),\n+            struct_type_name.as_ptr().cast(),\n+            struct_type_name.len(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             struct_size.bits(),\n@@ -2223,7 +2248,8 @@ fn create_struct_stub(\n             empty_array,\n             0,\n             None,\n-            unique_type_id.as_ptr(),\n+            unique_type_id.as_ptr().cast(),\n+            unique_type_id.len(),\n         )\n     };\n \n@@ -2239,10 +2265,9 @@ fn create_union_stub(\n ) -> &'ll DICompositeType {\n     let (union_size, union_align) = cx.size_and_align_of(union_type);\n \n-    let name = SmallCStr::new(union_type_name);\n-    let unique_type_id = SmallCStr::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id),\n-    );\n+    let type_map = debug_context(cx).type_map.borrow();\n+    let unique_type_id = type_map.get_unique_type_id_as_string(unique_type_id);\n+\n     let metadata_stub = unsafe {\n         // `LLVMRustDIBuilderCreateUnionType()` wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n@@ -2252,15 +2277,17 @@ fn create_union_stub(\n         llvm::LLVMRustDIBuilderCreateUnionType(\n             DIB(cx),\n             containing_scope,\n-            name.as_ptr(),\n+            union_type_name.as_ptr().cast(),\n+            union_type_name.len(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             union_size.bits(),\n             union_align.bits() as u32,\n             DIFlags::FlagZero,\n             Some(empty_array),\n             0, // RuntimeLang\n-            unique_type_id.as_ptr(),\n+            unique_type_id.as_ptr().cast(),\n+            unique_type_id.len(),\n         )\n     };\n \n@@ -2294,24 +2321,26 @@ pub fn create_global_var_metadata(cx: &CodegenCx<'ll, '_>, def_id: DefId, global\n     let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n     let variable_type = Instance::mono(cx.tcx, def_id).monomorphic_ty(cx.tcx);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let var_name = SmallCStr::new(&tcx.item_name(def_id).as_str());\n+    let var_name = tcx.item_name(def_id).as_str();\n     let linkage_name = if no_mangle {\n         None\n     } else {\n-        let linkage_name = mangled_name_of_instance(cx, Instance::mono(tcx, def_id));\n-        Some(SmallCStr::new(&linkage_name.name.as_str()))\n+        Some(mangled_name_of_instance(cx, Instance::mono(tcx, def_id)).name.as_str())\n     };\n+    // When empty, linkage_name field is omitted,\n+    // which is what we want for no_mangle statics\n+    let linkage_name = linkage_name.as_deref().unwrap_or(\"\");\n \n     let global_align = cx.align_of(variable_type);\n \n     unsafe {\n         llvm::LLVMRustDIBuilderCreateStaticVariable(\n             DIB(cx),\n             Some(var_scope),\n-            var_name.as_ptr(),\n-            // If null, linkage_name field is omitted,\n-            // which is what we want for no_mangle statics\n-            linkage_name.as_ref().map_or(ptr::null(), |name| name.as_ptr()),\n+            var_name.as_ptr().cast(),\n+            var_name.len(),\n+            linkage_name.as_ptr().cast(),\n+            linkage_name.len(),\n             file_metadata,\n             line_number,\n             type_metadata,\n@@ -2339,16 +2368,16 @@ pub fn create_vtable_metadata(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>, vtable: &\n         // pointer will lead to hard to trace and debug LLVM assertions\n         // later on in `llvm/lib/IR/Value.cpp`.\n         let empty_array = create_DIArray(DIB(cx), &[]);\n-\n-        let name = const_cstr!(\"vtable\");\n+        let name = \"vtable\";\n \n         // Create a new one each time. We don't want metadata caching\n         // here, because each vtable will refer to a unique containing\n         // type.\n         let vtable_type = llvm::LLVMRustDIBuilderCreateStructType(\n             DIB(cx),\n             NO_SCOPE_METADATA,\n-            name.as_ptr(),\n+            name.as_ptr().cast(),\n+            name.len(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             Size::ZERO.bits(),\n@@ -2358,14 +2387,18 @@ pub fn create_vtable_metadata(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>, vtable: &\n             empty_array,\n             0,\n             Some(type_metadata),\n-            name.as_ptr(),\n+            name.as_ptr().cast(),\n+            name.len(),\n         );\n \n+        let linkage_name = \"\";\n         llvm::LLVMRustDIBuilderCreateStaticVariable(\n             DIB(cx),\n             NO_SCOPE_METADATA,\n-            name.as_ptr(),\n-            ptr::null(),\n+            name.as_ptr().cast(),\n+            name.len(),\n+            linkage_name.as_ptr().cast(),\n+            linkage_name.len(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             vtable_type,"}, {"sha": "8deab1be3d3a93f6c04534baaab6c79a47c92ef6", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=58303b77e0f7b35edd6791b6000cfbaef9cc1cfe", "patch": "@@ -25,13 +25,11 @@ use rustc::ty::{self, Instance, ParamEnv, Ty};\n use rustc_codegen_ssa::debuginfo::type_names;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext, VariableKind};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_index::vec::IndexVec;\n \n use libc::c_uint;\n use log::debug;\n use std::cell::RefCell;\n-use std::ffi::CString;\n \n use rustc::ty::layout::{self, HasTyCtxt, LayoutOf, Size};\n use rustc_ast::ast;\n@@ -273,13 +271,11 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         // Get the linkage_name, which is just the symbol name\n         let linkage_name = mangled_name_of_instance(self, instance);\n+        let linkage_name = linkage_name.name.as_str();\n \n         // FIXME(eddyb) does this need to be separate from `loc.line` for some reason?\n         let scope_line = loc.line;\n \n-        let function_name = CString::new(name).unwrap();\n-        let linkage_name = SmallCStr::new(&linkage_name.name.as_str());\n-\n         let mut flags = DIFlags::FlagPrototyped;\n \n         if fn_abi.ret.layout.abi.is_uninhabited() {\n@@ -303,8 +299,10 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             llvm::LLVMRustDIBuilderCreateFunction(\n                 DIB(self),\n                 containing_scope,\n-                function_name.as_ptr(),\n-                linkage_name.as_ptr(),\n+                name.as_ptr().cast(),\n+                name.len(),\n+                linkage_name.as_ptr().cast(),\n+                linkage_name.len(),\n                 file_metadata,\n                 loc.line as c_uint,\n                 function_type_metadata,\n@@ -424,12 +422,13 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                             let actual_type_metadata =\n                                 type_metadata(cx, actual_type, rustc_span::DUMMY_SP);\n-                            let name = SmallCStr::new(&name.as_str());\n+                            let name = name.as_str();\n                             Some(unsafe {\n                                 Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                                     DIB(cx),\n                                     None,\n-                                    name.as_ptr(),\n+                                    name.as_ptr().cast(),\n+                                    name.len(),\n                                     actual_type_metadata,\n                                     file_metadata,\n                                     0,\n@@ -542,13 +541,14 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         };\n         let align = self.align_of(variable_type);\n \n-        let name = SmallCStr::new(&variable_name.as_str());\n+        let name = variable_name.as_str();\n         unsafe {\n             llvm::LLVMRustDIBuilderCreateVariable(\n                 DIB(self),\n                 dwarf_tag,\n                 scope_metadata,\n-                name.as_ptr(),\n+                name.as_ptr().cast(),\n+                name.len(),\n                 file_metadata,\n                 loc.line as c_uint,\n                 type_metadata,"}, {"sha": "55a3540809b487a35d924f37d3a11d566ae69b96", "filename": "src/librustc_codegen_llvm/debuginfo/namespace.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs?ref=58303b77e0f7b35edd6791b6000cfbaef9cc1cfe", "patch": "@@ -1,6 +1,5 @@\n // Namespace Handling.\n \n-use super::metadata::{unknown_file_metadata, UNKNOWN_LINE_NUMBER};\n use super::utils::{debug_context, DIB};\n use rustc::ty::{self, Instance};\n \n@@ -10,8 +9,6 @@ use crate::llvm::debuginfo::DIScope;\n use rustc::hir::map::DefPathData;\n use rustc_hir::def_id::DefId;\n \n-use rustc_data_structures::small_c_str::SmallCStr;\n-\n pub fn mangled_name_of_instance<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n     instance: Instance<'tcx>,\n@@ -34,16 +31,15 @@ pub fn item_namespace(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n         DefPathData::CrateRoot => cx.tcx.crate_name(def_id.krate),\n         data => data.as_symbol(),\n     };\n-\n-    let namespace_name = SmallCStr::new(&namespace_name.as_str());\n+    let namespace_name = namespace_name.as_str();\n \n     let scope = unsafe {\n         llvm::LLVMRustDIBuilderCreateNameSpace(\n             DIB(cx),\n             parent_scope,\n-            namespace_name.as_ptr(),\n-            unknown_file_metadata(cx),\n-            UNKNOWN_LINE_NUMBER,\n+            namespace_name.as_ptr().cast(),\n+            namespace_name.len(),\n+            false, // ExportSymbols (only relevant for C++ anonymous namespaces)\n         )\n     };\n "}, {"sha": "31a0f52809088695b2c46dda75b2384e05999deb", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=58303b77e0f7b35edd6791b6000cfbaef9cc1cfe", "patch": "@@ -1607,17 +1607,21 @@ extern \"C\" {\n         Lang: c_uint,\n         File: &'a DIFile,\n         Producer: *const c_char,\n+        ProducerLen: size_t,\n         isOptimized: bool,\n         Flags: *const c_char,\n         RuntimeVer: c_uint,\n         SplitName: *const c_char,\n+        SplitNameLen: size_t,\n         kind: DebugEmissionKind,\n     ) -> &'a DIDescriptor;\n \n     pub fn LLVMRustDIBuilderCreateFile(\n         Builder: &DIBuilder<'a>,\n         Filename: *const c_char,\n+        FilenameLen: size_t,\n         Directory: *const c_char,\n+        DirectoryLen: size_t,\n     ) -> &'a DIFile;\n \n     pub fn LLVMRustDIBuilderCreateSubroutineType(\n@@ -1630,7 +1634,9 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIDescriptor,\n         Name: *const c_char,\n+        NameLen: size_t,\n         LinkageName: *const c_char,\n+        LinkageNameLen: size_t,\n         File: &'a DIFile,\n         LineNo: c_uint,\n         Ty: &'a DIType,\n@@ -1645,6 +1651,7 @@ extern \"C\" {\n     pub fn LLVMRustDIBuilderCreateBasicType(\n         Builder: &DIBuilder<'a>,\n         Name: *const c_char,\n+        NameLen: size_t,\n         SizeInBits: u64,\n         AlignInBits: u32,\n         Encoding: c_uint,\n@@ -1655,13 +1662,16 @@ extern \"C\" {\n         PointeeTy: &'a DIType,\n         SizeInBits: u64,\n         AlignInBits: u32,\n+        AddressSpace: c_uint,\n         Name: *const c_char,\n+        NameLen: size_t,\n     ) -> &'a DIDerivedType;\n \n     pub fn LLVMRustDIBuilderCreateStructType(\n         Builder: &DIBuilder<'a>,\n         Scope: Option<&'a DIDescriptor>,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNumber: c_uint,\n         SizeInBits: u64,\n@@ -1672,12 +1682,14 @@ extern \"C\" {\n         RunTimeLang: c_uint,\n         VTableHolder: Option<&'a DIType>,\n         UniqueId: *const c_char,\n+        UniqueIdLen: size_t,\n     ) -> &'a DICompositeType;\n \n     pub fn LLVMRustDIBuilderCreateMemberType(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIDescriptor,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNo: c_uint,\n         SizeInBits: u64,\n@@ -1691,6 +1703,7 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNumber: c_uint,\n         SizeInBits: u64,\n@@ -1719,7 +1732,9 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Context: Option<&'a DIScope>,\n         Name: *const c_char,\n+        NameLen: size_t,\n         LinkageName: *const c_char,\n+        LinkageNameLen: size_t,\n         File: &'a DIFile,\n         LineNo: c_uint,\n         Ty: &'a DIType,\n@@ -1734,6 +1749,7 @@ extern \"C\" {\n         Tag: c_uint,\n         Scope: &'a DIDescriptor,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNo: c_uint,\n         Ty: &'a DIType,\n@@ -1785,6 +1801,7 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNumber: c_uint,\n         SizeInBits: u64,\n@@ -1798,6 +1815,7 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNumber: c_uint,\n         SizeInBits: u64,\n@@ -1806,12 +1824,14 @@ extern \"C\" {\n         Elements: Option<&'a DIArray>,\n         RunTimeLang: c_uint,\n         UniqueId: *const c_char,\n+        UniqueIdLen: size_t,\n     ) -> &'a DIType;\n \n     pub fn LLVMRustDIBuilderCreateVariantPart(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNo: c_uint,\n         SizeInBits: u64,\n@@ -1820,6 +1840,7 @@ extern \"C\" {\n         Discriminator: Option<&'a DIDerivedType>,\n         Elements: &'a DIArray,\n         UniqueId: *const c_char,\n+        UniqueIdLen: size_t,\n     ) -> &'a DIDerivedType;\n \n     pub fn LLVMSetUnnamedAddr(GlobalVar: &Value, UnnamedAddr: Bool);\n@@ -1828,6 +1849,7 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: Option<&'a DIScope>,\n         Name: *const c_char,\n+        NameLen: size_t,\n         Ty: &'a DIType,\n         File: &'a DIFile,\n         LineNo: c_uint,\n@@ -1838,8 +1860,8 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: Option<&'a DIScope>,\n         Name: *const c_char,\n-        File: &'a DIFile,\n-        LineNo: c_uint,\n+        NameLen: size_t,\n+        ExportSymbols: bool,\n     ) -> &'a DINameSpace;\n \n     pub fn LLVMRustDICompositeTypeReplaceArrays("}, {"sha": "aeddd4cfb9fe9f32444e768f9a2278418f8bb402", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 87, "deletions": 59, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/58303b77e0f7b35edd6791b6000cfbaef9cc1cfe/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=58303b77e0f7b35edd6791b6000cfbaef9cc1cfe", "patch": "@@ -665,20 +665,24 @@ extern \"C\" void LLVMRustDIBuilderFinalize(LLVMRustDIBuilderRef Builder) {\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateCompileUnit(\n     LLVMRustDIBuilderRef Builder, unsigned Lang, LLVMMetadataRef FileRef,\n-    const char *Producer, bool isOptimized, const char *Flags,\n-    unsigned RuntimeVer, const char *SplitName,\n+    const char *Producer, size_t ProducerLen, bool isOptimized,\n+    const char *Flags, unsigned RuntimeVer,\n+    const char *SplitName, size_t SplitNameLen,\n     LLVMRustDebugEmissionKind Kind) {\n   auto *File = unwrapDI<DIFile>(FileRef);\n \n-  return wrap(Builder->createCompileUnit(Lang, File, Producer, isOptimized,\n-                                         Flags, RuntimeVer, SplitName,\n+  return wrap(Builder->createCompileUnit(Lang, File, StringRef(Producer, ProducerLen),\n+                                         isOptimized, Flags, RuntimeVer,\n+                                         StringRef(SplitName, SplitNameLen),\n                                          fromRust(Kind)));\n }\n \n-extern \"C\" LLVMMetadataRef\n-LLVMRustDIBuilderCreateFile(LLVMRustDIBuilderRef Builder, const char *Filename,\n-                            const char *Directory) {\n-  return wrap(Builder->createFile(Filename, Directory));\n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFile(\n+    LLVMRustDIBuilderRef Builder,\n+    const char *Filename, size_t FilenameLen,\n+    const char *Directory, size_t DirectoryLen) {\n+  return wrap(Builder->createFile(StringRef(Filename, FilenameLen),\n+                                  StringRef(Directory, DirectoryLen)));\n }\n \n extern \"C\" LLVMMetadataRef\n@@ -690,8 +694,10 @@ LLVMRustDIBuilderCreateSubroutineType(LLVMRustDIBuilderRef Builder,\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n-    const char *LinkageName, LLVMMetadataRef File, unsigned LineNo,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n+    const char *LinkageName, size_t LinkageNameLen,\n+    LLVMMetadataRef File, unsigned LineNo,\n     LLVMMetadataRef Ty, unsigned ScopeLine, LLVMRustDIFlags Flags,\n     LLVMRustDISPFlags SPFlags, LLVMValueRef Fn, LLVMMetadataRef TParam,\n     LLVMMetadataRef Decl) {\n@@ -705,8 +711,11 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n     llvmFlags |= DINode::DIFlags::FlagMainSubprogram;\n #endif\n   DISubprogram *Sub = Builder->createFunction(\n-      unwrapDI<DIScope>(Scope), Name, LinkageName, unwrapDI<DIFile>(File),\n-      LineNo, unwrapDI<DISubroutineType>(Ty), ScopeLine, llvmFlags,\n+      unwrapDI<DIScope>(Scope),\n+      StringRef(Name, NameLen),\n+      StringRef(LinkageName, LinkageNameLen),\n+      unwrapDI<DIFile>(File), LineNo,\n+      unwrapDI<DISubroutineType>(Ty), ScopeLine, llvmFlags,\n       llvmSPFlags, TParams, unwrapDIPtr<DISubprogram>(Decl));\n #else\n   bool IsLocalToUnit = isSet(SPFlags & LLVMRustDISPFlags::SPFlagLocalToUnit);\n@@ -716,77 +725,87 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n   if (isSet(SPFlags & LLVMRustDISPFlags::SPFlagMainSubprogram))\n     llvmFlags |= DINode::DIFlags::FlagMainSubprogram;\n   DISubprogram *Sub = Builder->createFunction(\n-      unwrapDI<DIScope>(Scope), Name, LinkageName, unwrapDI<DIFile>(File),\n-      LineNo, unwrapDI<DISubroutineType>(Ty), IsLocalToUnit, IsDefinition,\n+      unwrapDI<DIScope>(Scope),\n+      StringRef(Name, NameLen),\n+      StringRef(LinkageName, LinkageNameLen),\n+      unwrapDI<DIFile>(File), LineNo,\n+      unwrapDI<DISubroutineType>(Ty), IsLocalToUnit, IsDefinition,\n       ScopeLine, llvmFlags, IsOptimized, TParams,\n       unwrapDIPtr<DISubprogram>(Decl));\n #endif\n   unwrap<Function>(Fn)->setSubprogram(Sub);\n   return wrap(Sub);\n }\n \n-extern \"C\" LLVMMetadataRef\n-LLVMRustDIBuilderCreateBasicType(LLVMRustDIBuilderRef Builder, const char *Name,\n-                                 uint64_t SizeInBits, uint32_t AlignInBits,\n-                                 unsigned Encoding) {\n-  return wrap(Builder->createBasicType(Name, SizeInBits, Encoding));\n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateBasicType(\n+    LLVMRustDIBuilderRef Builder, const char *Name, size_t NameLen,\n+    uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding) {\n+  return wrap(Builder->createBasicType(StringRef(Name, NameLen), SizeInBits, Encoding));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreatePointerType(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef PointeeTy,\n-    uint64_t SizeInBits, uint32_t AlignInBits, const char *Name) {\n+    uint64_t SizeInBits, uint32_t AlignInBits, unsigned AddressSpace,\n+    const char *Name, size_t NameLen) {\n   return wrap(Builder->createPointerType(unwrapDI<DIType>(PointeeTy),\n                                          SizeInBits, AlignInBits,\n-                                         /* DWARFAddressSpace */ None,\n-                                         Name));\n+                                         AddressSpace,\n+                                         StringRef(Name, NameLen)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStructType(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n     uint32_t AlignInBits, LLVMRustDIFlags Flags,\n     LLVMMetadataRef DerivedFrom, LLVMMetadataRef Elements,\n     unsigned RunTimeLang, LLVMMetadataRef VTableHolder,\n-    const char *UniqueId) {\n+    const char *UniqueId, size_t UniqueIdLen) {\n   return wrap(Builder->createStructType(\n-      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen),\n+      unwrapDI<DIFile>(File), LineNumber,\n       SizeInBits, AlignInBits, fromRust(Flags), unwrapDI<DIType>(DerivedFrom),\n       DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang,\n-      unwrapDI<DIType>(VTableHolder), UniqueId));\n+      unwrapDI<DIType>(VTableHolder), StringRef(UniqueId, UniqueIdLen)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariantPart(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n     uint32_t AlignInBits, LLVMRustDIFlags Flags, LLVMMetadataRef Discriminator,\n-    LLVMMetadataRef Elements, const char *UniqueId) {\n+    LLVMMetadataRef Elements, const char *UniqueId, size_t UniqueIdLen) {\n   return wrap(Builder->createVariantPart(\n-      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen),\n+      unwrapDI<DIFile>(File), LineNumber,\n       SizeInBits, AlignInBits, fromRust(Flags), unwrapDI<DIDerivedType>(Discriminator),\n-      DINodeArray(unwrapDI<MDTuple>(Elements)), UniqueId));\n+      DINodeArray(unwrapDI<MDTuple>(Elements)), StringRef(UniqueId, UniqueIdLen)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateMemberType(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n     uint32_t AlignInBits, uint64_t OffsetInBits, LLVMRustDIFlags Flags,\n     LLVMMetadataRef Ty) {\n-  return wrap(Builder->createMemberType(unwrapDI<DIDescriptor>(Scope), Name,\n+  return wrap(Builder->createMemberType(unwrapDI<DIDescriptor>(Scope),\n+                                        StringRef(Name, NameLen),\n                                         unwrapDI<DIFile>(File), LineNo,\n                                         SizeInBits, AlignInBits, OffsetInBits,\n                                         fromRust(Flags), unwrapDI<DIType>(Ty)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariantMemberType(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n-    const char *Name, LLVMMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n-    uint32_t AlignInBits, uint64_t OffsetInBits, LLVMValueRef Discriminant,\n+    const char *Name, size_t NameLen, LLVMMetadataRef File, unsigned LineNo,\n+    uint64_t SizeInBits, uint32_t AlignInBits, uint64_t OffsetInBits, LLVMValueRef Discriminant,\n     LLVMRustDIFlags Flags, LLVMMetadataRef Ty) {\n   llvm::ConstantInt* D = nullptr;\n   if (Discriminant) {\n     D = unwrap<llvm::ConstantInt>(Discriminant);\n   }\n-  return wrap(Builder->createVariantMemberType(unwrapDI<DIDescriptor>(Scope), Name,\n+  return wrap(Builder->createVariantMemberType(unwrapDI<DIDescriptor>(Scope),\n+                                               StringRef(Name, NameLen),\n                                                unwrapDI<DIFile>(File), LineNo,\n                                                SizeInBits, AlignInBits, OffsetInBits, D,\n                                                fromRust(Flags), unwrapDI<DIType>(Ty)));\n@@ -808,8 +827,10 @@ LLVMRustDIBuilderCreateLexicalBlockFile(LLVMRustDIBuilderRef Builder,\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Context, const char *Name,\n-    const char *LinkageName, LLVMMetadataRef File, unsigned LineNo,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Context,\n+    const char *Name, size_t NameLen,\n+    const char *LinkageName, size_t LinkageNameLen,\n+    LLVMMetadataRef File, unsigned LineNo,\n     LLVMMetadataRef Ty, bool IsLocalToUnit, LLVMValueRef V,\n     LLVMMetadataRef Decl = nullptr, uint32_t AlignInBits = 0) {\n   llvm::GlobalVariable *InitVal = cast<llvm::GlobalVariable>(unwrap(V));\n@@ -825,7 +846,8 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n   }\n \n   llvm::DIGlobalVariableExpression *VarExpr = Builder->createGlobalVariableExpression(\n-      unwrapDI<DIDescriptor>(Context), Name, LinkageName,\n+      unwrapDI<DIDescriptor>(Context), StringRef(Name, NameLen),\n+      StringRef(LinkageName, LinkageNameLen),\n       unwrapDI<DIFile>(File), LineNo, unwrapDI<DIType>(Ty), IsLocalToUnit,\n #if LLVM_VERSION_GE(10, 0)\n       /* isDefined */ true,\n@@ -843,17 +865,20 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariable(\n     LLVMRustDIBuilderRef Builder, unsigned Tag, LLVMMetadataRef Scope,\n-    const char *Name, LLVMMetadataRef File, unsigned LineNo,\n+    const char *Name, size_t NameLen,\n+    LLVMMetadataRef File, unsigned LineNo,\n     LLVMMetadataRef Ty, bool AlwaysPreserve, LLVMRustDIFlags Flags,\n     unsigned ArgNo, uint32_t AlignInBits) {\n   if (Tag == 0x100) { // DW_TAG_auto_variable\n     return wrap(Builder->createAutoVariable(\n-        unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo,\n+        unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen),\n+        unwrapDI<DIFile>(File), LineNo,\n         unwrapDI<DIType>(Ty), AlwaysPreserve, fromRust(Flags), AlignInBits));\n   } else {\n     return wrap(Builder->createParameterVariable(\n-        unwrapDI<DIDescriptor>(Scope), Name, ArgNo, unwrapDI<DIFile>(File),\n-        LineNo, unwrapDI<DIType>(Ty), AlwaysPreserve, fromRust(Flags)));\n+        unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), ArgNo,\n+        unwrapDI<DIFile>(File), LineNo,\n+        unwrapDI<DIType>(Ty), AlwaysPreserve, fromRust(Flags)));\n   }\n }\n \n@@ -894,47 +919,50 @@ extern \"C\" LLVMValueRef LLVMRustDIBuilderInsertDeclareAtEnd(\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateEnumerator(\n     LLVMRustDIBuilderRef Builder, const char *Name, size_t NameLen,\n     int64_t Value, bool IsUnsigned) {\n-  return wrap(Builder->createEnumerator({Name, NameLen}, Value, IsUnsigned));\n+  return wrap(Builder->createEnumerator(StringRef(Name, NameLen), Value, IsUnsigned));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateEnumerationType(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n     uint32_t AlignInBits, LLVMMetadataRef Elements,\n     LLVMMetadataRef ClassTy, bool IsScoped) {\n   return wrap(Builder->createEnumerationType(\n-      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen),\n+      unwrapDI<DIFile>(File), LineNumber,\n       SizeInBits, AlignInBits, DINodeArray(unwrapDI<MDTuple>(Elements)),\n       unwrapDI<DIType>(ClassTy), \"\", IsScoped));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateUnionType(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n     uint32_t AlignInBits, LLVMRustDIFlags Flags, LLVMMetadataRef Elements,\n-    unsigned RunTimeLang, const char *UniqueId) {\n+    unsigned RunTimeLang, const char *UniqueId, size_t UniqueIdLen) {\n   return wrap(Builder->createUnionType(\n-      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n-      SizeInBits, AlignInBits, fromRust(Flags),\n-      DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang, UniqueId));\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), unwrapDI<DIFile>(File),\n+      LineNumber, SizeInBits, AlignInBits, fromRust(Flags),\n+      DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang,\n+      StringRef(UniqueId, UniqueIdLen)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateTemplateTypeParameter(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef Ty, LLVMMetadataRef File, unsigned LineNo,\n     unsigned ColumnNo) {\n   return wrap(Builder->createTemplateTypeParameter(\n-      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIType>(Ty)));\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), unwrapDI<DIType>(Ty)));\n }\n \n-extern \"C\" LLVMMetadataRef\n-LLVMRustDIBuilderCreateNameSpace(LLVMRustDIBuilderRef Builder,\n-                                 LLVMMetadataRef Scope, const char *Name,\n-                                 LLVMMetadataRef File, unsigned LineNo) {\n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateNameSpace(\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen, bool ExportSymbols) {\n   return wrap(Builder->createNameSpace(\n-      unwrapDI<DIDescriptor>(Scope), Name,\n-      false // ExportSymbols (only relevant for C++ anonymous namespaces)\n-      ));\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), ExportSymbols\n+  ));\n }\n \n extern \"C\" void"}]}