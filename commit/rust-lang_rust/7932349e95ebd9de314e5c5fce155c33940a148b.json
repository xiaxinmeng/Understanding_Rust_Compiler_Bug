{"sha": "7932349e95ebd9de314e5c5fce155c33940a148b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MzIzNDllOTVlYmQ5ZGUzMTRlNWM1ZmNlMTU1YzMzOTQwYTE0OGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-25T00:40:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-25T00:40:09Z"}, "message": "Auto merge of #40072 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 11 pull requests\n\n- Successful merges: #39777, #39815, #39845, #39886, #39940, #40010, #40030, #40048, #40050, #40052, #40071\n- Failed merges:", "tree": {"sha": "2661207eb32ef57cfc5540ba31d5c3b8d5350881", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2661207eb32ef57cfc5540ba31d5c3b8d5350881"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7932349e95ebd9de314e5c5fce155c33940a148b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7932349e95ebd9de314e5c5fce155c33940a148b", "html_url": "https://github.com/rust-lang/rust/commit/7932349e95ebd9de314e5c5fce155c33940a148b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7932349e95ebd9de314e5c5fce155c33940a148b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08230775a026c955873ba557e624b7f665661f37", "url": "https://api.github.com/repos/rust-lang/rust/commits/08230775a026c955873ba557e624b7f665661f37", "html_url": "https://github.com/rust-lang/rust/commit/08230775a026c955873ba557e624b7f665661f37"}, {"sha": "f26bbb351051b17fd2d32f19fb4964415fe1d07b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f26bbb351051b17fd2d32f19fb4964415fe1d07b", "html_url": "https://github.com/rust-lang/rust/commit/f26bbb351051b17fd2d32f19fb4964415fe1d07b"}], "stats": {"total": 263, "additions": 223, "deletions": 40}, "files": [{"sha": "4f5a6a7c0332d75dd3a534d206af8ae5702f7bce", "filename": "src/doc/book/src/procedural-macros.md", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -170,7 +170,7 @@ a representation of our type (which can be either a `struct` or an `enum`).\n Check out the [docs](https://docs.rs/syn/0.10.5/syn/struct.MacroInput.html),\n there is some useful information there. We are able to get the name of the\n type using `ast.ident`. The `quote!` macro lets us write up the Rust code\n-that we wish to return and convert it into `Tokens`. `quote!` let's us use some\n+that we wish to return and convert it into `Tokens`. `quote!` lets us use some\n really cool templating mechanics; we simply write `#name` and `quote!` will\n replace it with the variable named `name`. You can even do some repetition\n similar to regular macros work. You should check out the\n@@ -211,3 +211,76 @@ Hello, World! My name is Waffles\n ```\n \n We've done it!\n+\n+## Custom Attributes\n+\n+In some cases it might make sense to allow users some kind of configuration.\n+For example, the user might want to overwrite the name that is printed in the `hello_world()` method.\n+\n+This can be achieved with custom attributes:\n+\n+```rust,ignore\n+#[derive(HelloWorld)]\n+#[HelloWorldName = \"the best Pancakes\"]\n+struct Pancakes;\n+\n+fn main() {\n+    Pancakes::hello_world();\n+}\n+```\n+\n+If we try to compile this though, the compiler will respond with an error:\n+\n+```bash\n+error: The attribute `HelloWorldName` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+```\n+\n+The compiler needs to know that we're handling this attribute and to not respond with an error.\n+This is done in the `hello-world-derive` crate by adding `attributes` to the `proc_macro_derive` attribute:\n+\n+```rust,ignore\n+#[proc_macro_derive(HelloWorld, attributes(HelloWorldName))]\n+pub fn hello_world(input: TokenStream) -> TokenStream \n+```\n+\n+Multiple attributes can be specified that way.\n+\n+## Raising Errors\n+\n+Let's assume that we do not want to accept enums as input to our custom derive method.\n+\n+This condition can be easily checked with the help of `syn`. \n+But how do we tell the user, that we do not accept enums?\n+The idiomatic way to report errors in procedural macros is to panic:\n+\n+```rust,ignore\n+fn impl_hello_world(ast: &syn::MacroInput) -> quote::Tokens {\n+    let name = &ast.ident;\n+    // Check if derive(HelloWorld) was specified for a struct\n+    if let syn::Body::Struct(_) = ast.body {\n+        // Yes, this is a struct\n+        quote! {\n+            impl HelloWorld for #name {\n+                fn hello_world() {\n+                    println!(\"Hello, World! My name is {}\", stringify!(#name));\n+                }\n+            }\n+        }\n+    } else {\n+        //Nope. This is an Enum. We cannot handle these!\n+       panic!(\"#[derive(HelloWorld)] is only defined for structs, not for enums!\");\n+    }\n+}\n+```\n+\n+If a user now tries to derive `HelloWorld` from an enum they will be greeted with following, hopefully helpful, error:\n+\n+```bash\n+error: custom derive attribute panicked\n+  --> src/main.rs\n+   |\n+   | #[derive(HelloWorld)]\n+   |          ^^^^^^^^^^\n+   |\n+   = help: message: #[derive(HelloWorld)] is only defined for structs, not for enums!\n+```"}, {"sha": "6866505df1310e8de0d3d6c2e441e988fd8aaf82", "filename": "src/doc/book/src/the-stack-and-the-heap.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Fdoc%2Fbook%2Fsrc%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Fdoc%2Fbook%2Fsrc%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fthe-stack-and-the-heap.md?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -86,7 +86,7 @@ to a large number, representing how much RAM your computer has. For example, if\n you have a gigabyte of RAM, your addresses go from `0` to `1,073,741,823`. That\n number comes from 2<sup>30</sup>, the number of bytes in a gigabyte. [^gigabyte]\n \n-[^gigabyte]: \u2018Gigabyte\u2019 can mean two things: 10^9, or 2^30. The SI standard resolved this by stating that \u2018gigabyte\u2019 is 10^9, and \u2018gibibyte\u2019 is 2^30. However, very few people use this terminology, and rely on context to differentiate. We follow in that tradition here.\n+[^gigabyte]: \u2018Gigabyte\u2019 can mean two things: 10<sup>9</sup>, or 2<sup>30</sup>. The IEC standard resolved this by stating that \u2018gigabyte\u2019 is 10<sup>9</sup>, and \u2018gibibyte\u2019 is 2<sup>30</sup>. However, very few people use this terminology, and rely on context to differentiate. We follow in that tradition here.\n \n This memory is kind of like a giant array: addresses start at zero and go\n up to the final number. So here\u2019s a diagram of our first stack frame:"}, {"sha": "a3cbc6abd69cc98023f139e408d15aab03007dc8", "filename": "src/doc/nomicon/src/exception-safety.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Fdoc%2Fnomicon%2Fsrc%2Fexception-safety.md", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Fdoc%2Fnomicon%2Fsrc%2Fexception-safety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fexception-safety.md?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -93,7 +93,7 @@ uselessly. We would rather have the following:\n ```text\n bubble_up(heap, index):\n     let elem = heap[index]\n-    while index != 0 && element < heap[parent(index)]:\n+    while index != 0 && elem < heap[parent(index)]:\n         heap[index] = heap[parent(index)]\n         index = parent(index)\n     heap[index] = elem\n@@ -137,7 +137,7 @@ If Rust had `try` and `finally` like in Java, we could do the following:\n bubble_up(heap, index):\n     let elem = heap[index]\n     try:\n-        while index != 0 && element < heap[parent(index)]:\n+ \u00a0 \u00a0 \u00a0 \u00a0while index != 0 && elem < heap[parent(index)]:\n             heap[index] = heap[parent(index)]\n             index = parent(index)\n     finally:"}, {"sha": "079541235a25e84f8e75bbb114d5c1319aa99081", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -62,7 +62,7 @@\n //!\n //! A format string is required to use all of its arguments, otherwise it is a\n //! compile-time error. You may refer to the same argument more than once in the\n-//! format string, although it must always be referred to with the same type.\n+//! format string.\n //!\n //! ## Named parameters\n //!\n@@ -89,19 +89,8 @@\n //!\n //! ## Argument types\n //!\n-//! Each argument's type is dictated by the format string. It is a requirement\n-//! that every argument is only ever referred to by one type. For example, this\n-//! is an invalid format string:\n-//!\n-//! ```text\n-//! {0:x} {0:o}\n-//! ```\n-//!\n-//! This is invalid because the first argument is both referred to as a\n-//! hexadecimal as well as an\n-//! octal.\n-//!\n-//! There are various parameters which do require a particular type, however.\n+//! Each argument's type is dictated by the format string.\n+//! There are various parameters which require a particular type, however.\n //! An example is the `{:.*}` syntax, which sets the number of decimal places\n //! in floating-point types:\n //!\n@@ -113,13 +102,7 @@\n //!\n //! If this syntax is used, then the number of characters to print precedes the\n //! actual object being formatted, and the number of characters must have the\n-//! type `usize`. Although a `usize` can be printed with `{}`, it is invalid to\n-//! reference an argument as such. For example this is another invalid format\n-//! string:\n-//!\n-//! ```text\n-//! {:.*} {0}\n-//! ```\n+//! type `usize`.\n //!\n //! ## Formatting traits\n //!"}, {"sha": "10bc5ab88c93f2001ebdbef9496ef2b7701cd759", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -1629,6 +1629,43 @@ impl hash::Hash for String {\n     }\n }\n \n+/// Implements the `+` operator for concatenating two strings.\n+///\n+/// This consumes the `String` on the left-hand side and re-uses its buffer (growing it if\n+/// necessary). This is done to avoid allocating a new `String` and copying the entire contents on\n+/// every operation, which would lead to `O(n^2)` running time when building an `n`-byte string by\n+/// repeated concatenation.\n+///\n+/// The string on the right-hand side is only borrowed; its contents are copied into the returned\n+/// `String`.\n+///\n+/// # Examples\n+///\n+/// Concatenating two `String`s takes the first by value and borrows the second:\n+///\n+/// ```\n+/// let a = String::from(\"hello\");\n+/// let b = String::from(\" world\");\n+/// let c = a + &b;\n+/// // `a` is moved and can no longer be used here.\n+/// ```\n+///\n+/// If you want to keep using the first `String`, you can clone it and append to the clone instead:\n+///\n+/// ```\n+/// let a = String::from(\"hello\");\n+/// let b = String::from(\" world\");\n+/// let c = a.clone() + &b;\n+/// // `a` is still valid here.\n+/// ```\n+///\n+/// Concatenating `&str` slices can be done by converting the first to a `String`:\n+///\n+/// ```\n+/// let a = \"hello\";\n+/// let b = \" world\";\n+/// let c = a.to_string() + b;\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Add<&'a str> for String {\n     type Output = String;\n@@ -1640,6 +1677,11 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n+/// Implements the `+=` operator for appending to a `String`.\n+///\n+/// This has the same behavior as the [`push_str()`] method.\n+///\n+/// [`push_str()`]: struct.String.html#method.push_str\n #[stable(feature = \"stringaddassign\", since = \"1.12.0\")]\n impl<'a> AddAssign<&'a str> for String {\n     #[inline]"}, {"sha": "bc7f562452d3b78bd265c0fab1096ae04865b702", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -1776,6 +1776,7 @@ array_impls! {\n     30 31 32\n }\n \n+/// Implements comparison of vectors, lexicographically.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n@@ -1787,6 +1788,7 @@ impl<T: PartialOrd> PartialOrd for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Vec<T> {}\n \n+/// Implements ordering of vectors, lexicographically.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]"}, {"sha": "0331c5d4ba4013280c27dabe8e141126117b5685", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -2202,13 +2202,15 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for [T] {}\n \n+/// Implements comparison of vectors lexicographically.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for [T] {\n     fn cmp(&self, other: &[T]) -> Ordering {\n         SliceOrd::compare(self, other)\n     }\n }\n \n+/// Implements comparison of vectors lexicographically.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for [T] {\n     fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {"}, {"sha": "925cd84154a2e6683479e3c02789acbe093a6352", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -1366,6 +1366,13 @@ mod traits {\n     use ops;\n     use str::eq_slice;\n \n+    /// Implements ordering of strings.\n+    ///\n+    /// Strings are ordered  lexicographically by their byte values.  This orders Unicode code\n+    /// points based on their positions in the code charts.  This is not necessarily the same as\n+    /// \"alphabetical\" order, which varies by language and locale.  Sorting strings according to\n+    /// culturally-accepted standards requires locale-specific data that is outside the scope of\n+    /// the `str` type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Ord for str {\n         #[inline]\n@@ -1387,6 +1394,13 @@ mod traits {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Eq for str {}\n \n+    /// Implements comparison operations on strings.\n+    ///\n+    /// Strings are compared lexicographically by their byte values.  This compares Unicode code\n+    /// points based on their positions in the code charts.  This is not necessarily the same as\n+    /// \"alphabetical\" order, which varies by language and locale.  Comparing strings according to\n+    /// culturally-accepted standards requires locale-specific data that is outside the scope of\n+    /// the `str` type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialOrd for str {\n         #[inline]"}, {"sha": "77c863a012318ca161a1ebbdf6f46a6a6839a3e0", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                         //      which contains a Foo<((T, T), (T, T))>\n                         //      which contains a Foo<(((T, T), (T, T)), ((T, T), (T, T)))>\n                         //      etc.\n-                        let error = format!(\"reached recursion limit while checking\n+                        let error = format!(\"reached recursion limit while checking \\\n                                              inhabitedness of `{}`\", self);\n                         tcx.sess.fatal(&error);\n                     }"}, {"sha": "f15e7ff891684ceee5c212d101666874614de53a", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 69, "deletions": 7, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -14,6 +14,8 @@ use sync::{Mutex, Condvar};\n /// A barrier enables multiple threads to synchronize the beginning\n /// of some computation.\n ///\n+/// # Examples\n+///\n /// ```\n /// use std::sync::{Arc, Barrier};\n /// use std::thread;\n@@ -50,8 +52,19 @@ struct BarrierState {\n \n /// A result returned from wait.\n ///\n-/// Currently this opaque structure only has one method, `.is_leader()`. Only\n+/// Currently this opaque structure only has one method, [`.is_leader()`]. Only\n /// one thread will receive a result that will return `true` from this function.\n+///\n+/// [`.is_leader()`]: #method.is_leader\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::sync::Barrier;\n+///\n+/// let barrier = Barrier::new(1);\n+/// let barrier_wait_result = barrier.wait();\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BarrierWaitResult(bool);\n \n@@ -65,8 +78,18 @@ impl fmt::Debug for Barrier {\n impl Barrier {\n     /// Creates a new barrier that can block a given number of threads.\n     ///\n-    /// A barrier will block `n`-1 threads which call `wait` and then wake up\n-    /// all threads at once when the `n`th thread calls `wait`.\n+    /// A barrier will block `n`-1 threads which call [`wait`] and then wake up\n+    /// all threads at once when the `n`th thread calls [`wait`].\n+    ///\n+    /// [`wait`]: #method.wait\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Barrier;\n+    ///\n+    /// let barrier = Barrier::new(10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(n: usize) -> Barrier {\n         Barrier {\n@@ -84,10 +107,37 @@ impl Barrier {\n     /// Barriers are re-usable after all threads have rendezvoused once, and can\n     /// be used continuously.\n     ///\n-    /// A single (arbitrary) thread will receive a `BarrierWaitResult` that\n-    /// returns `true` from `is_leader` when returning from this function, and\n+    /// A single (arbitrary) thread will receive a [`BarrierWaitResult`] that\n+    /// returns `true` from [`is_leader`] when returning from this function, and\n     /// all other threads will receive a result that will return `false` from\n-    /// `is_leader`\n+    /// [`is_leader`].\n+    ///\n+    /// [`BarrierWaitResult`]: struct.BarrierWaitResult.html\n+    /// [`is_leader`]: struct.BarrierWaitResult.html#method.is_leader\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Barrier};\n+    /// use std::thread;\n+    ///\n+    /// let mut handles = Vec::with_capacity(10);\n+    /// let barrier = Arc::new(Barrier::new(10));\n+    /// for _ in 0..10 {\n+    ///     let c = barrier.clone();\n+    ///     // The same messages will be printed together.\n+    ///     // You will NOT see any interleaving.\n+    ///     handles.push(thread::spawn(move|| {\n+    ///         println!(\"before wait\");\n+    ///         c.wait();\n+    ///         println!(\"after wait\");\n+    ///     }));\n+    /// }\n+    /// // Wait for other threads to finish.\n+    /// for handle in handles {\n+    ///     handle.join().unwrap();\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn wait(&self) -> BarrierWaitResult {\n         let mut lock = self.lock.lock().unwrap();\n@@ -120,10 +170,22 @@ impl fmt::Debug for BarrierWaitResult {\n }\n \n impl BarrierWaitResult {\n-    /// Returns whether this thread from `wait` is the \"leader thread\".\n+    /// Returns whether this thread from [`wait`] is the \"leader thread\".\n     ///\n     /// Only one thread will have `true` returned from their result, all other\n     /// threads will have `false` returned.\n+    ///\n+    /// [`wait`]: struct.Barrier.html#method.wait\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Barrier;\n+    ///\n+    /// let barrier = Barrier::new(1);\n+    /// let barrier_wait_result = barrier.wait();\n+    /// println!(\"{:?}\", barrier_wait_result.is_leader());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_leader(&self) -> bool { self.0 }\n }"}, {"sha": "97b84d59218ac290de902b451f7ccfbfb9ffea58", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -133,11 +133,13 @@ unsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }\n /// dropped (falls out of scope), the lock will be unlocked.\n ///\n /// The data protected by the mutex can be access through this guard via its\n-/// `Deref` and `DerefMut` implementations.\n+/// [`Deref`] and [`DerefMut`] implementations.\n ///\n /// This structure is created by the [`lock()`] and [`try_lock()`] methods on\n /// [`Mutex`].\n ///\n+/// [`Deref`]: ../../std/ops/trait.Deref.html\n+/// [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n /// [`lock()`]: struct.Mutex.html#method.lock\n /// [`try_lock()`]: struct.Mutex.html#method.try_lock\n /// [`Mutex`]: struct.Mutex.html"}, {"sha": "2bc066d3fea55c3c203525a08317a3e1cd609aa5", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -235,7 +235,7 @@ pub use self::local::{LocalKey, LocalKeyState};\n pub struct Builder {\n     // A name for the thread-to-be, for identification in panic messages\n     name: Option<String>,\n-    // The size of the stack for the spawned thread\n+    // The size of the stack for the spawned thread in bytes\n     stack_size: Option<usize>,\n }\n \n@@ -289,14 +289,17 @@ impl Builder {\n         self\n     }\n \n-    /// Sets the size of the stack for the new thread.\n+    /// Sets the size of the stack (in bytes) for the new thread.\n+    ///\n+    /// The actual stack size may be greater than this value if\n+    /// the platform specifies minimal stack size.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::thread;\n     ///\n-    /// let builder = thread::Builder::new().stack_size(10);\n+    /// let builder = thread::Builder::new().stack_size(32 * 1024);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn stack_size(mut self, size: usize) -> Builder {"}, {"sha": "5fdb0aa0641a0057c0dacaa47900cd8b7bdaf2fa", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7932349e95ebd9de314e5c5fce155c33940a148b/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=7932349e95ebd9de314e5c5fce155c33940a148b", "patch": "@@ -106,7 +106,7 @@ impl fmt::Display for TestName {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq)]\n-enum NamePadding {\n+pub enum NamePadding {\n     PadNone,\n     PadOnRight,\n }\n@@ -950,7 +950,7 @@ fn stdout_isatty() -> bool {\n }\n \n #[derive(Clone)]\n-enum TestEvent {\n+pub enum TestEvent {\n     TeFiltered(Vec<TestDesc>),\n     TeWait(TestDesc, NamePadding),\n     TeResult(TestDesc, TestResult, Vec<u8>),\n@@ -960,7 +960,7 @@ enum TestEvent {\n pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n \n \n-fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n+pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n     where F: FnMut(TestEvent) -> io::Result<()>\n {\n     use std::collections::HashMap;"}]}