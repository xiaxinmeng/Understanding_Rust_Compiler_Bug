{"sha": "aab4d6b8d73f029d178c3ac055152f57c7233995", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhYjRkNmI4ZDczZjAyOWQxNzhjM2FjMDU1MTUyZjU3YzcyMzM5OTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-29T21:45:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-29T22:34:38Z"}, "message": "std: Camel case some constructors", "tree": {"sha": "4bcf9b989e5dd2be2b8b3086c5365b7115765a9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bcf9b989e5dd2be2b8b3086c5365b7115765a9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aab4d6b8d73f029d178c3ac055152f57c7233995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aab4d6b8d73f029d178c3ac055152f57c7233995", "html_url": "https://github.com/rust-lang/rust/commit/aab4d6b8d73f029d178c3ac055152f57c7233995", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aab4d6b8d73f029d178c3ac055152f57c7233995/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c5c835a1dccd55287bbd81564d74a009497be57", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c5c835a1dccd55287bbd81564d74a009497be57", "html_url": "https://github.com/rust-lang/rust/commit/6c5c835a1dccd55287bbd81564d74a009497be57"}], "stats": {"total": 171, "additions": 85, "deletions": 86}, "files": [{"sha": "89cdb2a674d39c27f751e74527ec047a06f5e3ac", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -10,13 +10,13 @@ import unsafe::{SharedMutableState, shared_mutable_state,\n                 clone_shared_mutable_state, unwrap_shared_mutable_state,\n                 get_shared_mutable_state, get_shared_immutable_state};\n import sync;\n-import sync::{Mutex,  mutex,  mutex_with_condvars,\n-              RWlock, rwlock, rwlock_with_condvars};\n+import sync::{Mutex,  mutex_with_condvars,\n+              RWlock, rwlock_with_condvars};\n \n-export ARC, arc, clone, get;\n+export ARC, clone, get;\n export Condvar;\n-export MutexARC, mutex_arc, mutex_arc_with_condvars, unwrap_mutex_arc;\n-export RWARC, rw_arc, rw_arc_with_condvars, RWWriteMode, RWReadMode;\n+export MutexARC, mutex_arc_with_condvars, unwrap_mutex_arc;\n+export RWARC, rw_arc_with_condvars, RWWriteMode, RWReadMode;\n export unwrap_rw_arc;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signalling.\n@@ -73,7 +73,7 @@ impl &Condvar {\n struct ARC<T: const send> { x: SharedMutableState<T>; }\n \n /// Create an atomically reference counted wrapper.\n-fn arc<T: const send>(+data: T) -> ARC<T> {\n+fn ARC<T: const send>(+data: T) -> ARC<T> {\n     ARC { x: unsafe { shared_mutable_state(data) } }\n }\n \n@@ -120,7 +120,7 @@ struct MutexARCInner<T: send> { lock: Mutex; failed: bool; data: T; }\n struct MutexARC<T: send> { x: SharedMutableState<MutexARCInner<T>>; }\n \n /// Create a mutex-protected ARC with the supplied data.\n-fn mutex_arc<T: send>(+user_data: T) -> MutexARC<T> {\n+fn MutexARC<T: send>(+user_data: T) -> MutexARC<T> {\n     mutex_arc_with_condvars(user_data, 1)\n }\n /**\n@@ -249,7 +249,7 @@ struct RWARC<T: const send> {\n }\n \n /// Create a reader/writer ARC with the supplied data.\n-fn rw_arc<T: const send>(+user_data: T) -> RWARC<T> {\n+fn RWARC<T: const send>(+user_data: T) -> RWARC<T> {\n     rw_arc_with_condvars(user_data, 1)\n }\n /**\n@@ -445,7 +445,7 @@ mod tests {\n     #[test]\n     fn manually_share_arc() {\n         let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        let arc_v = arc::arc(v);\n+        let arc_v = arc::ARC(v);\n \n         let (c, p) = pipes::stream();\n \n@@ -469,7 +469,7 @@ mod tests {\n \n     #[test]\n     fn test_mutex_arc_condvar() {\n-        let arc = ~mutex_arc(false);\n+        let arc = ~MutexARC(false);\n         let arc2 = ~arc.clone();\n         let (c,p) = pipes::oneshot();\n         let (c,p) = (~mut Some(c), ~mut Some(p));\n@@ -491,7 +491,7 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_arc_condvar_poison() {\n-        let arc = ~mutex_arc(1);\n+        let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n         let (c,p) = pipes::stream();\n \n@@ -512,7 +512,7 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_mutex_arc_poison() {\n-        let arc = ~mutex_arc(1);\n+        let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n         do task::try {\n             do arc2.access |one| {\n@@ -525,7 +525,7 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_mutex_arc_unwrap_poison() {\n-        let arc = mutex_arc(1);\n+        let arc = MutexARC(1);\n         let arc2 = ~(&arc).clone();\n         let (c,p) = pipes::stream();\n         do task::spawn {\n@@ -540,7 +540,7 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rw_arc_poison_wr() {\n-        let arc = ~rw_arc(1);\n+        let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try {\n             do arc2.write |one| {\n@@ -553,7 +553,7 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rw_arc_poison_ww() {\n-        let arc = ~rw_arc(1);\n+        let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try {\n             do arc2.write |one| {\n@@ -566,7 +566,7 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rw_arc_poison_dw() {\n-        let arc = ~rw_arc(1);\n+        let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try {\n             do arc2.write_downgrade |write_mode| {\n@@ -581,7 +581,7 @@ mod tests {\n     }\n     #[test] #[ignore(cfg(windows))]\n     fn test_rw_arc_no_poison_rr() {\n-        let arc = ~rw_arc(1);\n+        let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try {\n             do arc2.read |one| {\n@@ -594,7 +594,7 @@ mod tests {\n     }\n     #[test] #[ignore(cfg(windows))]\n     fn test_rw_arc_no_poison_rw() {\n-        let arc = ~rw_arc(1);\n+        let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try {\n             do arc2.read |one| {\n@@ -607,7 +607,7 @@ mod tests {\n     }\n     #[test] #[ignore(cfg(windows))]\n     fn test_rw_arc_no_poison_dr() {\n-        let arc = ~rw_arc(1);\n+        let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try {\n             do arc2.write_downgrade |write_mode| {\n@@ -623,7 +623,7 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc() {\n-        let arc = ~rw_arc(0);\n+        let arc = ~RWARC(0);\n         let arc2 = ~arc.clone();\n         let (c,p) = pipes::stream();\n \n@@ -662,7 +662,7 @@ mod tests {\n         // (4) tells writer and all other readers to contend as it downgrades.\n         // (5) Writer attempts to set state back to 42, while downgraded task\n         //     and all reader tasks assert that it's 31337.\n-        let arc = ~rw_arc(0);\n+        let arc = ~RWARC(0);\n \n         // Reader tasks\n         let mut reader_convos = ~[];"}, {"sha": "6af7f71cb302fb961c7b3d0fdc1e3f5f6b1b02c8", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -28,7 +28,7 @@\n  */\n \n export CVec;\n-export c_vec, c_vec_with_dtor;\n+export CVec, c_vec_with_dtor;\n export get, set;\n export len;\n export ptr;\n@@ -66,7 +66,7 @@ struct DtorRes {\n  * * base - A foreign pointer to a buffer\n  * * len - The number of elements in the buffer\n  */\n-unsafe fn c_vec<T>(base: *mut T, len: uint) -> CVec<T> {\n+unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n     return CVecCtor({\n         base: base,\n         len: len,"}, {"sha": "068ad608e68ab66c6c7509efe225a0f2143ec665", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -6,7 +6,6 @@\n import core::Option;\n import option::{Some, None};\n \n-export doc;\n export Doc;\n export doc_at;\n export maybe_get_doc;\n@@ -75,7 +74,7 @@ fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n     } else { error!(\"vint too big\"); fail; }\n }\n \n-fn doc(data: @~[u8]) -> Doc {\n+fn Doc(data: @~[u8]) -> Doc {\n     return {data: data, start: 0u, end: vec::len::<u8>(*data)};\n }\n \n@@ -619,7 +618,7 @@ fn test_option_int() {\n         let mbuf = io::mem_buffer();\n         let ebml_w = ebml::Writer(io::mem_buffer_writer(mbuf));\n         serialize_0(ebml_w, v);\n-        let ebml_doc = ebml::doc(@io::mem_buffer_buf(mbuf));\n+        let ebml_doc = ebml::Doc(@io::mem_buffer_buf(mbuf));\n         let deser = ebml_deserializer(ebml_doc);\n         let v1 = deserialize_0(deser);\n         debug!(\"v1 == %?\", v1);"}, {"sha": "acd25bd7c7cd60e58472020ffa5167efb4272558", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -8,8 +8,8 @@\n  * in std.\n  */\n \n-export Condvar, Semaphore, Mutex, mutex, mutex_with_condvars;\n-export RWlock, rwlock, rwlock_with_condvars, RWlockReadMode, RWlockWriteMode;\n+export Condvar, Semaphore, Mutex, mutex_with_condvars;\n+export RWlock, rwlock_with_condvars, RWlockReadMode, RWlockWriteMode;\n \n import unsafe::{Exclusive, exclusive};\n \n@@ -362,7 +362,7 @@ impl &Semaphore {\n struct Mutex { priv sem: Sem<~[mut Waitqueue]>; }\n \n /// Create a new mutex, with one associated condvar.\n-fn mutex() -> Mutex { mutex_with_condvars(1) }\n+fn Mutex() -> Mutex { mutex_with_condvars(1) }\n /**\n  * Create a new mutex, with a specified number of associated condvars. This\n  * will allow calling wait_on/signal_on/broadcast_on with condvar IDs between\n@@ -412,7 +412,7 @@ struct RWlock {\n }\n \n /// Create a new rwlock, with one associated condvar.\n-fn rwlock() -> RWlock { rwlock_with_condvars(1) }\n+fn RWlock() -> RWlock { rwlock_with_condvars(1) }\n \n /**\n  * Create a new rwlock, with a specified number of associated condvars.\n@@ -745,7 +745,7 @@ mod tests {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp <- ptr; inc tmp; store ptr <- tmp\" dance.\n         let (c,p) = pipes::stream();\n-        let m = ~mutex();\n+        let m = ~Mutex();\n         let m2 = ~m.clone();\n         let sharedstate = ~0;\n         let ptr = ptr::addr_of(*sharedstate);\n@@ -773,7 +773,7 @@ mod tests {\n     }\n     #[test]\n     fn test_mutex_cond_wait() {\n-        let m = ~mutex();\n+        let m = ~Mutex();\n \n         // Child wakes up parent\n         do m.lock_cond |cond| {\n@@ -805,7 +805,7 @@ mod tests {\n     }\n     #[cfg(test)]\n     fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n-        let m = ~mutex();\n+        let m = ~Mutex();\n         let mut ports = ~[];\n \n         for num_waiters.times {\n@@ -840,7 +840,7 @@ mod tests {\n     }\n     #[test]\n     fn test_mutex_cond_no_waiter() {\n-        let m = ~mutex();\n+        let m = ~Mutex();\n         let m2 = ~m.clone();\n         do task::try {\n             do m.lock_cond |_x| { }\n@@ -852,7 +852,7 @@ mod tests {\n     #[test] #[ignore(cfg(windows))]\n     fn test_mutex_killed_simple() {\n         // Mutex must get automatically unlocked if failed/killed within.\n-        let m = ~mutex();\n+        let m = ~Mutex();\n         let m2 = ~m.clone();\n \n         let result: result::Result<(),()> = do task::try {\n@@ -868,7 +868,7 @@ mod tests {\n     fn test_mutex_killed_cond() {\n         // Getting killed during cond wait must not corrupt the mutex while\n         // unwinding (e.g. double unlock).\n-        let m = ~mutex();\n+        let m = ~Mutex();\n         let m2 = ~m.clone();\n \n         let result: result::Result<(),()> = do task::try {\n@@ -892,7 +892,7 @@ mod tests {\n     }\n     #[test] #[ignore(cfg(windows))]\n     fn test_mutex_killed_broadcast() {\n-        let m = ~mutex();\n+        let m = ~Mutex();\n         let m2 = ~m.clone();\n         let (c,p) = pipes::stream();\n \n@@ -936,7 +936,7 @@ mod tests {\n     #[test]\n     fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n-        let m = ~mutex();\n+        let m = ~Mutex();\n         do m.lock_cond |cond| {\n             let m2 = ~m.clone();\n             do task::spawn {\n@@ -1040,17 +1040,17 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_wont_modify_the_data() {\n-        test_rwlock_exclusion(~rwlock(), Read, Write);\n-        test_rwlock_exclusion(~rwlock(), Write, Read);\n-        test_rwlock_exclusion(~rwlock(), Read, Downgrade);\n-        test_rwlock_exclusion(~rwlock(), Downgrade, Read);\n+        test_rwlock_exclusion(~RWlock(), Read, Write);\n+        test_rwlock_exclusion(~RWlock(), Write, Read);\n+        test_rwlock_exclusion(~RWlock(), Read, Downgrade);\n+        test_rwlock_exclusion(~RWlock(), Downgrade, Read);\n     }\n     #[test]\n     fn test_rwlock_writers_and_writers() {\n-        test_rwlock_exclusion(~rwlock(), Write, Write);\n-        test_rwlock_exclusion(~rwlock(), Write, Downgrade);\n-        test_rwlock_exclusion(~rwlock(), Downgrade, Write);\n-        test_rwlock_exclusion(~rwlock(), Downgrade, Downgrade);\n+        test_rwlock_exclusion(~RWlock(), Write, Write);\n+        test_rwlock_exclusion(~RWlock(), Write, Downgrade);\n+        test_rwlock_exclusion(~RWlock(), Downgrade, Write);\n+        test_rwlock_exclusion(~RWlock(), Downgrade, Downgrade);\n     }\n     #[cfg(test)]\n     fn test_rwlock_handshake(+x: ~RWlock, mode1: RWlockMode,\n@@ -1084,32 +1084,32 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_and_readers() {\n-        test_rwlock_handshake(~rwlock(), Read, Read, false);\n+        test_rwlock_handshake(~RWlock(), Read, Read, false);\n         // The downgrader needs to get in before the reader gets in, otherwise\n         // they cannot end up reading at the same time.\n-        test_rwlock_handshake(~rwlock(), DowngradeRead, Read, false);\n-        test_rwlock_handshake(~rwlock(), Read, DowngradeRead, true);\n+        test_rwlock_handshake(~RWlock(), DowngradeRead, Read, false);\n+        test_rwlock_handshake(~RWlock(), Read, DowngradeRead, true);\n         // Two downgrade_reads can never both end up reading at the same time.\n     }\n     #[test]\n     fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n-        let x = ~rwlock();\n+        let x = ~RWlock();\n         do lock_rwlock_in_mode(x, Downgrade) { }\n         test_rwlock_handshake(x, Read, Read, false);\n-        let y = ~rwlock();\n+        let y = ~RWlock();\n         do lock_rwlock_in_mode(y, DowngradeRead) { }\n         test_rwlock_exclusion(y, Write, Write);\n     }\n     #[test]\n     fn test_rwlock_read_recursive() {\n-        let x = ~rwlock();\n+        let x = ~RWlock();\n         do x.read { do x.read { } }\n     }\n     #[test]\n     fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n-        let x = ~rwlock();\n+        let x = ~RWlock();\n \n         // Child wakes up parent\n         do x.write_cond |cond| {\n@@ -1154,7 +1154,7 @@ mod tests {\n                 x.write_cond(blk)\n             }\n         }\n-        let x = ~rwlock();\n+        let x = ~RWlock();\n         let mut ports = ~[];\n \n         for num_waiters.times {\n@@ -1193,7 +1193,7 @@ mod tests {\n     #[cfg(test)] #[ignore(cfg(windows))]\n     fn rwlock_kill_helper(mode1: RWlockMode, mode2: RWlockMode) {\n         // Mutex must get automatically unlocked if failed/killed within.\n-        let x = ~rwlock();\n+        let x = ~RWlock();\n         let x2 = ~x.clone();\n \n         let result: result::Result<(),()> = do task::try {\n@@ -1231,8 +1231,8 @@ mod tests {\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rwlock_downgrade_cant_swap() {\n         // Tests that you can't downgrade with a different rwlock's token.\n-        let x = ~rwlock();\n-        let y = ~rwlock();\n+        let x = ~RWlock();\n+        let y = ~RWlock();\n         do x.write_downgrade |xwrite| {\n             let mut xopt = Some(xwrite);\n             do y.write_downgrade |_ywrite| {"}, {"sha": "0c98541a363cf682e1202671d4448a65846a9f28", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -136,7 +136,7 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                   def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n-    let all_items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n+    let all_items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n     debug!(\"Looking up %?\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),"}, {"sha": "ac9d3d01554dd5c9d61c1cb85873d29fef405378", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -98,7 +98,7 @@ fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n-    let items = ebml::get_doc(ebml::doc(data), tag_items);\n+    let items = ebml::get_doc(ebml::Doc(data), tag_items);\n     match maybe_find_item(item_id, items) {\n        None => fail(fmt!(\"lookup_item: id not found: %d\", item_id)),\n        Some(d) => d\n@@ -362,7 +362,7 @@ fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n \n fn get_impl_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n                    name: ast::ident) -> ast::def_id {\n-    let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n+    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n     let mut found = None;\n     for ebml::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n         let m_did = ebml::with_doc_data(mid, |d| parse_def_id(d));\n@@ -375,7 +375,7 @@ fn get_impl_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n \n fn get_class_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n                     name: ast::ident) -> ast::def_id {\n-    let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n+    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n       Some(it) => it,\n@@ -396,7 +396,7 @@ fn get_class_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n }\n \n fn class_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n-    let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n+    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n             Some(it) => it,\n@@ -445,7 +445,7 @@ struct path_entry {\n \n /// Iterates over all the paths in the given crate.\n fn each_path(intr: ident_interner, cdata: cmd, f: fn(path_entry) -> bool) {\n-    let root = ebml::doc(cdata.data);\n+    let root = ebml::Doc(cdata.data);\n     let items = ebml::get_doc(root, tag_items);\n     let items_data = ebml::get_doc(items, tag_items_data);\n \n@@ -564,7 +564,7 @@ fn maybe_get_item_ast(intr: ident_interner, cdata: cmd, tcx: ty::ctxt,\n fn get_enum_variants(intr: ident_interner, cdata: cmd, id: ast::node_id,\n                      tcx: ty::ctxt) -> ~[ty::variant_info] {\n     let data = cdata.data;\n-    let items = ebml::get_doc(ebml::doc(data), tag_items);\n+    let items = ebml::get_doc(ebml::Doc(data), tag_items);\n     let item = find_item(id, items);\n     let mut infos: ~[ty::variant_info] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n@@ -888,15 +888,15 @@ fn list_crate_attributes(intr: ident_interner, md: ebml::Doc, hash: ~str,\n }\n \n fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n-    return get_attributes(ebml::doc(data));\n+    return get_attributes(ebml::Doc(data));\n }\n \n type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n                   vers: ~str, hash: ~str};\n \n fn get_crate_deps(intr: ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n-    let cratedoc = ebml::doc(data);\n+    let cratedoc = ebml::Doc(data);\n     let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n     fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n@@ -925,7 +925,7 @@ fn list_crate_deps(intr: ident_interner, data: @~[u8], out: io::Writer) {\n }\n \n fn get_crate_hash(data: @~[u8]) -> ~str {\n-    let cratedoc = ebml::doc(data);\n+    let cratedoc = ebml::Doc(data);\n     let hashdoc = ebml::get_doc(cratedoc, tag_crate_hash);\n     return str::from_bytes(ebml::doc_data(hashdoc));\n }\n@@ -981,7 +981,7 @@ fn get_crate_module_paths(intr: ident_interner, cdata: cmd)\n fn list_crate_metadata(intr: ident_interner, bytes: @~[u8],\n                        out: io::Writer) {\n     let hash = get_crate_hash(bytes);\n-    let md = ebml::doc(bytes);\n+    let md = ebml::Doc(bytes);\n     list_crate_attributes(intr, md, hash, out);\n     list_crate_deps(intr, bytes, out);\n }"}, {"sha": "3f329bc9b7678026d9b84af299414909d753cb0c", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -939,7 +939,7 @@ fn roundtrip(in_item: @ast::item) {\n     let mbuf = io::mem_buffer();\n     let ebml_w = ebml::Writer(io::mem_buffer_writer(mbuf));\n     encode_item_ast(ebml_w, in_item);\n-    let ebml_doc = ebml::doc(@io::mem_buffer_buf(mbuf));\n+    let ebml_doc = ebml::Doc(@io::mem_buffer_buf(mbuf));\n     let out_item = decode_item_ast(ebml_doc);\n \n     let exp_str ="}, {"sha": "cb94e43d8e7f039fbff18f7e6b04e855d85ee8cd", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -241,7 +241,7 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         i += 1u;\n         let old_len = colors.len();\n \n-        let color = arc::arc(colors);\n+        let color = arc::ARC(colors);\n \n         colors = do par::mapi_factory(*arc::get(&color)) {\n             let colors = arc::clone(&color);\n@@ -414,7 +414,7 @@ fn main(args: ~[~str]) {\n     let mut total_seq = 0.0;\n     let mut total_par = 0.0;\n \n-    let graph_arc = arc::arc(copy graph);\n+    let graph_arc = arc::ARC(copy graph);\n \n     do gen_search_keys(graph, num_keys).map() |root| {\n         io::stdout().write_line(~\"\");"}, {"sha": "9145a586161464c5cd6a0ecf0329374af889be1f", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -32,7 +32,7 @@ fn recv(p: &pipe) -> uint {\n }\n \n fn init() -> (pipe,pipe) {\n-    let m = arc::mutex_arc(~[]);\n+    let m = arc::MutexARC(~[]);\n     ((&m).clone(), m)\n }\n "}, {"sha": "7f7c42be2746c04ad49e23281efa4eca6bd7a3c3", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -32,7 +32,7 @@ fn recv(p: &pipe) -> uint {\n }\n \n fn init() -> (pipe,pipe) {\n-    let x = arc::rw_arc(~[]);\n+    let x = arc::RWARC(~[]);\n     ((&x).clone(), x)\n }\n "}, {"sha": "52ea25257ad6d61579a6b1aec1f4618970ed41e4", "filename": "src/test/compile-fail/arc-rw-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std::arc;\n fn main() {\n-    let x = ~arc::rw_arc(1);\n+    let x = ~arc::RWARC(1);\n     let mut y = None;\n     do x.write_cond |_one, cond| {\n         y = Some(cond);"}, {"sha": "104e4f103d38d81bf836704b5fac99db50dd4f90", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -1,7 +1,7 @@\n use std;\n import std::arc;\n fn main() {\n-    let x = ~arc::rw_arc(1);\n+    let x = ~arc::RWARC(1);\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         y = Some(x.downgrade(write_mode));"}, {"sha": "1639f9a86b4f73cedc9c35eaf9850eb1b20c9d12", "filename": "src/test/compile-fail/arc-rw-state-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std::arc;\n fn main() {\n-    let x = ~arc::rw_arc(1);\n+    let x = ~arc::RWARC(1);\n     let mut y = None;\n     do x.write |one| {\n         y = Some(one);"}, {"sha": "2b28172e3fd585bbe529ba416de31f3c35dd2f3f", "filename": "src/test/compile-fail/arc-rw-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std::arc;\n fn main() {\n-    let x = ~arc::rw_arc(1);\n+    let x = ~arc::RWARC(1);\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         do (&write_mode).write_cond |_one, cond| {"}, {"sha": "7aa97d7d1ee1ab44a9935ef577032b78dfd6e980", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std::arc;\n fn main() {\n-    let x = ~arc::rw_arc(1);\n+    let x = ~arc::RWARC(1);\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         y = Some(write_mode);"}, {"sha": "606d6e19950a6f7fbce8eaa37393840045a43b21", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -6,7 +6,7 @@ import comm::*;\n \n fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    let arc_v = arc::arc(v);\n+    let arc_v = arc::ARC(v);\n     \n     do task::spawn() {\n         let v = *arc::get(&arc_v);"}, {"sha": "dcdd57c898b0872be9e2f5de6697a6f31a9bab79", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -4,7 +4,7 @@ import comm::*;\n \n fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    let arc_v = arc::arc(v);\n+    let arc_v = arc::ARC(v);\n \n     do task::spawn() |move arc_v| { //~ NOTE move of variable occurred here\n         let v = *arc::get(&arc_v);"}, {"sha": "704d1a2e443b067eaf9b22877cce9d880f4325bd", "filename": "src/test/compile-fail/sync-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -3,7 +3,7 @@ use std;\n import std::sync;\n \n fn main() {\n-    let m = ~sync::mutex();\n+    let m = ~sync::Mutex();\n     let mut cond = None;\n     do m.lock_cond |c| {\n         cond = Some(c);"}, {"sha": "c64c75f8040ac43763d2416f132bbe2fc8259856", "filename": "src/test/compile-fail/sync-rwlock-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std::sync;\n fn main() {\n-    let x = ~sync::rwlock();\n+    let x = ~sync::RWlock();\n     let mut y = None;\n     do x.write_cond |cond| {\n         y = Some(cond);"}, {"sha": "373c2f80efac683655141f6a08aef8f67bd651a2", "filename": "src/test/compile-fail/sync-rwlock-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std::sync;\n fn main() {\n-    let x = ~sync::rwlock();\n+    let x = ~sync::RWlock();\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         y = Some(x.downgrade(write_mode));"}, {"sha": "79aff5f3a558e02d95276dcba6d4bdec7ac6e03f", "filename": "src/test/compile-fail/sync-rwlock-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std::sync;\n fn main() {\n-    let x = ~sync::rwlock();\n+    let x = ~sync::RWlock();\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         do (&write_mode).write_cond |cond| {"}, {"sha": "fde9656ca81b1c6f28b36641cd1afa6661a4bea2", "filename": "src/test/compile-fail/sync-rwlock-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std::sync;\n fn main() {\n-    let x = ~sync::rwlock();\n+    let x = ~sync::RWlock();\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         y = Some(write_mode);"}, {"sha": "62201eebe4101882d4a98db7ee4f0ca1de085b50", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab4d6b8d73f029d178c3ac055152f57c7233995/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=aab4d6b8d73f029d178c3ac055152f57c7233995", "patch": "@@ -23,7 +23,7 @@ fn test_ser_and_deser<A>(a1: A,\n     let buf = io::mem_buffer();\n     let w = ebml::Writer(buf as io::Writer);\n     ebml_ser_fn(w, a1);\n-    let d = ebml::doc(@io::mem_buffer_buf(buf));\n+    let d = ebml::Doc(@io::mem_buffer_buf(buf));\n     let a2 = ebml_deser_fn(ebml::ebml_deserializer(d));\n     io::print(~\"\\na1 = \");\n     io_ser_fn(io::stdout(), a1);"}]}