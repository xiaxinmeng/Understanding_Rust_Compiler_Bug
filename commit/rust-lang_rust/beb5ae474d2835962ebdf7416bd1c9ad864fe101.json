{"sha": "beb5ae474d2835962ebdf7416bd1c9ad864fe101", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlYjVhZTQ3NGQyODM1OTYyZWJkZjc0MTZiZDFjOWFkODY0ZmUxMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T21:08:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T21:08:06Z"}, "message": "Auto merge of #77023 - HeroicKatora:len-missed-optimization, r=Mark-Simulacrum\n\nHint the maximum length permitted by invariant of slices\n\nOne of the safety invariants of references, and in particular of references to slices, is that they may not cover more than `isize::MAX` bytes. The unsafe `from_raw_parts` constructors of slices explicitly requires the caller to guarantee this fact. Violating it would also be UB with regards to the semantics of generated llvm code.\n\nThis effectively bounds the length of a (non-ZST) slice from above by a compile time constant. But when the length is loaded from a function argument it appears llvm is not aware of this requirement. The additional value range assertions allow some further elision of code branches, including overflow checks, especially in the presence of artithmetic on the indices.\n\nThis may have a performance impact, adding more code to a common method but allowing more optimization. I'm not quite sure, is the Rust side of const-prop strong enough to elide the irrelevant match branches?\n\nFixes: #67186", "tree": {"sha": "0e85c63f96c094cb01ece1687dac8c91ae96b4b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e85c63f96c094cb01ece1687dac8c91ae96b4b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/beb5ae474d2835962ebdf7416bd1c9ad864fe101", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/beb5ae474d2835962ebdf7416bd1c9ad864fe101", "html_url": "https://github.com/rust-lang/rust/commit/beb5ae474d2835962ebdf7416bd1c9ad864fe101", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/beb5ae474d2835962ebdf7416bd1c9ad864fe101/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ccf5f731bb71db3470002d6baf5ab4792b821d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ccf5f731bb71db3470002d6baf5ab4792b821d9", "html_url": "https://github.com/rust-lang/rust/commit/4ccf5f731bb71db3470002d6baf5ab4792b821d9"}, {"sha": "e44784b8750016a695361c990024750e037d8f9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e44784b8750016a695361c990024750e037d8f9f", "html_url": "https://github.com/rust-lang/rust/commit/e44784b8750016a695361c990024750e037d8f9f"}], "stats": {"total": 54, "additions": 51, "deletions": 3}, "files": [{"sha": "49cec16276260ad81b5e74fd13a090828df162cc", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/beb5ae474d2835962ebdf7416bd1c9ad864fe101/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb5ae474d2835962ebdf7416bd1c9ad864fe101/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=beb5ae474d2835962ebdf7416bd1c9ad864fe101", "patch": "@@ -80,8 +80,9 @@\n #![feature(constctlz)]\n #![feature(const_panic)]\n #![feature(const_pin)]\n-#![feature(const_fn_union)]\n #![feature(const_fn)]\n+#![feature(const_fn_union)]\n+#![feature(const_assume)]\n #![cfg_attr(not(bootstrap), feature(const_fn_floating_point_arithmetic))]\n #![cfg_attr(not(bootstrap), feature(const_fn_fn_ptr_basics))]\n #![feature(const_generics)]"}, {"sha": "9373c6feccda36840398b3d3c1ba164d1a74eb20", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/beb5ae474d2835962ebdf7416bd1c9ad864fe101/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb5ae474d2835962ebdf7416bd1c9ad864fe101/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=beb5ae474d2835962ebdf7416bd1c9ad864fe101", "patch": "@@ -78,6 +78,17 @@ pub use index::check_range;\n #[lang = \"slice\"]\n #[cfg(not(test))]\n impl<T> [T] {\n+    #[cfg(not(bootstrap))] // Unused in bootstrap\n+    /// The maximum, inclusive, length such that the slice is no larger than `isize::MAX` bytes.\n+    /// This constant is used in `len` below.\n+    const MAX_LEN_BOUND: usize = {\n+        if mem::size_of::<T>() == 0 {\n+            usize::MAX\n+        } else {\n+            isize::MAX as usize / mem::size_of::<T>()\n+        }\n+    };\n+\n     /// Returns the number of elements in the slice.\n     ///\n     /// # Examples\n@@ -90,11 +101,23 @@ impl<T> [T] {\n     #[rustc_const_stable(feature = \"const_slice_len\", since = \"1.32.0\")]\n     #[inline]\n     // SAFETY: const sound because we transmute out the length field as a usize (which it must be)\n-    #[allow_internal_unstable(const_fn_union)]\n+    #[allow_internal_unstable(const_fn_union, const_assume)]\n     pub const fn len(&self) -> usize {\n         // SAFETY: this is safe because `&[T]` and `FatPtr<T>` have the same layout.\n         // Only `std` can make this guarantee.\n-        unsafe { crate::ptr::Repr { rust: self }.raw.len }\n+        let raw_len = unsafe { crate::ptr::Repr { rust: self }.raw.len };\n+\n+        #[cfg(not(bootstrap))] // FIXME: executing assume in const eval not supported in bootstrap\n+        // SAFETY: this assume asserts that `raw_len * size_of::<T>() <= isize::MAX`. All\n+        // references must point to one allocation with size at most isize::MAX. Note that we the\n+        // multiplication could appear to overflow until we have assumed the bound. This overflow\n+        // would make additional values appear 'valid' and then `n > 1` the range of permissible\n+        // length would no longer be the full or even a single range.\n+        unsafe {\n+            crate::intrinsics::assume(raw_len <= Self::MAX_LEN_BOUND)\n+        };\n+\n+        raw_len\n     }\n \n     /// Returns `true` if the slice has a length of 0."}, {"sha": "bb74fc3b2752cf85257a6abbbf0d9443b114d38f", "filename": "src/test/codegen/len-is-bounded.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/beb5ae474d2835962ebdf7416bd1c9ad864fe101/src%2Ftest%2Fcodegen%2Flen-is-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb5ae474d2835962ebdf7416bd1c9ad864fe101/src%2Ftest%2Fcodegen%2Flen-is-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flen-is-bounded.rs?ref=beb5ae474d2835962ebdf7416bd1c9ad864fe101", "patch": "@@ -0,0 +1,24 @@\n+// min-llvm-version: 11.0\n+// compile-flags: -O -C panic=abort\n+#![crate_type = \"lib\"]\n+\n+#[no_mangle]\n+pub fn len_range(a: &[u8], b: &[u8]) -> usize {\n+    // CHECK-NOT: panic\n+    a.len().checked_add(b.len()).unwrap()\n+}\n+\n+#[no_mangle]\n+pub fn len_range_on_non_byte(a: &[u16], b: &[u16]) -> usize {\n+    // CHECK-NOT: panic\n+    a.len().checked_add(b.len()).unwrap()\n+}\n+\n+pub struct Zst;\n+\n+#[no_mangle]\n+pub fn zst_range(a: &[Zst], b: &[Zst]) -> usize {\n+    // Zsts may be arbitrarily large.\n+    // CHECK: panic\n+    a.len().checked_add(b.len()).unwrap()\n+}"}]}