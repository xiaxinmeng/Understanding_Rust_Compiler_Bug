{"sha": "84e03b621522799a72f55d3e728d63aebb561139", "node_id": "C_kwDOAAsO6NoAKDg0ZTAzYjYyMTUyMjc5OWE3MmY1NWQzZTcyOGQ2M2FlYmI1NjExMzk", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-07-10T19:04:29Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-07-17T15:14:07Z"}, "message": "Don't lint `explicit_auto_deref` on `dyn Trait` return", "tree": {"sha": "9b7f12d401a280c5ed779db7a3ec3240e93691b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b7f12d401a280c5ed779db7a3ec3240e93691b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84e03b621522799a72f55d3e728d63aebb561139", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84e03b621522799a72f55d3e728d63aebb561139", "html_url": "https://github.com/rust-lang/rust/commit/84e03b621522799a72f55d3e728d63aebb561139", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84e03b621522799a72f55d3e728d63aebb561139/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ce0f82b8ab44869777d441b51aecfb9d8ebdef9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ce0f82b8ab44869777d441b51aecfb9d8ebdef9", "html_url": "https://github.com/rust-lang/rust/commit/9ce0f82b8ab44869777d441b51aecfb9d8ebdef9"}], "stats": {"total": 199, "additions": 119, "deletions": 80}, "files": [{"sha": "40e62dbd58643d8ac6642d06ac2a81785a98b419", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 63, "deletions": 59, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/84e03b621522799a72f55d3e728d63aebb561139/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84e03b621522799a72f55d3e728d63aebb561139/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=84e03b621522799a72f55d3e728d63aebb561139", "patch": "@@ -668,14 +668,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                 ..\n             }) if span.ctxt() == ctxt => {\n                 let ty = cx.tcx.type_of(def_id);\n-                Some(if let ty::Ref(_, ty, _) = *ty.kind() {\n-                    Position::DerefStable(\n-                        precedence,\n-                        ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n-                    )\n-                } else {\n-                    Position::Other(precedence)\n-                })\n+                Some(ty_auto_deref_stability(cx, ty, precedence).position_for_result(cx))\n             },\n \n             Node::Item(&Item {\n@@ -699,18 +692,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                 let output = cx\n                     .tcx\n                     .erase_late_bound_regions(cx.tcx.fn_sig(def_id.to_def_id()).output());\n-                Some(if let ty::Ref(_, ty, _) = *output.kind() {\n-                    if ty.has_placeholders() || ty.has_opaque_types() {\n-                        Position::ReborrowStable(precedence)\n-                    } else {\n-                        Position::DerefStable(\n-                            precedence,\n-                            ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n-                        )\n-                    }\n-                } else {\n-                    Position::Other(precedence)\n-                })\n+                Some(ty_auto_deref_stability(cx, output, precedence).position_for_result(cx))\n             },\n \n             Node::Expr(parent) if parent.span.ctxt() == ctxt => match parent.kind {\n@@ -730,18 +712,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                             let output = cx\n                                 .tcx\n                                 .erase_late_bound_regions(cx.tcx.fn_sig(cx.tcx.hir().local_def_id(owner_id)).output());\n-                            if let ty::Ref(_, ty, _) = *output.kind() {\n-                                if ty.has_placeholders() || ty.has_opaque_types() {\n-                                    Position::ReborrowStable(precedence)\n-                                } else {\n-                                    Position::DerefStable(\n-                                        precedence,\n-                                        ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n-                                    )\n-                                }\n-                            } else {\n-                                Position::Other(precedence)\n-                            }\n+                            ty_auto_deref_stability(cx, output, precedence).position_for_result(cx)\n                         },\n                     )\n                 },\n@@ -757,7 +728,8 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                         // Type inference for closures can depend on how they're called. Only go by the explicit\n                         // types here.\n                         Some(ty) => binding_ty_auto_deref_stability(cx, ty, precedence),\n-                        None => param_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence),\n+                        None => ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n+                            .position_for_arg(),\n                     }),\n                 ExprKind::MethodCall(_, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n@@ -798,11 +770,12 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                                 Position::MethodReceiver\n                             }\n                         } else {\n-                            param_auto_deref_stability(\n+                            ty_auto_deref_stability(\n                                 cx,\n                                 cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n                                 precedence,\n                             )\n+                            .position_for_arg()\n                         }\n                     })\n                 },\n@@ -813,7 +786,9 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                         .find(|f| f.expr.hir_id == child_id)\n                         .zip(variant)\n                         .and_then(|(field, variant)| variant.fields.iter().find(|f| f.name == field.ident.name))\n-                        .map(|field| param_auto_deref_stability(cx, cx.tcx.type_of(field.did), precedence))\n+                        .map(|field| {\n+                            ty_auto_deref_stability(cx, cx.tcx.type_of(field.did), precedence).position_for_arg()\n+                        })\n                 },\n                 ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n                 ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),\n@@ -890,17 +865,17 @@ fn binding_ty_auto_deref_stability(cx: &LateContext<'_>, ty: &hir::Ty<'_>, prece\n             | TyKind::Never\n             | TyKind::Tup(_)\n             | TyKind::Ptr(_)\n-            | TyKind::TraitObject(..)\n             | TyKind::Path(_) => Position::DerefStable(\n                 precedence,\n                 cx\n-                    .typeck_results()\n-                    .node_type(ty.ty.hir_id)\n-                    .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                .typeck_results()\n+                .node_type(ty.ty.hir_id)\n+                .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n             ),\n             TyKind::OpaqueDef(..)\n             | TyKind::Infer\n             | TyKind::Typeof(..)\n+            | TyKind::TraitObject(..)\n             | TyKind::Err => Position::ReborrowStable(precedence),\n         };\n     }\n@@ -937,10 +912,39 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n     v.0\n }\n \n+struct TyPosition<'tcx> {\n+    position: Position,\n+    ty: Option<Ty<'tcx>>,\n+}\n+impl From<Position> for TyPosition<'_> {\n+    fn from(position: Position) -> Self {\n+        Self { position, ty: None }\n+    }\n+}\n+impl<'tcx> TyPosition<'tcx> {\n+    fn new_deref_stable_for_result(precedence: i8, ty: Ty<'tcx>) -> Self {\n+        Self {\n+            position: Position::ReborrowStable(precedence),\n+            ty: Some(ty),\n+        }\n+    }\n+    fn position_for_result(self, cx: &LateContext<'tcx>) -> Position {\n+        match (self.position, self.ty) {\n+            (Position::ReborrowStable(precedence), Some(ty)) => {\n+                Position::DerefStable(precedence, ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env))\n+            },\n+            (position, _) => position,\n+        }\n+    }\n+    fn position_for_arg(self) -> Position {\n+        self.position\n+    }\n+}\n+\n // Checks whether a type is stable when switching to auto dereferencing,\n-fn param_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedence: i8) -> Position {\n+fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedence: i8) -> TyPosition<'tcx> {\n     let ty::Ref(_, mut ty, _) = *ty.kind() else {\n-        return Position::Other(precedence);\n+        return Position::Other(precedence).into();\n     };\n \n     loop {\n@@ -949,38 +953,38 @@ fn param_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, preced\n                 ty = ref_ty;\n                 continue;\n             },\n-            ty::Infer(_)\n-            | ty::Error(_)\n-            | ty::Param(_)\n-            | ty::Bound(..)\n-            | ty::Opaque(..)\n-            | ty::Placeholder(_)\n-            | ty::Dynamic(..) => Position::ReborrowStable(precedence),\n-            ty::Adt(..) if ty.has_placeholders() || ty.has_param_types_or_consts() => {\n-                Position::ReborrowStable(precedence)\n+            ty::Param(_) => TyPosition::new_deref_stable_for_result(precedence, ty),\n+            ty::Infer(_) | ty::Error(_) | ty::Bound(..) | ty::Opaque(..) | ty::Placeholder(_) | ty::Dynamic(..) => {\n+                Position::ReborrowStable(precedence).into()\n             },\n-            ty::Adt(..)\n-            | ty::Bool\n+            ty::Adt(..) if ty.has_placeholders() || ty.has_opaque_types() => {\n+                Position::ReborrowStable(precedence).into()\n+            },\n+            ty::Adt(_, substs) if substs.has_param_types_or_consts() => {\n+                TyPosition::new_deref_stable_for_result(precedence, ty)\n+            },\n+            ty::Bool\n             | ty::Char\n             | ty::Int(_)\n             | ty::Uint(_)\n-            | ty::Float(_)\n-            | ty::Foreign(_)\n-            | ty::Str\n             | ty::Array(..)\n-            | ty::Slice(..)\n+            | ty::Float(_)\n             | ty::RawPtr(..)\n+            | ty::FnPtr(_) => Position::DerefStable(precedence, true).into(),\n+            ty::Str | ty::Slice(..) => Position::DerefStable(precedence, false).into(),\n+            ty::Adt(..)\n+            | ty::Foreign(_)\n             | ty::FnDef(..)\n-            | ty::FnPtr(_)\n-            | ty::Closure(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n+            | ty::Closure(..)\n             | ty::Never\n             | ty::Tuple(_)\n             | ty::Projection(_) => Position::DerefStable(\n                 precedence,\n                 ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n-            ),\n+            )\n+            .into(),\n         };\n     }\n }"}, {"sha": "d394360fc678b55d0c85f344d88924fd8a1e62f0", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/84e03b621522799a72f55d3e728d63aebb561139/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84e03b621522799a72f55d3e728d63aebb561139/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=84e03b621522799a72f55d3e728d63aebb561139", "patch": "@@ -503,7 +503,7 @@ pub fn all_predicates_of(tcx: TyCtxt<'_>, id: DefId) -> impl Iterator<Item = &(P\n pub enum ExprFnSig<'tcx> {\n     Sig(Binder<'tcx, FnSig<'tcx>>, Option<DefId>),\n     Closure(Option<&'tcx FnDecl<'tcx>>, Binder<'tcx, FnSig<'tcx>>),\n-    Trait(Binder<'tcx, Ty<'tcx>>, Option<Binder<'tcx, Ty<'tcx>>>),\n+    Trait(Binder<'tcx, Ty<'tcx>>, Option<Binder<'tcx, Ty<'tcx>>>, Option<DefId>),\n }\n impl<'tcx> ExprFnSig<'tcx> {\n     /// Gets the argument type at the given offset. This will return `None` when the index is out of\n@@ -518,7 +518,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n                 }\n             },\n             Self::Closure(_, sig) => Some(sig.input(0).map_bound(|ty| ty.tuple_fields()[i])),\n-            Self::Trait(inputs, _) => Some(inputs.map_bound(|ty| ty.tuple_fields()[i])),\n+            Self::Trait(inputs, _, _) => Some(inputs.map_bound(|ty| ty.tuple_fields()[i])),\n         }\n     }\n \n@@ -541,7 +541,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n                 decl.and_then(|decl| decl.inputs.get(i)),\n                 sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n             )),\n-            Self::Trait(inputs, _) => Some((None, inputs.map_bound(|ty| ty.tuple_fields()[i]))),\n+            Self::Trait(inputs, _, _) => Some((None, inputs.map_bound(|ty| ty.tuple_fields()[i]))),\n         }\n     }\n \n@@ -550,12 +550,16 @@ impl<'tcx> ExprFnSig<'tcx> {\n     pub fn output(self) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         match self {\n             Self::Sig(sig, _) | Self::Closure(_, sig) => Some(sig.output()),\n-            Self::Trait(_, output) => output,\n+            Self::Trait(_, output, _) => output,\n         }\n     }\n \n     pub fn predicates_id(&self) -> Option<DefId> {\n-        if let ExprFnSig::Sig(_, id) = *self { id } else { None }\n+        if let ExprFnSig::Sig(_, id) | ExprFnSig::Trait(_, _, id) = *self {\n+            id\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -580,7 +584,7 @@ fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>>\n             Some(ExprFnSig::Closure(decl, subs.as_closure().sig()))\n         },\n         ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs), Some(id))),\n-        ty::Opaque(id, _) => ty_sig(cx, cx.tcx.type_of(id)),\n+        ty::Opaque(id, _) => sig_from_bounds(cx, ty, cx.tcx.item_bounds(id), cx.tcx.opt_parent(id)),\n         ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig, None)),\n         ty::Dynamic(bounds, _) => {\n             let lang_items = cx.tcx.lang_items();\n@@ -594,38 +598,44 @@ fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>>\n                         .projection_bounds()\n                         .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n                         .map(|p| p.map_bound(|p| p.term.ty().unwrap()));\n-                    Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output))\n+                    Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output, None))\n                 },\n                 _ => None,\n             }\n         },\n         ty::Projection(proj) => match cx.tcx.try_normalize_erasing_regions(cx.param_env, ty) {\n             Ok(normalized_ty) if normalized_ty != ty => ty_sig(cx, normalized_ty),\n-            _ => sig_for_projection(cx, proj).or_else(|| sig_from_bounds(cx, ty)),\n+            _ => sig_for_projection(cx, proj).or_else(|| sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None)),\n         },\n-        ty::Param(_) => sig_from_bounds(cx, ty),\n+        ty::Param(_) => sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None),\n         _ => None,\n     }\n }\n \n-fn sig_from_bounds<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+fn sig_from_bounds<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    predicates: &'tcx [Predicate<'tcx>],\n+    predicates_id: Option<DefId>,\n+) -> Option<ExprFnSig<'tcx>> {\n     let mut inputs = None;\n     let mut output = None;\n     let lang_items = cx.tcx.lang_items();\n \n-    for (pred, _) in all_predicates_of(cx.tcx, cx.typeck_results().hir_owner.to_def_id()) {\n+    for pred in predicates {\n         match pred.kind().skip_binder() {\n             PredicateKind::Trait(p)\n                 if (lang_items.fn_trait() == Some(p.def_id())\n                     || lang_items.fn_mut_trait() == Some(p.def_id())\n                     || lang_items.fn_once_trait() == Some(p.def_id()))\n                     && p.self_ty() == ty =>\n             {\n-                if inputs.is_some() {\n+                let i = pred.kind().rebind(p.trait_ref.substs.type_at(1));\n+                if inputs.map_or(false, |inputs| i != inputs) {\n                     // Multiple different fn trait impls. Is this even allowed?\n                     return None;\n                 }\n-                inputs = Some(pred.kind().rebind(p.trait_ref.substs.type_at(1)));\n+                inputs = Some(i);\n             },\n             PredicateKind::Projection(p)\n                 if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n@@ -641,7 +651,7 @@ fn sig_from_bounds<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnS\n         }\n     }\n \n-    inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+    inputs.map(|ty| ExprFnSig::Trait(ty, output, predicates_id))\n }\n \n fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> Option<ExprFnSig<'tcx>> {\n@@ -661,14 +671,15 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n                     || lang_items.fn_mut_trait() == Some(p.def_id())\n                     || lang_items.fn_once_trait() == Some(p.def_id())) =>\n             {\n-                if inputs.is_some() {\n+                let i = pred\n+                    .map_bound(|pred| pred.kind().rebind(p.trait_ref.substs.type_at(1)))\n+                    .subst(cx.tcx, ty.substs);\n+\n+                if inputs.map_or(false, |inputs| inputs != i) {\n                     // Multiple different fn trait impls. Is this even allowed?\n                     return None;\n                 }\n-                inputs = Some(\n-                    pred.map_bound(|pred| pred.kind().rebind(p.trait_ref.substs.type_at(1)))\n-                        .subst(cx.tcx, ty.substs),\n-                );\n+                inputs = Some(i);\n             },\n             PredicateKind::Projection(p) if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() => {\n                 if output.is_some() {\n@@ -684,7 +695,7 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n         }\n     }\n \n-    inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+    inputs.map(|ty| ExprFnSig::Trait(ty, output, None))\n }\n \n #[derive(Clone, Copy)]"}, {"sha": "464dd2dc0da6a14df9f8267a400893df90949e2e", "filename": "tests/ui/explicit_auto_deref.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84e03b621522799a72f55d3e728d63aebb561139/tests%2Fui%2Fexplicit_auto_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/84e03b621522799a72f55d3e728d63aebb561139/tests%2Fui%2Fexplicit_auto_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.fixed?ref=84e03b621522799a72f55d3e728d63aebb561139", "patch": "@@ -233,4 +233,13 @@ fn main() {\n         _ => panic!(),\n     };\n     let _: &X = &*if true { Y(X) } else { panic!() };\n+\n+    fn deref_to_u<U, T: core::ops::Deref<Target = U>>(x: &T) -> &U {\n+        x\n+    }\n+\n+    let _ = |x: &'static Box<dyn Iterator<Item = u32>>| -> &'static dyn Iterator<Item = u32> { &**x };\n+    fn ret_any(x: &Box<dyn std::any::Any>) -> &dyn std::any::Any {\n+        &**x\n+    }\n }"}, {"sha": "453b90f09b33c6ca97df96f09eab77880cae58c0", "filename": "tests/ui/explicit_auto_deref.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84e03b621522799a72f55d3e728d63aebb561139/tests%2Fui%2Fexplicit_auto_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84e03b621522799a72f55d3e728d63aebb561139/tests%2Fui%2Fexplicit_auto_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.rs?ref=84e03b621522799a72f55d3e728d63aebb561139", "patch": "@@ -233,4 +233,13 @@ fn main() {\n         _ => panic!(),\n     };\n     let _: &X = &*if true { Y(X) } else { panic!() };\n+\n+    fn deref_to_u<U, T: core::ops::Deref<Target = U>>(x: &T) -> &U {\n+        &**x\n+    }\n+\n+    let _ = |x: &'static Box<dyn Iterator<Item = u32>>| -> &'static dyn Iterator<Item = u32> { &**x };\n+    fn ret_any(x: &Box<dyn std::any::Any>) -> &dyn std::any::Any {\n+        &**x\n+    }\n }"}, {"sha": "f2933390fb95c4ca91a5b7f75b3ddd69bd614b2f", "filename": "tests/ui/explicit_auto_deref.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84e03b621522799a72f55d3e728d63aebb561139/tests%2Fui%2Fexplicit_auto_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84e03b621522799a72f55d3e728d63aebb561139/tests%2Fui%2Fexplicit_auto_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.stderr?ref=84e03b621522799a72f55d3e728d63aebb561139", "patch": "@@ -210,5 +210,11 @@ error: deref which would be done by auto-deref\n LL |     let _ = || -> &'static str { return *s };\n    |                                         ^^ help: try this: `s`\n \n-error: aborting due to 35 previous errors\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:238:9\n+   |\n+LL |         &**x\n+   |         ^^^^ help: try this: `x`\n+\n+error: aborting due to 36 previous errors\n "}]}