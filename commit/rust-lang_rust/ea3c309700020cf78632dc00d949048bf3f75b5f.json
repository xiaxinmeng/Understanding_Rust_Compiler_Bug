{"sha": "ea3c309700020cf78632dc00d949048bf3f75b5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhM2MzMDk3MDAwMjBjZjc4NjMyZGMwMGQ5NDkwNDhiZjNmNzViNWY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-19T06:56:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-19T06:56:04Z"}, "message": "Rollup merge of #72999 - mati865:separate-self-contained-dir, r=Mark-Simulacrum\n\nCreate self-contained directory and move there some of external binaries/libs\n\nOne of the steps to reach design described in https://github.com/rust-lang/rust/issues/68887#issuecomment-633048380\nThis PR moves things around and allows link code to handle the new directory structure.", "tree": {"sha": "84243ace4f458c35867bddeb6539d5ae68392a93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84243ace4f458c35867bddeb6539d5ae68392a93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea3c309700020cf78632dc00d949048bf3f75b5f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7GGECRBK7hj4Ov3rIwAAdHIIAC/x+vQei1Wf+fen5d105rPi\nW0q7s1/B2OX7jZeY5LDiFbi9yGWout6C4BwMB/debZcZfBtSzymUlkXVF7ZPW7nL\n+CZyCPyppBXjbdjy79RNtlknWQ1hEsOx/RlUZf0FvVV4Ez+e6SQcDSHyM8eyplP9\nbjvc5qKLhkRCbYsVDGAxItffwEZiJPD3UxDJNA93pUsQvrZJCNFeMFqpIv1+dLeA\n4REC+sHkJR0OjjbtFCBWBmd6ZNKVQIQ4/jqpmW38Z9U5mmDGF5bUdfU9mzz88OhJ\n4h6NsqCw0PJNiV9DnN6n5+Kv9OcfLgdz5wcokS9KvJPHr7m2KGeHmM20ZJfWDOg=\n=a/Kr\n-----END PGP SIGNATURE-----\n", "payload": "tree 84243ace4f458c35867bddeb6539d5ae68392a93\nparent 5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787\nparent 43905cd7501fd37090cb9de6069faaba761e514a\nauthor Ralf Jung <post@ralfj.de> 1592549764 +0200\ncommitter GitHub <noreply@github.com> 1592549764 +0200\n\nRollup merge of #72999 - mati865:separate-self-contained-dir, r=Mark-Simulacrum\n\nCreate self-contained directory and move there some of external binaries/libs\n\nOne of the steps to reach design described in https://github.com/rust-lang/rust/issues/68887#issuecomment-633048380\nThis PR moves things around and allows link code to handle the new directory structure.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea3c309700020cf78632dc00d949048bf3f75b5f", "html_url": "https://github.com/rust-lang/rust/commit/ea3c309700020cf78632dc00d949048bf3f75b5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea3c309700020cf78632dc00d949048bf3f75b5f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787", "html_url": "https://github.com/rust-lang/rust/commit/5e7eec2eaa8b25d8a607a9ced3ef4df01aab3787"}, {"sha": "43905cd7501fd37090cb9de6069faaba761e514a", "url": "https://api.github.com/repos/rust-lang/rust/commits/43905cd7501fd37090cb9de6069faaba761e514a", "html_url": "https://github.com/rust-lang/rust/commit/43905cd7501fd37090cb9de6069faaba761e514a"}], "stats": {"total": 223, "additions": 162, "deletions": 61}, "files": [{"sha": "afcf0dcac7e55341e4764ce8a8ba513dd92a855b", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 112, "deletions": 52, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/ea3c309700020cf78632dc00d949048bf3f75b5f/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea3c309700020cf78632dc00d949048bf3f75b5f/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=ea3c309700020cf78632dc00d949048bf3f75b5f", "patch": "@@ -23,7 +23,7 @@ use crate::builder::Cargo;\n use crate::dist;\n use crate::native;\n use crate::util::{exe, is_dylib, symlink_dir};\n-use crate::{Compiler, GitRepo, Mode};\n+use crate::{Compiler, DependencyType, GitRepo, Mode};\n \n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n@@ -74,6 +74,7 @@ impl Step for Std {\n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n             copy_third_party_objects(builder, &compiler, target);\n+            copy_self_contained_objects(builder, &compiler, target);\n \n             builder.ensure(StdLink {\n                 compiler: compiler_to_use,\n@@ -83,7 +84,8 @@ impl Step for Std {\n             return;\n         }\n \n-        target_deps.extend(copy_third_party_objects(builder, &compiler, target).into_iter());\n+        target_deps.extend(copy_third_party_objects(builder, &compiler, target));\n+        target_deps.extend(copy_self_contained_objects(builder, &compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n         std_cargo(builder, target, compiler.stage, &mut cargo);\n@@ -109,21 +111,76 @@ impl Step for Std {\n     }\n }\n \n+fn copy_and_stamp(\n+    builder: &Builder<'_>,\n+    libdir: &Path,\n+    sourcedir: &Path,\n+    name: &str,\n+    target_deps: &mut Vec<(PathBuf, DependencyType)>,\n+    dependency_type: DependencyType,\n+) {\n+    let target = libdir.join(name);\n+    builder.copy(&sourcedir.join(name), &target);\n+\n+    target_deps.push((target, dependency_type));\n+}\n+\n /// Copies third party objects needed by various targets.\n fn copy_third_party_objects(\n     builder: &Builder<'_>,\n     compiler: &Compiler,\n     target: Interned<String>,\n-) -> Vec<PathBuf> {\n+) -> Vec<(PathBuf, DependencyType)> {\n     let libdir = builder.sysroot_libdir(*compiler, target);\n-\n     let mut target_deps = vec![];\n \n-    let mut copy_and_stamp = |sourcedir: &Path, name: &str| {\n-        let target = libdir.join(name);\n-        builder.copy(&sourcedir.join(name), &target);\n-        target_deps.push(target);\n+    // Copies libunwind.a compiled to be linked with x86_64-fortanix-unknown-sgx.\n+    //\n+    // This target needs to be linked to Fortanix's port of llvm's libunwind.\n+    // libunwind requires support for rwlock and printing to stderr,\n+    // which is provided by std for this target.\n+    if target == \"x86_64-fortanix-unknown-sgx\" {\n+        let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n+        let src =\n+            env::var(src_path_env).unwrap_or_else(|_| panic!(\"{} not found in env\", src_path_env));\n+        copy_and_stamp(\n+            builder,\n+            &*libdir,\n+            Path::new(&src),\n+            \"libunwind.a\",\n+            &mut target_deps,\n+            DependencyType::Target,\n+        );\n+    }\n+\n+    if builder.config.sanitizers && compiler.stage != 0 {\n+        // The sanitizers are only copied in stage1 or above,\n+        // to avoid creating dependency on LLVM.\n+        target_deps.extend(\n+            copy_sanitizers(builder, &compiler, target)\n+                .into_iter()\n+                .map(|d| (d, DependencyType::Target)),\n+        );\n+    }\n+\n+    target_deps\n+}\n+\n+/// Copies third party objects needed by various targets for self-contained linkage.\n+fn copy_self_contained_objects(\n+    builder: &Builder<'_>,\n+    compiler: &Compiler,\n+    target: Interned<String>,\n+) -> Vec<(PathBuf, DependencyType)> {\n+    // cfg(bootstrap)\n+    // Remove when upgrading bootstrap compiler.\n+    let libdir_self_contained = if compiler.stage == 0 {\n+        builder.sysroot_libdir(*compiler, target).to_path_buf()\n+    } else {\n+        builder.sysroot_libdir(*compiler, target).join(\"self-contained\")\n     };\n+    t!(fs::create_dir_all(&libdir_self_contained));\n+    let mut target_deps = vec![];\n \n     // Copies the CRT objects.\n     //\n@@ -135,29 +192,32 @@ fn copy_third_party_objects(\n     if target.contains(\"musl\") {\n         let srcdir = builder.musl_root(target).unwrap().join(\"lib\");\n         for &obj in &[\"crt1.o\", \"Scrt1.o\", \"rcrt1.o\", \"crti.o\", \"crtn.o\"] {\n-            copy_and_stamp(&srcdir, obj);\n+            copy_and_stamp(\n+                builder,\n+                &libdir_self_contained,\n+                &srcdir,\n+                obj,\n+                &mut target_deps,\n+                DependencyType::TargetSelfContained,\n+            );\n         }\n     } else if target.ends_with(\"-wasi\") {\n         let srcdir = builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\");\n-        copy_and_stamp(&srcdir, \"crt1.o\");\n-    }\n-\n-    // Copies libunwind.a compiled to be linked with x86_64-fortanix-unknown-sgx.\n-    //\n-    // This target needs to be linked to Fortanix's port of llvm's libunwind.\n-    // libunwind requires support for rwlock and printing to stderr,\n-    // which is provided by std for this target.\n-    if target == \"x86_64-fortanix-unknown-sgx\" {\n-        let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n-        let src =\n-            env::var(src_path_env).unwrap_or_else(|_| panic!(\"{} not found in env\", src_path_env));\n-        copy_and_stamp(Path::new(&src), \"libunwind.a\");\n-    }\n-\n-    if builder.config.sanitizers && compiler.stage != 0 {\n-        // The sanitizers are only copied in stage1 or above,\n-        // to avoid creating dependency on LLVM.\n-        target_deps.extend(copy_sanitizers(builder, &compiler, target));\n+        copy_and_stamp(\n+            builder,\n+            &libdir_self_contained,\n+            &srcdir,\n+            \"crt1.o\",\n+            &mut target_deps,\n+            DependencyType::TargetSelfContained,\n+        );\n+    } else if target.contains(\"windows-gnu\") {\n+        for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n+            let src = compiler_file(builder, builder.cc(target), target, obj);\n+            let target = libdir_self_contained.join(obj);\n+            builder.copy(&src, &target);\n+            target_deps.push((target, DependencyType::TargetSelfContained));\n+        }\n     }\n \n     target_deps\n@@ -335,7 +395,7 @@ pub struct StartupObjects {\n }\n \n impl Step for StartupObjects {\n-    type Output = Vec<PathBuf>;\n+    type Output = Vec<(PathBuf, DependencyType)>;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/rtstartup\")\n@@ -354,7 +414,7 @@ impl Step for StartupObjects {\n     /// They don't require any library support as they're just plain old object\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n-    fn run(self, builder: &Builder<'_>) -> Vec<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Vec<(PathBuf, DependencyType)> {\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"windows-gnu\") {\n@@ -388,14 +448,7 @@ impl Step for StartupObjects {\n \n             let target = sysroot_dir.join((*file).to_string() + \".o\");\n             builder.copy(dst_file, &target);\n-            target_deps.push(target);\n-        }\n-\n-        for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n-            let src = compiler_file(builder, builder.cc(target), target, obj);\n-            let target = sysroot_dir.join(obj);\n-            builder.copy(&src, &target);\n-            target_deps.push(target);\n+            target_deps.push((target, DependencyType::Target));\n         }\n \n         target_deps\n@@ -808,14 +861,17 @@ pub fn add_to_sysroot(\n     sysroot_host_dst: &Path,\n     stamp: &Path,\n ) {\n+    let self_contained_dst = &sysroot_dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&sysroot_dst));\n     t!(fs::create_dir_all(&sysroot_host_dst));\n-    for (path, host) in builder.read_stamp_file(stamp) {\n-        if host {\n-            builder.copy(&path, &sysroot_host_dst.join(path.file_name().unwrap()));\n-        } else {\n-            builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n-        }\n+    t!(fs::create_dir_all(&self_contained_dst));\n+    for (path, dependency_type) in builder.read_stamp_file(stamp) {\n+        let dst = match dependency_type {\n+            DependencyType::Host => sysroot_host_dst,\n+            DependencyType::Target => sysroot_dst,\n+            DependencyType::TargetSelfContained => self_contained_dst,\n+        };\n+        builder.copy(&path, &dst.join(path.file_name().unwrap()));\n     }\n }\n \n@@ -824,7 +880,7 @@ pub fn run_cargo(\n     cargo: Cargo,\n     tail_args: Vec<String>,\n     stamp: &Path,\n-    additional_target_deps: Vec<PathBuf>,\n+    additional_target_deps: Vec<(PathBuf, DependencyType)>,\n     is_check: bool,\n ) -> Vec<PathBuf> {\n     if builder.config.dry_run {\n@@ -875,15 +931,15 @@ pub fn run_cargo(\n             if filename.starts_with(&host_root_dir) {\n                 // Unless it's a proc macro used in the compiler\n                 if crate_types.iter().any(|t| t == \"proc-macro\") {\n-                    deps.push((filename.to_path_buf(), true));\n+                    deps.push((filename.to_path_buf(), DependencyType::Host));\n                 }\n                 continue;\n             }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n             if filename.starts_with(&target_deps_dir) {\n-                deps.push((filename.to_path_buf(), false));\n+                deps.push((filename.to_path_buf(), DependencyType::Target));\n                 continue;\n             }\n \n@@ -935,17 +991,21 @@ pub fn run_cargo(\n             let candidate = format!(\"{}.lib\", path_to_add);\n             let candidate = PathBuf::from(candidate);\n             if candidate.exists() {\n-                deps.push((candidate, false));\n+                deps.push((candidate, DependencyType::Target));\n             }\n         }\n-        deps.push((path_to_add.into(), false));\n+        deps.push((path_to_add.into(), DependencyType::Target));\n     }\n \n-    deps.extend(additional_target_deps.into_iter().map(|d| (d, false)));\n+    deps.extend(additional_target_deps);\n     deps.sort();\n     let mut new_contents = Vec::new();\n-    for (dep, proc_macro) in deps.iter() {\n-        new_contents.extend(if *proc_macro { b\"h\" } else { b\"t\" });\n+    for (dep, dependency_type) in deps.iter() {\n+        new_contents.extend(match *dependency_type {\n+            DependencyType::Host => b\"h\",\n+            DependencyType::Target => b\"t\",\n+            DependencyType::TargetSelfContained => b\"s\",\n+        });\n         new_contents.extend(dep.to_str().unwrap().as_bytes());\n         new_contents.extend(b\"\\0\");\n     }"}, {"sha": "8a2463d378fdb8642cea130e3bd1c10fb5bbd3ba", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ea3c309700020cf78632dc00d949048bf3f75b5f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea3c309700020cf78632dc00d949048bf3f75b5f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=ea3c309700020cf78632dc00d949048bf3f75b5f", "patch": "@@ -22,7 +22,7 @@ use crate::channel;\n use crate::compile;\n use crate::tool::{self, Tool};\n use crate::util::{exe, is_dylib, timeit};\n-use crate::{Compiler, Mode, LLVM_TOOLS};\n+use crate::{Compiler, DependencyType, Mode, LLVM_TOOLS};\n use time::{self, Timespec};\n \n pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n@@ -306,7 +306,12 @@ fn make_win_dist(\n     }\n \n     //Copy platform tools to platform-specific bin directory\n-    let target_bin_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"bin\");\n+    let target_bin_dir = plat_root\n+        .join(\"lib\")\n+        .join(\"rustlib\")\n+        .join(target_triple)\n+        .join(\"bin\")\n+        .join(\"self-contained\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n     for src in target_tools {\n         builder.copy_to_folder(&src, &target_bin_dir);\n@@ -321,7 +326,12 @@ fn make_win_dist(\n     );\n \n     //Copy platform libs to platform-specific lib directory\n-    let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n+    let target_lib_dir = plat_root\n+        .join(\"lib\")\n+        .join(\"rustlib\")\n+        .join(target_triple)\n+        .join(\"lib\")\n+        .join(\"self-contained\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n     for src in target_libs {\n         builder.copy_to_folder(&src, &target_lib_dir);\n@@ -652,9 +662,13 @@ fn skip_host_target_lib(builder: &Builder<'_>, compiler: Compiler) -> bool {\n /// Copy stamped files into an image's `target/lib` directory.\n fn copy_target_libs(builder: &Builder<'_>, target: &str, image: &Path, stamp: &Path) {\n     let dst = image.join(\"lib/rustlib\").join(target).join(\"lib\");\n+    let self_contained_dst = dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&dst));\n-    for (path, host) in builder.read_stamp_file(stamp) {\n-        if !host || builder.config.build == target {\n+    t!(fs::create_dir_all(&self_contained_dst));\n+    for (path, dependency_type) in builder.read_stamp_file(stamp) {\n+        if dependency_type == DependencyType::TargetSelfContained {\n+            builder.copy(&path, &self_contained_dst.join(path.file_name().unwrap()));\n+        } else if dependency_type == DependencyType::Target || builder.config.build == target {\n             builder.copy(&path, &dst.join(path.file_name().unwrap()));\n         }\n     }"}, {"sha": "db861cb7013713c040677ba0ffbfaf37a4ded2c6", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea3c309700020cf78632dc00d949048bf3f75b5f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea3c309700020cf78632dc00d949048bf3f75b5f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=ea3c309700020cf78632dc00d949048bf3f75b5f", "patch": "@@ -280,6 +280,17 @@ impl Crate {\n     }\n }\n \n+/// When building Rust various objects are handled differently.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum DependencyType {\n+    /// Libraries originating from proc-macros.\n+    Host,\n+    /// Typical Rust libraries.\n+    Target,\n+    /// Non Rust libraries and objects shipped to ease usage of certain targets.\n+    TargetSelfContained,\n+}\n+\n /// The various \"modes\" of invoking Cargo.\n ///\n /// These entries currently correspond to the various output directories of the\n@@ -1097,7 +1108,7 @@ impl Build {\n         ret\n     }\n \n-    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, bool)> {\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, DependencyType)> {\n         if self.config.dry_run {\n             return Vec::new();\n         }\n@@ -1110,9 +1121,14 @@ impl Build {\n             if part.is_empty() {\n                 continue;\n             }\n-            let host = part[0] as char == 'h';\n+            let dependency_type = match part[0] as char {\n+                'h' => DependencyType::Host,\n+                's' => DependencyType::TargetSelfContained,\n+                't' => DependencyType::Target,\n+                _ => unreachable!(),\n+            };\n             let path = PathBuf::from(t!(str::from_utf8(&part[1..])));\n-            paths.push((path, host));\n+            paths.push((path, dependency_type));\n         }\n         paths\n     }"}, {"sha": "1eef86f6c931c8e73daba26ac482c558456411da", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ea3c309700020cf78632dc00d949048bf3f75b5f/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea3c309700020cf78632dc00d949048bf3f75b5f/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=ea3c309700020cf78632dc00d949048bf3f75b5f", "patch": "@@ -1075,6 +1075,10 @@ fn get_object_file_path(sess: &Session, name: &str) -> PathBuf {\n     if file_path.exists() {\n         return file_path;\n     }\n+    let file_path = fs.get_selfcontained_lib_path().join(name);\n+    if file_path.exists() {\n+        return file_path;\n+    }\n     for search_path in fs.search_paths() {\n         let file_path = search_path.dir.join(name);\n         if file_path.exists() {\n@@ -1470,6 +1474,9 @@ fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session) {\n     // The location of crates will be determined as needed.\n     let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+\n+    let lib_path = sess.target_filesearch(PathKind::All).get_selfcontained_lib_path();\n+    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n }\n \n /// Add options making relocation sections in the produced ELF files read-only"}, {"sha": "5586b82b0edc082f8c5001b0516ee001b5963a52", "filename": "src/librustc_session/filesearch.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea3c309700020cf78632dc00d949048bf3f75b5f/src%2Flibrustc_session%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea3c309700020cf78632dc00d949048bf3f75b5f/src%2Flibrustc_session%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Ffilesearch.rs?ref=ea3c309700020cf78632dc00d949048bf3f75b5f", "patch": "@@ -41,6 +41,10 @@ impl<'a> FileSearch<'a> {\n         make_target_lib_path(self.sysroot, self.triple)\n     }\n \n+    pub fn get_selfcontained_lib_path(&self) -> PathBuf {\n+        self.get_lib_path().join(\"self-contained\")\n+    }\n+\n     pub fn search<F>(&self, mut pick: F)\n     where\n         F: FnMut(&SearchPathFile, PathKind) -> FileMatch,\n@@ -94,7 +98,7 @@ impl<'a> FileSearch<'a> {\n         p.push(RUST_LIB_DIR);\n         p.push(&self.triple);\n         p.push(\"bin\");\n-        vec![p]\n+        vec![p.clone(), p.join(\"self-contained\")]\n     }\n }\n "}]}