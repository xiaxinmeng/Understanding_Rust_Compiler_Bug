{"sha": "9852b42b581bbc4843460f4654a2dbd859bd9034", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NTJiNDJiNTgxYmJjNDg0MzQ2MGY0NjU0YTJkYmQ4NTliZDkwMzQ=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-18T18:41:43Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-27T19:06:36Z"}, "message": "`PredicateKint` -> `PredicateKind`, the beginning of the end", "tree": {"sha": "20be6a510c5b93e2a299f504e4b70ff15342258e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20be6a510c5b93e2a299f504e4b70ff15342258e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9852b42b581bbc4843460f4654a2dbd859bd9034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9852b42b581bbc4843460f4654a2dbd859bd9034", "html_url": "https://github.com/rust-lang/rust/commit/9852b42b581bbc4843460f4654a2dbd859bd9034", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9852b42b581bbc4843460f4654a2dbd859bd9034/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "506f4308b757e64ceb9e894e27265c103593cd9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/506f4308b757e64ceb9e894e27265c103593cd9e", "html_url": "https://github.com/rust-lang/rust/commit/506f4308b757e64ceb9e894e27265c103593cd9e"}], "stats": {"total": 1482, "additions": 742, "deletions": 740}, "files": [{"sha": "3541bf3b80938adc9eda3c45b6a7defc1b30026f", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -531,12 +531,14 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 GenericArg<'tcx>,\n                 ty::Region<'tcx>,\n             >| match k1.unpack() {\n-                GenericArgKind::Lifetime(r1) => self.tcx.intern_predicate_kint(\n-                    ty::PredicateKint::RegionOutlives(ty::OutlivesPredicate(r1, r2)),\n-                ),\n-                GenericArgKind::Type(t1) => self.tcx.intern_predicate_kint(\n-                    ty::PredicateKint::TypeOutlives(ty::OutlivesPredicate(t1, r2)),\n-                ),\n+                GenericArgKind::Lifetime(r1) => {\n+                    ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n+                        .to_predicate(self.tcx)\n+                }\n+                GenericArgKind::Type(t1) => {\n+                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t1, r2))\n+                        .to_predicate(self.tcx)\n+                }\n                 GenericArgKind::Const(..) => {\n                     // Consts cannot outlive one another, so we don't expect to\n                     // ecounter this branch.\n@@ -545,9 +547,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             };\n \n             let predicate = if let Some(constraint) = constraint.no_bound_vars() {\n-                to_predicate(constraint).to_predicate(self.tcx)\n+                to_predicate(constraint)\n             } else {\n-                ty::PredicateKint::ForAll(constraint.map_bound(to_predicate)).to_predicate(self.tcx)\n+                ty::PredicateKind::ForAll(constraint.map_bound(to_predicate)).to_predicate(self.tcx)\n             };\n \n             Obligation::new(cause.clone(), param_env, predicate)\n@@ -670,7 +672,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         self.obligations.push(Obligation {\n             cause: self.cause.clone(),\n             param_env: self.param_env,\n-            predicate: ty::PredicateKint::RegionOutlives(ty::OutlivesPredicate(sup, sub))\n+            predicate: ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(sup, sub))\n                 .to_predicate(self.infcx.tcx),\n             recursion_depth: 0,\n         });"}, {"sha": "c63464e5baec9e3b1a71409ad0402cc1a710684e", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -308,7 +308,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             self.obligations.push(Obligation::new(\n                 self.trace.cause.clone(),\n                 self.param_env,\n-                ty::PredicateKint::WellFormed(b_ty.into()).to_predicate(self.infcx.tcx),\n+                ty::PredicateKind::WellFormed(b_ty.into()).to_predicate(self.infcx.tcx),\n             ));\n         }\n \n@@ -400,9 +400,9 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         b: &'tcx ty::Const<'tcx>,\n     ) {\n         let predicate = if a_is_expected {\n-            ty::PredicateKint::ConstEquate(a, b)\n+            ty::PredicateKind::ConstEquate(a, b)\n         } else {\n-            ty::PredicateKint::ConstEquate(b, a)\n+            ty::PredicateKind::ConstEquate(b, a)\n         };\n         self.obligations.push(Obligation::new(\n             self.trace.cause.clone(),"}, {"sha": "59f3d01777c7b5806f1ce6c5828b7ac0825346e5", "filename": "src/librustc_infer/infer/outlives/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -3,7 +3,7 @@ use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, TyCtxt};\n \n use super::explicit_outlives_bounds;\n \n@@ -69,15 +69,15 @@ pub struct OutlivesEnvironment<'tcx> {\n pub type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n \n impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n-    pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Self {\n         let mut env = OutlivesEnvironment {\n             param_env,\n             free_region_map: Default::default(),\n             region_bound_pairs_map: Default::default(),\n             region_bound_pairs_accum: vec![],\n         };\n \n-        env.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n+        env.add_outlives_bounds(None, explicit_outlives_bounds(tcx, param_env));\n \n         env\n     }"}, {"sha": "ad1579083b646196b4c8c4651e89a1fed603cbd4", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -5,9 +5,10 @@ pub mod obligations;\n pub mod verify;\n \n use rustc_middle::traits::query::OutlivesBound;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, TyCtxt};\n \n pub fn explicit_outlives_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n     debug!(\"explicit_outlives_bounds()\");"}, {"sha": "27d21dd0b70ef15e9da4a9de8ddf5d99805a1cbd", "filename": "src/librustc_infer/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -331,8 +331,9 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         compare_ty: impl Fn(Ty<'tcx>) -> bool,\n         predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+        let tcx = self.tcx;\n         predicates\n-            .filter_map(|p| p.to_opt_type_outlives())\n+            .filter_map(move |p| p.to_opt_type_outlives(tcx))\n             .filter_map(|p| p.no_bound_vars())\n             .filter(move |p| compare_ty(p.0))\n     }"}, {"sha": "5ad08f0b8952abc867e304f210e64dad5a3c49ce", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -100,7 +100,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,\n-                    ty::PredicateKint::Subtype(ty::SubtypePredicate {\n+                    ty::PredicateKind::Subtype(ty::SubtypePredicate {\n                         a_is_expected: self.a_is_expected,\n                         a,\n                         b,"}, {"sha": "1bee16f7556a18bca771c15ca01c8839c112e1c6", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -10,34 +10,34 @@ pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     pred: ty::Predicate<'tcx>,\n ) -> ty::Predicate<'tcx> {\n-    let kind = pred.kint(tcx);\n+    let kind = pred.kind();\n     let new = match kind {\n-        ty::PredicateKint::ForAll(binder) => {\n-            ty::PredicateKint::ForAll(tcx.anonymize_late_bound_regions(binder))\n+        ty::PredicateKind::ForAll(binder) => {\n+            ty::PredicateKind::ForAll(tcx.anonymize_late_bound_regions(binder))\n         }\n-        &ty::PredicateKint::Trait(data, constness) => ty::PredicateKint::Trait(data, constness),\n+        &ty::PredicateKind::Trait(data, constness) => ty::PredicateKind::Trait(data, constness),\n \n-        &ty::PredicateKint::RegionOutlives(data) => ty::PredicateKint::RegionOutlives(data),\n+        &ty::PredicateKind::RegionOutlives(data) => ty::PredicateKind::RegionOutlives(data),\n \n-        &ty::PredicateKint::TypeOutlives(data) => ty::PredicateKint::TypeOutlives(data),\n+        &ty::PredicateKind::TypeOutlives(data) => ty::PredicateKind::TypeOutlives(data),\n \n-        &ty::PredicateKint::Projection(data) => ty::PredicateKint::Projection(data),\n+        &ty::PredicateKind::Projection(data) => ty::PredicateKind::Projection(data),\n \n-        &ty::PredicateKint::WellFormed(data) => ty::PredicateKint::WellFormed(data),\n+        &ty::PredicateKind::WellFormed(data) => ty::PredicateKind::WellFormed(data),\n \n-        &ty::PredicateKint::ObjectSafe(data) => ty::PredicateKint::ObjectSafe(data),\n+        &ty::PredicateKind::ObjectSafe(data) => ty::PredicateKind::ObjectSafe(data),\n \n-        &ty::PredicateKint::ClosureKind(closure_def_id, closure_substs, kind) => {\n-            ty::PredicateKint::ClosureKind(closure_def_id, closure_substs, kind)\n+        &ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n         }\n \n-        &ty::PredicateKint::Subtype(data) => ty::PredicateKint::Subtype(data),\n+        &ty::PredicateKind::Subtype(data) => ty::PredicateKind::Subtype(data),\n \n-        &ty::PredicateKint::ConstEvaluatable(def_id, substs) => {\n-            ty::PredicateKint::ConstEvaluatable(def_id, substs)\n+        &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs)\n         }\n \n-        &ty::PredicateKint::ConstEquate(c1, c2) => ty::PredicateKint::ConstEquate(c1, c2),\n+        &ty::PredicateKind::ConstEquate(c1, c2) => ty::PredicateKind::ConstEquate(c1, c2),\n     };\n \n     if new != *kind { new.to_predicate(tcx) } else { pred }\n@@ -145,22 +145,22 @@ fn predicate_obligation<'tcx>(\n }\n \n impl Elaborator<'tcx> {\n-    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n-        FilterToTraits::new(self)\n+    pub fn filter_to_traits(self) -> FilterToTraits<'tcx, Self> {\n+        FilterToTraits::new(self.visited.tcx, self)\n     }\n \n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n-        let pred = match obligation.predicate.kint(tcx) {\n-            // We have to be careful and rebind this whenever\n+        let pred = match obligation.predicate.kind() {\n+            // We have to be careful and rebind this when\n             // dealing with a predicate further down.\n-            ty::PredicateKint::ForAll(binder) => binder.skip_binder(),\n+            ty::PredicateKind::ForAll(binder) => binder.skip_binder().kind(),\n             pred => pred,\n         };\n \n         match pred {\n-            ty::PredicateKint::ForAll(_) => bug!(\"unexpected predicate: {:?}\", pred),\n-            ty::PredicateKint::Trait(ref data, _) => {\n+            ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", pred),\n+            ty::PredicateKind::Trait(data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n@@ -181,36 +181,36 @@ impl Elaborator<'tcx> {\n \n                 self.stack.extend(obligations);\n             }\n-            ty::PredicateKint::WellFormed(..) => {\n+            ty::PredicateKind::WellFormed(..) => {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could.\n             }\n-            ty::PredicateKint::ObjectSafe(..) => {\n+            ty::PredicateKind::ObjectSafe(..) => {\n                 // Currently, we do not elaborate object-safe\n                 // predicates.\n             }\n-            ty::PredicateKint::Subtype(..) => {\n+            ty::PredicateKind::Subtype(..) => {\n                 // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n                 // though conceivably we might.\n             }\n-            ty::PredicateKint::Projection(..) => {\n+            ty::PredicateKind::Projection(..) => {\n                 // Nothing to elaborate in a projection predicate.\n             }\n-            ty::PredicateKint::ClosureKind(..) => {\n+            ty::PredicateKind::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n-            ty::PredicateKint::ConstEvaluatable(..) => {\n+            ty::PredicateKind::ConstEvaluatable(..) => {\n                 // Currently, we do not elaborate const-evaluatable\n                 // predicates.\n             }\n-            ty::PredicateKint::ConstEquate(..) => {\n+            ty::PredicateKind::ConstEquate(..) => {\n                 // Currently, we do not elaborate const-equate\n                 // predicates.\n             }\n-            ty::PredicateKint::RegionOutlives(..) => {\n+            ty::PredicateKind::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }\n-            ty::PredicateKint::TypeOutlives(ty::OutlivesPredicate(ty_max, r_min)) => {\n+            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_max, r_min)) => {\n                 // We know that `T: 'a` for some type `T`. We can\n                 // often elaborate this. For example, if we know that\n                 // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n@@ -240,15 +240,15 @@ impl Elaborator<'tcx> {\n                                 if r.is_late_bound() {\n                                     None\n                                 } else {\n-                                    Some(ty::PredicateKint::RegionOutlives(ty::OutlivesPredicate(\n+                                    Some(ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n                                         r, r_min,\n                                     )))\n                                 }\n                             }\n \n                             Component::Param(p) => {\n                                 let ty = tcx.mk_ty_param(p.index, p.name);\n-                                Some(ty::PredicateKint::TypeOutlives(ty::OutlivesPredicate(\n+                                Some(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n                                     ty, r_min,\n                                 )))\n                             }\n@@ -293,7 +293,7 @@ impl Iterator for Elaborator<'tcx> {\n // Supertrait iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n+pub type Supertraits<'tcx> = FilterToTraits<'tcx, Elaborator<'tcx>>;\n \n pub fn supertraits<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -315,22 +315,23 @@ pub fn transitive_bounds<'tcx>(\n \n /// A filter around an iterator of predicates that makes it yield up\n /// just trait references.\n-pub struct FilterToTraits<I> {\n+pub struct FilterToTraits<'tcx, I> {\n+    tcx: TyCtxt<'tcx>,\n     base_iterator: I,\n }\n \n-impl<I> FilterToTraits<I> {\n-    fn new(base: I) -> FilterToTraits<I> {\n-        FilterToTraits { base_iterator: base }\n+impl<'tcx, I> FilterToTraits<'tcx, I> {\n+    fn new(tcx: TyCtxt<'tcx>, base: I) -> FilterToTraits<'tcx, I> {\n+        FilterToTraits { tcx, base_iterator: base }\n     }\n }\n \n-impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToTraits<I> {\n+impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToTraits<'tcx, I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         while let Some(obligation) = self.base_iterator.next() {\n-            if let Some(data) = obligation.predicate.to_opt_poly_trait_ref() {\n+            if let Some(data) = obligation.predicate.to_opt_poly_trait_ref(self.tcx) {\n                 return Some(data);\n             }\n         }"}, {"sha": "cedf742b9a9498558a915701709545a156d9c302", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -1202,15 +1202,15 @@ declare_lint_pass!(\n impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::fold::TypeFoldable;\n-        use rustc_middle::ty::PredicateKint::*;\n+        use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n             for &(predicate, span) in predicates.predicates {\n                 // We don't actually look inside of the predicate,\n                 // so it is safe to skip this binder here.\n-                let predicate_kind_name = match predicate.kint(cx.tcx).ignore_qualifiers().skip_binder() {\n+                let predicate_kind_name = match predicate.ignore_qualifiers(cx.tcx).skip_binder().kind() {\n                     Trait(..) => \"Trait\",\n                     TypeOutlives(..) |\n                     RegionOutlives(..) => \"Lifetime\",\n@@ -1495,34 +1495,32 @@ declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMEN\n \n impl ExplicitOutlivesRequirements {\n     fn lifetimes_outliving_lifetime<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n         inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         index: u32,\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.kind() {\n-                ty::PredicateKind::RegionOutlives(outlives) => {\n-                    let outlives = outlives.skip_binder();\n-                    match outlives.0 {\n-                        ty::ReEarlyBound(ebr) if ebr.index == index => Some(outlives.1),\n-                        _ => None,\n-                    }\n-                }\n+            .filter_map(|(pred, _)| match pred.ignore_qualifiers(tcx).skip_binder().kind() {\n+                &ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => match a {\n+                    ty::ReEarlyBound(ebr) if ebr.index == index => Some(b),\n+                    _ => None,\n+                },\n                 _ => None,\n             })\n             .collect()\n     }\n \n     fn lifetimes_outliving_type<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n         inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         index: u32,\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.kind() {\n-                ty::PredicateKind::TypeOutlives(outlives) => {\n-                    let outlives = outlives.skip_binder();\n-                    outlives.0.is_param(index).then_some(outlives.1)\n+            .filter_map(|(pred, _)| match pred.ignore_qualifiers(tcx).skip_binder().kind() {\n+                &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n+                    a.is_param(index).then_some(b)\n                 }\n                 _ => None,\n             })\n@@ -1541,10 +1539,10 @@ impl ExplicitOutlivesRequirements {\n \n         match param.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n-                Self::lifetimes_outliving_lifetime(inferred_outlives, index)\n+                Self::lifetimes_outliving_lifetime(tcx, inferred_outlives, index)\n             }\n             hir::GenericParamKind::Type { .. } => {\n-                Self::lifetimes_outliving_type(inferred_outlives, index)\n+                Self::lifetimes_outliving_type(tcx, inferred_outlives, index)\n             }\n             hir::GenericParamKind::Const { .. } => Vec::new(),\n         }\n@@ -1696,7 +1694,11 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                             cx.tcx.named_region(predicate.lifetime.hir_id)\n                         {\n                             (\n-                                Self::lifetimes_outliving_lifetime(inferred_outlives, index),\n+                                Self::lifetimes_outliving_lifetime(\n+                                    cx.tcx,\n+                                    inferred_outlives,\n+                                    index,\n+                                ),\n                                 &predicate.bounds,\n                                 predicate.span,\n                             )\n@@ -1712,7 +1714,11 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                                 if let Res::Def(DefKind::TyParam, def_id) = path.res {\n                                     let index = ty_generics.param_def_id_to_index[&def_id];\n                                     (\n-                                        Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                        Self::lifetimes_outliving_type(\n+                                            cx.tcx,\n+                                            inferred_outlives,\n+                                            index,\n+                                        ),\n                                         &predicate.bounds,\n                                         predicate.span,\n                                     )"}, {"sha": "1430b799afce2fd5e071291d36d20d310bae8951", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -147,8 +147,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     let mut has_emitted = false;\n                     for (predicate, _) in cx.tcx.predicates_of(def).predicates {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n-                        if let ty::PredicateKint::Trait(ref poly_trait_predicate, _) =\n-                            predicate.kint(cx.tcx).ignore_qualifiers().skip_binder()\n+                        if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) =\n+                            predicate.ignore_qualifiers(cx.tcx).skip_binder().kind()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n                             let descr_pre ="}, {"sha": "a7c7b16048039386290eef78c30dffe041f5074c", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -39,7 +39,7 @@ impl<'tcx> EncodableWithShorthand for Ty<'tcx> {\n }\n \n impl<'tcx> EncodableWithShorthand for ty::Predicate<'tcx> {\n-    type Variant = ty::PredicateKynd<'tcx>;\n+    type Variant = ty::PredicateKind<'tcx>;\n     fn variant(&self) -> &Self::Variant {\n         self.kind()\n     }\n@@ -195,7 +195,7 @@ where\n         })\n     } else {\n         let tcx = decoder.tcx();\n-        Ok(tcx.mk_predicate(ty::PredicateKynd::decode(decoder)?))\n+        Ok(tcx.mk_predicate(ty::PredicateKind::decode(decoder)?))\n     }\n }\n "}, {"sha": "1e7fceb8e22e151fd2954dfd53dd910233bb2d7c", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -20,8 +20,8 @@ use crate::ty::{\n     self, query, AdtDef, AdtKind, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid,\n     DefIdTree, ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy,\n     IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind,\n-    PredicateKint, ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind,\n-    TyS, TyVar, TyVid, TypeAndMut,\n+    ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar,\n+    TyVid, TypeAndMut,\n };\n use rustc_ast::ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -79,7 +79,6 @@ pub struct CtxtInterners<'tcx> {\n     region: InternedSet<'tcx, RegionKind>,\n     existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n     predicate: InternedSet<'tcx, PredicateInner<'tcx>>,\n-    predicate_kint: InternedSet<'tcx, PredicateKint<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n@@ -99,7 +98,6 @@ impl<'tcx> CtxtInterners<'tcx> {\n             existential_predicates: Default::default(),\n             canonical_var_infos: Default::default(),\n             predicate: Default::default(),\n-            predicate_kint: Default::default(),\n             predicates: Default::default(),\n             projs: Default::default(),\n             place_elems: Default::default(),\n@@ -1617,7 +1615,6 @@ nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n nop_lift! {region; Region<'a> => Region<'tcx>}\n nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n nop_lift! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n-nop_lift! {predicate_kint; &'a PredicateKint<'a> => &'tcx PredicateKint<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {existential_predicates; ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n@@ -2030,8 +2027,8 @@ impl<'tcx> Borrow<Const<'tcx>> for Interned<'tcx, Const<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<PredicateKint<'tcx>> for Interned<'tcx, PredicateKint<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a PredicateKint<'tcx> {\n+impl<'tcx> Borrow<PredicateKind<'tcx>> for Interned<'tcx, PredicateKind<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a PredicateKind<'tcx> {\n         &self.0\n     }\n }\n@@ -2065,7 +2062,6 @@ macro_rules! direct_interners {\n direct_interners! {\n     region: mk_region(RegionKind),\n     const_: mk_const(Const<'tcx>),\n-    predicate_kint: intern_predicate_kint(PredicateKint<'tcx>),\n }\n \n macro_rules! slice_interners {"}, {"sha": "c8c8475b056da05df67676407bc05ab86ccf090d", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -201,45 +201,31 @@ impl FlagComputation {\n         }\n     }\n \n+    fn add_predicate(&mut self, pred: &ty::Predicate<'_>) {\n+        self.add_flags(pred.inner.flags);\n+        self.add_exclusive_binder(pred.inner.outer_exclusive_binder);\n+    }\n+\n     fn add_predicate_kind(&mut self, kind: &ty::PredicateKind<'_>) {\n         match kind {\n             ty::PredicateKind::Trait(trait_pred, _constness) => {\n-                let mut computation = FlagComputation::new();\n-                computation.add_substs(trait_pred.skip_binder().trait_ref.substs);\n-\n-                self.add_bound_computation(computation);\n+                self.add_substs(trait_pred.trait_ref.substs);\n             }\n-            ty::PredicateKind::RegionOutlives(poly_outlives) => {\n-                let mut computation = FlagComputation::new();\n-                let ty::OutlivesPredicate(a, b) = poly_outlives.skip_binder();\n-                computation.add_region(a);\n-                computation.add_region(b);\n-\n-                self.add_bound_computation(computation);\n+            ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n+                self.add_region(a);\n+                self.add_region(b);\n             }\n-            ty::PredicateKind::TypeOutlives(poly_outlives) => {\n-                let mut computation = FlagComputation::new();\n-                let ty::OutlivesPredicate(ty, region) = poly_outlives.skip_binder();\n-                computation.add_ty(ty);\n-                computation.add_region(region);\n-\n-                self.add_bound_computation(computation);\n+            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, region)) => {\n+                self.add_ty(ty);\n+                self.add_region(region);\n             }\n-            ty::PredicateKind::Subtype(poly_subtype) => {\n-                let mut computation = FlagComputation::new();\n-                let ty::SubtypePredicate { a_is_expected: _, a, b } = poly_subtype.skip_binder();\n-                computation.add_ty(a);\n-                computation.add_ty(b);\n-\n-                self.add_bound_computation(computation);\n+            ty::PredicateKind::Subtype(ty::SubtypePredicate { a_is_expected: _, a, b }) => {\n+                self.add_ty(a);\n+                self.add_ty(b);\n             }\n-            &ty::PredicateKind::Projection(projection) => {\n-                let mut computation = FlagComputation::new();\n-                let ty::ProjectionPredicate { projection_ty, ty } = projection.skip_binder();\n-                computation.add_projection_ty(projection_ty);\n-                computation.add_ty(ty);\n-\n-                self.add_bound_computation(computation);\n+            ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n+                self.add_projection_ty(projection_ty);\n+                self.add_ty(ty);\n             }\n             ty::PredicateKind::WellFormed(arg) => {\n                 self.add_substs(slice::from_ref(arg));\n@@ -255,6 +241,13 @@ impl FlagComputation {\n                 self.add_const(expected);\n                 self.add_const(found);\n             }\n+            ty::PredicateKind::ForAll(binder) => {\n+                let mut computation = FlagComputation::new();\n+\n+                computation.add_predicate(binder.skip_binder());\n+\n+                self.add_bound_computation(computation);\n+            }\n         }\n     }\n "}, {"sha": "3b154bf1518d6d65d458998b3d15bea626458bb4", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 115, "deletions": 239, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -1048,6 +1048,36 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn kind(self) -> &'tcx PredicateKind<'tcx> {\n         &self.inner.kind\n     }\n+\n+    /// Skips `PredicateKind::ForAll`.\n+    pub fn ignore_qualifiers(self, tcx: TyCtxt<'tcx>) -> Binder<Predicate<'tcx>> {\n+        match self.kind() {\n+            &PredicateKind::ForAll(binder) => binder,\n+            ty::PredicateKind::Projection(..)\n+            | ty::PredicateKind::Trait(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::WellFormed(..)\n+            | ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::TypeOutlives(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::RegionOutlives(..) => Binder::wrap_nonbinding(tcx, self),\n+        }\n+    }\n+\n+    /// Wraps `self` with the given qualifier if this predicate has any unbound variables.\n+    pub fn potentially_qualified(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        qualifier: impl FnOnce(Binder<Predicate<'tcx>>) -> PredicateKind<'tcx>,\n+    ) -> Predicate<'tcx> {\n+        if self.has_escaping_bound_vars() {\n+            qualifier(Binder::bind(self)).to_predicate(tcx)\n+        } else {\n+            self\n+        }\n+    }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n@@ -1065,72 +1095,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n     }\n }\n \n-impl<'tcx> Predicate<'tcx> {\n-    pub fn kint(self, tcx: TyCtxt<'tcx>) -> &'tcx PredicateKint<'tcx> {\n-        // I am efficient\n-        tcx.intern_predicate_kint(match *self.kind() {\n-            PredicateKind::Trait(binder, data) => {\n-                if let Some(simpl) = binder.no_bound_vars() {\n-                    PredicateKint::Trait(simpl, data)\n-                } else {\n-                    let inner = tcx\n-                        .intern_predicate_kint(PredicateKint::Trait(*binder.skip_binder(), data));\n-                    PredicateKint::ForAll(Binder::bind(inner))\n-                }\n-            }\n-            PredicateKind::RegionOutlives(binder) => {\n-                if let Some(simpl) = binder.no_bound_vars() {\n-                    PredicateKint::RegionOutlives(simpl)\n-                } else {\n-                    let inner = tcx.intern_predicate_kint(PredicateKint::RegionOutlives(\n-                        *binder.skip_binder(),\n-                    ));\n-                    PredicateKint::ForAll(Binder::bind(inner))\n-                }\n-            }\n-            PredicateKind::TypeOutlives(binder) => {\n-                if let Some(simpl) = binder.no_bound_vars() {\n-                    PredicateKint::TypeOutlives(simpl)\n-                } else {\n-                    let inner = tcx\n-                        .intern_predicate_kint(PredicateKint::TypeOutlives(*binder.skip_binder()));\n-                    PredicateKint::ForAll(Binder::bind(inner))\n-                }\n-            }\n-            PredicateKind::Projection(binder) => {\n-                if let Some(simpl) = binder.no_bound_vars() {\n-                    PredicateKint::Projection(simpl)\n-                } else {\n-                    let inner =\n-                        tcx.intern_predicate_kint(PredicateKint::Projection(*binder.skip_binder()));\n-                    PredicateKint::ForAll(Binder::bind(inner))\n-                }\n-            }\n-            PredicateKind::WellFormed(arg) => PredicateKint::WellFormed(arg),\n-            PredicateKind::ObjectSafe(def_id) => PredicateKint::ObjectSafe(def_id),\n-            PredicateKind::ClosureKind(def_id, substs, kind) => {\n-                PredicateKint::ClosureKind(def_id, substs, kind)\n-            }\n-            PredicateKind::Subtype(binder) => {\n-                if let Some(simpl) = binder.no_bound_vars() {\n-                    PredicateKint::Subtype(simpl)\n-                } else {\n-                    let inner =\n-                        tcx.intern_predicate_kint(PredicateKint::Subtype(*binder.skip_binder()));\n-                    PredicateKint::ForAll(Binder::bind(inner))\n-                }\n-            }\n-            PredicateKind::ConstEvaluatable(def, substs) => {\n-                PredicateKint::ConstEvaluatable(def, substs)\n-            }\n-            PredicateKind::ConstEquate(l, r) => PredicateKint::ConstEquate(l, r),\n-        })\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-#[derive(TypeFoldable)]\n-pub enum PredicateKint<'tcx> {\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(HashStable, TypeFoldable)]\n+pub enum PredicateKind<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n@@ -1164,67 +1131,14 @@ pub enum PredicateKint<'tcx> {\n     /// `T1 <: T2`\n     Subtype(SubtypePredicate<'tcx>),\n \n-    /// Constant initializer must evaluate successfully.\n-    ConstEvaluatable(DefId, SubstsRef<'tcx>),\n-\n-    /// Constants must be equal. The first component is the const that is expected.\n-    ConstEquate(&'tcx Const<'tcx>, &'tcx Const<'tcx>),\n-\n-    /// `for<'a>: ...`\n-    ForAll(Binder<&'tcx PredicateKint<'tcx>>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-#[derive(HashStable, TypeFoldable)]\n-pub enum PredicateKind<'tcx> {\n-    /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n-    /// the `Self` type of the trait reference and `A`, `B`, and `C`\n-    /// would be the type parameters.\n-    ///\n-    /// A trait predicate will have `Constness::Const` if it originates\n-    /// from a bound on a `const fn` without the `?const` opt-out (e.g.,\n-    /// `const fn foobar<Foo: Bar>() {}`).\n-    Trait(PolyTraitPredicate<'tcx>, Constness),\n-\n-    /// `where 'a: 'b`\n-    RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n-\n-    /// `where T: 'a`\n-    TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n-\n-    /// `where <T as TraitRef>::Name == X`, approximately.\n-    /// See the `ProjectionPredicate` struct for details.\n-    Projection(PolyProjectionPredicate<'tcx>),\n-\n-    /// No syntax: `T` well-formed.\n-    WellFormed(GenericArg<'tcx>),\n-\n-    /// Trait must be object-safe.\n-    ObjectSafe(DefId),\n-\n-    /// No direct syntax. May be thought of as `where T: FnFoo<...>`\n-    /// for some substitutions `...` and `T` being a closure type.\n-    /// Satisfied (or refuted) once we know the closure's kind.\n-    ClosureKind(DefId, SubstsRef<'tcx>, ClosureKind),\n-\n-    /// `T1 <: T2`\n-    Subtype(PolySubtypePredicate<'tcx>),\n-\n     /// Constant initializer must evaluate successfully.\n     ConstEvaluatable(ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n \n     /// Constants must be equal. The first component is the const that is expected.\n     ConstEquate(&'tcx Const<'tcx>, &'tcx Const<'tcx>),\n-}\n \n-impl<'tcx> PredicateKint<'tcx> {\n-    /// Skips `PredicateKint::ForAll`.\n-    pub fn ignore_qualifiers(&'tcx self) -> Binder<&'tcx PredicateKint<'tcx>> {\n-        match self {\n-            &PredicateKint::ForAll(binder) => binder,\n-            pred => Binder::dummy(pred),\n-        }\n-    }\n+    /// `for<'a>: ...`\n+    ForAll(Binder<Predicate<'tcx>>),\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -1313,20 +1227,18 @@ impl<'tcx> Predicate<'tcx> {\n         // this trick achieves that).\n \n         let substs = trait_ref.skip_binder().substs;\n-        let kind = match self.kint(tcx) {\n-            PredicateKint::ForAll(binder) => *binder.skip_binder(),\n+        let kind = match self.kind() {\n+            PredicateKind::ForAll(binder) => binder.skip_binder().kind(),\n             kind => kind,\n         };\n \n         let new = kind.subst(tcx, substs);\n \n-        let rebound = if new.has_escaping_bound_vars() {\n-            PredicateKint::ForAll(Binder::bind(tcx.intern_predicate_kint(new)))\n+        if new != *kind {\n+            new.to_predicate(tcx).potentially_qualified(tcx, PredicateKind::ForAll)\n         } else {\n-            new\n-        };\n-\n-        if rebound != *kind { rebound.to_predicate(tcx) } else { self }\n+            self\n+        }\n     }\n }\n \n@@ -1451,94 +1363,33 @@ impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n     }\n }\n \n-impl ToPredicate<'tcx> for PredicateKint<'tcx> {\n-    #[inline(always)]\n+impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n     fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        let (predicate, in_binder) = if let PredicateKint::ForAll(binder) = self {\n-            (*binder.skip_binder(), true)\n-        } else {\n-            (self, false)\n-        };\n-\n-        macro_rules! bind {\n-            ($expr:expr) => {\n-                match $expr {\n-                    expr => {\n-                        if in_binder {\n-                            Binder::bind(expr)\n-                        } else {\n-                            Binder::dummy(expr)\n-                        }\n-                    }\n-                }\n-            };\n-        }\n-\n-        match *predicate {\n-            PredicateKint::ForAll(_) => bug!(\"unexpected PredicateKint: {:?}\", self),\n-            PredicateKint::Trait(data, ct) => PredicateKind::Trait(bind!(data), ct),\n-            PredicateKint::RegionOutlives(data) => PredicateKind::RegionOutlives(bind!(data)),\n-            PredicateKint::TypeOutlives(data) => PredicateKind::TypeOutlives(bind!(data)),\n-            PredicateKint::Projection(data) => PredicateKind::Projection(bind!(data)),\n-            PredicateKint::WellFormed(arg) => {\n-                if in_binder {\n-                    bug!(\"unexpected ForAll: {:?}\", self)\n-                } else {\n-                    PredicateKind::WellFormed(arg)\n-                }\n-            }\n-            PredicateKint::ObjectSafe(def_id) => {\n-                if in_binder {\n-                    bug!(\"unexpected ForAll: {:?}\", self)\n-                } else {\n-                    PredicateKind::ObjectSafe(def_id)\n-                }\n-            }\n-            PredicateKint::ClosureKind(def_id, substs, kind) => {\n-                if in_binder {\n-                    bug!(\"unexpected ForAll: {:?}\", self)\n-                } else {\n-                    PredicateKind::ClosureKind(def_id, substs, kind)\n-                }\n-            }\n-            PredicateKint::Subtype(data) => PredicateKind::Subtype(bind!(data)),\n-            PredicateKint::ConstEvaluatable(def_id, substs) => {\n-                if in_binder {\n-                    bug!(\"unexpected ForAll: {:?}\", self)\n-                } else {\n-                    PredicateKind::ConstEvaluatable(def_id, substs)\n-                }\n-            }\n-            PredicateKint::ConstEquate(l, r) => {\n-                if in_binder {\n-                    bug!(\"unexpected ForAll: {:?}\", self)\n-                } else {\n-                    PredicateKind::ConstEquate(l, r)\n-                }\n-            }\n-        }\n-        .to_predicate(tcx)\n+        ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref: self.value }, self.constness)\n+            .to_predicate(tcx)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n+impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        ty::PredicateKint::Trait(ty::TraitPredicate { trait_ref: self.value }, self.constness)\n-            .to_predicate(tcx)\n+        ConstnessAnd {\n+            value: self.value.map_bound(|trait_ref| ty::TraitPredicate { trait_ref }),\n+            constness: self.constness,\n+        }\n+        .to_predicate(tcx)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n+impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitPredicate<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        if let Some(trait_ref) = self.value.no_bound_vars() {\n-            ty::PredicateKint::Trait(ty::TraitPredicate { trait_ref }, self.constness)\n+        if let Some(pred) = self.value.no_bound_vars() {\n+            ty::PredicateKind::Trait(pred, self.constness)\n         } else {\n-            ty::PredicateKint::ForAll(self.value.map_bound(|trait_ref| {\n-                tcx.intern_predicate_kint(ty::PredicateKint::Trait(\n-                    ty::TraitPredicate { trait_ref },\n-                    self.constness,\n-                ))\n-            }))\n+            ty::PredicateKind::ForAll(\n+                self.value.map_bound(|pred| {\n+                    ty::PredicateKind::Trait(pred, self.constness).to_predicate(tcx)\n+                }),\n+            )\n         }\n         .to_predicate(tcx)\n     }\n@@ -1547,57 +1398,82 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         if let Some(outlives) = self.no_bound_vars() {\n-            PredicateKint::RegionOutlives(outlives)\n+            PredicateKind::RegionOutlives(outlives)\n         } else {\n-            ty::PredicateKint::ForAll(self.map_bound(|outlives| {\n-                tcx.intern_predicate_kint(PredicateKint::RegionOutlives(outlives))\n-            }))\n+            ty::PredicateKind::ForAll(\n+                self.map_bound(|outlives| {\n+                    PredicateKind::RegionOutlives(outlives).to_predicate(tcx)\n+                }),\n+            )\n         }\n         .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateKind::TypeOutlives(self).to_predicate(tcx)\n+        if let Some(outlives) = self.no_bound_vars() {\n+            PredicateKind::TypeOutlives(outlives)\n+        } else {\n+            ty::PredicateKind::ForAll(\n+                self.map_bound(|outlives| PredicateKind::TypeOutlives(outlives).to_predicate(tcx)),\n+            )\n+        }\n+        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateKind::Projection(self).to_predicate(tcx)\n+        if let Some(proj) = self.no_bound_vars() {\n+            PredicateKind::Projection(proj)\n+        } else {\n+            ty::PredicateKind::ForAll(\n+                self.map_bound(|proj| PredicateKind::Projection(proj).to_predicate(tcx)),\n+            )\n+        }\n+        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> Predicate<'tcx> {\n-    pub fn to_opt_poly_trait_ref(self) -> Option<PolyTraitRef<'tcx>> {\n-        match self.kind() {\n-            &PredicateKind::Trait(ref t, _) => Some(t.to_poly_trait_ref()),\n-            PredicateKind::Projection(..)\n-            | PredicateKind::Subtype(..)\n-            | PredicateKind::RegionOutlives(..)\n-            | PredicateKind::WellFormed(..)\n-            | PredicateKind::ObjectSafe(..)\n-            | PredicateKind::ClosureKind(..)\n-            | PredicateKind::TypeOutlives(..)\n-            | PredicateKind::ConstEvaluatable(..)\n-            | PredicateKind::ConstEquate(..) => None,\n-        }\n+    pub fn to_opt_poly_trait_ref(self, tcx: TyCtxt<'tcx>) -> Option<PolyTraitRef<'tcx>> {\n+        self.ignore_qualifiers(tcx)\n+            .map_bound(|pred| match pred.kind() {\n+                &PredicateKind::Trait(ref t, _) => Some(t.trait_ref),\n+                PredicateKind::Projection(..)\n+                | PredicateKind::Subtype(..)\n+                | PredicateKind::RegionOutlives(..)\n+                | PredicateKind::WellFormed(..)\n+                | PredicateKind::ObjectSafe(..)\n+                | PredicateKind::ClosureKind(..)\n+                | PredicateKind::TypeOutlives(..)\n+                | PredicateKind::ConstEvaluatable(..)\n+                | PredicateKind::ConstEquate(..) => None,\n+                PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", self),\n+            })\n+            .transpose()\n     }\n \n-    pub fn to_opt_type_outlives(self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n-        match self.kind() {\n-            &PredicateKind::TypeOutlives(data) => Some(data),\n-            PredicateKind::Trait(..)\n-            | PredicateKind::Projection(..)\n-            | PredicateKind::Subtype(..)\n-            | PredicateKind::RegionOutlives(..)\n-            | PredicateKind::WellFormed(..)\n-            | PredicateKind::ObjectSafe(..)\n-            | PredicateKind::ClosureKind(..)\n-            | PredicateKind::ConstEvaluatable(..)\n-            | PredicateKind::ConstEquate(..) => None,\n-        }\n+    pub fn to_opt_type_outlives(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n+        self.ignore_qualifiers(tcx)\n+            .map_bound(|pred| match pred.kind() {\n+                &PredicateKind::TypeOutlives(data) => Some(data),\n+                PredicateKind::Trait(..)\n+                | PredicateKind::Projection(..)\n+                | PredicateKind::Subtype(..)\n+                | PredicateKind::RegionOutlives(..)\n+                | PredicateKind::WellFormed(..)\n+                | PredicateKind::ObjectSafe(..)\n+                | PredicateKind::ClosureKind(..)\n+                | PredicateKind::ConstEvaluatable(..)\n+                | PredicateKind::ConstEquate(..) => None,\n+                PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", self),\n+            })\n+            .transpose()\n     }\n }\n "}, {"sha": "1fdd7d4c82479d5a4c8c794d9ac76d24754b54ed", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -572,7 +572,7 @@ pub trait PrettyPrinter<'tcx>:\n                     let mut is_sized = false;\n                     p!(write(\"impl\"));\n                     for predicate in bounds.predicates {\n-                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref(self.tcx()) {\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n                                 is_sized = true;\n@@ -2039,6 +2039,9 @@ define_print_and_forward_display! {\n                    print(c2),\n                    write(\"`\"))\n             }\n+            ty::PredicateKind::ForAll(binder) => {\n+                p!(print(binder))\n+            }\n         }\n     }\n "}, {"sha": "55fab4999053aa45cccbb426f78f1ced17acc1c7", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -247,6 +247,7 @@ impl fmt::Debug for ty::PredicateKind<'tcx> {\n                 write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n             }\n             ty::PredicateKind::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n+            ty::PredicateKind::ForAll(binder) => write!(f, \"ForAll({:?})\", binder),\n         }\n     }\n }\n@@ -478,20 +479,18 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n     type Lifted = ty::PredicateKind<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            ty::PredicateKind::Trait(ref binder, constness) => {\n-                tcx.lift(binder).map(|binder| ty::PredicateKind::Trait(binder, constness))\n+            ty::PredicateKind::Trait(ref data, constness) => {\n+                tcx.lift(data).map(|data| ty::PredicateKind::Trait(data, constness))\n             }\n-            ty::PredicateKind::Subtype(ref binder) => {\n-                tcx.lift(binder).map(ty::PredicateKind::Subtype)\n+            ty::PredicateKind::Subtype(ref data) => tcx.lift(data).map(ty::PredicateKind::Subtype),\n+            ty::PredicateKind::RegionOutlives(ref data) => {\n+                tcx.lift(data).map(ty::PredicateKind::RegionOutlives)\n             }\n-            ty::PredicateKind::RegionOutlives(ref binder) => {\n-                tcx.lift(binder).map(ty::PredicateKind::RegionOutlives)\n+            ty::PredicateKind::TypeOutlives(ref data) => {\n+                tcx.lift(data).map(ty::PredicateKind::TypeOutlives)\n             }\n-            ty::PredicateKind::TypeOutlives(ref binder) => {\n-                tcx.lift(binder).map(ty::PredicateKind::TypeOutlives)\n-            }\n-            ty::PredicateKind::Projection(ref binder) => {\n-                tcx.lift(binder).map(ty::PredicateKind::Projection)\n+            ty::PredicateKind::Projection(ref data) => {\n+                tcx.lift(data).map(ty::PredicateKind::Projection)\n             }\n             ty::PredicateKind::WellFormed(ty) => tcx.lift(&ty).map(ty::PredicateKind::WellFormed),\n             ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n@@ -508,6 +507,9 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n             ty::PredicateKind::ConstEquate(c1, c2) => {\n                 tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateKind::ConstEquate(c1, c2))\n             }\n+            ty::PredicateKind::ForAll(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::ForAll)\n+            }\n         }\n     }\n }\n@@ -1028,17 +1030,6 @@ impl<T: TypeVisitor<'tcx>> PredicateVisitor<'tcx> for T {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::PredicateKint<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let new = ty::PredicateKint::super_fold_with(self, folder);\n-        folder.tcx().intern_predicate_kint(new)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        ty::PredicateKint::super_visit_with(self, visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         fold_list(*self, folder, |tcx, v| tcx.intern_predicates(v))"}, {"sha": "58a89c7fdb11000f692794000193d2504b7e4732", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -895,6 +895,19 @@ impl<T> Binder<T> {\n         Binder(value)\n     }\n \n+    /// Wraps `value` in a binder without actually binding any currently\n+    /// unbound variables.\n+    pub fn wrap_nonbinding(tcx: TyCtxt<'tcx>, value: T) -> Binder<T>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        if value.has_escaping_bound_vars() {\n+            Binder::bind(super::fold::shift_vars(tcx, &value, 1))\n+        } else {\n+            Binder::dummy(value)\n+        }\n+    }\n+\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// De Bruijn indices and the like. It is usually better to\n@@ -979,6 +992,15 @@ impl<T> Binder<T> {\n     }\n }\n \n+impl<T> Binder<Option<T>> {\n+    pub fn transpose(self) -> Option<Binder<T>> {\n+        match self.0 {\n+            Some(v) => Some(Binder(v)),\n+            None => None,\n+        }\n+    }\n+}\n+\n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "4daebcec6ffea766b5bf2bea2a37c927dcfe5190", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -589,10 +589,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                     let mut found = false;\n                     for predicate in bounds.predicates {\n-                        if let ty::PredicateKind::TypeOutlives(binder) = predicate.kind() {\n-                            if let ty::OutlivesPredicate(_, ty::RegionKind::ReStatic) =\n-                                binder.skip_binder()\n-                            {\n+                        if let ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_, r)) =\n+                            predicate.ignore_qualifiers(self.infcx.tcx).skip_binder().kind()\n+                        {\n+                            if let ty::RegionKind::ReStatic = r {\n                                 found = true;\n                                 break;\n                             } else {"}, {"sha": "fe8d924debe7928dc10e1b77206d341bbc3176d3", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -274,7 +274,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n \n         // Insert the facts we know from the predicates. Why? Why not.\n         let param_env = self.param_env;\n-        self.add_outlives_bounds(outlives::explicit_outlives_bounds(param_env));\n+        self.add_outlives_bounds(outlives::explicit_outlives_bounds(self.infcx.tcx, param_env));\n \n         // Finally:\n         // - outlives is reflexive, so `'r: 'r` for every region `'r`"}, {"sha": "8fdedd72c483f532c915446e24a9ef0152b233a8", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -1021,7 +1021,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     self.prove_predicate(\n-                        ty::PredicateKint::WellFormed(inferred_ty.into()).to_predicate(self.tcx()),\n+                        ty::PredicateKind::WellFormed(inferred_ty.into()).to_predicate(self.tcx()),\n                         Locations::All(span),\n                         ConstraintCategory::TypeAnnotation,\n                     );\n@@ -1273,7 +1273,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     obligations.obligations.push(traits::Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        ty::PredicateKint::WellFormed(revealed_ty.into()).to_predicate(infcx.tcx),\n+                        ty::PredicateKind::WellFormed(revealed_ty.into()).to_predicate(infcx.tcx),\n                     ));\n                     obligations.add(\n                         infcx\n@@ -1617,7 +1617,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.check_call_dest(body, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n-                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKint::WellFormed(ty.into())),\n+                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKind::WellFormed(ty.into())),\n                     term_location.to_locations(),\n                     ConstraintCategory::Boring,\n                 );\n@@ -2702,7 +2702,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) {\n         self.prove_predicates(\n-            Some(ty::PredicateKint::Trait(\n+            Some(ty::PredicateKind::Trait(\n                 ty::TraitPredicate { trait_ref },\n                 hir::Constness::NotConst,\n             )),"}, {"sha": "0d4d10263818138b6ed8cc72a25dafce4938cd6a", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -24,7 +24,9 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n     loop {\n         let predicates = tcx.predicates_of(current);\n         for (predicate, _) in predicates.predicates {\n-            match predicate.kind() {\n+            // TODO: forall\n+            match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+                ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", predicate),\n                 ty::PredicateKind::RegionOutlives(_)\n                 | ty::PredicateKind::TypeOutlives(_)\n                 | ty::PredicateKind::WellFormed(_)\n@@ -44,7 +46,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }\n-                    match pred.skip_binder().self_ty().kind {\n+                    match pred.self_ty().kind {\n                         ty::Param(ref p) => {\n                             // Allow `T: ?const Trait`\n                             if constness == hir::Constness::NotConst"}, {"sha": "74f0e669ef3c361f86341c01f18e63912ccddf18", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -87,25 +87,22 @@ where\n     fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> bool {\n         let ty::GenericPredicates { parent: _, predicates } = predicates;\n         for (predicate, _span) in predicates {\n-            match predicate.kind() {\n-                ty::PredicateKind::Trait(poly_predicate, _) => {\n-                    let ty::TraitPredicate { trait_ref } = poly_predicate.skip_binder();\n+            // This visitor does not care about bound regions.\n+            match predicate.ignore_qualifiers(self.def_id_visitor.tcx()).skip_binder().kind() {\n+                &ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref }, _) => {\n                     if self.visit_trait(trait_ref) {\n                         return true;\n                     }\n                 }\n-                ty::PredicateKind::Projection(poly_predicate) => {\n-                    let ty::ProjectionPredicate { projection_ty, ty } =\n-                        poly_predicate.skip_binder();\n+                &ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n                     if ty.visit_with(self) {\n                         return true;\n                     }\n                     if self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx())) {\n                         return true;\n                     }\n                 }\n-                ty::PredicateKind::TypeOutlives(poly_predicate) => {\n-                    let ty::OutlivesPredicate(ty, _region) = poly_predicate.skip_binder();\n+                &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n                     if ty.visit_with(self) {\n                         return true;\n                     }"}, {"sha": "3c42400fbbc1972792e0a1b4b93a9db26175e9cd", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -1154,8 +1154,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n         for predicate in &bounds.predicates {\n-            if let ty::PredicateKind::Projection(projection) = predicate.kind() {\n-                if projection.skip_binder().ty.references_error() {\n+            if let ty::PredicateKind::Projection(projection) =\n+                predicate.ignore_qualifiers(tcx).skip_binder().kind()\n+            {\n+                if projection.ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n                     return ty_var;\n                 }\n@@ -1252,7 +1254,7 @@ crate fn required_region_bounds(\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|obligation| {\n             debug!(\"required_region_bounds(obligation={:?})\", obligation);\n-            match obligation.predicate.kind() {\n+            match obligation.predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n                 ty::PredicateKind::Projection(..)\n                 | ty::PredicateKind::Trait(..)\n                 | ty::PredicateKind::Subtype(..)\n@@ -1262,7 +1264,8 @@ crate fn required_region_bounds(\n                 | ty::PredicateKind::RegionOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..) => None,\n-                ty::PredicateKind::TypeOutlives(predicate) => {\n+                ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", obligation),\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n                     // Search for a bound of the form `erased_self_ty\n                     // : 'a`, but be wary of something like `for<'a>\n                     // erased_self_ty : 'a` (we interpret a\n@@ -1272,7 +1275,6 @@ crate fn required_region_bounds(\n                     // it's kind of a moot point since you could never\n                     // construct such an object, but this seems\n                     // correct even if that code changes).\n-                    let ty::OutlivesPredicate(ref t, ref r) = predicate.skip_binder();\n                     if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n                         Some(*r)\n                     } else {"}, {"sha": "9c530912bf0e4ed88a7d8b68cb3564b2f6550ec1", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -344,8 +344,7 @@ impl AutoTraitFinder<'tcx> {\n                         already_visited.remove(&pred);\n                         self.add_user_pred(\n                             &mut user_computed_preds,\n-                            ty::PredicateKind::Trait(pred, hir::Constness::NotConst)\n-                                .to_predicate(self.tcx),\n+                            pred.without_const().to_predicate(self.tcx),\n                         );\n                         predicates.push_back(pred);\n                     } else {\n@@ -408,21 +407,23 @@ impl AutoTraitFinder<'tcx> {\n     /// under which a type implements an auto trait. A trait predicate involving\n     /// a HRTB means that the type needs to work with any choice of lifetime,\n     /// not just one specific lifetime (e.g., `'static`).\n-    fn add_user_pred<'c>(\n+    fn add_user_pred(\n         &self,\n-        user_computed_preds: &mut FxHashSet<ty::Predicate<'c>>,\n-        new_pred: ty::Predicate<'c>,\n+        user_computed_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n+        new_pred: ty::Predicate<'tcx>,\n     ) {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n             if let (\n                 ty::PredicateKind::Trait(new_trait, _),\n                 ty::PredicateKind::Trait(old_trait, _),\n-            ) = (new_pred.kind(), old_pred.kind())\n-            {\n+            ) = (\n+                new_pred.ignore_qualifiers(self.tcx).skip_binder().kind(),\n+                old_pred.ignore_qualifiers(self.tcx).skip_binder().kind(),\n+            ) {\n                 if new_trait.def_id() == old_trait.def_id() {\n-                    let new_substs = new_trait.skip_binder().trait_ref.substs;\n-                    let old_substs = old_trait.skip_binder().trait_ref.substs;\n+                    let new_substs = new_trait.trait_ref.substs;\n+                    let old_substs = old_trait.trait_ref.substs;\n \n                     if !new_substs.types().eq(old_substs.types()) {\n                         // We can't compare lifetimes if the types are different,\n@@ -618,11 +619,12 @@ impl AutoTraitFinder<'tcx> {\n     ) -> bool {\n         let dummy_cause = ObligationCause::dummy();\n \n-        for (obligation, mut predicate) in nested.map(|o| (o.clone(), o.predicate)) {\n-            let is_new_pred = fresh_preds.insert(self.clean_pred(select.infcx(), predicate));\n+        for obligation in nested {\n+            let is_new_pred =\n+                fresh_preds.insert(self.clean_pred(select.infcx(), obligation.predicate));\n \n             // Resolve any inference variables that we can, to help selection succeed\n-            predicate = select.infcx().resolve_vars_if_possible(&predicate);\n+            let predicate = select.infcx().resolve_vars_if_possible(&obligation.predicate);\n \n             // We only add a predicate as a user-displayable bound if\n             // it involves a generic parameter, and doesn't contain\n@@ -636,17 +638,20 @@ impl AutoTraitFinder<'tcx> {\n             //\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n-            match predicate.kind() {\n+\n+            // TODO: forall\n+            match predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n                 &ty::PredicateKind::Trait(p, _) => {\n-                    if self.is_param_no_infer(p.skip_binder().trait_ref.substs)\n+                    if self.is_param_no_infer(p.trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred\n                     {\n                         self.add_user_pred(computed_preds, predicate);\n                     }\n-                    predicates.push_back(p);\n+                    predicates.push_back(ty::Binder::bind(p));\n                 }\n                 &ty::PredicateKind::Projection(p) => {\n+                    let p = ty::Binder::bind(p);\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n                         predicate\n@@ -772,11 +777,13 @@ impl AutoTraitFinder<'tcx> {\n                     }\n                 }\n                 &ty::PredicateKind::RegionOutlives(binder) => {\n+                    let binder = ty::Binder::bind(binder);\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n                 &ty::PredicateKind::TypeOutlives(binder) => {\n+                    let binder = ty::Binder::bind(binder);\n                     match (\n                         binder.no_bound_vars(),\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),"}, {"sha": "8a2915bb30c7173093e3ae84fa41dbd631872cfb", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -255,9 +255,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .emit();\n                     return;\n                 }\n-                match obligation.predicate.kind() {\n-                    ty::PredicateKind::Trait(ref trait_predicate, _) => {\n-                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n+\n+                // TODO: forall\n+                match obligation.predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+                    ty::PredicateKind::ForAll(_) => {\n+                        bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n+                    }\n+                    &ty::PredicateKind::Trait(trait_predicate, _) => {\n+                        let trait_predicate = ty::Binder::bind(trait_predicate);\n+                        let trait_predicate = self.resolve_vars_if_possible(&trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n                             return;\n@@ -503,14 +509,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 );\n                                 trait_pred\n                             });\n-                            let unit_obligation = Obligation {\n-                                predicate: ty::PredicateKind::Trait(\n-                                    predicate,\n-                                    hir::Constness::NotConst,\n-                                )\n-                                .to_predicate(self.tcx),\n-                                ..obligation.clone()\n-                            };\n+                            let unit_obligation =\n+                                obligation.with(predicate.without_const().to_predicate(tcx));\n                             if self.predicate_may_hold(&unit_obligation) {\n                                 err.note(\n                                     \"the trait is implemented for `()`. \\\n@@ -526,15 +526,16 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err\n                     }\n \n-                    ty::PredicateKind::Subtype(ref predicate) => {\n+                    ty::PredicateKind::Subtype(predicate) => {\n                         // Errors for Subtype predicates show up as\n                         // `FulfillmentErrorCode::CodeSubtypeError`,\n                         // not selection error.\n                         span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n                     }\n \n-                    ty::PredicateKind::RegionOutlives(ref predicate) => {\n-                        let predicate = self.resolve_vars_if_possible(predicate);\n+                    &ty::PredicateKind::RegionOutlives(predicate) => {\n+                        let predicate = ty::Binder::bind(predicate);\n+                        let predicate = self.resolve_vars_if_possible(&predicate);\n                         let err = self\n                             .region_outlives_predicate(&obligation.cause, predicate)\n                             .err()\n@@ -1089,18 +1090,26 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return true;\n         }\n \n-        let (cond, error) = match (cond.kind(), error.kind()) {\n-            (ty::PredicateKind::Trait(..), ty::PredicateKind::Trait(error, _)) => (cond, error),\n+        // FIXME: It should be possible to deal with `ForAll` in a cleaner way.\n+        let (cond, error) = match (\n+            cond.ignore_qualifiers(self.tcx).skip_binder().kind(),\n+            error.ignore_qualifiers(self.tcx).skip_binder().kind(),\n+        ) {\n+            (ty::PredicateKind::Trait(..), &ty::PredicateKind::Trait(error, _)) => {\n+                (cond, ty::Binder::bind(error))\n+            }\n             _ => {\n                 // FIXME: make this work in other cases too.\n                 return false;\n             }\n         };\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n-            if let ty::PredicateKind::Trait(implication, _) = obligation.predicate.kind() {\n+            if let &ty::PredicateKind::Trait(implication, _) =\n+                obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind()\n+            {\n                 let error = error.to_poly_trait_ref();\n-                let implication = implication.to_poly_trait_ref();\n+                let implication = ty::Binder::bind(implication).to_poly_trait_ref();\n                 // FIXME: I'm just not taking associated types at all here.\n                 // Eventually I'll need to implement param-env-aware\n                 // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n@@ -1178,12 +1187,14 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             //\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n-            if let ty::PredicateKind::Projection(ref data) = predicate.kind() {\n+            if let &ty::PredicateKind::Projection(data) =\n+                predicate.ignore_qualifiers(self.tcx).skip_binder().kind()\n+            {\n                 let mut selcx = SelectionContext::new(self);\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    data,\n+                    &ty::Binder::bind(data),\n                 );\n                 let mut obligations = vec![];\n                 let normalized_ty = super::normalize_projection_type(\n@@ -1470,9 +1481,10 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        let mut err = match predicate.kind() {\n-            ty::PredicateKind::Trait(ref data, _) => {\n-                let trait_ref = data.to_poly_trait_ref();\n+        // TODO: forall\n+        let mut err = match predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+            &ty::PredicateKind::Trait(data, _) => {\n+                let trait_ref = ty::Binder::bind(data.trait_ref);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n                 debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n \n@@ -1571,6 +1583,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n \n             ty::PredicateKind::WellFormed(arg) => {\n+                // TODO: forall\n+\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n                 if arg.references_error() || self.tcx.sess.has_errors() {\n@@ -1595,15 +1609,15 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     // no need to overload user in such cases\n                     return;\n                 }\n-                let SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n+                let &SubtypePredicate { a_is_expected: _, a, b } = data;\n                 // both must be type variables, or the other would've been instantiated\n                 assert!(a.is_ty_var() && b.is_ty_var());\n                 self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n             }\n-            ty::PredicateKind::Projection(ref data) => {\n-                let trait_ref = data.to_poly_trait_ref(self.tcx);\n+            &ty::PredicateKind::Projection(data) => {\n+                let trait_ref = ty::Binder::bind(data).to_poly_trait_ref(self.tcx);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n-                let ty = data.skip_binder().ty;\n+                let ty = data.ty;\n                 if predicate.references_error() {\n                     return;\n                 }\n@@ -1724,16 +1738,16 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         let (pred, item_def_id, span) =\n-            match (obligation.predicate.kind(), &obligation.cause.code.peel_derives()) {\n+            match (obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind(), obligation.cause.code.peel_derives()) {\n                 (\n                     ty::PredicateKind::Trait(pred, _),\n-                    ObligationCauseCode::BindingObligation(item_def_id, span),\n+                    &ObligationCauseCode::BindingObligation(item_def_id, span),\n                 ) => (pred, item_def_id, span),\n                 _ => return,\n             };\n \n         let node = match (\n-            self.tcx.hir().get_if_local(*item_def_id),\n+            self.tcx.hir().get_if_local(item_def_id),\n             Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n         ) {\n             (Some(node), true) => node,\n@@ -1744,7 +1758,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             None => return,\n         };\n         for param in generics.params {\n-            if param.span != *span\n+            if param.span != span\n                 || param.bounds.iter().any(|bound| {\n                     bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n                         == self.tcx.lang_items().sized_trait()"}, {"sha": "7e3d4908f9af6637e6161768cf3cd3dc3a2ce5fc", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -1299,12 +1299,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // the type. The last generator (`outer_generator` below) has information about where the\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n-        let (mut trait_ref, mut target_ty) = match obligation.predicate.kind() {\n-            ty::PredicateKind::Trait(p, _) => {\n-                (Some(p.skip_binder().trait_ref), Some(p.skip_binder().self_ty()))\n-            }\n-            _ => (None, None),\n-        };\n+        let (mut trait_ref, mut target_ty) =\n+            match obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+                ty::PredicateKind::Trait(p, _) => (Some(p.trait_ref), Some(p.self_ty())),\n+                _ => (None, None),\n+            };\n         let mut generator = None;\n         let mut outer_generator = None;\n         let mut next_code = Some(&obligation.cause.code);"}, {"sha": "995be1d90de36b16a8996beab1bd818c0b9add17", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::ErrorReported;\n use rustc_infer::traits::{PolyTraitObligation, TraitEngine, TraitEngineExt as _};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n-use rustc_middle::ty::{self, Binder, Const, ToPredicate, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, Binder, Const, Ty, TypeFoldable};\n use std::marker::PhantomData;\n \n use super::project;\n@@ -318,12 +318,12 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         let infcx = self.selcx.infcx();\n \n-        match obligation.predicate.kint(infcx.tcx) {\n-            ty::PredicateKint::ForAll(binder) => match binder.skip_binder() {\n+        match obligation.predicate.kind() {\n+            ty::PredicateKind::ForAll(binder) => match binder.skip_binder().kind() {\n                 // Evaluation will discard candidates using the leak check.\n                 // This means we need to pass it the bound version of our\n                 // predicate.\n-                rustc_middle::ty::PredicateKint::Trait(trait_ref, _constness) => {\n+                ty::PredicateKind::Trait(trait_ref, _constness) => {\n                     let trait_obligation = obligation.with(Binder::bind(*trait_ref));\n \n                     self.process_trait_obligation(\n@@ -332,30 +332,28 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                         &mut pending_obligation.stalled_on,\n                     )\n                 }\n-                rustc_middle::ty::PredicateKint::Projection(projection) => {\n+                ty::PredicateKind::Projection(projection) => {\n                     let project_obligation = obligation.with(Binder::bind(*projection));\n \n                     self.process_projection_obligation(\n                         project_obligation,\n                         &mut pending_obligation.stalled_on,\n                     )\n                 }\n-                rustc_middle::ty::PredicateKint::RegionOutlives(_)\n-                | rustc_middle::ty::PredicateKint::TypeOutlives(_)\n-                | rustc_middle::ty::PredicateKint::WellFormed(_)\n-                | rustc_middle::ty::PredicateKint::ObjectSafe(_)\n-                | rustc_middle::ty::PredicateKint::ClosureKind(..)\n-                | rustc_middle::ty::PredicateKint::Subtype(_)\n-                | rustc_middle::ty::PredicateKint::ConstEvaluatable(..)\n-                | rustc_middle::ty::PredicateKint::ConstEquate(..)\n-                | rustc_middle::ty::PredicateKint::ForAll(_) => {\n+                ty::PredicateKind::RegionOutlives(_)\n+                | ty::PredicateKind::TypeOutlives(_)\n+                | ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::ObjectSafe(_)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::Subtype(_)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::ForAll(_) => {\n                     let (pred, _) = infcx.replace_bound_vars_with_placeholders(binder);\n-                    ProcessResult::Changed(mk_pending(vec![\n-                        obligation.with(pred.to_predicate(infcx.tcx)),\n-                    ]))\n+                    ProcessResult::Changed(mk_pending(vec![obligation.with(pred)]))\n                 }\n             },\n-            ty::PredicateKint::Trait(ref data, _) => {\n+            ty::PredicateKind::Trait(ref data, _) => {\n                 let trait_obligation = obligation.with(Binder::dummy(*data));\n \n                 self.process_trait_obligation(\n@@ -365,14 +363,14 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 )\n             }\n \n-            &ty::PredicateKint::RegionOutlives(data) => {\n+            &ty::PredicateKind::RegionOutlives(data) => {\n                 match infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data)) {\n                     Ok(()) => ProcessResult::Changed(vec![]),\n                     Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n                 }\n             }\n \n-            ty::PredicateKint::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {\n+            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {\n                 if self.register_region_obligations {\n                     self.selcx.infcx().register_region_obligation_with_cause(\n                         t_a,\n@@ -383,7 +381,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 ProcessResult::Changed(vec![])\n             }\n \n-            ty::PredicateKint::Projection(ref data) => {\n+            ty::PredicateKind::Projection(ref data) => {\n                 let project_obligation = obligation.with(Binder::dummy(*data));\n \n                 self.process_projection_obligation(\n@@ -392,15 +390,15 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 )\n             }\n \n-            &ty::PredicateKint::ObjectSafe(trait_def_id) => {\n+            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 if !self.selcx.tcx().is_object_safe(trait_def_id) {\n                     ProcessResult::Error(CodeSelectionError(Unimplemented))\n                 } else {\n                     ProcessResult::Changed(vec![])\n                 }\n             }\n \n-            &ty::PredicateKint::ClosureKind(_, closure_substs, kind) => {\n+            &ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n                 match self.selcx.infcx().closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n@@ -413,7 +411,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKint::WellFormed(arg) => {\n+            &ty::PredicateKind::WellFormed(arg) => {\n                 match wf::obligations(\n                     self.selcx.infcx(),\n                     obligation.param_env,\n@@ -430,7 +428,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKint::Subtype(subtype) => {\n+            &ty::PredicateKind::Subtype(subtype) => {\n                 match self.selcx.infcx().subtype_predicate(\n                     &obligation.cause,\n                     obligation.param_env,\n@@ -456,7 +454,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKint::ConstEvaluatable(def_id, substs) => {\n+            &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 match self.selcx.infcx().const_eval_resolve(\n                     obligation.param_env,\n                     def_id,\n@@ -469,7 +467,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKint::ConstEquate(c1, c2) => {\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n                 debug!(\"equating consts: c1={:?} c2={:?}\", c1, c2);\n \n                 let stalled_on = &mut pending_obligation.stalled_on;"}, {"sha": "da17d89b8c13a1f3f713e24570703390af572df7", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -237,7 +237,7 @@ fn do_normalize_predicates<'tcx>(\n \n         // We can use the `elaborated_env` here; the region code only\n         // cares about declarations like `'a: 'b`.\n-        let outlives_env = OutlivesEnvironment::new(elaborated_env);\n+        let outlives_env = OutlivesEnvironment::new(tcx, elaborated_env);\n \n         infcx.resolve_regions_and_report_errors(\n             region_context,\n@@ -328,7 +328,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // This works fairly well because trait matching  does not actually care about param-env\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n-        .drain_filter(|predicate| match predicate.kind() {\n+        .drain_filter(|predicate| match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n             ty::PredicateKind::TypeOutlives(..) => true,\n             _ => false,\n         })"}, {"sha": "cb03751bb7861454438bd85e677f88310cf68fb6", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -245,14 +245,11 @@ fn predicates_reference_self(\n         .iter()\n         .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|(predicate, &sp)| {\n-            match predicate.kind() {\n+            // TODO: forall\n+            match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n                 ty::PredicateKind::Trait(ref data, _) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n-                    if data.skip_binder().trait_ref.substs[1..].iter().any(has_self_ty) {\n-                        Some(sp)\n-                    } else {\n-                        None\n-                    }\n+                    if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n                 }\n                 ty::PredicateKind::Projection(ref data) => {\n                     // And similarly for projections. This should be redundant with\n@@ -267,10 +264,7 @@ fn predicates_reference_self(\n                     //\n                     // This is ALT2 in issue #56288, see that for discussion of the\n                     // possible alternatives.\n-                    if data.skip_binder().projection_ty.trait_ref(tcx).substs[1..]\n-                        .iter()\n-                        .any(has_self_ty)\n-                    {\n+                    if data.projection_ty.trait_ref(tcx).substs[1..].iter().any(has_self_ty) {\n                         Some(sp)\n                     } else {\n                         None\n@@ -284,6 +278,7 @@ fn predicates_reference_self(\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..) => None,\n+                ty::PredicateKind::ForAll(..) => bug!(\"unexpected predicate: {:?}\", predicate),\n             }\n         })\n         .collect()\n@@ -305,10 +300,10 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n     elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| {\n-        match obligation.predicate.kind() {\n+        // TODO: forall\n+        match obligation.predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n             ty::PredicateKind::Trait(ref trait_pred, _) => {\n-                trait_pred.def_id() == sized_def_id\n-                    && trait_pred.skip_binder().self_ty().is_param(0)\n+                trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n             }\n             ty::PredicateKind::Projection(..)\n             | ty::PredicateKind::Subtype(..)\n@@ -319,6 +314,9 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..) => false,\n+            ty::PredicateKind::ForAll(_) => {\n+                bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n+            }\n         }\n     })\n }\n@@ -404,7 +402,7 @@ fn virtual_call_violation_for_method<'tcx>(\n         // A trait object can't claim to live more than the concrete type,\n         // so outlives predicates will always hold.\n         .cloned()\n-        .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n+        .filter(|(p, _)| p.to_opt_type_outlives(tcx).is_none())\n         .collect::<Vec<_>>()\n         // Do a shallow visit so that `contains_illegal_self_type_reference`\n         // may apply it's custom visiting."}, {"sha": "30c86055e409e26a7a69dee665d29ef697a3038a", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -664,23 +664,25 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n     let mut obligations: Vec<_> = result\n         .obligations\n         .iter()\n-        .filter(|obligation| match obligation.predicate.kind() {\n-            // We found a `T: Foo<X = U>` predicate, let's check\n-            // if `U` references any unresolved type\n-            // variables. In principle, we only care if this\n-            // projection can help resolve any of the type\n-            // variables found in `result.value` -- but we just\n-            // check for any type variables here, for fear of\n-            // indirect obligations (e.g., we project to `?0`,\n-            // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n-            // ?0>`).\n-            ty::PredicateKind::Projection(ref data) => {\n-                infcx.unresolved_type_vars(&data.ty()).is_some()\n-            }\n+        .filter(|obligation| {\n+            match obligation.predicate.ignore_qualifiers(infcx.tcx).skip_binder().kind() {\n+                // We found a `T: Foo<X = U>` predicate, let's check\n+                // if `U` references any unresolved type\n+                // variables. In principle, we only care if this\n+                // projection can help resolve any of the type\n+                // variables found in `result.value` -- but we just\n+                // check for any type variables here, for fear of\n+                // indirect obligations (e.g., we project to `?0`,\n+                // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n+                // ?0>`).\n+                &ty::PredicateKind::Projection(data) => {\n+                    infcx.unresolved_type_vars(&ty::Binder::bind(data.ty)).is_some()\n+                }\n \n-            // We are only interested in `T: Foo<X = U>` predicates, whre\n-            // `U` references one of `unresolved_type_vars`. =)\n-            _ => false,\n+                // We are only interested in `T: Foo<X = U>` predicates, whre\n+                // `U` references one of `unresolved_type_vars`. =)\n+                _ => false,\n+            }\n         })\n         .cloned()\n         .collect();\n@@ -931,7 +933,11 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         debug!(\"assemble_candidates_from_predicates: predicate={:?}\", predicate);\n-        if let &ty::PredicateKind::Projection(data) = predicate.kind() {\n+        // TODO: forall\n+        if let &ty::PredicateKind::Projection(data) =\n+            predicate.ignore_qualifiers(infcx.tcx).skip_binder().kind()\n+        {\n+            let data = ty::Binder::bind(data);\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n \n             let is_match = same_def_id\n@@ -1221,13 +1227,17 @@ fn confirm_object_candidate<'cx, 'tcx>(\n \n         // select only those projections that are actually projecting an\n         // item with the correct name\n-        let env_predicates = env_predicates.filter_map(|o| match o.predicate.kind() {\n-            &ty::PredicateKind::Projection(data)\n-                if data.projection_def_id() == obligation.predicate.item_def_id =>\n-            {\n-                Some(data)\n+\n+        // TODO: forall\n+        let env_predicates = env_predicates.filter_map(|o| {\n+            match o.predicate.ignore_qualifiers(selcx.tcx()).skip_binder().kind() {\n+                &ty::PredicateKind::Projection(data)\n+                    if data.projection_ty.item_def_id == obligation.predicate.item_def_id =>\n+                {\n+                    Some(ty::Binder::bind(data))\n+                }\n+                _ => None,\n             }\n-            _ => None,\n         });\n \n         // select those with a relevant trait-ref"}, {"sha": "f2a6677e2f626c079e548a65960db6607f85174a", "filename": "src/librustc_trait_selection/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -15,10 +15,12 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         // `&T`, accounts for about 60% percentage of the predicates\n         // we have to prove. No need to canonicalize and all that for\n         // such cases.\n-        if let ty::PredicateKind::Trait(trait_ref, _) = key.value.predicate.kind() {\n+        if let ty::PredicateKind::Trait(trait_ref, _) =\n+            key.value.predicate.ignore_qualifiers(tcx).skip_binder().kind()\n+        {\n             if let Some(sized_def_id) = tcx.lang_items().sized_trait() {\n                 if trait_ref.def_id() == sized_def_id {\n-                    if trait_ref.skip_binder().self_ty().is_trivially_sized(tcx) {\n+                    if trait_ref.self_ty().is_trivially_sized(tcx) {\n                         return Some(());\n                     }\n                 }"}, {"sha": "7b654856ddeade6f9431dbd228494627e632437a", "filename": "src/librustc_trait_selection/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -181,14 +181,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         stack: &TraitObligationStack<'o, 'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n+        let tcx = self.tcx();\n         debug!(\"assemble_candidates_from_caller_bounds({:?})\", stack.obligation);\n \n         let all_bounds = stack\n             .obligation\n             .param_env\n             .caller_bounds()\n             .iter()\n-            .filter_map(|o| o.to_opt_poly_trait_ref());\n+            .filter_map(move |o| o.to_opt_poly_trait_ref(tcx));\n \n         // Micro-optimization: filter out predicates relating to different traits.\n         let matching_bounds ="}, {"sha": "fa970589bbbf60399b801884cd6ccb94db9572da", "filename": "src/librustc_trait_selection/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -532,7 +532,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligations.push(Obligation::new(\n                 obligation.cause.clone(),\n                 obligation.param_env,\n-                ty::PredicateKint::ClosureKind(closure_def_id, substs, kind)\n+                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind)\n                     .to_predicate(self.tcx()),\n             ));\n         }"}, {"sha": "5683303605511d9d50adf698a8dc2106da3af9a0", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -35,7 +35,9 @@ use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n-use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+};\n use rustc_span::symbol::sym;\n \n use std::cell::{Cell, RefCell};\n@@ -406,14 +408,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => self.check_recursion_limit(&obligation, &obligation)?,\n         }\n \n-        match obligation.predicate.kind() {\n+        // TODO: forall\n+        match obligation.predicate.ignore_qualifiers(self.tcx()).skip_binder().kind() {\n+            ty::PredicateKind::ForAll(_) => {\n+                bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n+            }\n             &ty::PredicateKind::Trait(t, _) => {\n+                let t = ty::Binder::bind(t);\n                 debug_assert!(!t.has_escaping_bound_vars());\n                 let obligation = obligation.with(t);\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n             &ty::PredicateKind::Subtype(p) => {\n+                let p = ty::Binder::bind(p);\n                 // Does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { mut obligations, .. })) => {\n@@ -456,6 +464,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             &ty::PredicateKind::Projection(data) => {\n+                let data = ty::Binder::bind(data);\n                 let project_obligation = obligation.with(data);\n                 match project::poly_project_and_unify_type(self, &project_obligation) {\n                     Ok(Some(mut subobligations)) => {\n@@ -669,10 +678,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // if the regions match exactly.\n             let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);\n             let tcx = self.tcx();\n-            let cycle = cycle.map(|stack| {\n-                ty::PredicateKind::Trait(stack.obligation.predicate, hir::Constness::NotConst)\n-                    .to_predicate(tcx)\n-            });\n+            let cycle =\n+                cycle.map(|stack| stack.obligation.predicate.without_const().to_predicate(tcx));\n             if self.coinductive_match(cycle) {\n                 debug!(\"evaluate_stack({:?}) --> recursive, coinductive\", stack.fresh_trait_ref);\n                 Some(EvaluatedToOk)\n@@ -786,7 +793,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n-        let result = match predicate.kind() {\n+        let result = match predicate.ignore_qualifiers(self.tcx()).skip_binder().kind() {\n             ty::PredicateKind::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n             _ => false,\n         };"}, {"sha": "dda2e03d77937200a46de320648072a9a0aac4ad", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -497,7 +497,7 @@ fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String>\n         Vec::with_capacity(predicates.len() + types_without_default_bounds.len());\n \n     for (p, _) in predicates {\n-        if let Some(poly_trait_ref) = p.to_opt_poly_trait_ref() {\n+        if let Some(poly_trait_ref) = p.to_opt_poly_trait_ref(tcx) {\n             if Some(poly_trait_ref.def_id()) == sized_trait {\n                 types_without_default_bounds.remove(poly_trait_ref.self_ty().skip_binder());\n                 continue;"}, {"sha": "d2fdfb45617cc44452f09d82c1768318d947a1f2", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -120,7 +120,7 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n \n         let items = predicates.predicates.iter().rev().filter_map(|(pred, span)| {\n             pred.subst_supertrait(tcx, &trait_ref)\n-                .to_opt_poly_trait_ref()\n+                .to_opt_poly_trait_ref(tcx)\n                 .map(|trait_ref| item.clone_and_push(trait_ref, *span))\n         });\n         debug!(\"expand_trait_aliases: items={:?}\", items.clone());\n@@ -170,14 +170,15 @@ impl Iterator for SupertraitDefIds<'tcx> {\n     type Item = DefId;\n \n     fn next(&mut self) -> Option<DefId> {\n+        let tcx = self.tcx;\n         let def_id = self.stack.pop()?;\n         let predicates = self.tcx.super_predicates_of(def_id);\n         let visited = &mut self.visited;\n         self.stack.extend(\n             predicates\n                 .predicates\n                 .iter()\n-                .filter_map(|(pred, _)| pred.to_opt_poly_trait_ref())\n+                .filter_map(move |(pred, _)| pred.to_opt_poly_trait_ref(tcx))\n                 .map(|trait_ref| trait_ref.def_id())\n                 .filter(|&super_def_id| visited.insert(super_def_id)),\n         );"}, {"sha": "da1a34871d025904e14e7a725caba0d1ee2f1638", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -88,33 +88,33 @@ pub fn predicate_obligations<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n-    predicate: &'tcx ty::PredicateKint<'tcx>,\n+    predicate: &'_ ty::Predicate<'tcx>,\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n \n-    match predicate {\n-        ty::PredicateKint::ForAll(binder) => {\n+    match predicate.kind() {\n+        ty::PredicateKind::ForAll(binder) => {\n             // It's ok to skip the binder here because wf code is prepared for it\n-            return predicate_obligations(infcx, param_env, body_id, *binder.skip_binder(), span);\n+            return predicate_obligations(infcx, param_env, body_id, binder.skip_binder(), span);\n         }\n-        ty::PredicateKint::Trait(t, _) => {\n+        ty::PredicateKind::Trait(t, _) => {\n             wf.compute_trait_ref(&t.trait_ref, Elaborate::None);\n         }\n-        ty::PredicateKint::RegionOutlives(..) => {}\n-        &ty::PredicateKint::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+        ty::PredicateKind::RegionOutlives(..) => {}\n+        &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n             wf.compute(ty.into());\n         }\n-        ty::PredicateKint::Projection(t) => {\n+        ty::PredicateKind::Projection(t) => {\n             wf.compute_projection(t.projection_ty);\n             wf.compute(t.ty.into());\n         }\n-        &ty::PredicateKint::WellFormed(arg) => {\n+        &ty::PredicateKind::WellFormed(arg) => {\n             wf.compute(arg);\n         }\n-        ty::PredicateKint::ObjectSafe(_) => {}\n-        ty::PredicateKint::ClosureKind(..) => {}\n-        &ty::PredicateKint::Subtype(ty::SubtypePredicate { a, b, a_is_expected: _ }) => {\n+        ty::PredicateKind::ObjectSafe(_) => {}\n+        ty::PredicateKind::ClosureKind(..) => {}\n+        &ty::PredicateKind::Subtype(ty::SubtypePredicate { a, b, a_is_expected: _ }) => {\n             wf.compute(a.into());\n             wf.compute(b.into());\n         }\n@@ -126,7 +126,7 @@ pub fn predicate_obligations<'a, 'tcx>(\n                 wf.compute(arg);\n             }\n         }\n-        &ty::PredicateKint::ConstEquate(c1, c2) => {\n+        &ty::PredicateKind::ConstEquate(c1, c2) => {\n             wf.compute(c1.into());\n             wf.compute(c2.into());\n         }\n@@ -178,7 +178,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n     trait_ref: &ty::TraitRef<'tcx>,\n     item: Option<&hir::Item<'tcx>>,\n     cause: &mut traits::ObligationCause<'tcx>,\n-    pred: &ty::Predicate<'_>,\n+    pred: &ty::Predicate<'tcx>,\n     mut trait_assoc_items: impl Iterator<Item = &'tcx ty::AssocItem>,\n ) {\n     debug!(\n@@ -194,15 +194,16 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             hir::ImplItemKind::Const(ty, _) | hir::ImplItemKind::TyAlias(ty) => ty.span,\n             _ => impl_item_ref.span,\n         };\n-    match pred.kind() {\n+\n+    // It is fine to skip the binder as we don't care about regions here.\n+    match pred.ignore_qualifiers(tcx).skip_binder().kind() {\n         ty::PredicateKind::Projection(proj) => {\n             // The obligation comes not from the current `impl` nor the `trait` being implemented,\n             // but rather from a \"second order\" obligation, where an associated type has a\n             // projection coming from another associated type. See\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs` and\n             // `traits-assoc-type-in-supertrait-bad.rs`.\n-            let kind = &proj.ty().skip_binder().kind;\n-            if let ty::Projection(projection_ty) = kind {\n+            if let ty::Projection(projection_ty) = proj.ty.kind {\n                 let trait_assoc_item = tcx.associated_item(projection_ty.item_def_id);\n                 if let Some(impl_item_span) =\n                     items.iter().find(|item| item.ident == trait_assoc_item.ident).map(fix_span)\n@@ -215,11 +216,9 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n-            if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) =\n-                &pred.skip_binder().self_ty().kind\n-            {\n+            if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) = pred.self_ty().kind {\n                 if let Some(impl_item_span) = trait_assoc_items\n-                    .find(|i| i.def_id == *item_def_id)\n+                    .find(|i| i.def_id == item_def_id)\n                     .and_then(|trait_assoc_item| {\n                         items.iter().find(|i| i.ident == trait_assoc_item.ident).map(fix_span)\n                     })\n@@ -270,7 +269,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n         let extend = |obligation: traits::PredicateObligation<'tcx>| {\n             let mut cause = cause.clone();\n-            if let Some(parent_trait_ref) = obligation.predicate.to_opt_poly_trait_ref() {\n+            if let Some(parent_trait_ref) = obligation.predicate.to_opt_poly_trait_ref(tcx) {\n                 let derived_cause = traits::DerivedObligationCause {\n                     parent_trait_ref,\n                     parent_code: Rc::new(obligation.cause.code.clone()),\n@@ -318,7 +317,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     traits::Obligation::new(\n                         new_cause,\n                         param_env,\n-                        ty::PredicateKint::WellFormed(arg).to_predicate(tcx),\n+                        ty::PredicateKind::WellFormed(arg).to_predicate(tcx),\n                     )\n                 }),\n         );\n@@ -397,7 +396,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 self.out.push(traits::Obligation::new(\n                                     cause,\n                                     self.param_env,\n-                                    ty::PredicateKint::WellFormed(resolved_constant.into())\n+                                    ty::PredicateKind::WellFormed(resolved_constant.into())\n                                         .to_predicate(self.tcx()),\n                                 ));\n                             }\n@@ -483,7 +482,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::PredicateKint::TypeOutlives(ty::OutlivesPredicate(rty, r))\n+                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(rty, r))\n                                 .to_predicate(self.tcx()),\n                         ));\n                     }"}, {"sha": "2abceb5fe2b059b2b7396cdbf4515c4cecc3dacd", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -78,10 +78,13 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n     ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n         let clauses = self.environment.into_iter().filter_map(|clause| match clause {\n             ChalkEnvironmentClause::Predicate(predicate) => {\n-                match predicate.kind() {\n-                    ty::PredicateKind::Trait(predicate, _) => {\n+                // FIXME(chalk): forall\n+                match predicate.ignore_qualifiers(interner.tcx).skip_binder().kind() {\n+                    ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", predicate),\n+                    &ty::PredicateKind::Trait(predicate, _) => {\n+                        let predicate = ty::Binder::bind(predicate);\n                         let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, predicate);\n+                            collect_bound_vars(interner, interner.tcx, &predicate);\n \n                         Some(\n                             chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n@@ -124,9 +127,10 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                     }\n                     // FIXME(chalk): need to add TypeOutlives\n                     ty::PredicateKind::TypeOutlives(_) => None,\n-                    ty::PredicateKind::Projection(predicate) => {\n+                    &ty::PredicateKind::Projection(predicate) => {\n+                        let predicate = ty::Binder::bind(predicate);\n                         let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, predicate);\n+                            collect_bound_vars(interner, interner.tcx, &predicate);\n \n                         Some(\n                             chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n@@ -181,8 +185,12 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        match self.kind() {\n-            ty::PredicateKind::Trait(predicate, _) => predicate.lower_into(interner),\n+        // FIXME(chalk): forall\n+        match self.ignore_qualifiers(interner.tcx).skip_binder().kind() {\n+            ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", self),\n+            &ty::PredicateKind::Trait(predicate, _) => {\n+                ty::Binder::bind(predicate).lower_into(interner)\n+            }\n             ty::PredicateKind::RegionOutlives(predicate) => {\n                 let (predicate, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, predicate);\n@@ -205,7 +213,9 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             ty::PredicateKind::TypeOutlives(_predicate) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n-            ty::PredicateKind::Projection(predicate) => predicate.lower_into(interner),\n+            &ty::PredicateKind::Projection(predicate) => {\n+                ty::Binder::bind(predicate).lower_into(interner)\n+            }\n             ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n                 GenericArgKind::Type(ty) => match ty.kind {\n                     // FIXME(chalk): In Chalk, a placeholder is WellFormed if it\n@@ -532,8 +542,11 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        match &self.kind() {\n-            ty::PredicateKind::Trait(predicate, _) => {\n+        // FIXME(chalk): forall\n+        match self.ignore_qualifiers(interner.tcx).skip_binder().kind() {\n+            ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", self),\n+            &ty::PredicateKind::Trait(predicate, _) => {\n+                let predicate = &ty::Binder::bind(predicate);\n                 let (predicate, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, predicate);\n \n@@ -632,7 +645,9 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n     }\n \n     (0..parameters.len()).for_each(|i| {\n-        parameters.get(&(i as u32)).expect(&format!(\"Skipped bound var index `{:?}`.\", i));\n+        parameters\n+            .get(&(i as u32))\n+            .or_else(|| bug!(\"Skipped bound var index: ty={:?}, parameters={:?}\", ty, parameters));\n     });\n \n     let binders = chalk_ir::VariableKinds::from(interner, parameters.into_iter().map(|(_, v)| v));"}, {"sha": "26a44bb5c2f1b8abd1326b8449018e736190212a", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -95,35 +95,29 @@ fn compute_implied_outlives_bounds<'tcx>(\n         implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n             assert!(!obligation.has_escaping_bound_vars());\n             match obligation.predicate.kind() {\n+                ty::PredicateKind::ForAll(..) => vec![],\n                 ty::PredicateKind::Trait(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Projection(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..) => vec![],\n-\n                 &ty::PredicateKind::WellFormed(arg) => {\n                     wf_args.push(arg);\n                     vec![]\n                 }\n \n-                ty::PredicateKind::RegionOutlives(ref data) => match data.no_bound_vars() {\n-                    None => vec![],\n-                    Some(ty::OutlivesPredicate(r_a, r_b)) => {\n-                        vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n-                    }\n-                },\n+                &ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n+                    vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n+                }\n \n-                ty::PredicateKind::TypeOutlives(ref data) => match data.no_bound_vars() {\n-                    None => vec![],\n-                    Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                        let ty_a = infcx.resolve_vars_if_possible(&ty_a);\n-                        let mut components = smallvec![];\n-                        tcx.push_outlives_components(ty_a, &mut components);\n-                        implied_bounds_from_components(r_b, components)\n-                    }\n-                },\n+                &ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                    let ty_a = infcx.resolve_vars_if_possible(&ty_a);\n+                    let mut components = smallvec![];\n+                    tcx.push_outlives_components(ty_a, &mut components);\n+                    implied_bounds_from_components(r_b, components)\n+                }\n             }\n         }));\n     }"}, {"sha": "06a90d145115d79b09e3ed745ef3579b7ce3f9aa", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -27,7 +27,9 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n                 // always only region relations, and we are about to\n                 // erase those anyway:\n                 debug_assert_eq!(\n-                    normalized_obligations.iter().find(|p| not_outlives_predicate(&p.predicate)),\n+                    normalized_obligations\n+                        .iter()\n+                        .find(|p| not_outlives_predicate(tcx, &p.predicate)),\n                     None,\n                 );\n \n@@ -39,9 +41,11 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n     })\n }\n \n-fn not_outlives_predicate(p: &ty::Predicate<'_>) -> bool {\n-    match p.kind() {\n+fn not_outlives_predicate(tcx: TyCtxt<'tcx>, p: &ty::Predicate<'tcx>) -> bool {\n+    // TODO: forall\n+    match p.ignore_qualifiers(tcx).skip_binder().kind() {\n         ty::PredicateKind::RegionOutlives(..) | ty::PredicateKind::TypeOutlives(..) => false,\n+        ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", p),\n         ty::PredicateKind::Trait(..)\n         | ty::PredicateKind::Projection(..)\n         | ty::PredicateKind::WellFormed(..)"}, {"sha": "9cc9a35b38b8adfb5b9293cb89f147cdb8197214", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -140,7 +140,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n             self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n \n             self.prove_predicate(\n-                ty::PredicateKint::WellFormed(impl_self_ty.into()).to_predicate(self.tcx()),\n+                ty::PredicateKind::WellFormed(impl_self_ty.into()).to_predicate(self.tcx()),\n             );\n         }\n \n@@ -155,7 +155,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         // them?  This would only be relevant if some input\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n-        self.prove_predicate(ty::PredicateKint::WellFormed(ty.into()).to_predicate(self.tcx()));\n+        self.prove_predicate(ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()));\n         Ok(())\n     }\n }"}, {"sha": "ef7726e7705b4b18365e283065b5003bdf4e2c98", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -1705,8 +1705,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     \"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\",\n                     obligation.predicate\n                 );\n-                match obligation.predicate.kind() {\n-                    ty::PredicateKind::Trait(pred, _) => {\n+\n+                // TODO: forall\n+                match obligation.predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+                    &ty::PredicateKind::Trait(pred, _) => {\n+                        let pred = ty::Binder::bind(pred);\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n                                 .in_definition_order()\n@@ -1715,6 +1718,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         );\n                     }\n                     &ty::PredicateKind::Projection(pred) => {\n+                        let pred = ty::Binder::bind(pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n                         let references_self =\n@@ -2094,7 +2098,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             || {\n                 traits::transitive_bounds(\n                     tcx,\n-                    predicates.iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref()),\n+                    predicates.iter().filter_map(move |(p, _)| p.to_opt_poly_trait_ref(tcx)),\n                 )\n             },\n             || param_name.to_string(),"}, {"sha": "9d88a35901e4a95f1674cfa1f2a8a093829014e6", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -206,11 +206,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n-                if let &ty::PredicateKind::Projection(proj_predicate) = obligation.predicate.kind()\n+                if let &ty::PredicateKind::Projection(proj_predicate) =\n+                    obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind()\n                 {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n-                    self.deduce_sig_from_projection(Some(obligation.cause.span), proj_predicate)\n+                    self.deduce_sig_from_projection(\n+                        Some(obligation.cause.span),\n+                        ty::Binder::bind(proj_predicate),\n+                    )\n                 } else {\n                     None\n                 }\n@@ -627,8 +631,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n         let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            if let &ty::PredicateKind::Projection(proj_predicate) = obligation.predicate.kind() {\n-                self.deduce_future_output_from_projection(obligation.cause.span, proj_predicate)\n+            if let &ty::PredicateKind::Projection(proj_predicate) =\n+                obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind()\n+            {\n+                self.deduce_future_output_from_projection(\n+                    obligation.cause.span,\n+                    ty::Binder::bind(proj_predicate),\n+                )\n             } else {\n                 None\n             }"}, {"sha": "6b3d986e7b1b588718d046bd95700c7658772cf6", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -582,24 +582,25 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_pred = match obligation.predicate.kind() {\n-                &ty::PredicateKind::Trait(trait_pred, _)\n-                    if traits.contains(&trait_pred.def_id()) =>\n-                {\n-                    if unsize_did == trait_pred.def_id() {\n-                        let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n-                        if let ty::Tuple(..) = unsize_ty.kind {\n-                            debug!(\"coerce_unsized: found unsized tuple coercion\");\n-                            has_unsized_tuple_coercion = true;\n+            let trait_pred =\n+                match obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+                    &ty::PredicateKind::Trait(trait_pred, _)\n+                        if traits.contains(&trait_pred.def_id()) =>\n+                    {\n+                        if unsize_did == trait_pred.def_id() {\n+                            let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();\n+                            if let ty::Tuple(..) = unsize_ty.kind {\n+                                debug!(\"coerce_unsized: found unsized tuple coercion\");\n+                                has_unsized_tuple_coercion = true;\n+                            }\n                         }\n+                        ty::Binder::bind(trait_pred)\n                     }\n-                    trait_pred\n-                }\n-                _ => {\n-                    coercion.obligations.push(obligation);\n-                    continue;\n-                }\n-            };\n+                    _ => {\n+                        coercion.obligations.push(obligation);\n+                        continue;\n+                    }\n+                };\n             match selcx.select(&obligation.with(trait_pred)) {\n                 // Uncertain or unimplemented.\n                 Ok(None) => {"}, {"sha": "ae288ef6af781bf8ff3c094cf5e067d1ac1501a7", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -127,7 +127,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         // it did the wrong thing, so I chose to preserve existing\n         // behavior, since it ought to be simply more\n         // conservative. -nmatsakis\n-        let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n+        let outlives_env = OutlivesEnvironment::new(infcx.tcx, ty::ParamEnv::empty());\n \n         infcx.resolve_regions_and_report_errors(\n             drop_impl_did.to_def_id(),\n@@ -226,12 +226,15 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // could be extended easily also to the other `Predicate`.\n         let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            match (predicate.kind(), p.kind()) {\n+            match (\n+                predicate.ignore_qualifiers(tcx).skip_binder().kind(),\n+                p.ignore_qualifiers(tcx).skip_binder().kind(),\n+            ) {\n                 (&ty::PredicateKind::Trait(a, _), &ty::PredicateKind::Trait(b, _)) => {\n-                    relator.relate(a, b).is_ok()\n+                    relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n                 }\n                 (&ty::PredicateKind::Projection(a), &ty::PredicateKind::Projection(b)) => {\n-                    relator.relate(a, b).is_ok()\n+                    relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n                 }\n                 _ => predicate == p,\n             }"}, {"sha": "a9f663fff48a570fa5211eea730e3d9ab2d44a97", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -447,21 +447,27 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         };\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n-            .filter_map(|obligation| match obligation.predicate.kind() {\n-                ty::PredicateKind::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n-                    let span = predicates\n-                        .predicates\n-                        .iter()\n-                        .zip(predicates.spans.iter())\n-                        .find_map(\n-                            |(p, span)| if *p == obligation.predicate { Some(*span) } else { None },\n-                        )\n-                        .unwrap_or(rustc_span::DUMMY_SP);\n-                    Some((trait_pred, span))\n+            // We don't care about regions here.\n+            .filter_map(|obligation| {\n+                match obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+                    ty::PredicateKind::Trait(trait_pred, _)\n+                        if trait_pred.def_id() == sized_def_id =>\n+                    {\n+                        let span =\n+                            predicates\n+                                .predicates\n+                                .iter()\n+                                .zip(predicates.spans.iter())\n+                                .find_map(|(p, span)| {\n+                                    if *p == obligation.predicate { Some(*span) } else { None }\n+                                })\n+                                .unwrap_or(rustc_span::DUMMY_SP);\n+                        Some((trait_pred, span))\n+                    }\n+                    _ => None,\n                 }\n-                _ => None,\n             })\n-            .find_map(|(trait_pred, span)| match trait_pred.skip_binder().self_ty().kind {\n+            .find_map(|(trait_pred, span)| match trait_pred.self_ty().kind {\n                 ty::Dynamic(..) => Some(span),\n                 _ => None,\n             })"}, {"sha": "64dce3e1738e38115fd37a66536d3acc37a24fdc", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         obligations.push(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKint::WellFormed(method_ty.into()).to_predicate(tcx),\n+            ty::PredicateKind::WellFormed(method_ty.into()).to_predicate(tcx),\n         ));\n \n         let callee = MethodCallee { def_id, substs: trait_ref.substs, sig: fn_sig };"}, {"sha": "90ebce8dc1887251f240fa4c21169c03346fae2f", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -795,6 +795,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_param(&mut self, param_ty: ty::ParamTy) {\n+        let tcx = self.tcx;\n         // FIXME: do we want to commit to this behavior for param bounds?\n         debug!(\"assemble_inherent_candidates_from_param(param_ty={:?})\", param_ty);\n "}, {"sha": "34abbb9cef11126c5d391391d20df2494df6b3bc", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -570,12 +570,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     };\n                     let mut type_params = FxHashMap::default();\n                     let mut bound_spans = vec![];\n-                    let mut collect_type_param_suggestions =\n-                        |self_ty: Ty<'_>, parent_pred: &ty::Predicate<'_>, obligation: &str| {\n-                            if let (ty::Param(_), ty::PredicateKind::Trait(p, _)) =\n-                                (&self_ty.kind, parent_pred.kind())\n-                            {\n-                                if let ty::Adt(def, _) = p.skip_binder().trait_ref.self_ty().kind {\n+\n+                    let mut collect_type_param_suggestions = {\n+                        // We need to move `tcx` while only borrowing the rest,\n+                        // this is kind of ugly.\n+                        |self_ty: Ty<'tcx>, parent_pred: &ty::Predicate<'tcx>, obligation: &str| {\n+                            // We don't care about regions here, so it's fine to skip the binder here.\n+                            if let (ty::Param(_), ty::PredicateKind::Trait(p, _)) = (\n+                                &self_ty.kind,\n+                                parent_pred.ignore_qualifiers(tcx).skip_binder().kind(),\n+                            ) {\n+                                if let ty::Adt(def, _) = p.trait_ref.self_ty().kind {\n                                     let node = def.did.as_local().map(|def_id| {\n                                         self.tcx.hir().get(self.tcx.hir().as_local_hir_id(def_id))\n                                     });\n@@ -597,7 +602,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     }\n                                 }\n                             }\n-                        };\n+                        }\n+                    };\n                     let mut bound_span_label = |self_ty: Ty<'_>, obligation: &str, quiet: &str| {\n                         let msg = format!(\n                             \"doesn't satisfy `{}`\",\n@@ -625,8 +631,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     };\n                     let mut format_pred = |pred: ty::Predicate<'tcx>| {\n-                        match pred.kind() {\n-                            ty::PredicateKind::Projection(pred) => {\n+                        // TODO: forall\n+                        match pred.ignore_qualifiers(tcx).skip_binder().kind() {\n+                            &ty::PredicateKind::Projection(pred) => {\n+                                let pred = ty::Binder::bind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let trait_ref =\n                                     pred.skip_binder().projection_ty.trait_ref(self.tcx);\n@@ -644,7 +652,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 bound_span_label(trait_ref.self_ty(), &obligation, &quiet);\n                                 Some((obligation, trait_ref.self_ty()))\n                             }\n-                            ty::PredicateKind::Trait(poly_trait_ref, _) => {\n+                            &ty::PredicateKind::Trait(poly_trait_ref, _) => {\n+                                let poly_trait_ref = ty::Binder::bind(poly_trait_ref);\n                                 let p = poly_trait_ref.skip_binder().trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n@@ -950,12 +959,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n-                unsatisfied_predicates.iter().all(|(p, _)| match p.kind() {\n-                    // Hide traits if they are present in predicates as they can be fixed without\n-                    // having to implement them.\n-                    ty::PredicateKind::Trait(t, _) => t.def_id() == info.def_id,\n-                    ty::PredicateKind::Projection(p) => p.item_def_id() == info.def_id,\n-                    _ => false,\n+                unsatisfied_predicates.iter().all(|(p, _)| {\n+                    match p.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+                        // Hide traits if they are present in predicates as they can be fixed without\n+                        // having to implement them.\n+                        ty::PredicateKind::Trait(t, _) => t.def_id() == info.def_id,\n+                        ty::PredicateKind::Projection(p) => {\n+                            p.projection_ty.item_def_id == info.def_id\n+                        }\n+                        _ => false,\n+                    }\n                 }) && (type_is_local || info.def_id.is_local())\n                     && self\n                         .associated_item(info.def_id, item_name, Namespace::ValueNS)"}, {"sha": "a98a7198435a3e5cbc9c78593ef761ba3f2e7a26", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 63, "deletions": 49, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -2392,26 +2392,28 @@ fn missing_items_err(\n }\n \n /// Resugar `ty::GenericPredicates` in a way suitable to be used in structured suggestions.\n-fn bounds_from_generic_predicates(\n-    tcx: TyCtxt<'_>,\n-    predicates: ty::GenericPredicates<'_>,\n+fn bounds_from_generic_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicates: ty::GenericPredicates<'tcx>,\n ) -> (String, String) {\n-    let mut types: FxHashMap<Ty<'_>, Vec<DefId>> = FxHashMap::default();\n+    let mut types: FxHashMap<Ty<'tcx>, Vec<DefId>> = FxHashMap::default();\n     let mut projections = vec![];\n     for (predicate, _) in predicates.predicates {\n         debug!(\"predicate {:?}\", predicate);\n-        match predicate.kind() {\n+        // TODO: forall (we could keep the current behavior and just skip binders eagerly,\n+        // not sure if we want to though)\n+        match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n             ty::PredicateKind::Trait(trait_predicate, _) => {\n-                let entry = types.entry(trait_predicate.skip_binder().self_ty()).or_default();\n-                let def_id = trait_predicate.skip_binder().def_id();\n+                let entry = types.entry(trait_predicate.self_ty()).or_default();\n+                let def_id = trait_predicate.def_id();\n                 if Some(def_id) != tcx.lang_items().sized_trait() {\n                     // Type params are `Sized` by default, do not add that restriction to the list\n                     // if it is a positive requirement.\n-                    entry.push(trait_predicate.skip_binder().def_id());\n+                    entry.push(trait_predicate.def_id());\n                 }\n             }\n             ty::PredicateKind::Projection(projection_pred) => {\n-                projections.push(projection_pred);\n+                projections.push(ty::Binder::bind(projection_pred));\n             }\n             _ => {}\n         }\n@@ -2456,11 +2458,11 @@ fn bounds_from_generic_predicates(\n }\n \n /// Return placeholder code for the given function.\n-fn fn_sig_suggestion(\n-    tcx: TyCtxt<'_>,\n-    sig: ty::FnSig<'_>,\n+fn fn_sig_suggestion<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sig: ty::FnSig<'tcx>,\n     ident: Ident,\n-    predicates: ty::GenericPredicates<'_>,\n+    predicates: ty::GenericPredicates<'tcx>,\n     assoc: &ty::AssocItem,\n ) -> String {\n     let args = sig\n@@ -3612,7 +3614,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.register_predicate(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKint::WellFormed(arg).to_predicate(self.tcx),\n+            ty::PredicateKind::WellFormed(arg).to_predicate(self.tcx),\n         ));\n     }\n \n@@ -3893,29 +3895,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .borrow()\n             .pending_obligations()\n             .into_iter()\n-            .filter_map(move |obligation| match obligation.predicate.kind() {\n-                ty::PredicateKind::Projection(ref data) => {\n-                    Some((data.to_poly_trait_ref(self.tcx), obligation))\n-                }\n-                ty::PredicateKind::Trait(ref data, _) => {\n-                    Some((data.to_poly_trait_ref(), obligation))\n+            // TODO: forall\n+            .filter_map(move |obligation| {\n+                match obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind() {\n+                    ty::PredicateKind::ForAll(_) => {\n+                        bug!(\"unexpected predicate: {:?}\", obligation.predicate)\n+                    }\n+                    &ty::PredicateKind::Projection(data) => {\n+                        Some((ty::Binder::bind(data).to_poly_trait_ref(self.tcx), obligation))\n+                    }\n+                    &ty::PredicateKind::Trait(data, _) => {\n+                        Some((ty::Binder::bind(data).to_poly_trait_ref(), obligation))\n+                    }\n+                    ty::PredicateKind::Subtype(..) => None,\n+                    ty::PredicateKind::RegionOutlives(..) => None,\n+                    ty::PredicateKind::TypeOutlives(..) => None,\n+                    ty::PredicateKind::WellFormed(..) => None,\n+                    ty::PredicateKind::ObjectSafe(..) => None,\n+                    ty::PredicateKind::ConstEvaluatable(..) => None,\n+                    ty::PredicateKind::ConstEquate(..) => None,\n+                    // N.B., this predicate is created by breaking down a\n+                    // `ClosureType: FnFoo()` predicate, where\n+                    // `ClosureType` represents some `Closure`. It can't\n+                    // possibly be referring to the current closure,\n+                    // because we haven't produced the `Closure` for\n+                    // this closure yet; this is exactly why the other\n+                    // code is looking for a self type of a unresolved\n+                    // inference variable.\n+                    ty::PredicateKind::ClosureKind(..) => None,\n                 }\n-                ty::PredicateKind::Subtype(..) => None,\n-                ty::PredicateKind::RegionOutlives(..) => None,\n-                ty::PredicateKind::TypeOutlives(..) => None,\n-                ty::PredicateKind::WellFormed(..) => None,\n-                ty::PredicateKind::ObjectSafe(..) => None,\n-                ty::PredicateKind::ConstEvaluatable(..) => None,\n-                ty::PredicateKind::ConstEquate(..) => None,\n-                // N.B., this predicate is created by breaking down a\n-                // `ClosureType: FnFoo()` predicate, where\n-                // `ClosureType` represents some `Closure`. It can't\n-                // possibly be referring to the current closure,\n-                // because we haven't produced the `Closure` for\n-                // this closure yet; this is exactly why the other\n-                // code is looking for a self type of a unresolved\n-                // inference variable.\n-                ty::PredicateKind::ClosureKind(..) => None,\n             })\n             .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n     }\n@@ -4225,7 +4233,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// the corresponding argument's expression span instead of the `fn` call path span.\n     fn point_at_arg_instead_of_call_if_possible(\n         &self,\n-        errors: &mut Vec<traits::FulfillmentError<'_>>,\n+        errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n         final_arg_types: &[(usize, Ty<'tcx>, Ty<'tcx>)],\n         call_sp: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n@@ -4244,7 +4252,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 continue;\n             }\n \n-            if let ty::PredicateKind::Trait(predicate, _) = error.obligation.predicate.kind() {\n+            if let ty::PredicateKind::Trait(predicate, _) =\n+                error.obligation.predicate.ignore_qualifiers(self.tcx).skip_binder().kind()\n+            {\n                 // Collect the argument position for all arguments that could have caused this\n                 // `FulfillmentError`.\n                 let mut referenced_in = final_arg_types\n@@ -4255,7 +4265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let ty = self.resolve_vars_if_possible(&ty);\n                         // We walk the argument type because the argument's type could have\n                         // been `Option<T>`, but the `FulfillmentError` references `T`.\n-                        if ty.walk().any(|arg| arg == predicate.skip_binder().self_ty().into()) {\n+                        if ty.walk().any(|arg| arg == predicate.self_ty().into()) {\n                             Some(i)\n                         } else {\n                             None\n@@ -4284,15 +4294,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// instead of the `fn` call path span.\n     fn point_at_type_arg_instead_of_call_if_possible(\n         &self,\n-        errors: &mut Vec<traits::FulfillmentError<'_>>,\n+        errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n         call_expr: &'tcx hir::Expr<'tcx>,\n     ) {\n         if let hir::ExprKind::Call(path, _) = &call_expr.kind {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n-                        if let ty::PredicateKind::Trait(predicate, _) =\n-                            error.obligation.predicate.kind()\n+                        if let ty::PredicateKind::Trait(predicate, _) = error\n+                            .obligation\n+                            .predicate\n+                            .ignore_qualifiers(self.tcx)\n+                            .skip_binder()\n+                            .kind()\n                         {\n                             // If any of the type arguments in this path segment caused the\n                             // `FullfillmentError`, point at its span (#61860).\n@@ -4313,7 +4327,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     } else {\n                                         let ty = AstConv::ast_ty_to_ty(self, hir_ty);\n                                         let ty = self.resolve_vars_if_possible(&ty);\n-                                        if ty == predicate.skip_binder().self_ty() {\n+                                        if ty == predicate.self_ty() {\n                                             error.obligation.cause.make_mut().span = hir_ty.span;\n                                         }\n                                     }\n@@ -5365,12 +5379,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     item_def_id,\n                 };\n \n-                let predicate =\n-                    ty::PredicateKind::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n-                        projection_ty,\n-                        ty: expected,\n-                    }))\n-                    .to_predicate(self.tcx);\n+                let predicate = ty::PredicateKind::Projection(ty::ProjectionPredicate {\n+                    projection_ty,\n+                    ty: expected,\n+                })\n+                .to_predicate(self.tcx)\n+                .potentially_qualified(self.tcx, ty::PredicateKind::ForAll);\n                 let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n \n                 debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);"}, {"sha": "71187244601e8bfcca740fceb9ca8619cc49c535", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> RegionCtxt<'a, 'tcx> {\n         let region_scope_tree = fcx.tcx.region_scope_tree(subject);\n-        let outlives_environment = OutlivesEnvironment::new(param_env);\n+        let outlives_environment = OutlivesEnvironment::new(fcx.tcx, param_env);\n         RegionCtxt {\n             fcx,\n             region_scope_tree,"}, {"sha": "80f03e2211a08f02451debffb3236815fe3d379d", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -828,8 +828,8 @@ fn check_where_clauses<'tcx, 'fcx>(\n     debug!(\"check_where_clauses: predicates={:?}\", predicates.predicates);\n     assert_eq!(predicates.predicates.len(), predicates.spans.len());\n     let wf_obligations =\n-        predicates.predicates.iter().zip(predicates.spans.iter()).flat_map(|(&p, &sp)| {\n-            traits::wf::predicate_obligations(fcx, fcx.param_env, fcx.body_id, p.kint(tcx), sp)\n+        predicates.predicates.iter().zip(predicates.spans.iter()).flat_map(|(p, &sp)| {\n+            traits::wf::predicate_obligations(fcx, fcx.param_env, fcx.body_id, p, sp)\n         });\n \n     for obligation in wf_obligations.chain(default_obligations) {"}, {"sha": "d40abf1f54edb62a478ac812cd8ca8f181f6c34d", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -292,7 +292,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                     }\n \n                     // Finally, resolve all regions.\n-                    let outlives_env = OutlivesEnvironment::new(param_env);\n+                    let outlives_env = OutlivesEnvironment::new(tcx, param_env);\n                     infcx.resolve_regions_and_report_errors(\n                         impl_did.to_def_id(),\n                         &outlives_env,\n@@ -549,7 +549,7 @@ pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedI\n         }\n \n         // Finally, resolve all regions.\n-        let outlives_env = OutlivesEnvironment::new(param_env);\n+        let outlives_env = OutlivesEnvironment::new(tcx, param_env);\n         infcx.resolve_regions_and_report_errors(impl_did, &outlives_env, RegionckMode::default());\n \n         CoerceUnsizedInfo { custom_kind: kind }"}, {"sha": "23cf639f3c8cf434c9639caf660cd2cfa04e49b1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -552,10 +552,8 @@ fn type_param_predicates(\n     let extra_predicates = extend.into_iter().chain(\n         icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n             .into_iter()\n-            .filter(|(predicate, _)| match predicate.kind() {\n-                ty::PredicateKind::Trait(ref data, _) => {\n-                    data.skip_binder().self_ty().is_param(index)\n-                }\n+            .filter(|(predicate, _)| match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+                ty::PredicateKind::Trait(data, _) => data.self_ty().is_param(index),\n                 _ => false,\n             }),\n     );\n@@ -1006,7 +1004,8 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n     // which will, in turn, reach indirect supertraits.\n     for &(pred, span) in superbounds {\n         debug!(\"superbound: {:?}\", pred);\n-        if let ty::PredicateKind::Trait(bound, _) = pred.kind() {\n+        if let ty::PredicateKind::Trait(bound, _) = pred.ignore_qualifiers(tcx).skip_binder().kind()\n+        {\n             tcx.at(span).super_predicates_of(bound.def_id());\n         }\n     }\n@@ -1961,9 +1960,10 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n-                            let pred = ty::Binder::bind(ty::OutlivesPredicate(ty, region));\n                             predicates.push((\n-                                ty::PredicateKind::TypeOutlives(pred).to_predicate(tcx),\n+                                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, region))\n+                                    .to_predicate(tcx)\n+                                    .potentially_qualified(tcx, ty::PredicateKind::ForAll),\n                                 lifetime.span,\n                             ))\n                         }\n@@ -1980,9 +1980,10 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         }\n                         _ => bug!(),\n                     };\n-                    let pred = ty::Binder::bind(ty::OutlivesPredicate(r1, r2));\n+                    let pred = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n+                        .to_predicate(icx.tcx);\n \n-                    (ty::PredicateKind::RegionOutlives(pred).to_predicate(icx.tcx), span)\n+                    (pred.potentially_qualified(icx.tcx, ty::PredicateKind::ForAll), span)\n                 }))\n             }\n \n@@ -2110,8 +2111,10 @@ fn predicates_from_bound<'tcx>(\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n-            let pred = ty::Binder::bind(ty::OutlivesPredicate(param_ty, region));\n-            vec![(ty::PredicateKind::TypeOutlives(pred).to_predicate(astconv.tcx()), lifetime.span)]\n+            let pred = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(param_ty, region))\n+                .to_predicate(astconv.tcx())\n+                .potentially_qualified(astconv.tcx(), ty::PredicateKind::ForAll);\n+            vec![(pred, lifetime.span)]\n         }\n     }\n }"}, {"sha": "8d469d0e4298863a7f6e4c2adcded5f89ebe9f3f", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -180,11 +180,11 @@ pub fn setup_constraining_predicates<'tcx>(\n         changed = false;\n \n         for j in i..predicates.len() {\n-            if let ty::PredicateKind::Projection(ref poly_projection) = predicates[j].0.kind() {\n-                // Note that we can skip binder here because the impl\n-                // trait ref never contains any late-bound regions.\n-                let projection = poly_projection.skip_binder();\n-\n+            // Note that we don't have to care about binders here,\n+            // as the impl trait ref never contains any late-bound regions.\n+            if let ty::PredicateKind::Projection(projection) =\n+                predicates[j].0.ignore_qualifiers(tcx).skip_binder().kind()\n+            {\n                 // Special case: watch out for some kind of sneaky attempt\n                 // to project out an associated type defined by this very\n                 // trait."}, {"sha": "c1c8e73358bca4f819539fdbcd9cf926a6f71ea7", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -163,7 +163,7 @@ fn get_impl_substs<'tcx>(\n     let impl2_substs = translate_substs(infcx, param_env, impl1_def_id, impl1_substs, impl2_node);\n \n     // Conservatively use an empty `ParamEnv`.\n-    let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n+    let outlives_env = OutlivesEnvironment::new(tcx, ty::ParamEnv::empty());\n     infcx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env, RegionckMode::default());\n     let impl2_substs = match infcx.fully_resolve(&impl2_substs) {\n         Ok(s) => s,\n@@ -198,9 +198,11 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     // the functions in `cgp` add the constrained parameters to a list of\n     // unconstrained parameters.\n     for (predicate, _) in impl_generic_predicates.predicates.iter() {\n-        if let ty::PredicateKind::Projection(proj) = predicate.kind() {\n-            let projection_ty = proj.skip_binder().projection_ty;\n-            let projected_ty = proj.skip_binder().ty;\n+        if let ty::PredicateKind::Projection(proj) =\n+            predicate.ignore_qualifiers(tcx).skip_binder().kind()\n+        {\n+            let projection_ty = proj.projection_ty;\n+            let projected_ty = proj.ty;\n \n             let unbound_trait_ref = projection_ty.trait_ref(tcx);\n             if Some(unbound_trait_ref) == impl_trait_ref {\n@@ -359,7 +361,7 @@ fn check_predicates<'tcx>(\n \n fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tcx>, span: Span) {\n     debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n-    match predicate.kind() {\n+    match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n         _ if predicate.is_global() => (),\n@@ -392,7 +394,8 @@ fn trait_predicate_kind<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicate: ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n-    match predicate.kind() {\n+    match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+        ty::PredicateKind::ForAll(_) => bug!(\"unexpected predicate: {:?}\", predicate),\n         ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n             Some(tcx.trait_def(pred.def_id()).specialization_kind)\n         }"}, {"sha": "1e946c73c5040887d8d2f072e8600f21d5ccf7f7", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -29,9 +29,12 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n             for &(predicate, span) in predicates.predicates {\n-                match predicate.kind() {\n+                // TODO: forall\n+                match predicate.ignore_qualifiers(tcx).skip_binder().kind() {\n+                    ty::PredicateKind::ForAll(_) => bug!(\"unepected predicate: {:?}\", predicate),\n+\n                     ty::PredicateKind::TypeOutlives(predicate) => {\n-                        let OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();\n+                        let OutlivesPredicate(ref ty, ref reg) = predicate;\n                         insert_outlives_predicate(\n                             tcx,\n                             (*ty).into(),\n@@ -42,7 +45,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     }\n \n                     ty::PredicateKind::RegionOutlives(predicate) => {\n-                        let OutlivesPredicate(ref reg1, ref reg2) = predicate.skip_binder();\n+                        let OutlivesPredicate(ref reg1, ref reg2) = predicate;\n                         insert_outlives_predicate(\n                             tcx,\n                             (*reg1).into(),"}, {"sha": "d450a27941ff95411e1a9bd1614afa37fc86b07f", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -85,17 +85,17 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CratePredica\n                 |(ty::OutlivesPredicate(kind1, region2), &span)| {\n                     match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => Some((\n-                            ty::PredicateKind::TypeOutlives(ty::Binder::bind(\n-                                ty::OutlivesPredicate(ty1, region2),\n-                            ))\n-                            .to_predicate(tcx),\n+                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty1, region2))\n+                                .to_predicate(tcx)\n+                                .potentially_qualified(tcx, ty::PredicateKind::ForAll),\n                             span,\n                         )),\n                         GenericArgKind::Lifetime(region1) => Some((\n-                            ty::PredicateKind::RegionOutlives(ty::Binder::bind(\n-                                ty::OutlivesPredicate(region1, region2),\n+                            ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n+                                region1, region2,\n                             ))\n-                            .to_predicate(tcx),\n+                            .to_predicate(tcx)\n+                            .potentially_qualified(tcx, ty::PredicateKind::ForAll),\n                             span,\n                         )),\n                         GenericArgKind::Const(_) => {"}, {"sha": "ddd27d42df45eb68cd423a11fb6ac12eb7f6fab9", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -465,7 +465,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .iter()\n             .filter(|p| {\n                 !orig_bounds.contains(p)\n-                    || match p.kind() {\n+                    || match p.ignore_qualifiers().skip_binder().kind() {\n                         ty::PredicateKind::Trait(pred, _) => pred.def_id() == sized_trait,\n                         _ => false,\n                     }"}, {"sha": "1361117f6c4dab093bfe7dc3bd35b30c70d3c7b8", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9852b42b581bbc4843460f4654a2dbd859bd9034/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr?ref=9852b42b581bbc4843460f4654a2dbd859bd9034", "patch": "@@ -1,4 +1,4 @@\n-error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id[0]::This[0]) }, (I,)))`\n+error: cannot specialize on `ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id[0]::This[0]) }, (I,))`\n   --> $DIR/repeated_projection_type.rs:19:1\n    |\n LL | / impl<I, V: Id<This = (I,)>> X for V {"}]}