{"sha": "333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "node_id": "C_kwDOAAsO6NoAKDMzM2I5MmM1ZWQ3YzRhNjg0OWJjZjcyZDBiMDI2ZGU2NGZkZThkZjk", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-09-08T00:52:51Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-17T02:45:59Z"}, "message": "Box `ExprKind::{Closure,MethodCall}`, and `QSelf` in expressions, types, and patterns.", "tree": {"sha": "0b2f905f9283db3c2f997e7251264b52ace7e318", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b2f905f9283db3c2f997e7251264b52ace7e318"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "html_url": "https://github.com/rust-lang/rust/commit/333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbd6159095dd4f5e96671e9230420a46c6302dd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbd6159095dd4f5e96671e9230420a46c6302dd3", "html_url": "https://github.com/rust-lang/rust/commit/cbd6159095dd4f5e96671e9230420a46c6302dd3"}], "stats": {"total": 78, "additions": 50, "deletions": 28}, "files": [{"sha": "29425b2e5541791db6c485d904a38981abda173b", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "patch": "@@ -61,10 +61,10 @@ impl EarlyLintPass for DoubleParens {\n                     }\n                 }\n             },\n-            ExprKind::MethodCall(_, _, ref params, _) => {\n-                if let [ref param] = params[..] {\n-                    if let ExprKind::Paren(_) = param.kind {\n-                        span_lint(cx, DOUBLE_PARENS, param.span, msg);\n+            ExprKind::MethodCall(ref call) => {\n+                if let [ref arg] = call.args[..] {\n+                    if let ExprKind::Paren(_) = arg.kind {\n+                        span_lint(cx, DOUBLE_PARENS, arg.span, msg);\n                     }\n                 }\n             },"}, {"sha": "377bddeaa5feabccaa30f4a6e759baf33b152741", "filename": "clippy_lints/src/option_env_unwrap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Foption_env_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Foption_env_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_env_unwrap.rs?ref=333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::is_direct_expn_of;\n use if_chain::if_chain;\n-use rustc_ast::ast::{Expr, ExprKind};\n+use rustc_ast::ast::{Expr, ExprKind, MethodCall};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -37,8 +37,8 @@ declare_lint_pass!(OptionEnvUnwrap => [OPTION_ENV_UNWRAP]);\n impl EarlyLintPass for OptionEnvUnwrap {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path_segment, receiver, _, _) = &expr.kind;\n-            if matches!(path_segment.ident.name, sym::expect | sym::unwrap);\n+            if let ExprKind::MethodCall(box MethodCall { seg, receiver, .. }) = &expr.kind;\n+            if matches!(seg.ident.name, sym::expect | sym::unwrap);\n             if let ExprKind::Call(caller, _) = &receiver.kind;\n             if is_direct_expn_of(caller.span, \"option_env\").is_some();\n             then {"}, {"sha": "057b7e30642ec5bc0edd134d913bef1ec8c537e4", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use if_chain::if_chain;\n-use rustc_ast::ast::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_ast::ast::{BinOpKind, Expr, ExprKind, MethodCall, UnOp};\n use rustc_ast::token;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n@@ -110,11 +110,11 @@ impl EarlyLintPass for Precedence {\n             let mut arg = operand;\n \n             let mut all_odd = true;\n-            while let ExprKind::MethodCall(path_segment, receiver, _, _) = &arg.kind {\n-                let path_segment_str = path_segment.ident.name.as_str();\n+            while let ExprKind::MethodCall(box MethodCall { seg, receiver, .. }) = &arg.kind {\n+                let seg_str = seg.ident.name.as_str();\n                 all_odd &= ALLOWED_ODD_FUNCTIONS\n                     .iter()\n-                    .any(|odd_function| **odd_function == *path_segment_str);\n+                    .any(|odd_function| **odd_function == *seg_str);\n                 arg = receiver;\n             }\n "}, {"sha": "4cbe9597c5393eee7221480dbb487aa6d863ce76", "filename": "clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "patch": "@@ -69,24 +69,24 @@ impl EarlyLintPass for RedundantClosureCall {\n         if_chain! {\n             if let ast::ExprKind::Call(ref paren, _) = expr.kind;\n             if let ast::ExprKind::Paren(ref closure) = paren.kind;\n-            if let ast::ExprKind::Closure(_, _, ref r#async, _, ref decl, ref block, _) = closure.kind;\n+            if let ast::ExprKind::Closure(box ast::Closure { ref asyncness, ref fn_decl, ref body, .. }) = closure.kind;\n             then {\n                 let mut visitor = ReturnVisitor::new();\n-                visitor.visit_expr(block);\n+                visitor.visit_expr(body);\n                 if !visitor.found_return {\n                     span_lint_and_then(\n                         cx,\n                         REDUNDANT_CLOSURE_CALL,\n                         expr.span,\n                         \"try not to call a closure in the expression where it is declared\",\n                         |diag| {\n-                            if decl.inputs.is_empty() {\n+                            if fn_decl.inputs.is_empty() {\n                                 let app = Applicability::MachineApplicable;\n-                                let mut hint = Sugg::ast(cx, block, \"..\");\n+                                let mut hint = Sugg::ast(cx, body, \"..\");\n \n-                                if r#async.is_async() {\n+                                if asyncness.is_async() {\n                                     // `async x` is a syntax error, so it becomes `async { x }`\n-                                    if !matches!(block.kind, ast::ExprKind::Block(_, _)) {\n+                                    if !matches!(body.kind, ast::ExprKind::Block(_, _)) {\n                                         hint = hint.blockify();\n                                     }\n "}, {"sha": "78e83880e1a6121020f0d6e0d724fee457fe46e0", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "patch": "@@ -580,7 +580,7 @@ fn ident_difference_expr_with_base_location(\n         | (Await(_), Await(_))\n         | (Async(_, _, _), Async(_, _, _))\n         | (Block(_, _), Block(_, _))\n-        | (Closure(_, _, _, _, _, _, _), Closure(_, _, _, _, _, _, _))\n+        | (Closure(_), Closure(_))\n         | (Match(_, _), Match(_, _))\n         | (Loop(_, _), Loop(_, _))\n         | (ForLoop(_, _, _, _), ForLoop(_, _, _, _))\n@@ -593,7 +593,7 @@ fn ident_difference_expr_with_base_location(\n         | (Unary(_, _), Unary(_, _))\n         | (Binary(_, _, _), Binary(_, _, _))\n         | (Tup(_), Tup(_))\n-        | (MethodCall(_, _, _, _), MethodCall(_, _, _, _))\n+        | (MethodCall(_), MethodCall(_))\n         | (Call(_, _), Call(_, _))\n         | (ConstBlock(_), ConstBlock(_))\n         | (Array(_), Array(_))"}, {"sha": "bb6fb38e9690e32a3e472c49f1462bc38fa28d1b", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "patch": "@@ -292,7 +292,7 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n /// So when we fixate on some `ident_k: pat_k`, we try to find `ident_k` in the other pattern\n /// and check that all `fp_i` where `i \u2208 ((0...n) \\ k)` between two patterns are equal.\n fn extend_with_struct_pat(\n-    qself1: &Option<ast::QSelf>,\n+    qself1: &Option<P<ast::QSelf>>,\n     path1: &ast::Path,\n     fps1: &mut [ast::PatField],\n     rest1: bool,"}, {"sha": "5ab351bc29ca0b8b1ba653287f1933cc70d99217", "filename": "clippy_lints/src/unused_rounding.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Funused_rounding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_lints%2Fsrc%2Funused_rounding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_rounding.rs?ref=333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use rustc_ast::ast::{Expr, ExprKind};\n+use rustc_ast::ast::{Expr, ExprKind, MethodCall};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -30,8 +30,8 @@ declare_clippy_lint! {\n declare_lint_pass!(UnusedRounding => [UNUSED_ROUNDING]);\n \n fn is_useless_rounding(expr: &Expr) -> Option<(&str, String)> {\n-    if let ExprKind::MethodCall(name_ident, receiver, _, _) = &expr.kind\n-        && let method_name = name_ident.ident.name.as_str()\n+    if let ExprKind::MethodCall(box MethodCall { seg, receiver, .. }) = &expr.kind\n+        && let method_name = seg.ident.name.as_str()\n         && (method_name == \"ceil\" || method_name == \"round\" || method_name == \"floor\")\n         && let ExprKind::Lit(token_lit) = &receiver.kind\n         && token_lit.is_semantic_float() {"}, {"sha": "23aed4b5ba2f40f2c675009c338736431a5fdd1e", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333b92c5ed7c4a6849bcf72d0b026de64fde8df9/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=333b92c5ed7c4a6849bcf72d0b026de64fde8df9", "patch": "@@ -75,11 +75,11 @@ pub fn eq_field_pat(l: &PatField, r: &PatField) -> bool {\n         && over(&l.attrs, &r.attrs, eq_attr)\n }\n \n-pub fn eq_qself(l: &QSelf, r: &QSelf) -> bool {\n+pub fn eq_qself(l: &P<QSelf>, r: &P<QSelf>) -> bool {\n     l.position == r.position && eq_ty(&l.ty, &r.ty)\n }\n \n-pub fn eq_maybe_qself(l: &Option<QSelf>, r: &Option<QSelf>) -> bool {\n+pub fn eq_maybe_qself(l: &Option<P<QSelf>>, r: &Option<P<QSelf>>) -> bool {\n     match (l, r) {\n         (Some(l), Some(r)) => eq_qself(l, r),\n         (None, None) => true,\n@@ -147,8 +147,11 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Array(l), Array(r)) | (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n         (Repeat(le, ls), Repeat(re, rs)) => eq_expr(le, re) && eq_expr(&ls.value, &rs.value),\n         (Call(lc, la), Call(rc, ra)) => eq_expr(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n-        (MethodCall(lc, ls, la, _), MethodCall(rc, rs, ra, _)) => {\n-            eq_path_seg(lc, rc) && eq_expr(ls, rs) && over(la, ra, |l, r| eq_expr(l, r))\n+        (\n+            MethodCall(box ast::MethodCall { seg: ls, receiver: lr, args: la, .. }),\n+            MethodCall(box ast::MethodCall { seg: rs, receiver: rr, args: ra, .. })\n+        ) => {\n+            eq_path_seg(ls, rs) && eq_expr(lr, rr) && over(la, ra, |l, r| eq_expr(l, r))\n         },\n         (Binary(lo, ll, lr), Binary(ro, rl, rr)) => lo.node == ro.node && eq_expr(ll, rl) && eq_expr(lr, rr),\n         (Unary(lo, l), Unary(ro, r)) => mem::discriminant(lo) == mem::discriminant(ro) && eq_expr(l, r),\n@@ -170,7 +173,26 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (AssignOp(lo, lp, lv), AssignOp(ro, rp, rv)) => lo.node == ro.node && eq_expr(lp, rp) && eq_expr(lv, rv),\n         (Field(lp, lf), Field(rp, rf)) => eq_id(*lf, *rf) && eq_expr(lp, rp),\n         (Match(ls, la), Match(rs, ra)) => eq_expr(ls, rs) && over(la, ra, eq_arm),\n-        (Closure(lb, lc, la, lm, lf, le, _), Closure(rb, rc, ra, rm, rf, re, _)) => {\n+        (\n+            Closure(box ast::Closure {\n+                binder: lb,\n+                capture_clause: lc,\n+                asyncness: la,\n+                movability: lm,\n+                fn_decl: lf,\n+                body: le,\n+                ..\n+            }),\n+            Closure(box ast::Closure {\n+                binder: rb,\n+                capture_clause: rc,\n+                asyncness: ra,\n+                movability: rm,\n+                fn_decl: rf,\n+                body: re,\n+                ..\n+            })\n+        ) => {\n             eq_closure_binder(lb, rb)\n                 && lc == rc\n                 && la.is_async() == ra.is_async()"}]}