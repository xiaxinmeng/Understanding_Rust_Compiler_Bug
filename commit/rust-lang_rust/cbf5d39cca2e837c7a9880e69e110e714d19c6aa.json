{"sha": "cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZjVkMzljY2EyZTgzN2M3YTk4ODBlNjllMTEwZTcxNGQxOWM2YWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-11T16:00:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-11T16:00:25Z"}, "message": "Auto merge of #44888 - tirr-c:binder-hr-region, r=arielb1\n\nRefactor fmt::Display and fmt::Debug impls in ppaux\n\nAlso fixes #44887.\n\nThere was a problem that unnamed late-bound regions are *always* named `'r` while they are displayed using `std::fmt::Display`.\n\n---\n\n```rust\nfn main() {\n    f(|_: (), _: ()| {});\n}\nfn f<F>(_: F) where F: Fn(&(), for<'r> fn(&'r ())) {}\n```\n\nBefore (incorrectly shadows lifetime, `for<'r>` omitted for the second argument):\n\n```\nerror[E0631]: type mismatch in closure arguments\n --> test.rs:2:5\n  |\n2 |     f(|_: (), _: ()| {});\n  |     ^ ----------------- found signature of `fn((), ()) -> _`\n  |     |\n  |     expected signature of `for<'r> fn(&'r (), fn(&'r ())) -> _`\n  |\n  = note: required by `f`\n```\n\nAfter:\n\n```\nerror[E0631]: type mismatch in closure arguments\n --> test.rs:2:5\n  |\n2 |     f(|_: (), _: ()| {});\n  |     ^ ----------------- found signature of `fn((), ()) -> _`\n  |     |\n  |     expected signature of `for<'s> fn(&'s (), for<'r> fn(&'r ())) -> _`\n  |\n  = note: required by `f`\n```\n\nr? @nikomatsakis", "tree": {"sha": "f3728479cabecb1caf34be67121afd3c91b3eb5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3728479cabecb1caf34be67121afd3c91b3eb5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "html_url": "https://github.com/rust-lang/rust/commit/cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0d40a1908723a7bbf0d2f745570162de250f188", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0d40a1908723a7bbf0d2f745570162de250f188", "html_url": "https://github.com/rust-lang/rust/commit/c0d40a1908723a7bbf0d2f745570162de250f188"}, {"sha": "84cb90f8ee080ed04512620357c1f734146df8c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/84cb90f8ee080ed04512620357c1f734146df8c3", "html_url": "https://github.com/rust-lang/rust/commit/84cb90f8ee080ed04512620357c1f734146df8c3"}], "stats": {"total": 1987, "additions": 1180, "deletions": 807}, "files": [{"sha": "0eb2c19fe44ddeb72a2013ce0e79638691e64a39", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 989, "deletions": 768, "changes": 1757, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -20,6 +20,7 @@ use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::{TyClosure, TyGenerator, TyProjection, TyAnon};\n use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use util::nodemap::FxHashSet;\n \n use std::cell::Cell;\n use std::fmt;\n@@ -32,310 +33,543 @@ use syntax::ast::CRATE_NODE_ID;\n use syntax::symbol::Symbol;\n use hir;\n \n-pub fn verbose() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.verbose())\n+macro_rules! gen_display_debug_body {\n+    ( $with:path ) => {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            let mut cx = PrintContext::new();\n+            $with(self, f, &mut cx)\n+        }\n+    };\n }\n-\n-pub fn identify_regions() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.identify_regions)\n+macro_rules! gen_display_debug {\n+    ( ($($x:tt)+) $target:ty, display yes ) => {\n+        impl<$($x)+> fmt::Display for $target {\n+            gen_display_debug_body! { Print::print_display }\n+        }\n+    };\n+    ( () $target:ty, display yes ) => {\n+        impl fmt::Display for $target {\n+            gen_display_debug_body! { Print::print_display }\n+        }\n+    };\n+    ( ($($x:tt)+) $target:ty, debug yes ) => {\n+        impl<$($x)+> fmt::Debug for $target {\n+            gen_display_debug_body! { Print::print_debug }\n+        }\n+    };\n+    ( () $target:ty, debug yes ) => {\n+        impl fmt::Debug for $target {\n+            gen_display_debug_body! { Print::print_debug }\n+        }\n+    };\n+    ( $generic:tt $target:ty, $t:ident no ) => {};\n }\n-\n-fn fn_sig(f: &mut fmt::Formatter,\n-          inputs: &[Ty],\n-          variadic: bool,\n-          output: Ty)\n-          -> fmt::Result {\n-    write!(f, \"(\")?;\n-    let mut inputs = inputs.iter();\n-    if let Some(&ty) = inputs.next() {\n-        write!(f, \"{}\", ty)?;\n-        for &ty in inputs {\n-            write!(f, \", {}\", ty)?;\n+macro_rules! gen_print_impl {\n+    ( ($($x:tt)+) $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n+        impl<$($x)+> Print for $target {\n+            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n+                if $cx.is_debug $dbg\n+                else $disp\n+            }\n         }\n-        if variadic {\n-            write!(f, \", ...\")?;\n+    };\n+    ( () $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n+        impl Print for $target {\n+            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n+                if $cx.is_debug $dbg\n+                else $disp\n+            }\n         }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt $gendisp:ident $disp:block $gendbg:ident $dbg:block ) => {\n+        gen_print_impl! { $generic $target, $vars $disp $dbg }\n+        gen_display_debug! { $generic $target, display $gendisp }\n+        gen_display_debug! { $generic $target, debug $gendbg }\n     }\n-    write!(f, \")\")?;\n-    if !output.is_nil() {\n-        write!(f, \" -> {}\", output)?;\n+}\n+macro_rules! define_print {\n+    ( $generic:tt $target:ty,\n+      $vars:tt { display $disp:block debug $dbg:block } ) => {\n+        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt { debug $dbg:block display $disp:block } ) => {\n+        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt { debug $dbg:block } ) => {\n+        gen_print_impl! { $generic $target, $vars no {\n+            bug!(concat!(\"display not implemented for \", stringify!($target)));\n+        } yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      ($self:ident, $f:ident, $cx:ident) { display $disp:block } ) => {\n+        gen_print_impl! { $generic $target, ($self, $f, $cx) yes $disp no {\n+            write!($f, \"{:?}\", $self)\n+        } }\n+    };\n+}\n+macro_rules! define_print_multi {\n+    ( [ $($generic:tt $target:ty),* ] $vars:tt $def:tt ) => {\n+        $(define_print! { $generic $target, $vars $def })*\n+    };\n+}\n+macro_rules! print_inner {\n+    ( $f:expr, $cx:expr, write ($($data:expr),+) ) => {\n+        write!($f, $($data),+)\n+    };\n+    ( $f:expr, $cx:expr, $kind:ident ($data:expr) ) => {\n+        $data.$kind($f, $cx)\n+    };\n+}\n+macro_rules! print {\n+    ( $f:expr, $cx:expr $(, $kind:ident $data:tt)+ ) => {\n+        Ok(())$(.and_then(|_| print_inner!($f, $cx, $kind $data)))+\n+    };\n+}\n+\n+\n+struct LateBoundRegionNameCollector(FxHashSet<Symbol>);\n+impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        match *r {\n+            ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n+                self.0.insert(name);\n+            },\n+            _ => {},\n+        }\n+        r.super_visit_with(self)\n     }\n+}\n \n-    Ok(())\n+#[derive(Debug)]\n+pub struct PrintContext {\n+    is_debug: bool,\n+    is_verbose: bool,\n+    identify_regions: bool,\n+    used_region_names: Option<FxHashSet<Symbol>>,\n+    region_index: usize,\n+    binder_depth: usize,\n+}\n+impl PrintContext {\n+    fn new() -> Self {\n+        ty::tls::with_opt(|tcx| {\n+            let (is_verbose, identify_regions) = tcx.map(\n+                |tcx| (tcx.sess.verbose(), tcx.sess.opts.debugging_opts.identify_regions)\n+            ).unwrap_or((false, false));\n+            PrintContext {\n+                is_debug: false,\n+                is_verbose: is_verbose,\n+                identify_regions: identify_regions,\n+                used_region_names: None,\n+                region_index: 0,\n+                binder_depth: 0,\n+            }\n+        })\n+    }\n+    fn prepare_late_bound_region_info<'tcx, T>(&mut self, value: &ty::Binder<T>)\n+    where T: TypeFoldable<'tcx>\n+    {\n+        let mut collector = LateBoundRegionNameCollector(FxHashSet());\n+        value.visit_with(&mut collector);\n+        self.used_region_names = Some(collector.0);\n+        self.region_index = 0;\n+    }\n }\n \n-pub fn parameterized(f: &mut fmt::Formatter,\n-                     substs: &subst::Substs,\n-                     mut did: DefId,\n-                     projections: &[ty::ProjectionPredicate])\n-                     -> fmt::Result {\n-    let key = ty::tls::with(|tcx| tcx.def_key(did));\n-    let mut item_name = if let Some(name) = key.disambiguated_data.data.get_opt_name() {\n-        Some(name)\n-    } else {\n-        did.index = key.parent.unwrap_or_else(\n-            || bug!(\"finding type for {:?}, encountered def-id {:?} with no parent\",\n-                    did, did));\n-        parameterized(f, substs, did, projections)?;\n-        return write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str());\n-    };\n+pub trait Print {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result;\n+    fn print_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print(&mut result, cx);\n+        result\n+    }\n+    fn print_display<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        let old_debug = cx.is_debug;\n+        cx.is_debug = false;\n+        let result = self.print(f, cx);\n+        cx.is_debug = old_debug;\n+        result\n+    }\n+    fn print_display_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print_display(&mut result, cx);\n+        result\n+    }\n+    fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        let old_debug = cx.is_debug;\n+        cx.is_debug = true;\n+        let result = self.print(f, cx);\n+        cx.is_debug = old_debug;\n+        result\n+    }\n+    fn print_debug_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print_debug(&mut result, cx);\n+        result\n+    }\n+}\n \n-    let mut verbose = false;\n-    let mut num_supplied_defaults = 0;\n-    let mut has_self = false;\n-    let mut num_regions = 0;\n-    let mut num_types = 0;\n-    let mut is_value_path = false;\n-    let fn_trait_kind = ty::tls::with(|tcx| {\n-        // Unfortunately, some kinds of items (e.g., closures) don't have\n-        // generics. So walk back up the find the closest parent that DOES\n-        // have them.\n-        let mut item_def_id = did;\n-        loop {\n-            let key = tcx.def_key(item_def_id);\n-            match key.disambiguated_data.data {\n-                DefPathData::TypeNs(_) => {\n-                    break;\n-                }\n-                DefPathData::ValueNs(_) | DefPathData::EnumVariant(_) => {\n-                    is_value_path = true;\n-                    break;\n-                }\n-                _ => {\n-                    // if we're making a symbol for something, there ought\n-                    // to be a value or type-def or something in there\n-                    // *somewhere*\n-                    item_def_id.index = key.parent.unwrap_or_else(|| {\n-                        bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                             parent\", did, item_def_id);\n-                    });\n-                }\n+impl PrintContext {\n+    fn fn_sig<F: fmt::Write>(&mut self,\n+                             f: &mut F,\n+                             inputs: &[Ty],\n+                             variadic: bool,\n+                             output: Ty)\n+                             -> fmt::Result {\n+        write!(f, \"(\")?;\n+        let mut inputs = inputs.iter();\n+        if let Some(&ty) = inputs.next() {\n+            print!(f, self, print_display(ty))?;\n+            for &ty in inputs {\n+                print!(f, self, write(\", \"), print_display(ty))?;\n+            }\n+            if variadic {\n+                write!(f, \", ...\")?;\n             }\n         }\n-        let mut generics = tcx.generics_of(item_def_id);\n-        let mut path_def_id = did;\n-        verbose = tcx.sess.verbose();\n-        has_self = generics.has_self;\n-\n-        let mut child_types = 0;\n-        if let Some(def_id) = generics.parent {\n-            // Methods.\n-            assert!(is_value_path);\n-            child_types = generics.types.len();\n-            generics = tcx.generics_of(def_id);\n-            num_regions = generics.regions.len();\n-            num_types = generics.types.len();\n+        write!(f, \")\")?;\n+        if !output.is_nil() {\n+            print!(f, self, write(\" -> \"), print_display(output))?;\n+        }\n \n-            if has_self {\n-                write!(f, \"<{} as \", substs.type_at(0))?;\n-            }\n+        Ok(())\n+    }\n \n-            path_def_id = def_id;\n+    fn parameterized<F: fmt::Write>(&mut self,\n+                                    f: &mut F,\n+                                    substs: &subst::Substs,\n+                                    mut did: DefId,\n+                                    projections: &[ty::ProjectionPredicate])\n+                                    -> fmt::Result {\n+        let key = ty::tls::with(|tcx| tcx.def_key(did));\n+        let mut item_name = if let Some(name) = key.disambiguated_data.data.get_opt_name() {\n+            Some(name)\n         } else {\n-            item_name = None;\n+            did.index = key.parent.unwrap_or_else(\n+                || bug!(\"finding type for {:?}, encountered def-id {:?} with no parent\",\n+                        did, did));\n+            self.parameterized(f, substs, did, projections)?;\n+            return write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str());\n+        };\n \n-            if is_value_path {\n-                // Functions.\n-                assert_eq!(has_self, false);\n-            } else {\n-                // Types and traits.\n+        let verbose = self.is_verbose;\n+        let mut num_supplied_defaults = 0;\n+        let mut has_self = false;\n+        let mut num_regions = 0;\n+        let mut num_types = 0;\n+        let mut is_value_path = false;\n+        let fn_trait_kind = ty::tls::with(|tcx| {\n+            // Unfortunately, some kinds of items (e.g., closures) don't have\n+            // generics. So walk back up the find the closest parent that DOES\n+            // have them.\n+            let mut item_def_id = did;\n+            loop {\n+                let key = tcx.def_key(item_def_id);\n+                match key.disambiguated_data.data {\n+                    DefPathData::TypeNs(_) => {\n+                        break;\n+                    }\n+                    DefPathData::ValueNs(_) | DefPathData::EnumVariant(_) => {\n+                        is_value_path = true;\n+                        break;\n+                    }\n+                    _ => {\n+                        // if we're making a symbol for something, there ought\n+                        // to be a value or type-def or something in there\n+                        // *somewhere*\n+                        item_def_id.index = key.parent.unwrap_or_else(|| {\n+                            bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                                 parent\", did, item_def_id);\n+                        });\n+                    }\n+                }\n+            }\n+            let mut generics = tcx.generics_of(item_def_id);\n+            let mut path_def_id = did;\n+            has_self = generics.has_self;\n+\n+            let mut child_types = 0;\n+            if let Some(def_id) = generics.parent {\n+                // Methods.\n+                assert!(is_value_path);\n+                child_types = generics.types.len();\n+                generics = tcx.generics_of(def_id);\n                 num_regions = generics.regions.len();\n                 num_types = generics.types.len();\n+\n+                if has_self {\n+                    print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n+                }\n+\n+                path_def_id = def_id;\n+            } else {\n+                item_name = None;\n+\n+                if is_value_path {\n+                    // Functions.\n+                    assert_eq!(has_self, false);\n+                } else {\n+                    // Types and traits.\n+                    num_regions = generics.regions.len();\n+                    num_types = generics.types.len();\n+                }\n             }\n-        }\n \n-        if !verbose {\n-            if generics.types.last().map_or(false, |def| def.has_default) {\n-                if let Some(substs) = tcx.lift(&substs) {\n-                    let tps = substs.types().rev().skip(child_types);\n-                    for (def, actual) in generics.types.iter().rev().zip(tps) {\n-                        if !def.has_default {\n-                            break;\n-                        }\n-                        if tcx.type_of(def.def_id).subst(tcx, substs) != actual {\n-                            break;\n+            if !verbose {\n+                if generics.types.last().map_or(false, |def| def.has_default) {\n+                    if let Some(substs) = tcx.lift(&substs) {\n+                        let tps = substs.types().rev().skip(child_types);\n+                        for (def, actual) in generics.types.iter().rev().zip(tps) {\n+                            if !def.has_default {\n+                                break;\n+                            }\n+                            if tcx.type_of(def.def_id).subst(tcx, substs) != actual {\n+                                break;\n+                            }\n+                            num_supplied_defaults += 1;\n                         }\n-                        num_supplied_defaults += 1;\n                     }\n                 }\n             }\n-        }\n \n-        write!(f, \"{}\", tcx.item_path_str(path_def_id))?;\n-        Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n-    })?;\n+            print!(f, self, write(\"{}\", tcx.item_path_str(path_def_id)))?;\n+            Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n+        })?;\n \n-    if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n-        let projection_ty = projections[0].ty;\n-        if let TyTuple(ref args, _) = substs.type_at(1).sty {\n-            return fn_sig(f, args, false, projection_ty);\n+        if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n+            let projection_ty = projections[0].ty;\n+            if let TyTuple(ref args, _) = substs.type_at(1).sty {\n+                return self.fn_sig(f, args, false, projection_ty);\n+            }\n         }\n-    }\n \n-    let empty = Cell::new(true);\n-    let start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n-        if empty.get() {\n-            empty.set(false);\n-            write!(f, \"{}\", start)\n-        } else {\n-            write!(f, \"{}\", cont)\n-        }\n-    };\n+        let empty = Cell::new(true);\n+        let start_or_continue = |f: &mut F, start: &str, cont: &str| {\n+            if empty.get() {\n+                empty.set(false);\n+                write!(f, \"{}\", start)\n+            } else {\n+                write!(f, \"{}\", cont)\n+            }\n+        };\n \n-    let print_regions = |f: &mut fmt::Formatter, start: &str, skip, count| {\n-        // Don't print any regions if they're all erased.\n-        let regions = || substs.regions().skip(skip).take(count);\n-        if regions().all(|r: ty::Region| *r == ty::ReErased) {\n-            return Ok(());\n-        }\n+        let print_regions = |f: &mut F, start: &str, skip, count| {\n+            // Don't print any regions if they're all erased.\n+            let regions = || substs.regions().skip(skip).take(count);\n+            if regions().all(|r: ty::Region| *r == ty::ReErased) {\n+                return Ok(());\n+            }\n \n-        for region in regions() {\n-            let region: ty::Region = region;\n-            start_or_continue(f, start, \", \")?;\n-            if verbose {\n-                write!(f, \"{:?}\", region)?;\n-            } else {\n-                let s = region.to_string();\n-                if s.is_empty() {\n-                    // This happens when the value of the region\n-                    // parameter is not easily serialized. This may be\n-                    // because the user omitted it in the first place,\n-                    // or because it refers to some block in the code,\n-                    // etc. I'm not sure how best to serialize this.\n-                    write!(f, \"'_\")?;\n+            for region in regions() {\n+                let region: ty::Region = region;\n+                start_or_continue(f, start, \", \")?;\n+                if verbose {\n+                    write!(f, \"{:?}\", region)?;\n                 } else {\n-                    write!(f, \"{}\", s)?;\n+                    let s = region.to_string();\n+                    if s.is_empty() {\n+                        // This happens when the value of the region\n+                        // parameter is not easily serialized. This may be\n+                        // because the user omitted it in the first place,\n+                        // or because it refers to some block in the code,\n+                        // etc. I'm not sure how best to serialize this.\n+                        write!(f, \"'_\")?;\n+                    } else {\n+                        write!(f, \"{}\", s)?;\n+                    }\n                 }\n             }\n+\n+            Ok(())\n+        };\n+\n+        print_regions(f, \"<\", 0, num_regions)?;\n+\n+        let tps = substs.types().take(num_types - num_supplied_defaults)\n+                                .skip(has_self as usize);\n+\n+        for ty in tps {\n+            start_or_continue(f, \"<\", \", \")?;\n+            ty.print_display(f, self)?;\n         }\n \n-        Ok(())\n-    };\n+        for projection in projections {\n+            start_or_continue(f, \"<\", \", \")?;\n+            ty::tls::with(|tcx|\n+                print!(f, self,\n+                       write(\"{}=\",\n+                             tcx.associated_item(projection.projection_ty.item_def_id).name),\n+                       print_display(projection.ty))\n+            )?;\n+        }\n \n-    print_regions(f, \"<\", 0, num_regions)?;\n+        start_or_continue(f, \"\", \">\")?;\n \n-    let tps = substs.types().take(num_types - num_supplied_defaults)\n-                            .skip(has_self as usize);\n+        // For values, also print their name and type parameters.\n+        if is_value_path {\n+            empty.set(true);\n \n-    for ty in tps {\n-        start_or_continue(f, \"<\", \", \")?;\n-        write!(f, \"{}\", ty)?;\n-    }\n+            if has_self {\n+                write!(f, \">\")?;\n+            }\n \n-    for projection in projections {\n-        start_or_continue(f, \"<\", \", \")?;\n-        ty::tls::with(|tcx|\n-            write!(f, \"{}={}\",\n-            tcx.associated_item(projection.projection_ty.item_def_id).name,\n-            projection.ty)\n-        )?;\n-    }\n+            if let Some(item_name) = item_name {\n+                write!(f, \"::{}\", item_name)?;\n+            }\n \n-    start_or_continue(f, \"\", \">\")?;\n+            print_regions(f, \"::<\", num_regions, usize::MAX)?;\n \n-    // For values, also print their name and type parameters.\n-    if is_value_path {\n-        empty.set(true);\n+            // FIXME: consider being smart with defaults here too\n+            for ty in substs.types().skip(num_types) {\n+                start_or_continue(f, \"::<\", \", \")?;\n+                ty.print_display(f, self)?;\n+            }\n \n-        if has_self {\n-            write!(f, \">\")?;\n+            start_or_continue(f, \"\", \">\")?;\n         }\n \n-        if let Some(item_name) = item_name {\n-            write!(f, \"::{}\", item_name)?;\n+        Ok(())\n+    }\n+\n+    fn in_binder<'a, 'gcx, 'tcx, T, U, F>(&mut self,\n+                                          f: &mut F,\n+                                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                          original: &ty::Binder<T>,\n+                                          lifted: Option<ty::Binder<U>>) -> fmt::Result\n+        where T: Print, U: Print + TypeFoldable<'tcx>, F: fmt::Write\n+    {\n+        fn name_by_region_index(index: usize) -> Symbol {\n+            match index {\n+                0 => Symbol::intern(\"'r\"),\n+                1 => Symbol::intern(\"'s\"),\n+                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n+            }\n         }\n \n-        print_regions(f, \"::<\", num_regions, usize::MAX)?;\n+        // Replace any anonymous late-bound regions with named\n+        // variants, using gensym'd identifiers, so that we can\n+        // clearly differentiate between named and unnamed regions in\n+        // the output. We'll probably want to tweak this over time to\n+        // decide just how much information to give.\n+        let value = if let Some(v) = lifted {\n+            v\n+        } else {\n+            return original.0.print_display(f, self);\n+        };\n \n-        // FIXME: consider being smart with defaults here too\n-        for ty in substs.types().skip(num_types) {\n-            start_or_continue(f, \"::<\", \", \")?;\n-            write!(f, \"{}\", ty)?;\n+        if self.binder_depth == 0 {\n+            self.prepare_late_bound_region_info(&value);\n         }\n \n-        start_or_continue(f, \"\", \">\")?;\n+        let mut empty = true;\n+        let mut start_or_continue = |f: &mut F, start: &str, cont: &str| {\n+            if empty {\n+                empty = false;\n+                write!(f, \"{}\", start)\n+            } else {\n+                write!(f, \"{}\", cont)\n+            }\n+        };\n+\n+        let old_region_index = self.region_index;\n+        let mut region_index = old_region_index;\n+        let new_value = tcx.replace_late_bound_regions(&value, |br| {\n+            let _ = start_or_continue(f, \"for<\", \", \");\n+            let br = match br {\n+                ty::BrNamed(_, name) => {\n+                    let _ = write!(f, \"{}\", name);\n+                    br\n+                }\n+                ty::BrAnon(_) |\n+                ty::BrFresh(_) |\n+                ty::BrEnv => {\n+                    let name = loop {\n+                        let name = name_by_region_index(region_index);\n+                        region_index += 1;\n+                        if !self.is_name_used(&name) {\n+                            break name;\n+                        }\n+                    };\n+                    let _ = write!(f, \"{}\", name);\n+                    ty::BrNamed(tcx.hir.local_def_id(CRATE_NODE_ID),\n+                                name)\n+                }\n+            };\n+            tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), br))\n+        }).0;\n+        start_or_continue(f, \"\", \"> \")?;\n+\n+        // Push current state to gcx, and restore after writing new_value.\n+        self.binder_depth += 1;\n+        self.region_index = region_index;\n+        let result = new_value.print_display(f, self);\n+        self.region_index = old_region_index;\n+        self.binder_depth -= 1;\n+        result\n     }\n \n-    Ok(())\n+    fn is_name_used(&self, name: &Symbol) -> bool {\n+        match self.used_region_names {\n+            Some(ref names) => names.contains(name),\n+            None => false,\n+        }\n+    }\n }\n \n-fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n-                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                   original: &ty::Binder<T>,\n-                                   lifted: Option<ty::Binder<U>>) -> fmt::Result\n-    where T: fmt::Display, U: fmt::Display + TypeFoldable<'tcx>\n-{\n-    // Replace any anonymous late-bound regions with named\n-    // variants, using gensym'd identifiers, so that we can\n-    // clearly differentiate between named and unnamed regions in\n-    // the output. We'll probably want to tweak this over time to\n-    // decide just how much information to give.\n-    let value = if let Some(v) = lifted {\n-        v\n-    } else {\n-        return write!(f, \"{}\", original.0);\n-    };\n+pub fn verbose() -> bool {\n+    ty::tls::with(|tcx| tcx.sess.verbose())\n+}\n \n-    let mut empty = true;\n-    let mut start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n-        if empty {\n-            empty = false;\n-            write!(f, \"{}\", start)\n-        } else {\n-            write!(f, \"{}\", cont)\n-        }\n-    };\n+pub fn identify_regions() -> bool {\n+    ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.identify_regions)\n+}\n \n-    let new_value = tcx.replace_late_bound_regions(&value, |br| {\n-        let _ = start_or_continue(f, \"for<\", \", \");\n-        let br = match br {\n-            ty::BrNamed(_, name) => {\n-                let _ = write!(f, \"{}\", name);\n-                br\n-            }\n-            ty::BrAnon(_) |\n-            ty::BrFresh(_) |\n-            ty::BrEnv => {\n-                let name = Symbol::intern(\"'r\");\n-                let _ = write!(f, \"{}\", name);\n-                ty::BrNamed(tcx.hir.local_def_id(CRATE_NODE_ID),\n-                            name)\n-            }\n-        };\n-        tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), br))\n-    }).0;\n+pub fn parameterized<F: fmt::Write>(f: &mut F,\n+                                    substs: &subst::Substs,\n+                                    did: DefId,\n+                                    projections: &[ty::ProjectionPredicate])\n+                                    -> fmt::Result {\n+    PrintContext::new().parameterized(f, substs, did, projections)\n+}\n \n-    start_or_continue(f, \"\", \"> \")?;\n-    write!(f, \"{}\", new_value)\n+\n+impl<'a, T: Print> Print for &'a T {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        (*self).print(f, cx)\n+    }\n }\n \n-impl<'tcx> fmt::Display for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // Generate the main trait ref, including associated types.\n-        ty::tls::with(|tcx| {\n-            // Use a type that can't appear in defaults of type parameters.\n-            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-\n-            if let Some(p) = self.principal() {\n-                let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n-                    .with_self_ty(tcx, dummy_self);\n-                let projections = self.projection_bounds().map(|p| {\n-                    tcx.lift(&p)\n-                        .expect(\"could not lift projection for printing\")\n-                        .with_self_ty(tcx, dummy_self)\n-                }).collect::<Vec<_>>();\n-                parameterized(f, principal.substs, principal.def_id, &projections)?;\n-            }\n+define_print! {\n+    ('tcx) &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n+        display {\n+            // Generate the main trait ref, including associated types.\n+            ty::tls::with(|tcx| {\n+                // Use a type that can't appear in defaults of type parameters.\n+                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+                if let Some(p) = self.principal() {\n+                    let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n+                        .with_self_ty(tcx, dummy_self);\n+                    let projections = self.projection_bounds().map(|p| {\n+                        tcx.lift(&p)\n+                            .expect(\"could not lift projection for printing\")\n+                            .with_self_ty(tcx, dummy_self)\n+                    }).collect::<Vec<_>>();\n+                    cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n+                }\n \n-            // Builtin bounds.\n-            for did in self.auto_traits() {\n-                write!(f, \" + {}\", tcx.item_path_str(did))?;\n-            }\n+                // Builtin bounds.\n+                for did in self.auto_traits() {\n+                    write!(f, \" + {}\", tcx.item_path_str(did))?;\n+                }\n \n-            Ok(())\n-        })?;\n+                Ok(())\n+            })?;\n \n-        Ok(())\n+            Ok(())\n+        }\n     }\n }\n \n@@ -357,42 +591,6 @@ impl fmt::Debug for ty::RegionParameterDef {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TyS<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", *self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::TypeAndMut<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}{}\",\n-               if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" },\n-               self.ty)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // when printing out the debug representation, we don't need\n-        // to enumerate the `for<...>` etc because the debruijn index\n-        // tells you everything you need to know.\n-        write!(f, \"<{:?} as {}>\", self.self_ty(), *self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-\n-            let trait_ref = tcx.lift(&ty::Binder(*self))\n-                               .expect(\"could not lift TraitRef for printing\")\n-                               .with_self_ty(tcx, dummy_self).0;\n-            parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n-        })\n-    }\n-}\n-\n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| {\n@@ -409,196 +607,226 @@ impl fmt::Debug for ty::AdtDef {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n+impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?} -> {}\", self.kind, self.target)\n+        write!(f, \"ClosureUpvar({:?},{:?})\",\n+               self.def,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n+impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::Predicate::Trait(ref a) => write!(f, \"{:?}\", a),\n-            ty::Predicate::Equate(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::Subtype(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::Projection(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::WellFormed(ty) => write!(f, \"WF({:?})\", ty),\n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n-                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n-            }\n-            ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                write!(f, \"ClosureKind({:?}, {:?})\", closure_def_id, kind)\n-            }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n-            }\n-        }\n+        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n+               self.var_id,\n+               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_id))),\n+               self.closure_expr_id)\n     }\n }\n \n-impl fmt::Display for ty::BoundRegion {\n+impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if verbose() {\n-            return write!(f, \"{:?}\", *self);\n+        write!(f, \"UpvarBorrow({:?}, {:?})\",\n+               self.kind, self.region)\n+    }\n+}\n+\n+define_print! {\n+    ('tcx) ty::TypeAndMut<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx,\n+                   write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n+                   print(self.ty))\n         }\n+    }\n+}\n \n-        match *self {\n-            BrNamed(_, name) => write!(f, \"{}\", name),\n-            BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n+define_print! {\n+    ('tcx) ty::ExistentialTraitRef<'tcx>, (self, f, cx) {\n+        debug {\n+            ty::tls::with(|tcx| {\n+                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+                let trait_ref = tcx.lift(&ty::Binder(*self))\n+                                   .expect(\"could not lift TraitRef for printing\")\n+                                   .with_self_ty(tcx, dummy_self).0;\n+                cx.parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n+            })\n         }\n     }\n }\n \n-impl fmt::Debug for ty::BoundRegion {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n-            BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n-            BrNamed(did, name) => {\n-                write!(f, \"BrNamed({:?}:{:?}, {:?})\",\n-                       did.krate, did.index, name)\n-            }\n-            BrEnv => \"BrEnv\".fmt(f),\n+define_print! {\n+    ('tcx) ty::adjustment::Adjustment<'tcx>, (self, f, cx) {\n+        debug {\n+            print!(f, cx, write(\"{:?} -> \", self.kind), print(self.target))\n         }\n     }\n }\n \n-impl fmt::Debug for ty::RegionKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::ReEarlyBound(ref data) => {\n-                write!(f, \"ReEarlyBound({}, {})\",\n-                       data.index,\n-                       data.name)\n+define_print! {\n+    () ty::BoundRegion, (self, f, cx) {\n+        display {\n+            if cx.is_verbose {\n+                return self.print_debug(f, cx);\n             }\n \n-            ty::ReLateBound(binder_id, ref bound_region) => {\n-                write!(f, \"ReLateBound({:?}, {:?})\",\n-                       binder_id,\n-                       bound_region)\n+            match *self {\n+                BrNamed(_, name) => write!(f, \"{}\", name),\n+                BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n             }\n+        }\n+        debug {\n+            return match *self {\n+                BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n+                BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n+                BrNamed(did, name) => {\n+                    write!(f, \"BrNamed({:?}:{:?}, {:?})\",\n+                           did.krate, did.index, name)\n+                }\n+                BrEnv => write!(f, \"BrEnv\"),\n+            };\n+        }\n+    }\n+}\n \n-            ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n-\n-            ty::ReScope(id) => {\n-                write!(f, \"ReScope({:?})\", id)\n+define_print! {\n+    () ty::RegionKind, (self, f, cx) {\n+        display {\n+            if cx.is_verbose {\n+                return self.print_debug(f, cx);\n             }\n \n-            ty::ReStatic => write!(f, \"ReStatic\"),\n-\n-            ty::ReVar(ref vid) => {\n-                write!(f, \"{:?}\", vid)\n+            // These printouts are concise.  They do not contain all the information\n+            // the user might want to diagnose an error, but there is basically no way\n+            // to fit that into a short string.  Hence the recommendation to use\n+            // `explain_region()` or `note_and_explain_region()`.\n+            match *self {\n+                ty::ReEarlyBound(ref data) => {\n+                    write!(f, \"{}\", data.name)\n+                }\n+                ty::ReLateBound(_, br) |\n+                ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+                ty::ReSkolemized(_, br) => {\n+                    write!(f, \"{}\", br)\n+                }\n+                ty::ReScope(scope) if cx.identify_regions => {\n+                    match scope.data() {\n+                        region::ScopeData::Node(id) =>\n+                            write!(f, \"'{}s\", id.as_usize()),\n+                        region::ScopeData::CallSite(id) =>\n+                            write!(f, \"'{}cs\", id.as_usize()),\n+                        region::ScopeData::Arguments(id) =>\n+                            write!(f, \"'{}as\", id.as_usize()),\n+                        region::ScopeData::Destruction(id) =>\n+                            write!(f, \"'{}ds\", id.as_usize()),\n+                        region::ScopeData::Remainder(BlockRemainder\n+                                                     { block, first_statement_index }) =>\n+                            write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n+                    }\n+                }\n+                ty::ReVar(region_vid) if cx.identify_regions => {\n+                    write!(f, \"'{}rv\", region_vid.index)\n+                }\n+                ty::ReScope(_) |\n+                ty::ReVar(_) |\n+                ty::ReErased => Ok(()),\n+                ty::ReStatic => write!(f, \"'static\"),\n+                ty::ReEmpty => write!(f, \"'<empty>\"),\n             }\n+        }\n+        debug {\n+            match *self {\n+                ty::ReEarlyBound(ref data) => {\n+                    write!(f, \"ReEarlyBound({}, {})\",\n+                           data.index,\n+                           data.name)\n+                }\n \n-            ty::ReSkolemized(id, ref bound_region) => {\n-                write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n-            }\n+                ty::ReLateBound(binder_id, ref bound_region) => {\n+                    write!(f, \"ReLateBound({:?}, {:?})\",\n+                           binder_id,\n+                           bound_region)\n+                }\n \n-            ty::ReEmpty => write!(f, \"ReEmpty\"),\n+                ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n \n-            ty::ReErased => write!(f, \"ReErased\")\n-        }\n-    }\n-}\n+                ty::ReScope(id) => {\n+                    write!(f, \"ReScope({:?})\", id)\n+                }\n \n-impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ClosureUpvar({:?},{:?})\",\n-               self.def,\n-               self.ty)\n-    }\n-}\n+                ty::ReStatic => write!(f, \"ReStatic\"),\n \n-impl fmt::Display for ty::RegionKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if verbose() {\n-            return write!(f, \"{:?}\", *self);\n-        }\n+                ty::ReVar(ref vid) => {\n+                    write!(f, \"{:?}\", vid)\n+                }\n \n-        // These printouts are concise.  They do not contain all the information\n-        // the user might want to diagnose an error, but there is basically no way\n-        // to fit that into a short string.  Hence the recommendation to use\n-        // `explain_region()` or `note_and_explain_region()`.\n-        match *self {\n-            ty::ReEarlyBound(ref data) => {\n-                write!(f, \"{}\", data.name)\n-            }\n-            ty::ReLateBound(_, br) |\n-            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-            ty::ReSkolemized(_, br) => {\n-                write!(f, \"{}\", br)\n-            }\n-            ty::ReScope(scope) if identify_regions() => {\n-                match scope.data() {\n-                    region::ScopeData::Node(id) =>\n-                        write!(f, \"'{}s\", id.as_usize()),\n-                    region::ScopeData::CallSite(id) =>\n-                        write!(f, \"'{}cs\", id.as_usize()),\n-                    region::ScopeData::Arguments(id) =>\n-                        write!(f, \"'{}as\", id.as_usize()),\n-                    region::ScopeData::Destruction(id) =>\n-                        write!(f, \"'{}ds\", id.as_usize()),\n-                    region::ScopeData::Remainder(BlockRemainder { block, first_statement_index }) =>\n-                        write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n+                ty::ReSkolemized(id, ref bound_region) => {\n+                    write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n                 }\n+\n+                ty::ReEmpty => write!(f, \"ReEmpty\"),\n+\n+                ty::ReErased => write!(f, \"ReErased\")\n             }\n-            ty::ReVar(region_vid) if identify_regions() => {\n-                write!(f, \"'{}rv\", region_vid.index)\n-            }\n-            ty::ReScope(_) |\n-            ty::ReVar(_) |\n-            ty::ReErased => Ok(()),\n-            ty::ReStatic => write!(f, \"'static\"),\n-            ty::ReEmpty => write!(f, \"'<empty>\"),\n         }\n     }\n }\n \n-impl fmt::Debug for ty::FreeRegion {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ReFree({:?}, {:?})\",\n-               self.scope, self.bound_region)\n+define_print! {\n+    () ty::FreeRegion, (self, f, cx) {\n+        debug {\n+            write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)\n+        }\n     }\n }\n \n-impl fmt::Debug for ty::Variance {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(match *self {\n-            ty::Covariant => \"+\",\n-            ty::Contravariant => \"-\",\n-            ty::Invariant => \"o\",\n-            ty::Bivariant => \"*\",\n-        })\n+define_print! {\n+    () ty::Variance, (self, f, cx) {\n+        debug {\n+            f.write_str(match *self {\n+                ty::Covariant => \"+\",\n+                ty::Contravariant => \"-\",\n+                ty::Invariant => \"o\",\n+                ty::Bivariant => \"*\",\n+            })\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::GenericPredicates<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"GenericPredicates({:?})\", self.predicates)\n+define_print! {\n+    ('tcx) ty::GenericPredicates<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"GenericPredicates({:?})\", self.predicates)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"InstantiatedPredicates({:?})\",\n-               self.predicates)\n+define_print! {\n+    ('tcx) ty::InstantiatedPredicates<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"InstantiatedPredicates({:?})\", self.predicates)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.unsafety == hir::Unsafety::Unsafe {\n-            write!(f, \"unsafe \")?;\n-        }\n+define_print! {\n+    ('tcx) ty::FnSig<'tcx>, (self, f, cx) {\n+        display {\n+            if self.unsafety == hir::Unsafety::Unsafe {\n+                write!(f, \"unsafe \")?;\n+            }\n \n-        if self.abi != Abi::Rust {\n-            write!(f, \"extern {} \", self.abi)?;\n-        }\n+            if self.abi != Abi::Rust {\n+                write!(f, \"extern {} \", self.abi)?;\n+            }\n \n-        write!(f, \"fn\")?;\n-        fn_sig(f, self.inputs(), self.variadic, self.output())\n+            write!(f, \"fn\")?;\n+            cx.fn_sig(f, self.inputs(), self.variadic, self.output())\n+        }\n+        debug {\n+            write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n+        }\n     }\n }\n \n@@ -626,21 +854,27 @@ impl fmt::Debug for ty::RegionVid {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::FnSig<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n-    }\n-}\n-\n-impl fmt::Debug for ty::InferTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::TyVar(ref v) => v.fmt(f),\n-            ty::IntVar(ref v) => v.fmt(f),\n-            ty::FloatVar(ref v) => v.fmt(f),\n-            ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n-            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n-            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n+define_print! {\n+    () ty::InferTy, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::TyVar(_) => write!(f, \"_\"),\n+                ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n+                ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n+                ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+            }\n+        }\n+        debug {\n+            match *self {\n+                ty::TyVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::IntVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::FloatVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n+            }\n         }\n     }\n }\n@@ -665,406 +899,393 @@ impl fmt::Debug for ty::IntVarValue {\n     }\n }*/\n \n-impl<'tcx> fmt::Display for ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::TraitRef<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::FnSig<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::TraitPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::EquatePredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::SubtypePredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>,\n-                                                             ty::Region<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n+define_print_multi! {\n+    [\n+    ('tcx) ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n+    ('tcx) ty::Binder<ty::TraitRef<'tcx>>,\n+    ('tcx) ty::Binder<ty::FnSig<'tcx>>,\n+    ('tcx) ty::Binder<ty::TraitPredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::EquatePredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::SubtypePredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::ProjectionPredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n+    ('tcx) ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>\n+    ]\n+    (self, f, cx) {\n+        display {\n+            ty::tls::with(|tcx| cx.in_binder(f, tcx, self, tcx.lift(self)))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        parameterized(f, self.substs, self.def_id, &[])\n+define_print! {\n+    ('tcx) ty::TraitRef<'tcx>, (self, f, cx) {\n+        display {\n+            cx.parameterized(f, self.substs, self.def_id, &[])\n+        }\n+        debug {\n+            // when printing out the debug representation, we don't need\n+            // to enumerate the `for<...>` etc because the debruijn index\n+            // tells you everything you need to know.\n+            print!(f, cx,\n+                   write(\"<\"),\n+                   print(self.self_ty()),\n+                   write(\" as \"))?;\n+            cx.parameterized(f, self.substs, self.def_id, &[])?;\n+            write!(f, \">\")\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::GeneratorInterior<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.witness.fmt(f)\n+define_print! {\n+    ('tcx) ty::GeneratorInterior<'tcx>, (self, f, cx) {\n+        display {\n+            self.witness.print(f, cx)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            TyBool => write!(f, \"bool\"),\n-            TyChar => write!(f, \"char\"),\n-            TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyRawPtr(ref tm) => {\n-                write!(f, \"*{} {}\", match tm.mutbl {\n-                    hir::MutMutable => \"mut\",\n-                    hir::MutImmutable => \"const\",\n-                },  tm.ty)\n-            }\n-            TyRef(r, ref tm) => {\n-                write!(f, \"&\")?;\n-                let s = r.to_string();\n-                write!(f, \"{}\", s)?;\n-                if !s.is_empty() {\n-                    write!(f, \" \")?;\n+define_print! {\n+    ('tcx) ty::TypeVariants<'tcx>, (self, f, cx) {\n+        display {\n+            match *self {\n+                TyBool => write!(f, \"bool\"),\n+                TyChar => write!(f, \"char\"),\n+                TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyRawPtr(ref tm) => {\n+                    write!(f, \"*{} \", match tm.mutbl {\n+                        hir::MutMutable => \"mut\",\n+                        hir::MutImmutable => \"const\",\n+                    })?;\n+                    tm.ty.print(f, cx)\n                 }\n-                write!(f, \"{}\", tm)\n-            }\n-            TyNever => write!(f, \"!\"),\n-            TyTuple(ref tys, _) => {\n-                write!(f, \"(\")?;\n-                let mut tys = tys.iter();\n-                if let Some(&ty) = tys.next() {\n-                    write!(f, \"{},\", ty)?;\n+                TyRef(r, ref tm) => {\n+                    write!(f, \"&\")?;\n+                    let s = r.print_to_string(cx);\n+                    write!(f, \"{}\", s)?;\n+                    if !s.is_empty() {\n+                        write!(f, \" \")?;\n+                    }\n+                    tm.print(f, cx)\n+                }\n+                TyNever => write!(f, \"!\"),\n+                TyTuple(ref tys, _) => {\n+                    write!(f, \"(\")?;\n+                    let mut tys = tys.iter();\n                     if let Some(&ty) = tys.next() {\n-                        write!(f, \" {}\", ty)?;\n-                        for &ty in tys {\n-                            write!(f, \", {}\", ty)?;\n+                        print!(f, cx, print(ty), write(\",\"))?;\n+                        if let Some(&ty) = tys.next() {\n+                            print!(f, cx, write(\" \"), print(ty))?;\n+                            for &ty in tys {\n+                                print!(f, cx, write(\", \"), print(ty))?;\n+                            }\n                         }\n                     }\n+                    write!(f, \")\")\n                 }\n-                write!(f, \")\")\n-            }\n-            TyFnDef(def_id, substs) => {\n-                ty::tls::with(|tcx| {\n-                    let mut sig = tcx.fn_sig(def_id);\n-                    if let Some(substs) = tcx.lift(&substs) {\n-                        sig = sig.subst(tcx, substs);\n+                TyFnDef(def_id, substs) => {\n+                    ty::tls::with(|tcx| {\n+                        let mut sig = tcx.fn_sig(def_id);\n+                        if let Some(substs) = tcx.lift(&substs) {\n+                            sig = sig.subst(tcx, substs);\n+                        }\n+                        print!(f, cx, print(sig), write(\" {{\"))\n+                    })?;\n+                    cx.parameterized(f, substs, def_id, &[])?;\n+                    write!(f, \"}}\")\n+                }\n+                TyFnPtr(ref bare_fn) => {\n+                    bare_fn.print(f, cx)\n+                }\n+                TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n+                TyError => write!(f, \"[type error]\"),\n+                TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n+                TyAdt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n+                TyDynamic(data, r) => {\n+                    data.print(f, cx)?;\n+                    let r = r.print_to_string(cx);\n+                    if !r.is_empty() {\n+                        write!(f, \" + {}\", r)\n+                    } else {\n+                        Ok(())\n                     }\n-                    write!(f, \"{} {{\", sig.0)\n-                })?;\n-                parameterized(f, substs, def_id, &[])?;\n-                write!(f, \"}}\")\n-            }\n-            TyFnPtr(ref bare_fn) => {\n-                write!(f, \"{}\", bare_fn.0)\n-            }\n-            TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n-            TyError => write!(f, \"[type error]\"),\n-            TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-            TyAdt(def, substs) => parameterized(f, substs, def.did, &[]),\n-            TyDynamic(data, r) => {\n-                write!(f, \"{}\", data)?;\n-                let r = r.to_string();\n-                if !r.is_empty() {\n-                    write!(f, \" + {}\", r)\n-                } else {\n-                    Ok(())\n                 }\n-            }\n-            TyProjection(ref data) => write!(f, \"{}\", data),\n-            TyAnon(def_id, substs) => {\n-                ty::tls::with(|tcx| {\n-                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                    // by looking up the projections associated with the def_id.\n-                    let predicates_of = tcx.predicates_of(def_id);\n-                    let substs = tcx.lift(&substs).unwrap_or_else(|| {\n-                        tcx.intern_substs(&[])\n-                    });\n-                    let bounds = predicates_of.instantiate(tcx, substs);\n-\n-                    let mut first = true;\n-                    let mut is_sized = false;\n-                    write!(f, \"impl\")?;\n-                    for predicate in bounds.predicates {\n-                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                            // Don't print +Sized, but rather +?Sized if absent.\n-                            if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n-                                is_sized = true;\n-                                continue;\n+                TyProjection(ref data) => data.print(f, cx),\n+                TyAnon(def_id, substs) => {\n+                    ty::tls::with(|tcx| {\n+                        // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                        // by looking up the projections associated with the def_id.\n+                        let predicates_of = tcx.predicates_of(def_id);\n+                        let substs = tcx.lift(&substs).unwrap_or_else(|| {\n+                            tcx.intern_substs(&[])\n+                        });\n+                        let bounds = predicates_of.instantiate(tcx, substs);\n+\n+                        let mut first = true;\n+                        let mut is_sized = false;\n+                        write!(f, \"impl\")?;\n+                        for predicate in bounds.predicates {\n+                            if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                                // Don't print +Sized, but rather +?Sized if absent.\n+                                if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n+                                    is_sized = true;\n+                                    continue;\n+                                }\n+\n+                                print!(f, cx,\n+                                       write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                       print(trait_ref))?;\n+                                first = false;\n                             }\n-\n-                            write!(f, \"{}{}\", if first { \" \" } else { \"+\" }, trait_ref)?;\n-                            first = false;\n                         }\n-                    }\n-                    if !is_sized {\n-                        write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n-                    }\n-                    Ok(())\n-                })\n-            }\n-            TyStr => write!(f, \"str\"),\n-            TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n-                let upvar_tys = substs.upvar_tys(did, tcx);\n-                write!(f, \"[generator\")?;\n-\n-                if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n-                    write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n-                    let mut sep = \" \";\n-                    tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                            write!(f,\n-                                        \"{}{}:{}\",\n-                                        sep,\n-                                        tcx.hir.name(freevar.var_id()),\n-                                        upvar_ty)?;\n-                            sep = \", \";\n+                        if !is_sized {\n+                            write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n                         }\n                         Ok(())\n-                    })?\n-                } else {\n-                    // cross-crate closure types should only be\n-                    // visible in trans bug reports, I imagine.\n-                    write!(f, \"@{:?}\", did)?;\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n-                        sep = \", \";\n-                    }\n+                    })\n                 }\n+                TyStr => write!(f, \"str\"),\n+                TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n+                    let upvar_tys = substs.upvar_tys(did, tcx);\n+                    write!(f, \"[generator\")?;\n \n-                write!(f, \" {}\", interior)?;\n-\n-                write!(f, \"]\")\n-            }),\n-            TyClosure(did, substs) => ty::tls::with(|tcx| {\n-                let upvar_tys = substs.upvar_tys(did, tcx);\n-                write!(f, \"[closure\")?;\n-\n-                if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n-                    if tcx.sess.opts.debugging_opts.span_free_formats {\n-                        write!(f, \"@{:?}\", node_id)?;\n-                    } else {\n+                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n                         write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n-                    }\n-                    let mut sep = \" \";\n-                    tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                            write!(f,\n-                                        \"{}{}:{}\",\n-                                        sep,\n-                                        tcx.hir.name(freevar.var_id()),\n-                                        upvar_ty)?;\n+                        let mut sep = \" \";\n+                        tcx.with_freevars(node_id, |freevars| {\n+                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n+                                print!(f, cx,\n+                                       write(\"{}{}:\",\n+                                             sep,\n+                                             tcx.hir.name(freevar.var_id())),\n+                                       print(upvar_ty))?;\n+                                sep = \", \";\n+                            }\n+                            Ok(())\n+                        })?\n+                    } else {\n+                        // cross-crate closure types should only be\n+                        // visible in trans bug reports, I imagine.\n+                        write!(f, \"@{:?}\", did)?;\n+                        let mut sep = \" \";\n+                        for (index, upvar_ty) in upvar_tys.enumerate() {\n+                            print!(f, cx,\n+                                   write(\"{}{}:\", sep, index),\n+                                   print(upvar_ty))?;\n                             sep = \", \";\n                         }\n-                        Ok(())\n-                    })?\n-                } else {\n-                    // cross-crate closure types should only be\n-                    // visible in trans bug reports, I imagine.\n-                    write!(f, \"@{:?}\", did)?;\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n-                        sep = \", \";\n                     }\n-                }\n \n-                write!(f, \"]\")\n-            }),\n-            TyArray(ty, sz) => {\n-                write!(f, \"[{}; \", ty)?;\n-                match sz.val {\n-                    ConstVal::Integral(ConstInt::Usize(sz)) => {\n-                        write!(f, \"{}\", sz)?;\n-                    }\n-                    ConstVal::Unevaluated(_def_id, substs) => {\n-                        write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n+                    print!(f, cx, write(\" \"), print(interior), write(\"]\"))\n+                }),\n+                TyClosure(did, substs) => ty::tls::with(|tcx| {\n+                    let upvar_tys = substs.upvar_tys(did, tcx);\n+                    write!(f, \"[closure\")?;\n+\n+                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n+                        if tcx.sess.opts.debugging_opts.span_free_formats {\n+                            write!(f, \"@{:?}\", node_id)?;\n+                        } else {\n+                            write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n+                        }\n+                        let mut sep = \" \";\n+                        tcx.with_freevars(node_id, |freevars| {\n+                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n+                                print!(f, cx,\n+                                       write(\"{}{}:\",\n+                                             sep,\n+                                             tcx.hir.name(freevar.var_id())),\n+                                       print(upvar_ty))?;\n+                                sep = \", \";\n+                            }\n+                            Ok(())\n+                        })?\n+                    } else {\n+                        // cross-crate closure types should only be\n+                        // visible in trans bug reports, I imagine.\n+                        write!(f, \"@{:?}\", did)?;\n+                        let mut sep = \" \";\n+                        for (index, upvar_ty) in upvar_tys.enumerate() {\n+                            print!(f, cx,\n+                                   write(\"{}{}:\", sep, index),\n+                                   print(upvar_ty))?;\n+                            sep = \", \";\n+                        }\n                     }\n-                    _ => {\n-                        write!(f, \"{:?}\", sz)?;\n+\n+                    write!(f, \"]\")\n+                }),\n+                TyArray(ty, sz) => {\n+                    print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n+                    match sz.val {\n+                        ConstVal::Integral(ConstInt::Usize(sz)) => {\n+                            write!(f, \"{}\", sz)?;\n+                        }\n+                        ConstVal::Unevaluated(_def_id, substs) => {\n+                            write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n+                        }\n+                        _ => {\n+                            write!(f, \"{:?}\", sz)?;\n+                        }\n                     }\n+                    write!(f, \"]\")\n+                }\n+                TySlice(ty) => {\n+                    print!(f, cx, write(\"[\"), print(ty), write(\"]\"))\n                 }\n-                write!(f, \"]\")\n             }\n-            TySlice(ty) => write!(f, \"[{}]\",  ty)\n         }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TyS<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.sty)\n-    }\n-}\n-\n-impl fmt::Debug for ty::UpvarId {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n-               self.var_id,\n-               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_id))),\n-               self.closure_expr_id)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"UpvarBorrow({:?}, {:?})\",\n-               self.kind, self.region)\n-    }\n-}\n-\n-impl fmt::Display for ty::InferTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let print_var_ids = verbose();\n-        match *self {\n-            ty::TyVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::IntVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::FloatVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::TyVar(_) => write!(f, \"_\"),\n-            ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n-            ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n-            ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n-            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+define_print! {\n+    ('tcx) ty::TyS<'tcx>, (self, f, cx) {\n+        display {\n+            self.sty.print(f, cx)\n+        }\n+        debug {\n+            self.sty.print_display(f, cx)\n         }\n     }\n }\n \n-impl fmt::Display for ty::ParamTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.name)\n-    }\n-}\n-\n-impl fmt::Debug for ty::ParamTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}/#{}\", self, self.idx)\n-    }\n-}\n-\n-impl<'tcx, T, U> fmt::Display for ty::OutlivesPredicate<T,U>\n-    where T: fmt::Display, U: fmt::Display\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} : {}\", self.0, self.1)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::EquatePredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} == {}\", self.0, self.1)\n+define_print! {\n+    () ty::ParamTy, (self, f, cx) {\n+        display {\n+            write!(f, \"{}\", self.name)\n+        }\n+        debug {\n+            write!(f, \"{}/#{}\", self.name, self.idx)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::SubtypePredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} <: {}\", self.a, self.b)\n+define_print! {\n+    ('tcx, T: Print + fmt::Debug, U: Print + fmt::Debug) ty::OutlivesPredicate<T, U>,\n+    (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.0), write(\" : \"), print(self.1))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TraitPredicate({:?})\",\n-               self.trait_ref)\n+define_print! {\n+    ('tcx) ty::EquatePredicate<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.0), write(\" == \"), print(self.1))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TraitPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}: {}\", self.trait_ref.self_ty(), self.trait_ref)\n+define_print! {\n+    ('tcx) ty::SubtypePredicate<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.a), write(\" <: \"), print(self.b))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ProjectionPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ProjectionPredicate({:?}, {:?})\",\n-               self.projection_ty,\n-               self.ty)\n+define_print! {\n+    ('tcx) ty::TraitPredicate<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"TraitPredicate({:?})\",\n+                   self.trait_ref)\n+        }\n+        display {\n+            print!(f, cx, print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::ProjectionPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} == {}\",\n-               self.projection_ty,\n-               self.ty)\n+define_print! {\n+    ('tcx) ty::ProjectionPredicate<'tcx>, (self, f, cx) {\n+        debug {\n+            print!(f, cx,\n+                   write(\"ProjectionPredicate(\"),\n+                   print(self.projection_ty),\n+                   write(\", \"),\n+                   print(self.ty),\n+                   write(\")\"))\n+        }\n+        display {\n+            print!(f, cx, print(self.projection_ty), write(\" == \"), print(self.ty))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::ProjectionTy<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // FIXME(tschottdorf): use something like\n-        //   parameterized(f, self.substs, self.item_def_id, &[])\n-        // (which currently ICEs).\n-        let (trait_ref, item_name) = ty::tls::with(|tcx|\n-            (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).name)\n-        );\n-        write!(f, \"{:?}::{}\",\n-               trait_ref,\n-               item_name)\n+define_print! {\n+    ('tcx) ty::ProjectionTy<'tcx>, (self, f, cx) {\n+        display {\n+            // FIXME(tschottdorf): use something like\n+            //   parameterized(f, self.substs, self.item_def_id, &[])\n+            // (which currently ICEs).\n+            let (trait_ref, item_name) = ty::tls::with(|tcx|\n+                (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).name)\n+            );\n+            print!(f, cx, print_debug(trait_ref), write(\"::{}\", item_name))\n+        }\n     }\n }\n \n-impl fmt::Display for ty::ClosureKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::ClosureKind::Fn => write!(f, \"Fn\"),\n-            ty::ClosureKind::FnMut => write!(f, \"FnMut\"),\n-            ty::ClosureKind::FnOnce => write!(f, \"FnOnce\"),\n+define_print! {\n+    () ty::ClosureKind, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::ClosureKind::Fn => write!(f, \"Fn\"),\n+                ty::ClosureKind::FnMut => write!(f, \"FnMut\"),\n+                ty::ClosureKind::FnOnce => write!(f, \"FnOnce\"),\n+            }\n         }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::Predicate::Trait(ref data) => write!(f, \"{}\", data),\n-            ty::Predicate::Equate(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::Subtype(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::RegionOutlives(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::TypeOutlives(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::Projection(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::WellFormed(ty) => write!(f, \"{} well-formed\", ty),\n-            ty::Predicate::ObjectSafe(trait_def_id) =>\n-                ty::tls::with(|tcx| {\n-                    write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n-                }),\n-            ty::Predicate::ClosureKind(closure_def_id, kind) =>\n-                ty::tls::with(|tcx| {\n-                    write!(f, \"the closure `{}` implements the trait `{}`\",\n-                           tcx.item_path_str(closure_def_id), kind)\n-                }),\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                write!(f, \"the constant `\")?;\n-                parameterized(f, substs, def_id, &[])?;\n-                write!(f, \"` can be evaluated\")\n+define_print! {\n+    ('tcx) ty::Predicate<'tcx>, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::Predicate::Trait(ref data) => data.print(f, cx),\n+                ty::Predicate::Equate(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::Subtype(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::RegionOutlives(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::TypeOutlives(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::Projection(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::WellFormed(ty) => print!(f, cx, print(ty), write(\" well-formed\")),\n+                ty::Predicate::ObjectSafe(trait_def_id) =>\n+                    ty::tls::with(|tcx| {\n+                        write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n+                    }),\n+                ty::Predicate::ClosureKind(closure_def_id, kind) =>\n+                    ty::tls::with(|tcx| {\n+                        write!(f, \"the closure `{}` implements the trait `{}`\",\n+                               tcx.item_path_str(closure_def_id), kind)\n+                    }),\n+                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                    write!(f, \"the constant `\")?;\n+                    cx.parameterized(f, substs, def_id, &[])?;\n+                    write!(f, \"` can be evaluated\")\n+                }\n+            }\n+        }\n+        debug {\n+            match *self {\n+                ty::Predicate::Trait(ref a) => a.print(f, cx),\n+                ty::Predicate::Equate(ref pair) => pair.print(f, cx),\n+                ty::Predicate::Subtype(ref pair) => pair.print(f, cx),\n+                ty::Predicate::RegionOutlives(ref pair) => pair.print(f, cx),\n+                ty::Predicate::TypeOutlives(ref pair) => pair.print(f, cx),\n+                ty::Predicate::Projection(ref pair) => pair.print(f, cx),\n+                ty::Predicate::WellFormed(ty) => ty.print(f, cx),\n+                ty::Predicate::ObjectSafe(trait_def_id) => {\n+                    write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+                }\n+                ty::Predicate::ClosureKind(closure_def_id, kind) => {\n+                    write!(f, \"ClosureKind({:?}, {:?})\", closure_def_id, kind)\n+                }\n+                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                    write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n+                }\n             }\n         }\n     }"}, {"sha": "cdba559445d195be1a4636a496ed0b57fa8467b0", "filename": "src/test/compile-fail/hygiene/impl_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -19,7 +19,7 @@ mod foo {\n     }\n \n     pub macro m() {\n-        let _: () = S.f(); //~ ERROR type `fn(&foo::S) {foo::S::f}` is private\n+        let _: () = S.f(); //~ ERROR type `for<'r> fn(&'r foo::S) {foo::S::f}` is private\n     }\n }\n "}, {"sha": "85d91bb2db202dd6dcb1681cb4ed1e1ef8fe4505", "filename": "src/test/compile-fail/issue-12997-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -15,6 +15,6 @@\n #[bench]\n fn bar(x: isize) { }\n //~^ ERROR mismatched types\n-//~| expected type `fn(&mut __test::test::Bencher)`\n+//~| expected type `for<'r> fn(&'r mut __test::test::Bencher)`\n //~| found type `fn(isize) {bar}`\n //~| expected mutable reference, found isize"}, {"sha": "c0ba38b240202ece9a41e16605b858f6cd9ef7f1", "filename": "src/test/compile-fail/private-inferred-type-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -15,7 +15,7 @@\n // error-pattern:type `fn() {<u8 as ext::PrivTrait>::method}` is private\n // error-pattern:type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct::{{constructor}}}` is pr\n // error-pattern:type `fn(u8) -> ext::PubTupleStruct {ext::PubTupleStruct::{{constructor}}}` is priv\n-// error-pattern:type `fn(&ext::Pub<u8>) {<ext::Pub<u8>>::priv_method}` is private\n+// error-pattern:type `for<'r> fn(&'r ext::Pub<u8>) {<ext::Pub<u8>>::priv_method}` is private\n \n #![feature(decl_macro)]\n "}, {"sha": "95e3732d6134278e980b0b2f44c45fea2af88e14", "filename": "src/test/compile-fail/private-inferred-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -56,7 +56,7 @@ mod m {\n         PubTupleStruct;\n         //~^ ERROR type `fn(u8) -> m::PubTupleStruct {m::PubTupleStruct::{{constructor}}}` is privat\n         Pub(0u8).priv_method();\n-        //~^ ERROR type `fn(&m::Pub<u8>) {<m::Pub<u8>>::priv_method}` is private\n+        //~^ ERROR type `for<'r> fn(&'r m::Pub<u8>) {<m::Pub<u8>>::priv_method}` is private\n     }\n \n     trait Trait {}"}, {"sha": "6be65a5e35905194fe710c4d12a16d0f238aa32c", "filename": "src/test/compile-fail/regions-fn-subtyping-return-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -58,8 +58,8 @@ fn supply_G() {\n     want_G(bar);\n     want_G(baz);\n     //~^ ERROR mismatched types\n-    //~| expected type `fn(&'cx S) -> &'static S`\n-    //~| found type `fn(&S) -> &S {baz}`\n+    //~| expected type `for<'cx> fn(&'cx S) -> &'static S`\n+    //~| found type `for<'r> fn(&'r S) -> &'r S {baz}`\n     //~| expected concrete lifetime, found bound lifetime parameter 'cx\n }\n "}, {"sha": "39f43e4e990cd0eecb4e064f483ef6cd129d7c4c", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -57,7 +57,7 @@ fn main() {\n // START rustc.node50.EraseRegions.after.mir\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(50)], _2: &ReErased mut i32) -> i32 {\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[8cd8]::main[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(50)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(50)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n //         _3 = _2;\n //         StorageLive(_4);"}, {"sha": "b670d8094dd53d8fca9ccc5a19eb83b1fcc3e675", "filename": "src/test/mir-opt/validate_4.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -48,8 +48,8 @@ fn main() {\n // START rustc.node22.EraseRegions.after.mir\n // fn write_42::{{closure}}(_1: &ReErased [closure@NodeId(22)], _2: *mut i32) -> () {\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[8cd8]::write_42[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(22)], _2: *mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[8cd8]::write_42[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(22)], _2: *mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[8cd8]::write_42[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[8cd8]::write_42[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n //         StorageLive(_3);\n //         _3 = _2;\n //         (*_3) = const 23i32;\n@@ -74,8 +74,8 @@ fn main() {\n // START rustc.node60.EraseRegions.after.mir\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(60)], _2: &ReErased mut i32) -> bool {\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n //         _0 = const write_42(_4) -> bb1;\n //     }"}, {"sha": "059d3adb407aacef2d5f46280033f7c75567ad72", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -45,7 +45,7 @@ fn main() {\n // START rustc.node46.EraseRegions.after.mir\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(46)], _2: &ReErased mut i32) -> bool {\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[8cd8]::main[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(46)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(46)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n //         _3 = _2;\n //         StorageLive(_4);"}, {"sha": "02b8425d88beedb2486b8fdfb7345d2689568742", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -40,31 +40,31 @@\n \n \n                   ((::fmt::format as\n-                       fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((<::std::fmt::Arguments>::new_v1\n-                                                                                                   as\n-                                                                                                   fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})((&([(\"test\"\n-                                                                                                                                                                                                                  as\n-                                                                                                                                                                                                                  &'static str)]\n-                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                [&str; 1])\n-                                                                                                                                                                                                              as\n-                                                                                                                                                                                                              &[&str; 1]),\n-                                                                                                                                                                                                          (&(match (()\n-                                                                                                                                                                                                                       as\n-                                                                                                                                                                                                                       ())\n-                                                                                                                                                                                                                 {\n-                                                                                                                                                                                                                 ()\n-                                                                                                                                                                                                                 =>\n-                                                                                                                                                                                                                 ([]\n-                                                                                                                                                                                                                     as\n-                                                                                                                                                                                                                     [std::fmt::ArgumentV1<'_>; 0]),\n-                                                                                                                                                                                                             }\n-                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                [std::fmt::ArgumentV1<'_>; 0])\n-                                                                                                                                                                                                              as\n-                                                                                                                                                                                                              &[std::fmt::ArgumentV1<'_>; 0]))\n-                                                                                                  as\n-                                                                                                  std::fmt::Arguments<'_>))\n+                       for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<::std::fmt::Arguments>::new_v1\n+                                                                                                           as\n+                                                                                                           fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})((&([(\"test\"\n+                                                                                                                                                                                                                          as\n+                                                                                                                                                                                                                          &'static str)]\n+                                                                                                                                                                                                                        as\n+                                                                                                                                                                                                                        [&str; 1])\n+                                                                                                                                                                                                                      as\n+                                                                                                                                                                                                                      &[&str; 1]),\n+                                                                                                                                                                                                                  (&(match (()\n+                                                                                                                                                                                                                               as\n+                                                                                                                                                                                                                               ())\n+                                                                                                                                                                                                                         {\n+                                                                                                                                                                                                                         ()\n+                                                                                                                                                                                                                         =>\n+                                                                                                                                                                                                                         ([]\n+                                                                                                                                                                                                                             as\n+                                                                                                                                                                                                                             [std::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                                     }\n+                                                                                                                                                                                                                        as\n+                                                                                                                                                                                                                        [std::fmt::ArgumentV1<'_>; 0])\n+                                                                                                                                                                                                                      as\n+                                                                                                                                                                                                                      &[std::fmt::ArgumentV1<'_>; 0]))\n+                                                                                                          as\n+                                                                                                          std::fmt::Arguments<'_>))\n                       as std::string::String);\n               } as ())\n pub type Foo = [i32; (3 as usize)];"}, {"sha": "f2d04c16d99e146682c315858c4578b6cb96aa77", "filename": "src/test/ui/anonymous-higher-ranked-lifetime.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.rs?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    f1(|_: (), _: ()| {});\n+    f2(|_: (), _: ()| {});\n+    f3(|_: (), _: ()| {});\n+    f4(|_: (), _: ()| {});\n+    f5(|_: (), _: ()| {});\n+    g1(|_: (), _: ()| {});\n+    g2(|_: (), _: ()| {});\n+    g3(|_: (), _: ()| {});\n+    g4(|_: (), _: ()| {});\n+    h1(|_: (), _: (), _: (), _: ()| {});\n+    h2(|_: (), _: (), _: (), _: ()| {});\n+}\n+\n+// Basic\n+fn f1<F>(_: F) where F: Fn(&(), &()) {}\n+fn f2<F>(_: F) where F: for<'a> Fn(&'a (), &()) {}\n+fn f3<'a, F>(_: F) where F: Fn(&'a (), &()) {}\n+fn f4<F>(_: F) where F: for<'r> Fn(&(), &'r ()) {}\n+fn f5<F>(_: F) where F: for<'r> Fn(&'r (), &'r ()) {}\n+\n+// Nested\n+fn g1<F>(_: F) where F: Fn(&(), Box<Fn(&())>) {}\n+fn g2<F>(_: F) where F: Fn(&(), fn(&())) {}\n+fn g3<F>(_: F) where F: for<'s> Fn(&'s (), Box<Fn(&())>) {}\n+fn g4<F>(_: F) where F: Fn(&(), for<'r> fn(&'r ())) {}\n+\n+// Mixed\n+fn h1<F>(_: F) where F: Fn(&(), Box<Fn(&())>, &(), fn(&(), &())) {}\n+fn h2<F>(_: F) where F: for<'t0> Fn(&(), Box<Fn(&())>, &'t0 (), fn(&(), &())) {}"}, {"sha": "f962b7722036b6c1a82b093fd88a7ac3dcd9432e", "filename": "src/test/ui/anonymous-higher-ranked-lifetime.stderr", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fanonymous-higher-ranked-lifetime.stderr?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -0,0 +1,112 @@\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:12:5\n+   |\n+12 |     f1(|_: (), _: ()| {});\n+   |     ^^ ----------------- found signature of `fn((), ()) -> _`\n+   |     |\n+   |     expected signature of `for<'r, 's> fn(&'r (), &'s ()) -> _`\n+   |\n+   = note: required by `f1`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:13:5\n+   |\n+13 |     f2(|_: (), _: ()| {});\n+   |     ^^ ----------------- found signature of `fn((), ()) -> _`\n+   |     |\n+   |     expected signature of `for<'a, 'r> fn(&'a (), &'r ()) -> _`\n+   |\n+   = note: required by `f2`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:14:5\n+   |\n+14 |     f3(|_: (), _: ()| {});\n+   |     ^^ ----------------- found signature of `fn((), ()) -> _`\n+   |     |\n+   |     expected signature of `for<'r> fn(&(), &'r ()) -> _`\n+   |\n+   = note: required by `f3`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:15:5\n+   |\n+15 |     f4(|_: (), _: ()| {});\n+   |     ^^ ----------------- found signature of `fn((), ()) -> _`\n+   |     |\n+   |     expected signature of `for<'s, 'r> fn(&'s (), &'r ()) -> _`\n+   |\n+   = note: required by `f4`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:16:5\n+   |\n+16 |     f5(|_: (), _: ()| {});\n+   |     ^^ ----------------- found signature of `fn((), ()) -> _`\n+   |     |\n+   |     expected signature of `for<'r> fn(&'r (), &'r ()) -> _`\n+   |\n+   = note: required by `f5`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:17:5\n+   |\n+17 |     g1(|_: (), _: ()| {});\n+   |     ^^ ----------------- found signature of `fn((), ()) -> _`\n+   |     |\n+   |     expected signature of `for<'r> fn(&'r (), std::boxed::Box<for<'s> std::ops::Fn(&'s ()) + 'static>) -> _`\n+   |\n+   = note: required by `g1`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:18:5\n+   |\n+18 |     g2(|_: (), _: ()| {});\n+   |     ^^ ----------------- found signature of `fn((), ()) -> _`\n+   |     |\n+   |     expected signature of `for<'r> fn(&'r (), for<'s> fn(&'s ())) -> _`\n+   |\n+   = note: required by `g2`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:19:5\n+   |\n+19 |     g3(|_: (), _: ()| {});\n+   |     ^^ ----------------- found signature of `fn((), ()) -> _`\n+   |     |\n+   |     expected signature of `for<'s> fn(&'s (), std::boxed::Box<for<'r> std::ops::Fn(&'r ()) + 'static>) -> _`\n+   |\n+   = note: required by `g3`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:20:5\n+   |\n+20 |     g4(|_: (), _: ()| {});\n+   |     ^^ ----------------- found signature of `fn((), ()) -> _`\n+   |     |\n+   |     expected signature of `for<'s> fn(&'s (), for<'r> fn(&'r ())) -> _`\n+   |\n+   = note: required by `g4`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:21:5\n+   |\n+21 |     h1(|_: (), _: (), _: (), _: ()| {});\n+   |     ^^ ------------------------------- found signature of `fn((), (), (), ()) -> _`\n+   |     |\n+   |     expected signature of `for<'r, 's> fn(&'r (), std::boxed::Box<for<'t0> std::ops::Fn(&'t0 ()) + 'static>, &'s (), for<'t0, 't1> fn(&'t0 (), &'t1 ())) -> _`\n+   |\n+   = note: required by `h1`\n+\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/anonymous-higher-ranked-lifetime.rs:22:5\n+   |\n+22 |     h2(|_: (), _: (), _: (), _: ()| {});\n+   |     ^^ ------------------------------- found signature of `fn((), (), (), ()) -> _`\n+   |     |\n+   |     expected signature of `for<'r, 't0> fn(&'r (), std::boxed::Box<for<'s> std::ops::Fn(&'s ()) + 'static>, &'t0 (), for<'s, 't1> fn(&'s (), &'t1 ())) -> _`\n+   |\n+   = note: required by `h2`\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "4a97537223cf6afabaa7d27a1b987982ee5ac83a", "filename": "src/test/ui/regions-fn-subtyping-return-static.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf5d39cca2e837c7a9880e69e110e714d19c6aa/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static.stderr?ref=cbf5d39cca2e837c7a9880e69e110e714d19c6aa", "patch": "@@ -4,8 +4,8 @@ error[E0308]: mismatched types\n 51 |     want_F(bar); //~ ERROR E0308\n    |            ^^^ expected concrete lifetime, found bound lifetime parameter 'cx\n    |\n-   = note: expected type `fn(&'cx S) -> &'cx S`\n-              found type `fn(&'a S) -> &S {bar::<'_>}`\n+   = note: expected type `for<'cx> fn(&'cx S) -> &'cx S`\n+              found type `for<'a> fn(&'a S) -> &S {bar::<'_>}`\n \n error: aborting due to previous error\n "}]}