{"sha": "8e4be2708635818aa3e210f0e39fb871cc433004", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNGJlMjcwODYzNTgxOGFhM2UyMTBmMGUzOWZiODcxY2M0MzMwMDQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-10T11:42:42Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-10T11:42:42Z"}, "message": "Merge #774\n\n774: Batch crate & command r=matklad a=flodiebold\n\nThis adds a new crate, `ra_batch`, which is intended for scenarios where you're loading a workspace once and then running some analyses using the HIR API. Also, it adds a command to `ra_cli` which uses that to type-check all crates in a workspace and print some statistics:\r\n\r\nE.g. in rust-analyzer:\r\n```\r\n> $ time target/release/ra_cli analysis-stats\r\nDatabase loaded, 21 roots\r\nCrates in this dir: 28\r\nTotal modules found: 231\r\nTotal declarations: 3694\r\nTotal functions: 2408\r\nTotal expressions: 47017\r\nExpressions of unknown type: 19826 (42%)\r\nExpressions of partially unknown type: 4482 (9%)\r\ntarget/release/ra_cli analysis-stats  3,23s user 0,60s system 100% cpu 3,821 total\r\n```\r\n\r\nOr in rust-lang/rust:\r\n```\r\n> $ time ../opensource/rust-analyzer/target/release/ra_cli analysis-stats\r\nDatabase loaded, 77 roots\r\nCrates in this dir: 130\r\nTotal modules found: 1820\r\nTotal declarations: 35038\r\nTotal functions: 25914\r\nTotal expressions: 753678\r\nExpressions of unknown type: 337975 (44%)\r\nExpressions of partially unknown type: 92314 (12%)\r\n../opensource/rust-analyzer/target/release/ra_cli analysis-stats  13,45s user 2,08s system 100% cpu 15,477 total\r\n```\r\n\r\n~This still needs a test. Type-checking all of rust-analyzer sadly takes almost a minute when compiled in debug mode :sweat_smile: So I'll need to add something simpler (maybe just looking at a few modules).~\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "569110cbb504c0516b136c414610b0f2edbe5044", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/569110cbb504c0516b136c414610b0f2edbe5044"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e4be2708635818aa3e210f0e39fb871cc433004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e4be2708635818aa3e210f0e39fb871cc433004", "html_url": "https://github.com/rust-lang/rust/commit/8e4be2708635818aa3e210f0e39fb871cc433004", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e4be2708635818aa3e210f0e39fb871cc433004/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "01b15c9fc2ce128149872ffe02de022bdb157286", "url": "https://api.github.com/repos/rust-lang/rust/commits/01b15c9fc2ce128149872ffe02de022bdb157286", "html_url": "https://github.com/rust-lang/rust/commit/01b15c9fc2ce128149872ffe02de022bdb157286"}, {"sha": "2e9194a621ccb33872d6189ecc30a83c17e6e33a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e9194a621ccb33872d6189ecc30a83c17e6e33a", "html_url": "https://github.com/rust-lang/rust/commit/2e9194a621ccb33872d6189ecc30a83c17e6e33a"}], "stats": {"total": 435, "additions": 429, "deletions": 6}, "files": [{"sha": "0a5bec2bf24689d3d158b09e60cb1847b0a38c70", "filename": "Cargo.lock", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -486,6 +486,18 @@ name = \"indexmap\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"indicatif\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"console 0.7.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"number_prefix 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"inotify\"\n version = \"0.6.1\"\n@@ -780,6 +792,14 @@ dependencies = [\n  \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"number_prefix\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"owning_ref\"\n version = \"0.4.0\"\n@@ -909,13 +929,33 @@ dependencies = [\n  \"test_utils 0.1.0\",\n ]\n \n+[[package]]\n+name = \"ra_batch\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_db 0.1.0\",\n+ \"ra_hir 0.1.0\",\n+ \"ra_project_model 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+ \"ra_vfs 0.1.0\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"test_utils 0.1.0\",\n+]\n+\n [[package]]\n name = \"ra_cli\"\n version = \"0.1.0\"\n dependencies = [\n  \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.10.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"indicatif 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_batch 0.1.0\",\n+ \"ra_db 0.1.0\",\n+ \"ra_hir 0.1.0\",\n  \"ra_ide_api_light 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"tools 0.1.0\",\n@@ -1934,6 +1974,7 @@ dependencies = [\n \"checksum idna 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38f09e0f0b1fb55fdee1f17470ad800da77af5186a1a76c026b679358b7e844e\"\n \"checksum im 12.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0627d417829c1d763d602687634869f254fc79f7e22dea6c824dab993db857e4\"\n \"checksum indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e81a7c05f79578dbc15793d8b619db9ba32b4577003ef3af1a91c416798c58d\"\n+\"checksum indicatif 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2c60da1c9abea75996b70a931bba6c750730399005b61ccd853cee50ef3d0d0c\"\n \"checksum inotify 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40b54539f3910d6f84fbf9a643efd6e3aa6e4f001426c0329576128255994718\"\n \"checksum inotify-sys 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e74a1aa87c59aeff6ef2cc2fa62d41bc43f54952f55652656b18a02fd5e356c0\"\n \"checksum insta 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcdfb5ab565a1fc5c397722d5a9503f2095696ef07ef1a222d85a0fd6666c6aa\"\n@@ -1967,6 +2008,7 @@ dependencies = [\n \"checksum num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e83d528d2677f0518c570baf2b7abdcf0cd2d248860b68507bdcb3e91d4c0cea\"\n \"checksum num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0b3a5d7cc97d6d30d8b9bc8fa19bf45349ffe46241e8816f50f62f6d6aaabee1\"\n \"checksum num_cpus 1.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5a69d464bdc213aaaff628444e99578ede64e9c854025aa43b9796530afa9238\"\n+\"checksum number_prefix 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbf9993e59c894e3c08aa1c2712914e9e6bf1fcbfc6bef283e2183df345a4fee\"\n \"checksum owning_ref 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49a4b8ea2179e6a2e27411d3bca09ca6dd630821cf6894c6c7c8467a8ee7ef13\"\n \"checksum parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab41b4aed082705d1056416ae4468b6ea99d52599ecf3169b00088d43113e337\"\n \"checksum parking_lot_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94c8c7923936b28d546dfd14d4472eaf34c99b14e1c973a32b3e6d4eb04298c9\""}, {"sha": "30a0749c7e62def0958e88a0f09eb2164b3fb34d", "filename": "crates/ra_batch/Cargo.toml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_batch%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_batch%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2FCargo.toml?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -0,0 +1,20 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_batch\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n+\n+[dependencies]\n+log = \"0.4.5\"\n+rustc-hash = \"1.0\"\n+\n+failure = \"0.1.4\"\n+\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_hir = { path = \"../ra_hir\" }\n+ra_vfs = { path = \"../ra_vfs\" }\n+ra_project_model = { path = \"../ra_project_model\" }\n+\n+[dev-dependencies]\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "837fff4dce5eec6661e3b9050651d2551c656399", "filename": "crates/ra_batch/src/lib.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_batch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_batch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2Fsrc%2Flib.rs?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -0,0 +1,151 @@\n+use std::sync::Arc;\n+use std::path::Path;\n+use std::collections::HashSet;\n+\n+use rustc_hash::FxHashMap;\n+\n+use ra_db::{\n+    CrateGraph, FileId, SourceRoot, SourceRootId, SourceDatabase, salsa,\n+};\n+use ra_hir::{db, HirInterner};\n+use ra_project_model::ProjectWorkspace;\n+use ra_vfs::{Vfs, VfsChange};\n+\n+type Result<T> = std::result::Result<T, failure::Error>;\n+\n+#[salsa::database(\n+    ra_db::SourceDatabaseStorage,\n+    db::HirDatabaseStorage,\n+    db::PersistentHirDatabaseStorage\n+)]\n+#[derive(Debug)]\n+pub struct BatchDatabase {\n+    runtime: salsa::Runtime<BatchDatabase>,\n+    interner: Arc<HirInterner>,\n+}\n+\n+impl salsa::Database for BatchDatabase {\n+    fn salsa_runtime(&self) -> &salsa::Runtime<BatchDatabase> {\n+        &self.runtime\n+    }\n+}\n+\n+impl AsRef<HirInterner> for BatchDatabase {\n+    fn as_ref(&self) -> &HirInterner {\n+        &self.interner\n+    }\n+}\n+\n+fn vfs_file_to_id(f: ra_vfs::VfsFile) -> FileId {\n+    FileId(f.0.into())\n+}\n+fn vfs_root_to_id(r: ra_vfs::VfsRoot) -> SourceRootId {\n+    SourceRootId(r.0.into())\n+}\n+\n+impl BatchDatabase {\n+    pub fn load(crate_graph: CrateGraph, vfs: &mut Vfs) -> BatchDatabase {\n+        let mut db =\n+            BatchDatabase { runtime: salsa::Runtime::default(), interner: Default::default() };\n+        db.set_crate_graph(Arc::new(crate_graph));\n+\n+        // wait until Vfs has loaded all roots\n+        let receiver = vfs.task_receiver().clone();\n+        let mut roots_loaded = HashSet::new();\n+        for task in receiver {\n+            vfs.handle_task(task);\n+            let mut done = false;\n+            for change in vfs.commit_changes() {\n+                match change {\n+                    VfsChange::AddRoot { root, files } => {\n+                        let source_root_id = vfs_root_to_id(root);\n+                        log::debug!(\n+                            \"loaded source root {:?} with path {:?}\",\n+                            source_root_id,\n+                            vfs.root2path(root)\n+                        );\n+                        let mut file_map = FxHashMap::default();\n+                        for (vfs_file, path, text) in files {\n+                            let file_id = vfs_file_to_id(vfs_file);\n+                            db.set_file_text(file_id, text);\n+                            db.set_file_relative_path(file_id, path.clone());\n+                            db.set_file_source_root(file_id, source_root_id);\n+                            file_map.insert(path, file_id);\n+                        }\n+                        let source_root = SourceRoot { files: file_map };\n+                        db.set_source_root(source_root_id, Arc::new(source_root));\n+                        roots_loaded.insert(source_root_id);\n+                        if roots_loaded.len() == vfs.num_roots() {\n+                            done = true;\n+                        }\n+                    }\n+                    VfsChange::AddFile { .. }\n+                    | VfsChange::RemoveFile { .. }\n+                    | VfsChange::ChangeFile { .. } => {\n+                        // We just need the first scan, so just ignore these\n+                    }\n+                }\n+            }\n+            if done {\n+                break;\n+            }\n+        }\n+\n+        db\n+    }\n+\n+    pub fn load_cargo(root: impl AsRef<Path>) -> Result<(BatchDatabase, Vec<SourceRootId>)> {\n+        let root = root.as_ref().canonicalize()?;\n+        let ws = ProjectWorkspace::discover(root.as_ref())?;\n+        let mut roots = Vec::new();\n+        roots.push(root.clone());\n+        for pkg in ws.cargo.packages() {\n+            roots.push(pkg.root(&ws.cargo).to_path_buf());\n+        }\n+        for krate in ws.sysroot.crates() {\n+            roots.push(krate.root_dir(&ws.sysroot).to_path_buf())\n+        }\n+        let (mut vfs, roots) = Vfs::new(roots);\n+        let mut load = |path: &Path| {\n+            let vfs_file = vfs.load(path);\n+            log::debug!(\"vfs file {:?} -> {:?}\", path, vfs_file);\n+            vfs_file.map(vfs_file_to_id)\n+        };\n+        let crate_graph = ws.to_crate_graph(&mut load);\n+        log::debug!(\"crate graph: {:?}\", crate_graph);\n+\n+        let local_roots = roots\n+            .into_iter()\n+            .filter(|r| vfs.root2path(*r).starts_with(&root))\n+            .map(vfs_root_to_id)\n+            .collect();\n+\n+        let db = BatchDatabase::load(crate_graph, &mut vfs);\n+        let _ = vfs.shutdown();\n+        Ok((db, local_roots))\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_hir::Crate;\n+    use super::*;\n+\n+    #[test]\n+    fn test_loading_rust_analyzer() {\n+        let mut path = std::env::current_exe().unwrap();\n+        while !path.join(\"Cargo.toml\").is_file() {\n+            path = path.parent().unwrap().to_owned();\n+        }\n+        let (db, roots) = BatchDatabase::load_cargo(path).unwrap();\n+        let mut num_crates = 0;\n+        for root in roots {\n+            for _krate in Crate::source_root_crates(&db, root) {\n+                num_crates += 1;\n+            }\n+        }\n+\n+        // RA has quite a few crates, but the exact count doesn't matter\n+        assert!(num_crates > 20);\n+    }\n+}"}, {"sha": "641ac5cbde055f4bc1d9315e253178c7bc77acfd", "filename": "crates/ra_cli/Cargo.toml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2FCargo.toml?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -9,6 +9,12 @@ publish = false\n clap = \"2.32.0\"\n failure = \"0.1.4\"\n join_to_string = \"0.1.1\"\n+flexi_logger = \"0.10.0\"\n+indicatif = \"0.11.0\"\n+\n ra_syntax = { path = \"../ra_syntax\" }\n ra_ide_api_light = { path = \"../ra_ide_api_light\" }\n tools = { path = \"../tools\" }\n+ra_batch = { path = \"../ra_batch\" }\n+ra_hir = { path = \"../ra_hir\" }\n+ra_db = { path = \"../ra_db\" }"}, {"sha": "a46ac974de8b77a4a00a2bc6c9a09b3a5eca77c9", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -0,0 +1,100 @@\n+use std::collections::HashSet;\n+\n+use ra_db::SourceDatabase;\n+use ra_batch::BatchDatabase;\n+use ra_hir::{Crate, ModuleDef, Ty, ImplItem};\n+use ra_syntax::AstNode;\n+\n+use crate::Result;\n+\n+pub fn run(verbose: bool) -> Result<()> {\n+    let (db, roots) = BatchDatabase::load_cargo(\".\")?;\n+    println!(\"Database loaded, {} roots\", roots.len());\n+    let mut num_crates = 0;\n+    let mut visited_modules = HashSet::new();\n+    let mut visit_queue = Vec::new();\n+    for root in roots {\n+        for krate in Crate::source_root_crates(&db, root) {\n+            num_crates += 1;\n+            let module = krate.root_module(&db).expect(\"crate in source root without root module\");\n+            visit_queue.push(module);\n+        }\n+    }\n+    println!(\"Crates in this dir: {}\", num_crates);\n+    let mut num_decls = 0;\n+    let mut funcs = Vec::new();\n+    while let Some(module) = visit_queue.pop() {\n+        if visited_modules.insert(module) {\n+            visit_queue.extend(module.children(&db));\n+\n+            for decl in module.declarations(&db) {\n+                num_decls += 1;\n+                match decl {\n+                    ModuleDef::Function(f) => funcs.push(f),\n+                    _ => {}\n+                }\n+            }\n+\n+            for impl_block in module.impl_blocks(&db) {\n+                for item in impl_block.items() {\n+                    num_decls += 1;\n+                    match item {\n+                        ImplItem::Method(f) => funcs.push(*f),\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    println!(\"Total modules found: {}\", visited_modules.len());\n+    println!(\"Total declarations: {}\", num_decls);\n+    println!(\"Total functions: {}\", funcs.len());\n+    let bar = indicatif::ProgressBar::new(funcs.len() as u64);\n+    bar.tick();\n+    let mut num_exprs = 0;\n+    let mut num_exprs_unknown = 0;\n+    let mut num_exprs_partially_unknown = 0;\n+    for f in funcs {\n+        if verbose {\n+            let (file_id, source) = f.source(&db);\n+            let original_file = file_id.original_file(&db);\n+            let path = db.file_relative_path(original_file);\n+            let syntax_range = source.syntax().range();\n+            let name = f.name(&db);\n+            println!(\"{} ({:?} {})\", name, path, syntax_range);\n+        }\n+        let body = f.body(&db);\n+        let inference_result = f.infer(&db);\n+        for (expr_id, _) in body.exprs() {\n+            let ty = &inference_result[expr_id];\n+            num_exprs += 1;\n+            if let Ty::Unknown = ty {\n+                num_exprs_unknown += 1;\n+            } else {\n+                let mut is_partially_unknown = false;\n+                ty.walk(&mut |ty| {\n+                    if let Ty::Unknown = ty {\n+                        is_partially_unknown = true;\n+                    }\n+                });\n+                if is_partially_unknown {\n+                    num_exprs_partially_unknown += 1;\n+                }\n+            }\n+        }\n+        bar.inc(1);\n+    }\n+    bar.finish_and_clear();\n+    println!(\"Total expressions: {}\", num_exprs);\n+    println!(\n+        \"Expressions of unknown type: {} ({}%)\",\n+        num_exprs_unknown,\n+        (num_exprs_unknown * 100 / num_exprs)\n+    );\n+    println!(\n+        \"Expressions of partially unknown type: {} ({}%)\",\n+        num_exprs_partially_unknown,\n+        (num_exprs_partially_unknown * 100 / num_exprs)\n+    );\n+    Ok(())\n+}"}, {"sha": "72e6ae4d5219cd6db0a97f82ad6e9d792a7c0ff9", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -1,14 +1,18 @@\n+mod analysis_stats;\n+\n use std::{fs, io::Read, path::Path, time::Instant};\n \n use clap::{App, Arg, SubCommand};\n use join_to_string::join;\n use ra_ide_api_light::{extend_selection, file_structure, syntax_tree};\n use ra_syntax::{SourceFile, TextRange, TreeArc, AstNode};\n use tools::collect_tests;\n+use flexi_logger::Logger;\n \n type Result<T> = ::std::result::Result<T, failure::Error>;\n \n fn main() -> Result<()> {\n+    Logger::with_env().start()?;\n     let matches = App::new(\"ra-cli\")\n         .setting(clap::AppSettings::SubcommandRequiredElseHelp)\n         .subcommand(\n@@ -23,6 +27,9 @@ fn main() -> Result<()> {\n                 .arg(Arg::with_name(\"start\"))\n                 .arg(Arg::with_name(\"end\")),\n         )\n+        .subcommand(\n+            SubCommand::with_name(\"analysis-stats\").arg(Arg::with_name(\"verbose\").short(\"v\")),\n+        )\n         .get_matches();\n     match matches.subcommand() {\n         (\"parse\", Some(matches)) => {\n@@ -56,6 +63,10 @@ fn main() -> Result<()> {\n             let sels = selections(&file, start, end);\n             println!(\"{}\", sels)\n         }\n+        (\"analysis-stats\", Some(matches)) => {\n+            let verbose = matches.is_present(\"verbose\");\n+            analysis_stats::run(verbose)?;\n+        }\n         _ => unreachable!(),\n     }\n     Ok(())"}, {"sha": "8decc65c5e36c626c999bb1570820a3ce810a65f", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -112,6 +112,7 @@ impl CrateGraph {\n         self.arena[&crate_id].file_id\n     }\n \n+    // TODO: this only finds one crate with the given root; we could have multiple\n     pub fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n         let (&crate_id, _) = self.arena.iter().find(|(_crate_id, data)| data.file_id == file_id)?;\n         Some(crate_id)"}, {"sha": "19f103855d371b15f53ace91549310d0a2c1991d", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use relative_path::RelativePathBuf;\n-use ra_db::{CrateId, FileId};\n+use ra_db::{CrateId, FileId, SourceRootId};\n use ra_syntax::{ast::self, TreeArc, SyntaxNode};\n \n use crate::{\n@@ -16,7 +16,7 @@ use crate::{\n     docs::{Documentation, Docs, docs_from_ast},\n     module_tree::ModuleId,\n     ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeId},\n-    impl_block::ImplId,\n+    impl_block::{ImplId, ImplBlock},\n     resolve::Resolver,\n };\n \n@@ -44,6 +44,15 @@ impl Crate {\n     pub fn root_module(&self, db: &impl PersistentHirDatabase) -> Option<Module> {\n         self.root_module_impl(db)\n     }\n+\n+    // TODO: should this be in source_binder?\n+    pub fn source_root_crates(\n+        db: &impl PersistentHirDatabase,\n+        source_root: SourceRootId,\n+    ) -> Vec<Crate> {\n+        let crate_ids = db.source_root_crates(source_root);\n+        crate_ids.iter().map(|&crate_id| Crate { crate_id }).collect()\n+    }\n }\n \n #[derive(Debug)]\n@@ -168,6 +177,27 @@ impl Module {\n         let item_map = db.item_map(self.krate);\n         Resolver::default().push_module_scope(item_map, *self)\n     }\n+\n+    pub fn declarations(self, db: &impl HirDatabase) -> Vec<ModuleDef> {\n+        let (lowered_module, _) = db.lower_module(self);\n+        lowered_module\n+            .declarations\n+            .values()\n+            .cloned()\n+            .flat_map(|per_ns| {\n+                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n+            })\n+            .collect()\n+    }\n+\n+    pub fn impl_blocks(self, db: &impl HirDatabase) -> Vec<ImplBlock> {\n+        let module_impl_blocks = db.impls_in_module(self);\n+        module_impl_blocks\n+            .impls\n+            .iter()\n+            .map(|(impl_id, _)| ImplBlock::from_id(module_impl_blocks.clone(), impl_id))\n+            .collect()\n+    }\n }\n \n impl Docs for Module {"}, {"sha": "4e73590d0d9303be86ee61899540a68c829911dd", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -70,6 +70,14 @@ impl Body {\n         self.owner\n     }\n \n+    pub fn exprs(&self) -> impl Iterator<Item = (ExprId, &Expr)> {\n+        self.exprs.iter()\n+    }\n+\n+    pub fn pats(&self) -> impl Iterator<Item = (PatId, &Pat)> {\n+        self.pats.iter()\n+    }\n+\n     pub fn syntax_mapping(&self, db: &impl HirDatabase) -> Arc<BodySyntaxMapping> {\n         db.body_syntax_mapping(self.owner)\n     }"}, {"sha": "2dc1de41aa491b3b55e8129623ffb41459e56093", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -449,6 +449,49 @@ impl Ty {\n         Ty::Tuple(Arc::new([]))\n     }\n \n+    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        f(self);\n+        match self {\n+            Ty::Slice(t) | Ty::Array(t) => t.walk(f),\n+            Ty::RawPtr(t, _) => t.walk(f),\n+            Ty::Ref(t, _) => t.walk(f),\n+            Ty::Tuple(ts) => {\n+                for t in ts.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::FnPtr(sig) => {\n+                for input in &sig.input {\n+                    input.walk(f);\n+                }\n+                sig.output.walk(f);\n+            }\n+            Ty::FnDef { substs, sig, .. } => {\n+                for input in &sig.input {\n+                    input.walk(f);\n+                }\n+                sig.output.walk(f);\n+                for t in substs.0.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::Adt { substs, .. } => {\n+                for t in substs.0.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::Bool\n+            | Ty::Char\n+            | Ty::Int(_)\n+            | Ty::Float(_)\n+            | Ty::Str\n+            | Ty::Never\n+            | Ty::Param { .. }\n+            | Ty::Infer(_)\n+            | Ty::Unknown => {}\n+        }\n+    }\n+\n     fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         f(self);\n         match self {\n@@ -491,7 +534,15 @@ impl Ty {\n                 }\n                 substs.0 = v.into();\n             }\n-            _ => {}\n+            Ty::Bool\n+            | Ty::Char\n+            | Ty::Int(_)\n+            | Ty::Float(_)\n+            | Ty::Str\n+            | Ty::Never\n+            | Ty::Param { .. }\n+            | Ty::Infer(_)\n+            | Ty::Unknown => {}\n         }\n     }\n "}, {"sha": "4a68c019ff4e6d87cb31e4a2ab1d248395cec152", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -47,10 +47,8 @@ impl ServerWorldState {\n                 roots.push(krate.root_dir(&ws.sysroot).to_path_buf())\n             }\n         }\n-        roots.sort();\n-        roots.dedup();\n-        let roots_to_scan = roots.len();\n         let (mut vfs, roots) = Vfs::new(roots);\n+        let roots_to_scan = roots.len();\n         for r in roots {\n             let is_local = vfs.root2path(r).starts_with(&root);\n             change.add_root(SourceRootId(r.0.into()), is_local);"}, {"sha": "3805be570a694d5a0538adacf8f17490d358051c", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4be2708635818aa3e210f0e39fb871cc433004/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=8e4be2708635818aa3e210f0e39fb871cc433004", "patch": "@@ -94,6 +94,7 @@ impl Roots {\n         let mut roots = Arena::default();\n         // A hack to make nesting work.\n         paths.sort_by_key(|it| Reverse(it.as_os_str().len()));\n+        paths.dedup();\n         for (i, path) in paths.iter().enumerate() {\n             let nested_roots = paths[..i]\n                 .iter()\n@@ -181,6 +182,10 @@ impl Vfs {\n         None\n     }\n \n+    pub fn num_roots(&self) -> usize {\n+        self.roots.len()\n+    }\n+\n     pub fn load(&mut self, path: &Path) -> Option<VfsFile> {\n         if let Some((root, rel_path, file)) = self.find_root(path) {\n             return if let Some(file) = file {"}]}