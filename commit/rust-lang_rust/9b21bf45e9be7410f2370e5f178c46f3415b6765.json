{"sha": "9b21bf45e9be7410f2370e5f178c46f3415b6765", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMjFiZjQ1ZTliZTc0MTBmMjM3MGU1ZjE3OGM0NmYzNDE1YjY3NjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-12T07:59:39Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-12T20:13:57Z"}, "message": "Account for possible 0-sized elements in vector iterators\n\nCloses #7733", "tree": {"sha": "6dce4d4c3c1131c7c145f8a2b3986f8d54ec53f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dce4d4c3c1131c7c145f8a2b3986f8d54ec53f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b21bf45e9be7410f2370e5f178c46f3415b6765", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b21bf45e9be7410f2370e5f178c46f3415b6765", "html_url": "https://github.com/rust-lang/rust/commit/9b21bf45e9be7410f2370e5f178c46f3415b6765", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b21bf45e9be7410f2370e5f178c46f3415b6765/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ec06e01241822f799b3b8da176797593d51bb17", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec06e01241822f799b3b8da176797593d51bb17", "html_url": "https://github.com/rust-lang/rust/commit/1ec06e01241822f799b3b8da176797593d51bb17"}], "stats": {"total": 81, "additions": 68, "deletions": 13}, "files": [{"sha": "8b27ce4235ee4386a4b6eeaea5c042b0f490b59a", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 68, "deletions": 13, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9b21bf45e9be7410f2370e5f178c46f3415b6765/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b21bf45e9be7410f2370e5f178c46f3415b6765/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=9b21bf45e9be7410f2370e5f178c46f3415b6765", "patch": "@@ -30,7 +30,6 @@ use ptr::RawPtr;\n use rt::global_heap::malloc_raw;\n use rt::global_heap::realloc_raw;\n use sys;\n-use sys::size_of;\n use uint;\n use unstable::intrinsics;\n #[cfg(stage0)]\n@@ -109,7 +108,7 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n             vec\n         } else {\n             let alloc = capacity * sys::nonzero_size_of::<T>();\n-            let ptr = malloc_raw(alloc + size_of::<raw::VecRepr>()) as *mut raw::VecRepr;\n+            let ptr = malloc_raw(alloc + sys::size_of::<raw::VecRepr>()) as *mut raw::VecRepr;\n             (*ptr).unboxed.alloc = alloc;\n             (*ptr).unboxed.fill = 0;\n             cast::transmute(ptr)\n@@ -751,7 +750,9 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn iter(self) -> VecIterator<'self, T> {\n         unsafe {\n             let p = vec::raw::to_ptr(self);\n-            VecIterator{ptr: p, end: p.offset(self.len()),\n+            VecIterator{ptr: p,\n+                        end: cast::transmute(p as uint + self.len() *\n+                                             sys::nonzero_size_of::<T>()),\n                         lifetime: cast::transmute(p)}\n         }\n     }\n@@ -1149,7 +1150,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                     ::at_vec::raw::reserve_raw(td, ptr, n);\n                 } else {\n                     let alloc = n * sys::nonzero_size_of::<T>();\n-                    *ptr = realloc_raw(*ptr as *mut c_void, alloc + size_of::<raw::VecRepr>())\n+                    *ptr = realloc_raw(*ptr as *mut c_void, alloc + sys::size_of::<raw::VecRepr>())\n                            as *mut raw::VecRepr;\n                     (**ptr).unboxed.alloc = alloc;\n                 }\n@@ -1178,7 +1179,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                     ::at_vec::raw::reserve_raw(td, ptr, n);\n                 } else {\n                     let alloc = n * sys::nonzero_size_of::<T>();\n-                    let size = alloc + size_of::<raw::VecRepr>();\n+                    let size = alloc + sys::size_of::<raw::VecRepr>();\n                     if alloc / sys::nonzero_size_of::<T>() != n || size < alloc {\n                         fail!(\"vector size is too large: %u\", n);\n                     }\n@@ -1712,7 +1713,9 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     fn mut_iter(self) -> VecMutIterator<'self, T> {\n         unsafe {\n             let p = vec::raw::to_mut_ptr(self);\n-            VecMutIterator{ptr: p, end: p.offset(self.len()),\n+            VecMutIterator{ptr: p,\n+                           end: cast::transmute(p as uint + self.len() *\n+                                                sys::nonzero_size_of::<T>()),\n                            lifetime: cast::transmute(p)}\n         }\n     }\n@@ -2089,7 +2092,11 @@ macro_rules! iterator {\n                         None\n                     } else {\n                         let old = self.ptr;\n-                        self.ptr = self.ptr.offset(1);\n+                        // purposefully don't use 'ptr.offset' because for\n+                        // vectors with 0-size elements this would return the\n+                        // same pointer.\n+                        self.ptr = cast::transmute(self.ptr as uint +\n+                                                   sys::nonzero_size_of::<T>());\n                         Some(cast::transmute(old))\n                     }\n                 }\n@@ -2098,7 +2105,7 @@ macro_rules! iterator {\n             #[inline]\n             fn size_hint(&self) -> (uint, Option<uint>) {\n                 let diff = (self.end as uint) - (self.ptr as uint);\n-                let exact = diff / size_of::<$elem>();\n+                let exact = diff / sys::nonzero_size_of::<$elem>();\n                 (exact, Some(exact))\n             }\n         }\n@@ -2115,7 +2122,9 @@ macro_rules! double_ended_iterator {\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        self.end = self.end.offset(-1);\n+                        // See above for why 'ptr.offset' isn't used\n+                        self.end = cast::transmute(self.end as uint -\n+                                                   sys::nonzero_size_of::<T>());\n                         Some(cast::transmute(self.end))\n                     }\n                 }\n@@ -2671,19 +2680,19 @@ mod tests {\n         let mut results: ~[~[int]];\n \n         results = ~[];\n-        for each_permutation([]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([]) |v| { results.push(v.to_owned()); }\n         assert_eq!(results, ~[~[]]);\n \n         results = ~[];\n-        for each_permutation([7]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([7]) |v| { results.push(v.to_owned()); }\n         assert_eq!(results, ~[~[7]]);\n \n         results = ~[];\n-        for each_permutation([1,1]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([1,1]) |v| { results.push(v.to_owned()); }\n         assert_eq!(results, ~[~[1,1],~[1,1]]);\n \n         results = ~[];\n-        for each_permutation([5,2,0]) |v| { results.push(to_owned(v)); }\n+        for each_permutation([5,2,0]) |v| { results.push(v.to_owned()); }\n         assert!(results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n     }\n@@ -3370,4 +3379,50 @@ mod tests {\n \n         assert_eq!(values, [2, 3, 5, 6, 7]);\n     }\n+\n+    #[deriving(Eq)]\n+    struct Foo;\n+\n+    #[test]\n+    fn test_iter_zero_sized() {\n+        let mut v = ~[Foo, Foo, Foo];\n+        assert_eq!(v.len(), 3);\n+        let mut cnt = 0;\n+\n+        for v.iter().advance |f| {\n+            assert!(*f == Foo);\n+            cnt += 1;\n+        }\n+        assert_eq!(cnt, 3);\n+\n+        for v.slice(1, 3).iter().advance |f| {\n+            assert!(*f == Foo);\n+            cnt += 1;\n+        }\n+        assert_eq!(cnt, 5);\n+\n+        for v.mut_iter().advance |f| {\n+            assert!(*f == Foo);\n+            cnt += 1;\n+        }\n+        assert_eq!(cnt, 8);\n+\n+        for v.consume_iter().advance |f| {\n+            assert!(f == Foo);\n+            cnt += 1;\n+        }\n+        assert_eq!(cnt, 11);\n+\n+        let xs = ~[Foo, Foo, Foo];\n+        assert_eq!(fmt!(\"%?\", xs.slice(0, 2).to_owned()), ~\"~[{}, {}]\");\n+\n+        let xs: [Foo, ..3] = [Foo, Foo, Foo];\n+        assert_eq!(fmt!(\"%?\", xs.slice(0, 2).to_owned()), ~\"~[{}, {}]\");\n+        cnt = 0;\n+        for xs.iter().advance |f| {\n+            assert!(*f == Foo);\n+            cnt += 1;\n+        }\n+        assert!(cnt == 3);\n+    }\n }"}]}