{"sha": "7a8ba535422a4e3d2b649acde75b5c400ef5e7c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhOGJhNTM1NDIyYTRlM2QyYjY0OWFjZGU3NWI1YzQwMGVmNWU3YzY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-03-17T17:20:51Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-03-21T21:11:53Z"}, "message": "Add Ty::Apply", "tree": {"sha": "c97f014c20f6059905236b70a235e8d66743608c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c97f014c20f6059905236b70a235e8d66743608c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a8ba535422a4e3d2b649acde75b5c400ef5e7c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a8ba535422a4e3d2b649acde75b5c400ef5e7c6", "html_url": "https://github.com/rust-lang/rust/commit/7a8ba535422a4e3d2b649acde75b5c400ef5e7c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a8ba535422a4e3d2b649acde75b5c400ef5e7c6/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc7752e5279f274887cd92ac76779f227264ae13", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc7752e5279f274887cd92ac76779f227264ae13", "html_url": "https://github.com/rust-lang/rust/commit/bc7752e5279f274887cd92ac76779f227264ae13"}], "stats": {"total": 178, "additions": 177, "deletions": 1}, "files": [{"sha": "e63775f034ff5110b8bd650023adf7c20da3128c", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 177, "deletions": 1, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/7a8ba535422a4e3d2b649acde75b5c400ef5e7c6/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8ba535422a4e3d2b649acde75b5c400ef5e7c6/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=7a8ba535422a4e3d2b649acde75b5c400ef5e7c6", "patch": "@@ -20,11 +20,84 @@ pub(crate) use lower::{TypableDef, CallableDef, type_for_def, type_for_field, ca\n pub(crate) use infer::{infer, InferenceResult, InferTy};\n use display::{HirDisplay, HirFormatter};\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum TypeName {\n+    /// The primitive boolean type. Written as `bool`.\n+    Bool,\n+\n+    /// The primitive character type; holds a Unicode scalar value\n+    /// (a non-surrogate code point). Written as `char`.\n+    Char,\n+\n+    /// A primitive integer type. For example, `i32`.\n+    Int(primitive::UncertainIntTy),\n+\n+    /// A primitive floating-point type. For example, `f64`.\n+    Float(primitive::UncertainFloatTy),\n+\n+    /// Structures, enumerations and unions.\n+    Adt(AdtDef),\n+\n+    /// The pointee of a string slice. Written as `str`.\n+    Str,\n+\n+    /// The pointee of an array slice.  Written as `[T]`.\n+    Slice,\n+\n+    /// An array with the given length. Written as `[T; n]`.\n+    Array,\n+\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    RawPtr(Mutability),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&'a mut T` or `&'a T`.\n+    Ref(Mutability),\n+\n+    /// The anonymous type of a function declaration/definition. Each\n+    /// function has a unique type, which is output (for a function\n+    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n+    ///\n+    /// This includes tuple struct / enum variant constructors as well.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar = foo; // bar: fn() -> i32 {foo}\n+    /// ```\n+    FnDef(CallableDef),\n+\n+    /// A pointer to a function.  Written as `fn() -> i32`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar: fn() -> i32 = foo;\n+    /// ```\n+    FnPtr,\n+\n+    /// The never type `!`.\n+    Never,\n+\n+    /// A tuple type.  For example, `(i32, bool)`.\n+    Tuple,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct ApplicationTy {\n+    pub name: TypeName,\n+    pub parameters: Substs,\n+}\n+\n /// A type. This is based on the `TyKind` enum in rustc (librustc/ty/sty.rs).\n ///\n /// This should be cheap to clone.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum Ty {\n+    Apply(ApplicationTy),\n+\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n \n@@ -139,6 +212,13 @@ impl Substs {\n         }\n         self.0 = v.into();\n     }\n+\n+    pub fn as_single(&self) -> &Ty {\n+        if self.0.len() != 1 {\n+            panic!(\"expected substs of len 1, got {:?}\", self);\n+        }\n+        &self.0[0]\n+    }\n }\n \n /// A function signature.\n@@ -176,12 +256,20 @@ impl FnSig {\n }\n \n impl Ty {\n+    pub fn apply(name: TypeName, parameters: Substs) -> Ty {\n+        Ty::Apply(ApplicationTy { name, parameters })\n+    }\n     pub fn unit() -> Self {\n-        Ty::Tuple(Substs::empty())\n+        Ty::apply(TypeName::Tuple, Substs::empty())\n     }\n \n     pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         match self {\n+            Ty::Apply(a_ty) => {\n+                for t in a_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n             Ty::Slice(t) | Ty::Array(t) => t.walk(f),\n             Ty::RawPtr(t, _) => t.walk(f),\n             Ty::Ref(t, _) => t.walk(f),\n@@ -220,6 +308,9 @@ impl Ty {\n \n     fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         match self {\n+            Ty::Apply(a_ty) => {\n+                a_ty.parameters.walk_mut(f);\n+            }\n             Ty::Slice(t) | Ty::Array(t) => Arc::make_mut(t).walk_mut(f),\n             Ty::RawPtr(t, _) => Arc::make_mut(t).walk_mut(f),\n             Ty::Ref(t, _) => Arc::make_mut(t).walk_mut(f),\n@@ -258,6 +349,11 @@ impl Ty {\n \n     fn builtin_deref(&self) -> Option<Ty> {\n         match self {\n+            Ty::Apply(a_ty) => match a_ty.name {\n+                TypeName::Ref(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n+                TypeName::RawPtr(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n+                _ => None,\n+            },\n             Ty::Ref(t, _) => Some(Ty::clone(t)),\n             Ty::RawPtr(t, _) => Some(Ty::clone(t)),\n             _ => None,\n@@ -270,6 +366,9 @@ impl Ty {\n     /// `Option<u32>` afterwards.)\n     pub fn apply_substs(self, substs: Substs) -> Ty {\n         match self {\n+            Ty::Apply(ApplicationTy { name, .. }) => {\n+                Ty::Apply(ApplicationTy { name, parameters: substs })\n+            }\n             Ty::Adt { def_id, .. } => Ty::Adt { def_id, substs },\n             Ty::FnDef { def, .. } => Ty::FnDef { def, substs },\n             _ => self,\n@@ -296,6 +395,7 @@ impl Ty {\n     /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n     fn substs(&self) -> Option<Substs> {\n         match self {\n+            Ty::Apply(ApplicationTy { parameters, .. }) => Some(parameters.clone()),\n             Ty::Adt { substs, .. } | Ty::FnDef { substs, .. } => Some(substs.clone()),\n             _ => None,\n         }\n@@ -308,9 +408,85 @@ impl HirDisplay for &Ty {\n     }\n }\n \n+impl HirDisplay for ApplicationTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        match self.name {\n+            TypeName::Bool => write!(f, \"bool\")?,\n+            TypeName::Char => write!(f, \"char\")?,\n+            TypeName::Int(t) => write!(f, \"{}\", t)?,\n+            TypeName::Float(t) => write!(f, \"{}\", t)?,\n+            TypeName::Str => write!(f, \"str\")?,\n+            TypeName::Slice | TypeName::Array => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"[{}]\", t.display(f.db))?;\n+            }\n+            TypeName::RawPtr(m) => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n+            }\n+            TypeName::Ref(m) => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"&{}{}\", m.as_keyword_for_ref(), t.display(f.db))?;\n+            }\n+            TypeName::Never => write!(f, \"!\")?,\n+            TypeName::Tuple => {\n+                let ts = &self.parameters;\n+                if ts.0.len() == 1 {\n+                    write!(f, \"({},)\", ts.0[0].display(f.db))?;\n+                } else {\n+                    write!(f, \"(\")?;\n+                    f.write_joined(&*ts.0, \", \")?;\n+                    write!(f, \")\")?;\n+                }\n+            }\n+            TypeName::FnPtr => {\n+                let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n+                write!(f, \"fn(\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n+            }\n+            TypeName::FnDef(def) => {\n+                let sig = f.db.callable_item_signature(def);\n+                let name = match def {\n+                    CallableDef::Function(ff) => ff.name(f.db),\n+                    CallableDef::Struct(s) => s.name(f.db).unwrap_or_else(Name::missing),\n+                    CallableDef::EnumVariant(e) => e.name(f.db).unwrap_or_else(Name::missing),\n+                };\n+                match def {\n+                    CallableDef::Function(_) => write!(f, \"fn {}\", name)?,\n+                    CallableDef::Struct(_) | CallableDef::EnumVariant(_) => write!(f, \"{}\", name)?,\n+                }\n+                if self.parameters.0.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+                write!(f, \"(\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n+            }\n+            TypeName::Adt(def_id) => {\n+                let name = match def_id {\n+                    AdtDef::Struct(s) => s.name(f.db),\n+                    AdtDef::Enum(e) => e.name(f.db),\n+                }\n+                .unwrap_or_else(Name::missing);\n+                write!(f, \"{}\", name)?;\n+                if self.parameters.0.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl HirDisplay for Ty {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n         match self {\n+            Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n             Ty::Bool => write!(f, \"bool\")?,\n             Ty::Char => write!(f, \"char\")?,\n             Ty::Int(t) => write!(f, \"{}\", t)?,"}]}