{"sha": "96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YWViN2UzYzM1ZWUwZDBjZjViOWFiOGRiNWVmNjllNGNmYjI2NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-13T05:21:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-13T05:21:56Z"}, "message": "auto merge of #13461 : eddyb/rust/cleanup-at-fn, r=luqmana", "tree": {"sha": "37b06241edd266e498e4fa8e715bcc2e7784d387", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37b06241edd266e498e4fa8e715bcc2e7784d387"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "html_url": "https://github.com/rust-lang/rust/commit/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4178db07c5747ea412118c8e64f3fbefad4338e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4178db07c5747ea412118c8e64f3fbefad4338e", "html_url": "https://github.com/rust-lang/rust/commit/e4178db07c5747ea412118c8e64f3fbefad4338e"}, {"sha": "9d570ad8c16970e1b2f629d224716f2d7a8b7820", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d570ad8c16970e1b2f629d224716f2d7a8b7820", "html_url": "https://github.com/rust-lang/rust/commit/9d570ad8c16970e1b2f629d224716f2d7a8b7820"}], "stats": {"total": 886, "additions": 334, "deletions": 552}, "files": [{"sha": "dd604af40ec52dd6d57902643282b2de93a834db", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -260,8 +260,7 @@ impl<'a> Visitor<()> for Context<'a> {\n \n     fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n         match t.node {\n-            ast::TyClosure(closure) if closure.onceness == ast::Once &&\n-                    closure.sigil != ast::OwnedSigil => {\n+            ast::TyClosure(closure, _) if closure.onceness == ast::Once => {\n                 self.gate_feature(\"once_fns\", t.span,\n                                   \"once functions are \\\n                                    experimental and likely to be removed\");"}, {"sha": "5df5b718f3e76b163d44d714a605b9cc4f5500ee", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -137,15 +137,6 @@ pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx:\n     parse_substs(&mut st, conv)\n }\n \n-fn parse_sigil(st: &mut PState) -> ast::Sigil {\n-    match next(st) {\n-        '@' => ast::ManagedSigil,\n-        '~' => ast::OwnedSigil,\n-        '&' => ast::BorrowedSigil,\n-        c => st.tcx.sess.bug(format!(\"parse_sigil(): bad input '{}'\", c))\n-    }\n-}\n-\n fn parse_vstore<M>(st: &mut PState, conv: conv_did,\n                    parse_mut: |&mut PState| -> M) -> ty::Vstore<M> {\n     assert_eq!(next(st), '/');\n@@ -476,17 +467,15 @@ fn parse_onceness(c: char) -> ast::Onceness {\n }\n \n fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n-    let sigil = parse_sigil(st);\n     let fn_style = parse_fn_style(next(st));\n     let onceness = parse_onceness(next(st));\n-    let region = parse_region(st, |x,y| conv(x,y));\n+    let store = parse_trait_store(st, |x,y| conv(x,y));\n     let bounds = parse_bounds(st, |x,y| conv(x,y));\n     let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::ClosureTy {\n         fn_style: fn_style,\n-        sigil: sigil,\n         onceness: onceness,\n-        region: region,\n+        store: store,\n         bounds: bounds.builtin_bounds,\n         sig: sig\n     }"}, {"sha": "53fe1c19d8ff948c60bc359ad29a5aff20f029a3", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -327,14 +327,6 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n     }\n }\n \n-fn enc_sigil(w: &mut MemWriter, sigil: Sigil) {\n-    match sigil {\n-        ManagedSigil => mywrite!(w, \"@\"),\n-        OwnedSigil => mywrite!(w, \"~\"),\n-        BorrowedSigil => mywrite!(w, \"&\"),\n-    }\n-}\n-\n fn enc_fn_style(w: &mut MemWriter, p: FnStyle) {\n     match p {\n         NormalFn => mywrite!(w, \"n\"),\n@@ -363,10 +355,9 @@ pub fn enc_bare_fn_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::BareFnTy) {\n }\n \n fn enc_closure_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::ClosureTy) {\n-    enc_sigil(w, ft.sigil);\n     enc_fn_style(w, ft.fn_style);\n     enc_onceness(w, ft.onceness);\n-    enc_region(w, cx, ft.region);\n+    enc_trait_store(w, cx, ft.store);\n     let bounds = ty::ParamBounds {builtin_bounds: ft.bounds,\n                                   trait_bounds: Vec::new()};\n     enc_bounds(w, cx, &bounds);"}, {"sha": "858e873f7ed3592e83d2c3a68d13f8dc6394dfd9", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -897,10 +897,9 @@ impl<'a> ebml_writer_helpers for Encoder<'a> {\n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment) {\n         self.emit_enum(\"AutoAdjustment\", |this| {\n             match *adj {\n-                ty::AutoAddEnv(region, sigil) => {\n-                    this.emit_enum_variant(\"AutoAddEnv\", 0, 2, |this| {\n-                        this.emit_enum_variant_arg(0, |this| region.encode(this));\n-                        this.emit_enum_variant_arg(1, |this| sigil.encode(this))\n+                ty::AutoAddEnv(store) => {\n+                    this.emit_enum_variant(\"AutoAddEnv\", 0, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| store.encode(this))\n                     })\n                 }\n \n@@ -1270,12 +1269,10 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n-                        let region: ty::Region =\n+                        let store: ty::TraitStore =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n-                        let sigil: ast::Sigil =\n-                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n \n-                        ty:: AutoAddEnv(region.tr(xcx), sigil)\n+                        ty:: AutoAddEnv(store.tr(xcx))\n                     }\n                     1 => {\n                         let auto_deref_ref: ty::AutoDerefRef ="}, {"sha": "f0a6c5f16f77d34978b853afa823fbc5fcfb9357", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -451,17 +451,8 @@ impl<'a> GatherLoanCtxt<'a> {\n                                              r,\n                                              AutoRef)\n                     }\n-                    ty::AutoBorrowFn(r) => {\n-                        let cmt_deref = mc.cat_deref_fn_or_obj(expr, cmt, 0);\n-                        self.guarantee_valid(expr.id,\n-                                             expr.span,\n-                                             cmt_deref,\n-                                             ast::MutImmutable,\n-                                             r,\n-                                             AutoRef)\n-                    }\n                     ty::AutoBorrowObj(r, m) => {\n-                        let cmt_deref = mc.cat_deref_fn_or_obj(expr, cmt, 0);\n+                        let cmt_deref = mc.cat_deref_obj(expr, cmt);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_deref,"}, {"sha": "21e68e2724fc327d4f54c1fffd79982d4b09374a", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -620,7 +620,7 @@ impl<'a> BorrowckCtxt<'a> {\n         fn move_suggestion(tcx: &ty::ctxt, ty: ty::t, default_msg: &'static str)\n                           -> &'static str {\n             match ty::get(ty).sty {\n-                ty::ty_closure(ref cty) if cty.sigil == ast::BorrowedSigil =>\n+                ty::ty_closure(~ty::ClosureTy { store: ty::RegionTraitStore(..), .. }) =>\n                     \"a non-copyable stack closure (capture it in a new closure, \\\n                      e.g. `|x| f(x)`, to override)\",\n                 _ if ty::type_moves_by_default(tcx, ty) =>"}, {"sha": "a152e06eb06aafd2cf193dedebb9286b8e9c4ff0", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -197,27 +197,13 @@ fn with_appropriate_checker(cx: &Context,\n     let fty = ty::node_id_to_type(cx.tcx, id);\n     match ty::get(fty).sty {\n         ty::ty_closure(~ty::ClosureTy {\n-            sigil: OwnedSigil,\n-            bounds: bounds,\n-            ..\n-        }) => {\n-            b(|cx, fv| check_for_uniq(cx, fv, bounds))\n-        }\n-        ty::ty_closure(~ty::ClosureTy {\n-            sigil: ManagedSigil,\n-            ..\n-        }) => {\n-            // can't happen\n-            fail!(\"internal error: saw closure with managed sigil (@fn)\");\n-        }\n+            store: ty::UniqTraitStore, bounds, ..\n+        }) => b(|cx, fv| check_for_uniq(cx, fv, bounds)),\n+\n         ty::ty_closure(~ty::ClosureTy {\n-            sigil: BorrowedSigil,\n-            bounds: bounds,\n-            region: region,\n-            ..\n-        }) => {\n-            b(|cx, fv| check_for_block(cx, fv, bounds, region))\n-        }\n+            store: ty::RegionTraitStore(region, _), bounds, ..\n+        }) => b(|cx, fv| check_for_block(cx, fv, bounds, region)),\n+\n         ty::ty_bare_fn(_) => {\n             b(check_for_bare)\n         }"}, {"sha": "e376f85ff6db030934292ae3fa46568749e2218e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -919,10 +919,8 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n                 }\n                 ty::ty_uniq(_) | ty::ty_str(ty::VstoreUniq) |\n                 ty::ty_vec(_, ty::VstoreUniq) |\n-                ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) => {\n-                    n_uniq += 1;\n-                }\n-                ty::ty_closure(ref c) if c.sigil == ast::OwnedSigil => {\n+                ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n+                ty::ty_closure(~ty::ClosureTy { store: ty::UniqTraitStore, .. }) => {\n                     n_uniq += 1;\n                 }\n "}, {"sha": "7f157e321baf9cd87089340f03b827c9d693b386", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -76,7 +76,7 @@ use syntax::parse::token;\n pub enum categorization {\n     cat_rvalue(ty::Region),            // temporary val, argument is its scope\n     cat_static_item,\n-    cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n+    cat_copied_upvar(CopiedUpvar),     // upvar copied into proc env\n     cat_upvar(ty::UpvarId, ty::UpvarBorrow), // by ref upvar from stack closure\n     cat_local(ast::NodeId),            // local variable\n     cat_arg(ast::NodeId),              // formal argument\n@@ -172,7 +172,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n         ty::ty_vec(_, ty::VstoreUniq) |\n         ty::ty_str(ty::VstoreUniq) |\n-        ty::ty_closure(~ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n+        ty::ty_closure(~ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n             Some(deref_ptr(OwnedPtr))\n         }\n \n@@ -187,8 +187,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         }\n \n         ty::ty_str(ty::VstoreSlice(r, ())) |\n-        ty::ty_closure(~ty::ClosureTy {sigil: ast::BorrowedSigil,\n-                                      region: r, ..}) => {\n+        ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(r, _), ..}) => {\n             Some(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n         }\n \n@@ -540,15 +539,14 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                       // Decide whether to use implicit reference or by copy/move\n                       // capture for the upvar. This, combined with the onceness,\n                       // determines whether the closure can move out of it.\n-                      let var_is_refd = match (closure_ty.sigil, closure_ty.onceness) {\n+                      let var_is_refd = match (closure_ty.store, closure_ty.onceness) {\n                           // Many-shot stack closures can never move out.\n-                          (ast::BorrowedSigil, ast::Many) => true,\n+                          (ty::RegionTraitStore(..), ast::Many) => true,\n                           // 1-shot stack closures can move out.\n-                          (ast::BorrowedSigil, ast::Once) => false,\n+                          (ty::RegionTraitStore(..), ast::Once) => false,\n                           // Heap closures always capture by copy/move, and can\n                           // move out if they are once.\n-                          (ast::OwnedSigil, _) |\n-                          (ast::ManagedSigil, _) => false,\n+                          (ty::UniqTraitStore, _) => false,\n \n                       };\n                       if var_is_refd {\n@@ -688,19 +686,8 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_deref_fn_or_obj<N:ast_node>(&mut self,\n-                                           node: &N,\n-                                           base_cmt: cmt,\n-                                           deref_cnt: uint)\n-                                           -> cmt {\n-        // Bit of a hack: the \"dereference\" of a function pointer like\n-        // `@fn()` is a mere logical concept. We interpret it as\n-        // dereferencing the environment pointer; of course, we don't\n-        // know what type lies at the other end, so we just call it\n-        // `()` (the empty tuple).\n-\n-        let opaque_ty = ty::mk_tup(self.tcx(), Vec::new());\n-        self.cat_deref_common(node, base_cmt, deref_cnt, opaque_ty)\n+    pub fn cat_deref_obj<N:ast_node>(&mut self, node: &N, base_cmt: cmt) -> cmt {\n+        self.cat_deref_common(node, base_cmt, 0, ty::mk_nil())\n     }\n \n     fn cat_deref<N:ast_node>(&mut self,\n@@ -1105,7 +1092,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n               ~\"static item\"\n           }\n           cat_copied_upvar(_) => {\n-              ~\"captured outer variable in a heap closure\"\n+              ~\"captured outer variable in a proc\"\n           }\n           cat_rvalue(..) => {\n               ~\"non-lvalue\""}, {"sha": "2029df38b10015e17c2d9bd96624f0e93aed4385", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -650,30 +650,30 @@ impl<'a> VisitContext<'a> {\n         let _indenter = indenter();\n \n         let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n-        let sigil = ty::ty_closure_sigil(fn_ty);\n         let freevars = freevars::get_freevars(self.tcx, fn_expr_id);\n-        let v = if sigil == BorrowedSigil {\n-            // || captures everything by ref\n-            freevars.iter()\n-                    .map(|fvar| CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef})\n-                    .collect()\n-        } else {\n-            // @fn() and ~fn() capture by copy or by move depending on type\n-            freevars.iter()\n-                    .map(|fvar| {\n-                let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n-                let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n-                debug!(\"fvar_def_id={:?} fvar_ty={}\",\n-                       fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n-                let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n-                    CapMove\n-                } else {\n-                    CapCopy\n-                };\n-                CaptureVar {def: fvar.def, span: fvar.span, mode:mode}\n-\n+        Rc::new(match ty::ty_closure_store(fn_ty) {\n+            ty::RegionTraitStore(..) => {\n+                // || captures everything by ref\n+                freevars.iter()\n+                        .map(|fvar| CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef})\n+                        .collect()\n+            }\n+            ty::UniqTraitStore => {\n+                // proc captures by copy or by move depending on type\n+                freevars.iter()\n+                        .map(|fvar| {\n+                    let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n+                    let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n+                    debug!(\"fvar_def_id={:?} fvar_ty={}\",\n+                        fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n+                    let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n+                        CapMove\n+                    } else {\n+                        CapCopy\n+                    };\n+                    CaptureVar {def: fvar.def, span: fvar.span, mode:mode}\n                 }).collect()\n-        };\n-        Rc::new(v)\n+            }\n+        })\n     }\n }"}, {"sha": "e5b13adb4d0dc9d827f1753b47677f605f74db0a", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -4274,7 +4274,7 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n \n-            TyClosure(c) => {\n+            TyClosure(c, _) | TyProc(c) => {\n                 c.bounds.as_ref().map(|bounds| {\n                     for bound in bounds.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound);"}, {"sha": "130c93ac51e91e8c4152cf63c583525720878021", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -112,7 +112,9 @@ impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n \n     fn visit_ty(&mut self, ty: &ast::Ty, scope: Scope<'a>) {\n         match ty.node {\n-            ast::TyClosure(c) => push_fn_scope(self, ty, scope, &c.lifetimes),\n+            ast::TyClosure(c, _) | ast::TyProc(c) => {\n+                push_fn_scope(self, ty, scope, &c.lifetimes);\n+            }\n             ast::TyBareFn(c) => push_fn_scope(self, ty, scope, &c.lifetimes),\n             _ => visit::walk_ty(self, ty, scope),\n         }"}, {"sha": "60d6e6850f7ead745dbc1917bc1c0f61bb7164a5", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -260,7 +260,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, has_env: bool,\n             // noalias because the actual object pointer is nested.\n             ty::ty_uniq(..) | // ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n             ty::ty_vec(_, ty::VstoreUniq) | ty::ty_str(ty::VstoreUniq) |\n-            ty::ty_closure(~ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n+            ty::ty_closure(~ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n                 unsafe {\n                     llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n                 }"}, {"sha": "bc80f88f623e1d6ca1ef743c5ac65dc9c0e63d96", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -38,17 +38,14 @@ use syntax::ast_util;\n // roughly as follows:\n //\n // struct rust_opaque_box {         // see rust_internal.h\n-//   unsigned ref_count;            // only used for @fn()\n-//   type_desc *tydesc;             // describes closure_data struct\n-//   rust_opaque_box *prev;         // (used internally by memory alloc)\n-//   rust_opaque_box *next;         // (used internally by memory alloc)\n+//   unsigned ref_count;            // obsolete (part of @T's header)\n+//   fn(void*) *drop_glue;          // destructor (for proc)\n+//   rust_opaque_box *prev;         // obsolete (part of @T's header)\n+//   rust_opaque_box *next;         // obsolete (part of @T's header)\n //   struct closure_data {\n-//       type_desc *bound_tdescs[]; // bound descriptors\n-//       struct {\n-//         upvar1_t upvar1;\n-//         ...\n-//         upvarN_t upvarN;\n-//       } bound_data;\n+//       upvar1_t upvar1;\n+//       ...\n+//       upvarN_t upvarN;\n //    }\n // };\n //\n@@ -158,24 +155,21 @@ fn tuplify_box_ty(tcx: &ty::ctxt, t: ty::t) -> ty::t {\n }\n \n fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n-                     sigil: ast::Sigil,\n+                     store: ty::TraitStore,\n                      cdata_ty: ty::t)\n                      -> Result<'a> {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let tcx = bcx.tcx();\n \n     // Allocate and initialize the box:\n-    match sigil {\n-        ast::ManagedSigil => {\n-            tcx.sess.bug(\"trying to trans allocation of @fn\")\n-        }\n-        ast::OwnedSigil => {\n+    match store {\n+        ty::UniqTraitStore => {\n             let ty = type_of(bcx.ccx(), cdata_ty);\n             let size = llsize_of(bcx.ccx(), ty);\n             // we treat proc as @ here, which isn't ideal\n             malloc_raw_dyn_managed(bcx, cdata_ty, ClosureExchangeMallocFnLangItem, size)\n         }\n-        ast::BorrowedSigil => {\n+        ty::RegionTraitStore(..) => {\n             let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n             let llbox = alloc_ty(bcx, cbox_ty, \"__closure\");\n             rslt(bcx, llbox)\n@@ -196,7 +190,7 @@ pub struct ClosureResult<'a> {\n pub fn store_environment<'a>(\n                          bcx: &'a Block<'a>,\n                          bound_values: Vec<EnvValue> ,\n-                         sigil: ast::Sigil)\n+                         store: ty::TraitStore)\n                          -> ClosureResult<'a> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n@@ -220,7 +214,7 @@ pub fn store_environment<'a>(\n     }\n \n     // allocate closure in the heap\n-    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, sigil, cdata_ty);\n+    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, store, cdata_ty);\n \n     let llbox = PointerCast(bcx, llbox, llboxptr_ty);\n     debug!(\"tuplify_box_ty = {}\", ty_to_str(tcx, cbox_ty));\n@@ -254,7 +248,7 @@ pub fn store_environment<'a>(\n // collects the upvars and packages them up for store_environment.\n fn build_closure<'a>(bcx0: &'a Block<'a>,\n                      cap_vars: &[moves::CaptureVar],\n-                     sigil: ast::Sigil)\n+                     store: ty::TraitStore)\n                      -> ClosureResult<'a> {\n     let _icx = push_ctxt(\"closure::build_closure\");\n \n@@ -268,7 +262,11 @@ fn build_closure<'a>(bcx0: &'a Block<'a>,\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             moves::CapRef => {\n-                assert_eq!(sigil, ast::BorrowedSigil);\n+                let is_region_closure = match store {\n+                    ty::RegionTraitStore(..) => true,\n+                    ty::UniqTraitStore => false\n+                };\n+                assert!(is_region_closure);\n                 env_vals.push(EnvValue {action: EnvRef,\n                                         datum: datum});\n             }\n@@ -283,15 +281,15 @@ fn build_closure<'a>(bcx0: &'a Block<'a>,\n         }\n     }\n \n-    return store_environment(bcx, env_vals, sigil);\n+    store_environment(bcx, env_vals, store)\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n                         cap_vars: &[moves::CaptureVar],\n-                        sigil: ast::Sigil) -> &'a Block<'a> {\n+                        store: ty::TraitStore) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n     // Don't bother to create the block if there's nothing to load\n@@ -316,9 +314,9 @@ fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n     let mut i = 0u;\n     for cap_var in cap_vars.iter() {\n         let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n-        match sigil {\n-            ast::BorrowedSigil => { upvarptr = Load(bcx, upvarptr); }\n-            ast::ManagedSigil | ast::OwnedSigil => {}\n+        match store {\n+            ty::RegionTraitStore(..) => { upvarptr = Load(bcx, upvarptr); }\n+            ty::UniqTraitStore => {}\n         }\n         let def_id = ast_util::def_id_of_def(cap_var.def);\n \n@@ -331,7 +329,7 @@ fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n                 cdata_ty,\n                 env_pointer_alloca,\n                 i,\n-                sigil,\n+                store,\n                 cap_var.span);\n         }\n \n@@ -349,7 +347,7 @@ fn fill_fn_pair(bcx: &Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef)\n \n pub fn trans_expr_fn<'a>(\n                      bcx: &'a Block<'a>,\n-                     sigil: ast::Sigil,\n+                     store: ty::TraitStore,\n                      decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      id: ast::NodeId,\n@@ -359,7 +357,7 @@ pub fn trans_expr_fn<'a>(\n      *\n      * Translates the body of a closure expression.\n      *\n-     * - `sigil`\n+     * - `store`\n      * - `decl`\n      * - `body`\n      * - `id`: The id of the closure expression.\n@@ -399,11 +397,11 @@ pub fn trans_expr_fn<'a>(\n \n     let cap_vars = ccx.maps.capture_map.borrow().get_copy(&id);\n     let ClosureResult {llbox, cdata_ty, bcx} =\n-        build_closure(bcx, cap_vars.as_slice(), sigil);\n+        build_closure(bcx, cap_vars.as_slice(), store);\n     trans_closure(ccx, decl, body, llfn,\n                   bcx.fcx.param_substs, id,\n                   [], ty::ty_fn_ret(fty),\n-                  |bcx| load_environment(bcx, cdata_ty, cap_vars.as_slice(), sigil));\n+                  |bcx| load_environment(bcx, cdata_ty, cap_vars.as_slice(), store));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n \n     bcx"}, {"sha": "e0a54234fca7e0fedba76f903cb396e3a1ea556b", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -191,7 +191,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n         None => { }\n         Some(adj) => {\n             match *adj {\n-                ty::AutoAddEnv(ty::ReStatic, ast::BorrowedSigil) => {\n+                ty::AutoAddEnv(ty::RegionTraitStore(ty::ReStatic, _)) => {\n                     let def = ty::resolve_expr(cx.tcx(), e);\n                     let wrapper = closure::get_wrapper_for_bare_fn(cx,\n                                                                    ety_adjusted,\n@@ -200,13 +200,11 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                                                    is_local);\n                     llconst = C_struct(cx, [wrapper, C_null(Type::i8p(cx))], false)\n                 }\n-                ty::AutoAddEnv(ref r, ref s) => {\n+                ty::AutoAddEnv(store) => {\n                     cx.sess()\n                       .span_bug(e.span,\n-                                format!(\"unexpected static function: region \\\n-                                         {:?} sigil {:?}\",\n-                                        *r,\n-                                        *s))\n+                                format!(\"unexpected static function: {:?}\",\n+                                        store))\n                 }\n                 ty::AutoObject(..) => {\n                     cx.sess()"}, {"sha": "ae58e153258ef467d9726aab94a31858b37c623e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -394,7 +394,7 @@ pub fn create_captured_var_metadata(bcx: &Block,\n                                     env_data_type: ty::t,\n                                     env_pointer: ValueRef,\n                                     env_index: uint,\n-                                    closure_sigil: ast::Sigil,\n+                                    closure_store: ty::TraitStore,\n                                     span: Span) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n@@ -443,11 +443,11 @@ pub fn create_captured_var_metadata(bcx: &Block,\n          llvm::LLVMDIBuilderCreateOpDeref(Type::i64(cx).to_ref())]\n     };\n \n-    let address_op_count = match closure_sigil {\n-        ast::BorrowedSigil => {\n+    let address_op_count = match closure_store {\n+        ty::RegionTraitStore(..) => {\n             address_operations.len()\n         }\n-        ast::ManagedSigil | ast::OwnedSigil => {\n+        ty::UniqTraitStore => {\n             address_operations.len() - 1\n         }\n     };"}, {"sha": "e19408520f6ee765a516fd3cfcd6d741edbf702a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -62,7 +62,7 @@ use middle::trans::type_of;\n use middle::trans::write_guard;\n use middle::ty::struct_fields;\n use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoObject, AutoUnsafe};\n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n+use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef};\n use middle::ty;\n use middle::typeck::MethodCall;\n use util::common::indenter;\n@@ -200,14 +200,6 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n                 Some(AutoBorrowVecRef(..)) => {\n                     unpack_datum!(bcx, auto_slice_and_ref(bcx, expr, datum))\n                 }\n-                Some(AutoBorrowFn(..)) => {\n-                    let adjusted_ty = ty::adjust_ty(bcx.tcx(), expr.span, expr.id, datum.ty,\n-                                                    Some(adjustment), |method_call| {\n-                        bcx.ccx().maps.method_map.borrow()\n-                           .find(&method_call).map(|method| method.ty)\n-                    });\n-                    unpack_datum!(bcx, auto_borrow_fn(bcx, adjusted_ty, datum))\n-                }\n                 Some(AutoBorrowObj(..)) => {\n                     unpack_datum!(bcx, auto_borrow_obj(bcx, expr, datum))\n                 }\n@@ -225,20 +217,6 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n     debug!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n-    fn auto_borrow_fn<'a>(\n-                      bcx: &'a Block<'a>,\n-                      adjusted_ty: ty::t,\n-                      datum: Datum<Expr>)\n-                      -> DatumBlock<'a, Expr> {\n-        // Currently, all closure types are represented precisely the\n-        // same, so no runtime adjustment is required, but we still\n-        // must patchup the type.\n-        DatumBlock {bcx: bcx,\n-                    datum: Datum {val: datum.val,\n-                                  ty: adjusted_ty,\n-                                  kind: datum.kind}}\n-    }\n-\n     fn auto_slice<'a>(\n                   bcx: &'a Block<'a>,\n                   expr: &ast::Expr,\n@@ -731,10 +709,10 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprFnBlock(decl, body) |\n         ast::ExprProc(decl, body) => {\n             let expr_ty = expr_ty(bcx, expr);\n-            let sigil = ty::ty_closure_sigil(expr_ty);\n+            let store = ty::ty_closure_store(expr_ty);\n             debug!(\"translating block function {} with type {}\",\n                    expr_to_str(expr), expr_ty.repr(tcx));\n-            closure::trans_expr_fn(bcx, sigil, decl, body, expr.id, dest)\n+            closure::trans_expr_fn(bcx, store, decl, body, expr.id, dest)\n         }\n         ast::ExprCall(f, ref args) => {\n             callee::trans_call(bcx, expr, f, callee::ArgExprs(args.as_slice()), dest)"}, {"sha": "98e135c27c4862fdd0935873dd7f2db7fe6696fe", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -323,7 +323,7 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 bcx\n             })\n         }\n-        ty::ty_closure(ref f) if f.sigil == ast::OwnedSigil => {\n+        ty::ty_closure(ref f) if f.store == ty::UniqTraitStore => {\n             let box_cell_v = GEPi(bcx, v0, [0u, abi::fn_field_box]);\n             let env = Load(bcx, box_cell_v);\n             let env_ptr_ty = Type::at_box(bcx.ccx(), Type::i8(bcx.ccx())).ptr_to();"}, {"sha": "3fe494ad41b0eca83ddc9d5bab76670bb1982d81", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -218,7 +218,10 @@ impl<'a> Reflector<'a> {\n           // FIXME (#4809): visitor should break out bare fns from other fns\n           ty::ty_closure(ref fty) => {\n             let pureval = ast_fn_style_constant(fty.fn_style);\n-            let sigilval = ast_sigil_constant(fty.sigil);\n+            let sigilval = match fty.store {\n+                ty::UniqTraitStore => 2u,\n+                ty::RegionTraitStore(..) => 4u,\n+            };\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n             let extra = vec!(self.c_uint(pureval),\n                           self.c_uint(sigilval),\n@@ -397,14 +400,6 @@ pub fn emit_calls_to_trait_visit_ty<'a>(\n     return final;\n }\n \n-pub fn ast_sigil_constant(sigil: ast::Sigil) -> uint {\n-    match sigil {\n-        ast::OwnedSigil => 2u,\n-        ast::ManagedSigil => 3u,\n-        ast::BorrowedSigil => 4u,\n-    }\n-}\n-\n pub fn ast_fn_style_constant(fn_style: ast::FnStyle) -> uint {\n     match fn_style {\n         ast::UnsafeFn => 1u,"}, {"sha": "af53c31ad4eecd9fdea0002f60f462a45f01af70", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 30, "deletions": 70, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -214,7 +214,7 @@ pub enum Variance {\n }\n \n pub enum AutoAdjustment {\n-    AutoAddEnv(ty::Region, ast::Sigil),\n+    AutoAddEnv(ty::TraitStore),\n     AutoDerefRef(AutoDerefRef),\n     AutoObject(ty::TraitStore,\n                ty::BuiltinBounds,\n@@ -239,9 +239,6 @@ pub enum AutoRef {\n     /// Convert from ~[]/&[] to &&[] (or str)\n     AutoBorrowVecRef(Region, ast::Mutability),\n \n-    /// Convert from @fn()/~fn()/|| to ||\n-    AutoBorrowFn(Region),\n-\n     /// Convert from T to *T\n     AutoUnsafe(ast::Mutability),\n \n@@ -430,9 +427,8 @@ pub struct BareFnTy {\n #[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct ClosureTy {\n     pub fn_style: ast::FnStyle,\n-    pub sigil: ast::Sigil,\n     pub onceness: ast::Onceness,\n-    pub region: Region,\n+    pub store: TraitStore,\n     pub bounds: BuiltinBounds,\n     pub sig: FnSig,\n }\n@@ -801,7 +797,7 @@ pub enum type_err {\n     terr_onceness_mismatch(expected_found<Onceness>),\n     terr_abi_mismatch(expected_found<abi::Abi>),\n     terr_mutability,\n-    terr_sigil_mismatch(expected_found<ast::Sigil>),\n+    terr_sigil_mismatch(expected_found<TraitStore>),\n     terr_box_mutability,\n     terr_ptr_mutability,\n     terr_ref_mutability,\n@@ -1204,11 +1200,13 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_param(_) => flags |= has_params as uint,\n       &ty_infer(_) => flags |= needs_infer as uint,\n       &ty_self(_) => flags |= has_self as uint,\n-      &ty_enum(_, ref substs) | &ty_struct(_, ref substs) |\n-      &ty_trait(~ty::TyTrait { ref substs, .. }) => {\n+      &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n+          flags |= sflags(substs);\n+      }\n+      &ty_trait(~ty::TyTrait { ref substs, store, .. }) => {\n           flags |= sflags(substs);\n-          match st {\n-              ty_trait(~ty::TyTrait { store: RegionTraitStore(r, _), .. }) => {\n+          match store {\n+              RegionTraitStore(r, _) => {\n                     flags |= rflags(r);\n                 }\n               _ => {}\n@@ -1232,7 +1230,12 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         flags &= !(has_ty_bot as uint);\n       }\n       &ty_closure(ref f) => {\n-        flags |= rflags(f.region);\n+        match f.store {\n+            RegionTraitStore(r, _) => {\n+                flags |= rflags(r);\n+            }\n+            _ => {}\n+        }\n         for a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n         flags |= get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n@@ -2217,17 +2220,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n     fn closure_contents(cx: &ctxt, cty: &ClosureTy) -> TypeContents {\n         // Closure contents are just like trait contents, but with potentially\n         // even more stuff.\n-        let st = match cty.sigil {\n-            ast::BorrowedSigil =>\n-                object_contents(cx, RegionTraitStore(cty.region, MutMutable), cty.bounds),\n-            ast::OwnedSigil => object_contents(cx, UniqTraitStore, cty.bounds),\n-            ast::ManagedSigil => unreachable!()\n-        };\n-\n-        // FIXME(#3569): This borrowed_contents call should be taken care of in\n-        // object_contents, after ~Traits and @Traits can have region bounds too.\n-        // This one here is redundant for &fns but important for ~fns and @fns.\n-        let rt = borrowed_contents(cty.region, ast::MutImmutable);\n+        let st = object_contents(cx, cty.store, cty.bounds);\n \n         // This also prohibits \"@once fn\" from being copied, which allows it to\n         // be called. Neither way really makes much sense.\n@@ -2236,7 +2229,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n             ast::Many => TC::None,\n         };\n \n-        st | rt | ot\n+        st | ot\n     }\n \n     fn object_contents(cx: &ctxt,\n@@ -2696,11 +2689,11 @@ pub fn ty_fn_args(fty: t) -> Vec<t> {\n     }\n }\n \n-pub fn ty_closure_sigil(fty: t) -> Sigil {\n+pub fn ty_closure_store(fty: t) -> TraitStore {\n     match get(fty).sty {\n-        ty_closure(ref f) => f.sigil,\n+        ty_closure(ref f) => f.store,\n         ref s => {\n-            fail!(\"ty_closure_sigil() called on non-closure type: {:?}\", s)\n+            fail!(\"ty_closure_store() called on non-closure type: {:?}\", s)\n         }\n     }\n }\n@@ -2838,15 +2831,14 @@ pub fn adjust_ty(cx: &ctxt,\n     return match adjustment {\n         Some(adjustment) => {\n             match *adjustment {\n-                AutoAddEnv(r, s) => {\n+                AutoAddEnv(store) => {\n                     match ty::get(unadjusted_ty).sty {\n                         ty::ty_bare_fn(ref b) => {\n                             ty::mk_closure(\n                                 cx,\n                                 ty::ClosureTy {fn_style: b.fn_style,\n-                                               sigil: s,\n                                                onceness: ast::Many,\n-                                               region: r,\n+                                               store: store,\n                                                bounds: ty::AllBuiltinBounds(),\n                                                sig: b.sig.clone()})\n                         }\n@@ -2911,10 +2903,6 @@ pub fn adjust_ty(cx: &ctxt,\n                                     })\n                                 }\n \n-                                AutoBorrowFn(r) => {\n-                                    borrow_fn(cx, span, r, adjusted_ty)\n-                                }\n-\n                                 AutoUnsafe(m) => {\n                                     mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n                                 }\n@@ -2956,25 +2944,6 @@ pub fn adjust_ty(cx: &ctxt,\n         }\n     }\n \n-    fn borrow_fn(cx: &ctxt, span: Span, r: Region, ty: ty::t) -> ty::t {\n-        match get(ty).sty {\n-            ty_closure(ref fty) => {\n-                ty::mk_closure(cx, ClosureTy {\n-                    sigil: BorrowedSigil,\n-                    region: r,\n-                    ..(**fty).clone()\n-                })\n-            }\n-\n-            ref s => {\n-                cx.sess.span_bug(\n-                    span,\n-                    format!(\"borrow-fn associated with bad sty: {:?}\",\n-                         s));\n-            }\n-        }\n-    }\n-\n     fn borrow_obj(cx: &ctxt, span: Span, r: Region,\n                   m: ast::Mutability, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n@@ -2998,7 +2967,6 @@ impl AutoRef {\n             ty::AutoPtr(r, m) => ty::AutoPtr(f(r), m),\n             ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(f(r), m),\n             ty::AutoBorrowVecRef(r, m) => ty::AutoBorrowVecRef(f(r), m),\n-            ty::AutoBorrowFn(r) => ty::AutoBorrowFn(f(r)),\n             ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n             ty::AutoBorrowObj(r, m) => ty::AutoBorrowObj(f(r), m),\n         }\n@@ -4278,20 +4246,6 @@ pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::Expr) ->\n     }\n }\n \n-// Determine what the style to check a nested function under\n-pub fn determine_inherited_style(parent: (ast::FnStyle, ast::NodeId),\n-                                  child: (ast::FnStyle, ast::NodeId),\n-                                  child_sigil: ast::Sigil)\n-                                    -> (ast::FnStyle, ast::NodeId) {\n-    // If the closure is a stack closure and hasn't had some non-standard\n-    // style inferred for it, then check it under its parent's style.\n-    // Otherwise, use its own\n-    match child_sigil {\n-        ast::BorrowedSigil if child.val0() == ast::NormalFn => parent,\n-        _ => child\n-    }\n-}\n-\n // Iterate over a type parameter's bounded traits and any supertraits\n // of those traits, ignoring kinds.\n // Here, the supertraits are the transitive closure of the supertrait\n@@ -4640,10 +4594,16 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             ty_closure(ref c) => {\n                 byte!(15);\n                 hash!(c.fn_style);\n-                hash!(c.sigil);\n                 hash!(c.onceness);\n                 hash!(c.bounds);\n-                region(&mut state, c.region);\n+                match c.store {\n+                    UniqTraitStore => byte!(0),\n+                    RegionTraitStore(r, m) => {\n+                        byte!(1)\n+                        region(&mut state, r);\n+                        assert_eq!(m, ast::MutMutable);\n+                    }\n+                }\n             }\n             ty_trait(~ty::TyTrait { def_id: d, store, bounds, .. }) => {\n                 byte!(17);"}, {"sha": "840f741badb7a9576b5efddac83681c9cd9d573c", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -56,10 +56,9 @@ pub trait TypeFolder {\n                        fty: &ty::ClosureTy)\n                        -> ty::ClosureTy {\n         ty::ClosureTy {\n-            region: self.fold_region(fty.region),\n+            store: self.fold_trait_store(fty.store),\n             sig: self.fold_sig(&fty.sig),\n             fn_style: fty.fn_style,\n-            sigil: fty.sigil,\n             onceness: fty.onceness,\n             bounds: fty.bounds,\n         }"}, {"sha": "99f10395437a5ee0bbd9f62e5caf254adcebb5ff", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 34, "deletions": 50, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -112,7 +112,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n     r\n }\n \n-fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n+pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     default_span: Span,\n@@ -516,33 +516,42 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.fn_style,\n                                                   bf.abi, bf.decl))\n             }\n-            ast::TyClosure(ref f) => {\n-                if f.sigil == ast::ManagedSigil {\n-                    tcx.sess.span_err(ast_ty.span,\n-                                      \"managed closures are not supported\");\n-                }\n+            ast::TyClosure(ref f, ref region) => {\n+\n+                // resolve the function bound region in the original region\n+                // scope `rscope`, not the scope of the function parameters\n+                let bound_region = opt_ast_region_to_region(this, rscope,\n+                                                            ast_ty.span, region);\n+\n+                let store = ty::RegionTraitStore(bound_region, ast::MutMutable);\n+\n+                // Use corresponding trait store to figure out default bounds\n+                // if none were specified.\n+                let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, store);\n \n-                let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, match f.sigil {\n-                        // Use corresponding trait store to figure out default bounds\n-                        // if none were specified.\n-                        ast::BorrowedSigil => {\n-                            // dummy region\n-                            ty::RegionTraitStore(ty::ReEmpty, ast::MutMutable)\n-                        }\n-                        ast::OwnedSigil    => ty::UniqTraitStore,\n-                        ast::ManagedSigil  => return ty::mk_err()\n-                    });\n                 let fn_decl = ty_of_closure(this,\n-                                            rscope,\n                                             ast_ty.id,\n-                                            f.sigil,\n                                             f.fn_style,\n                                             f.onceness,\n                                             bounds,\n-                                            &f.region,\n+                                            store,\n                                             f.decl,\n-                                            None,\n-                                            ast_ty.span);\n+                                            None);\n+                ty::mk_closure(tcx, fn_decl)\n+            }\n+            ast::TyProc(ref f) => {\n+                // Use corresponding trait store to figure out default bounds\n+                // if none were specified.\n+                let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, ty::UniqTraitStore);\n+\n+                let fn_decl = ty_of_closure(this,\n+                                            ast_ty.id,\n+                                            f.fn_style,\n+                                            f.onceness,\n+                                            bounds,\n+                                            ty::UniqTraitStore,\n+                                            f.decl,\n+                                            None);\n                 ty::mk_closure(tcx, fn_decl)\n             }\n             ast::TyPath(ref path, ref bounds, id) => {\n@@ -728,43 +737,19 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n     };\n }\n \n-pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n+pub fn ty_of_closure<AC:AstConv>(\n     this: &AC,\n-    rscope: &RS,\n     id: ast::NodeId,\n-    sigil: ast::Sigil,\n     fn_style: ast::FnStyle,\n     onceness: ast::Onceness,\n     bounds: ty::BuiltinBounds,\n-    opt_lifetime: &Option<ast::Lifetime>,\n+    store: ty::TraitStore,\n     decl: &ast::FnDecl,\n-    expected_sig: Option<ty::FnSig>,\n-    span: Span)\n+    expected_sig: Option<ty::FnSig>)\n     -> ty::ClosureTy\n {\n     debug!(\"ty_of_fn_decl\");\n \n-    // resolve the function bound region in the original region\n-    // scope `rscope`, not the scope of the function parameters\n-    let bound_region = match opt_lifetime {\n-        &Some(ref lifetime) => {\n-            ast_region_to_region(this.tcx(), lifetime)\n-        }\n-        &None => {\n-            match sigil {\n-                ast::OwnedSigil | ast::ManagedSigil => {\n-                    // @fn(), ~fn() default to static as the bound\n-                    // on their upvars:\n-                    ty::ReStatic\n-                }\n-                ast::BorrowedSigil => {\n-                    // || defaults as normal for an omitted lifetime:\n-                    opt_ast_region_to_region(this, rscope, span, opt_lifetime)\n-                }\n-            }\n-        }\n-    };\n-\n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n     let rb = rscope::BindingRscope::new(id);\n@@ -791,9 +776,8 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n \n     ty::ClosureTy {\n         fn_style: fn_style,\n-        sigil: sigil,\n         onceness: onceness,\n-        region: bound_region,\n+        store: store,\n         bounds: bounds,\n         sig: ty::FnSig {binder_id: id,\n                         inputs: input_tys,"}, {"sha": "d9f4527e9d1e99014d0f1362794b060f6e5ccaf0", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -2116,7 +2116,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     fn check_expr_fn(fcx: &FnCtxt,\n                      expr: &ast::Expr,\n-                     ast_sigil_opt: Option<ast::Sigil>,\n+                     store: ty::TraitStore,\n                      decl: &ast::FnDecl,\n                      body: ast::P<ast::Block>,\n                      fn_kind: FnKind,\n@@ -2126,18 +2126,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Find the expected input/output types (if any). Substitute\n         // fresh bound regions for any bound regions we find in the\n         // expected types so as to avoid capture.\n-        //\n-        // Also try to pick up inferred style and sigil, defaulting\n-        // to impure and block. Note that we only will use those for\n-        // block syntax lambdas; that is, lambdas without explicit\n-        // sigils.\n         let expected_sty = unpack_expected(fcx,\n                                            expected,\n                                            |x| Some((*x).clone()));\n         let error_happened = false;\n         let (expected_sig,\n-             expected_style,\n-             expected_sigil,\n              expected_onceness,\n              expected_bounds) = {\n             match expected_sty {\n@@ -2146,47 +2139,32 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         replace_late_bound_regions_in_fn_sig(\n                             tcx, &cenv.sig,\n                             |_| fcx.inh.infcx.fresh_bound_region(expr.id));\n-                    (Some(sig), cenv.fn_style, cenv.sigil,\n-                     cenv.onceness, cenv.bounds)\n+                    (Some(sig), cenv.onceness, cenv.bounds)\n                 }\n                 _ => {\n                     // Not an error! Means we're inferring the closure type\n-                    let mut sigil = ast::BorrowedSigil;\n-                    let mut onceness = ast::Many;\n                     let mut bounds = ty::EmptyBuiltinBounds();\n-                    match expr.node {\n+                    let onceness = match expr.node {\n                         ast::ExprProc(..) => {\n-                            sigil = ast::OwnedSigil;\n-                            onceness = ast::Once;\n                             bounds.add(ty::BoundSend);\n+                            ast::Once\n                         }\n-                        _ => ()\n-                    }\n-                    (None, ast::NormalFn, sigil,\n-                     onceness, bounds)\n+                        _ => ast::Many\n+                    };\n+                    (None, onceness, bounds)\n                 }\n             }\n         };\n \n-        // If the proto is specified, use that, otherwise select a\n-        // proto based on inference.\n-        let (sigil, fn_style) = match ast_sigil_opt {\n-            Some(p) => (p, ast::NormalFn),\n-            None => (expected_sigil, expected_style)\n-        };\n-\n         // construct the function type\n         let fn_ty = astconv::ty_of_closure(fcx,\n-                                           fcx.infcx(),\n                                            expr.id,\n-                                           sigil,\n-                                           fn_style,\n+                                           ast::NormalFn,\n                                            expected_onceness,\n                                            expected_bounds,\n-                                           &None,\n+                                           store,\n                                            decl,\n-                                           expected_sig,\n-                                           expr.span);\n+                                           expected_sig);\n \n         let fty_sig;\n         let fty = if error_happened {\n@@ -2198,21 +2176,23 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             };\n             ty::mk_err()\n         } else {\n-            let fn_ty_copy = fn_ty.clone();\n             fty_sig = fn_ty.sig.clone();\n-            ty::mk_closure(tcx, fn_ty_copy)\n+            ty::mk_closure(tcx, fn_ty.clone())\n         };\n \n         debug!(\"check_expr_fn_with_unifier fty={}\",\n                fcx.infcx().ty_to_str(fty));\n \n         fcx.write_ty(expr.id, fty);\n \n-        let (inherited_style, id) =\n-            ty::determine_inherited_style((fcx.ps.borrow().fn_style,\n-                                            fcx.ps.borrow().def),\n-                                           (fn_style, expr.id),\n-                                           sigil);\n+        // If the closure is a stack closure and hasn't had some non-standard\n+        // style inferred for it, then check it under its parent's style.\n+        // Otherwise, use its own\n+        let (inherited_style, id) = match store {\n+            ty::RegionTraitStore(..) => (fcx.ps.borrow().fn_style,\n+                                         fcx.ps.borrow().def),\n+            ty::UniqTraitStore => (ast::NormalFn, expr.id)\n+        };\n \n         check_fn(fcx.ccx, inherited_style, &fty_sig,\n                  decl, id, body, fn_kind, fcx.inh);\n@@ -2856,9 +2836,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         _match::check_match(fcx, expr, discrim, arms.as_slice());\n       }\n       ast::ExprFnBlock(decl, body) => {\n+        let region = astconv::opt_ast_region_to_region(fcx,\n+                                                       fcx.infcx(),\n+                                                       expr.span,\n+                                                       &None);\n         check_expr_fn(fcx,\n                       expr,\n-                      Some(ast::BorrowedSigil),\n+                      ty::RegionTraitStore(region, ast::MutMutable),\n                       decl,\n                       body,\n                       Vanilla,\n@@ -2867,7 +2851,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprProc(decl, body) => {\n         check_expr_fn(fcx,\n                       expr,\n-                      Some(ast::OwnedSigil),\n+                      ty::UniqTraitStore,\n                       decl,\n                       body,\n                       Vanilla,"}, {"sha": "9e7bb1b10f60f3279ea4bca78888585fa09e227f", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -133,7 +133,6 @@ use middle::typeck::MethodCall;\n use middle::pat_util;\n use util::ppaux::{ty_to_str, region_to_str, Repr};\n \n-use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{DefArg, DefBinding, DefLocal, DefUpvar};\n use syntax::ast;\n use syntax::ast_util;\n@@ -175,9 +174,9 @@ fn region_of_def(fcx: &FnCtxt, def: ast::Def) -> ty::Region {\n             tcx.region_maps.var_region(node_id)\n         }\n         DefUpvar(_, subdef, closure_id, body_id) => {\n-            match ty::ty_closure_sigil(fcx.node_ty(closure_id)) {\n-                BorrowedSigil => region_of_def(fcx, *subdef),\n-                ManagedSigil | OwnedSigil => ReScope(body_id)\n+            match ty::ty_closure_store(fcx.node_ty(closure_id)) {\n+                ty::RegionTraitStore(..) => region_of_def(fcx, *subdef),\n+                ty::UniqTraitStore => ReScope(body_id)\n             }\n         }\n         _ => {\n@@ -611,7 +610,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     let function_type = rcx.resolve_node_type(expr.id);\n     match ty::get(function_type).sty {\n         ty::ty_closure(~ty::ClosureTy {\n-                sigil: ast::BorrowedSigil, region: region, ..}) => {\n+                store: ty::RegionTraitStore(region, _), ..}) => {\n             let freevars = freevars::get_freevars(tcx, expr.id);\n             if freevars.is_empty() {\n                 // No free variables means that the environment\n@@ -635,7 +634,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     rcx.set_repeating_scope(repeating_scope);\n \n     match ty::get(function_type).sty {\n-        ty::ty_closure(~ty::ClosureTy {sigil: ast::BorrowedSigil, ..}) => {\n+        ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(..), ..}) => {\n             let freevars = freevars::get_freevars(tcx, expr.id);\n             propagate_upupvar_borrow_kind(rcx, expr, freevars);\n         }\n@@ -749,8 +748,12 @@ fn constrain_callee(rcx: &mut Rcx,\n     match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(..) => { }\n         ty::ty_closure(ref closure_ty) => {\n+            let region = match closure_ty.store {\n+                ty::RegionTraitStore(r, _) => r,\n+                ty::UniqTraitStore => ty::ReStatic\n+            };\n             rcx.fcx.mk_subr(true, infer::InvokeClosure(callee_expr.span),\n-                            call_region, closure_ty.region);\n+                            call_region, region);\n         }\n         _ => {\n             // this should not happen, but it does if the program is\n@@ -1120,13 +1123,8 @@ fn link_autoref(rcx: &mut Rcx,\n             link_region(mc.typer, expr.span, r, m, cmt_index);\n         }\n \n-        ty::AutoBorrowFn(r) => {\n-            let cmt_deref = mc.cat_deref_fn_or_obj(expr, expr_cmt, 0);\n-            link_region(mc.typer, expr.span, r, ast::MutImmutable, cmt_deref);\n-        }\n-\n         ty::AutoBorrowObj(r, m) => {\n-            let cmt_deref = mc.cat_deref_fn_or_obj(expr, expr_cmt, 0);\n+            let cmt_deref = mc.cat_deref_obj(expr, expr_cmt);\n             link_region(mc.typer, expr.span, r, m, cmt_deref);\n         }\n "}, {"sha": "6ad3d380b286b7266ba8575066cee6067ec90b8c", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -141,7 +141,11 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n \n         Some(adjustment) => {\n             match *adjustment {\n-                ty::AutoAddEnv(r, s) => {\n+                ty::AutoAddEnv(store) => {\n+                    let r = match store {\n+                        ty::RegionTraitStore(r, _) => r,\n+                        ty::UniqTraitStore => ty::ReStatic\n+                    };\n                     match resolve_region(fcx.infcx(),\n                                          r,\n                                          resolve_all | force_all) {\n@@ -166,7 +170,12 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                                         \"cannot coerce non-statically resolved bare fn\")\n                             }\n \n-                            let resolved_adj = @ty::AutoAddEnv(r1, s);\n+                            let resolved_adj = @ty::AutoAddEnv(match store {\n+                                ty::RegionTraitStore(..) => {\n+                                    ty::RegionTraitStore(r1, ast::MutMutable)\n+                                }\n+                                ty::UniqTraitStore => ty::UniqTraitStore\n+                            });\n                             debug!(\"Adjustments for node {}: {:?}\",\n                                    id, resolved_adj);\n                             tcx.adjustments.borrow_mut().insert(id, resolved_adj);"}, {"sha": "7d1ffa4451fb764ef14a51670019bcc5dd5177a5", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -65,8 +65,7 @@ we may want to adjust precisely when coercions occur.\n */\n \n \n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn, AutoBorrowObj};\n-use middle::ty::{AutoDerefRef};\n+use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowObj, AutoDerefRef};\n use middle::ty::{VstoreSlice, VstoreUniq};\n use middle::ty::{mt};\n use middle::ty;\n@@ -120,7 +119,7 @@ impl<'f> Coerce<'f> {\n                 });\n             }\n \n-            ty::ty_closure(~ty::ClosureTy {sigil: ast::BorrowedSigil, ..}) => {\n+            ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(..), ..}) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_fn(a, sty_a, b)\n                 });\n@@ -342,33 +341,14 @@ impl<'f> Coerce<'f> {\n                a.inf_str(self.get_ref().infcx), sty_a,\n                b.inf_str(self.get_ref().infcx));\n \n-        let fn_ty = match *sty_a {\n-            ty::ty_closure(ref f) if f.sigil == ast::ManagedSigil ||\n-                                     f.sigil == ast::OwnedSigil => {\n-                (*f).clone()\n-            }\n+        match *sty_a {\n             ty::ty_bare_fn(ref f) => {\n-                return self.coerce_from_bare_fn(a, f, b);\n+                self.coerce_from_bare_fn(a, f, b)\n             }\n             _ => {\n-                return self.subtype(a, b);\n+                self.subtype(a, b)\n             }\n-        };\n-\n-        let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n-        let a_borrowed = ty::mk_closure(\n-            self.get_ref().infcx.tcx,\n-            ty::ClosureTy {\n-                sigil: ast::BorrowedSigil,\n-                region: r_borrow,\n-                .. *fn_ty\n-            });\n-\n-        if_ok!(self.subtype(a_borrowed, b));\n-        Ok(Some(@AutoDerefRef(AutoDerefRef {\n-            autoderefs: 0,\n-            autoref: Some(AutoBorrowFn(r_borrow))\n-        })))\n+        }\n     }\n \n     fn coerce_from_bare_fn(&self, a: ty::t, fn_ty_a: &ty::BareFnTy, b: ty::t)\n@@ -393,7 +373,7 @@ impl<'f> Coerce<'f> {\n                 _ => return self.subtype(a, b)\n             };\n \n-            let adj = @ty::AutoAddEnv(fn_ty_b.region, fn_ty_b.sigil);\n+            let adj = @ty::AutoAddEnv(fn_ty_b.store);\n             let a_closure = ty::mk_closure(self.get_ref().infcx.tcx,\n                                            ty::ClosureTy {\n                                                 sig: fn_ty_a.sig.clone(),"}, {"sha": "8c449a8f118f481e921e5e7c1f923c49c42a2052", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -205,18 +205,32 @@ pub trait Combine {\n     fn closure_tys(&self, a: &ty::ClosureTy,\n                    b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n \n-        let p = if_ok!(self.sigils(a.sigil, b.sigil));\n-        let r = if_ok!(self.contraregions(a.region, b.region));\n+        let store = match (a.store, b.store) {\n+            (ty::RegionTraitStore(a_r, a_m),\n+             ty::RegionTraitStore(b_r, b_m)) if a_m == b_m => {\n+                let r = if_ok!(self.contraregions(a_r, b_r));\n+                ty::RegionTraitStore(r, a_m)\n+            }\n+\n+            _ if a.store == b.store => {\n+                a.store\n+            }\n+\n+            _ => {\n+                return Err(ty::terr_sigil_mismatch(expected_found(self, a.store, b.store)))\n+            }\n+        };\n         let fn_style = if_ok!(self.fn_styles(a.fn_style, b.fn_style));\n         let onceness = if_ok!(self.oncenesses(a.onceness, b.onceness));\n         let bounds = if_ok!(self.bounds(a.bounds, b.bounds));\n         let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n-        Ok(ty::ClosureTy {fn_style: fn_style,\n-                sigil: p,\n-                onceness: onceness,\n-                region: r,\n-                bounds: bounds,\n-                sig: sig})\n+        Ok(ty::ClosureTy {\n+            fn_style: fn_style,\n+            onceness: onceness,\n+            store: store,\n+            bounds: bounds,\n+            sig: sig\n+        })\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n@@ -238,14 +252,6 @@ pub trait Combine {\n         self.contratys(a, b).and_then(|t| Ok(t))\n     }\n \n-    fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n-        if p1 == p2 {\n-            Ok(p1)\n-        } else {\n-            Err(ty::terr_sigil_mismatch(expected_found(self, p1, p2)))\n-        }\n-    }\n-\n     fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle>;\n \n     fn abi(&self, a: abi::Abi, b: abi::Abi) -> cres<abi::Abi> {"}, {"sha": "c6c79608f6c316fc4f270e7e254550a94dcea9e9", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -704,11 +704,13 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraint(index, variance);\n             }\n \n-            ty::ty_bare_fn(ty::BareFnTy { sig: ref sig, .. }) => {\n+            ty::ty_bare_fn(ty::BareFnTy { ref sig, .. }) |\n+            ty::ty_closure(~ty::ClosureTy { ref sig, store: ty::UniqTraitStore, .. }) => {\n                 self.add_constraints_from_sig(sig, variance);\n             }\n \n-            ty::ty_closure(~ty::ClosureTy { sig: ref sig, region, .. }) => {\n+            ty::ty_closure(~ty::ClosureTy { ref sig,\n+                    store: ty::RegionTraitStore(region, _), .. }) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(region, contra);\n                 self.add_constraints_from_sig(sig, variance);"}, {"sha": "63ea1a5ec86441be5f35e6c4a6126e49dce20aab", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 18, "deletions": 44, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -266,21 +266,11 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n     }\n \n     fn closure_to_str(cx: &ctxt, cty: &ty::ClosureTy) -> ~str {\n-        let is_proc =\n-            (cty.sigil, cty.onceness) == (ast::OwnedSigil, ast::Once);\n-        let is_borrowed_closure = cty.sigil == ast::BorrowedSigil;\n+        let mut s = StrBuf::new();\n \n-        let mut s = if is_proc || is_borrowed_closure {\n-            StrBuf::new()\n-        } else {\n-            StrBuf::from_owned_str(cty.sigil.to_str())\n-        };\n-\n-        match (cty.sigil, cty.region) {\n-            (ast::ManagedSigil, ty::ReStatic) |\n-            (ast::OwnedSigil, ty::ReStatic) => {}\n-\n-            (_, region) => {\n+        match cty.store {\n+            ty::UniqTraitStore => {}\n+            ty::RegionTraitStore(region, _) => {\n                 s.push_str(region_to_str(cx, \"\", true, region));\n             }\n         }\n@@ -293,40 +283,24 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n             }\n         };\n \n-        if is_proc {\n-            s.push_str(\"proc\");\n-        } else {\n-            match cty.onceness {\n-                ast::Many => {}\n-                ast::Once => {\n-                    s.push_str(cty.onceness.to_str());\n-                    s.push_char(' ');\n+        match cty.store {\n+            ty::UniqTraitStore => {\n+                assert_eq!(cty.onceness, ast::Once);\n+                s.push_str(\"proc\");\n+                push_sig_to_str(cx, &mut s, '(', ')', &cty.sig);\n+            }\n+            ty::RegionTraitStore(..) => {\n+                match cty.onceness {\n+                    ast::Many => {}\n+                    ast::Once => s.push_str(\"once \")\n                 }\n-            };\n-\n-            if !is_borrowed_closure {\n-                s.push_str(\"fn\");\n+                push_sig_to_str(cx, &mut s, '|', '|', &cty.sig);\n             }\n         }\n \n-        if !is_borrowed_closure {\n-            // Print bounds before `fn` if this is not a borrowed closure.\n-            if !cty.bounds.is_empty() {\n-                s.push_str(\":\");\n-                s.push_str(cty.bounds.repr(cx));\n-            }\n-\n-            push_sig_to_str(cx, &mut s, '(', ')', &cty.sig);\n-        } else {\n-            // Print bounds after the signature if this is a borrowed closure.\n-            push_sig_to_str(cx, &mut s, '|', '|', &cty.sig);\n-\n-            if is_borrowed_closure {\n-                if !cty.bounds.is_empty() {\n-                    s.push_str(\":\");\n-                    s.push_str(cty.bounds.repr(cx));\n-                }\n-            }\n+        if !cty.bounds.is_empty() {\n+            s.push_str(\":\");\n+            s.push_str(cty.bounds.repr(cx));\n         }\n \n         s.into_owned()"}, {"sha": "32a61fcca07f59d1e6713168da3c2664ac2bb403", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -474,8 +474,6 @@ impl Clean<Item> for doctree::Function {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct ClosureDecl {\n-    pub sigil: ast::Sigil,\n-    pub region: Option<Lifetime>,\n     pub lifetimes: Vec<Lifetime>,\n     pub decl: FnDecl,\n     pub onceness: ast::Onceness,\n@@ -486,8 +484,6 @@ pub struct ClosureDecl {\n impl Clean<ClosureDecl> for ast::ClosureTy {\n     fn clean(&self) -> ClosureDecl {\n         ClosureDecl {\n-            sigil: self.sigil,\n-            region: self.region.clean(),\n             lifetimes: self.lifetimes.clean().move_iter().collect(),\n             decl: self.decl.clean(),\n             onceness: self.onceness,\n@@ -652,7 +648,8 @@ pub enum Type {\n     Self(ast::NodeId),\n     /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n     Primitive(ast::PrimTy),\n-    Closure(~ClosureDecl),\n+    Closure(~ClosureDecl, Option<Lifetime>),\n+    Proc(~ClosureDecl),\n     /// extern \"ABI\" fn\n     BareFunction(~BareFunctionDecl),\n     Tuple(Vec<Type> ),\n@@ -706,7 +703,8 @@ impl Clean<Type> for ast::Ty {\n                              tpbs.clean().map(|x| x.move_iter().collect()),\n                              id)\n             }\n-            TyClosure(ref c) => Closure(~c.clean()),\n+            TyClosure(ref c, region) => Closure(~c.clean(), region.clean()),\n+            TyProc(ref c) => Proc(~c.clean()),\n             TyBareFn(ref barefn) => BareFunction(~barefn.clean()),\n             TyBot => Bottom,\n             ref x => fail!(\"Unimplemented type {:?}\", x),"}, {"sha": "66edbf82017e8d951462f4bd0b5bff7a53c20b30", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -337,19 +337,24 @@ impl fmt::Show for clean::Type {\n                 };\n                 f.buf.write(s.as_bytes())\n             }\n-            clean::Closure(ref decl) => {\n-                let region = match decl.region {\n+            clean::Closure(ref decl, ref region) => {\n+                let region = match *region {\n                     Some(ref region) => format!(\"{} \", *region),\n                     None => ~\"\",\n                 };\n \n-                write!(f.buf, \"{}{}{arrow, select, yes{ -&gt; {ret}} other{}}\",\n+                write!(f.buf, \"{}{}|{}|{arrow, select, yes{ -&gt; {ret}} other{}}\",\n                        FnStyleSpace(decl.fn_style),\n-                       match decl.sigil {\n-                           ast::OwnedSigil => format!(\"proc({})\", decl.decl.inputs),\n-                           ast::BorrowedSigil => format!(\"{}|{}|\", region, decl.decl.inputs),\n-                           ast::ManagedSigil => format!(\"@{}fn({})\", region, decl.decl.inputs),\n-                       },\n+                       region,\n+                       decl.decl.inputs,\n+                       arrow = match decl.decl.output { clean::Unit => \"no\", _ => \"yes\" },\n+                       ret = decl.decl.output)\n+                // FIXME: where are bounds and lifetimes printed?!\n+            }\n+            clean::Proc(ref decl) => {\n+                write!(f.buf, \"{}proc({}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n+                       FnStyleSpace(decl.fn_style),\n+                       decl.decl.inputs,\n                        arrow = match decl.decl.output { clean::Unit => \"no\", _ => \"yes\" },\n                        ret = decl.decl.output)\n                 // FIXME: where are bounds and lifetimes printed?!"}, {"sha": "a27a419e7bec80ad4deb6add49445966b032a57d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -359,23 +359,6 @@ pub enum Mutability {\n     MutImmutable,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n-pub enum Sigil {\n-    BorrowedSigil,\n-    OwnedSigil,\n-    ManagedSigil\n-}\n-\n-impl fmt::Show for Sigil {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            BorrowedSigil => \"&\".fmt(f),\n-            OwnedSigil => \"~\".fmt(f),\n-            ManagedSigil => \"@\".fmt(f),\n-         }\n-    }\n-}\n-\n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum ExprVstore {\n     ExprVstoreUniq,                 // ~[1,2,3,4]\n@@ -791,8 +774,6 @@ impl fmt::Show for Onceness {\n \n #[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct ClosureTy {\n-    pub sigil: Sigil,\n-    pub region: Option<Lifetime>,\n     pub lifetimes: Vec<Lifetime>,\n     pub fn_style: FnStyle,\n     pub onceness: Onceness,\n@@ -822,7 +803,8 @@ pub enum Ty_ {\n     TyFixedLengthVec(P<Ty>, @Expr),\n     TyPtr(MutTy),\n     TyRptr(Option<Lifetime>, MutTy),\n-    TyClosure(@ClosureTy),\n+    TyClosure(@ClosureTy, Option<Lifetime>),\n+    TyProc(@ClosureTy),\n     TyBareFn(@BareFnTy),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<OwnedSlice<TyParamBound>>, NodeId), // for #7264; see above"}, {"sha": "63df5566fa5df27803e92ddd1fa884eb5ecd3980", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -155,11 +155,18 @@ pub trait Folder {\n             TyRptr(ref region, ref mt) => {\n                 TyRptr(fold_opt_lifetime(region, self), fold_mt(mt, self))\n             }\n-            TyClosure(ref f) => {\n+            TyClosure(ref f, ref region) => {\n                 TyClosure(@ClosureTy {\n-                    sigil: f.sigil,\n                     fn_style: f.fn_style,\n-                    region: fold_opt_lifetime(&f.region, self),\n+                    onceness: f.onceness,\n+                    bounds: fold_opt_bounds(&f.bounds, self),\n+                    decl: self.fold_fn_decl(f.decl),\n+                    lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n+                }, fold_opt_lifetime(region, self))\n+            }\n+            TyProc(ref f) => {\n+                TyProc(@ClosureTy {\n+                    fn_style: f.fn_style,\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n                     decl: self.fold_fn_decl(f.decl),"}, {"sha": "88480c1b336a4a6d3cf3543bf80bc18382a721ae", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -11,7 +11,6 @@\n #![macro_escape]\n \n use abi;\n-use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil};\n use ast::{BareFnTy, ClosureTy};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{Provided, Public, FnStyle};\n@@ -49,8 +48,8 @@ use ast::StrStyle;\n use ast::{SelfRegion, SelfStatic, SelfUniq, SelfValue};\n use ast::{TokenTree, TraitMethod, TraitRef, TTDelim, TTSeq, TTTok};\n use ast::{TTNonterminal, TupleVariantKind, Ty, Ty_, TyBot, TyBox};\n-use ast::{TypeField, TyFixedLengthVec, TyClosure, TyBareFn, TyTypeof};\n-use ast::{TyInfer, TypeMethod};\n+use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n+use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyNil, TyParam, TyParamBound, TyPath, TyPtr, TyRptr};\n use ast::{TyTup, TyU32, TyUniq, TyVec, UnUniq};\n use ast::{UnnamedField, UnsafeBlock, UnsafeFn, ViewItem};\n@@ -923,9 +922,7 @@ impl<'a> Parser<'a> {\n             cf: ret_style,\n             variadic: variadic\n         });\n-        TyClosure(@ClosureTy {\n-            sigil: OwnedSigil,\n-            region: None,\n+        TyProc(@ClosureTy {\n             fn_style: NormalFn,\n             onceness: Once,\n             bounds: bounds,\n@@ -984,14 +981,12 @@ impl<'a> Parser<'a> {\n         });\n \n         TyClosure(@ClosureTy {\n-            sigil: BorrowedSigil,\n-            region: region,\n             fn_style: fn_style,\n             onceness: onceness,\n             bounds: bounds,\n             decl: decl,\n             lifetimes: lifetimes,\n-        })\n+        }, region)\n     }\n \n     pub fn parse_unsafety(&mut self) -> FnStyle {\n@@ -1201,11 +1196,11 @@ impl<'a> Parser<'a> {\n         } else if self.token == token::AT {\n             // MANAGED POINTER\n             self.bump();\n-            self.parse_box_or_uniq_pointee(ManagedSigil)\n+            TyBox(self.parse_ty(false))\n         } else if self.token == token::TILDE {\n             // OWNED POINTER\n             self.bump();\n-            self.parse_box_or_uniq_pointee(OwnedSigil)\n+            TyUniq(self.parse_ty(false))\n         } else if self.token == token::BINOP(token::STAR) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n@@ -1271,21 +1266,6 @@ impl<'a> Parser<'a> {\n         P(Ty {id: ast::DUMMY_NODE_ID, node: t, span: sp})\n     }\n \n-    // parse the type following a @ or a ~\n-    pub fn parse_box_or_uniq_pointee(&mut self,\n-                                     sigil: ast::Sigil)\n-                                     -> Ty_ {\n-        // other things are parsed as @/~ + a type.  Note that constructs like\n-        // ~[] and ~str will be resolved during typeck to slices and so forth,\n-        // rather than boxed ptrs.  But the special casing of str/vec is not\n-        // reflected in the AST type.\n-        if sigil == OwnedSigil {\n-            TyUniq(self.parse_ty(false))\n-        } else {\n-            TyBox(self.parse_ty(false))\n-        }\n-    }\n-\n     pub fn parse_borrowed_pointee(&mut self) -> Ty_ {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n         let opt_lifetime = self.parse_opt_lifetime();"}, {"sha": "4d911f6a89bdf54fcb15b04897c24f1e1f7e5db7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -483,14 +483,23 @@ impl<'a> State<'a> {\n                                    f.fn_style, ast::Many, f.decl, None, &None,\n                                    Some(&generics), None));\n             }\n-            ast::TyClosure(f) => {\n+            ast::TyClosure(f, ref region) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n                     ty_params: OwnedSlice::empty()\n                 };\n-                try!(self.print_ty_fn(None, Some(f.sigil), &f.region,\n-                                   f.fn_style, f.onceness, f.decl, None, &f.bounds,\n-                                   Some(&generics), None));\n+                try!(self.print_ty_fn(None, Some('&'), region, f.fn_style,\n+                                      f.onceness, f.decl, None, &f.bounds,\n+                                      Some(&generics), None));\n+            }\n+            ast::TyProc(f) => {\n+                let generics = ast::Generics {\n+                    lifetimes: f.lifetimes.clone(),\n+                    ty_params: OwnedSlice::empty()\n+                };\n+                try!(self.print_ty_fn(None, Some('~'), &None, f.fn_style,\n+                                      f.onceness, f.decl, None, &f.bounds,\n+                                      Some(&generics), None));\n             }\n             ast::TyPath(ref path, ref bounds, _) => {\n                 try!(self.print_bounded_path(path, bounds));\n@@ -1716,8 +1725,7 @@ impl<'a> State<'a> {\n                     opt_explicit_self: Option<ast::ExplicitSelf_>,\n                     vis: ast::Visibility) -> IoResult<()> {\n         try!(self.head(\"\"));\n-        try!(self.print_fn_header_info(opt_explicit_self, fn_style, abi,\n-                                       ast::Many, None, vis));\n+        try!(self.print_fn_header_info(opt_explicit_self, fn_style, abi, vis));\n         try!(self.nbsp());\n         try!(self.print_ident(name));\n         try!(self.print_generics(generics));\n@@ -2023,7 +2031,7 @@ impl<'a> State<'a> {\n \n     pub fn print_ty_fn(&mut self,\n                        opt_abi: Option<abi::Abi>,\n-                       opt_sigil: Option<ast::Sigil>,\n+                       opt_sigil: Option<char>,\n                        opt_region: &Option<ast::Lifetime>,\n                        fn_style: ast::FnStyle,\n                        onceness: ast::Onceness,\n@@ -2037,15 +2045,15 @@ impl<'a> State<'a> {\n \n         // Duplicates the logic in `print_fn_header_info()`.  This is because that\n         // function prints the sigil in the wrong place.  That should be fixed.\n-        if opt_sigil == Some(ast::OwnedSigil) && onceness == ast::Once {\n+        if opt_sigil == Some('~') && onceness == ast::Once {\n             try!(word(&mut self.s, \"proc\"));\n-        } else if opt_sigil == Some(ast::BorrowedSigil) {\n+        } else if opt_sigil == Some('&') {\n             try!(self.print_extern_opt_abi(opt_abi));\n             try!(self.print_fn_style(fn_style));\n             try!(self.print_onceness(onceness));\n         } else {\n+            assert!(opt_sigil.is_none());\n             try!(self.print_opt_abi_and_extern_if_nondefault(opt_abi));\n-            try!(self.print_opt_sigil(opt_sigil));\n             try!(self.print_fn_style(fn_style));\n             try!(self.print_onceness(onceness));\n             try!(word(&mut self.s, \"fn\"));\n@@ -2062,15 +2070,15 @@ impl<'a> State<'a> {\n         match generics { Some(g) => try!(self.print_generics(g)), _ => () }\n         try!(zerobreak(&mut self.s));\n \n-        if opt_sigil == Some(ast::BorrowedSigil) {\n+        if opt_sigil == Some('&') {\n             try!(word(&mut self.s, \"|\"));\n         } else {\n             try!(self.popen());\n         }\n \n         try!(self.print_fn_args(decl, opt_explicit_self));\n \n-        if opt_sigil == Some(ast::BorrowedSigil) {\n+        if opt_sigil == Some('&') {\n             try!(word(&mut self.s, \"|\"));\n         } else {\n             if decl.variadic {\n@@ -2327,22 +2335,10 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_opt_sigil(&mut self,\n-                           opt_sigil: Option<ast::Sigil>) -> IoResult<()> {\n-        match opt_sigil {\n-            Some(ast::BorrowedSigil) => word(&mut self.s, \"&\"),\n-            Some(ast::OwnedSigil) => word(&mut self.s, \"~\"),\n-            Some(ast::ManagedSigil) => word(&mut self.s, \"@\"),\n-            None => Ok(())\n-        }\n-    }\n-\n     pub fn print_fn_header_info(&mut self,\n                                 _opt_explicit_self: Option<ast::ExplicitSelf_>,\n                                 opt_fn_style: Option<ast::FnStyle>,\n                                 abi: abi::Abi,\n-                                onceness: ast::Onceness,\n-                                opt_sigil: Option<ast::Sigil>,\n                                 vis: ast::Visibility) -> IoResult<()> {\n         try!(word(&mut self.s, visibility_qualified(vis, \"\")));\n \n@@ -2357,9 +2353,7 @@ impl<'a> State<'a> {\n             try!(self.print_opt_fn_style(opt_fn_style));\n         }\n \n-        try!(self.print_onceness(onceness));\n-        try!(word(&mut self.s, \"fn\"));\n-        self.print_opt_sigil(opt_sigil)\n+        word(&mut self.s, \"fn\")\n     }\n \n     pub fn print_fn_style(&mut self, s: ast::FnStyle) -> IoResult<()> {"}, {"sha": "266de67b81d7e0295d1716613935bc38705cf765", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=96aeb7e3c35ee0d0cf5b9ab8db5ef69e4cfb264e", "patch": "@@ -328,7 +328,7 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n                 visitor.visit_ty(tuple_element_type, env.clone())\n             }\n         }\n-        TyClosure(ref function_declaration) => {\n+        TyClosure(ref function_declaration, ref region) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(argument.ty, env.clone())\n             }\n@@ -338,11 +338,22 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n             }\n             visitor.visit_opt_lifetime_ref(\n                 typ.span,\n-                &function_declaration.region,\n+                region,\n                 env.clone());\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n                                 env.clone());\n         }\n+        TyProc(ref function_declaration) => {\n+            for argument in function_declaration.decl.inputs.iter() {\n+                visitor.visit_ty(argument.ty, env.clone())\n+            }\n+            visitor.visit_ty(function_declaration.decl.output, env.clone());\n+            for bounds in function_declaration.bounds.iter() {\n+                walk_ty_param_bounds(visitor, bounds, env.clone())\n+            }\n+            walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n+                                env.clone());\n+        }\n         TyBareFn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(argument.ty, env.clone())"}]}