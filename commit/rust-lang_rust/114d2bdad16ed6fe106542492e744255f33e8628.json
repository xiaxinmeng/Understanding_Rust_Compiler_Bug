{"sha": "114d2bdad16ed6fe106542492e744255f33e8628", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNGQyYmRhZDE2ZWQ2ZmUxMDY1NDI0OTJlNzQ0MjU1ZjMzZTg2Mjg=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-01-08T12:14:07Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-01-08T12:14:07Z"}, "message": "Restore indentation in common.rs\n\nMost of the file lost one level of indentation in a recent rollup. Most\nlikely an accident during merge conflict resolution.", "tree": {"sha": "04345ab6d790be05e69d97451024f1942f9dd779", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04345ab6d790be05e69d97451024f1942f9dd779"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/114d2bdad16ed6fe106542492e744255f33e8628", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/114d2bdad16ed6fe106542492e744255f33e8628", "html_url": "https://github.com/rust-lang/rust/commit/114d2bdad16ed6fe106542492e744255f33e8628", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/114d2bdad16ed6fe106542492e744255f33e8628/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5364c4853fa61aced8fdf773d9de41b929a0d318", "url": "https://api.github.com/repos/rust-lang/rust/commits/5364c4853fa61aced8fdf773d9de41b929a0d318", "html_url": "https://github.com/rust-lang/rust/commit/5364c4853fa61aced8fdf773d9de41b929a0d318"}], "stats": {"total": 1348, "additions": 674, "deletions": 674}, "files": [{"sha": "3afd33d324dd1867417772cadaf49d83931a9b29", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 674, "deletions": 674, "changes": 1348, "blob_url": "https://github.com/rust-lang/rust/blob/114d2bdad16ed6fe106542492e744255f33e8628/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114d2bdad16ed6fe106542492e744255f33e8628/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=114d2bdad16ed6fe106542492e744255f33e8628", "patch": "@@ -124,170 +124,170 @@ pub fn type_is_sized<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n pub fn lltype_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-match ty.sty {\n-    ty::ty_open(_) => true,\n-    _ => type_is_sized(cx, ty),\n-}\n+    match ty.sty {\n+        ty::ty_open(_) => true,\n+        _ => type_is_sized(cx, ty),\n+    }\n }\n \n pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-match ty.sty {\n-    ty::ty_ptr(ty::mt{ty, ..}) |\n-    ty::ty_rptr(_, ty::mt{ty, ..}) |\n-    ty::ty_uniq(ty) => {\n-        !type_is_sized(cx, ty)\n-    }\n-    _ => {\n-        false\n+    match ty.sty {\n+        ty::ty_ptr(ty::mt{ty, ..}) |\n+        ty::ty_rptr(_, ty::mt{ty, ..}) |\n+        ty::ty_uniq(ty) => {\n+            !type_is_sized(cx, ty)\n+        }\n+        _ => {\n+            false\n+        }\n     }\n }\n-}\n \n // Return the smallest part of `ty` which is unsized. Fails if `ty` is sized.\n // 'Smallest' here means component of the static representation of the type; not\n // the size of an object at runtime.\n pub fn unsized_part_of_type<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-match ty.sty {\n-    ty::ty_str | ty::ty_trait(..) | ty::ty_vec(..) => ty,\n-    ty::ty_struct(def_id, substs) => {\n-        let unsized_fields: Vec<_> =\n-            ty::struct_fields(cx, def_id, substs)\n-            .iter()\n-            .map(|f| f.mt.ty)\n-            .filter(|ty| !type_is_sized(cx, *ty))\n-            .collect();\n-\n-        // Exactly one of the fields must be unsized.\n-        assert!(unsized_fields.len() == 1);\n-\n-        unsized_part_of_type(cx, unsized_fields[0])\n-    }\n-    _ => {\n-        assert!(type_is_sized(cx, ty),\n-                \"unsized_part_of_type failed even though ty is unsized\");\n-        panic!(\"called unsized_part_of_type with sized ty\");\n+    match ty.sty {\n+        ty::ty_str | ty::ty_trait(..) | ty::ty_vec(..) => ty,\n+        ty::ty_struct(def_id, substs) => {\n+            let unsized_fields: Vec<_> =\n+                ty::struct_fields(cx, def_id, substs)\n+                .iter()\n+                .map(|f| f.mt.ty)\n+                .filter(|ty| !type_is_sized(cx, *ty))\n+                .collect();\n+\n+            // Exactly one of the fields must be unsized.\n+            assert!(unsized_fields.len() == 1);\n+\n+            unsized_part_of_type(cx, unsized_fields[0])\n+        }\n+        _ => {\n+            assert!(type_is_sized(cx, ty),\n+                    \"unsized_part_of_type failed even though ty is unsized\");\n+            panic!(\"called unsized_part_of_type with sized ty\");\n+        }\n     }\n }\n-}\n \n // Some things don't need cleanups during unwinding because the\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-return memoized(ccx.needs_unwind_cleanup_cache(), ty, |ty| {\n-    type_needs_unwind_cleanup_(ccx.tcx(), ty, &mut FnvHashSet::new())\n-});\n-\n-fn type_needs_unwind_cleanup_<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                    ty: Ty<'tcx>,\n-                                    tycache: &mut FnvHashSet<Ty<'tcx>>)\n-                                    -> bool\n-{\n-    // Prevent infinite recursion\n-    if !tycache.insert(ty) {\n-        return false;\n-    }\n-\n-    let mut needs_unwind_cleanup = false;\n-    ty::maybe_walk_ty(ty, |ty| {\n-        needs_unwind_cleanup |= match ty.sty {\n-            ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_) |\n-            ty::ty_float(_) | ty::ty_tup(_) | ty::ty_ptr(_) => false,\n+    return memoized(ccx.needs_unwind_cleanup_cache(), ty, |ty| {\n+        type_needs_unwind_cleanup_(ccx.tcx(), ty, &mut FnvHashSet::new())\n+    });\n \n-            ty::ty_enum(did, substs) =>\n-                ty::enum_variants(tcx, did).iter().any(|v|\n-                    v.args.iter().any(|&aty| {\n-                        let t = aty.subst(tcx, substs);\n-                        type_needs_unwind_cleanup_(tcx, t, tycache)\n-                    })\n-                ),\n+    fn type_needs_unwind_cleanup_<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                        ty: Ty<'tcx>,\n+                                        tycache: &mut FnvHashSet<Ty<'tcx>>)\n+                                        -> bool\n+    {\n+        // Prevent infinite recursion\n+        if !tycache.insert(ty) {\n+            return false;\n+        }\n \n-            _ => true\n-        };\n-        !needs_unwind_cleanup\n-    });\n-    needs_unwind_cleanup\n-}\n+        let mut needs_unwind_cleanup = false;\n+        ty::maybe_walk_ty(ty, |ty| {\n+            needs_unwind_cleanup |= match ty.sty {\n+                ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_) |\n+                ty::ty_float(_) | ty::ty_tup(_) | ty::ty_ptr(_) => false,\n+\n+                ty::ty_enum(did, substs) =>\n+                    ty::enum_variants(tcx, did).iter().any(|v|\n+                        v.args.iter().any(|&aty| {\n+                            let t = aty.subst(tcx, substs);\n+                            type_needs_unwind_cleanup_(tcx, t, tycache)\n+                        })\n+                    ),\n+\n+                _ => true\n+            };\n+            !needs_unwind_cleanup\n+        });\n+        needs_unwind_cleanup\n+    }\n }\n \n pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>,\n                          ty: Ty<'tcx>)\n                          -> bool {\n-ty::type_contents(cx, ty).needs_drop(cx)\n+    ty::type_contents(cx, ty).needs_drop(cx)\n }\n \n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    ty: Ty<'tcx>) -> bool {\n-match ty.sty {\n-    ty::ty_struct(def_id, substs) => {\n-        let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n-        fields.len() == 1 &&\n-            fields[0].name ==\n-                token::special_idents::unnamed_field.name &&\n-            type_is_immediate(ccx, fields[0].mt.ty)\n+    match ty.sty {\n+        ty::ty_struct(def_id, substs) => {\n+            let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n+            fields.len() == 1 &&\n+                fields[0].name ==\n+                    token::special_idents::unnamed_field.name &&\n+                type_is_immediate(ccx, fields[0].mt.ty)\n+        }\n+        _ => false\n     }\n-    _ => false\n-}\n }\n \n pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-use trans::machine::llsize_of_alloc;\n-use trans::type_of::sizing_type_of;\n-\n-let tcx = ccx.tcx();\n-let simple = ty::type_is_scalar(ty) ||\n-    ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n-    type_is_newtype_immediate(ccx, ty) ||\n-    ty::type_is_simd(tcx, ty);\n-if simple && !type_is_fat_ptr(tcx, ty) {\n-    return true;\n-}\n-if !type_is_sized(tcx, ty) {\n-    return false;\n-}\n-match ty.sty {\n-    ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n-    ty::ty_unboxed_closure(..) => {\n-        let llty = sizing_type_of(ccx, ty);\n-        llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n+    use trans::machine::llsize_of_alloc;\n+    use trans::type_of::sizing_type_of;\n+\n+    let tcx = ccx.tcx();\n+    let simple = ty::type_is_scalar(ty) ||\n+        ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n+        type_is_newtype_immediate(ccx, ty) ||\n+        ty::type_is_simd(tcx, ty);\n+    if simple && !type_is_fat_ptr(tcx, ty) {\n+        return true;\n+    }\n+    if !type_is_sized(tcx, ty) {\n+        return false;\n+    }\n+    match ty.sty {\n+        ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n+        ty::ty_unboxed_closure(..) => {\n+            let llty = sizing_type_of(ccx, ty);\n+            llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n+        }\n+        _ => type_is_zero_size(ccx, ty)\n     }\n-    _ => type_is_zero_size(ccx, ty)\n-}\n }\n \n /// Identify types which have size zero at runtime.\n pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-use trans::machine::llsize_of_alloc;\n-use trans::type_of::sizing_type_of;\n-let llty = sizing_type_of(ccx, ty);\n-llsize_of_alloc(ccx, llty) == 0\n+    use trans::machine::llsize_of_alloc;\n+    use trans::type_of::sizing_type_of;\n+    let llty = sizing_type_of(ccx, ty);\n+    llsize_of_alloc(ccx, llty) == 0\n }\n \n /// Identifies types which we declare to be equivalent to `void` in C for the purpose of function\n /// return types. These are `()`, bot, and uninhabited enums. Note that all such types are also\n /// zero-size, but not all zero-size types use a `void` return type (in order to aid with C ABI\n /// compatibility).\n pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n-ty::type_is_nil(ty) || ty::type_is_empty(ccx.tcx(), ty)\n+    ty::type_is_nil(ty) || ty::type_is_empty(ccx.tcx(), ty)\n }\n \n /// Generates a unique symbol based off the name given. This is used to create\n /// unique symbols for things like closures.\n pub fn gensym_name(name: &str) -> PathElem {\n-let num = token::gensym(name).uint();\n-// use one colon which will get translated to a period by the mangler, and\n-// we're guaranteed that `num` is globally unique for this crate.\n-PathName(token::gensym(&format!(\"{}:{}\", name, num)[]))\n+    let num = token::gensym(name).uint();\n+    // use one colon which will get translated to a period by the mangler, and\n+    // we're guaranteed that `num` is globally unique for this crate.\n+    PathName(token::gensym(&format!(\"{}:{}\", name, num)[]))\n }\n \n #[derive(Copy)]\n pub struct tydesc_info<'tcx> {\n-pub ty: Ty<'tcx>,\n-pub tydesc: ValueRef,\n-pub size: ValueRef,\n-pub align: ValueRef,\n-pub name: ValueRef,\n+    pub ty: Ty<'tcx>,\n+    pub tydesc: ValueRef,\n+    pub size: ValueRef,\n+    pub align: ValueRef,\n+    pub name: ValueRef,\n }\n \n /*\n@@ -318,36 +318,36 @@ pub name: ValueRef,\n \n #[derive(Copy)]\n pub struct NodeInfo {\n-pub id: ast::NodeId,\n-pub span: Span,\n+    pub id: ast::NodeId,\n+    pub span: Span,\n }\n \n pub fn expr_info(expr: &ast::Expr) -> NodeInfo {\n-NodeInfo { id: expr.id, span: expr.span }\n+    NodeInfo { id: expr.id, span: expr.span }\n }\n \n pub struct BuilderRef_res {\n-pub b: BuilderRef,\n+    pub b: BuilderRef,\n }\n \n impl Drop for BuilderRef_res {\n-fn drop(&mut self) {\n-    unsafe {\n-        llvm::LLVMDisposeBuilder(self.b);\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMDisposeBuilder(self.b);\n+        }\n     }\n }\n-}\n \n pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n-BuilderRef_res {\n-    b: b\n-}\n+    BuilderRef_res {\n+        b: b\n+    }\n }\n \n pub type ExternMap = FnvHashMap<String, ValueRef>;\n \n pub fn validate_substs(substs: &Substs) {\n-assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n+    assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n }\n \n // work around bizarre resolve errors\n@@ -357,183 +357,183 @@ type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct FunctionContext<'a, 'tcx: 'a> {\n-// The ValueRef returned from a call to llvm::LLVMAddFunction; the\n-// address of the first instruction in the sequence of\n-// instructions for this function that will go in the .text\n-// section of the executable we're generating.\n-pub llfn: ValueRef,\n+    // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n+    // address of the first instruction in the sequence of\n+    // instructions for this function that will go in the .text\n+    // section of the executable we're generating.\n+    pub llfn: ValueRef,\n \n-// always an empty parameter-environment\n-pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n+    // always an empty parameter-environment\n+    pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n \n-// The environment argument in a closure.\n-pub llenv: Option<ValueRef>,\n+    // The environment argument in a closure.\n+    pub llenv: Option<ValueRef>,\n \n-// A pointer to where to store the return value. If the return type is\n-// immediate, this points to an alloca in the function. Otherwise, it's a\n-// pointer to the hidden first parameter of the function. After function\n-// construction, this should always be Some.\n-pub llretslotptr: Cell<Option<ValueRef>>,\n+    // A pointer to where to store the return value. If the return type is\n+    // immediate, this points to an alloca in the function. Otherwise, it's a\n+    // pointer to the hidden first parameter of the function. After function\n+    // construction, this should always be Some.\n+    pub llretslotptr: Cell<Option<ValueRef>>,\n \n-// These pub elements: \"hoisted basic blocks\" containing\n-// administrative activities that have to happen in only one place in\n-// the function, due to LLVM's quirks.\n-// A marker for the place where we want to insert the function's static\n-// allocas, so that LLVM will coalesce them into a single alloca call.\n-pub alloca_insert_pt: Cell<Option<ValueRef>>,\n-pub llreturn: Cell<Option<BasicBlockRef>>,\n+    // These pub elements: \"hoisted basic blocks\" containing\n+    // administrative activities that have to happen in only one place in\n+    // the function, due to LLVM's quirks.\n+    // A marker for the place where we want to insert the function's static\n+    // allocas, so that LLVM will coalesce them into a single alloca call.\n+    pub alloca_insert_pt: Cell<Option<ValueRef>>,\n+    pub llreturn: Cell<Option<BasicBlockRef>>,\n \n-// If the function has any nested return's, including something like:\n-// fn foo() -> Option<Foo> { Some(Foo { x: return None }) }, then\n-// we use a separate alloca for each return\n-pub needs_ret_allocas: bool,\n+    // If the function has any nested return's, including something like:\n+    // fn foo() -> Option<Foo> { Some(Foo { x: return None }) }, then\n+    // we use a separate alloca for each return\n+    pub needs_ret_allocas: bool,\n \n-// The a value alloca'd for calls to upcalls.rust_personality. Used when\n-// outputting the resume instruction.\n-pub personality: Cell<Option<ValueRef>>,\n+    // The a value alloca'd for calls to upcalls.rust_personality. Used when\n+    // outputting the resume instruction.\n+    pub personality: Cell<Option<ValueRef>>,\n \n-// True if the caller expects this fn to use the out pointer to\n-// return. Either way, your code should write into the slot llretslotptr\n-// points to, but if this value is false, that slot will be a local alloca.\n-pub caller_expects_out_pointer: bool,\n+    // True if the caller expects this fn to use the out pointer to\n+    // return. Either way, your code should write into the slot llretslotptr\n+    // points to, but if this value is false, that slot will be a local alloca.\n+    pub caller_expects_out_pointer: bool,\n \n-// Maps the DefId's for local variables to the allocas created for\n-// them in llallocas.\n-pub lllocals: RefCell<NodeMap<LvalueDatum<'tcx>>>,\n+    // Maps the DefId's for local variables to the allocas created for\n+    // them in llallocas.\n+    pub lllocals: RefCell<NodeMap<LvalueDatum<'tcx>>>,\n \n-// Same as above, but for closure upvars\n-pub llupvars: RefCell<NodeMap<ValueRef>>,\n+    // Same as above, but for closure upvars\n+    pub llupvars: RefCell<NodeMap<ValueRef>>,\n \n-// The NodeId of the function, or -1 if it doesn't correspond to\n-// a user-defined function.\n-pub id: ast::NodeId,\n+    // The NodeId of the function, or -1 if it doesn't correspond to\n+    // a user-defined function.\n+    pub id: ast::NodeId,\n \n-// If this function is being monomorphized, this contains the type\n-// substitutions used.\n-pub param_substs: &'a Substs<'tcx>,\n+    // If this function is being monomorphized, this contains the type\n+    // substitutions used.\n+    pub param_substs: &'a Substs<'tcx>,\n \n-// The source span and nesting context where this function comes from, for\n-// error reporting and symbol generation.\n-pub span: Option<Span>,\n+    // The source span and nesting context where this function comes from, for\n+    // error reporting and symbol generation.\n+    pub span: Option<Span>,\n \n-// The arena that blocks are allocated from.\n-pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n+    // The arena that blocks are allocated from.\n+    pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n \n-// This function's enclosing crate context.\n-pub ccx: &'a CrateContext<'a, 'tcx>,\n+    // This function's enclosing crate context.\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n \n-// Used and maintained by the debuginfo module.\n-pub debug_context: debuginfo::FunctionDebugContext,\n+    // Used and maintained by the debuginfo module.\n+    pub debug_context: debuginfo::FunctionDebugContext,\n \n-// Cleanup scopes.\n-pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n+    // Cleanup scopes.\n+    pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n \n-pub cfg: Option<cfg::CFG>,\n+    pub cfg: Option<cfg::CFG>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-pub fn arg_pos(&self, arg: uint) -> uint {\n-    let arg = self.env_arg_pos() + arg;\n-    if self.llenv.is_some() {\n-        arg + 1\n-    } else {\n-        arg\n+    pub fn arg_pos(&self, arg: uint) -> uint {\n+        let arg = self.env_arg_pos() + arg;\n+        if self.llenv.is_some() {\n+            arg + 1\n+        } else {\n+            arg\n+        }\n     }\n-}\n \n-pub fn env_arg_pos(&self) -> uint {\n-    if self.caller_expects_out_pointer {\n-        1u\n-    } else {\n-        0u\n+    pub fn env_arg_pos(&self) -> uint {\n+        if self.caller_expects_out_pointer {\n+            1u\n+        } else {\n+            0u\n+        }\n     }\n-}\n \n-pub fn cleanup(&self) {\n-    unsafe {\n-        llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt\n-                                                 .get()\n-                                                 .unwrap());\n+    pub fn cleanup(&self) {\n+        unsafe {\n+            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt\n+                                                     .get()\n+                                                     .unwrap());\n+        }\n     }\n-}\n \n-pub fn get_llreturn(&self) -> BasicBlockRef {\n-    if self.llreturn.get().is_none() {\n+    pub fn get_llreturn(&self) -> BasicBlockRef {\n+        if self.llreturn.get().is_none() {\n \n-        self.llreturn.set(Some(unsafe {\n-            llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn,\n-                                                \"return\\0\".as_ptr() as *const _)\n-        }))\n-    }\n+            self.llreturn.set(Some(unsafe {\n+                llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn,\n+                                                    \"return\\0\".as_ptr() as *const _)\n+            }))\n+        }\n \n-    self.llreturn.get().unwrap()\n-}\n+        self.llreturn.get().unwrap()\n+    }\n \n-pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>,\n-                    output: ty::FnOutput<'tcx>,\n-                    name: &str) -> ValueRef {\n-    if self.needs_ret_allocas {\n-        base::alloca_no_lifetime(bcx, match output {\n-            ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n-            ty::FnDiverging => Type::void(bcx.ccx())\n-        }, name)\n-    } else {\n-        self.llretslotptr.get().unwrap()\n+    pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>,\n+                        output: ty::FnOutput<'tcx>,\n+                        name: &str) -> ValueRef {\n+        if self.needs_ret_allocas {\n+            base::alloca_no_lifetime(bcx, match output {\n+                ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n+                ty::FnDiverging => Type::void(bcx.ccx())\n+            }, name)\n+        } else {\n+            self.llretslotptr.get().unwrap()\n+        }\n     }\n-}\n \n-pub fn new_block(&'a self,\n-                 is_lpad: bool,\n-                 name: &str,\n-                 opt_node_id: Option<ast::NodeId>)\n-                 -> Block<'a, 'tcx> {\n-    unsafe {\n-        let name = CString::from_slice(name.as_bytes());\n-        let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n-                                                       self.llfn,\n-                                                       name.as_ptr());\n-        BlockS::new(llbb, is_lpad, opt_node_id, self)\n+    pub fn new_block(&'a self,\n+                     is_lpad: bool,\n+                     name: &str,\n+                     opt_node_id: Option<ast::NodeId>)\n+                     -> Block<'a, 'tcx> {\n+        unsafe {\n+            let name = CString::from_slice(name.as_bytes());\n+            let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n+                                                           self.llfn,\n+                                                           name.as_ptr());\n+            BlockS::new(llbb, is_lpad, opt_node_id, self)\n+        }\n     }\n-}\n \n-pub fn new_id_block(&'a self,\n-                    name: &str,\n-                    node_id: ast::NodeId)\n-                    -> Block<'a, 'tcx> {\n-    self.new_block(false, name, Some(node_id))\n-}\n+    pub fn new_id_block(&'a self,\n+                        name: &str,\n+                        node_id: ast::NodeId)\n+                        -> Block<'a, 'tcx> {\n+        self.new_block(false, name, Some(node_id))\n+    }\n \n-pub fn new_temp_block(&'a self,\n-                      name: &str)\n-                      -> Block<'a, 'tcx> {\n-    self.new_block(false, name, None)\n-}\n+    pub fn new_temp_block(&'a self,\n+                          name: &str)\n+                          -> Block<'a, 'tcx> {\n+        self.new_block(false, name, None)\n+    }\n \n-pub fn join_blocks(&'a self,\n-                   id: ast::NodeId,\n-                   in_cxs: &[Block<'a, 'tcx>])\n-                   -> Block<'a, 'tcx> {\n-    let out = self.new_id_block(\"join\", id);\n-    let mut reachable = false;\n-    for bcx in in_cxs.iter() {\n-        if !bcx.unreachable.get() {\n-            build::Br(*bcx, out.llbb);\n-            reachable = true;\n+    pub fn join_blocks(&'a self,\n+                       id: ast::NodeId,\n+                       in_cxs: &[Block<'a, 'tcx>])\n+                       -> Block<'a, 'tcx> {\n+        let out = self.new_id_block(\"join\", id);\n+        let mut reachable = false;\n+        for bcx in in_cxs.iter() {\n+            if !bcx.unreachable.get() {\n+                build::Br(*bcx, out.llbb);\n+                reachable = true;\n+            }\n         }\n+        if !reachable {\n+            build::Unreachable(out);\n+        }\n+        return out;\n     }\n-    if !reachable {\n-        build::Unreachable(out);\n-    }\n-    return out;\n-}\n \n-pub fn monomorphize<T>(&self, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n-{\n-    monomorphize::apply_param_substs(self.ccx.tcx(),\n-                                     self.param_substs,\n-                                     value)\n-}\n+    pub fn monomorphize<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    {\n+        monomorphize::apply_param_substs(self.ccx.tcx(),\n+                                         self.param_substs,\n+                                         value)\n+    }\n }\n \n // Basic block context.  We create a block context for each basic block\n@@ -542,277 +542,277 @@ pub fn monomorphize<T>(&self, value: &T) -> T\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n pub struct BlockS<'blk, 'tcx: 'blk> {\n-// The BasicBlockRef returned from a call to\n-// llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n-// block to the function pointed to by llfn.  We insert\n-// instructions into that block by way of this block context.\n-// The block pointing to this one in the function's digraph.\n-pub llbb: BasicBlockRef,\n-pub terminated: Cell<bool>,\n-pub unreachable: Cell<bool>,\n+    // The BasicBlockRef returned from a call to\n+    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n+    // block to the function pointed to by llfn.  We insert\n+    // instructions into that block by way of this block context.\n+    // The block pointing to this one in the function's digraph.\n+    pub llbb: BasicBlockRef,\n+    pub terminated: Cell<bool>,\n+    pub unreachable: Cell<bool>,\n \n-// Is this block part of a landing pad?\n-pub is_lpad: bool,\n+    // Is this block part of a landing pad?\n+    pub is_lpad: bool,\n \n-// AST node-id associated with this block, if any. Used for\n-// debugging purposes only.\n-pub opt_node_id: Option<ast::NodeId>,\n+    // AST node-id associated with this block, if any. Used for\n+    // debugging purposes only.\n+    pub opt_node_id: Option<ast::NodeId>,\n \n-// The function context for the function to which this block is\n-// attached.\n-pub fcx: &'blk FunctionContext<'blk, 'tcx>,\n+    // The function context for the function to which this block is\n+    // attached.\n+    pub fcx: &'blk FunctionContext<'blk, 'tcx>,\n }\n \n pub type Block<'blk, 'tcx> = &'blk BlockS<'blk, 'tcx>;\n \n impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n-pub fn new(llbb: BasicBlockRef,\n-           is_lpad: bool,\n-           opt_node_id: Option<ast::NodeId>,\n-           fcx: &'blk FunctionContext<'blk, 'tcx>)\n-           -> Block<'blk, 'tcx> {\n-    fcx.block_arena.alloc(BlockS {\n-        llbb: llbb,\n-        terminated: Cell::new(false),\n-        unreachable: Cell::new(false),\n-        is_lpad: is_lpad,\n-        opt_node_id: opt_node_id,\n-        fcx: fcx\n-    })\n-}\n+    pub fn new(llbb: BasicBlockRef,\n+               is_lpad: bool,\n+               opt_node_id: Option<ast::NodeId>,\n+               fcx: &'blk FunctionContext<'blk, 'tcx>)\n+               -> Block<'blk, 'tcx> {\n+        fcx.block_arena.alloc(BlockS {\n+            llbb: llbb,\n+            terminated: Cell::new(false),\n+            unreachable: Cell::new(false),\n+            is_lpad: is_lpad,\n+            opt_node_id: opt_node_id,\n+            fcx: fcx\n+        })\n+    }\n \n-pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n-    self.fcx.ccx\n-}\n-pub fn tcx(&self) -> &'blk ty::ctxt<'tcx> {\n-    self.fcx.ccx.tcx()\n-}\n-pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n+    pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n+        self.fcx.ccx\n+    }\n+    pub fn tcx(&self) -> &'blk ty::ctxt<'tcx> {\n+        self.fcx.ccx.tcx()\n+    }\n+    pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n-pub fn ident(&self, ident: Ident) -> String {\n-    token::get_ident(ident).get().to_string()\n-}\n+    pub fn ident(&self, ident: Ident) -> String {\n+        token::get_ident(ident).get().to_string()\n+    }\n \n-pub fn node_id_to_string(&self, id: ast::NodeId) -> String {\n-    self.tcx().map.node_to_string(id).to_string()\n-}\n+    pub fn node_id_to_string(&self, id: ast::NodeId) -> String {\n+        self.tcx().map.node_to_string(id).to_string()\n+    }\n \n-pub fn expr_to_string(&self, e: &ast::Expr) -> String {\n-    e.repr(self.tcx())\n-}\n+    pub fn expr_to_string(&self, e: &ast::Expr) -> String {\n+        e.repr(self.tcx())\n+    }\n \n-pub fn def(&self, nid: ast::NodeId) -> def::Def {\n-    match self.tcx().def_map.borrow().get(&nid) {\n-        Some(v) => v.clone(),\n-        None => {\n-            self.tcx().sess.bug(&format!(\n-                \"no def associated with node id {}\", nid)[]);\n+    pub fn def(&self, nid: ast::NodeId) -> def::Def {\n+        match self.tcx().def_map.borrow().get(&nid) {\n+            Some(v) => v.clone(),\n+            None => {\n+                self.tcx().sess.bug(&format!(\n+                    \"no def associated with node id {}\", nid)[]);\n+            }\n         }\n     }\n-}\n \n-pub fn val_to_string(&self, val: ValueRef) -> String {\n-    self.ccx().tn().val_to_string(val)\n-}\n+    pub fn val_to_string(&self, val: ValueRef) -> String {\n+        self.ccx().tn().val_to_string(val)\n+    }\n \n-pub fn llty_str(&self, ty: Type) -> String {\n-    self.ccx().tn().type_to_string(ty)\n-}\n+    pub fn llty_str(&self, ty: Type) -> String {\n+        self.ccx().tn().type_to_string(ty)\n+    }\n \n-pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-    t.repr(self.tcx())\n-}\n+    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n+        t.repr(self.tcx())\n+    }\n \n-pub fn to_str(&self) -> String {\n-    format!(\"[block {:p}]\", self)\n-}\n+    pub fn to_str(&self) -> String {\n+        format!(\"[block {:p}]\", self)\n+    }\n \n-pub fn monomorphize<T>(&self, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n-{\n-    monomorphize::apply_param_substs(self.tcx(),\n-                                     self.fcx.param_substs,\n-                                     value)\n-}\n+    pub fn monomorphize<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    {\n+        monomorphize::apply_param_substs(self.tcx(),\n+                                         self.fcx.param_substs,\n+                                         value)\n+    }\n }\n \n impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n-fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-    self.tcx()\n-}\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+        self.tcx()\n+    }\n \n-fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n-    Ok(node_id_type(self, id))\n-}\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n+        Ok(node_id_type(self, id))\n+    }\n \n-fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n-    Ok(expr_ty_adjusted(self, expr))\n-}\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n+        Ok(expr_ty_adjusted(self, expr))\n+    }\n \n-fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n-    self.tcx()\n-        .method_map\n-        .borrow()\n-        .get(&method_call)\n-        .map(|method| monomorphize_type(self, method.ty))\n-}\n+    fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n+        self.tcx()\n+            .method_map\n+            .borrow()\n+            .get(&method_call)\n+            .map(|method| monomorphize_type(self, method.ty))\n+    }\n \n-fn node_method_origin(&self, method_call: ty::MethodCall)\n-                      -> Option<ty::MethodOrigin<'tcx>>\n-{\n-    self.tcx()\n-        .method_map\n-        .borrow()\n-        .get(&method_call)\n-        .map(|method| method.origin.clone())\n-}\n+    fn node_method_origin(&self, method_call: ty::MethodCall)\n+                          -> Option<ty::MethodOrigin<'tcx>>\n+    {\n+        self.tcx()\n+            .method_map\n+            .borrow()\n+            .get(&method_call)\n+            .map(|method| method.origin.clone())\n+    }\n \n-fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-    &self.tcx().adjustments\n-}\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        &self.tcx().adjustments\n+    }\n \n-fn is_method_call(&self, id: ast::NodeId) -> bool {\n-    self.tcx().method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n-}\n+    fn is_method_call(&self, id: ast::NodeId) -> bool {\n+        self.tcx().method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n+    }\n \n-fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n-    self.tcx().region_maps.temporary_scope(rvalue_id)\n-}\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n+        self.tcx().region_maps.temporary_scope(rvalue_id)\n+    }\n \n-fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n-    Some(self.tcx().upvar_borrow_map.borrow()[upvar_id].clone())\n-}\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n+        Some(self.tcx().upvar_borrow_map.borrow()[upvar_id].clone())\n+    }\n \n-fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                -> ast::CaptureClause {\n-    self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n-}\n+    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n+                    -> ast::CaptureClause {\n+        self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n+    }\n \n-fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n-    self.fcx.param_env.type_moves_by_default(span, ty)\n-}\n+    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n+        self.fcx.param_env.type_moves_by_default(span, ty)\n+    }\n }\n \n impl<'blk, 'tcx> ty::UnboxedClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n-fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx> {\n-    &self.fcx.param_env\n-}\n+    fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx> {\n+        &self.fcx.param_env\n+    }\n \n-fn unboxed_closure_kind(&self,\n-                        def_id: ast::DefId)\n-                        -> ty::UnboxedClosureKind\n-{\n-    let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-    typer.unboxed_closure_kind(def_id)\n-}\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+        typer.unboxed_closure_kind(def_id)\n+    }\n \n-fn unboxed_closure_type(&self,\n-                        def_id: ast::DefId,\n-                        substs: &subst::Substs<'tcx>)\n-                        -> ty::ClosureTy<'tcx>\n-{\n-    let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-    typer.unboxed_closure_type(def_id, substs)\n-}\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+        typer.unboxed_closure_type(def_id, substs)\n+    }\n \n-fn unboxed_closure_upvars(&self,\n-                          def_id: ast::DefId,\n-                          substs: &Substs<'tcx>)\n-                          -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n-{\n-    let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-    typer.unboxed_closure_upvars(def_id, substs)\n-}\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    {\n+        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+        typer.unboxed_closure_upvars(def_id, substs)\n+    }\n }\n \n pub struct Result<'blk, 'tcx: 'blk> {\n-pub bcx: Block<'blk, 'tcx>,\n-pub val: ValueRef\n+    pub bcx: Block<'blk, 'tcx>,\n+    pub val: ValueRef\n }\n \n impl<'b, 'tcx> Result<'b, 'tcx> {\n-pub fn new(bcx: Block<'b, 'tcx>, val: ValueRef) -> Result<'b, 'tcx> {\n-    Result {\n-        bcx: bcx,\n-        val: val,\n+    pub fn new(bcx: Block<'b, 'tcx>, val: ValueRef) -> Result<'b, 'tcx> {\n+        Result {\n+            bcx: bcx,\n+            val: val,\n+        }\n     }\n }\n-}\n \n pub fn val_ty(v: ValueRef) -> Type {\n-unsafe {\n-    Type::from_ref(llvm::LLVMTypeOf(v))\n-}\n+    unsafe {\n+        Type::from_ref(llvm::LLVMTypeOf(v))\n+    }\n }\n \n // LLVM constant constructors.\n pub fn C_null(t: Type) -> ValueRef {\n-unsafe {\n-    llvm::LLVMConstNull(t.to_ref())\n-}\n+    unsafe {\n+        llvm::LLVMConstNull(t.to_ref())\n+    }\n }\n \n pub fn C_undef(t: Type) -> ValueRef {\n-unsafe {\n-    llvm::LLVMGetUndef(t.to_ref())\n-}\n+    unsafe {\n+        llvm::LLVMGetUndef(t.to_ref())\n+    }\n }\n \n pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n-unsafe {\n-    llvm::LLVMConstInt(t.to_ref(), u, sign_extend as Bool)\n-}\n+    unsafe {\n+        llvm::LLVMConstInt(t.to_ref(), u, sign_extend as Bool)\n+    }\n }\n \n pub fn C_floating(s: &str, t: Type) -> ValueRef {\n-unsafe {\n-    let s = CString::from_slice(s.as_bytes());\n-    llvm::LLVMConstRealOfString(t.to_ref(), s.as_ptr())\n-}\n+    unsafe {\n+        let s = CString::from_slice(s.as_bytes());\n+        llvm::LLVMConstRealOfString(t.to_ref(), s.as_ptr())\n+    }\n }\n \n pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n-C_struct(ccx, &[], false)\n+    C_struct(ccx, &[], false)\n }\n \n pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n-C_integral(Type::i1(ccx), val as u64, false)\n+    C_integral(Type::i1(ccx), val as u64, false)\n }\n \n pub fn C_i32(ccx: &CrateContext, i: i32) -> ValueRef {\n-C_integral(Type::i32(ccx), i as u64, true)\n+    C_integral(Type::i32(ccx), i as u64, true)\n }\n \n pub fn C_i64(ccx: &CrateContext, i: i64) -> ValueRef {\n-C_integral(Type::i64(ccx), i as u64, true)\n+    C_integral(Type::i64(ccx), i as u64, true)\n }\n \n pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n-C_integral(Type::i64(ccx), i, false)\n+    C_integral(Type::i64(ccx), i, false)\n }\n \n pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n-let v = i.as_i64();\n+    let v = i.as_i64();\n \n-match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-    32 => assert!(v < (1<<31) && v >= -(1<<31)),\n-    64 => {},\n-    n => panic!(\"unsupported target size: {}\", n)\n-}\n+    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n+        32 => assert!(v < (1<<31) && v >= -(1<<31)),\n+        64 => {},\n+        n => panic!(\"unsupported target size: {}\", n)\n+    }\n \n-C_integral(ccx.int_type(), v as u64, true)\n+    C_integral(ccx.int_type(), v as u64, true)\n }\n \n pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n-let v = i.as_u64();\n+    let v = i.as_u64();\n \n-match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-    32 => assert!(v < (1<<32)),\n-    64 => {},\n-    n => panic!(\"unsupported target size: {}\", n)\n-}\n+    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n+        32 => assert!(v < (1<<32)),\n+        64 => {},\n+        n => panic!(\"unsupported target size: {}\", n)\n+    }\n \n-C_integral(ccx.int_type(), v, false)\n+    C_integral(ccx.int_type(), v, false)\n }\n \n pub trait AsI64 { fn as_i64(self) -> i64; }\n@@ -829,157 +829,157 @@ impl AsU64 for u32  { fn as_u64(self) -> u64 { self as u64 }}\n impl AsU64 for uint { fn as_u64(self) -> u64 { self as u64 }}\n \n pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n-C_integral(Type::i8(ccx), i as u64, false)\n+    C_integral(Type::i8(ccx), i as u64, false)\n }\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> ValueRef {\n-unsafe {\n-    match cx.const_cstr_cache().borrow().get(&s) {\n-        Some(&llval) => return llval,\n-        None => ()\n-    }\n+    unsafe {\n+        match cx.const_cstr_cache().borrow().get(&s) {\n+            Some(&llval) => return llval,\n+            None => ()\n+        }\n \n-    let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n-                                            s.get().as_ptr() as *const c_char,\n-                                            s.get().len() as c_uint,\n-                                            !null_terminated as Bool);\n+        let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n+                                                s.get().as_ptr() as *const c_char,\n+                                                s.get().len() as c_uint,\n+                                                !null_terminated as Bool);\n \n-    let gsym = token::gensym(\"str\");\n-    let buf = CString::from_vec(format!(\"str{}\", gsym.uint()).into_bytes());\n-    let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n-    llvm::LLVMSetInitializer(g, sc);\n-    llvm::LLVMSetGlobalConstant(g, True);\n-    llvm::SetLinkage(g, llvm::InternalLinkage);\n+        let gsym = token::gensym(\"str\");\n+        let buf = CString::from_vec(format!(\"str{}\", gsym.uint()).into_bytes());\n+        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n+        llvm::LLVMSetInitializer(g, sc);\n+        llvm::LLVMSetGlobalConstant(g, True);\n+        llvm::SetLinkage(g, llvm::InternalLinkage);\n \n-    cx.const_cstr_cache().borrow_mut().insert(s, g);\n-    g\n-}\n+        cx.const_cstr_cache().borrow_mut().insert(s, g);\n+        g\n+    }\n }\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n-let len = s.get().len();\n-let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n-C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n+    let len = s.get().len();\n+    let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n+    C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n }\n \n pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n-unsafe {\n-    let len = data.len();\n-    let lldata = C_bytes(cx, data);\n-\n-    let gsym = token::gensym(\"binary\");\n-    let name = format!(\"binary{}\", gsym.uint());\n-    let name = CString::from_vec(name.into_bytes());\n-    let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n-                                name.as_ptr());\n-    llvm::LLVMSetInitializer(g, lldata);\n-    llvm::LLVMSetGlobalConstant(g, True);\n-    llvm::SetLinkage(g, llvm::InternalLinkage);\n-\n-    let cs = consts::ptrcast(g, Type::i8p(cx));\n-    C_struct(cx, &[cs, C_uint(cx, len)], false)\n-}\n+    unsafe {\n+        let len = data.len();\n+        let lldata = C_bytes(cx, data);\n+\n+        let gsym = token::gensym(\"binary\");\n+        let name = format!(\"binary{}\", gsym.uint());\n+        let name = CString::from_vec(name.into_bytes());\n+        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n+                                    name.as_ptr());\n+        llvm::LLVMSetInitializer(g, lldata);\n+        llvm::LLVMSetGlobalConstant(g, True);\n+        llvm::SetLinkage(g, llvm::InternalLinkage);\n+\n+        let cs = consts::ptrcast(g, Type::i8p(cx));\n+        C_struct(cx, &[cs, C_uint(cx, len)], false)\n+    }\n }\n \n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n-C_struct_in_context(cx.llcx(), elts, packed)\n+    C_struct_in_context(cx.llcx(), elts, packed)\n }\n \n pub fn C_struct_in_context(llcx: ContextRef, elts: &[ValueRef], packed: bool) -> ValueRef {\n-unsafe {\n-    llvm::LLVMConstStructInContext(llcx,\n-                                   elts.as_ptr(), elts.len() as c_uint,\n-                                   packed as Bool)\n-}\n+    unsafe {\n+        llvm::LLVMConstStructInContext(llcx,\n+                                       elts.as_ptr(), elts.len() as c_uint,\n+                                       packed as Bool)\n+    }\n }\n \n pub fn C_named_struct(t: Type, elts: &[ValueRef]) -> ValueRef {\n-unsafe {\n-    llvm::LLVMConstNamedStruct(t.to_ref(), elts.as_ptr(), elts.len() as c_uint)\n-}\n+    unsafe {\n+        llvm::LLVMConstNamedStruct(t.to_ref(), elts.as_ptr(), elts.len() as c_uint)\n+    }\n }\n \n pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n-unsafe {\n-    return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);\n-}\n+    unsafe {\n+        return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);\n+    }\n }\n \n pub fn C_bytes(cx: &CrateContext, bytes: &[u8]) -> ValueRef {\n-C_bytes_in_context(cx.llcx(), bytes)\n+    C_bytes_in_context(cx.llcx(), bytes)\n }\n \n pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n-unsafe {\n-    let ptr = bytes.as_ptr() as *const c_char;\n-    return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n-}\n+    unsafe {\n+        let ptr = bytes.as_ptr() as *const c_char;\n+        return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n+    }\n }\n \n pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n               -> ValueRef {\n-unsafe {\n-    let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n+    unsafe {\n+        let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n-    debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n-           cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n+        debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n+               cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n \n-    return r;\n-}\n+        return r;\n+    }\n }\n \n pub fn is_const(v: ValueRef) -> bool {\n-unsafe {\n-    llvm::LLVMIsConstant(v) == True\n-}\n+    unsafe {\n+        llvm::LLVMIsConstant(v) == True\n+    }\n }\n \n pub fn const_to_int(v: ValueRef) -> i64 {\n-unsafe {\n-    llvm::LLVMConstIntGetSExtValue(v)\n-}\n+    unsafe {\n+        llvm::LLVMConstIntGetSExtValue(v)\n+    }\n }\n \n pub fn const_to_uint(v: ValueRef) -> u64 {\n-unsafe {\n-    llvm::LLVMConstIntGetZExtValue(v)\n-}\n+    unsafe {\n+        llvm::LLVMConstIntGetZExtValue(v)\n+    }\n }\n \n pub fn is_undef(val: ValueRef) -> bool {\n-unsafe {\n-    llvm::LLVMIsUndef(val) != False\n-}\n+    unsafe {\n+        llvm::LLVMIsUndef(val) != False\n+    }\n }\n \n #[allow(dead_code)] // potentially useful\n pub fn is_null(val: ValueRef) -> bool {\n-unsafe {\n-    llvm::LLVMIsNull(val) != False\n-}\n+    unsafe {\n+        llvm::LLVMIsNull(val) != False\n+    }\n }\n \n pub fn monomorphize_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n-bcx.fcx.monomorphize(&t)\n+    bcx.fcx.monomorphize(&t)\n }\n \n pub fn node_id_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n-let tcx = bcx.tcx();\n-let t = ty::node_id_to_type(tcx, id);\n-monomorphize_type(bcx, t)\n+    let tcx = bcx.tcx();\n+    let t = ty::node_id_to_type(tcx, id);\n+    monomorphize_type(bcx, t)\n }\n \n pub fn expr_ty<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n-node_id_type(bcx, ex.id)\n+    node_id_type(bcx, ex.id)\n }\n \n pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n-monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n+    monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n \n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n@@ -990,191 +990,191 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 trait_ref: ty::PolyTraitRef<'tcx>)\n                                 -> traits::Vtable<'tcx, ()>\n {\n-let tcx = ccx.tcx();\n-\n-// Remove any references to regions; this helps improve caching.\n-let trait_ref = erase_regions(tcx, &trait_ref);\n-\n-// First check the cache.\n-match ccx.trait_cache().borrow().get(&trait_ref) {\n-    Some(vtable) => {\n-        info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n-        return (*vtable).clone();\n-    }\n-    None => { }\n-}\n-\n-debug!(\"trans fulfill_obligation: trait_ref={}\", trait_ref.repr(ccx.tcx()));\n-\n-ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n-let infcx = infer::new_infer_ctxt(tcx);\n-\n-// Do the initial selection for the obligation. This yields the\n-// shallow result we are looking for -- that is, what specific impl.\n-let typer = NormalizingUnboxedClosureTyper::new(tcx);\n-let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n-let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n-                                         trait_ref.to_poly_trait_predicate());\n-let selection = match selcx.select(&obligation) {\n-    Ok(Some(selection)) => selection,\n-    Ok(None) => {\n-        // Ambiguity can happen when monomorphizing during trans\n-        // expands to some humongo type that never occurred\n-        // statically -- this humongo type can then overflow,\n-        // leading to an ambiguous result. So report this as an\n-        // overflow bug, since I believe this is the only case\n-        // where ambiguity can result.\n-        debug!(\"Encountered ambiguity selecting `{}` during trans, \\\n-                presuming due to overflow\",\n-               trait_ref.repr(tcx));\n-        ccx.sess().span_fatal(\n-            span,\n-            \"reached the recursion limit during monomorphization\");\n-    }\n-    Err(e) => {\n-        tcx.sess.span_bug(\n-            span,\n-            &format!(\"Encountered error `{}` selecting `{}` during trans\",\n-                    e.repr(tcx),\n-                    trait_ref.repr(tcx))[])\n-    }\n-};\n-\n-// Currently, we use a fulfillment context to completely resolve\n-// all nested obligations. This is because they can inform the\n-// inference of the impl's type parameters.\n-let mut fulfill_cx = traits::FulfillmentContext::new();\n-let vtable = selection.map_move_nested(|predicate| {\n-    fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-});\n-let vtable = drain_fulfillment_cx(span, &infcx, &mut fulfill_cx, &vtable);\n-\n-info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n-ccx.trait_cache().borrow_mut().insert(trait_ref,\n-                                      vtable.clone());\n-\n-vtable\n+    let tcx = ccx.tcx();\n+\n+    // Remove any references to regions; this helps improve caching.\n+    let trait_ref = erase_regions(tcx, &trait_ref);\n+\n+    // First check the cache.\n+    match ccx.trait_cache().borrow().get(&trait_ref) {\n+        Some(vtable) => {\n+            info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n+            return (*vtable).clone();\n+        }\n+        None => { }\n+    }\n+\n+    debug!(\"trans fulfill_obligation: trait_ref={}\", trait_ref.repr(ccx.tcx()));\n+\n+    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n+    let infcx = infer::new_infer_ctxt(tcx);\n+\n+    // Do the initial selection for the obligation. This yields the\n+    // shallow result we are looking for -- that is, what specific impl.\n+    let typer = NormalizingUnboxedClosureTyper::new(tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n+    let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                             trait_ref.to_poly_trait_predicate());\n+    let selection = match selcx.select(&obligation) {\n+        Ok(Some(selection)) => selection,\n+        Ok(None) => {\n+            // Ambiguity can happen when monomorphizing during trans\n+            // expands to some humongo type that never occurred\n+            // statically -- this humongo type can then overflow,\n+            // leading to an ambiguous result. So report this as an\n+            // overflow bug, since I believe this is the only case\n+            // where ambiguity can result.\n+            debug!(\"Encountered ambiguity selecting `{}` during trans, \\\n+                    presuming due to overflow\",\n+                   trait_ref.repr(tcx));\n+            ccx.sess().span_fatal(\n+                span,\n+                \"reached the recursion limit during monomorphization\");\n+        }\n+        Err(e) => {\n+            tcx.sess.span_bug(\n+                span,\n+                &format!(\"Encountered error `{}` selecting `{}` during trans\",\n+                        e.repr(tcx),\n+                        trait_ref.repr(tcx))[])\n+        }\n+    };\n+\n+    // Currently, we use a fulfillment context to completely resolve\n+    // all nested obligations. This is because they can inform the\n+    // inference of the impl's type parameters.\n+    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let vtable = selection.map_move_nested(|predicate| {\n+        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+    });\n+    let vtable = drain_fulfillment_cx(span, &infcx, &mut fulfill_cx, &vtable);\n+\n+    info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n+    ccx.trait_cache().borrow_mut().insert(trait_ref,\n+                                          vtable.clone());\n+\n+    vtable\n }\n \n pub struct NormalizingUnboxedClosureTyper<'a,'tcx:'a> {\n-param_env: ty::ParameterEnvironment<'a, 'tcx>\n+    param_env: ty::ParameterEnvironment<'a, 'tcx>\n }\n \n impl<'a,'tcx> NormalizingUnboxedClosureTyper<'a,'tcx> {\n-pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingUnboxedClosureTyper<'a,'tcx> {\n-    // Parameter environment is used to give details about type parameters,\n-    // but since we are in trans, everything is fully monomorphized.\n-    NormalizingUnboxedClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n-}\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingUnboxedClosureTyper<'a,'tcx> {\n+        // Parameter environment is used to give details about type parameters,\n+        // but since we are in trans, everything is fully monomorphized.\n+        NormalizingUnboxedClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n+    }\n }\n \n impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'a,'tcx> {\n-fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n-    &self.param_env\n-}\n+    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        &self.param_env\n+    }\n \n-fn unboxed_closure_kind(&self,\n-                        def_id: ast::DefId)\n-                        -> ty::UnboxedClosureKind\n-{\n-    self.param_env.tcx.unboxed_closure_kind(def_id)\n-}\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        self.param_env.tcx.unboxed_closure_kind(def_id)\n+    }\n \n-fn unboxed_closure_type(&self,\n-                        def_id: ast::DefId,\n-                        substs: &subst::Substs<'tcx>)\n-                        -> ty::ClosureTy<'tcx>\n-{\n-    // the substitutions in `substs` are already monomorphized,\n-    // but we still must normalize associated types\n-    let closure_ty = self.param_env.tcx.unboxed_closure_type(def_id, substs);\n-    monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n-}\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        // the substitutions in `substs` are already monomorphized,\n+        // but we still must normalize associated types\n+        let closure_ty = self.param_env.tcx.unboxed_closure_type(def_id, substs);\n+        monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n+    }\n \n-fn unboxed_closure_upvars(&self,\n-                          def_id: ast::DefId,\n-                          substs: &Substs<'tcx>)\n-                          -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n-{\n-    // the substitutions in `substs` are already monomorphized,\n-    // but we still must normalize associated types\n-    let result = ty::unboxed_closure_upvars(&self.param_env, def_id, substs);\n-    monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n-}\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    {\n+        // the substitutions in `substs` are already monomorphized,\n+        // but we still must normalize associated types\n+        let result = ty::unboxed_closure_upvars(&self.param_env, def_id, substs);\n+        monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n+    }\n }\n \n pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n                                    infcx: &infer::InferCtxt<'a,'tcx>,\n                                    fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                    result: &T)\n                                    -> T\n-where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n-debug!(\"drain_fulfillment_cx(result={})\",\n-       result.repr(infcx.tcx));\n-\n-// In principle, we only need to do this so long as `result`\n-// contains unbound type parameters. It could be a slight\n-// optimization to stop iterating early.\n-let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n-match fulfill_cx.select_all_or_error(infcx, &typer) {\n-    Ok(()) => { }\n-    Err(errors) => {\n-        if errors.iter().all(|e| e.is_overflow()) {\n-            // See Ok(None) case above.\n-            infcx.tcx.sess.span_fatal(\n-                span,\n-                \"reached the recursion limit during monomorphization\");\n-        } else {\n-            infcx.tcx.sess.span_bug(\n-                span,\n-                &format!(\"Encountered errors `{}` fulfilling during trans\",\n-                        errors.repr(infcx.tcx))[]);\n+    debug!(\"drain_fulfillment_cx(result={})\",\n+           result.repr(infcx.tcx));\n+\n+    // In principle, we only need to do this so long as `result`\n+    // contains unbound type parameters. It could be a slight\n+    // optimization to stop iterating early.\n+    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n+    match fulfill_cx.select_all_or_error(infcx, &typer) {\n+        Ok(()) => { }\n+        Err(errors) => {\n+            if errors.iter().all(|e| e.is_overflow()) {\n+                // See Ok(None) case above.\n+                infcx.tcx.sess.span_fatal(\n+                    span,\n+                    \"reached the recursion limit during monomorphization\");\n+            } else {\n+                infcx.tcx.sess.span_bug(\n+                    span,\n+                    &format!(\"Encountered errors `{}` fulfilling during trans\",\n+                            errors.repr(infcx.tcx))[]);\n+            }\n         }\n     }\n-}\n \n-// Use freshen to simultaneously replace all type variables with\n-// their bindings and replace all regions with 'static.  This is\n-// sort of overkill because we do not expect there to be any\n-// unbound type variables, hence no `TyFresh` types should ever be\n-// inserted.\n-result.fold_with(&mut infcx.freshener())\n+    // Use freshen to simultaneously replace all type variables with\n+    // their bindings and replace all regions with 'static.  This is\n+    // sort of overkill because we do not expect there to be any\n+    // unbound type variables, hence no `TyFresh` types should ever be\n+    // inserted.\n+    result.fold_with(&mut infcx.freshener())\n }\n \n // Key used to lookup values supplied for type parameters in an expr.\n #[derive(Copy, PartialEq, Show)]\n pub enum ExprOrMethodCall {\n-// Type parameters for a path like `None::<int>`\n-ExprId(ast::NodeId),\n+    // Type parameters for a path like `None::<int>`\n+    ExprId(ast::NodeId),\n \n-// Type parameters for a method call like `a.foo::<int>()`\n-MethodCallKey(ty::MethodCall)\n+    // Type parameters for a method call like `a.foo::<int>()`\n+    MethodCallKey(ty::MethodCall)\n }\n \n pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             node: ExprOrMethodCall,\n                             param_substs: &subst::Substs<'tcx>)\n                             -> subst::Substs<'tcx> {\n-let tcx = ccx.tcx();\n+    let tcx = ccx.tcx();\n \n-let substs = match node {\n-    ExprId(id) => {\n-        ty::node_id_item_substs(tcx, id).substs\n-    }\n-    MethodCallKey(method_call) => {\n-        (*tcx.method_map.borrow())[method_call].substs.clone()\n-    }\n-};\n+    let substs = match node {\n+        ExprId(id) => {\n+            ty::node_id_item_substs(tcx, id).substs\n+        }\n+        MethodCallKey(method_call) => {\n+            (*tcx.method_map.borrow())[method_call].substs.clone()\n+        }\n+    };\n \n-if substs.types.any(|t| ty::type_needs_infer(*t)) {\n-        tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n-                             node, substs.repr(tcx))[]);\n-    }\n+    if substs.types.any(|t| ty::type_needs_infer(*t)) {\n+            tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n+                                 node, substs.repr(tcx))[]);\n+        }\n \n-    monomorphize::apply_param_substs(tcx,\n-                                     param_substs,\n-                                     &substs.erase_regions())\n+        monomorphize::apply_param_substs(tcx,\n+                                         param_substs,\n+                                         &substs.erase_regions())\n }\n \n pub fn langcall(bcx: Block,"}]}