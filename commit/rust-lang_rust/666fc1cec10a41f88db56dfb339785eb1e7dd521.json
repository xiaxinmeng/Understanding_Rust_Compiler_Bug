{"sha": "666fc1cec10a41f88db56dfb339785eb1e7dd521", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NmZjMWNlYzEwYTQxZjg4ZGI1NmRmYjMzOTc4NWViMWU3ZGQ1MjE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-26T20:43:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-26T20:43:53Z"}, "message": "Merge #9015\n\n9015: Merge pattern completion related bools into an enum r=Veykril a=Veykril\n\nThe two bools can never both be set so this is basically just a tri-state enum.\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "b06cb9f920a95da9289005e8a8b98d15834be439", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b06cb9f920a95da9289005e8a8b98d15834be439"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/666fc1cec10a41f88db56dfb339785eb1e7dd521", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgrrMJCRBK7hj4Ov3rIwAAs7gIADvWfCrSJ2q76tJyXfYYbmKi\nApzrMmeX4EzVxxpd2M8hugaHkQmxBRN5zN3fG9qzys2hPmZqSWJnZUhul8VT20gw\nvqltADmmKzgpNmhHjbcr/ensEV4g183JXGC7v2v07IPRpdSpJv89ERlUR9WCGR5Q\ny8oLO3TP9632TCPa5Pkh3lpxw7grE3h5xfd2Dxd+0ImIEYQ02AfOiNjUAyXNL0b2\nlwSB/0R3qCZ9EdiLnWe+fyGC4X6JKXU2OSK/cCQCAsfkqtD7u/5RvB2lXQH6zEAV\nJLv+34jOJBIjwZHjx71uVJkMVWZKxiXx7w8WfITQTp1sK7SXaYtG8M8ErzqMtk4=\n=NvEj\n-----END PGP SIGNATURE-----\n", "payload": "tree b06cb9f920a95da9289005e8a8b98d15834be439\nparent 8389510f8d15e67ab112343ef876db1c8b01e36e\nparent 7d865ef071a78736866a9e73d0348352f4332754\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622061833 +0000\ncommitter GitHub <noreply@github.com> 1622061833 +0000\n\nMerge #9015\n\n9015: Merge pattern completion related bools into an enum r=Veykril a=Veykril\n\nThe two bools can never both be set so this is basically just a tri-state enum.\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/666fc1cec10a41f88db56dfb339785eb1e7dd521", "html_url": "https://github.com/rust-lang/rust/commit/666fc1cec10a41f88db56dfb339785eb1e7dd521", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/666fc1cec10a41f88db56dfb339785eb1e7dd521/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8389510f8d15e67ab112343ef876db1c8b01e36e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8389510f8d15e67ab112343ef876db1c8b01e36e", "html_url": "https://github.com/rust-lang/rust/commit/8389510f8d15e67ab112343ef876db1c8b01e36e"}, {"sha": "7d865ef071a78736866a9e73d0348352f4332754", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d865ef071a78736866a9e73d0348352f4332754", "html_url": "https://github.com/rust-lang/rust/commit/7d865ef071a78736866a9e73d0348352f4332754"}], "stats": {"total": 173, "additions": 93, "deletions": 80}, "files": [{"sha": "3329a48441a94c509b0a6f8c1a4c08a35c07dfb9", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/666fc1cec10a41f88db56dfb339785eb1e7dd521/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666fc1cec10a41f88db56dfb339785eb1e7dd521/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=666fc1cec10a41f88db56dfb339785eb1e7dd521", "patch": "@@ -1,17 +1,18 @@\n //! Completes constants and paths in patterns.\n \n-use crate::{CompletionContext, Completions};\n+use crate::{context::IsPatOrConst, CompletionContext, Completions};\n \n /// Completes constants and paths in patterns.\n pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !(ctx.is_pat_binding_or_const || ctx.is_irrefutable_pat_binding) {\n+    if ctx.is_pat_or_const == IsPatOrConst::No {\n         return;\n     }\n     if ctx.record_pat_syntax.is_some() {\n         return;\n     }\n \n-    if !ctx.is_irrefutable_pat_binding {\n+    let refutable = ctx.is_pat_or_const == IsPatOrConst::Refutable;\n+    if refutable {\n         if let Some(hir::Adt::Enum(e)) =\n             ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n         {\n@@ -31,14 +32,14 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n                     acc.add_struct_pat(ctx, *strukt, Some(name.clone()));\n                     true\n                 }\n-                hir::ModuleDef::Variant(variant) if !ctx.is_irrefutable_pat_binding => {\n+                hir::ModuleDef::Variant(variant) if refutable => {\n                     acc.add_variant_pat(ctx, *variant, Some(name.clone()));\n                     true\n                 }\n                 hir::ModuleDef::Adt(hir::Adt::Enum(..))\n                 | hir::ModuleDef::Variant(..)\n                 | hir::ModuleDef::Const(..)\n-                | hir::ModuleDef::Module(..) => !ctx.is_irrefutable_pat_binding,\n+                | hir::ModuleDef::Module(..) => refutable,\n                 _ => false,\n             },\n             hir::ScopeDef::MacroDef(_) => true,\n@@ -47,7 +48,7 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n                     acc.add_struct_pat(ctx, strukt, Some(name.clone()));\n                     true\n                 }\n-                Some(hir::Adt::Enum(_)) => !ctx.is_irrefutable_pat_binding,\n+                Some(hir::Adt::Enum(_)) => refutable,\n                 _ => true,\n             },\n             _ => false,"}, {"sha": "b8f8ef25f9a29843611059281ecb31ebadf36f90", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/666fc1cec10a41f88db56dfb339785eb1e7dd521/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666fc1cec10a41f88db56dfb339785eb1e7dd521/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=666fc1cec10a41f88db56dfb339785eb1e7dd521", "patch": "@@ -88,7 +88,7 @@ fn quux(x: Option<Enum>) {\n     }\n }\n \"#,\n-            expect![[\"\"]],\n+            expect![[r#\"\"#]],\n         );\n     }\n \n@@ -104,7 +104,7 @@ fn quux(x: Option<Enum>) {\n     }\n }\n \"#,\n-            expect![[\"\"]],\n+            expect![[r#\"\"#]],\n         );\n     }\n "}, {"sha": "9d761aa43bdb620047955991a9c8efaf8c1def57", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 82, "deletions": 70, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/666fc1cec10a41f88db56dfb339785eb1e7dd521/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666fc1cec10a41f88db56dfb339785eb1e7dd521/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=666fc1cec10a41f88db56dfb339785eb1e7dd521", "patch": "@@ -25,6 +25,13 @@ use crate::{\n     CompletionConfig,\n };\n \n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) enum IsPatOrConst {\n+    No,\n+    Refutable,\n+    Irrefutable,\n+}\n+\n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n #[derive(Debug)]\n@@ -42,23 +49,26 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) expected_name: Option<NameOrNameRef>,\n     pub(super) expected_type: Option<Type>,\n     pub(super) name_ref_syntax: Option<ast::NameRef>,\n-    pub(super) lifetime_syntax: Option<ast::Lifetime>,\n-    pub(super) lifetime_param_syntax: Option<ast::LifetimeParam>,\n     pub(super) function_syntax: Option<ast::Fn>,\n     pub(super) use_item_syntax: Option<ast::Use>,\n     pub(super) record_lit_syntax: Option<ast::RecordExpr>,\n     pub(super) record_pat_syntax: Option<ast::RecordPat>,\n     pub(super) record_field_syntax: Option<ast::RecordExprField>,\n+    /// The parent impl of the cursor position if it exists.\n     pub(super) impl_def: Option<ast::Impl>,\n+\n+    // potentially set if we are completing a lifetime\n+    pub(super) lifetime_syntax: Option<ast::Lifetime>,\n+    pub(super) lifetime_param_syntax: Option<ast::LifetimeParam>,\n     pub(super) lifetime_allowed: bool,\n+    pub(super) is_label_ref: bool,\n+\n+    // potentially set if we are completing a name\n+    pub(super) is_pat_or_const: IsPatOrConst,\n+    pub(super) is_param: bool,\n+\n     /// FIXME: `ActiveParameter` is string-based, which is very very wrong\n     pub(super) active_parameter: Option<ActiveParameter>,\n-    pub(super) is_param: bool,\n-    pub(super) is_label_ref: bool,\n-    /// If a name-binding or reference to a const in a pattern.\n-    /// Irrefutable patterns (like let) are excluded.\n-    pub(super) is_pat_binding_or_const: bool,\n-    pub(super) is_irrefutable_pat_binding: bool,\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n     /// If not a trivial path, the prefix (qualifier).\n@@ -103,7 +113,6 @@ pub(crate) struct CompletionContext<'a> {\n \n     no_completion_required: bool,\n }\n-\n impl<'a> CompletionContext<'a> {\n     pub(super) fn new(\n         db: &'a RootDatabase,\n@@ -160,8 +169,7 @@ impl<'a> CompletionContext<'a> {\n             active_parameter: ActiveParameter::at(db, position),\n             is_label_ref: false,\n             is_param: false,\n-            is_pat_binding_or_const: false,\n-            is_irrefutable_pat_binding: false,\n+            is_pat_or_const: IsPatOrConst::No,\n             is_trivial_path: false,\n             path_qual: None,\n             after_if: false,\n@@ -417,67 +425,19 @@ impl<'a> CompletionContext<'a> {\n         self.expected_type = expected_type;\n         self.expected_name = expected_name;\n         self.attribute_under_caret = find_node_at_offset(&file_with_fake_ident, offset);\n-\n-        if let Some(lifetime) = find_node_at_offset::<ast::Lifetime>(&file_with_fake_ident, offset)\n-        {\n-            self.classify_lifetime(original_file, lifetime, offset);\n-        }\n-\n-        // First, let's try to complete a reference to some declaration.\n-        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&file_with_fake_ident, offset) {\n-            // Special case, `trait T { fn foo(i_am_a_name_ref) {} }`.\n-            // See RFC#1685.\n-            if is_node::<ast::Param>(name_ref.syntax()) {\n-                self.is_param = true;\n-                return;\n-            }\n-            // FIXME: remove this (V) duplication and make the check more precise\n-            if name_ref.syntax().ancestors().find_map(ast::RecordPatFieldList::cast).is_some() {\n-                self.record_pat_syntax =\n-                    self.sema.find_node_at_offset_with_macros(&original_file, offset);\n-            }\n-            self.classify_name_ref(original_file, name_ref, offset);\n-        }\n-\n-        // Otherwise, see if this is a declaration. We can use heuristics to\n-        // suggest declaration names, see `CompletionKind::Magic`.\n-        if let Some(name) = find_node_at_offset::<ast::Name>(&file_with_fake_ident, offset) {\n-            if let Some(bind_pat) = name.syntax().ancestors().find_map(ast::IdentPat::cast) {\n-                self.is_pat_binding_or_const = true;\n-                if bind_pat.at_token().is_some()\n-                    || bind_pat.ref_token().is_some()\n-                    || bind_pat.mut_token().is_some()\n-                {\n-                    self.is_pat_binding_or_const = false;\n-                }\n-                if bind_pat.syntax().parent().and_then(ast::RecordPatFieldList::cast).is_some() {\n-                    self.is_pat_binding_or_const = false;\n-                }\n-                if let Some(Some(pat)) = bind_pat.syntax().ancestors().find_map(|node| {\n-                    match_ast! {\n-                        match node {\n-                            ast::LetStmt(it) => Some(it.pat()),\n-                            ast::Param(it) => Some(it.pat()),\n-                            _ => None,\n-                        }\n-                    }\n-                }) {\n-                    if pat.syntax().text_range().contains_range(bind_pat.syntax().text_range()) {\n-                        self.is_pat_binding_or_const = false;\n-                        self.is_irrefutable_pat_binding = true;\n-                    }\n-                }\n-\n-                self.fill_impl_def();\n+        let name_like = match find_node_at_offset(&&file_with_fake_ident, offset) {\n+            Some(it) => it,\n+            None => return,\n+        };\n+        match name_like {\n+            ast::NameLike::Lifetime(lifetime) => {\n+                self.classify_lifetime(original_file, lifetime, offset);\n             }\n-            if is_node::<ast::Param>(name.syntax()) {\n-                self.is_param = true;\n-                return;\n+            ast::NameLike::NameRef(name_ref) => {\n+                self.classify_name_ref(original_file, name_ref, offset);\n             }\n-            // FIXME: remove this (^) duplication and make the check more precise\n-            if name.syntax().ancestors().find_map(ast::RecordPatFieldList::cast).is_some() {\n-                self.record_pat_syntax =\n-                    self.sema.find_node_at_offset_with_macros(&original_file, offset);\n+            ast::NameLike::Name(name) => {\n+                self.classify_name(original_file, name, offset);\n             }\n         }\n     }\n@@ -511,12 +471,64 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n+    fn classify_name(&mut self, original_file: &SyntaxNode, name: ast::Name, offset: TextSize) {\n+        if let Some(bind_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n+            self.is_pat_or_const = IsPatOrConst::Refutable;\n+            // if any of these is here our bind pat can't be a const pat anymore\n+            let complex_ident_pat = bind_pat.at_token().is_some()\n+                || bind_pat.ref_token().is_some()\n+                || bind_pat.mut_token().is_some();\n+            if complex_ident_pat {\n+                self.is_pat_or_const = IsPatOrConst::No;\n+            } else if let Some(pat_field) =\n+                bind_pat.syntax().parent().and_then(ast::RecordPatField::cast)\n+            {\n+                if pat_field.name_ref().is_none() {\n+                    self.is_pat_or_const = IsPatOrConst::No;\n+                }\n+            } else {\n+                let irrefutable_pat = bind_pat.syntax().ancestors().find_map(|node| {\n+                    match_ast! {\n+                        match node {\n+                            ast::LetStmt(it) => Some(it.pat()),\n+                            ast::Param(it) => Some(it.pat()),\n+                            _ => None,\n+                        }\n+                    }\n+                });\n+                if let Some(Some(pat)) = irrefutable_pat {\n+                    // This check is here since we could be inside a pattern in the initializer expression of the let statement.\n+                    if pat.syntax().text_range().contains_range(bind_pat.syntax().text_range()) {\n+                        self.is_pat_or_const = IsPatOrConst::Irrefutable;\n+                    }\n+                }\n+            }\n+\n+            self.fill_impl_def();\n+        }\n+        if is_node::<ast::Param>(name.syntax()) {\n+            self.is_param = true;\n+            return;\n+        }\n+        // FIXME: remove this (V) duplication and make the check more precise\n+        if name.syntax().ancestors().find_map(ast::RecordPatFieldList::cast).is_some() {\n+            self.record_pat_syntax =\n+                self.sema.find_node_at_offset_with_macros(&original_file, offset);\n+        }\n+    }\n+\n     fn classify_name_ref(\n         &mut self,\n         original_file: &SyntaxNode,\n         name_ref: ast::NameRef,\n         offset: TextSize,\n     ) {\n+        // FIXME: remove this (^) duplication and make the check more precise\n+        if name_ref.syntax().ancestors().find_map(ast::RecordPatFieldList::cast).is_some() {\n+            self.record_pat_syntax =\n+                self.sema.find_node_at_offset_with_macros(&original_file, offset);\n+        }\n+\n         self.name_ref_syntax =\n             find_node_at_offset(original_file, name_ref.syntax().text_range().start());\n         let name_range = name_ref.syntax().text_range();"}, {"sha": "21f0da5f8f2c92b13806f6327805e2dce23c2db1", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/666fc1cec10a41f88db56dfb339785eb1e7dd521/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666fc1cec10a41f88db56dfb339785eb1e7dd521/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=666fc1cec10a41f88db56dfb339785eb1e7dd521", "patch": "@@ -20,6 +20,7 @@ use ide_db::{\n use syntax::TextRange;\n \n use crate::{\n+    context::IsPatOrConst,\n     item::{CompletionRelevanceTypeMatch, ImportEdit},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, CompletionRelevance,\n };\n@@ -188,8 +189,7 @@ impl<'a> Render<'a> {\n                 return render_fn(self.ctx, import_to_add, Some(local_name), *func);\n             }\n             ScopeDef::ModuleDef(Variant(_))\n-                if self.ctx.completion.is_pat_binding_or_const\n-                    | self.ctx.completion.is_irrefutable_pat_binding =>\n+                if self.ctx.completion.is_pat_or_const != IsPatOrConst::No =>\n             {\n                 CompletionItemKind::SymbolKind(SymbolKind::Variant)\n             }"}]}