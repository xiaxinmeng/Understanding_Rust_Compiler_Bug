{"sha": "8b6b3c159c0b980e340a9bb05b8a90bd9bc1dfd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNmIzYzE1OWMwYjk4MGUzNDBhOWJiMDViOGE5MGJkOWJjMWRmZDg=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-03-01T17:19:07Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-03-01T18:45:35Z"}, "message": "Emit proper attributes for the self pointer in method call through trait objects\n\nFor method calls through trait objects, we currently generate the llvm\nfunction argument attributes using the non-opaque method signature that\nstill has the trait object fat pointer for the self pointer. This leads\nto attributes that are plain wrong, e.g. noalias. As we don't know\nanything about the concrete type of the underlying object, we must\nreplace the self argument with an opaque i8 pointer before applying the\nattributes.", "tree": {"sha": "2f21f8e0b79c3134698811230db4db1a3271dcf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f21f8e0b79c3134698811230db4db1a3271dcf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b6b3c159c0b980e340a9bb05b8a90bd9bc1dfd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b6b3c159c0b980e340a9bb05b8a90bd9bc1dfd8", "html_url": "https://github.com/rust-lang/rust/commit/8b6b3c159c0b980e340a9bb05b8a90bd9bc1dfd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b6b3c159c0b980e340a9bb05b8a90bd9bc1dfd8/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41f8b1e89b5ca0c79d7bca782ca44085624d4564", "url": "https://api.github.com/repos/rust-lang/rust/commits/41f8b1e89b5ca0c79d7bca782ca44085624d4564", "html_url": "https://github.com/rust-lang/rust/commit/41f8b1e89b5ca0c79d7bca782ca44085624d4564"}], "stats": {"total": 41, "additions": 35, "deletions": 6}, "files": [{"sha": "71265bd71e18f77a2cd8f222463b6c0451474967", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8b6b3c159c0b980e340a9bb05b8a90bd9bc1dfd8/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b6b3c159c0b980e340a9bb05b8a90bd9bc1dfd8/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=8b6b3c159c0b980e340a9bb05b8a90bd9bc1dfd8", "patch": "@@ -603,7 +603,18 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_expr={})\", call_expr.repr(bcx.tcx()));\n     let method_call = MethodCall::expr(call_expr.id);\n-    let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n+    let method_ty = match bcx.tcx().method_map.borrow().get(&method_call) {\n+        Some(method) => match method.origin {\n+            ty::MethodTraitObject(_) => match method.ty.sty {\n+                ty::ty_bare_fn(_, ref fty) => {\n+                    ty::mk_bare_fn(bcx.tcx(), None, meth::opaque_method_ty(bcx.tcx(), fty))\n+                }\n+                _ => method.ty\n+            },\n+            _ => method.ty\n+        },\n+        None => panic!(\"method not found in trans_method_call\")\n+    };\n     trans_call_inner(\n         bcx,\n         call_expr.debug_loc(),"}, {"sha": "69e05eaea21d2c55046d9fced1e0fef0dc05d2ae", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8b6b3c159c0b980e340a9bb05b8a90bd9bc1dfd8/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b6b3c159c0b980e340a9bb05b8a90bd9bc1dfd8/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=8b6b3c159c0b980e340a9bb05b8a90bd9bc1dfd8", "patch": "@@ -589,15 +589,16 @@ pub fn trans_object_shim<'a, 'tcx>(\n     };\n     let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n     let fty = tcx.mk_bare_fn(fty);\n-    debug!(\"trans_object_shim: fty={}\", fty.repr(tcx));\n+    let method_ty = opaque_method_ty(tcx, fty);\n+    debug!(\"trans_object_shim: fty={} method_ty={}\", fty.repr(tcx), method_ty.repr(tcx));\n \n     //\n-    let method_bare_fn_ty =\n-        ty::mk_bare_fn(tcx, None, fty);\n+    let shim_fn_ty = ty::mk_bare_fn(tcx, None, fty);\n+    let method_bare_fn_ty = ty::mk_bare_fn(tcx, None, method_ty);\n     let function_name =\n-        link::mangle_internal_name_by_type_and_seq(ccx, method_bare_fn_ty, \"object_shim\");\n+        link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n     let llfn =\n-        decl_internal_rust_fn(ccx, method_bare_fn_ty, &function_name);\n+        decl_internal_rust_fn(ccx, shim_fn_ty, &function_name);\n \n     let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n \n@@ -866,3 +867,20 @@ pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     bcx\n }\n+\n+/// Replace the self type (&Self or Box<Self>) with an opaque pointer.\n+pub fn opaque_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n+        -> &'tcx ty::BareFnTy<'tcx> {\n+    let mut inputs = method_ty.sig.0.inputs.clone();\n+    inputs[0] = ty::mk_mut_ptr(tcx, ty::mk_mach_int(tcx, ast::TyI8));\n+\n+    tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: method_ty.unsafety,\n+        abi: method_ty.abi,\n+        sig: ty::Binder(ty::FnSig {\n+            inputs: inputs,\n+            output: method_ty.sig.0.output,\n+            variadic: method_ty.sig.0.variadic,\n+        }),\n+    })\n+}"}]}