{"sha": "278f5b043d3cde9ed5b6dfef708ed29179fd534c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OGY1YjA0M2QzY2RlOWVkNWI2ZGZlZjcwOGVkMjkxNzlmZDUzNGM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-09T18:06:24Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-21T15:48:34Z"}, "message": "Fix fallback to bound vars in `unify`", "tree": {"sha": "834bda00395d46f9ac3b08c993d29ae7e1cd0834", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/834bda00395d46f9ac3b08c993d29ae7e1cd0834"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/278f5b043d3cde9ed5b6dfef708ed29179fd534c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/278f5b043d3cde9ed5b6dfef708ed29179fd534c", "html_url": "https://github.com/rust-lang/rust/commit/278f5b043d3cde9ed5b6dfef708ed29179fd534c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/278f5b043d3cde9ed5b6dfef708ed29179fd534c/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aebcf7b5d4a37a08f2a64f7660b7e3d890476dba", "url": "https://api.github.com/repos/rust-lang/rust/commits/aebcf7b5d4a37a08f2a64f7660b7e3d890476dba", "html_url": "https://github.com/rust-lang/rust/commit/aebcf7b5d4a37a08f2a64f7660b7e3d890476dba"}], "stats": {"total": 123, "additions": 78, "deletions": 45}, "files": [{"sha": "00066975fc3bbecec17d96e915c4ee9c6222116c", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 78, "deletions": 45, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/278f5b043d3cde9ed5b6dfef708ed29179fd534c/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278f5b043d3cde9ed5b6dfef708ed29179fd534c/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=278f5b043d3cde9ed5b6dfef708ed29179fd534c", "patch": "@@ -4,15 +4,14 @@ use std::{borrow::Cow, fmt, sync::Arc};\n \n use chalk_ir::{\n     cast::Cast, fold::Fold, interner::HasInterner, FloatTy, IntTy, TyVariableKind, UniverseIndex,\n-    VariableKind,\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n \n use super::{InferOk, InferResult, InferenceContext, TypeError};\n use crate::{\n     db::HirDatabase, fold_tys, static_lifetime, BoundVar, Canonical, DebruijnIndex, GenericArg,\n-    InferenceVar, Interner, Scalar, Substitution, TraitEnvironment, Ty, TyKind,\n+    InferenceVar, Interner, Scalar, Substitution, TraitEnvironment, Ty, TyKind, VariableKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -112,19 +111,28 @@ pub(crate) fn unify(\n     }\n     // default any type vars that weren't unified back to their original bound vars\n     // (kind of hacky)\n-    for (i, var) in vars.iter(&Interner).enumerate() {\n-        let var = var.assert_ty_ref(&Interner);\n-        if &*table.resolve_ty_shallow(var) == var {\n-            table.unify(\n-                var,\n-                &TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i)).intern(&Interner),\n-            );\n-        }\n-    }\n+    let find_var = |iv| {\n+        vars.iter(&Interner).position(|v| match v.interned() {\n+            chalk_ir::GenericArgData::Ty(ty) => ty.inference_var(&Interner),\n+            chalk_ir::GenericArgData::Lifetime(lt) => lt.inference_var(&Interner),\n+            chalk_ir::GenericArgData::Const(c) => c.inference_var(&Interner),\n+        } == Some(iv))\n+    };\n+    let fallback = |iv, kind, default| match kind {\n+        chalk_ir::VariableKind::Ty(_ty_kind) => find_var(iv).map_or(default, |i| {\n+            BoundVar::new(DebruijnIndex::INNERMOST, i).to_ty(&Interner).cast(&Interner)\n+        }),\n+        chalk_ir::VariableKind::Lifetime => find_var(iv).map_or(default, |i| {\n+            BoundVar::new(DebruijnIndex::INNERMOST, i).to_lifetime(&Interner).cast(&Interner)\n+        }),\n+        chalk_ir::VariableKind::Const(ty) => find_var(iv).map_or(default, |i| {\n+            BoundVar::new(DebruijnIndex::INNERMOST, i).to_const(&Interner, ty).cast(&Interner)\n+        }),\n+    };\n     Some(Substitution::from_iter(\n         &Interner,\n         vars.iter(&Interner)\n-            .map(|v| table.resolve_ty_completely(v.assert_ty_ref(&Interner).clone())),\n+            .map(|v| table.resolve_with_fallback(v.assert_ty_ref(&Interner).clone(), fallback)),\n     ))\n }\n \n@@ -201,8 +209,65 @@ impl<'a> InferenceTable<'a> {\n         self.new_var(TyVariableKind::General, true)\n     }\n \n+    pub(crate) fn resolve_with_fallback<T>(\n+        &mut self,\n+        t: T,\n+        fallback: impl Fn(InferenceVar, VariableKind, GenericArg) -> GenericArg,\n+    ) -> T::Result\n+    where\n+        T: HasInterner<Interner = Interner> + Fold<Interner>,\n+    {\n+        self.resolve_with_fallback_inner(&mut Vec::new(), t, &fallback)\n+    }\n+\n+    fn resolve_with_fallback_inner<T>(\n+        &mut self,\n+        var_stack: &mut Vec<InferenceVar>,\n+        t: T,\n+        fallback: &impl Fn(InferenceVar, VariableKind, GenericArg) -> GenericArg,\n+    ) -> T::Result\n+    where\n+        T: HasInterner<Interner = Interner> + Fold<Interner>,\n+    {\n+        fold_tys(\n+            t,\n+            |ty, _| match ty.kind(&Interner) {\n+                &TyKind::InferenceVar(tv, kind) => {\n+                    if var_stack.contains(&tv) {\n+                        cov_mark::hit!(type_var_cycles_resolve_as_possible);\n+                        // recursive type\n+                        let default =\n+                            self.type_variable_table.fallback_value(tv, kind).cast(&Interner);\n+                        return fallback(tv, VariableKind::Ty(kind), default)\n+                            .assert_ty_ref(&Interner)\n+                            .clone();\n+                    }\n+                    if let Some(known_ty) = self.var_unification_table.probe_var(tv) {\n+                        // known_ty may contain other variables that are known by now\n+                        var_stack.push(tv);\n+                        let result = self.resolve_with_fallback_inner(\n+                            var_stack,\n+                            known_ty.assert_ty_ref(&Interner).clone(),\n+                            fallback,\n+                        );\n+                        var_stack.pop();\n+                        result\n+                    } else {\n+                        let default =\n+                            self.type_variable_table.fallback_value(tv, kind).cast(&Interner);\n+                        fallback(tv, VariableKind::Ty(kind), default)\n+                            .assert_ty_ref(&Interner)\n+                            .clone()\n+                    }\n+                }\n+                _ => ty,\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n+    }\n+\n     pub(crate) fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n-        self.resolve_ty_completely_inner(&mut Vec::new(), ty)\n+        self.resolve_with_fallback(ty, |_, _, d| d)\n     }\n \n     // FIXME get rid of this, instead resolve shallowly where necessary\n@@ -282,38 +347,6 @@ impl<'a> InferenceTable<'a> {\n             DebruijnIndex::INNERMOST,\n         )\n     }\n-\n-    /// Resolves the type completely; type variables without known type are\n-    /// replaced by TyKind::Unknown.\n-    fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<InferenceVar>, ty: Ty) -> Ty {\n-        // FIXME implement as a proper Folder, handle lifetimes and consts as well\n-        fold_tys(\n-            ty,\n-            |ty, _| match ty.kind(&Interner) {\n-                &TyKind::InferenceVar(tv, kind) => {\n-                    if tv_stack.contains(&tv) {\n-                        cov_mark::hit!(type_var_cycles_resolve_completely);\n-                        // recursive type\n-                        return self.type_variable_table.fallback_value(tv, kind);\n-                    }\n-                    if let Some(known_ty) = self.var_unification_table.probe_var(tv) {\n-                        // known_ty may contain other variables that are known by now\n-                        tv_stack.push(tv);\n-                        let result = self.resolve_ty_completely_inner(\n-                            tv_stack,\n-                            known_ty.assert_ty_ref(&Interner).clone(),\n-                        );\n-                        tv_stack.pop();\n-                        result\n-                    } else {\n-                        self.type_variable_table.fallback_value(tv, kind)\n-                    }\n-                }\n-                _ => ty,\n-            },\n-            DebruijnIndex::INNERMOST,\n-        )\n-    }\n }\n \n impl<'a> fmt::Debug for InferenceTable<'a> {"}]}