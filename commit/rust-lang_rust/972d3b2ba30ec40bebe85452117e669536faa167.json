{"sha": "972d3b2ba30ec40bebe85452117e669536faa167", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MmQzYjJiYTMwZWM0MGJlYmU4NTQ1MjExN2U2Njk1MzZmYWExNjc=", "commit": {"author": {"name": "veetaha", "email": "veetaha2@gmail.com", "date": "2020-04-18T20:51:13Z"}, "committer": {"name": "veetaha", "email": "veetaha2@gmail.com", "date": "2020-04-18T20:51:13Z"}, "message": "Group generated ast boilerplate apart from the interesting part", "tree": {"sha": "f1e2763392c045324f1963e355378de4acf9eb57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1e2763392c045324f1963e355378de4acf9eb57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/972d3b2ba30ec40bebe85452117e669536faa167", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/972d3b2ba30ec40bebe85452117e669536faa167", "html_url": "https://github.com/rust-lang/rust/commit/972d3b2ba30ec40bebe85452117e669536faa167", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/972d3b2ba30ec40bebe85452117e669536faa167/comments", "author": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b949500126f6bd3723d22541adb2f7c8aae206a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b949500126f6bd3723d22541adb2f7c8aae206a4", "html_url": "https://github.com/rust-lang/rust/commit/b949500126f6bd3723d22541adb2f7c8aae206a4"}], "stats": {"total": 3222, "additions": 1616, "deletions": 1606}, "files": [{"sha": "2cb3ad01145f05f3df97b8dead1676ee96a9c053", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1486, "deletions": 1486, "changes": 2972, "blob_url": "https://github.com/rust-lang/rust/blob/972d3b2ba30ec40bebe85452117e669536faa167/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972d3b2ba30ec40bebe85452117e669536faa167/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=972d3b2ba30ec40bebe85452117e669536faa167"}, {"sha": "e9dc09552da7b4db5405161f11c2105546e17bd1", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 130, "deletions": 120, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/972d3b2ba30ec40bebe85452117e669536faa167/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972d3b2ba30ec40bebe85452117e669536faa167/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=972d3b2ba30ec40bebe85452117e669536faa167", "patch": "@@ -63,126 +63,138 @@ fn generate_tokens(grammar: AstSrc<'_>) -> Result<String> {\n }\n \n fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n-    let nodes = grammar.nodes.iter().map(|node| {\n-        let name = format_ident!(\"{}\", node.name);\n-        let kind = format_ident!(\"{}\", to_upper_snake_case(&name.to_string()));\n-        let traits = node.traits.iter().map(|trait_name| {\n-            let trait_name = format_ident!(\"{}\", trait_name);\n-            quote!(impl ast::#trait_name for #name {})\n-        });\n-\n-        let methods = node.fields.iter().map(|field| {\n-            let method_name = field.method_name();\n-            let ty = field.ty();\n-\n-            if field.is_many() {\n-                quote! {\n-                    pub fn #method_name(&self) -> AstChildren<#ty> {\n-                        support::children(&self.syntax)\n-                    }\n-                }\n-            } else {\n-                if let Some(token_kind) = field.token_kind() {\n+    let (node_defs, node_boilerplate_impls): (Vec<_>, Vec<_>) = grammar\n+        .nodes\n+        .iter()\n+        .map(|node| {\n+            let name = format_ident!(\"{}\", node.name);\n+            let kind = format_ident!(\"{}\", to_upper_snake_case(&name.to_string()));\n+            let traits = node.traits.iter().map(|trait_name| {\n+                let trait_name = format_ident!(\"{}\", trait_name);\n+                quote!(impl ast::#trait_name for #name {})\n+            });\n+\n+            let methods = node.fields.iter().map(|field| {\n+                let method_name = field.method_name();\n+                let ty = field.ty();\n+\n+                if field.is_many() {\n                     quote! {\n-                        pub fn #method_name(&self) -> Option<#ty> {\n-                            support::token(&self.syntax, #token_kind)\n+                        pub fn #method_name(&self) -> AstChildren<#ty> {\n+                            support::children(&self.syntax)\n                         }\n                     }\n                 } else {\n-                    quote! {\n-                        pub fn #method_name(&self) -> Option<#ty> {\n-                            support::child(&self.syntax)\n+                    if let Some(token_kind) = field.token_kind() {\n+                        quote! {\n+                            pub fn #method_name(&self) -> Option<#ty> {\n+                                support::token(&self.syntax, #token_kind)\n+                            }\n+                        }\n+                    } else {\n+                        quote! {\n+                            pub fn #method_name(&self) -> Option<#ty> {\n+                                support::child(&self.syntax)\n+                            }\n                         }\n                     }\n                 }\n-            }\n-        });\n-\n-        quote! {\n-            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-            pub struct #name {\n-                pub(crate) syntax: SyntaxNode,\n-            }\n-\n-            impl AstNode for #name {\n-                fn can_cast(kind: SyntaxKind) -> bool {\n-                    kind == #kind\n-                }\n-                fn cast(syntax: SyntaxNode) -> Option<Self> {\n-                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n-                }\n-                fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-            }\n-\n-            #(#traits)*\n-\n-            impl #name {\n-                #(#methods)*\n-            }\n-        }\n-    });\n+            });\n+            (\n+                quote! {\n+                    #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+                    pub struct #name {\n+                        pub(crate) syntax: SyntaxNode,\n+                    }\n \n-    let enums = grammar.enums.iter().map(|en| {\n-        let variants = en.variants.iter().map(|var| format_ident!(\"{}\", var)).collect::<Vec<_>>();\n-        let name = format_ident!(\"{}\", en.name);\n-        let kinds = variants\n-            .iter()\n-            .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.to_string())))\n-            .collect::<Vec<_>>();\n-        let traits = en.traits.iter().map(|trait_name| {\n-            let trait_name = format_ident!(\"{}\", trait_name);\n-            quote!(impl ast::#trait_name for #name {})\n-        });\n+                    #(#traits)*\n \n-        quote! {\n-            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-            pub enum #name {\n-                #(#variants(#variants),)*\n-            }\n+                    impl #name {\n+                        #(#methods)*\n+                    }\n+                },\n+                quote! {\n+                    impl AstNode for #name {\n+                        fn can_cast(kind: SyntaxKind) -> bool {\n+                            kind == #kind\n+                        }\n+                        fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                            if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n+                        }\n+                        fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+                    }\n+                },\n+            )\n+        })\n+        .unzip();\n \n-            #(\n-            impl From<#variants> for #name {\n-                fn from(node: #variants) -> #name {\n-                    #name::#variants(node)\n-                }\n-            }\n-            )*\n+    let (enum_defs, enum_boilerplate_impls): (Vec<_>, Vec<_>) = grammar\n+        .enums\n+        .iter()\n+        .map(|en| {\n+            let variants: Vec<_> = en.variants.iter().map(|var| format_ident!(\"{}\", var)).collect();\n+            let name = format_ident!(\"{}\", en.name);\n+            let kinds: Vec<_> = variants\n+                .iter()\n+                .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.to_string())))\n+                .collect();\n+            let traits = en.traits.iter().map(|trait_name| {\n+                let trait_name = format_ident!(\"{}\", trait_name);\n+                quote!(impl ast::#trait_name for #name {})\n+            });\n+\n+            (\n+                quote! {\n+                    #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+                    pub enum #name {\n+                        #(#variants(#variants),)*\n+                    }\n \n-            impl AstNode for #name {\n-                fn can_cast(kind: SyntaxKind) -> bool {\n-                    match kind {\n-                        #(#kinds)|* => true,\n-                        _ => false,\n+                    #(#traits)*\n+                },\n+                quote! {\n+                    #(\n+                    impl From<#variants> for #name {\n+                        fn from(node: #variants) -> #name {\n+                            #name::#variants(node)\n+                        }\n                     }\n-                }\n-                fn cast(syntax: SyntaxNode) -> Option<Self> {\n-                    let res = match syntax.kind() {\n-                        #(\n-                        #kinds => #name::#variants(#variants { syntax }),\n-                        )*\n-                        _ => return None,\n-                    };\n-                    Some(res)\n-                }\n-                fn syntax(&self) -> &SyntaxNode {\n-                    match self {\n-                        #(\n-                        #name::#variants(it) => &it.syntax,\n-                        )*\n+                    )*\n+\n+                    impl AstNode for #name {\n+                        fn can_cast(kind: SyntaxKind) -> bool {\n+                            match kind {\n+                                #(#kinds)|* => true,\n+                                _ => false,\n+                            }\n+                        }\n+                        fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                            let res = match syntax.kind() {\n+                                #(\n+                                #kinds => #name::#variants(#variants { syntax }),\n+                                )*\n+                                _ => return None,\n+                            };\n+                            Some(res)\n+                        }\n+                        fn syntax(&self) -> &SyntaxNode {\n+                            match self {\n+                                #(\n+                                #name::#variants(it) => &it.syntax,\n+                                )*\n+                            }\n+                        }\n                     }\n-                }\n-            }\n+                },\n+            )\n+        })\n+        .unzip();\n \n-            #(#traits)*\n-        }\n-    });\n+    let enum_names = grammar.enums.iter().map(|it| it.name);\n+    let node_names = grammar.nodes.iter().map(|it| it.name);\n \n-    let displays = grammar\n-        .enums\n-        .iter()\n-        .map(|it| format_ident!(\"{}\", it.name))\n-        .chain(grammar.nodes.iter().map(|it| format_ident!(\"{}\", it.name)))\n-        .map(|name| {\n+    let display_impls =\n+        enum_names.chain(node_names.clone()).map(|it| format_ident!(\"{}\", it)).map(|name| {\n             quote! {\n                 impl std::fmt::Display for #name {\n                     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n@@ -192,13 +204,13 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             }\n         });\n \n-    let defined_nodes: HashSet<_> = grammar.nodes.iter().map(|node| node.name).collect();\n+    let defined_nodes: HashSet<_> = node_names.collect();\n \n     for node in kinds\n         .nodes\n         .iter()\n-        .map(|kind| to_pascal_case(*kind))\n-        .filter(|name| !defined_nodes.contains(&**name))\n+        .map(|kind| to_pascal_case(kind))\n+        .filter(|name| !defined_nodes.contains(name.as_str()))\n     {\n         eprintln!(\"Warning: node {} not defined in ast source\", node);\n     }\n@@ -210,9 +222,11 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             T,\n         };\n \n-        #(#nodes)*\n-        #(#enums)*\n-        #(#displays)*\n+        #(#node_defs)*\n+        #(#enum_defs)*\n+        #(#node_boilerplate_impls)*\n+        #(#enum_boilerplate_impls)*\n+        #(#display_impls)*\n     };\n \n     let ast = ast.to_string().replace(\"T ! [ \", \"T![\").replace(\" ] )\", \"])\");\n@@ -380,20 +394,16 @@ fn to_pascal_case(s: &str) -> String {\n \n impl Field<'_> {\n     fn is_many(&self) -> bool {\n-        match self {\n-            Field::Node { src: FieldSrc::Many(_), .. } => true,\n-            _ => false,\n-        }\n+        matches!(self, Field::Node { src: FieldSrc::Many(_), .. })\n     }\n     fn token_kind(&self) -> Option<proc_macro2::TokenStream> {\n-        let res = match self {\n+        match self {\n             Field::Token(token) => {\n                 let token: proc_macro2::TokenStream = token.parse().unwrap();\n-                quote! { T![#token] }\n+                Some(quote! { T![#token] })\n             }\n-            _ => return None,\n-        };\n-        Some(res)\n+            _ => None,\n+        }\n     }\n     fn method_name(&self) -> proc_macro2::Ident {\n         match self {"}]}