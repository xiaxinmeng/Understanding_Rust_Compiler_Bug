{"sha": "8996328ebf34aa73e83a1db326767c11041f811d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5OTYzMjhlYmYzNGFhNzNlODNhMWRiMzI2NzY3YzExMDQxZjgxMWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-06T08:21:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-06T08:21:32Z"}, "message": "Auto merge of #63319 - Centril:rollup-d89rmey, r=Centril\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #61457 (Implement DoubleEndedIterator for iter::{StepBy, Peekable, Take})\n - #63017 (Remove special code-path for handing unknown tokens)\n - #63184 (Explaining the reason why validation is performed in to_str of path.rs)\n - #63230 (Make use of possibly uninitialized data [E0381] a hard error)\n - #63260 (fix UB in a test)\n - #63264 (Revert \"Rollup merge of #62696 - chocol4te:fix_#62194, r=estebank\")\n - #63272 (Some more libsyntax::attr cleanup)\n - #63285 (Remove leftover AwaitOrigin)\n - #63287 (Don't store &Span)\n - #63293 (Clarify align_to's requirements and obligations)\n - #63295 (improve align_offset docs)\n - #63299 (Make qualify consts in_projection use PlaceRef)\n - #63312 (doc: fix broken sentence)\n - #63315 (Fix #63313)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ace3a569927dac51b06712b6c2b71dada6a6e211", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ace3a569927dac51b06712b6c2b71dada6a6e211"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8996328ebf34aa73e83a1db326767c11041f811d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8996328ebf34aa73e83a1db326767c11041f811d", "html_url": "https://github.com/rust-lang/rust/commit/8996328ebf34aa73e83a1db326767c11041f811d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8996328ebf34aa73e83a1db326767c11041f811d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "766b10a8d544550712fd6352863457a86f46db3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/766b10a8d544550712fd6352863457a86f46db3c", "html_url": "https://github.com/rust-lang/rust/commit/766b10a8d544550712fd6352863457a86f46db3c"}, {"sha": "c27405f829f6b57b2695478c41096729236831f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c27405f829f6b57b2695478c41096729236831f2", "html_url": "https://github.com/rust-lang/rust/commit/c27405f829f6b57b2695478c41096729236831f2"}], "stats": {"total": 1138, "additions": 808, "deletions": 330}, "files": [{"sha": "af46e6df2942b21711a2e570470540732573464b", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -485,6 +485,39 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n     }\n }\n \n+impl<I> StepBy<I> where I: ExactSizeIterator {\n+    // The zero-based index starting from the end of the iterator of the\n+    // last element. Used in the `DoubleEndedIterator` implementation.\n+    fn next_back_index(&self) -> usize {\n+        let rem = self.iter.len() % (self.step + 1);\n+        if self.first_take {\n+            if rem == 0 { self.step } else { rem - 1 }\n+        } else {\n+            rem\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"double_ended_step_by_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for StepBy<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.iter.nth_back(self.next_back_index())\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        // `self.iter.nth_back(usize::MAX)` does the right thing here when `n`\n+        // is out of bounds because the length of `self.iter` does not exceed\n+        // `usize::MAX` (because `I: ExactSizeIterator`) and `nth_back` is\n+        // zero-indexed\n+        let n = n\n+            .saturating_mul(self.step + 1)\n+            .saturating_add(self.next_back_index());\n+        self.iter.nth_back(n)\n+    }\n+}\n+\n // StepBy can only make the iterator shorter, so the len will still fit.\n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n@@ -1158,6 +1191,45 @@ impl<I: Iterator> Iterator for Peekable<I> {\n     }\n }\n \n+#[stable(feature = \"double_ended_peek_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.iter.next_back().or_else(|| self.peeked.take().and_then(|x| x))\n+    }\n+\n+    #[inline]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        match self.peeked.take() {\n+            Some(None) => return Try::from_ok(init),\n+            Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n+                Ok(acc) => f(acc, v),\n+                Err(e) => {\n+                    self.peeked = Some(Some(v));\n+                    Try::from_error(e)\n+                }\n+            },\n+            None => self.iter.try_rfold(init, f),\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        match self.peeked {\n+            Some(None) => return init,\n+            Some(Some(v)) => {\n+                let acc = self.iter.rfold(init, &mut fold);\n+                fold(acc, v)\n+            }\n+            None => self.iter.rfold(init, fold),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n \n@@ -1627,6 +1699,51 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n }\n \n+#[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Take<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.n == 0 {\n+            None\n+        } else {\n+            let n = self.n;\n+            self.n -= 1;\n+            self.iter.nth_back(self.iter.len().saturating_sub(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.iter.len();\n+        if self.n > n {\n+            let m = len.saturating_sub(self.n) + n;\n+            self.n -= n + 1;\n+            self.iter.nth_back(m)\n+        } else {\n+            if len > 0 {\n+                self.iter.nth_back(len - 1);\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok = Acc>\n+    {\n+        if self.n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            let len = self.iter.len();\n+            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n+                Try::from_ok(init)\n+            } else {\n+                self.iter.try_rfold(init, fold)\n+            }\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n "}, {"sha": "fa55bbf9c16507ecd4c1f5399fd6ec9d4f497efb", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -1606,10 +1606,12 @@ impl<T: ?Sized> *const T {\n     /// `align`.\n     ///\n     /// If it is not possible to align the pointer, the implementation returns\n-    /// `usize::max_value()`.\n+    /// `usize::max_value()`. It is permissible for the implementation to *always*\n+    /// return `usize::max_value()`. Only your algorithm's performance can depend\n+    /// on getting a usable offset here, not its correctness.\n     ///\n     /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n-    /// used with the `add` method.\n+    /// used with the `wrapping_add` method.\n     ///\n     /// There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n     /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n@@ -2407,10 +2409,12 @@ impl<T: ?Sized> *mut T {\n     /// `align`.\n     ///\n     /// If it is not possible to align the pointer, the implementation returns\n-    /// `usize::max_value()`.\n+    /// `usize::max_value()`. It is permissible for the implementation to *always*\n+    /// return `usize::max_value()`. Only your algorithm's performance can depend\n+    /// on getting a usable offset here, not its correctness.\n     ///\n     /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n-    /// used with the `add` method.\n+    /// used with the `wrapping_add` method.\n     ///\n     /// There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n     /// beyond the allocation that the pointer points into. It is up to the caller to ensure that"}, {"sha": "d5a34ea2bd5a17edda41537a4194c82aa96cbadd", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -2308,9 +2308,10 @@ impl<T> [T] {\n     /// maintained.\n     ///\n     /// This method splits the slice into three distinct slices: prefix, correctly aligned middle\n-    /// slice of a new type, and the suffix slice. The method does a best effort to make the\n-    /// middle slice the greatest length possible for a given type and input slice, but only\n-    /// your algorithm's performance should depend on that, not its correctness.\n+    /// slice of a new type, and the suffix slice. The method may make the middle slice the greatest\n+    /// length possible for a given type and input slice, but only your algorithm's performance\n+    /// should depend on that, not its correctness. It is permissible for all of the input data to\n+    /// be returned as the prefix or suffix slice.\n     ///\n     /// This method has no purpose when either input element `T` or output element `U` are\n     /// zero-sized and will return the original slice without splitting anything.\n@@ -2361,9 +2362,10 @@ impl<T> [T] {\n     /// maintained.\n     ///\n     /// This method splits the slice into three distinct slices: prefix, correctly aligned middle\n-    /// slice of a new type, and the suffix slice. The method does a best effort to make the\n-    /// middle slice the greatest length possible for a given type and input slice, but only\n-    /// your algorithm's performance should depend on that, not its correctness.\n+    /// slice of a new type, and the suffix slice. The method may make the middle slice the greatest\n+    /// length possible for a given type and input slice, but only your algorithm's performance\n+    /// should depend on that, not its correctness. It is permissible for all of the input data to\n+    /// be returned as the prefix or suffix slice.\n     ///\n     /// This method has no purpose when either input element `T` or output element `U` are\n     /// zero-sized and will return the original slice without splitting anything."}, {"sha": "e27e1605607144f94b63a284015fab14e185bcac", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 179, "deletions": 13, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -188,6 +188,19 @@ fn test_iterator_step_by() {\n     assert_eq!(it.next(), Some(6));\n     assert_eq!(it.next(), Some(9));\n     assert_eq!(it.next(), None);\n+\n+    let mut it = (0..3).step_by(1);\n+    assert_eq!(it.next_back(), Some(2));\n+    assert_eq!(it.next_back(), Some(1));\n+    assert_eq!(it.next_back(), Some(0));\n+    assert_eq!(it.next_back(), None);\n+\n+    let mut it = (0..11).step_by(3);\n+    assert_eq!(it.next_back(), Some(9));\n+    assert_eq!(it.next_back(), Some(6));\n+    assert_eq!(it.next_back(), Some(3));\n+    assert_eq!(it.next_back(), Some(0));\n+    assert_eq!(it.next_back(), None);\n }\n \n #[test]\n@@ -252,6 +265,31 @@ fn test_iterator_step_by_nth_overflow() {\n     assert_eq!(it.0, (usize::MAX as Bigger) * 1);\n }\n \n+#[test]\n+fn test_iterator_step_by_nth_back() {\n+    let mut it = (0..16).step_by(5);\n+    assert_eq!(it.nth_back(0), Some(15));\n+    assert_eq!(it.nth_back(0), Some(10));\n+    assert_eq!(it.nth_back(0), Some(5));\n+    assert_eq!(it.nth_back(0), Some(0));\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let mut it = (0..16).step_by(5);\n+    assert_eq!(it.next(), Some(0)); // to set `first_take` to `false`\n+    assert_eq!(it.nth_back(0), Some(15));\n+    assert_eq!(it.nth_back(0), Some(10));\n+    assert_eq!(it.nth_back(0), Some(5));\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let it = || (0..18).step_by(5);\n+    assert_eq!(it().nth_back(0), Some(15));\n+    assert_eq!(it().nth_back(1), Some(10));\n+    assert_eq!(it().nth_back(2), Some(5));\n+    assert_eq!(it().nth_back(3), Some(0));\n+    assert_eq!(it().nth_back(4), None);\n+    assert_eq!(it().nth_back(42), None);\n+}\n+\n #[test]\n #[should_panic]\n fn test_iterator_step_by_zero() {\n@@ -465,8 +503,8 @@ fn test_iterator_filter_fold() {\n #[test]\n fn test_iterator_peekable() {\n     let xs = vec![0, 1, 2, 3, 4, 5];\n-    let mut it = xs.iter().cloned().peekable();\n \n+    let mut it = xs.iter().cloned().peekable();\n     assert_eq!(it.len(), 6);\n     assert_eq!(it.peek().unwrap(), &0);\n     assert_eq!(it.len(), 6);\n@@ -492,6 +530,33 @@ fn test_iterator_peekable() {\n     assert_eq!(it.len(), 0);\n     assert!(it.next().is_none());\n     assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().cloned().peekable();\n+    assert_eq!(it.len(), 6);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 6);\n+    assert_eq!(it.next_back().unwrap(), 5);\n+    assert_eq!(it.len(), 5);\n+    assert_eq!(it.next_back().unwrap(), 4);\n+    assert_eq!(it.len(), 4);\n+    assert_eq!(it.next_back().unwrap(), 3);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.next_back().unwrap(), 2);\n+    assert_eq!(it.len(), 2);\n+    assert_eq!(it.next_back().unwrap(), 1);\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.next_back().unwrap(), 0);\n+    assert_eq!(it.len(), 0);\n+    assert!(it.peek().is_none());\n+    assert_eq!(it.len(), 0);\n+    assert!(it.next_back().is_none());\n+    assert_eq!(it.len(), 0);\n }\n \n #[test]\n@@ -564,6 +629,18 @@ fn test_iterator_peekable_fold() {\n     assert_eq!(i, xs.len());\n }\n \n+#[test]\n+fn test_iterator_peekable_rfold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    let i = it.rfold(0, |i, &x| {\n+        assert_eq!(x, xs[xs.len() - 1 - i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}\n+\n /// This is an iterator that follows the Iterator contract,\n /// but it is not fused. After having returned None once, it will start\n /// producing elements if .next() is called again.\n@@ -812,13 +889,25 @@ fn test_iterator_skip_fold() {\n fn test_iterator_take() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n     let ys = [0, 1, 2, 3, 5];\n-    let mut it = xs.iter().take(5);\n+\n+    let mut it = xs.iter().take(ys.len());\n     let mut i = 0;\n-    assert_eq!(it.len(), 5);\n+    assert_eq!(it.len(), ys.len());\n     while let Some(&x) = it.next() {\n         assert_eq!(x, ys[i]);\n         i += 1;\n-        assert_eq!(it.len(), 5-i);\n+        assert_eq!(it.len(), ys.len() - i);\n+    }\n+    assert_eq!(i, ys.len());\n+    assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().take(ys.len());\n+    let mut i = 0;\n+    assert_eq!(it.len(), ys.len());\n+    while let Some(&x) = it.next_back() {\n+        i += 1;\n+        assert_eq!(x, ys[ys.len() - i]);\n+        assert_eq!(it.len(), ys.len() - i);\n     }\n     assert_eq!(i, ys.len());\n     assert_eq!(it.len(), 0);\n@@ -848,19 +937,51 @@ fn test_iterator_take_nth() {\n     }\n }\n \n+#[test]\n+fn test_iterator_take_nth_back() {\n+    let xs = [0, 1, 2, 4, 5];\n+    let mut it = xs.iter();\n+    {\n+        let mut take = it.by_ref().take(3);\n+        let mut i = 0;\n+        while let Some(&x) = take.nth_back(0) {\n+            i += 1;\n+            assert_eq!(x, 3 - i);\n+        }\n+    }\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let xs = [0, 1, 2, 3, 4];\n+    let mut it = xs.iter().take(7);\n+    assert_eq!(it.nth_back(1), Some(&3));\n+    assert_eq!(it.nth_back(1), Some(&1));\n+    assert_eq!(it.nth_back(1), None);\n+}\n+\n #[test]\n fn test_iterator_take_short() {\n     let xs = [0, 1, 2, 3];\n-    let ys = [0, 1, 2, 3];\n+\n     let mut it = xs.iter().take(5);\n     let mut i = 0;\n-    assert_eq!(it.len(), 4);\n+    assert_eq!(it.len(), xs.len());\n     while let Some(&x) = it.next() {\n-        assert_eq!(x, ys[i]);\n+        assert_eq!(x, xs[i]);\n         i += 1;\n-        assert_eq!(it.len(), 4-i);\n+        assert_eq!(it.len(), xs.len() - i);\n     }\n-    assert_eq!(i, ys.len());\n+    assert_eq!(i, xs.len());\n+    assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().take(5);\n+    let mut i = 0;\n+    assert_eq!(it.len(), xs.len());\n+    while let Some(&x) = it.next_back() {\n+        i += 1;\n+        assert_eq!(x, xs[xs.len() - i]);\n+        assert_eq!(it.len(), xs.len() - i);\n+    }\n+    assert_eq!(i, xs.len());\n     assert_eq!(it.len(), 0);\n }\n \n@@ -2278,17 +2399,50 @@ fn test_enumerate_try_folds() {\n }\n \n #[test]\n-fn test_peek_try_fold() {\n+fn test_peek_try_folds() {\n     let f = &|acc, x| i32::checked_add(2*acc, x);\n+\n     assert_eq!((1..20).peekable().try_fold(7, f), (1..20).try_fold(7, f));\n+    assert_eq!((1..20).peekable().try_rfold(7, f), (1..20).try_rfold(7, f));\n+\n     let mut iter = (1..20).peekable();\n     assert_eq!(iter.peek(), Some(&1));\n     assert_eq!(iter.try_fold(7, f), (1..20).try_fold(7, f));\n \n+    let mut iter = (1..20).peekable();\n+    assert_eq!(iter.peek(), Some(&1));\n+    assert_eq!(iter.try_rfold(7, f), (1..20).try_rfold(7, f));\n+\n     let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n     assert_eq!(iter.peek(), Some(&100));\n     assert_eq!(iter.try_fold(0, i8::checked_add), None);\n     assert_eq!(iter.peek(), Some(&40));\n+\n+    let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n+    assert_eq!(iter.peek(), Some(&100));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.peek(), Some(&100));\n+    assert_eq!(iter.next_back(), Some(50));\n+\n+    let mut iter = (2..5).peekable();\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.peek(), Some(&3));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.peek(), Some(&4));\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n+\n+    let mut iter = (2..5).peekable();\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(4));\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(3));\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(2));\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Ok(()));\n }\n \n #[test]\n@@ -2371,13 +2525,25 @@ fn test_skip_nth_back() {\n fn test_take_try_folds() {\n     let f = &|acc, x| i32::checked_add(2*acc, x);\n     assert_eq!((10..30).take(10).try_fold(7, f), (10..20).try_fold(7, f));\n-    //assert_eq!((10..30).take(10).try_rfold(7, f), (10..20).try_rfold(7, f));\n+    assert_eq!((10..30).take(10).try_rfold(7, f), (10..20).try_rfold(7, f));\n \n     let mut iter = (10..30).take(20);\n     assert_eq!(iter.try_fold(0, i8::checked_add), None);\n     assert_eq!(iter.next(), Some(20));\n-    //assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n-    //assert_eq!(iter.next_back(), Some(24));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(24));\n+\n+    let mut iter = (2..20).take(3);\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n+\n+    let mut iter = (2..20).take(3).rev();\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n }\n \n #[test]"}, {"sha": "1a6be3a9bbd034558618281c4a325e762d1f6ac6", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -145,7 +145,6 @@ fn test_as_ref() {\n }\n \n #[test]\n-#[cfg(not(miri))] // This test is UB according to Stacked Borrows\n fn test_as_mut() {\n     unsafe {\n         let p: *mut isize = null_mut();\n@@ -164,7 +163,7 @@ fn test_as_mut() {\n         // Pointers to unsized types -- slices\n         let s: &mut [u8] = &mut [1, 2, 3];\n         let ms: *mut [u8] = s;\n-        assert_eq!(ms.as_mut(), Some(s));\n+        assert_eq!(ms.as_mut(), Some(&mut [1, 2, 3][..]));\n \n         let mz: *mut [u8] = &mut [];\n         assert_eq!(mz.as_mut(), Some(&mut [][..]));"}, {"sha": "493083c680aad0f4585cde7b9a3fcaa89c50cbb2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -5176,11 +5176,10 @@ impl<'a> LoweringContext<'a> {\n                 let attr = {\n                     // `allow(unreachable_code)`\n                     let allow = {\n-                        let allow_ident = Ident::with_empty_ctxt(sym::allow).with_span_pos(e.span);\n-                        let uc_ident = Ident::with_empty_ctxt(sym::unreachable_code)\n-                            .with_span_pos(e.span);\n+                        let allow_ident = Ident::new(sym::allow, e.span);\n+                        let uc_ident = Ident::new(sym::unreachable_code, e.span);\n                         let uc_nested = attr::mk_nested_word_item(uc_ident);\n-                        attr::mk_list_item(e.span, allow_ident, vec![uc_nested])\n+                        attr::mk_list_item(allow_ident, vec![uc_nested])\n                     };\n                     attr::mk_attr_outer(allow)\n                 };"}, {"sha": "5cc8324b316065064a413867c538c8abe2ee6d46", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -363,7 +363,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for token::TokenKind {\n             }\n \n             token::DocComment(val) |\n-            token::Shebang(val) => val.hash_stable(hcx, hasher),\n+            token::Shebang(val) |\n+            token::Unknown(val) => val.hash_stable(hcx, hasher),\n         }\n     }\n }"}, {"sha": "7eb4da86ec081fb82b144431409186f0da1471f8", "filename": "src/librustc/infer/lexical_region_resolve/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -6,7 +6,7 @@\n > As of edition 2018, region inference is done using Non-lexical lifetimes,\n > which is described in the guide and [this RFC].\n \n-[rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n+[rustc guide]: https://rust-lang.github.io/rustc-guide/borrow_check/region_inference.html\n [this RFC]: https://github.com/rust-lang/rfcs/blob/master/text/2094-nll.md\n \n ## Terminology"}, {"sha": "f0389bb037ac5b827aeb4e1e5bcc8e07f1d29d5a", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -366,13 +366,8 @@ pub(super) fn specialization_graph_provider(\n                     }\n                 }\n \n-                let access_levels = tcx.privacy_access_levels(impl_def_id.krate);\n-                if let Some(id) = tcx.hir().as_local_hir_id(impl_def_id) {\n-                    if access_levels.is_exported(id) || access_levels.is_public(id) {\n-                        for cause in &overlap.intercrate_ambiguity_causes {\n-                            cause.add_intercrate_ambiguity_hint(&mut err);\n-                        }\n-                    }\n+                for cause in &overlap.intercrate_ambiguity_causes {\n+                    cause.add_intercrate_ambiguity_hint(&mut err);\n                 }\n \n                 if overlap.involves_placeholder {"}, {"sha": "4217a29bc663cbf4e7a7b663360552306d9a8997", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -105,6 +105,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n             );\n \n+            // This error should not be downgraded to a warning,\n+            // even in migrate mode.\n+            self.disable_error_downgrading();\n             err.buffer(&mut self.errors_buffer);\n         } else {\n             if let Some((reported_place, _)) = self.move_error_reported.get(&move_out_indices) {"}, {"sha": "de27aec2b29902054420aae7cc6a8048d2b3e052", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -253,6 +253,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         move_error_reported: BTreeMap::new(),\n         uninitialized_error_reported: Default::default(),\n         errors_buffer,\n+        disable_error_downgrading: false,\n         nonlexical_regioncx: regioncx,\n         used_mut: Default::default(),\n         used_mut_upvars: SmallVec::new(),\n@@ -364,7 +365,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     if !mbcx.errors_buffer.is_empty() {\n         mbcx.errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n \n-        if tcx.migrate_borrowck() {\n+        if !mbcx.disable_error_downgrading && tcx.migrate_borrowck() {\n             // When borrowck=migrate, check if AST-borrowck would\n             // error on the given code.\n \n@@ -481,6 +482,9 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     uninitialized_error_reported: FxHashSet<PlaceRef<'cx, 'tcx>>,\n     /// Errors to be reported buffer\n     errors_buffer: Vec<Diagnostic>,\n+    /// If there are no errors reported by the HIR borrow checker, we downgrade\n+    /// all NLL errors to warnings. Setting this flag disables downgrading.\n+    disable_error_downgrading: bool,\n     /// This field keeps track of all the local variables that are declared mut and are mutated.\n     /// Used for the warning issued by an unused mutable local variable.\n     used_mut: FxHashSet<Local>,\n@@ -921,6 +925,12 @@ impl InitializationRequiringAction {\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n+    /// If there are no errors reported by the HIR borrow checker, we downgrade\n+    /// all NLL errors to warnings. Calling this disables downgrading.\n+    crate fn disable_error_downgrading(&mut self)  {\n+        self.disable_error_downgrading = true;\n+    }\n+\n     /// Checks an access to the given place to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n     /// place is initialized and (b) it is not borrowed in some way that would prevent this"}, {"sha": "fad9fafbb08037519360e105fb14e54260fa6a29", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -305,7 +305,7 @@ impl_stable_hash_for!(enum crate::interpret::eval_context::StackPopCleanup {\n #[derive(Eq, PartialEq)]\n struct FrameSnapshot<'a, 'tcx> {\n     instance: &'a ty::Instance<'tcx>,\n-    span: &'a Span,\n+    span: Span,\n     return_to_block: &'a StackPopCleanup,\n     return_place: Option<Place<(), AllocIdSnapshot<'a>>>,\n     locals: IndexVec<mir::Local, LocalValue<(), AllocIdSnapshot<'a>>>,\n@@ -345,7 +345,7 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n \n         FrameSnapshot {\n             instance,\n-            span,\n+            span: *span,\n             return_to_block,\n             block,\n             stmt: *stmt,"}, {"sha": "dcfc80968f31cbb5634d1f64c468676746e2db58", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -182,16 +182,17 @@ trait Qualif {\n \n     fn in_projection_structurally(\n         cx: &ConstCx<'_, 'tcx>,\n-        base: &PlaceBase<'tcx>,\n-        proj: &Projection<'tcx>,\n+        place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n+        let proj = place.projection.as_ref().unwrap();\n+\n         let base_qualif = Self::in_place(cx, PlaceRef {\n-            base,\n+            base: place.base,\n             projection: &proj.base,\n         });\n         let qualif = base_qualif && Self::mask_for_ty(\n             cx,\n-            Place::ty_from(&base, &proj.base, cx.body, cx.tcx)\n+            Place::ty_from(place.base, &proj.base, cx.body, cx.tcx)\n                 .projection_ty(cx.tcx, &proj.elem)\n                 .ty,\n         );\n@@ -208,10 +209,9 @@ trait Qualif {\n \n     fn in_projection(\n         cx: &ConstCx<'_, 'tcx>,\n-        base: &PlaceBase<'tcx>,\n-        proj: &Projection<'tcx>,\n+        place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n-        Self::in_projection_structurally(cx, base, proj)\n+        Self::in_projection_structurally(cx, place)\n     }\n \n     fn in_place(cx: &ConstCx<'_, 'tcx>, place: PlaceRef<'_, 'tcx>) -> bool {\n@@ -234,9 +234,9 @@ trait Qualif {\n                 Self::in_static(cx, static_)\n             },\n             PlaceRef {\n-                base,\n-                projection: Some(proj),\n-            } => Self::in_projection(cx, base, proj),\n+                base: _,\n+                projection: Some(_),\n+            } => Self::in_projection(cx, place),\n         }\n     }\n \n@@ -448,9 +448,10 @@ impl Qualif for IsNotPromotable {\n \n     fn in_projection(\n         cx: &ConstCx<'_, 'tcx>,\n-        base: &PlaceBase<'tcx>,\n-        proj: &Projection<'tcx>,\n+        place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n+        let proj = place.projection.as_ref().unwrap();\n+\n         match proj.elem {\n             ProjectionElem::Deref |\n             ProjectionElem::Downcast(..) => return true,\n@@ -461,7 +462,7 @@ impl Qualif for IsNotPromotable {\n \n             ProjectionElem::Field(..) => {\n                 if cx.mode == Mode::NonConstFn {\n-                    let base_ty = Place::ty_from(base, &proj.base, cx.body, cx.tcx).ty;\n+                    let base_ty = Place::ty_from(place.base, &proj.base, cx.body, cx.tcx).ty;\n                     if let Some(def) = base_ty.ty_adt_def() {\n                         // No promotion of union field accesses.\n                         if def.is_union() {\n@@ -472,7 +473,7 @@ impl Qualif for IsNotPromotable {\n             }\n         }\n \n-        Self::in_projection_structurally(cx, base, proj)\n+        Self::in_projection_structurally(cx, place)\n     }\n \n     fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {"}, {"sha": "1908d85e4ff2a561daf94ad90262e7c64e1f76ea", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -171,7 +171,7 @@ enum ResolutionError<'a> {\n     GenericParamsFromOuterFunction(Res),\n     /// Error E0403: the name is already used for a type or const parameter in this generic\n     /// parameter list.\n-    NameAlreadyUsedInParameterList(Name, &'a Span),\n+    NameAlreadyUsedInParameterList(Name, Span),\n     /// Error E0407: method is not a member of trait.\n     MethodNotMemberOfTrait(Name, &'a str),\n     /// Error E0437: type is not a member of trait.\n@@ -297,7 +297,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                                             parameter in this list of generic parameters\",\n                                             name);\n              err.span_label(span, \"already used\");\n-             err.span_label(first_use_span.clone(), format!(\"first use of `{}`\", name));\n+             err.span_label(first_use_span, format!(\"first use of `{}`\", name));\n              err\n         }\n         ResolutionError::MethodNotMemberOfTrait(method, trait_) => {\n@@ -2853,7 +2853,7 @@ impl<'a> Resolver<'a> {\n                                 let span = seen_bindings.get(&ident).unwrap();\n                                 let err = ResolutionError::NameAlreadyUsedInParameterList(\n                                     ident.name,\n-                                    span,\n+                                    *span,\n                                 );\n                                 resolve_error(self, param.ident.span, err);\n                             }\n@@ -2875,7 +2875,7 @@ impl<'a> Resolver<'a> {\n                                 let span = seen_bindings.get(&ident).unwrap();\n                                 let err = ResolutionError::NameAlreadyUsedInParameterList(\n                                     ident.name,\n-                                    span,\n+                                    *span,\n                                 );\n                                 resolve_error(self, param.ident.span, err);\n                             }"}, {"sha": "405144b444f09225b5eb5a09772b0b8a893aa20e", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -211,7 +211,6 @@ fn test_parse_ok() {\n fn test_parse_err() {\n     with_default_globals(|| {\n         let mi = attr::mk_name_value_item(\n-            DUMMY_SP,\n             Ident::from_str(\"foo\"),\n             LitKind::Bool(false),\n             DUMMY_SP,"}, {"sha": "5d86ee9721b75711aa73b12290c2493c15f82eac", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -44,7 +44,7 @@ pub fn render_with_highlighting(\n \n         let mut highlighted_source = vec![];\n         if classifier.write_source(&mut highlighted_source).is_err() {\n-            Err(classifier.lexer.buffer_fatal_errors())\n+            Err(())\n         } else {\n             Ok(String::from_utf8_lossy(&highlighted_source).into_owned())\n         }\n@@ -59,14 +59,9 @@ pub fn render_with_highlighting(\n             }\n             write_footer(&mut out).unwrap();\n         }\n-        Err(errors) => {\n-            // If errors are encountered while trying to highlight, cancel the errors and just emit\n-            // the unhighlighted source. The errors will have already been reported in the\n-            // `check-code-block-syntax` pass.\n-            for mut error in errors {\n-                error.cancel();\n-            }\n-\n+        Err(()) => {\n+            // If errors are encountered while trying to highlight, just emit\n+            // the unhighlighted source.\n             write!(out, \"<pre><code>{}</code></pre>\", src).unwrap();\n         }\n     }\n@@ -192,14 +187,20 @@ impl<'a> Classifier<'a> {\n         if let Some(token) = self.peek_token.take() {\n             return Ok(token);\n         }\n-        self.lexer.try_next_token().map_err(|()| HighlightError::LexError)\n+        let token = self.lexer.next_token();\n+        if let token::Unknown(..) = &token.kind {\n+            return Err(HighlightError::LexError);\n+        }\n+        Ok(token)\n     }\n \n     fn peek(&mut self) -> Result<&Token, HighlightError> {\n         if self.peek_token.is_none() {\n-            self.peek_token = Some(\n-                self.lexer.try_next_token().map_err(|()| HighlightError::LexError)?\n-            );\n+            let token = self.lexer.next_token();\n+            if let token::Unknown(..) = &token.kind {\n+                return Err(HighlightError::LexError);\n+            }\n+            self.peek_token = Some(token);\n         }\n         Ok(self.peek_token.as_ref().unwrap())\n     }\n@@ -237,7 +238,7 @@ impl<'a> Classifier<'a> {\n                 return Ok(());\n             },\n \n-            token::Whitespace => Class::None,\n+            token::Whitespace | token::Unknown(..) => Class::None,\n             token::Comment => Class::Comment,\n             token::DocComment(..) => Class::DocComment,\n "}, {"sha": "357e17d2d1bc46c4c97cb79576f1cb668efd6ea8", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -32,24 +32,20 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n             dox[code_block.code].to_owned(),\n         );\n \n-        let errors = {\n+        let has_errors = {\n+            let mut has_errors = false;\n             let mut lexer = Lexer::new(&sess, source_file, None);\n-            while let Ok(token::Token { kind, .. }) = lexer.try_next_token() {\n-                if kind == token::Eof {\n-                    break;\n+            loop  {\n+                match lexer.next_token().kind {\n+                    token::Eof => break,\n+                    token::Unknown(..) => has_errors = true,\n+                    _ => (),\n                 }\n             }\n-\n-            let errors = lexer.buffer_fatal_errors();\n-\n-            if !errors.is_empty() {\n-                Err(errors)\n-            } else {\n-                Ok(())\n-            }\n+            has_errors\n         };\n \n-        if let Err(errors) = errors {\n+        if has_errors {\n             let mut diag = if let Some(sp) =\n                 super::source_span_for_markdown_range(self.cx, &dox, &code_block.range, &item.attrs)\n             {\n@@ -58,11 +54,6 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n                     .sess()\n                     .struct_span_warn(sp, \"could not parse code block as Rust code\");\n \n-                for mut err in errors {\n-                    diag.note(&format!(\"error from rustc: {}\", err.message()));\n-                    err.cancel();\n-                }\n-\n                 if code_block.syntax.is_none() && code_block.is_fenced {\n                     let sp = sp.from_inner(InnerSpan::new(0, 3));\n                     diag.span_suggestion(\n@@ -82,11 +73,6 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n                     \"doc comment contains an invalid Rust code block\",\n                 );\n \n-                for mut err in errors {\n-                    // Don't bother reporting the error, because we can't show where it happened.\n-                    err.cancel();\n-                }\n-\n                 if code_block.syntax.is_none() && code_block.is_fenced {\n                     diag.help(\"mark blocks that do not contain Rust code as text: ```text\");\n                 }"}, {"sha": "56fde77daac5808a01926caed2bac9d60653d986", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -1819,6 +1819,8 @@ impl Path {\n     /// Yields a [`&str`] slice if the `Path` is valid unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n+    /// Note that validation is performed because non-UTF-8 strings are\n+    /// perfectly valid for some OS.\n     ///\n     /// [`&str`]: ../primitive.str.html\n     ///"}, {"sha": "052eb55b40811078994a4a3521f6bc155364ae0c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -1284,15 +1284,6 @@ pub enum Movability {\n     Movable,\n }\n \n-/// Whether an `await` comes from `await!` or `.await` syntax.\n-/// FIXME: this should be removed when support for legacy `await!` is removed.\n-/// https://github.com/rust-lang/rust/issues/60610\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n-pub enum AwaitOrigin {\n-    FieldLike,\n-    MacroLike,\n-}\n-\n pub type Mac = Spanned<Mac_>;\n \n /// Represents a macro invocation. The `Path` indicates which macro"}, {"sha": "a9d3227b3a8f40d5732445de148e5622a0894345", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -347,16 +347,17 @@ impl Attribute {\n \n pub fn mk_name_value_item_str(ident: Ident, value: Spanned<Symbol>) -> MetaItem {\n     let lit_kind = LitKind::Str(value.node, ast::StrStyle::Cooked);\n-    mk_name_value_item(ident.span.to(value.span), ident, lit_kind, value.span)\n+    mk_name_value_item(ident, lit_kind, value.span)\n }\n \n-pub fn mk_name_value_item(span: Span, ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n+pub fn mk_name_value_item(ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n     let lit = Lit::from_lit_kind(lit_kind, lit_span);\n+    let span = ident.span.to(lit_span);\n     MetaItem { path: Path::from_ident(ident), span, node: MetaItemKind::NameValue(lit) }\n }\n \n-pub fn mk_list_item(span: Span, ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span, node: MetaItemKind::List(items) }\n+pub fn mk_list_item(ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n+    MetaItem { path: Path::from_ident(ident), span: ident.span, node: MetaItemKind::List(items) }\n }\n \n pub fn mk_word_item(ident: Ident) -> MetaItem {\n@@ -367,7 +368,7 @@ pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n     NestedMetaItem::MetaItem(mk_word_item(ident))\n }\n \n-pub fn mk_attr_id() -> AttrId {\n+crate fn mk_attr_id() -> AttrId {\n     use std::sync::atomic::AtomicUsize;\n     use std::sync::atomic::Ordering;\n "}, {"sha": "db562840e8d3bae41f2d847803ec431ba7ecbd2e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -879,13 +879,12 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn meta_list(&self, sp: Span, name: ast::Name, mis: Vec<ast::NestedMetaItem>)\n                  -> ast::MetaItem {\n-        attr::mk_list_item(sp, Ident::new(name, sp), mis)\n+        attr::mk_list_item(Ident::new(name, sp), mis)\n     }\n \n     pub fn meta_name_value(&self, span: Span, name: ast::Name, lit_kind: ast::LitKind)\n                        -> ast::MetaItem {\n-        attr::mk_name_value_item(span, Ident::new(name, span),\n-                                 lit_kind, span)\n+        attr::mk_name_value_item(Ident::new(name, span), lit_kind, span)\n     }\n \n     pub fn item_use(&self, sp: Span,"}, {"sha": "964c81dd4664103743ca0cfd505acc6c3105acfa", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -1272,7 +1272,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                             ];\n \n                             let include_ident = Ident::with_empty_ctxt(sym::include);\n-                            let item = attr::mk_list_item(DUMMY_SP, include_ident, include_info);\n+                            let item = attr::mk_list_item(include_ident, include_info);\n                             items.push(ast::NestedMetaItem::MetaItem(item));\n                         }\n                         Err(e) => {\n@@ -1333,7 +1333,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 }\n             }\n \n-            let meta = attr::mk_list_item(DUMMY_SP, Ident::with_empty_ctxt(sym::doc), items);\n+            let meta = attr::mk_list_item(Ident::with_empty_ctxt(sym::doc), items);\n             *at = attr::Attribute {\n                 span: at.span,\n                 id: at.id,"}, {"sha": "36621ce7775107d77a76790c2a1d28f4099c8b9b", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -184,7 +184,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n             }\n \n             OpenDelim(..) | CloseDelim(..) => unreachable!(),\n-            Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n+            Whitespace | Comment | Shebang(..) | Unknown(..) | Eof => unreachable!(),\n         }\n     }\n }"}, {"sha": "e86d4c7fde683f39e6ba394e2f70a2deeb43db0b", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 13, "deletions": 60, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -3,7 +3,7 @@ use crate::parse::token::{self, Token, TokenKind};\n use crate::symbol::{sym, Symbol};\n use crate::parse::unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n-use errors::{FatalError, Diagnostic, DiagnosticBuilder};\n+use errors::{FatalError, DiagnosticBuilder};\n use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION};\n use rustc_lexer::Base;\n use rustc_lexer::unescape;\n@@ -39,7 +39,6 @@ pub struct StringReader<'a> {\n     pos: BytePos,\n     /// Stop reading src at this index.\n     end_src_index: usize,\n-    fatal_errs: Vec<DiagnosticBuilder<'a>>,\n     /// Source text to tokenize.\n     src: Lrc<String>,\n     override_span: Option<Span>,\n@@ -62,7 +61,6 @@ impl<'a> StringReader<'a> {\n             pos: source_file.start_pos,\n             end_src_index: src.len(),\n             src,\n-            fatal_errs: Vec::new(),\n             override_span,\n         }\n     }\n@@ -89,29 +87,17 @@ impl<'a> StringReader<'a> {\n         self.override_span.unwrap_or_else(|| Span::new(lo, hi, NO_EXPANSION))\n     }\n \n-    fn unwrap_or_abort(&mut self, res: Result<Token, ()>) -> Token {\n-        match res {\n-            Ok(tok) => tok,\n-            Err(_) => {\n-                self.emit_fatal_errors();\n-                FatalError.raise();\n-            }\n-        }\n-    }\n-\n     /// Returns the next token, including trivia like whitespace or comments.\n     ///\n     /// `Err(())` means that some errors were encountered, which can be\n     /// retrieved using `buffer_fatal_errors`.\n-    pub fn try_next_token(&mut self) -> Result<Token, ()> {\n-        assert!(self.fatal_errs.is_empty());\n-\n+    pub fn next_token(&mut self) -> Token {\n         let start_src_index = self.src_index(self.pos);\n         let text: &str = &self.src[start_src_index..self.end_src_index];\n \n         if text.is_empty() {\n             let span = self.mk_sp(self.pos, self.pos);\n-            return Ok(Token::new(token::Eof, span));\n+            return Token::new(token::Eof, span);\n         }\n \n         {\n@@ -125,7 +111,7 @@ impl<'a> StringReader<'a> {\n                     let kind = token::Shebang(sym);\n \n                     let span = self.mk_sp(start, self.pos);\n-                    return Ok(Token::new(kind, span));\n+                    return Token::new(kind, span);\n                 }\n             }\n         }\n@@ -139,39 +125,10 @@ impl<'a> StringReader<'a> {\n \n         // This could use `?`, but that makes code significantly (10-20%) slower.\n         // https://github.com/rust-lang/rust/issues/37939\n-        let kind = match self.cook_lexer_token(token.kind, start) {\n-            Ok(it) => it,\n-            Err(err) => return Err(self.fatal_errs.push(err)),\n-        };\n+        let kind = self.cook_lexer_token(token.kind, start);\n \n         let span = self.mk_sp(start, self.pos);\n-        Ok(Token::new(kind, span))\n-    }\n-\n-    /// Returns the next token, including trivia like whitespace or comments.\n-    ///\n-    /// Aborts in case of an error.\n-    pub fn next_token(&mut self) -> Token {\n-        let res = self.try_next_token();\n-        self.unwrap_or_abort(res)\n-    }\n-\n-    fn emit_fatal_errors(&mut self) {\n-        for err in &mut self.fatal_errs {\n-            err.emit();\n-        }\n-\n-        self.fatal_errs.clear();\n-    }\n-\n-    pub fn buffer_fatal_errors(&mut self) -> Vec<Diagnostic> {\n-        let mut buffer = Vec::new();\n-\n-        for err in self.fatal_errs.drain(..) {\n-            err.buffer(&mut buffer);\n-        }\n-\n-        buffer\n+        Token::new(kind, span)\n     }\n \n     /// Report a fatal lexical error with a given span.\n@@ -218,8 +175,8 @@ impl<'a> StringReader<'a> {\n         &self,\n         token: rustc_lexer::TokenKind,\n         start: BytePos,\n-    ) -> Result<TokenKind, DiagnosticBuilder<'a>> {\n-        let kind = match token {\n+    ) -> TokenKind {\n+        match token {\n             rustc_lexer::TokenKind::LineComment => {\n                 let string = self.str_from(start);\n                 // comments with only more \"/\"s are not doc comments\n@@ -396,16 +353,12 @@ impl<'a> StringReader<'a> {\n                 // this should be inside `rustc_lexer`. However, we should first remove compound\n                 // tokens like `<<` from `rustc_lexer`, and then add fancier error recovery to it,\n                 // as there will be less overall work to do this way.\n-                return match unicode_chars::check_for_substitution(self, start, c, &mut err) {\n-                    Some(token) => {\n-                        err.emit();\n-                        Ok(token)\n-                    }\n-                    None => Err(err),\n-                }\n+                let token = unicode_chars::check_for_substitution(self, start, c, &mut err)\n+                    .unwrap_or_else(|| token::Unknown(self.symbol_from(start)));\n+                err.emit();\n+                token\n             }\n-        };\n-        Ok(kind)\n+        }\n     }\n \n     fn cook_lexer_literal("}, {"sha": "37e67a2729e6d36ac904727bb5ea7f6b4724689e", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -217,7 +217,7 @@ impl<'a> TokenTreesReader<'a> {\n         loop {\n             let token = self.string_reader.next_token();\n             match token.kind {\n-                token::Whitespace | token::Comment | token::Shebang(_) => {\n+                token::Whitespace | token::Comment | token::Shebang(_) | token::Unknown(_) => {\n                     self.joint_to_prev = NonJoint;\n                 }\n                 _ => {"}, {"sha": "be800b4de66aff2153ec99c7fb06ef92473ceaf2", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -255,6 +255,8 @@ pub enum TokenKind {\n     /// A comment.\n     Comment,\n     Shebang(ast::Name),\n+    /// A completely invalid token which should be skipped.\n+    Unknown(ast::Name),\n \n     Eof,\n }\n@@ -603,7 +605,7 @@ impl Token {\n             DotDotEq | Comma | Semi | ModSep | RArrow | LArrow | FatArrow | Pound | Dollar |\n             Question | OpenDelim(..) | CloseDelim(..) |\n             Literal(..) | Ident(..) | Lifetime(..) | Interpolated(..) | DocComment(..) |\n-            Whitespace | Comment | Shebang(..) | Eof => return None,\n+            Whitespace | Comment | Shebang(..) | Unknown(..) | Eof => return None,\n         };\n \n         Some(Token::new(kind, self.span.to(joint.span)))"}, {"sha": "bda761244d5ca09d4cac7ed844852a4f8162eaff", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -15,7 +15,7 @@ use crate::tokenstream::{self, TokenStream, TokenTree};\n \n use rustc_target::spec::abi::{self, Abi};\n use syntax_pos::{self, BytePos};\n-use syntax_pos::{DUMMY_SP, FileName, Span};\n+use syntax_pos::{FileName, Span};\n \n use std::borrow::Cow;\n \n@@ -124,8 +124,7 @@ pub fn print_crate<'a>(cm: &'a SourceMap,\n \n         // #![feature(prelude_import)]\n         let pi_nested = attr::mk_nested_word_item(ast::Ident::with_empty_ctxt(sym::prelude_import));\n-        let list = attr::mk_list_item(\n-            DUMMY_SP, ast::Ident::with_empty_ctxt(sym::feature), vec![pi_nested]);\n+        let list = attr::mk_list_item(ast::Ident::with_empty_ctxt(sym::feature), vec![pi_nested]);\n         let fake_attr = attr::mk_attr_inner(list);\n         s.print_attribute(&fake_attr);\n \n@@ -288,6 +287,7 @@ fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>)\n         token::Whitespace           => \" \".to_string(),\n         token::Comment              => \"/* */\".to_string(),\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s),\n+        token::Unknown(s)           => s.to_string(),\n \n         token::Interpolated(ref nt) => nonterminal_to_string(nt),\n     }"}, {"sha": "eec8a3f802343f9a286a5ae65148218e86603f1b", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -157,8 +157,7 @@ impl MutVisitor for EntryPointCleaner {\n                 item.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n                     let allow_ident = Ident::with_empty_ctxt(sym::allow);\n                     let dc_nested = attr::mk_nested_word_item(Ident::from_str(\"dead_code\"));\n-                    let allow_dead_code_item = attr::mk_list_item(DUMMY_SP, allow_ident,\n-                                                                  vec![dc_nested]);\n+                    let allow_dead_code_item = attr::mk_list_item(allow_ident, vec![dc_nested]);\n                     let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n \n                     ast::Item {"}, {"sha": "3f47ca834cda6ba37e2f194ff0557a0385766b70", "filename": "src/test/COMPILER_TESTS.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2FCOMPILER_TESTS.md", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2FCOMPILER_TESTS.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2FCOMPILER_TESTS.md?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -1,4 +1,4 @@\n # Compiler Test Documentation\n \n-Documentation the compiler testing framework has moved to\n+Documentation for the compiler testing framework can be found in\n [the rustc guide](https://rust-lang.github.io/rustc-guide/tests/intro.html)."}, {"sha": "3bebbecb9dfcf5ad196f5a19657d24c8260fb637", "filename": "src/test/rustdoc-ui/invalid-syntax.stderr", "status": "modified", "additions": 154, "deletions": 14, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -1,3 +1,21 @@\n+error: unknown start of token: \\\n+ --> <doctest>:1:1\n+  |\n+1 | \\__________pkt->size___________/          \\_result->size_/ \\__pkt->size__/\n+  | ^\n+\n+error: unknown start of token: \\\n+ --> <doctest>:1:43\n+  |\n+1 | \\__________pkt->size___________/          \\_result->size_/ \\__pkt->size__/\n+  |                                           ^\n+\n+error: unknown start of token: \\\n+ --> <doctest>:1:60\n+  |\n+1 | \\__________pkt->size___________/          \\_result->size_/ \\__pkt->size__/\n+  |                                                            ^\n+\n warning: could not parse code block as Rust code\n   --> $DIR/invalid-syntax.rs:3:5\n    |\n@@ -6,13 +24,31 @@ LL |   /// ```\n LL | | /// \\__________pkt->size___________/          \\_result->size_/ \\__pkt->size__/\n LL | | /// ```\n    | |_______^\n-   |\n-   = note: error from rustc: unknown start of token: \\\n help: mark blocks that do not contain Rust code as text\n    |\n LL | /// ```text\n    |     ^^^^^^^\n \n+error: unknown start of token: `\n+ --> <doctest>:3:30\n+  |\n+3 |    |     ^^^^^^ did you mean `baz::foobar`?\n+  |                              ^\n+help: Unicode character '`' (Grave Accent) looks like ''' (Single Quote), but it is not\n+  |\n+3 |    |     ^^^^^^ did you mean 'baz::foobar`?\n+  |                              ^\n+\n+error: unknown start of token: `\n+ --> <doctest>:3:42\n+  |\n+3 |    |     ^^^^^^ did you mean `baz::foobar`?\n+  |                                          ^\n+help: Unicode character '`' (Grave Accent) looks like ''' (Single Quote), but it is not\n+  |\n+3 |    |     ^^^^^^ did you mean `baz::foobar'?\n+  |                                          ^\n+\n warning: could not parse code block as Rust code\n   --> $DIR/invalid-syntax.rs:8:5\n    |\n@@ -23,13 +59,17 @@ LL | | /// LL | use foobar::Baz;\n LL | | ///    |     ^^^^^^ did you mean `baz::foobar`?\n LL | | /// ```\n    | |_______^\n-   |\n-   = note: error from rustc: unknown start of token: `\n help: mark blocks that do not contain Rust code as text\n    |\n LL | /// ```text\n    |     ^^^^^^^\n \n+error: unknown start of token: \\\n+ --> <doctest>:1:1\n+  |\n+1 | \\_\n+  | ^\n+\n warning: could not parse code block as Rust code\n   --> $DIR/invalid-syntax.rs:19:5\n    |\n@@ -38,13 +78,17 @@ LL |   /// ```\n LL | | /// \\_\n LL | | /// ```\n    | |_______^\n-   |\n-   = note: error from rustc: unknown start of token: \\\n help: mark blocks that do not contain Rust code as text\n    |\n LL | /// ```text\n    |     ^^^^^^^\n \n+error: unknown start of token: \\\n+ --> <doctest>:1:1\n+  |\n+1 | \\_\n+  | ^\n+\n warning: could not parse code block as Rust code\n   --> $DIR/invalid-syntax.rs:32:5\n    |\n@@ -53,8 +97,12 @@ LL |   /// ```rust\n LL | | /// \\_\n LL | | /// ```\n    | |_______^\n-   |\n-   = note: error from rustc: unknown start of token: \\\n+\n+error: unknown start of token: \\\n+ --> <doctest>:2:5\n+  |\n+2 |     \\_\n+  |     ^\n \n warning: could not parse code block as Rust code\n   --> $DIR/invalid-syntax.rs:41:9\n@@ -63,16 +111,48 @@ LL |   ///     code with bad syntax\n    |  _________^\n LL | | ///     \\_\n    | |__________^\n-   |\n-   = note: error from rustc: unknown start of token: \\\n+\n+error: unknown start of token: `\n+ --> <doctest>:1:1\n+  |\n+1 | ```\n+  | ^\n+help: Unicode character '`' (Grave Accent) looks like ''' (Single Quote), but it is not\n+  |\n+1 | '``\n+  | ^\n+\n+error: unknown start of token: `\n+ --> <doctest>:1:2\n+  |\n+1 | ```\n+  |  ^\n+help: Unicode character '`' (Grave Accent) looks like ''' (Single Quote), but it is not\n+  |\n+1 | `'`\n+  |  ^\n+\n+error: unknown start of token: `\n+ --> <doctest>:1:3\n+  |\n+1 | ```\n+  |   ^\n+help: Unicode character '`' (Grave Accent) looks like ''' (Single Quote), but it is not\n+  |\n+1 | ``'\n+  |   ^\n \n warning: could not parse code block as Rust code\n   --> $DIR/invalid-syntax.rs:55:9\n    |\n LL | ///     ```\n    |         ^^^\n-   |\n-   = note: error from rustc: unknown start of token: `\n+\n+error: unknown start of token: \\\n+ --> <doctest>:1:1\n+  |\n+1 | \\_\n+  | ^\n \n warning: could not parse code block as Rust code\n   --> $DIR/invalid-syntax.rs:58:5\n@@ -82,8 +162,12 @@ LL |   /// ```edition2018\n LL | | /// \\_\n LL | | /// ```\n    | |_______^\n-   |\n-   = note: error from rustc: unknown start of token: \\\n+\n+error: unknown start of token: \\\n+ --> <doctest>:1:1\n+  |\n+1 | \\_\n+  | ^\n \n warning: doc comment contains an invalid Rust code block\n   --> $DIR/invalid-syntax.rs:63:1\n@@ -95,3 +179,59 @@ LL | | #[doc = \"```\"]\n    |\n    = help: mark blocks that do not contain Rust code as text: ```text\n \n+error: unknown start of token: \\\n+ --> <rustdoc-highlighting>:1:1\n+  |\n+1 | \\_\n+  | ^\n+\n+error: unknown start of token: \\\n+ --> <rustdoc-highlighting>:1:1\n+  |\n+1 | \\_\n+  | ^\n+\n+error: unknown start of token: `\n+ --> <rustdoc-highlighting>:1:1\n+  |\n+1 | ```\n+  | ^\n+help: Unicode character '`' (Grave Accent) looks like ''' (Single Quote), but it is not\n+  |\n+1 | '``\n+  | ^\n+\n+error: unknown start of token: \\\n+ --> <rustdoc-highlighting>:2:1\n+  |\n+2 | \\_\n+  | ^\n+\n+error: unknown start of token: \\\n+ --> <rustdoc-highlighting>:1:1\n+  |\n+1 | \\_\n+  | ^\n+\n+error: unknown start of token: \\\n+ --> <rustdoc-highlighting>:1:1\n+  |\n+1 | \\_\n+  | ^\n+\n+error: unknown start of token: `\n+ --> <rustdoc-highlighting>:3:30\n+  |\n+3 |    |     ^^^^^^ did you mean `baz::foobar`?\n+  |                              ^\n+help: Unicode character '`' (Grave Accent) looks like ''' (Single Quote), but it is not\n+  |\n+3 |    |     ^^^^^^ did you mean 'baz::foobar`?\n+  |                              ^\n+\n+error: unknown start of token: \\\n+ --> <rustdoc-highlighting>:1:1\n+  |\n+1 | \\__________pkt->size___________/          \\_result->size_/ \\__pkt->size__/\n+  | ^\n+"}, {"sha": "40f9f5202e77c5760da4943fd6df8b261a8c56f5", "filename": "src/test/ui/async-await/partial-initialization-across-await.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -0,0 +1,44 @@\n+// Test that we don't allow awaiting from an async fn while a local is partially\n+// initialized.\n+\n+// edition:2018\n+\n+#![feature(async_await)]\n+\n+struct S { x: i32, y: i32 }\n+struct T(i32, i32);\n+\n+async fn noop() {}\n+\n+async fn test_tuple() {\n+    let mut t: (i32, i32);\n+    t.0 = 42;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+    noop().await;\n+    t.1 = 88;\n+    let _ = t;\n+}\n+\n+async fn test_tuple_struct() {\n+    let mut t: T;\n+    t.0 = 42;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+    noop().await;\n+    t.1 = 88;\n+    let _ = t;\n+}\n+\n+async fn test_struct() {\n+    let mut t: S;\n+    t.x = 42;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+    noop().await;\n+    t.y = 88;\n+    let _ = t;\n+}\n+\n+fn main() {\n+    let _ = test_tuple();\n+    let _ = test_tuple_struct();\n+    let _ = test_struct();\n+}"}, {"sha": "fe79eb08befaa5458fe642398b3d2a7ce735ec6d", "filename": "src/test/ui/async-await/partial-initialization-across-await.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-initialization-across-await.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -0,0 +1,21 @@\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/partial-initialization-across-await.rs:15:5\n+   |\n+LL |     t.0 = 42;\n+   |     ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/partial-initialization-across-await.rs:24:5\n+   |\n+LL |     t.0 = 42;\n+   |     ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/partial-initialization-across-await.rs:33:5\n+   |\n+LL |     t.x = 42;\n+   |     ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "a987c00b091914f21a347be6c78bd96a52d2d8df", "filename": "src/test/ui/borrowck/disallow-possibly-uninitialized.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fborrowck%2Fdisallow-possibly-uninitialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fborrowck%2Fdisallow-possibly-uninitialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fdisallow-possibly-uninitialized.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -0,0 +1,22 @@\n+// Test that we don't allow partial initialization.\n+// This may be relaxed in the future (see #54987).\n+\n+fn main() {\n+    let mut t: (u64, u64);\n+    t.0 = 1;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+    t.1 = 1;\n+\n+    let mut t: (u64, u64);\n+    t.1 = 1;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+    t.0 = 1;\n+\n+    let mut t: (u64, u64);\n+    t.0 = 1;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+\n+    let mut t: (u64,);\n+    t.0 = 1;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+}"}, {"sha": "a32b17b165934f1f574c4b5f21a0ba2b9bb9f249", "filename": "src/test/ui/borrowck/disallow-possibly-uninitialized.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fborrowck%2Fdisallow-possibly-uninitialized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fborrowck%2Fdisallow-possibly-uninitialized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fdisallow-possibly-uninitialized.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -0,0 +1,27 @@\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/disallow-possibly-uninitialized.rs:6:5\n+   |\n+LL |     t.0 = 1;\n+   |     ^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/disallow-possibly-uninitialized.rs:11:5\n+   |\n+LL |     t.1 = 1;\n+   |     ^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/disallow-possibly-uninitialized.rs:16:5\n+   |\n+LL |     t.0 = 1;\n+   |     ^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/disallow-possibly-uninitialized.rs:20:5\n+   |\n+LL |     t.0 = 1;\n+   |     ^^^^^^^ use of possibly uninitialized `t`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "6c3484c2d8c4df3ca0ac3d9deee704c982ea70dc", "filename": "src/test/ui/coherence/coherence-overlap-upstream.old.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.old.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -5,6 +5,8 @@ LL | impl<T> Foo for T where T: Remote {}\n    | --------------------------------- first implementation here\n LL | impl Foo for i16 {}\n    | ^^^^^^^^^^^^^^^^ conflicting implementation for `i16`\n+   |\n+   = note: upstream crates may add new impl of trait `coherence_lib::Remote` for type `i16` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "6c3484c2d8c4df3ca0ac3d9deee704c982ea70dc", "filename": "src/test/ui/coherence/coherence-overlap-upstream.re.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-upstream.re.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -5,6 +5,8 @@ LL | impl<T> Foo for T where T: Remote {}\n    | --------------------------------- first implementation here\n LL | impl Foo for i16 {}\n    | ^^^^^^^^^^^^^^^^ conflicting implementation for `i16`\n+   |\n+   = note: upstream crates may add new impl of trait `coherence_lib::Remote` for type `i16` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "12c7a1f977c3fefdd878d8b73309af7ee6b1077a", "filename": "src/test/ui/coherence/coherence_copy_like_err_fundamental_struct_tuple.old.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.old.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -6,6 +6,8 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n ...\n LL | impl MyTrait for lib::MyFundamentalStruct<(MyType,)> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `lib::MyFundamentalStruct<(MyType,)>`\n+   |\n+   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `lib::MyFundamentalStruct<(MyType,)>` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "12c7a1f977c3fefdd878d8b73309af7ee6b1077a", "filename": "src/test/ui/coherence/coherence_copy_like_err_fundamental_struct_tuple.re.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_fundamental_struct_tuple.re.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -6,6 +6,8 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n ...\n LL | impl MyTrait for lib::MyFundamentalStruct<(MyType,)> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `lib::MyFundamentalStruct<(MyType,)>`\n+   |\n+   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `lib::MyFundamentalStruct<(MyType,)>` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "1b6c62e9bf3a802b7c21b36102200be6eec0d172", "filename": "src/test/ui/coherence/coherence_copy_like_err_struct.old.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.old.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -6,6 +6,8 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n ...\n LL | impl MyTrait for lib::MyStruct<MyType> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `lib::MyStruct<MyType>`\n+   |\n+   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `lib::MyStruct<MyType>` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "1b6c62e9bf3a802b7c21b36102200be6eec0d172", "filename": "src/test/ui/coherence/coherence_copy_like_err_struct.re.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_struct.re.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -6,6 +6,8 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n ...\n LL | impl MyTrait for lib::MyStruct<MyType> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `lib::MyStruct<MyType>`\n+   |\n+   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `lib::MyStruct<MyType>` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "11bd788c761530cdedc7182762d1d4414e167a1e", "filename": "src/test/ui/coherence/coherence_copy_like_err_tuple.old.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.old.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -6,6 +6,8 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n ...\n LL | impl MyTrait for (MyType,) { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(MyType,)`\n+   |\n+   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `(MyType,)` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "11bd788c761530cdedc7182762d1d4414e167a1e", "filename": "src/test/ui/coherence/coherence_copy_like_err_tuple.re.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence_copy_like_err_tuple.re.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -6,6 +6,8 @@ LL | impl<T: lib::MyCopy> MyTrait for T { }\n ...\n LL | impl MyTrait for (MyType,) { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(MyType,)`\n+   |\n+   = note: upstream crates may add new impl of trait `lib::MyCopy` for type `(MyType,)` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "a61c9b0c9fef9995daa1542852cf39603ac42417", "filename": "src/test/ui/consts/const_let_refutable.nll.stderr", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.nll.stderr?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -1,31 +0,0 @@\n-error[E0005]: refutable pattern in function argument: `&[]` not covered\n-  --> $DIR/const_let_refutable.rs:3:16\n-   |\n-LL | const fn slice([a, b]: &[i32]) -> i32 {\n-   |                ^^^^^^ pattern `&[]` not covered\n-\n-error[E0723]: can only call other `const fn` within a `const fn`, but `const <&i32 as std::ops::Add>::add` is not stable as `const fn`\n-  --> $DIR/const_let_refutable.rs:4:5\n-   |\n-LL |     a + b\n-   |     ^^^^^\n-   |\n-   = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n-\n-error[E0381]: use of possibly uninitialized variable: `a`\n-  --> $DIR/const_let_refutable.rs:4:5\n-   |\n-LL |     a + b\n-   |     ^ use of possibly uninitialized `a`\n-\n-error[E0381]: use of possibly uninitialized variable: `b`\n-  --> $DIR/const_let_refutable.rs:4:9\n-   |\n-LL |     a + b\n-   |         ^ use of possibly uninitialized `b`\n-\n-error: aborting due to 4 previous errors\n-\n-Some errors have detailed explanations: E0005, E0381, E0723.\n-For more information about an error, try `rustc --explain E0005`."}, {"sha": "7b3a591223025b85538db8d8f7e44d4646749370", "filename": "src/test/ui/consts/const_let_refutable.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -2,10 +2,6 @@ fn main() {}\n \n const fn slice([a, b]: &[i32]) -> i32 { //~ ERROR refutable pattern in function argument\n     a + b //~ ERROR can only call other `const fn` within a `const fn`\n-    //~^ WARN use of possibly uninitialized variable: `a`\n-    //~| WARN this error has been downgraded to a warning for backwards compatibility\n-    //~| WARN this represents potential undefined behavior in your code and this warning will\n-    //~| WARN use of possibly uninitialized variable: `b`\n-    //~| WARN this error has been downgraded to a warning for backwards compatibility\n-    //~| WARN this represents potential undefined behavior in your code and this warning will\n+    //~^ ERROR use of possibly uninitialized variable: `a`\n+    //~| ERROR use of possibly uninitialized variable: `b`\n }"}, {"sha": "a61c9b0c9fef9995daa1542852cf39603ac42417", "filename": "src/test/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -13,27 +13,19 @@ LL |     a + b\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-warning[E0381]: use of possibly uninitialized variable: `a`\n+error[E0381]: use of possibly uninitialized variable: `a`\n   --> $DIR/const_let_refutable.rs:4:5\n    |\n LL |     a + b\n    |     ^ use of possibly uninitialized `a`\n-   |\n-   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n-   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n-   = note: for more information, try `rustc --explain E0729`\n \n-warning[E0381]: use of possibly uninitialized variable: `b`\n+error[E0381]: use of possibly uninitialized variable: `b`\n   --> $DIR/const_let_refutable.rs:4:9\n    |\n LL |     a + b\n    |         ^ use of possibly uninitialized `b`\n-   |\n-   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n-   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n-   = note: for more information, try `rustc --explain E0729`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0005, E0381, E0723.\n For more information about an error, try `rustc --explain E0005`."}, {"sha": "01ee1c3a4d7fadbf7ec17219fcf79cff4a67648b", "filename": "src/test/ui/empty/empty-never-array.nll.stderr", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.nll.stderr?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -1,23 +0,0 @@\n-error[E0005]: refutable pattern in local binding: `T(_, _)` not covered\n-  --> $DIR/empty-never-array.rs:10:9\n-   |\n-LL | / enum Helper<T, U> {\n-LL | |     T(T, [!; 0]),\n-LL | |     #[allow(dead_code)]\n-LL | |     U(U),\n-LL | | }\n-   | |_- `Helper<T, U>` defined here\n-...\n-LL |       let Helper::U(u) = Helper::T(t, []);\n-   |           ^^^^^^^^^^^^ pattern `T(_, _)` not covered\n-\n-error[E0381]: use of possibly uninitialized variable: `u`\n-  --> $DIR/empty-never-array.rs:12:5\n-   |\n-LL |     u\n-   |     ^ use of possibly uninitialized `u`\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0005, E0381.\n-For more information about an error, try `rustc --explain E0005`."}, {"sha": "ffd2545b291e269b561ad8a3f766128cd8659e4a", "filename": "src/test/ui/empty/empty-never-array.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -10,9 +10,7 @@ fn transmute<T, U>(t: T) -> U {\n     let Helper::U(u) = Helper::T(t, []);\n     //~^ ERROR refutable pattern in local binding: `T(_, _)` not covered\n     u\n-    //~^ WARN use of possibly uninitialized variable: `u`\n-    //~| WARN this error has been downgraded to a warning for backwards compatibility\n-    //~| WARN this represents potential undefined behavior in your code and this warning will\n+    //~^ ERROR use of possibly uninitialized variable: `u`\n }\n \n fn main() {"}, {"sha": "01ee1c3a4d7fadbf7ec17219fcf79cff4a67648b", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -11,17 +11,13 @@ LL | | }\n LL |       let Helper::U(u) = Helper::T(t, []);\n    |           ^^^^^^^^^^^^ pattern `T(_, _)` not covered\n \n-warning[E0381]: use of possibly uninitialized variable: `u`\n+error[E0381]: use of possibly uninitialized variable: `u`\n   --> $DIR/empty-never-array.rs:12:5\n    |\n LL |     u\n    |     ^ use of possibly uninitialized `u`\n-   |\n-   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n-   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n-   = note: for more information, try `rustc --explain E0729`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0005, E0381.\n For more information about an error, try `rustc --explain E0005`."}, {"sha": "1e4593002cb9a0b09c28661c0e54d9d1aa2ad5db", "filename": "src/test/ui/generator/partial-initialization-across-yield.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fgenerator%2Fpartial-initialization-across-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fgenerator%2Fpartial-initialization-across-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpartial-initialization-across-yield.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -0,0 +1,46 @@\n+// Test that we don't allow yielding from a generator while a local is partially\n+// initialized.\n+\n+#![feature(generators)]\n+\n+struct S { x: i32, y: i32 }\n+struct T(i32, i32);\n+\n+fn test_tuple() {\n+    let _ = || {\n+        let mut t: (i32, i32);\n+        t.0 = 42;\n+        //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+        yield;\n+        t.1 = 88;\n+        let _ = t;\n+    };\n+}\n+\n+fn test_tuple_struct() {\n+    let _ = || {\n+        let mut t: T;\n+        t.0 = 42;\n+        //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+        yield;\n+        t.1 = 88;\n+        let _ = t;\n+    };\n+}\n+\n+fn test_struct() {\n+    let _ = || {\n+        let mut t: S;\n+        t.x = 42;\n+        //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+        yield;\n+        t.y = 88;\n+        let _ = t;\n+    };\n+}\n+\n+fn main() {\n+    test_tuple();\n+    test_tuple_struct();\n+    test_struct();\n+}"}, {"sha": "8bf0037e0700946f1e4f14b7fb4716663b17fcbb", "filename": "src/test/ui/generator/partial-initialization-across-yield.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fgenerator%2Fpartial-initialization-across-yield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fgenerator%2Fpartial-initialization-across-yield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpartial-initialization-across-yield.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -0,0 +1,21 @@\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/partial-initialization-across-yield.rs:12:9\n+   |\n+LL |         t.0 = 42;\n+   |         ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/partial-initialization-across-yield.rs:23:9\n+   |\n+LL |         t.0 = 42;\n+   |         ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/partial-initialization-across-yield.rs:34:9\n+   |\n+LL |         t.x = 42;\n+   |         ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "a8495846b3610e544fd318ae296de9c89e3e4c8a", "filename": "src/test/ui/issues/issue-15381.nll.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Ftest%2Fui%2Fissues%2Fissue-15381.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Ftest%2Fui%2Fissues%2Fissue-15381.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15381.nll.stderr?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -1,16 +0,0 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&[]` not covered\n-  --> $DIR/issue-15381.rs:4:9\n-   |\n-LL |     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n-   |         ^^^^^^^^ pattern `&[]` not covered\n-\n-error[E0381]: borrow of possibly uninitialized variable: `y`\n-  --> $DIR/issue-15381.rs:6:26\n-   |\n-LL |         println!(\"y={}\", y);\n-   |                          ^ use of possibly uninitialized `y`\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0005, E0381.\n-For more information about an error, try `rustc --explain E0005`."}, {"sha": "d21c321b09399a79e9d7f5f365ccc3cb3db92fb4", "filename": "src/test/ui/issues/issue-15381.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -4,8 +4,6 @@ fn main() {\n     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n         //~^ ERROR refutable pattern in `for` loop binding: `&[]` not covered\n         println!(\"y={}\", y);\n-        //~^ WARN borrow of possibly uninitialized variable: `y`\n-        //~| WARN this error has been downgraded to a warning for backwards compatibility\n-        //~| WARN this represents potential undefined behavior in your code and this warning will\n+        //~^ ERROR borrow of possibly uninitialized variable: `y`\n     }\n }"}, {"sha": "a8495846b3610e544fd318ae296de9c89e3e4c8a", "filename": "src/test/ui/issues/issue-15381.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -4,17 +4,13 @@ error[E0005]: refutable pattern in `for` loop binding: `&[]` not covered\n LL |     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n    |         ^^^^^^^^ pattern `&[]` not covered\n \n-warning[E0381]: borrow of possibly uninitialized variable: `y`\n+error[E0381]: borrow of possibly uninitialized variable: `y`\n   --> $DIR/issue-15381.rs:6:26\n    |\n LL |         println!(\"y={}\", y);\n    |                          ^ use of possibly uninitialized `y`\n-   |\n-   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n-   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n-   = note: for more information, try `rustc --explain E0729`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0005, E0381.\n For more information about an error, try `rustc --explain E0005`."}, {"sha": "99a9bf9903e25702deef4acc6f25d4550ccf61af", "filename": "src/test/ui/issues/issue-48728.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fissues%2Fissue-48728.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fissues%2Fissue-48728.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-48728.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -6,6 +6,8 @@ LL | #[derive(Clone)]\n ...\n LL | impl<T: Clone + ?Sized> Clone for Node<[T]> {\n    | ------------------------------------------- first implementation here\n+   |\n+   = note: upstream crates may add new impl of trait `std::clone::Clone` for type `[_]` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "9e4824611128d1d64fdc4234da5716a7758af2e5", "filename": "src/test/ui/parser/lex-bad-token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fparser%2Flex-bad-token.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fparser%2Flex-bad-token.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-token.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -1 +1,3 @@\n \u25cf //~ ERROR: unknown start of token\n+\n+fn main() {}"}, {"sha": "bb27f44c279f7ccf4c903c8f5e82a29e20b937b5", "filename": "src/test/ui/parser/lex-stray-backslash.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fparser%2Flex-stray-backslash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fparser%2Flex-stray-backslash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-stray-backslash.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -1 +1,3 @@\n \\ //~ ERROR: unknown start of token: \\\n+\n+fn main() {}"}, {"sha": "1812dad81afc34b92c0f1a998d8447e86be5ba9c", "filename": "src/test/ui/parser/unicode-quote-chars.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -4,4 +4,7 @@ fn main() {\n     println!(\u201chello world\u201d);\n     //~^ ERROR unknown start of token: \\u{201c}\n     //~^^ HELP Unicode characters '\u201c' (Left Double Quotation Mark) and '\u201d' (Right Double Quotation Mark) look like '\"' (Quotation Mark), but are not\n+    //~^^^ ERROR unknown start of token: \\u{201d}\n+    //~^^^^ HELP Unicode character '\u201d' (Right Double Quotation Mark) looks like '\"' (Quotation Mark), but it is not\n+    //~^^^^^ ERROR expected token: `,`\n }"}, {"sha": "84e45ecd873a4852564cf35c13800b5e4299492d", "filename": "src/test/ui/parser/unicode-quote-chars.stderr", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -8,5 +8,21 @@ help: Unicode characters '\u201c' (Left Double Quotation Mark) and '\u201d' (Right Dou\n LL |     println!(\"hello world\");\n    |              ^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: unknown start of token: \\u{201d}\n+  --> $DIR/unicode-quote-chars.rs:4:26\n+   |\n+LL |     println!(\u201chello world\u201d);\n+   |                          ^\n+help: Unicode character '\u201d' (Right Double Quotation Mark) looks like '\"' (Quotation Mark), but it is not\n+   |\n+LL |     println!(\u201chello world\");\n+   |                          ^\n+\n+error: expected token: `,`\n+  --> $DIR/unicode-quote-chars.rs:4:21\n+   |\n+LL |     println!(\u201chello world\u201d);\n+   |                     ^^^^^ expected `,`\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "eee331d95b9bc9c6f31a6241b21c2cd67d9290f2", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.nll.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/766b10a8d544550712fd6352863457a86f46db3c/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/766b10a8d544550712fd6352863457a86f46db3c/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.nll.stderr?ref=766b10a8d544550712fd6352863457a86f46db3c", "patch": "@@ -1,16 +0,0 @@\n-error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n-  --> $DIR/recursive-types-are-not-uninhabited.rs:6:9\n-   |\n-LL |     let Ok(x) = res;\n-   |         ^^^^^ pattern `Err(_)` not covered\n-\n-error[E0381]: use of possibly uninitialized variable: `x`\n-  --> $DIR/recursive-types-are-not-uninhabited.rs:8:5\n-   |\n-LL |     x\n-   |     ^ use of possibly uninitialized `x`\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0005, E0381.\n-For more information about an error, try `rustc --explain E0005`."}, {"sha": "45910c3c3a8c6dbc945baf39253f1e7328c08c2d", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -6,9 +6,7 @@ fn foo(res: Result<u32, &R>) -> u32 {\n     let Ok(x) = res;\n     //~^ ERROR refutable pattern\n     x\n-    //~^ WARN use of possibly uninitialized variable: `x`\n-    //~| WARN this error has been downgraded to a warning for backwards compatibility\n-    //~| WARN this represents potential undefined behavior in your code and this warning will\n+    //~^ ERROR use of possibly uninitialized variable: `x`\n }\n \n fn main() {"}, {"sha": "eee331d95b9bc9c6f31a6241b21c2cd67d9290f2", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -4,17 +4,13 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n LL |     let Ok(x) = res;\n    |         ^^^^^ pattern `Err(_)` not covered\n \n-warning[E0381]: use of possibly uninitialized variable: `x`\n+error[E0381]: use of possibly uninitialized variable: `x`\n   --> $DIR/recursive-types-are-not-uninhabited.rs:8:5\n    |\n LL |     x\n    |     ^ use of possibly uninitialized `x`\n-   |\n-   = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n-   = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n-   = note: for more information, try `rustc --explain E0729`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0005, E0381.\n For more information about an error, try `rustc --explain E0005`."}, {"sha": "dcb34f3ad4836518aad8be94b7fd533d51f91a47", "filename": "src/test/ui/specialization/issue-52050.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fspecialization%2Fissue-52050.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8996328ebf34aa73e83a1db326767c11041f811d/src%2Ftest%2Fui%2Fspecialization%2Fissue-52050.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-52050.stderr?ref=8996328ebf34aa73e83a1db326767c11041f811d", "patch": "@@ -10,6 +10,8 @@ LL | | }\n LL | \n LL |   impl IntoPyDictPointer for ()\n    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `()`\n+   |\n+   = note: upstream crates may add new impl of trait `std::iter::Iterator` for type `()` in future versions\n \n error: aborting due to previous error\n "}]}