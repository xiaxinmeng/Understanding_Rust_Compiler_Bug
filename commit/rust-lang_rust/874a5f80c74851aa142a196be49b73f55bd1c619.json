{"sha": "874a5f80c74851aa142a196be49b73f55bd1c619", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NGE1ZjgwYzc0ODUxYWExNDJhMTk2YmU0OWI3M2Y1NWJkMWM2MTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T06:01:03Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T06:01:03Z"}, "message": "Scale progress down\n\nThere are two reasons why we don't want a generic ra_progress crate\njust yet:\n\n*First*, it introduces a common interface between separate components,\nand that is usually undesirable (b/c components start to fit the\ninterface, rather than doing what makes most sense for each particular\ncomponent).\n\n*Second*, it introduces a separate async channel for progress, which\nmakes it harder to correlate progress reports with the work done. Ie,\nwhen we see 100% progress, it's not blindly obvious that the work has\nactually finished, we might have some pending messages still.", "tree": {"sha": "0ff97656e30c9b1fe3c4bb96b0171f33890c11ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ff97656e30c9b1fe3c4bb96b0171f33890c11ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/874a5f80c74851aa142a196be49b73f55bd1c619", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/874a5f80c74851aa142a196be49b73f55bd1c619", "html_url": "https://github.com/rust-lang/rust/commit/874a5f80c74851aa142a196be49b73f55bd1c619", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/874a5f80c74851aa142a196be49b73f55bd1c619/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76a530242a12f75e2a8456f952cef07e2d564f67", "url": "https://api.github.com/repos/rust-lang/rust/commits/76a530242a12f75e2a8456f952cef07e2d564f67", "html_url": "https://github.com/rust-lang/rust/commit/76a530242a12f75e2a8456f952cef07e2d564f67"}], "stats": {"total": 456, "additions": 102, "deletions": 354}, "files": [{"sha": "c2d00adebc58d231bc71652801b71786802adbb3", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/874a5f80c74851aa142a196be49b73f55bd1c619/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/874a5f80c74851aa142a196be49b73f55bd1c619/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=874a5f80c74851aa142a196be49b73f55bd1c619", "patch": "@@ -967,7 +967,6 @@ dependencies = [\n  \"crossbeam-channel\",\n  \"jod-thread\",\n  \"log\",\n- \"ra_progress\",\n  \"ra_toolchain\",\n  \"serde_json\",\n ]\n@@ -1081,11 +1080,7 @@ dependencies = [\n  \"ra_hir\",\n  \"ra_ide_db\",\n  \"ra_prof\",\n-<<<<<<< HEAD\n  \"ra_ssr\",\n-=======\n- \"ra_progress\",\n->>>>>>> Veetaha-feat/sync-branch\n  \"ra_syntax\",\n  \"ra_text_edit\",\n  \"rand\",\n@@ -1173,13 +1168,6 @@ dependencies = [\n  \"ra_arena\",\n ]\n \n-[[package]]\n-name = \"ra_progress\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"crossbeam-channel\",\n-]\n-\n [[package]]\n name = \"ra_project_model\"\n version = \"0.1.0\"\n@@ -1404,7 +1392,6 @@ dependencies = [\n  \"ra_mbe\",\n  \"ra_proc_macro_srv\",\n  \"ra_prof\",\n- \"ra_progress\",\n  \"ra_project_model\",\n  \"ra_syntax\",\n  \"ra_text_edit\","}, {"sha": "1aa39badea967a560418fc0f76ad8b7d85d54ef6", "filename": "crates/ra_flycheck/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Fra_flycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Fra_flycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2FCargo.toml?ref=874a5f80c74851aa142a196be49b73f55bd1c619", "patch": "@@ -14,4 +14,3 @@ cargo_metadata = \"0.10.0\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n ra_toolchain = { path = \"../ra_toolchain\" }\n-ra_progress = { path = \"../ra_progress\" }"}, {"sha": "0e2ee8698c0e05ea21accc468ba1b182bbc9a1ac", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=874a5f80c74851aa142a196be49b73f55bd1c619", "patch": "@@ -17,9 +17,6 @@ pub use cargo_metadata::diagnostic::{\n     Applicability, Diagnostic, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion,\n };\n \n-type Progress = ra_progress::Progress<(), String>;\n-type ProgressSource = ra_progress::ProgressSource<(), String>;\n-\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum FlycheckConfig {\n     CargoCommand {\n@@ -59,15 +56,11 @@ pub struct Flycheck {\n }\n \n impl Flycheck {\n-    pub fn new(\n-        config: FlycheckConfig,\n-        workspace_root: PathBuf,\n-        progress_src: ProgressSource,\n-    ) -> Flycheck {\n+    pub fn new(config: FlycheckConfig, workspace_root: PathBuf) -> Flycheck {\n         let (task_send, task_recv) = unbounded::<CheckTask>();\n         let (cmd_send, cmd_recv) = unbounded::<CheckCommand>();\n         let handle = jod_thread::spawn(move || {\n-            FlycheckThread::new(config, workspace_root, progress_src).run(&task_send, &cmd_recv);\n+            FlycheckThread::new(config, workspace_root).run(&task_send, &cmd_recv);\n         });\n         Flycheck { task_recv, cmd_send, handle }\n     }\n@@ -85,6 +78,16 @@ pub enum CheckTask {\n \n     /// Request adding a diagnostic with fixes included to a file\n     AddDiagnostic { workspace_root: PathBuf, diagnostic: Diagnostic },\n+\n+    /// Request check progress notification to client\n+    Status(Status),\n+}\n+\n+#[derive(Debug)]\n+pub enum Status {\n+    Being,\n+    Progress(String),\n+    End,\n }\n \n pub enum CheckCommand {\n@@ -96,8 +99,6 @@ struct FlycheckThread {\n     config: FlycheckConfig,\n     workspace_root: PathBuf,\n     last_update_req: Option<Instant>,\n-    progress_src: ProgressSource,\n-    progress: Option<Progress>,\n     // XXX: drop order is significant\n     message_recv: Receiver<CheckEvent>,\n     /// WatchThread exists to wrap around the communication needed to be able to\n@@ -109,17 +110,11 @@ struct FlycheckThread {\n }\n \n impl FlycheckThread {\n-    fn new(\n-        config: FlycheckConfig,\n-        workspace_root: PathBuf,\n-        progress_src: ProgressSource,\n-    ) -> FlycheckThread {\n+    fn new(config: FlycheckConfig, workspace_root: PathBuf) -> FlycheckThread {\n         FlycheckThread {\n             config,\n             workspace_root,\n-            progress_src,\n             last_update_req: None,\n-            progress: None,\n             message_recv: never(),\n             check_process: None,\n         }\n@@ -157,9 +152,9 @@ impl FlycheckThread {\n         }\n     }\n \n-    fn clean_previous_results(&mut self, task_send: &Sender<CheckTask>) {\n+    fn clean_previous_results(&self, task_send: &Sender<CheckTask>) {\n         task_send.send(CheckTask::ClearDiagnostics).unwrap();\n-        self.progress = None;\n+        task_send.send(CheckTask::Status(Status::End)).unwrap();\n     }\n \n     fn should_recheck(&mut self) -> bool {\n@@ -178,17 +173,18 @@ impl FlycheckThread {\n         }\n     }\n \n-    fn handle_message(&mut self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n+    fn handle_message(&self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n         match msg {\n             CheckEvent::Begin => {\n-                self.progress = Some(self.progress_src.begin(()));\n+                task_send.send(CheckTask::Status(Status::Being)).unwrap();\n+            }\n+\n+            CheckEvent::End => {\n+                task_send.send(CheckTask::Status(Status::End)).unwrap();\n             }\n-            CheckEvent::End => self.progress = None,\n+\n             CheckEvent::Msg(Message::CompilerArtifact(msg)) => {\n-                self.progress\n-                    .as_mut()\n-                    .expect(\"check process reported progress without the 'Begin' notification\")\n-                    .report(msg.target.name);\n+                task_send.send(CheckTask::Status(Status::Progress(msg.target.name))).unwrap();\n             }\n \n             CheckEvent::Msg(Message::CompilerMessage(msg)) => {"}, {"sha": "c7f7c6dd3421e452f74fdddfb873d945f6cc2da0", "filename": "crates/ra_progress/Cargo.toml", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_progress%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_progress%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_progress%2FCargo.toml?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -1,8 +0,0 @@\n-[package]\n-name = \"ra_progress\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n-edition = \"2018\"\n-\n-[dependencies]\n-crossbeam-channel = { version = \"0.4\" }"}, {"sha": "0ff1f846ca1b9726362b029e62f45288b5b7d102", "filename": "crates/ra_progress/src/lib.rs", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_progress%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a530242a12f75e2a8456f952cef07e2d564f67/crates%2Fra_progress%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_progress%2Fsrc%2Flib.rs?ref=76a530242a12f75e2a8456f952cef07e2d564f67", "patch": "@@ -1,129 +0,0 @@\n-//! General-purpose instrumentation for progress reporting.\n-//!\n-//! Note:\n-//! Most of the methods accept `&mut self` just to be more restrictive (for forward compat)\n-//! even tho for some of them we can weaken this requirement to shared reference (`&self`).\n-\n-use crossbeam_channel::Receiver;\n-use std::fmt;\n-\n-#[derive(Debug)]\n-pub enum ProgressStatus<B, P> {\n-    Begin(B),\n-    Progress(P),\n-    End,\n-}\n-\n-pub struct Progress<B, P>(Option<crossbeam_channel::Sender<ProgressStatus<B, P>>>);\n-impl<B, P> Progress<B, P> {\n-    pub fn report(&mut self, payload: P) {\n-        self.report_with(|| payload);\n-    }\n-\n-    pub fn report_with(&mut self, payload: impl FnOnce() -> P) {\n-        self.send_status(|| ProgressStatus::Progress(payload()));\n-    }\n-\n-    fn send_status(&self, status: impl FnOnce() -> ProgressStatus<B, P>) {\n-        if let Some(sender) = &self.0 {\n-            sender.try_send(status()).expect(\"progress report must not block\");\n-        }\n-    }\n-}\n-\n-impl<B, P> Drop for Progress<B, P> {\n-    fn drop(&mut self) {\n-        self.send_status(|| ProgressStatus::End);\n-    }\n-}\n-\n-pub struct ProgressSource<B, P>(Option<crossbeam_channel::Sender<ProgressStatus<B, P>>>);\n-impl<B, P> ProgressSource<B, P> {\n-    pub fn real_if(real: bool) -> (Receiver<ProgressStatus<B, P>>, Self) {\n-        if real {\n-            let (sender, receiver) = crossbeam_channel::unbounded();\n-            (receiver, Self(Some(sender)))\n-        } else {\n-            (crossbeam_channel::never(), Self(None))\n-        }\n-    }\n-\n-    pub fn begin(&mut self, payload: B) -> Progress<B, P> {\n-        self.begin_with(|| payload)\n-    }\n-\n-    pub fn begin_with(&mut self, payload: impl FnOnce() -> B) -> Progress<B, P> {\n-        let progress = Progress(self.0.clone());\n-        progress.send_status(|| ProgressStatus::Begin(payload()));\n-        progress\n-    }\n-}\n-\n-impl<B, P> Clone for ProgressSource<B, P> {\n-    fn clone(&self) -> Self {\n-        Self(self.0.clone())\n-    }\n-}\n-\n-impl<B, P> fmt::Debug for ProgressSource<B, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"ProgressSource\").field(&self.0).finish()\n-    }\n-}\n-\n-pub type U32ProgressStatus = ProgressStatus<U32ProgressReport, U32ProgressReport>;\n-\n-#[derive(Debug)]\n-pub struct U32ProgressReport {\n-    pub processed: u32,\n-    pub total: u32,\n-}\n-impl U32ProgressReport {\n-    pub fn percentage(&self) -> f64 {\n-        f64::from(100 * self.processed) / f64::from(self.total)\n-    }\n-    pub fn to_message(&self, prefix: &str, unit: &str) -> String {\n-        format!(\"{} ({}/{} {})\", prefix, self.processed, self.total, unit)\n-    }\n-}\n-\n-pub struct U32Progress {\n-    inner: Progress<U32ProgressReport, U32ProgressReport>,\n-    processed: u32,\n-    total: u32,\n-}\n-\n-#[derive(Debug, Eq, PartialEq)]\n-pub struct IsDone(pub bool);\n-\n-impl U32Progress {\n-    pub fn report(&mut self, new_processed: u32) -> IsDone {\n-        if self.processed < new_processed {\n-            self.processed = new_processed;\n-            self.inner.report(U32ProgressReport { processed: new_processed, total: self.total });\n-        }\n-        IsDone(self.processed >= self.total)\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct U32ProgressSource {\n-    inner: ProgressSource<U32ProgressReport, U32ProgressReport>,\n-}\n-\n-impl U32ProgressSource {\n-    pub fn real_if(\n-        real: bool,\n-    ) -> (Receiver<ProgressStatus<U32ProgressReport, U32ProgressReport>>, Self) {\n-        let (recv, inner) = ProgressSource::real_if(real);\n-        (recv, Self { inner })\n-    }\n-\n-    pub fn begin(&mut self, initial: u32, total: u32) -> U32Progress {\n-        U32Progress {\n-            inner: self.inner.begin(U32ProgressReport { processed: initial, total }),\n-            processed: initial,\n-            total,\n-        }\n-    }\n-}"}, {"sha": "68d04f3e32cac74870c29800172e61e084c5db96", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=874a5f80c74851aa142a196be49b73f55bd1c619", "patch": "@@ -48,7 +48,6 @@ hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n hir_ty = { path = \"../ra_hir_ty\", package = \"ra_hir_ty\" }\n ra_proc_macro_srv = { path = \"../ra_proc_macro_srv\" }\n-ra_progress = { path = \"../ra_progress\" }\n \n [target.'cfg(windows)'.dependencies]\n winapi = \"0.3.8\""}, {"sha": "64d4e2787ae3c9a03381fc61480fe0e95a2c60f7", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=874a5f80c74851aa142a196be49b73f55bd1c619", "patch": "@@ -27,11 +27,7 @@ use crate::{\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-fn create_flycheck(\n-    workspaces: &[ProjectWorkspace],\n-    config: &FlycheckConfig,\n-    progress_src: &ProgressSource<(), String>,\n-) -> Option<Flycheck> {\n+fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) -> Option<Flycheck> {\n     // FIXME: Figure out the multi-workspace situation\n     workspaces.iter().find_map(move |w| match w {\n         ProjectWorkspace::Cargo { cargo, .. } => {\n@@ -147,12 +143,7 @@ impl GlobalState {\n         }\n         change.set_crate_graph(crate_graph);\n \n-        let (flycheck_progress_receiver, flycheck_progress_src) =\n-            ProgressSource::real_if(config.client_caps.work_done_progress);\n-        let flycheck = config\n-            .check\n-            .as_ref()\n-            .and_then(|c| create_flycheck(&workspaces, c, &flycheck_progress_src));\n+        let flycheck = config.check.as_ref().and_then(|c| create_flycheck(&workspaces, c));\n \n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n@@ -162,8 +153,6 @@ impl GlobalState {\n             loader,\n             task_receiver,\n             flycheck,\n-            flycheck_progress_src,\n-            flycheck_progress_receiver,\n             diagnostics: Default::default(),\n             mem_docs: FxHashSet::default(),\n             vfs: Arc::new(RwLock::new((vfs, FxHashMap::default()))),\n@@ -181,10 +170,8 @@ impl GlobalState {\n     pub(crate) fn update_configuration(&mut self, config: Config) {\n         self.analysis_host.update_lru_capacity(config.lru_capacity);\n         if config.check != self.config.check {\n-            self.flycheck = config\n-                .check\n-                .as_ref()\n-                .and_then(|it| create_flycheck(&self.workspaces, it, &self.flycheck_progress_src));\n+            self.flycheck =\n+                config.check.as_ref().and_then(|it| create_flycheck(&self.workspaces, it));\n         }\n \n         self.config = config;"}, {"sha": "794286672699ba968c83152045828380b89009aa", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=874a5f80c74851aa142a196be49b73f55bd1c619", "patch": "@@ -29,16 +29,14 @@ mod markdown;\n mod diagnostics;\n mod line_endings;\n mod request_metrics;\n+mod lsp_utils;\n pub mod lsp_ext;\n pub mod config;\n \n use serde::de::DeserializeOwned;\n \n pub type Result<T, E = Box<dyn std::error::Error + Send + Sync>> = std::result::Result<T, E>;\n-pub use crate::{\n-    caps::server_capabilities,\n-    main_loop::{main_loop, show_message},\n-};\n+pub use crate::{caps::server_capabilities, lsp_utils::show_message, main_loop::main_loop};\n use std::fmt;\n \n pub fn from_json<T: DeserializeOwned>(what: &'static str, json: serde_json::Value) -> Result<T> {"}, {"sha": "078f8778ea8b66a721cddfc40243be2769c4f2ed", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=874a5f80c74851aa142a196be49b73f55bd1c619", "patch": "@@ -1,10 +1,10 @@\n //! Utilities for LSP-related boilerplate code.\n+use std::error::Error;\n \n use crossbeam_channel::Sender;\n-use lsp_server::{Message, Notification, Request, RequestId};\n+use lsp_server::{Message, Notification};\n use ra_db::Canceled;\n use serde::{de::DeserializeOwned, Serialize};\n-use std::error::Error;\n \n pub fn show_message(\n     typ: lsp_types::MessageType,\n@@ -42,11 +42,3 @@ where\n {\n     Notification::new(N::METHOD.to_string(), params)\n }\n-\n-pub(crate) fn request_new<R>(id: RequestId, params: R::Params) -> Request\n-where\n-    R: lsp_types::request::Request,\n-    R::Params: Serialize,\n-{\n-    Request::new(id, R::METHOD.to_string(), params)\n-}"}, {"sha": "03569086a7eda33f62b3a4392439d4d7f46053cd", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 71, "deletions": 140, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=874a5f80c74851aa142a196be49b73f55bd1c619", "patch": "@@ -25,17 +25,10 @@ use crate::{\n     from_proto,\n     global_state::{file_id_to_url, GlobalState, GlobalStateSnapshot, Status},\n     handlers, lsp_ext,\n+    lsp_utils::{is_canceled, notification_cast, notification_is, notification_new, show_message},\n     request_metrics::RequestMetrics,\n     LspError, Result,\n };\n-pub use lsp_utils::show_message;\n-use lsp_utils::{is_canceled, notification_cast, notification_is, notification_new, request_new};\n-use ra_progress::{\n-    IsDone, ProgressStatus, U32Progress, U32ProgressReport, U32ProgressSource, U32ProgressStatus,\n-};\n-\n-const FLYCHECK_PROGRESS_TOKEN: &str = \"rustAnalyzer/flycheck\";\n-const ROOTS_SCANNED_PROGRESS_TOKEN: &str = \"rustAnalyzer/rootsScanned\";\n \n pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n     log::info!(\"initial config: {:#?}\", config);\n@@ -147,18 +140,6 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                     Ok(task) => Event::CheckWatcher(task),\n                     Err(RecvError) => return Err(\"check watcher died\".into()),\n                 },\n-                recv(global_state.flycheck_progress_receiver) -> status => match status {\n-                    Ok(status) => Event::ProgressReport(ProgressReport::Flycheck(status)),\n-                    Err(RecvError) => return Err(\"check watcher died\".into()),\n-                },\n-                recv(roots_scanned_progress_receiver) -> status => match status {\n-                    Ok(status) => Event::ProgressReport(ProgressReport::RootsScanned(status)),\n-                    Err(RecvError) => {\n-                        // Roots analysis has finished, we no longer need this receiver\n-                        roots_scanned_progress_receiver = never();\n-                        continue;\n-                    }\n-                }\n             };\n             if let Event::Msg(Message::Request(req)) = &event {\n                 if connection.handle_shutdown(&req)? {\n@@ -188,8 +169,6 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n #[derive(Debug)]\n enum Task {\n     Respond(Response),\n-    Notify(Notification),\n-    SendRequest(Request),\n     Diagnostic(DiagnosticTask),\n }\n \n@@ -198,13 +177,6 @@ enum Event {\n     Task(Task),\n     Vfs(vfs::loader::Message),\n     CheckWatcher(CheckTask),\n-    ProgressReport(ProgressReport),\n-}\n-\n-#[derive(Debug)]\n-enum ProgressReport {\n-    Flycheck(ProgressStatus<(), String>),\n-    RootsScanned(U32ProgressStatus),\n }\n \n impl fmt::Debug for Event {\n@@ -221,11 +193,6 @@ impl fmt::Debug for Event {\n                     return debug_verbose_not(not, f);\n                 }\n             }\n-            Event::Task(Task::Notify(not)) => {\n-                if notification_is::<lsp_types::notification::PublishDiagnostics>(not) {\n-                    return debug_verbose_not(not, f);\n-                }\n-            }\n             Event::Task(Task::Respond(resp)) => {\n                 return f\n                     .debug_struct(\"Response\")\n@@ -240,7 +207,6 @@ impl fmt::Debug for Event {\n             Event::Task(it) => fmt::Debug::fmt(it, f),\n             Event::Vfs(it) => fmt::Debug::fmt(it, f),\n             Event::CheckWatcher(it) => fmt::Debug::fmt(it, f),\n-            Event::ProgressReport(it) => fmt::Debug::fmt(it, f),\n         }\n     }\n }\n@@ -283,16 +249,28 @@ fn loop_turn(\n                 }\n             }\n             vfs::loader::Message::Progress { n_total, n_done } => {\n-                if n_done == n_total {\n+                let state = if n_done == 0 {\n+                    ProgressState::Start\n+                } else if n_done < n_total {\n+                    ProgressState::Report\n+                } else {\n+                    assert_eq!(n_done, n_total);\n                     global_state.status = Status::Ready;\n                     became_ready = true;\n-                }\n-                report_progress(global_state, &connection.sender, n_done, n_total, \"roots scanned\")\n+                    ProgressState::End\n+                };\n+                report_progress(\n+                    global_state,\n+                    &connection.sender,\n+                    \"roots scanned\",\n+                    state,\n+                    Some(format!(\"{}/{}\", n_done, n_total)),\n+                    Some(percentage(n_done, n_total)),\n+                )\n             }\n         },\n-        Event::CheckWatcher(task) => on_check_task(task, global_state, task_sender)?,\n-        Event::ProgressReport(report) => {\n-            on_progress_report(report, task_sender, loop_state, global_state)\n+        Event::CheckWatcher(task) => {\n+            on_check_task(task, global_state, task_sender, &connection.sender)?\n         }\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => {\n@@ -367,9 +345,6 @@ fn on_task(task: Task, msg_sender: &Sender<Message>, global_state: &mut GlobalSt\n                 msg_sender.send(response.into()).unwrap();\n             }\n         }\n-        Task::Notify(n) => {\n-            msg_sender.send(n.into()).unwrap();\n-        }\n         Task::Diagnostic(task) => on_diagnostic_task(task, msg_sender, global_state),\n     }\n }\n@@ -621,6 +596,7 @@ fn on_check_task(\n     task: CheckTask,\n     global_state: &mut GlobalState,\n     task_sender: &Sender<Task>,\n+    msg_sender: &Sender<Message>,\n ) -> Result<()> {\n     match task {\n         CheckTask::ClearDiagnostics => {\n@@ -652,39 +628,13 @@ fn on_check_task(\n         }\n \n         CheckTask::Status(status) => {\n-            if global_state.config.client_caps.work_done_progress {\n-                let progress = match status {\n-                    ra_flycheck::Status::Being => {\n-                        lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n-                            title: \"Running `cargo check`\".to_string(),\n-                            cancellable: Some(false),\n-                            message: None,\n-                            percentage: None,\n-                        })\n-                    }\n-                    ra_flycheck::Status::Progress(target) => {\n-                        lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n-                            cancellable: Some(false),\n-                            message: Some(target),\n-                            percentage: None,\n-                        })\n-                    }\n-                    ra_flycheck::Status::End => {\n-                        lsp_types::WorkDoneProgress::End(lsp_types::WorkDoneProgressEnd {\n-                            message: None,\n-                        })\n-                    }\n-                };\n+            let (state, message) = match status {\n+                ra_flycheck::Status::Being => (ProgressState::Start, None),\n+                ra_flycheck::Status::Progress(target) => (ProgressState::Report, Some(target)),\n+                ra_flycheck::Status::End => (ProgressState::End, None),\n+            };\n \n-                let params = lsp_types::ProgressParams {\n-                    token: lsp_types::ProgressToken::String(\n-                        \"rustAnalyzer/cargoWatcher\".to_string(),\n-                    ),\n-                    value: lsp_types::ProgressParamsValue::WorkDone(progress),\n-                };\n-                let not = notification_new::<lsp_types::notification::Progress>(params);\n-                task_sender.send(Task::Notify(not)).unwrap();\n-            }\n+            report_progress(global_state, msg_sender, \"cargo check\", state, message, None);\n         }\n     };\n \n@@ -703,39 +653,55 @@ fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state:\n     }\n }\n \n+#[derive(Eq, PartialEq)]\n+enum ProgressState {\n+    Start,\n+    Report,\n+    End,\n+}\n+\n+fn percentage(done: usize, total: usize) -> f64 {\n+    (done as f64 / total.max(1) as f64) * 100.0\n+}\n+\n fn report_progress(\n     global_state: &mut GlobalState,\n     sender: &Sender<Message>,\n-    done: usize,\n-    total: usize,\n-    message: &str,\n+    title: &str,\n+    state: ProgressState,\n+    message: Option<String>,\n+    percentage: Option<f64>,\n ) {\n-    let token = lsp_types::ProgressToken::String(format!(\"rustAnalyzer/{}\", message));\n-    let message = Some(format!(\"{}/{} {}\", done, total, message));\n-    let percentage = Some(100.0 * done as f64 / total.max(1) as f64);\n-    let work_done_progress = if done == 0 {\n-        let work_done_progress_create = global_state.req_queue.outgoing.register(\n-            lsp_types::request::WorkDoneProgressCreate::METHOD.to_string(),\n-            lsp_types::WorkDoneProgressCreateParams { token: token.clone() },\n-            DO_NOTHING,\n-        );\n-        sender.send(work_done_progress_create.into()).unwrap();\n-\n-        lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n-            title: \"rust-analyzer\".into(),\n-            cancellable: None,\n-            message,\n-            percentage,\n-        })\n-    } else if done < total {\n-        lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n-            cancellable: None,\n-            message,\n-            percentage,\n-        })\n-    } else {\n-        assert!(done == total);\n-        lsp_types::WorkDoneProgress::End(lsp_types::WorkDoneProgressEnd { message })\n+    if !global_state.config.client_caps.work_done_progress {\n+        return;\n+    }\n+    let token = lsp_types::ProgressToken::String(format!(\"rustAnalyzer/{}\", title));\n+    let work_done_progress = match state {\n+        ProgressState::Start => {\n+            let work_done_progress_create = global_state.req_queue.outgoing.register(\n+                lsp_types::request::WorkDoneProgressCreate::METHOD.to_string(),\n+                lsp_types::WorkDoneProgressCreateParams { token: token.clone() },\n+                DO_NOTHING,\n+            );\n+            sender.send(work_done_progress_create.into()).unwrap();\n+\n+            lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n+                title: title.into(),\n+                cancellable: None,\n+                message,\n+                percentage,\n+            })\n+        }\n+        ProgressState::Report => {\n+            lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n+                cancellable: None,\n+                message,\n+                percentage,\n+            })\n+        }\n+        ProgressState::End => {\n+            lsp_types::WorkDoneProgress::End(lsp_types::WorkDoneProgressEnd { message })\n+        }\n     };\n     let notification =\n         notification_new::<lsp_types::notification::Progress>(lsp_types::ProgressParams {\n@@ -898,41 +864,6 @@ fn update_file_notifications_on_threadpool(\n     }\n }\n \n-pub fn show_message(\n-    typ: lsp_types::MessageType,\n-    message: impl Into<String>,\n-    sender: &Sender<Message>,\n-) {\n-    let message = message.into();\n-    let params = lsp_types::ShowMessageParams { typ, message };\n-    let not = notification_new::<lsp_types::notification::ShowMessage>(params);\n-    sender.send(not.into()).unwrap();\n-}\n-\n-fn is_canceled(e: &Box<dyn std::error::Error + Send + Sync>) -> bool {\n-    e.downcast_ref::<Canceled>().is_some()\n-}\n-\n-fn notification_is<N: lsp_types::notification::Notification>(notification: &Notification) -> bool {\n-    notification.method == N::METHOD\n-}\n-\n-fn notification_cast<N>(notification: Notification) -> std::result::Result<N::Params, Notification>\n-where\n-    N: lsp_types::notification::Notification,\n-    N::Params: DeserializeOwned,\n-{\n-    notification.extract(N::METHOD)\n-}\n-\n-fn notification_new<N>(params: N::Params) -> Notification\n-where\n-    N: lsp_types::notification::Notification,\n-    N::Params: Serialize,\n-{\n-    Notification::new(N::METHOD.to_string(), params)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use lsp_types::{Position, Range, TextDocumentContentChangeEvent};"}, {"sha": "49f194f7efb6593c1a4a09302ea79d7ddcaf26ef", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874a5f80c74851aa142a196be49b73f55bd1c619/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=874a5f80c74851aa142a196be49b73f55bd1c619", "patch": "@@ -202,11 +202,7 @@ impl Server {\n                     ProgressParams {\n                         token: lsp_types::ProgressToken::String(ref token),\n                         value: ProgressParamsValue::WorkDone(WorkDoneProgress::End(_)),\n-<<<<<<< HEAD\n                     } if token == \"rustAnalyzer/roots scanned\" => true,\n-=======\n-                    } if token == \"rustAnalyzer/rootsScanned\" => true,\n->>>>>>> Veetaha-feat/sync-branch\n                     _ => false,\n                 }\n             }"}]}