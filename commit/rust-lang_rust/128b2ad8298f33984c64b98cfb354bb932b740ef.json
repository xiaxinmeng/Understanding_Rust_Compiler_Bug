{"sha": "128b2ad8298f33984c64b98cfb354bb932b740ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyOGIyYWQ4Mjk4ZjMzOTg0YzY0Yjk4Y2ZiMzU0YmI5MzJiNzQwZWY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-26T03:37:21Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-26T03:37:21Z"}, "message": "Rollup merge of #32199 - nikomatsakis:limiting-constants-in-patterns-2, r=pnkfelix\n\nRestrict constants in patterns\n\nThis implements [RFC 1445](https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md). The primary change is to limit the types of constants used in patterns to those that *derive* `Eq` (note that implementing `Eq` is not sufficient). This has two main effects:\n\n1. Floating point constants are linted, and will eventually be disallowed. This is because floating point constants do not implement `Eq` but only `PartialEq`. This check replaces the existing special case code that aimed to detect the use of `NaN`.\n2. Structs and enums must derive `Eq` to be usable within a match.\n\nThis is a [breaking-change]: if you encounter a problem, you are most likely using a constant in an expression where the type of the constant is some struct that does not currently implement\n`Eq`. Something like the following:\n\n```rust\nstruct SomeType { ... }\nconst SOME_CONST: SomeType = ...;\n\nmatch foo {\n    SOME_CONST => ...\n}\n```\n\nThe easiest and most future compatible fix is to annotate the type in question with `#[derive(Eq)]` (note that merely *implementing* `Eq` is not enough, it must be *derived*):\n\n```rust\nstruct SomeType { ... }\nconst SOME_CONST: SomeType = ...;\n\nmatch foo {\n    SOME_CONST => ...\n}\n```\n\nAnother good option is to rewrite the match arm to use an `if` condition (this is also particularly good for floating point types, which implement `PartialEq` but not `Eq`):\n\n```rust\nmatch foo {\n    c if c == SOME_CONST => ...\n}\n```\n\nFinally, a third alternative is to tag the type with `#[structural_match]`; but this is not recommended, as the attribute is never expected to be stabilized. Please see RFC #1445 for more details.\n\ncc https://github.com/rust-lang/rust/issues/31434\n\nr? @pnkfelix", "tree": {"sha": "0a04ffa5af03d56995d8df5f1bc753bc6e5dbc04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a04ffa5af03d56995d8df5f1bc753bc6e5dbc04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/128b2ad8298f33984c64b98cfb354bb932b740ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/128b2ad8298f33984c64b98cfb354bb932b740ef", "html_url": "https://github.com/rust-lang/rust/commit/128b2ad8298f33984c64b98cfb354bb932b740ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/128b2ad8298f33984c64b98cfb354bb932b740ef/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8b17a54cf1f6d216d83c5679cf9d7951656e36c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b17a54cf1f6d216d83c5679cf9d7951656e36c", "html_url": "https://github.com/rust-lang/rust/commit/b8b17a54cf1f6d216d83c5679cf9d7951656e36c"}, {"sha": "2536ae55a4fe3bb9d96ddd53e790631e76a6a11b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2536ae55a4fe3bb9d96ddd53e790631e76a6a11b", "html_url": "https://github.com/rust-lang/rust/commit/2536ae55a4fe3bb9d96ddd53e790631e76a6a11b"}], "stats": {"total": 484, "additions": 438, "deletions": 46}, "files": [{"sha": "879b894562092f6847cb8f45c5a02e37c46439f6", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -136,6 +136,19 @@ declare_lint! {\n     \"type parameter default erroneously allowed in invalid location\"\n }\n \n+declare_lint! {\n+    pub ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n+    Warn,\n+    \"floating-point constants cannot be used in patterns\"\n+}\n+\n+declare_lint! {\n+    pub ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n+    Deny,\n+    \"constants of struct or enum type can only be used in a pattern if \\\n+     the struct or enum has `#[derive(PartialEq, Eq)]`\"\n+}\n+\n declare_lint! {\n     pub MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n     Deny,\n@@ -193,6 +206,8 @@ impl LintPass for HardwiredLints {\n             PRIVATE_IN_PUBLIC,\n             INACCESSIBLE_EXTERN_CRATE,\n             INVALID_TYPE_PARAM_DEFAULT,\n+            ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n+            ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n             MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n             CONST_ERR,\n             RAW_POINTER_DERIVE,"}, {"sha": "3414d509d953fd9c2ad18f42414491c42d652193", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -478,15 +478,24 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                     Some(Def::Const(did)) => {\n                         let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n                         if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n-                            const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n-\n-                                if let Some(ref mut renaming_map) = self.renaming_map {\n-                                    // Record any renamings we do here\n-                                    record_renamings(const_expr, &pat, renaming_map);\n+                            match const_expr_to_pat(self.tcx, const_expr, pat.id, pat.span) {\n+                                Ok(new_pat) => {\n+                                    if let Some(ref mut map) = self.renaming_map {\n+                                        // Record any renamings we do here\n+                                        record_renamings(const_expr, &pat, map);\n+                                    }\n+                                    new_pat\n                                 }\n-\n-                                new_pat\n-                            })\n+                                Err(def_id) => {\n+                                    self.failed = true;\n+                                    self.tcx.sess.span_err(\n+                                        pat.span,\n+                                        &format!(\"constants of the type `{}` \\\n+                                                  cannot be used in patterns\",\n+                                                 self.tcx.item_path_str(def_id)));\n+                                    pat\n+                                }\n+                            }\n                         } else {\n                             self.failed = true;\n                             span_err!(self.tcx.sess, pat.span, E0158,"}, {"sha": "c102822e8c126049579f254cc5e4bd4056a8e38d", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -16,6 +16,7 @@ use self::EvalHint::*;\n \n use front::map as ast_map;\n use front::map::blocks::FnLikeNode;\n+use lint;\n use middle::cstore::{self, CrateStore, InlinedItem};\n use middle::{infer, subst, traits};\n use middle::def::Def;\n@@ -323,10 +324,41 @@ impl ConstVal {\n     }\n }\n \n-pub fn const_expr_to_pat(tcx: &TyCtxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n+pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, span: Span)\n+                         -> Result<P<hir::Pat>, DefId> {\n+    let pat_ty = tcx.expr_ty(expr);\n+    debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n+    match pat_ty.sty {\n+        ty::TyFloat(_) => {\n+            tcx.sess.add_lint(\n+                lint::builtin::ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n+                pat_id,\n+                span,\n+                format!(\"floating point constants cannot be used in patterns\"));\n+        }\n+        ty::TyEnum(adt_def, _) |\n+        ty::TyStruct(adt_def, _) => {\n+            if !tcx.has_attr(adt_def.did, \"structural_match\") {\n+                tcx.sess.add_lint(\n+                    lint::builtin::ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n+                    pat_id,\n+                    span,\n+                    format!(\"to use a constant of type `{}` \\\n+                             in a pattern, \\\n+                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                            tcx.item_path_str(adt_def.did),\n+                            tcx.item_path_str(adt_def.did)));\n+            }\n+        }\n+        _ => { }\n+    }\n+\n     let pat = match expr.node {\n         hir::ExprTup(ref exprs) =>\n-            PatKind::Tup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect()),\n+            PatKind::Tup(try!(exprs.iter()\n+                                  .map(|expr| const_expr_to_pat(tcx, &expr,\n+                                                                pat_id, span))\n+                                  .collect())),\n \n         hir::ExprCall(ref callee, ref args) => {\n             let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n@@ -336,31 +368,41 @@ pub fn const_expr_to_pat(tcx: &TyCtxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n             let path = match def.full_def() {\n                 Def::Struct(def_id) => def_to_path(tcx, def_id),\n                 Def::Variant(_, variant_did) => def_to_path(tcx, variant_did),\n-                Def::Fn(..) => return P(hir::Pat {\n+                Def::Fn(..) => return Ok(P(hir::Pat {\n                     id: expr.id,\n                     node: PatKind::Lit(P(expr.clone())),\n                     span: span,\n-                }),\n+                })),\n                 _ => unreachable!()\n             };\n-            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n+            let pats = try!(args.iter()\n+                                .map(|expr| const_expr_to_pat(tcx, &**expr,\n+                                                              pat_id, span))\n+                                .collect());\n             PatKind::TupleStruct(path, Some(pats))\n         }\n \n         hir::ExprStruct(ref path, ref fields, None) => {\n-            let field_pats = fields.iter().map(|field| codemap::Spanned {\n-                span: codemap::DUMMY_SP,\n-                node: hir::FieldPat {\n-                    name: field.name.node,\n-                    pat: const_expr_to_pat(tcx, &field.expr, span),\n-                    is_shorthand: false,\n-                },\n-            }).collect();\n+            let field_pats =\n+                try!(fields.iter()\n+                           .map(|field| Ok(codemap::Spanned {\n+                               span: codemap::DUMMY_SP,\n+                               node: hir::FieldPat {\n+                                   name: field.name.node,\n+                                   pat: try!(const_expr_to_pat(tcx, &field.expr,\n+                                                               pat_id, span)),\n+                                   is_shorthand: false,\n+                               },\n+                           }))\n+                           .collect());\n             PatKind::Struct(path.clone(), field_pats, false)\n         }\n \n         hir::ExprVec(ref exprs) => {\n-            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n+            let pats = try!(exprs.iter()\n+                                 .map(|expr| const_expr_to_pat(tcx, &expr,\n+                                                               pat_id, span))\n+                                 .collect());\n             PatKind::Vec(pats, None, hir::HirVec::new())\n         }\n \n@@ -373,15 +415,15 @@ pub fn const_expr_to_pat(tcx: &TyCtxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n                 Some(Def::AssociatedConst(def_id)) => {\n                     let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n-                    return const_expr_to_pat(tcx, expr, span);\n+                    return const_expr_to_pat(tcx, expr, pat_id, span);\n                 },\n                 _ => unreachable!(),\n             }\n         }\n \n         _ => PatKind::Lit(P(expr.clone()))\n     };\n-    P(hir::Pat { id: expr.id, node: pat, span: span })\n+    Ok(P(hir::Pat { id: expr.id, node: pat, span: span }))\n }\n \n pub fn eval_const_expr(tcx: &TyCtxt, e: &Expr) -> ConstVal {"}, {"sha": "19123f0f15ef4e5d512885c3c75cdfa5dd5d6244", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -252,7 +252,13 @@ impl Session {\n         let lint_id = lint::LintId::of(lint);\n         let mut lints = self.lints.borrow_mut();\n         match lints.get_mut(&id) {\n-            Some(arr) => { arr.push((lint_id, sp, msg)); return; }\n+            Some(arr) => {\n+                let tuple = (lint_id, sp, msg);\n+                if !arr.contains(&tuple) {\n+                    arr.push(tuple);\n+                }\n+                return;\n+            }\n             None => {}\n         }\n         lints.insert(id, vec!((lint_id, sp, msg)));"}, {"sha": "9ed21117cebca587e7e2dc4d32f05320987273cc", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -179,6 +179,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(OVERLAPPING_INHERENT_IMPLS),\n             reference: \"issue #22889 <https://github.com/rust-lang/rust/issues/22889>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN),\n+            reference: \"RFC 1445 <https://github.com/rust-lang/rfcs/pull/1445>\",\n+        },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN),\n+            reference: \"RFC 1445 <https://github.com/rust-lang/rfcs/pull/1445>\",\n+        },\n         ]);\n \n     // We have one lint pass defined specially"}, {"sha": "a582a4622a6d0cf070adb52985116993012d6091", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -90,9 +90,16 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                         let substs = Some(self.cx.tcx.node_id_item_substs(pat.id).substs);\n                         match const_eval::lookup_const_by_id(self.cx.tcx, def_id, substs) {\n                             Some((const_expr, _const_ty)) => {\n-                                let pat = const_eval::const_expr_to_pat(self.cx.tcx, const_expr,\n-                                                                        pat.span);\n-                                return self.to_pattern(&pat);\n+                                match const_eval::const_expr_to_pat(self.cx.tcx,\n+                                                                    const_expr,\n+                                                                    pat.id,\n+                                                                    pat.span) {\n+                                    Ok(pat) =>\n+                                        return self.to_pattern(&pat),\n+                                    Err(_) =>\n+                                        self.cx.tcx.sess.span_bug(\n+                                            pat.span, \"illegal constant\"),\n+                                }\n                             }\n                             None => {\n                                 self.cx.tcx.sess.span_bug("}, {"sha": "6fc26bb7eed71fd48940bce6fee5e0858c01446c", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -1152,9 +1152,10 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f32 {\n-        match self {\n-            NEG_INFINITY => NEG_INFINITY,\n-            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n+        if self == NEG_INFINITY {\n+            NEG_INFINITY\n+        } else {\n+            (self + ((self * self) + 1.0).sqrt()).ln()\n         }\n     }\n "}, {"sha": "93e5969a275c3f9855fdfd7f1a102c41c6d5d0de", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -1023,9 +1023,10 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f64 {\n-        match self {\n-            NEG_INFINITY => NEG_INFINITY,\n-            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n+        if self == NEG_INFINITY {\n+            NEG_INFINITY\n+        } else {\n+            (self + ((self * self) + 1.0).sqrt()).ln()\n         }\n     }\n "}, {"sha": "f771ee95bd1215696ca6557771290ca1a372755d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -1304,6 +1304,31 @@ impl CodeMap {\n         return a;\n     }\n \n+    /// Check if the backtrace `subtrace` contains `suptrace` as a prefix.\n+    pub fn more_specific_trace(&self,\n+                              mut subtrace: ExpnId,\n+                              suptrace: ExpnId)\n+                              -> bool {\n+        loop {\n+            if subtrace == suptrace {\n+                return true;\n+            }\n+\n+            let stop = self.with_expn_info(subtrace, |opt_expn_info| {\n+                if let Some(expn_info) = opt_expn_info {\n+                    subtrace = expn_info.call_site.expn_id;\n+                    false\n+                } else {\n+                    true\n+                }\n+            });\n+\n+            if stop {\n+                return false;\n+            }\n+        }\n+    }\n+\n     pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n         let mut expansions = self.expansions.borrow_mut();\n         expansions.push(expn_info);"}, {"sha": "8550617560df3ed7840259c812b60b6a3c2c9649", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -33,7 +33,7 @@ use visit::Visitor;\n use std_inject;\n \n use std::collections::HashSet;\n-\n+use std::env;\n \n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     let expr_span = e.span;\n@@ -1275,11 +1275,41 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n }\n \n fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n-    /* this discards information in the case of macro-defining macros */\n-    Span {\n-        lo: sp.lo,\n-        hi: sp.hi,\n-        expn_id: cx.backtrace(),\n+    debug!(\"new_span(sp={:?})\", sp);\n+\n+    if cx.codemap().more_specific_trace(sp.expn_id, cx.backtrace()) {\n+        // If the span we are looking at has a backtrace that has more\n+        // detail than our current backtrace, then we keep that\n+        // backtrace.  Honestly, I have no idea if this makes sense,\n+        // because I have no idea why we are stripping the backtrace\n+        // below. But the reason I made this change is because, in\n+        // deriving, we were generating attributes with a specific\n+        // backtrace, which was essential for `#[structural_match]` to\n+        // be properly supported, but these backtraces were being\n+        // stripped and replaced with a null backtrace. Sort of\n+        // unclear why this is the case. --nmatsakis\n+        debug!(\"new_span: keeping trace from {:?} because it is more specific\",\n+               sp.expn_id);\n+        sp\n+    } else {\n+        // This discards information in the case of macro-defining macros.\n+        //\n+        // The comment above was originally added in\n+        // b7ec2488ff2f29681fe28691d20fd2c260a9e454 in Feb 2012. I\n+        // *THINK* the reason we are doing this is because we want to\n+        // replace the backtrace of the macro contents with the\n+        // backtrace that contains the macro use. But it's pretty\n+        // unclear to me. --nmatsakis\n+        let sp1 = Span {\n+            lo: sp.lo,\n+            hi: sp.hi,\n+            expn_id: cx.backtrace(),\n+        };\n+        debug!(\"new_span({:?}) = {:?}\", sp, sp1);\n+        if sp.expn_id.into_u32() == 0 && env::var_os(\"NDM\").is_some() {\n+            panic!(\"NDM\");\n+        }\n+        sp1\n     }\n }\n "}, {"sha": "cd88aaa459750aea937ae4395ce382ef1da09387", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -109,6 +109,8 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     // to bootstrap fix for #5723.\n     (\"issue_5723_bootstrap\", \"1.0.0\", None, Accepted),\n \n+    (\"structural_match\", \"1.8.0\", Some(31434), Active),\n+\n     // A way to temporarily opt out of opt in copy. This will *never* be accepted.\n     (\"opt_out_copy\", \"1.0.0\", None, Removed),\n \n@@ -304,6 +306,11 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"link_args\", Normal, Ungated),\n     (\"macro_escape\", Normal, Ungated),\n \n+    // RFC #1445.\n+    (\"structural_match\", Whitelisted, Gated(\"structural_match\",\n+                                            \"the semantics of constant patterns is \\\n+                                             not yet settled\")),\n+\n     // Not used any more, but we can't feature gate it\n     (\"no_stack_check\", Normal, Ungated),\n \n@@ -682,7 +689,7 @@ impl<'a> Context<'a> {\n     fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n         let has_feature = self.has_feature(feature);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", feature, span, has_feature);\n-        if !has_feature {\n+        if !has_feature && !self.cm.span_allows_unstable(span) {\n             emit_feature_err(self.span_handler, feature, span, GateIssue::Language, explain);\n         }\n     }"}, {"sha": "671f3e4a7e3302cf265464adb617a4096c77e840", "filename": "src/libsyntax_ext/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -10,4 +10,5 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n fmt_macros = { path = \"../libfmt_macros\" }\n+log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "1774167e8300007214d1d2bc56d9d9af25de9561", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -78,7 +78,10 @@ fn expand_derive(cx: &mut ExtCtxt,\n                  mitem: &MetaItem,\n                  annotatable: Annotatable)\n                  -> Annotatable {\n-    annotatable.map_item_or(|item| {\n+    debug!(\"expand_derive: span = {:?}\", span);\n+    debug!(\"expand_derive: mitem = {:?}\", mitem);\n+    debug!(\"expand_derive: annotatable input  = {:?}\", annotatable);\n+    let annot = annotatable.map_item_or(|item| {\n         item.map(|mut item| {\n             if mitem.value_str().is_some() {\n                 cx.span_err(mitem.span, \"unexpected value in `derive`\");\n@@ -89,6 +92,9 @@ fn expand_derive(cx: &mut ExtCtxt,\n                 cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n             }\n \n+            let mut found_partial_eq = false;\n+            let mut found_eq = false;\n+\n             for titem in traits.iter().rev() {\n                 let tname = match titem.node {\n                     MetaItemKind::Word(ref tname) => tname,\n@@ -107,17 +113,64 @@ fn expand_derive(cx: &mut ExtCtxt,\n                     continue;\n                 }\n \n+                if &tname[..] == \"Eq\" {\n+                    found_eq = true;\n+                } else if &tname[..] == \"PartialEq\" {\n+                    found_partial_eq = true;\n+                }\n+\n                 // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n                 item.attrs.push(cx.attribute(titem.span, cx.meta_word(titem.span,\n                     intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n             }\n \n+            // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n+            // `#[structural_match]` attribute.\n+            if found_partial_eq && found_eq {\n+                // This span is **very** sensitive and crucial to\n+                // getting the stability behavior we want. What we are\n+                // doing is marking `#[structural_match]` with the\n+                // span of the `#[deriving(...)]` attribute (the\n+                // entire attribute, not just the `PartialEq` or `Eq`\n+                // part), but with the current backtrace. The current\n+                // backtrace will contain a topmost entry that IS this\n+                // `#[deriving(...)]` attribute and with the\n+                // \"allow-unstable\" flag set to true.\n+                //\n+                // Note that we do NOT use the span of the `Eq`\n+                // text itself. You might think this is\n+                // equivalent, because the `Eq` appears within the\n+                // `#[deriving(Eq)]` attribute, and hence we would\n+                // inherit the \"allows unstable\" from the\n+                // backtrace.  But in fact this is not always the\n+                // case. The actual source text that led to\n+                // deriving can be `#[$attr]`, for example, where\n+                // `$attr == deriving(Eq)`. In that case, the\n+                // \"#[structural_match]\" would be considered to\n+                // originate not from the deriving call but from\n+                // text outside the deriving call, and hence would\n+                // be forbidden from using unstable\n+                // content.\n+                //\n+                // See tests src/run-pass/rfc1445 for\n+                // examples. --nmatsakis\n+                let span = Span { expn_id: cx.backtrace(), .. span };\n+                assert!(cx.parse_sess.codemap().span_allows_unstable(span));\n+                debug!(\"inserting structural_match with span {:?}\", span);\n+                let structural_match = intern_and_get_ident(\"structural_match\");\n+                item.attrs.push(cx.attribute(span,\n+                                             cx.meta_word(span,\n+                                                          structural_match)));\n+            }\n+\n             item\n         })\n     }, |a| {\n         cx.span_err(span, \"`derive` can only be applied to items\");\n         a\n-    })\n+    });\n+    debug!(\"expand_derive: annotatable output = {:?}\", annot);\n+    annot\n }\n \n macro_rules! derive_traits {"}, {"sha": "f214ecdc3368dd4278ee4565b070b46c0bafb30c", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -24,6 +24,7 @@\n #![feature(str_char)]\n \n extern crate fmt_macros;\n+#[macro_use] extern crate log;\n #[macro_use]\n extern crate syntax;\n "}, {"sha": "f6b7e13c4f5e9328593e8bab6c99e8b233d8ffac", "filename": "src/test/compile-fail/issue-6804.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -24,9 +24,13 @@ fn main() { //~ ERROR compilation successful\n         _ => {},\n     };\n     //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead\n+    //~| WARNING floating point constants cannot be used\n+    //~| WARNING this was previously accepted\n     match [x, 1.0] {\n         [NAN, _] => {},\n         _ => {},\n     };\n     //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead\n+    //~| WARNING floating point constants cannot be used\n+    //~| WARNING this was previously accepted\n }"}, {"sha": "1f2d7819e26d8abc91c4d85af257cf930f12da9e", "filename": "src/test/compile-fail/rfc1445/feature-gate.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Fcompile-fail%2Frfc1445%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Fcompile-fail%2Frfc1445%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1445%2Ffeature-gate.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that structural match is only permitted with a feature gate,\n+// and that if a feature gate is supplied, it permits the type to be\n+// used in a match.\n+\n+// revisions: with_gate no_gate\n+\n+#![allow(dead_code)]\n+#![deny(future_incompatible)]\n+#![feature(rustc_attrs)]\n+#![cfg_attr(with_gate, feature(structural_match))]\n+\n+#[structural_match] //[no_gate]~ ERROR semantics of constant patterns is not yet settled\n+struct Foo {\n+    x: u32\n+}\n+\n+const FOO: Foo = Foo { x: 0 };\n+\n+#[rustc_error]\n+fn main() { //[with_gate]~ ERROR compilation successful\n+    let y = Foo { x: 1 };\n+    match y {\n+        FOO => { }\n+        _ => { }\n+    }\n+}"}, {"sha": "c573e3e8e28b27cb4d97e494cc5110051d493725", "filename": "src/test/compile-fail/rfc1445/match-forbidden-without-eq.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![deny(future_incompatible)]\n+\n+use std::f32;\n+\n+#[derive(PartialEq)]\n+struct Foo {\n+    x: u32\n+}\n+\n+const FOO: Foo = Foo { x: 0 };\n+\n+fn main() {\n+    let y = Foo { x: 1 };\n+    match y {\n+        FOO => { }\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARNING will become a hard error\n+        _ => { }\n+    }\n+\n+    let x = 0.0;\n+    match x {\n+        f32::INFINITY => { }\n+        //~^ ERROR floating point constants cannot be used in patterns\n+        //~| WARNING will become a hard error\n+        _ => { }\n+    }\n+}"}, {"sha": "029df08ebc37a99234834573c8572706f3d5d853", "filename": "src/test/compile-fail/rfc1445/match-requires-both-partialeq-and-eq.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![deny(future_incompatible)]\n+\n+#[derive(Eq)]\n+struct Foo {\n+    x: u32\n+}\n+\n+impl PartialEq for Foo {\n+    fn eq(&self, _: &Foo) -> bool {\n+        false // ha ha sucker!\n+    }\n+}\n+\n+const FOO: Foo = Foo { x: 0 };\n+\n+fn main() {\n+    let y = Foo { x: 1 };\n+    match y {\n+        FOO => { }\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARNING will become a hard error\n+        _ => { }\n+    }\n+}"}, {"sha": "6974238ac72f2cd4b6dd3d883cf27c60e8681e42", "filename": "src/test/debuginfo/constant-in-match-pattern.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -21,15 +21,18 @@\n \n const CONSTANT: u64 = 3;\n \n+#[derive(PartialEq, Eq)]\n struct Struct {\n     a: isize,\n     b: usize,\n }\n const STRUCT: Struct = Struct { a: 1, b: 2 };\n \n+#[derive(PartialEq, Eq)]\n struct TupleStruct(u32);\n const TUPLE_STRUCT: TupleStruct = TupleStruct(4);\n \n+#[derive(PartialEq, Eq)]\n enum Enum {\n     Variant1(char),\n     Variant2 { a: u8 },"}, {"sha": "01d1b27bfc99f803a42643588485cae13edbb471", "filename": "src/test/run-pass/associated-const-match-patterns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -17,6 +17,7 @@ use empty_struct::XEmpty2 as XFoo;\n \n struct Foo;\n \n+#[derive(PartialEq, Eq)]\n enum Bar {\n     Var1,\n     Var2,"}, {"sha": "0060150fbece01b90c07e411bfb31b4db4ae8a58", "filename": "src/test/run-pass/empty-struct-braces.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -18,7 +18,10 @@ use empty_struct::*;\n \n struct Empty1 {}\n struct Empty2;\n+\n+#[derive(PartialEq, Eq)]\n struct Empty3 {}\n+\n const Empty3: Empty3 = Empty3 {};\n \n enum E {"}, {"sha": "5c9ee74472b12c5047286d8fccc8e015cce43f73", "filename": "src/test/run-pass/issue-12860.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12860.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![feature(collections)]\n \n extern crate collections;"}, {"sha": "9700ed247959b43039d5bb8afebdf5a81be1b2e4", "filename": "src/test/run-pass/match-arm-statics.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -9,18 +9,24 @@\n // except according to those terms.\n \n \n+#[derive(PartialEq, Eq)]\n struct NewBool(bool);\n \n+#[derive(PartialEq, Eq)]\n enum Direction {\n     North,\n     East,\n     South,\n     West\n }\n+\n+#[derive(PartialEq, Eq)]\n struct Foo {\n     bar: Option<Direction>,\n     baz: NewBool\n }\n+\n+#[derive(PartialEq, Eq)]\n enum EnumWithStructVariants {\n     Variant1(bool),\n     Variant2 {\n@@ -37,7 +43,7 @@ const VARIANT2_NORTH: EnumWithStructVariants = EnumWithStructVariants::Variant2\n     dir: Direction::North };\n \n pub mod glfw {\n-    #[derive(Copy, Clone)]\n+    #[derive(Copy, Clone, PartialEq, Eq)]\n     pub struct InputState(usize);\n \n     pub const RELEASE  : InputState = InputState(0);\n@@ -82,13 +88,15 @@ fn issue_14576() {\n         _ => unreachable!()\n     }\n \n+    #[derive(PartialEq, Eq)]\n     enum C { D = 3, E = 4 }\n     const F : C = C::D;\n \n     assert_eq!(match C::D { F => 1, _ => 2, }, 1);\n }\n \n fn issue_13731() {\n+    #[derive(PartialEq, Eq)]\n     enum A { AA(()) }\n     const B: A = A::AA(());\n \n@@ -99,6 +107,7 @@ fn issue_13731() {\n \n fn issue_15393() {\n     #![allow(dead_code)]\n+    #[derive(PartialEq, Eq)]\n     struct Flags {\n         bits: usize\n     }"}, {"sha": "241fe6c6ab1e9a3c05bd86d58945ec9978145fde", "filename": "src/test/run-pass/rfc1445/eq-allows-match-on-ty-in-macro.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match-on-ty-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match-on-ty-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match-on-ty-in-macro.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+macro_rules! foo {\n+    (#[$attr:meta] $x:ident) => {\n+        #[$attr]\n+        struct $x {\n+            x: u32\n+        }\n+    }\n+}\n+\n+foo! { #[derive(PartialEq, Eq)] Foo }\n+\n+const FOO: Foo = Foo { x: 0 };\n+\n+fn main() {\n+    let y = Foo { x: 1 };\n+    match y {\n+        FOO => { }\n+        _ => { }\n+    }\n+}"}, {"sha": "f02a45625c9f6e5b10b655e9f7e6c9b92494bbcf", "filename": "src/test/run-pass/rfc1445/eq-allows-match.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b2ad8298f33984c64b98cfb354bb932b740ef/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match.rs?ref=128b2ad8298f33984c64b98cfb354bb932b740ef", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+#[derive(PartialEq, Eq)]\n+struct Foo {\n+    x: u32\n+}\n+\n+const FOO: Foo = Foo { x: 0 };\n+\n+fn main() {\n+    let y = Foo { x: 1 };\n+    match y {\n+        FOO => { }\n+        _ => { }\n+    }\n+}"}]}