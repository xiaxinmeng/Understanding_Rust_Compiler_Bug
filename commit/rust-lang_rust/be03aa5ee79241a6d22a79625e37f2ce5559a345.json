{"sha": "be03aa5ee79241a6d22a79625e37f2ce5559a345", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMDNhYTVlZTc5MjQxYTZkMjJhNzk2MjVlMzdmMmNlNTU1OWEzNDU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T12:26:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T20:23:30Z"}, "message": "extract tt cursor", "tree": {"sha": "441b0e765c8abd6b56cd4372c337645da9a8281d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/441b0e765c8abd6b56cd4372c337645da9a8281d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be03aa5ee79241a6d22a79625e37f2ce5559a345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be03aa5ee79241a6d22a79625e37f2ce5559a345", "html_url": "https://github.com/rust-lang/rust/commit/be03aa5ee79241a6d22a79625e37f2ce5559a345", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be03aa5ee79241a6d22a79625e37f2ce5559a345/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d5a8f085c966aec93cbde709ee9de8259a2b3e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d5a8f085c966aec93cbde709ee9de8259a2b3e1", "html_url": "https://github.com/rust-lang/rust/commit/8d5a8f085c966aec93cbde709ee9de8259a2b3e1"}], "stats": {"total": 197, "additions": 101, "deletions": 96}, "files": [{"sha": "e35a056ccf8c6af0f8777e55625f8da807459b25", "filename": "crates/ra_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be03aa5ee79241a6d22a79625e37f2ce5559a345/crates%2Fra_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be03aa5ee79241a6d22a79625e37f2ce5559a345/crates%2Fra_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Flib.rs?ref=be03aa5ee79241a6d22a79625e37f2ce5559a345", "patch": "@@ -12,5 +12,6 @@ macro_rules! impl_froms {\n \n pub mod tt;\n pub mod mbe;\n+mod tt_cursor;\n mod mbe_parser;\n mod mbe_expander;"}, {"sha": "6a168a1b5e259abbdca91b77899fc8f59a44702b", "filename": "crates/ra_macros/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be03aa5ee79241a6d22a79625e37f2ce5559a345/crates%2Fra_macros%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be03aa5ee79241a6d22a79625e37f2ce5559a345/crates%2Fra_macros%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Fmbe.rs?ref=be03aa5ee79241a6d22a79625e37f2ce5559a345", "patch": "@@ -1,6 +1,6 @@\n use smol_str::SmolStr;\n \n-use crate::tt::{self, Delimiter};\n+use crate::tt::Delimiter;\n \n pub use crate::{\n     mbe_parser::parse,"}, {"sha": "024d3a0404acfcece0dc416dda5eb70e0b3224a9", "filename": "crates/ra_macros/src/mbe_parser.rs", "status": "modified", "additions": 7, "deletions": 95, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/be03aa5ee79241a6d22a79625e37f2ce5559a345/crates%2Fra_macros%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be03aa5ee79241a6d22a79625e37f2ce5559a345/crates%2Fra_macros%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Fmbe_parser.rs?ref=be03aa5ee79241a6d22a79625e37f2ce5559a345", "patch": "@@ -1,107 +1,20 @@\n use crate::{tt, mbe};\n+use crate::tt_cursor::TtCursor;\n \n /// This module parses a raw `tt::TokenStream` into macro-by-example token\n /// stream. This is a *mostly* identify function, expect for handling of\n /// `$var:tt_kind` and `$(repeat),*` constructs.\n \n-struct RulesParser<'a> {\n-    subtree: &'a tt::Subtree,\n-    pos: usize,\n-}\n-\n-impl<'a> RulesParser<'a> {\n-    fn new(subtree: &'a tt::Subtree) -> RulesParser<'a> {\n-        RulesParser { subtree, pos: 0 }\n-    }\n-\n-    fn is_eof(&self) -> bool {\n-        self.pos == self.subtree.token_trees.len()\n-    }\n-\n-    fn current(&self) -> Option<&'a tt::TokenTree> {\n-        self.subtree.token_trees.get(self.pos)\n-    }\n-\n-    fn at_punct(&self) -> Option<&'a tt::Punct> {\n-        match self.current() {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(it))) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    fn at_char(&self, char: char) -> bool {\n-        match self.at_punct() {\n-            Some(tt::Punct { char: c }) if *c == char => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn at_ident(&mut self) -> Option<&'a tt::Ident> {\n-        match self.current() {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Ident(i))) => Some(i),\n-            _ => None,\n-        }\n-    }\n-\n-    fn bump(&mut self) {\n-        self.pos += 1;\n-    }\n-\n-    fn eat(&mut self) -> Option<&'a tt::TokenTree> {\n-        match self.current() {\n-            Some(it) => {\n-                self.bump();\n-                Some(it)\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn eat_subtree(&mut self) -> Option<&'a tt::Subtree> {\n-        match self.current()? {\n-            tt::TokenTree::Subtree(sub) => {\n-                self.bump();\n-                Some(sub)\n-            }\n-            _ => return None,\n-        }\n-    }\n-\n-    fn eat_punct(&mut self) -> Option<&'a tt::Punct> {\n-        if let Some(it) = self.at_punct() {\n-            self.bump();\n-            return Some(it);\n-        }\n-        None\n-    }\n-\n-    fn eat_ident(&mut self) -> Option<&'a tt::Ident> {\n-        if let Some(i) = self.at_ident() {\n-            self.bump();\n-            return Some(i);\n-        }\n-        None\n-    }\n-\n-    fn expect_char(&mut self, char: char) -> Option<()> {\n-        if self.at_char(char) {\n-            self.bump();\n-            return Some(());\n-        }\n-        None\n-    }\n-}\n-\n pub fn parse(tt: &tt::Subtree) -> Option<mbe::MacroRules> {\n-    let mut parser = RulesParser::new(tt);\n+    let mut parser = TtCursor::new(tt);\n     let mut rules = Vec::new();\n     while !parser.is_eof() {\n         rules.push(parse_rule(&mut parser)?)\n     }\n     Some(mbe::MacroRules { rules })\n }\n \n-fn parse_rule(p: &mut RulesParser) -> Option<mbe::Rule> {\n+fn parse_rule(p: &mut TtCursor) -> Option<mbe::Rule> {\n     let lhs = parse_subtree(p.eat_subtree()?)?;\n     p.expect_char('=')?;\n     p.expect_char('>')?;\n@@ -111,7 +24,7 @@ fn parse_rule(p: &mut RulesParser) -> Option<mbe::Rule> {\n \n fn parse_subtree(tt: &tt::Subtree) -> Option<mbe::Subtree> {\n     let mut token_trees = Vec::new();\n-    let mut p = RulesParser::new(tt);\n+    let mut p = TtCursor::new(tt);\n     while let Some(tt) = p.eat() {\n         let child: mbe::TokenTree = match tt {\n             tt::TokenTree::Leaf(leaf) => match leaf {\n@@ -142,16 +55,15 @@ fn parse_subtree(tt: &tt::Subtree) -> Option<mbe::Subtree> {\n     })\n }\n \n-fn parse_var(p: &mut RulesParser) -> Option<mbe::Var> {\n+fn parse_var(p: &mut TtCursor) -> Option<mbe::Var> {\n     let ident = p.eat_ident().unwrap();\n     let text = ident.text.clone();\n     let kind = if p.at_char(':') {\n         p.bump();\n         if let Some(ident) = p.eat_ident() {\n             Some(ident.text.clone())\n         } else {\n-            // ugly as hell :(\n-            p.pos -= 1;\n+            p.rev_bump();\n             None\n         }\n     } else {\n@@ -160,7 +72,7 @@ fn parse_var(p: &mut RulesParser) -> Option<mbe::Var> {\n     Some(mbe::Var { text, kind })\n }\n \n-fn parse_repeat(p: &mut RulesParser) -> Option<mbe::Repeat> {\n+fn parse_repeat(p: &mut TtCursor) -> Option<mbe::Repeat> {\n     let subtree = p.eat_subtree().unwrap();\n     let subtree = parse_subtree(subtree)?;\n     let sep = p.eat_punct()?;"}, {"sha": "380c60b408095a0b1bf0610a69c19a6f1d51c06c", "filename": "crates/ra_macros/src/tt_cursor.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/be03aa5ee79241a6d22a79625e37f2ce5559a345/crates%2Fra_macros%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be03aa5ee79241a6d22a79625e37f2ce5559a345/crates%2Fra_macros%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Ftt_cursor.rs?ref=be03aa5ee79241a6d22a79625e37f2ce5559a345", "patch": "@@ -0,0 +1,92 @@\n+use crate::tt;\n+\n+pub(crate) struct TtCursor<'a> {\n+    subtree: &'a tt::Subtree,\n+    pos: usize,\n+}\n+\n+impl<'a> TtCursor<'a> {\n+    pub(crate) fn new(subtree: &'a tt::Subtree) -> TtCursor<'a> {\n+        TtCursor { subtree, pos: 0 }\n+    }\n+\n+    pub(crate) fn is_eof(&self) -> bool {\n+        self.pos == self.subtree.token_trees.len()\n+    }\n+\n+    pub(crate) fn current(&self) -> Option<&'a tt::TokenTree> {\n+        self.subtree.token_trees.get(self.pos)\n+    }\n+\n+    pub(crate) fn at_punct(&self) -> Option<&'a tt::Punct> {\n+        match self.current() {\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(it))) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    pub(crate) fn at_char(&self, char: char) -> bool {\n+        match self.at_punct() {\n+            Some(tt::Punct { char: c }) if *c == char => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub(crate) fn at_ident(&mut self) -> Option<&'a tt::Ident> {\n+        match self.current() {\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Ident(i))) => Some(i),\n+            _ => None,\n+        }\n+    }\n+\n+    pub(crate) fn bump(&mut self) {\n+        self.pos += 1;\n+    }\n+    pub(crate) fn rev_bump(&mut self) {\n+        self.pos -= 1;\n+    }\n+\n+    pub(crate) fn eat(&mut self) -> Option<&'a tt::TokenTree> {\n+        match self.current() {\n+            Some(it) => {\n+                self.bump();\n+                Some(it)\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    pub(crate) fn eat_subtree(&mut self) -> Option<&'a tt::Subtree> {\n+        match self.current()? {\n+            tt::TokenTree::Subtree(sub) => {\n+                self.bump();\n+                Some(sub)\n+            }\n+            _ => return None,\n+        }\n+    }\n+\n+    pub(crate) fn eat_punct(&mut self) -> Option<&'a tt::Punct> {\n+        if let Some(it) = self.at_punct() {\n+            self.bump();\n+            return Some(it);\n+        }\n+        None\n+    }\n+\n+    pub(crate) fn eat_ident(&mut self) -> Option<&'a tt::Ident> {\n+        if let Some(i) = self.at_ident() {\n+            self.bump();\n+            return Some(i);\n+        }\n+        None\n+    }\n+\n+    pub(crate) fn expect_char(&mut self, char: char) -> Option<()> {\n+        if self.at_char(char) {\n+            self.bump();\n+            return Some(());\n+        }\n+        None\n+    }\n+}"}]}