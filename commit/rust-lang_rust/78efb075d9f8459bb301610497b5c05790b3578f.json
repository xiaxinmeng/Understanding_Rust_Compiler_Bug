{"sha": "78efb075d9f8459bb301610497b5c05790b3578f", "node_id": "C_kwDOAAsO6NoAKDc4ZWZiMDc1ZDlmODQ1OWJiMzAxNjEwNDk3YjVjMDU3OTBiMzU3OGY", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2022-01-28T01:21:30Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2022-01-30T21:20:54Z"}, "message": "review the total_cmp documentation\n\nThe documentation has been restructured to split out a brief summary\nparagraph out from the following elaborating paragraphs.\n\nI also attempted my hand at wording improvements and adding articles\nwhere I felt them missing, but being non-native english speaker these\nmay need more thorough review.", "tree": {"sha": "97480b940ee60bd029562a019b2a4d0f28293d06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97480b940ee60bd029562a019b2a4d0f28293d06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78efb075d9f8459bb301610497b5c05790b3578f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78efb075d9f8459bb301610497b5c05790b3578f", "html_url": "https://github.com/rust-lang/rust/commit/78efb075d9f8459bb301610497b5c05790b3578f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78efb075d9f8459bb301610497b5c05790b3578f/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c7f2bf44f7fafaa4546814e54add786429e5f76", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7f2bf44f7fafaa4546814e54add786429e5f76", "html_url": "https://github.com/rust-lang/rust/commit/8c7f2bf44f7fafaa4546814e54add786429e5f76"}], "stats": {"total": 92, "additions": 54, "deletions": 38}, "files": [{"sha": "d8dcfdafa8df9d0af4543eeed547e16677145211", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/78efb075d9f8459bb301610497b5c05790b3578f/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78efb075d9f8459bb301610497b5c05790b3578f/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=78efb075d9f8459bb301610497b5c05790b3578f", "patch": "@@ -1008,29 +1008,37 @@ impl f32 {\n         Self::from_bits(u32::from_ne_bytes(bytes))\n     }\n \n-    /// Returns an ordering between self and other values.\n+    /// Return the ordering between `self` and `other`.\n+    ///\n     /// Unlike the standard partial comparison between floating point numbers,\n     /// this comparison always produces an ordering in accordance to\n-    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n-    /// floating point standard. The values are ordered in following order:\n-    /// - Negative quiet NaN\n-    /// - Negative signaling NaN\n-    /// - Negative infinity\n-    /// - Negative numbers\n-    /// - Negative subnormal numbers\n-    /// - Negative zero\n-    /// - Positive zero\n-    /// - Positive subnormal numbers\n-    /// - Positive numbers\n-    /// - Positive infinity\n-    /// - Positive signaling NaN\n-    /// - Positive quiet NaN\n-    ///\n-    /// Note that this function does not always agree with the [`PartialOrd`]\n-    /// and [`PartialEq`] implementations of `f32`. In particular, they regard\n-    /// negative and positive zero as equal, while `total_cmp` doesn't.\n+    /// the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)\n+    /// floating point standard. The values are ordered in the following sequence:\n+    ///\n+    /// - negative quiet NaN\n+    /// - negative signaling NaN\n+    /// - negative infinity\n+    /// - negative numbers\n+    /// - negative subnormal numbers\n+    /// - negative zero\n+    /// - positive zero\n+    /// - positive subnormal numbers\n+    /// - positive numbers\n+    /// - positive infinity\n+    /// - positive signaling NaN\n+    /// - positive quiet NaN.\n+    ///\n+    /// The ordering established by this function does not always agree with the\n+    /// [`PartialOrd`] and [`PartialEq`] implementations of `f32`. For example,\n+    /// they consider negative and positive zero equal, while `total_cmp`\n+    /// doesn't.\n+    ///\n+    /// The interpretation of the signaling NaN bit follows the definition in\n+    /// the IEEE 754 standard, which may not match the interpretation by some of\n+    /// the older, non-conformant (e.g. MIPS) hardware implementations.\n     ///\n     /// # Example\n+    ///\n     /// ```\n     /// #![feature(total_cmp)]\n     /// struct GoodBoy {"}, {"sha": "7c2f51ff64639db45dad8dce1543c9004b04f5a5", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/78efb075d9f8459bb301610497b5c05790b3578f/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78efb075d9f8459bb301610497b5c05790b3578f/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=78efb075d9f8459bb301610497b5c05790b3578f", "patch": "@@ -1024,29 +1024,37 @@ impl f64 {\n         Self::from_bits(u64::from_ne_bytes(bytes))\n     }\n \n-    /// Returns an ordering between self and other values.\n+    /// Return the ordering between `self` and `other`.\n+    ///\n     /// Unlike the standard partial comparison between floating point numbers,\n     /// this comparison always produces an ordering in accordance to\n-    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n-    /// floating point standard. The values are ordered in following order:\n-    /// - Negative quiet NaN\n-    /// - Negative signaling NaN\n-    /// - Negative infinity\n-    /// - Negative numbers\n-    /// - Negative subnormal numbers\n-    /// - Negative zero\n-    /// - Positive zero\n-    /// - Positive subnormal numbers\n-    /// - Positive numbers\n-    /// - Positive infinity\n-    /// - Positive signaling NaN\n-    /// - Positive quiet NaN\n-    ///\n-    /// Note that this function does not always agree with the [`PartialOrd`]\n-    /// and [`PartialEq`] implementations of `f64`. In particular, they regard\n-    /// negative and positive zero as equal, while `total_cmp` doesn't.\n+    /// the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)\n+    /// floating point standard. The values are ordered in the following sequence:\n+    ///\n+    /// - negative quiet NaN\n+    /// - negative signaling NaN\n+    /// - negative infinity\n+    /// - negative numbers\n+    /// - negative subnormal numbers\n+    /// - negative zero\n+    /// - positive zero\n+    /// - positive subnormal numbers\n+    /// - positive numbers\n+    /// - positive infinity\n+    /// - positive signaling NaN\n+    /// - positive quiet NaN.\n+    ///\n+    /// The ordering established by this function does not always agree with the\n+    /// [`PartialOrd`] and [`PartialEq`] implementations of `f64`. For example,\n+    /// they consider negative and positive zero equal, while `total_cmp`\n+    /// doesn't.\n+    ///\n+    /// The interpretation of the signaling NaN bit follows the definition in\n+    /// the IEEE 754 standard, which may not match the interpretation by some of\n+    /// the older, non-conformant (e.g. MIPS) hardware implementations.\n     ///\n     /// # Example\n+    ///\n     /// ```\n     /// #![feature(total_cmp)]\n     /// struct GoodBoy {"}]}