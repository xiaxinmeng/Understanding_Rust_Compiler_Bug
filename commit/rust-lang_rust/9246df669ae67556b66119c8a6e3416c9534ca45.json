{"sha": "9246df669ae67556b66119c8a6e3416c9534ca45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNDZkZjY2OWFlNjc1NTZiNjYxMTljOGE2ZTM0MTZjOTUzNGNhNDU=", "commit": {"author": {"name": "Daniel McNab", "email": "36049421+DJMcNab@users.noreply.github.com", "date": "2021-03-07T12:24:20Z"}, "committer": {"name": "Daniel McNab", "email": "36049421+DJMcNab@users.noreply.github.com", "date": "2021-03-07T12:24:20Z"}, "message": "Require opt in to rustc_private\n\nThis gives the advantage that\n\nA future extension would be to check for `feature(rustc_private)` instead", "tree": {"sha": "cdc4cdbf90dd73c4887a17231503b2663e4d66d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdc4cdbf90dd73c4887a17231503b2663e4d66d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9246df669ae67556b66119c8a6e3416c9534ca45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9246df669ae67556b66119c8a6e3416c9534ca45", "html_url": "https://github.com/rust-lang/rust/commit/9246df669ae67556b66119c8a6e3416c9534ca45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9246df669ae67556b66119c8a6e3416c9534ca45/comments", "author": {"login": "DJMcNab", "id": 36049421, "node_id": "MDQ6VXNlcjM2MDQ5NDIx", "avatar_url": "https://avatars.githubusercontent.com/u/36049421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DJMcNab", "html_url": "https://github.com/DJMcNab", "followers_url": "https://api.github.com/users/DJMcNab/followers", "following_url": "https://api.github.com/users/DJMcNab/following{/other_user}", "gists_url": "https://api.github.com/users/DJMcNab/gists{/gist_id}", "starred_url": "https://api.github.com/users/DJMcNab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DJMcNab/subscriptions", "organizations_url": "https://api.github.com/users/DJMcNab/orgs", "repos_url": "https://api.github.com/users/DJMcNab/repos", "events_url": "https://api.github.com/users/DJMcNab/events{/privacy}", "received_events_url": "https://api.github.com/users/DJMcNab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DJMcNab", "id": 36049421, "node_id": "MDQ6VXNlcjM2MDQ5NDIx", "avatar_url": "https://avatars.githubusercontent.com/u/36049421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DJMcNab", "html_url": "https://github.com/DJMcNab", "followers_url": "https://api.github.com/users/DJMcNab/followers", "following_url": "https://api.github.com/users/DJMcNab/following{/other_user}", "gists_url": "https://api.github.com/users/DJMcNab/gists{/gist_id}", "starred_url": "https://api.github.com/users/DJMcNab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DJMcNab/subscriptions", "organizations_url": "https://api.github.com/users/DJMcNab/orgs", "repos_url": "https://api.github.com/users/DJMcNab/repos", "events_url": "https://api.github.com/users/DJMcNab/events{/privacy}", "received_events_url": "https://api.github.com/users/DJMcNab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71a254c1a1b8836db09dfd18a781c1a4215366fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/71a254c1a1b8836db09dfd18a781c1a4215366fc", "html_url": "https://github.com/rust-lang/rust/commit/71a254c1a1b8836db09dfd18a781c1a4215366fc"}], "stats": {"total": 140, "additions": 70, "deletions": 70}, "files": [{"sha": "bc6e203414ee3590614b0f5946e742e6b4e1daef", "filename": "crates/project_model/src/cargo_workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9246df669ae67556b66119c8a6e3416c9534ca45/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9246df669ae67556b66119c8a6e3416c9534ca45/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs?ref=9246df669ae67556b66119c8a6e3416c9534ca45", "patch": "@@ -112,7 +112,7 @@ pub struct PackageData {\n \n #[derive(Deserialize, Default, Debug, Clone, Eq, PartialEq)]\n pub struct RustAnalyzerPackageMetaData {\n-    pub rustc_private: Option<bool>,\n+    pub rustc_private: bool,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]"}, {"sha": "b969420cf3c86460ff43822c142cc3381cf0539d", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/9246df669ae67556b66119c8a6e3416c9534ca45/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9246df669ae67556b66119c8a6e3416c9534ca45/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=9246df669ae67556b66119c8a6e3416c9534ca45", "patch": "@@ -376,9 +376,10 @@ fn cargo_to_crate_graph(\n     cfg_options.insert_atom(\"debug_assertions\".into());\n \n     let mut pkg_crates = FxHashMap::default();\n-\n+    let mut has_private = false;\n     // Next, create crates for each package, target pair\n     for pkg in cargo.packages() {\n+        has_private |= cargo[pkg].metadata.rustc_private;\n         let mut lib_tgt = None;\n         for &tgt in cargo[pkg].targets.iter() {\n             if let Some(file_id) = load(&cargo[tgt].root) {\n@@ -441,89 +442,88 @@ fn cargo_to_crate_graph(\n \n     let mut rustc_pkg_crates = FxHashMap::default();\n \n-    // If the user provided a path to rustc sources, we add all the rustc_private crates\n-    // and create dependencies on them for the crates which opt-in to that\n-    if let Some(rustc_workspace) = rustc {\n-        // rustc-dev crates start from 'rustc_driver'\n-        // Therefore, we collect all crates which are transitive dependencies of rustc_driver\n-        if let Some(root_pkg) = rustc_workspace\n-            .packages()\n-            .find(|package| rustc_workspace[*package].name == \"rustc_driver\")\n-        {\n-            let mut queue = VecDeque::new();\n-            queue.push_back(root_pkg);\n-            while let Some(pkg) = queue.pop_front() {\n-                if rustc_pkg_crates.contains_key(&pkg) {\n-                    continue;\n-                }\n-                for dep in &rustc_workspace[pkg].dependencies {\n-                    queue.push_back(dep.pkg);\n-                }\n-                for &tgt in rustc_workspace[pkg].targets.iter() {\n-                    if rustc_workspace[tgt].kind != TargetKind::Lib {\n+    if has_private {\n+        // If the user provided a path to rustc sources, we add all the rustc_private crates\n+        // and create dependencies on them for the crates which opt-in to that\n+        if let Some(rustc_workspace) = rustc {\n+            // rustc-dev crates start from 'rustc_driver'\n+            // We want to collect all crates which are transitive dependencies of rustc_driver\n+            if let Some(root_pkg) = rustc_workspace\n+                .packages()\n+                .find(|package| rustc_workspace[*package].name == \"rustc_driver\")\n+            {\n+                let mut queue = VecDeque::new();\n+                queue.push_back(root_pkg);\n+                while let Some(pkg) = queue.pop_front() {\n+                    // Don't duplicate packages\n+                    if rustc_pkg_crates.contains_key(&pkg) {\n                         continue;\n                     }\n-                    if let Some(file_id) = load(&rustc_workspace[tgt].root) {\n-                        let crate_id = add_target_crate_root(\n-                            &mut crate_graph,\n-                            &rustc_workspace[pkg],\n-                            rustc_build_data_map.and_then(|it| it.get(&rustc_workspace[pkg].id)),\n-                            &cfg_options,\n-                            proc_macro_loader,\n-                            file_id,\n-                        );\n-                        pkg_to_lib_crate.insert(pkg, crate_id);\n-                        // Add dependencies on the core / std / alloc for rustc\n-                        for (name, krate) in public_deps.iter() {\n-                            add_dep(&mut crate_graph, crate_id, name.clone(), *krate);\n+                    for dep in &rustc_workspace[pkg].dependencies {\n+                        queue.push_back(dep.pkg);\n+                    }\n+                    for &tgt in rustc_workspace[pkg].targets.iter() {\n+                        if rustc_workspace[tgt].kind != TargetKind::Lib {\n+                            continue;\n+                        }\n+                        if let Some(file_id) = load(&rustc_workspace[tgt].root) {\n+                            let crate_id = add_target_crate_root(\n+                                &mut crate_graph,\n+                                &rustc_workspace[pkg],\n+                                rustc_build_data_map\n+                                    .and_then(|it| it.get(&rustc_workspace[pkg].id)),\n+                                &cfg_options,\n+                                proc_macro_loader,\n+                                file_id,\n+                            );\n+                            pkg_to_lib_crate.insert(pkg, crate_id);\n+                            // Add dependencies on the core / std / alloc for rustc\n+                            for (name, krate) in public_deps.iter() {\n+                                add_dep(&mut crate_graph, crate_id, name.clone(), *krate);\n+                            }\n+                            rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n                         }\n-                        rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n                     }\n                 }\n             }\n-        }\n-        // Now add a dep edge from all targets of upstream to the lib\n-        // target of downstream.\n-        for pkg in rustc_pkg_crates.keys().copied() {\n-            for dep in rustc_workspace[pkg].dependencies.iter() {\n-                let name = CrateName::new(&dep.name).unwrap();\n-                if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                    for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n-                        add_dep(&mut crate_graph, from, name.clone(), to);\n+            // Now add a dep edge from all targets of upstream to the lib\n+            // target of downstream.\n+            for pkg in rustc_pkg_crates.keys().copied() {\n+                for dep in rustc_workspace[pkg].dependencies.iter() {\n+                    let name = CrateName::new(&dep.name).unwrap();\n+                    if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                        for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n+                            add_dep(&mut crate_graph, from, name.clone(), to);\n+                        }\n                     }\n                 }\n             }\n-        }\n \n-        // Add dependencies for all crates which opt in to rustc_private libraries\n-        for dep in rustc_workspace.packages() {\n-            let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n-\n-            if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n-                for pkg in cargo.packages() {\n-                    let package = &cargo[pkg];\n-                    if matches!(\n-                        (package.is_member, package.metadata.rustc_private),\n-                        (true, Some(false)) | (false, Some(false)) | (false, None)\n-                    ) {\n-                        continue;\n-                    }\n-                    for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                        // Avoid creating duplicate dependencies\n-                        if !crate_graph[from].dependencies.iter().any(|d| d.name == name) {\n-                            add_dep(&mut crate_graph, from, name.clone(), to);\n-                        } else {\n-                            eprintln!(\n-                                \"Skipped {} for {:?}\",\n-                                &name, &crate_graph[from].display_name\n-                            );\n+            // Add dependencies for all crates which opt in to rustc_private libraries\n+            for dep in rustc_workspace.packages() {\n+                let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n+\n+                if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n+                    for pkg in cargo.packages() {\n+                        let package = &cargo[pkg];\n+                        if !package.metadata.rustc_private {\n+                            continue;\n+                        }\n+                        for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                            // Avoid creating duplicate dependencies\n+                            if !crate_graph[from].dependencies.iter().any(|d| d.name == name) {\n+                                add_dep(&mut crate_graph, from, name.clone(), to);\n+                            } else {\n+                                eprintln!(\n+                                    \"Skipped {} for {:?}\",\n+                                    &name, &crate_graph[from].display_name\n+                                );\n+                            }\n                         }\n                     }\n                 }\n             }\n         }\n-    } else {\n-        eprintln!(\"No cargo workspace\");\n     }\n     crate_graph\n }"}]}