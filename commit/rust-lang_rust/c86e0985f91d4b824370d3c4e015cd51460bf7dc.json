{"sha": "c86e0985f91d4b824370d3c4e015cd51460bf7dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NmUwOTg1ZjkxZDRiODI0MzcwZDNjNGUwMTVjZDUxNDYwYmY3ZGM=", "commit": {"author": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-04-02T15:37:52Z"}, "committer": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-04-02T15:37:52Z"}, "message": "Introduce `get_process_heap` and fix atomic ordering.", "tree": {"sha": "221e501daa924c7a0db3bd762646eed4968703b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/221e501daa924c7a0db3bd762646eed4968703b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c86e0985f91d4b824370d3c4e015cd51460bf7dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c86e0985f91d4b824370d3c4e015cd51460bf7dc", "html_url": "https://github.com/rust-lang/rust/commit/c86e0985f91d4b824370d3c4e015cd51460bf7dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c86e0985f91d4b824370d3c4e015cd51460bf7dc/comments", "author": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cce9e3db2d8a93fe72994e0a39e15e69cdbc7c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cce9e3db2d8a93fe72994e0a39e15e69cdbc7c2", "html_url": "https://github.com/rust-lang/rust/commit/4cce9e3db2d8a93fe72994e0a39e15e69cdbc7c2"}], "stats": {"total": 35, "additions": 22, "deletions": 13}, "files": [{"sha": "182743998d62f24f4b2e2c9660e7c7844ca7531b", "filename": "library/std/src/sys/windows/alloc.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c86e0985f91d4b824370d3c4e015cd51460bf7dc/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86e0985f91d4b824370d3c4e015cd51460bf7dc/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs?ref=c86e0985f91d4b824370d3c4e015cd51460bf7dc", "patch": "@@ -89,18 +89,18 @@ extern \"system\" {\n static HEAP: AtomicPtr<c_void> = AtomicPtr::new(ptr::null_mut());\n \n // Get a handle to the default heap of the current process, or null if the operation fails.\n-// SAFETY: If this operation is successful, `HEAP` will be successfully initialized and contain\n+// If this operation is successful, `HEAP` will be successfully initialized and contain\n // a non-null handle returned by `GetProcessHeap`.\n #[inline]\n-unsafe fn init_or_get_process_heap() -> c::HANDLE {\n+fn init_or_get_process_heap() -> c::HANDLE {\n     let heap = HEAP.load(Ordering::Relaxed);\n     if heap.is_null() {\n         // `HEAP` has not yet been successfully initialized\n         let heap = unsafe { GetProcessHeap() };\n         if !heap.is_null() {\n             // SAFETY: No locking is needed because within the same process,\n             // successful calls to `GetProcessHeap` will always return the same value, even on different threads.\n-            HEAP.store(heap, Ordering::Relaxed);\n+            HEAP.store(heap, Ordering::Release);\n \n             // SAFETY: `HEAP` contains a non-null handle returned by `GetProcessHeap`\n             heap\n@@ -114,16 +114,25 @@ unsafe fn init_or_get_process_heap() -> c::HANDLE {\n     }\n }\n \n+// Get a non-null handle to the default heap of the current process.\n+// SAFETY: `HEAP` must have been successfully initialized.\n+#[inline]\n+unsafe fn get_process_heap() -> c::HANDLE {\n+    HEAP.load(Ordering::Acquire)\n+}\n+\n // Header containing a pointer to the start of an allocated block.\n // SAFETY: Size and alignment must be <= `MIN_ALIGN`.\n #[repr(C)]\n struct Header(*mut u8);\n \n // Allocate a block of optionally zeroed memory for a given `layout`.\n-// SAFETY: Returns a pointer satisfying the guarantees of `System` about allocated pointers.\n+// SAFETY: Returns a pointer satisfying the guarantees of `System` about allocated pointers,\n+// or null if the operation fails. If this returns non-null `HEAP` will have been successfully\n+// initialized.\n #[inline]\n unsafe fn allocate(layout: Layout, zeroed: bool) -> *mut u8 {\n-    let heap = unsafe { init_or_get_process_heap() };\n+    let heap = init_or_get_process_heap();\n     if heap.is_null() {\n         // Allocation has failed, could not get the current process heap.\n         return ptr::null_mut();\n@@ -209,11 +218,11 @@ unsafe impl GlobalAlloc for System {\n         };\n \n         // SAFETY: because `ptr` has been successfully allocated with this allocator,\n-        // `HEAP` must have been successfully initialized and contain a non-null handle\n-        // returned by `GetProcessHeap`.\n-        let heap = HEAP.load(Ordering::Relaxed);\n+        // `HEAP` must have been successfully initialized.\n+        let heap = unsafe { get_process_heap() };\n \n-        // SAFETY: `block` is a pointer to the start of an allocated block.\n+        // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`,\n+        // `block` is a pointer to the start of an allocated block.\n         unsafe {\n             let err = HeapFree(heap, 0, block as c::LPVOID);\n             debug_assert!(err != 0, \"Failed to free heap memory: {}\", c::GetLastError());\n@@ -224,11 +233,11 @@ unsafe impl GlobalAlloc for System {\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n         if layout.align() <= MIN_ALIGN {\n             // SAFETY: because `ptr` has been successfully allocated with this allocator,\n-            // `HEAP` must have been successfully initialized and contain a non-null handle\n-            // returned by `GetProcessHeap`.\n-            let heap = HEAP.load(Ordering::Relaxed);\n+            // `HEAP` must have been successfully initialized.\n+            let heap = unsafe { get_process_heap() };\n \n-            // SAFETY: `ptr` is a pointer to the start of an allocated block.\n+            // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`,\n+            // `ptr` is a pointer to the start of an allocated block.\n             // The returned pointer points to the start of an allocated block.\n             unsafe { HeapReAlloc(heap, 0, ptr as c::LPVOID, new_size) as *mut u8 }\n         } else {"}]}