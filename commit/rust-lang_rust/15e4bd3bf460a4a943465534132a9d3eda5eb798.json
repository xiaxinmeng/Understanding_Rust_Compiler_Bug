{"sha": "15e4bd3bf460a4a943465534132a9d3eda5eb798", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZTRiZDNiZjQ2MGE0YTk0MzQ2NTUzNDEzMmE5ZDNlZGE1ZWI3OTg=", "commit": {"author": {"name": "David Rheinsberg", "email": "david.rheinsberg@gmail.com", "date": "2019-02-13T10:50:09Z"}, "committer": {"name": "David Rheinsberg", "email": "david.rheinsberg@gmail.com", "date": "2019-02-13T10:55:17Z"}, "message": "target/uefi: clarify documentation\n\nThis clarifies why FP-units are disabled on UEFI targets, as well as\nwhy we must opt into the NXCOMPAT feature.\n\nI did find some time to investigate why GRUB and friends disable FP on\nUEFI. The specification explicitly allows using MMX/SSE/AVX, but as it\nturns out it does not mandate enabling the instruction sets explicitly.\nHence, any use of these instructions will trigger CPU exceptions,\nunless an application explicitly enables them (which is not an option,\nas these are global flags that better be controlled by the\nkernel/firmware).\n\nFurthermore, UEFI systems are allowed to mark any non-code page as\nnon-executable. Hence, we must make sure to never place code on the\nstack or heap. So we better pass /NXCOMPAT to the linker for it to\ncomplain if it ever places code in non-code pages.\n\nLastly, this fixes some typos in related comments.", "tree": {"sha": "76669c1bfed1e1aa5295c191f76972c518fc1833", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76669c1bfed1e1aa5295c191f76972c518fc1833"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15e4bd3bf460a4a943465534132a9d3eda5eb798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15e4bd3bf460a4a943465534132a9d3eda5eb798", "html_url": "https://github.com/rust-lang/rust/commit/15e4bd3bf460a4a943465534132a9d3eda5eb798", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15e4bd3bf460a4a943465534132a9d3eda5eb798/comments", "author": {"login": "dvdhrm", "id": 623857, "node_id": "MDQ6VXNlcjYyMzg1Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/623857?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dvdhrm", "html_url": "https://github.com/dvdhrm", "followers_url": "https://api.github.com/users/dvdhrm/followers", "following_url": "https://api.github.com/users/dvdhrm/following{/other_user}", "gists_url": "https://api.github.com/users/dvdhrm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dvdhrm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dvdhrm/subscriptions", "organizations_url": "https://api.github.com/users/dvdhrm/orgs", "repos_url": "https://api.github.com/users/dvdhrm/repos", "events_url": "https://api.github.com/users/dvdhrm/events{/privacy}", "received_events_url": "https://api.github.com/users/dvdhrm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dvdhrm", "id": 623857, "node_id": "MDQ6VXNlcjYyMzg1Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/623857?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dvdhrm", "html_url": "https://github.com/dvdhrm", "followers_url": "https://api.github.com/users/dvdhrm/followers", "following_url": "https://api.github.com/users/dvdhrm/following{/other_user}", "gists_url": "https://api.github.com/users/dvdhrm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dvdhrm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dvdhrm/subscriptions", "organizations_url": "https://api.github.com/users/dvdhrm/orgs", "repos_url": "https://api.github.com/users/dvdhrm/repos", "events_url": "https://api.github.com/users/dvdhrm/events{/privacy}", "received_events_url": "https://api.github.com/users/dvdhrm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "827a141466e7bb85eb3c030600878a2c606019e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/827a141466e7bb85eb3c030600878a2c606019e9", "html_url": "https://github.com/rust-lang/rust/commit/827a141466e7bb85eb3c030600878a2c606019e9"}], "stats": {"total": 29, "additions": 17, "deletions": 12}, "files": [{"sha": "631966c09a498b23684277add55609c33830dd27", "filename": "src/librustc_target/spec/uefi_base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15e4bd3bf460a4a943465534132a9d3eda5eb798/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e4bd3bf460a4a943465534132a9d3eda5eb798/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs?ref=15e4bd3bf460a4a943465534132a9d3eda5eb798", "patch": "@@ -5,7 +5,7 @@\n // UEFI uses COFF/PE32+ format for binaries. All binaries must be statically linked. No dynamic\n // linker is supported. As native to COFF, binaries are position-dependent, but will be relocated\n // by the loader if the pre-chosen memory location is already in use.\n-// UEFI forbids running code on anything but the boot-CPU. Not interrupts are allowed other than\n+// UEFI forbids running code on anything but the boot-CPU. No interrupts are allowed other than\n // the timer-interrupt. Device-drivers are required to use polling-based models. Furthermore, all\n // code runs in the same environment, no process separation is supported.\n \n@@ -21,7 +21,10 @@ pub fn opts() -> TargetOptions {\n             \"/NOLOGO\".to_string(),\n \n             // UEFI is fully compatible to non-executable data pages. Tell the compiler that\n-            // non-code sections can be marked as non-executable, including stack pages.\n+            // non-code sections can be marked as non-executable, including stack pages. In fact,\n+            // firmware might enforce this, so we better let the linker know about this, so it\n+            // will fail if the compiler ever tries placing code on the stack (e.g., trampoline\n+            // constructs and alike).\n             \"/NXCOMPAT\".to_string(),\n \n             // There is no runtime for UEFI targets, prevent them from being linked. UEFI targets"}, {"sha": "443479f55f04a2361bbca5520e1ea820842587b2", "filename": "src/librustc_target/spec/x86_64_unknown_uefi.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/15e4bd3bf460a4a943465534132a9d3eda5eb798/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_uefi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e4bd3bf460a4a943465534132a9d3eda5eb798/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_uefi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_uefi.rs?ref=15e4bd3bf460a4a943465534132a9d3eda5eb798", "patch": "@@ -12,23 +12,25 @@ pub fn target() -> TargetResult {\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = Some(64);\n \n-    // We disable MMX and SSE for now. UEFI does not prevent these from being used, but there have\n-    // been reports to GRUB that some firmware does not initialize the FP exception handlers\n-    // properly. Therefore, using FP coprocessors will end you up at random memory locations when\n-    // you throw FP exceptions.\n-    // To be safe, we disable them for now and force soft-float. This can be revisited when we\n-    // have more test coverage. Disabling FP served GRUB well so far, so it should be good for us\n-    // as well.\n+    // We disable MMX and SSE for now, even though UEFI allows using them. Problem is, you have to\n+    // enable these CPU features explicitly before their first use, otherwise their instructions\n+    // will trigger an exception. Rust does not inject any code that enables AVX/MMX/SSE\n+    // instruction sets, so this must be done by the firmware. However, existing firmware is known\n+    // to leave these uninitialized, thus triggering exceptions if we make use of them. Which is\n+    // why we avoid them and instead use soft-floats. This is also what GRUB and friends did so\n+    // far.\n+    // If you initialize FP units yourself, you can override these flags with custom linker\n+    // arguments, thus giving you access to full MMX/SSE acceleration.\n     base.features = \"-mmx,-sse,+soft-float\".to_string();\n \n     // UEFI systems run without a host OS, hence we cannot assume any code locality. We must tell\n     // LLVM to expect code to reference any address in the address-space. The \"large\" code-model\n     // places no locality-restrictions, so it fits well here.\n     base.code_model = Some(\"large\".to_string());\n \n-    // UEFI mostly mirrors the calling-conventions used on windows. In case of x86-64 this means\n-    // small structs will be returned as int. This shouldn't matter much, since the restrictions\n-    // placed by the UEFI specifications forbid any ABI to return structures.\n+    // UEFI mirrors the calling-conventions used on windows. In case of x86-64 this means small\n+    // structs will be returned as int. This shouldn't matter much, since the restrictions placed\n+    // by the UEFI specifications forbid any ABI to return structures.\n     base.abi_return_struct_as_int = true;\n \n     Ok(Target {"}]}