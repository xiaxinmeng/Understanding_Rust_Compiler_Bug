{"sha": "3321880f1304943a87f3b9756de642417eb82d1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMjE4ODBmMTMwNDk0M2E4N2YzYjk3NTZkZTY0MjQxN2ViODJkMWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-28T00:44:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-28T00:44:40Z"}, "message": "Merge remote-tracking branch 'killerswan/fixing_strings_2'\n\nConflicts:\n\tsrc/comp/driver/driver.rs\n\tsrc/comp/middle/trans/base.rs\n\tsrc/comp/syntax/parse/lexer.rs", "tree": {"sha": "c9306f591e39bf02808b437ce67cd780b47b8524", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9306f591e39bf02808b437ce67cd780b47b8524"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3321880f1304943a87f3b9756de642417eb82d1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3321880f1304943a87f3b9756de642417eb82d1b", "html_url": "https://github.com/rust-lang/rust/commit/3321880f1304943a87f3b9756de642417eb82d1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3321880f1304943a87f3b9756de642417eb82d1b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e620f87a6f524434fdcaffa9d84bad1f7f5e13e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e620f87a6f524434fdcaffa9d84bad1f7f5e13e", "html_url": "https://github.com/rust-lang/rust/commit/7e620f87a6f524434fdcaffa9d84bad1f7f5e13e"}, {"sha": "3afc16f7a4ce66910107843b8f5cfbea3ad28a09", "url": "https://api.github.com/repos/rust-lang/rust/commits/3afc16f7a4ce66910107843b8f5cfbea3ad28a09", "html_url": "https://github.com/rust-lang/rust/commit/3afc16f7a4ce66910107843b8f5cfbea3ad28a09"}], "stats": {"total": 159, "additions": 96, "deletions": 63}, "files": [{"sha": "426263d654a7adf31cf28f3e1b49f54805106acd", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -83,7 +83,7 @@ fn item_family(item: ebml::doc) -> u8 {\n \n fn item_symbol(item: ebml::doc) -> str {\n     let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n-    ret str::unsafe_from_bytes(ebml::doc_data(sym));\n+    ret str::from_bytes(ebml::doc_data(sym));\n }\n \n fn variant_enum_id(d: ebml::doc) -> ast::def_id {\n@@ -162,7 +162,7 @@ fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> [ast::def_id] {\n // definition the path refers to.\n fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n     fn eq_item(data: [u8], s: str) -> bool {\n-        ret str::eq(str::unsafe_from_bytes(data), s);\n+        ret str::eq(str::from_bytes(data), s);\n     }\n     let s = str::connect(path, \"::\");\n     let md = ebml::new_doc(data);\n@@ -178,7 +178,7 @@ fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n \n fn item_name(item: ebml::doc) -> ast::ident {\n     let name = ebml::get_doc(item, tag_paths_data_name);\n-    str::unsafe_from_bytes(ebml::doc_data(name))\n+    str::from_bytes(ebml::doc_data(name))\n }\n \n fn lookup_item_name(data: @[u8], id: ast::node_id) -> ast::ident {\n@@ -325,7 +325,7 @@ fn read_path(d: ebml::doc) -> {path: str, pos: uint} {\n     let desc = ebml::doc_data(d);\n     let pos = ebml::be_uint_from_bytes(@desc, 0u, 4u);\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n-    let path = str::unsafe_from_bytes(pathbytes);\n+    let path = str::from_bytes(pathbytes);\n     ret {path: path, pos: pos};\n }\n \n@@ -358,21 +358,21 @@ fn get_meta_items(md: ebml::doc) -> [@ast::meta_item] {\n     let items: [@ast::meta_item] = [];\n     ebml::tagged_docs(md, tag_meta_item_word) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+        let n = str::from_bytes(ebml::doc_data(nd));\n         items += [attr::mk_word_item(n)];\n     };\n     ebml::tagged_docs(md, tag_meta_item_name_value) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n-        let v = str::unsafe_from_bytes(ebml::doc_data(vd));\n+        let n = str::from_bytes(ebml::doc_data(nd));\n+        let v = str::from_bytes(ebml::doc_data(vd));\n         // FIXME (#611): Should be able to decode meta_name_value variants,\n         // but currently they can't be encoded\n         items += [attr::mk_name_value_item_str(n, v)];\n     };\n     ebml::tagged_docs(md, tag_meta_item_list) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+        let n = str::from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n         items += [attr::mk_list_item(n, subitems)];\n     };\n@@ -427,7 +427,7 @@ fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n     let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n     let crate_num = 1;\n     ebml::tagged_docs(depsdoc, tag_crate_dep) {|depdoc|\n-        let depname = str::unsafe_from_bytes(ebml::doc_data(depdoc));\n+        let depname = str::from_bytes(ebml::doc_data(depdoc));\n         deps += [{cnum: crate_num, ident: depname}];\n         crate_num += 1;\n     };\n@@ -447,7 +447,7 @@ fn list_crate_deps(data: @[u8], out: io::writer) {\n fn get_crate_hash(data: @[u8]) -> str {\n     let cratedoc = ebml::new_doc(data);\n     let hashdoc = ebml::get_doc(cratedoc, tag_crate_hash);\n-    ret str::unsafe_from_bytes(ebml::doc_data(hashdoc));\n+    ret str::from_bytes(ebml::doc_data(hashdoc));\n }\n \n fn list_crate_items(bytes: @[u8], md: ebml::doc, out: io::writer) {"}, {"sha": "e74a2d62ced46c2500aed3175e6413d350c0cbed", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -661,7 +661,7 @@ fn encode_hash(ebml_w: ebml::writer, hash: str) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> str {\n+fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> [u8] {\n \n     let abbrevs = ty::new_ty_hash();\n     let ecx = @{ccx: cx, type_abbrevs: abbrevs};\n@@ -694,7 +694,7 @@ fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> str {\n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n     buf_w.write([0u8, 0u8, 0u8, 0u8]);\n-    io::mem_buffer_str(buf)\n+    io::mem_buffer_buf(buf)\n }\n \n // Get the encoded string for a type"}, {"sha": "b7adcfadf12d54a1e37647fd78ff56e1d60dccc9", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -39,7 +39,7 @@ fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n    ast::ident {\n     let rslt = \"\";\n     while !is_last(peek(st) as char) {\n-        rslt += str::unsafe_from_byte(next(st));\n+        rslt += str::from_byte(next(st));\n     }\n     ret rslt;\n }\n@@ -226,7 +226,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         while peek(st) as char != ']' {\n             let name = \"\";\n             while peek(st) as char != '=' {\n-                name += str::unsafe_from_byte(next(st));\n+                name += str::from_byte(next(st));\n             }\n             st.pos = st.pos + 1u;\n             fields += [{ident: name, mt: parse_mt(st, conv)}];"}, {"sha": "9b423be389e435e49da32d2ebfe1b546f7a132a1", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -268,7 +268,7 @@ fn sanitize(s: str) -> str {\n                            c != ' ' as u8 && c != '\\t' as u8 && c != ';' as u8\n                        {\n                         let v = [c];\n-                        result += str::unsafe_from_bytes(v);\n+                        result += str::from_bytes(v);\n                     }\n                 }\n             }\n@@ -5412,7 +5412,7 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n \n fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n     if !cx.sess.building_library { ret; }\n-    let llmeta = C_postr(metadata::encoder::encode_metadata(cx, crate));\n+    let llmeta = C_bytes(metadata::encoder::encode_metadata(cx, crate));\n     let llconst = C_struct([llmeta]);\n     let llglobal = str::as_buf(\"rust_metadata\", {|buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)"}, {"sha": "d2fbe02d63ad3ed15dd91034eb0a1734d7b2e91c", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -672,7 +672,7 @@ fn gather_comments_and_literals(cm: codemap::codemap,\n                                 path: str,\n                                 srdr: io::reader) ->\n    {cmnts: [cmnt], lits: [lit]} {\n-    let src = @str::unsafe_from_bytes(srdr.read_whole_stream());\n+    let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = @interner::mk::<str>(str::hash, str::eq);\n     let rdr = new_reader(cm, span_diagnostic,\n                          codemap::new_filemap(path, src, 0u, 0u), itr);"}, {"sha": "2ae8a860a2709c2fc9deb7ccc11371b84478dc98", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -118,7 +118,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       }\n       ty_var(v) { \"<T\" + int::str(v) + \">\" }\n       ty_param(id, _) {\n-        \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])\n+        \"'\" + str::from_bytes([('a' as u8) + (id as u8)])\n       }\n       _ { ty_to_short_str(cx, typ) }\n     }"}, {"sha": "6f3fd87466a6c84cb632212f00be1caaca6124d9", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -85,7 +85,7 @@ fn readclose(fd: fd_t) -> str {\n     let buf = \"\";\n     while !reader.eof() {\n         let bytes = reader.read_bytes(4096u);\n-        buf += str::unsafe_from_bytes(bytes);\n+        buf += str::from_bytes(bytes);\n     }\n     os::fclose(file);\n     ret buf;\n@@ -114,8 +114,8 @@ fn worker(p: port<request>) {\n                 // the alt discriminant are wrong.\n                 alt recv(p) {\n                   exec(lib_path, prog, args, respchan) {\n-                    {lib_path: str::unsafe_from_bytes(lib_path),\n-                     prog: str::unsafe_from_bytes(prog),\n+                    {lib_path: str::from_bytes(lib_path),\n+                     prog: str::from_bytes(prog),\n                      args: clone_vecu8str(args),\n                      respchan: respchan}\n                   }\n@@ -189,7 +189,7 @@ fn clone_vecstr(v: [str]) -> [[u8]] {\n fn clone_vecu8str(v: [[u8]]) -> [str] {\n     let r = [];\n     for t in vec::slice(v, 0u, vec::len(v)) {\n-        r += [str::unsafe_from_bytes(t)];\n+        r += [str::from_bytes(t)];\n     }\n     ret r;\n }"}, {"sha": "eb91c2cb5d517e60d588e8606549d4ea9dbe7f57", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -390,7 +390,7 @@ mod rt {\n     fn str_init_elt(n_elts: uint, c: char) -> str {\n         let svec = vec::init_elt::<u8>(n_elts, c as u8);\n \n-        ret str::unsafe_from_bytes(svec);\n+        ret str::from_bytes(svec);\n     }\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, }\n     fn pad(cv: conv, s: str, mode: pad_mode) -> str {\n@@ -439,7 +439,8 @@ mod rt {\n         if signed && zero_padding && str::byte_len(s) > 0u {\n             let head = s[0];\n             if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n-                let headstr = str::unsafe_from_bytes([head]);\n+                let headstr = str::from_bytes([head]);\n+                // FIXME: not UTF-8 safe\n                 let bytelen = str::byte_len(s);\n                 let numpart = str::substr(s, 1u, bytelen - 1u);\n                 ret headstr + padstr + numpart;"}, {"sha": "dad10eced7f2b96492348c9abfc7aba5cba96b4f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -13,6 +13,7 @@ export\n    // Creating a string\n    from_bytes,\n    unsafe_from_bytes,\n+   from_byte,\n    unsafe_from_byte,\n    //push_utf8_bytes,\n    from_char,\n@@ -117,14 +118,11 @@ Section: Creating a string\n /*\n Function: from_bytes\n \n-Safely convert a vector of bytes to a UTF-8 string, or error\n+Convert a vector of bytes to a UTF-8 string.  Fails if invalid UTF-8.\n */\n-fn from_bytes(vv: [u8]) -> result::t<str, str> {\n-   if is_utf8(vv) {\n-      ret result::ok(unsafe_from_bytes(vv));\n-   } else {\n-      ret result::err(\"vector doesn't contain valid UTF-8\");\n-   }\n+fn from_bytes(vv: [u8]) -> str {\n+   assert is_utf8(vv);\n+   ret unsafe_from_bytes(vv);\n }\n \n /*\n@@ -133,7 +131,7 @@ Function: unsafe_from_bytes\n Converts a vector of bytes to a string. Does not verify that the\n vector contains valid UTF-8.\n \n-// FIXME: remove?\n+FIXME: stop exporting\n */\n fn unsafe_from_bytes(v: [const u8]) -> str unsafe {\n     let vcopy: [u8] = v + [0u8];\n@@ -148,10 +146,20 @@ Function: unsafe_from_byte\n Converts a byte to a string. Does not verify that the byte is\n valid UTF-8.\n \n-FIXME: rename to 'from_byte'\n+FIXME: stop exporting\n */\n fn unsafe_from_byte(u: u8) -> str { unsafe_from_bytes([u]) }\n \n+\n+/*\n+Function: from_byte\n+\n+Convert a byte to a UTF-8 string.  Fails if invalid UTF-8.\n+*/\n+fn from_byte(uu: u8) -> str {\n+    from_bytes([uu])\n+}\n+\n fn push_utf8_bytes(&s: str, ch: char) {\n     let code = ch as uint;\n     let bytes =\n@@ -209,16 +217,16 @@ Function: from_cstr\n Create a Rust string from a null-terminated C string\n */\n unsafe fn from_cstr(cstr: sbuf) -> str {\n-    let res = \"\";\n+    let res = [];\n     let start = cstr;\n     let curr = start;\n     let i = 0u;\n     while *curr != 0u8 {\n-        push_byte(res, *curr);\n+        vec::push(res, *curr);\n         i += 1u;\n         curr = ptr::offset(start, i);\n     }\n-    ret res;\n+    ret from_bytes(res);\n }\n \n /*\n@@ -526,7 +534,7 @@ fn split(s: str, sep: u8) -> [str] {\n             v += [accum];\n             accum = \"\";\n             ends_with_sep = true;\n-        } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n+        } else { accum += from_byte(c); ends_with_sep = false; }\n     }\n     if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n     ret v;\n@@ -554,7 +562,7 @@ fn splitn(s: str, sep: u8, count: uint) -> [str] {\n             v += [accum];\n             accum = \"\";\n             ends_with_sep = true;\n-        } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n+        } else { accum += from_byte(c); ends_with_sep = false; }\n     }\n     if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n     ret v;\n@@ -575,26 +583,26 @@ FIXME: should behave like split and split_char:\n */\n fn split_str(s: str, sep: str) -> [str] {\n     assert byte_len(sep) > 0u;\n-    let v: [str] = [], accum = \"\", sep_match = 0u, leading = true;\n+    let v: [str] = [], accum = [], sep_match = 0u, leading = true;\n     for c: u8 in s {\n         // Did we match the entire separator?\n         if sep_match == byte_len(sep) {\n-            if !leading { v += [accum]; }\n-            accum = \"\";\n+            if !leading { vec::push(v, from_bytes(accum)); }\n+            accum = [];\n             sep_match = 0u;\n         }\n \n         if c == sep[sep_match] {\n             sep_match += 1u;\n         } else {\n             sep_match = 0u;\n-            accum += unsafe_from_byte(c);\n+            vec::push(accum, c);\n             leading = false;\n         }\n     }\n \n-    if byte_len(accum) > 0u { v += [accum]; }\n-    if sep_match == byte_len(sep) { v += [\"\"]; }\n+    if vec::len(accum) > 0u { vec::push(v, from_bytes(accum)); }\n+    if sep_match == byte_len(sep) { vec::push(v, \"\"); }\n \n     ret v;\n }\n@@ -1783,7 +1791,24 @@ mod tests {\n                   0x20_u8, 0x4e_u8, 0x61_u8,\n                   0x6d_u8];\n \n-         assert ss == result::get(from_bytes(bb));\n+         assert ss == from_bytes(bb);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_from_bytes_fail() {\n+        let bb = [0xff_u8, 0xb8_u8, 0xa8_u8,\n+                  0xe0_u8, 0xb9_u8, 0x84_u8,\n+                  0xe0_u8, 0xb8_u8, 0x97_u8,\n+                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n+                  0xe4_u8, 0xb8_u8, 0xad_u8,\n+                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n+                  0x56_u8, 0x69_u8, 0xe1_u8,\n+                  0xbb_u8, 0x87_u8, 0x74_u8,\n+                  0x20_u8, 0x4e_u8, 0x61_u8,\n+                  0x6d_u8];\n+\n+         let _x = from_bytes(bb);\n     }\n \n     #[test]\n@@ -1821,7 +1846,7 @@ mod tests {\n         let s1: str = \"All mimsy were the borogoves\";\n \n         let v: [u8] = bytes(s1);\n-        let s2: str = unsafe_from_bytes(v);\n+        let s2: str = from_bytes(v);\n         let i: uint = 0u;\n         let n1: uint = byte_len(s1);\n         let n2: uint = vec::len::<u8>(v);"}, {"sha": "2112399ba8026b29aee9d95dd2b4b0860a6a7c68", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -236,12 +236,12 @@ fn to_str(num: uint, radix: uint) -> str {\n     if n == 0u { ret \"0\"; }\n     let s: str = \"\";\n     while n != 0u {\n-        s += str::unsafe_from_byte(digit(n % radix) as u8);\n+        s += str::from_byte(digit(n % radix) as u8);\n         n /= radix;\n     }\n     let s1: str = \"\";\n     let len: uint = str::byte_len(s);\n-    while len != 0u { len -= 1u; s1 += str::unsafe_from_byte(s[len]); }\n+    while len != 0u { len -= 1u; s1 += str::from_byte(s[len]); }\n     ret s1;\n }\n "}, {"sha": "89aad5d7777856e632d2715c8b742a9a69a4f0d1", "filename": "src/libstd/freebsd_os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Ffreebsd_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Ffreebsd_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffreebsd_os.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -129,7 +129,8 @@ fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n /// followed by a path separator\n fn get_exe_path() -> option::t<fs::path> unsafe {\n     let bufsize = 1023u;\n-    let path = str::unsafe_from_bytes(vec::init_elt(bufsize, 0u8));\n+    // FIXME: path \"strings\" will likely need fixing...\n+    let path = str::from_bytes(vec::init_elt(bufsize, 0u8));\n     let mib = [libc_constants::CTL_KERN,\n                libc_constants::KERN_PROC,\n                libc_constants::KERN_PROC_PATHNAME, -1i32];"}, {"sha": "934352e7788445897651ede08f0d401426f52b35", "filename": "src/libstd/generic_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgeneric_os.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -75,7 +75,7 @@ fn getenv(n: str) -> option::t<str> {\n             unsafe {\n                 vec::unsafe::set_len(v, res);\n             }\n-            ret option::some(str::unsafe_from_bytes(v));\n+            ret option::some(str::from_bytes(v)); // UTF-8 or fail\n         } else { nsize = res; }\n     }\n     fail;"}, {"sha": "5cc08813d6abc344a746b90922796b5caead633a", "filename": "src/libstd/io.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -109,7 +109,7 @@ impl reader_util for reader {\n             if ch == -1 || ch == 10 { break; }\n             buf += [ch as u8];\n         }\n-        str::unsafe_from_bytes(buf)\n+        str::from_bytes(buf)\n     }\n \n     fn read_c_str() -> str {\n@@ -118,7 +118,7 @@ impl reader_util for reader {\n             let ch = self.read_byte();\n             if ch < 1 { break; } else { buf += [ch as u8]; }\n         }\n-        str::unsafe_from_bytes(buf)\n+        str::from_bytes(buf)\n     }\n \n     // FIXME deal with eof?\n@@ -461,7 +461,10 @@ fn mk_mem_buffer() -> mem_buffer {\n }\n fn mem_buffer_writer(b: mem_buffer) -> writer { b as writer }\n fn mem_buffer_buf(b: mem_buffer) -> [u8] { vec::from_mut(b.buf) }\n-fn mem_buffer_str(b: mem_buffer) -> str { str::unsafe_from_bytes(b.buf) }\n+fn mem_buffer_str(b: mem_buffer) -> str {\n+   let b_ = vec::from_mut(b.buf);\n+   str::from_bytes(b_)\n+}\n \n // Utility functions\n fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n@@ -479,7 +482,7 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n \n fn read_whole_file_str(file: str) -> result::t<str, str> {\n     result::chain(read_whole_file(file), { |bytes|\n-        result::ok(str::unsafe_from_bytes(bytes))\n+        result::ok(str::from_bytes(bytes))\n     })\n }\n "}, {"sha": "82b1197a51fbd226d96aaa9fe4a1c5a959ac9a39", "filename": "src/libstd/linux_os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flinux_os.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -125,7 +125,8 @@ fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n /// followed by a path separator\n fn get_exe_path() -> option::t<fs::path> {\n     let bufsize = 1023u;\n-    let path = str::unsafe_from_bytes(vec::init_elt(bufsize, 0u8));\n+    // FIXME: path \"strings\" will likely need fixing...\n+    let path = str::from_bytes(vec::init_elt(bufsize, 0u8));\n     ret str::as_buf(\"/proc/self/exe\", { |proc_self_buf|\n         str::as_buf(path, { |path_buf|\n             if libc::readlink(proc_self_buf, path_buf, bufsize) != -1 {"}, {"sha": "cd984870781cb0cab0f32ab3eb91f358646f5dcb", "filename": "src/libstd/macos_os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacos_os.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -133,8 +133,9 @@ fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".dylib\"; }\n \n fn get_exe_path() -> option::t<fs::path> {\n     // FIXME: This doesn't handle the case where the buffer is too small\n+    // FIXME: path \"strings\" will likely need fixing...\n     let bufsize = 1023u32;\n-    let path = str::unsafe_from_bytes(vec::init_elt(bufsize as uint, 0u8));\n+    let path = str::from_bytes(vec::init_elt(bufsize as uint, 0u8));\n     ret str::as_buf(path, { |path_buf|\n         if mac_libc::_NSGetExecutablePath(path_buf,\n                                           ptr::mut_addr_of(bufsize)) == 0i32 {"}, {"sha": "5b2de1e57d0c880358f8cb54c606babdcd82744f", "filename": "src/libstd/run_program.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun_program.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -216,7 +216,7 @@ fn read_all(rd: io::reader) -> str {\n     let buf = \"\";\n     while !rd.eof() {\n         let bytes = rd.read_bytes(4096u);\n-        buf += str::unsafe_from_bytes(bytes);\n+        buf += str::from_bytes(bytes);\n     }\n     ret buf;\n }\n@@ -347,7 +347,7 @@ mod tests {\n             let buf = \"\";\n             while !reader.eof() {\n                 let bytes = reader.read_bytes(4096u);\n-                buf += str::unsafe_from_bytes(bytes);\n+                buf += str::from_bytes(bytes);\n             }\n             os::fclose(file);\n             ret buf;"}, {"sha": "ae08cd5ed5e013b7dd3767675376d0a2d36d6eae", "filename": "src/libstd/uvtmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Fuvtmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Fuvtmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuvtmp.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -150,7 +150,7 @@ fn test_http() {\n                     unsafe {\n                         log(error, len);\n                         let buf = vec::unsafe::from_buf(buf, len as uint);\n-                        let str = str::unsafe_from_bytes(buf);\n+                        let str = str::from_bytes(buf);\n                         #error(\"read something\");\n                         io::println(str);\n                     }\n@@ -165,4 +165,4 @@ fn test_http() {\n     }\n     join_thread(thread);\n     delete_thread(thread);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "83306c757a4dd9bbad46fcfbc77be85449915223", "filename": "src/libstd/win32_os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Flibstd%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fwin32_os.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -113,8 +113,9 @@ fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n \n fn get_exe_path() -> option::t<fs::path> {\n     // FIXME: This doesn't handle the case where the buffer is too small\n+    // FIXME: path \"strings\" will likely need fixing...\n     let bufsize = 1023u;\n-    let path = str::unsafe_from_bytes(vec::init_elt(bufsize, 0u8));\n+    let path = str::from_bytes(vec::init_elt(bufsize, 0u8));\n     ret str::as_buf(path, { |path_buf|\n         if kernel32::GetModuleFileNameA(0u, path_buf,\n                                         bufsize as u32) != 0u32 {"}, {"sha": "8be28fabd79435fc9209911e0cfada3e96b1c785", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -32,7 +32,7 @@ import comm::recv;\n import comm::send;\n \n fn map(&&filename: [u8], emit: map_reduce::putter<[u8], int>) {\n-    let f = io::file_reader(str::unsafe_from_bytes(filename));\n+    let f = io::file_reader(str::from_bytes(filename));\n \n     while true {\n         alt read_word(f) {"}, {"sha": "9301d93874ebed0e4ed623a7f007df05e3b04fb8", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321880f1304943a87f3b9756de642417eb82d1b/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321880f1304943a87f3b9756de642417eb82d1b/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=3321880f1304943a87f3b9756de642417eb82d1b", "patch": "@@ -81,7 +81,7 @@ mod map_reduce {\n               mapper_done { num_mappers -= 1; }\n               find_reducer(k, cc) {\n                 let c;\n-                alt reducers.find(str::unsafe_from_bytes(k)) {\n+                alt reducers.find(str::from_bytes(k)) {\n                   some(_c) { c = _c; }\n                   none { c = 0; }\n                 }"}]}