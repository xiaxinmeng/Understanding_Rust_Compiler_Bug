{"sha": "e01dcf4b75a2742956515b0d254e540f1ae40b9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMWRjZjRiNzVhMjc0Mjk1NjUxNWIwZDI1NGU1NDBmMWFlNDBiOWI=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-11-01T05:32:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-01T05:32:10Z"}, "message": "Rollup merge of #45602 - petrochenkov:ospan, r=michaelwoerister\n\nOptimize some span operations\n\nDo not decode span data twice/thrice/etc unnecessarily.\nApplied to stable hashing and all methods in `impl Span`.\n\nFollow up to https://github.com/rust-lang/rust/pull/44646\nr? @michaelwoerister", "tree": {"sha": "a2aa511eea5ead711adce6730fc70f94f64463ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2aa511eea5ead711adce6730fc70f94f64463ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e01dcf4b75a2742956515b0d254e540f1ae40b9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e01dcf4b75a2742956515b0d254e540f1ae40b9b", "html_url": "https://github.com/rust-lang/rust/commit/e01dcf4b75a2742956515b0d254e540f1ae40b9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e01dcf4b75a2742956515b0d254e540f1ae40b9b/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59c9d03af8888f2d704c02f495a7734da4e86f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/59c9d03af8888f2d704c02f495a7734da4e86f2f", "html_url": "https://github.com/rust-lang/rust/commit/59c9d03af8888f2d704c02f495a7734da4e86f2f"}, {"sha": "06f7f1f68bf9cecaa712a6706691fb04b47dfc49", "url": "https://api.github.com/repos/rust-lang/rust/commits/06f7f1f68bf9cecaa712a6706691fb04b47dfc49", "html_url": "https://github.com/rust-lang/rust/commit/06f7f1f68bf9cecaa712a6706691fb04b47dfc49"}], "stats": {"total": 88, "additions": 58, "deletions": 30}, "files": [{"sha": "d24344e4e2166c9960ccbd3115700f186a1113d9", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e01dcf4b75a2742956515b0d254e540f1ae40b9b/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01dcf4b75a2742956515b0d254e540f1ae40b9b/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=e01dcf4b75a2742956515b0d254e540f1ae40b9b", "patch": "@@ -371,17 +371,18 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n         // If this is not an empty or invalid span, we want to hash the last\n         // position that belongs to it, as opposed to hashing the first\n         // position past it.\n-        let span_hi = if self.hi() > self.lo() {\n+        let span = self.data();\n+        let span_hi = if span.hi > span.lo {\n             // We might end up in the middle of a multibyte character here,\n             // but that's OK, since we are not trying to decode anything at\n             // this position.\n-            self.hi() - ::syntax_pos::BytePos(1)\n+            span.hi - ::syntax_pos::BytePos(1)\n         } else {\n-            self.hi()\n+            span.hi\n         };\n \n         {\n-            let loc1 = hcx.codemap().byte_pos_to_line_and_col(self.lo());\n+            let loc1 = hcx.codemap().byte_pos_to_line_and_col(span.lo);\n             let loc1 = loc1.as_ref()\n                            .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n                            .unwrap_or((\"???\", 0, 0));\n@@ -414,7 +415,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n             }\n         }\n \n-        if self.ctxt() == SyntaxContext::empty() {\n+        if span.ctxt == SyntaxContext::empty() {\n             0u8.hash_stable(hcx, hasher);\n         } else {\n             1u8.hash_stable(hcx, hasher);"}, {"sha": "44e73d876e85a9f1ee3a84d7c4ebac2b7df138c2", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 52, "deletions": 25, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e01dcf4b75a2742956515b0d254e540f1ae40b9b/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01dcf4b75a2742956515b0d254e540f1ae40b9b/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=e01dcf4b75a2742956515b0d254e540f1ae40b9b", "patch": "@@ -75,6 +75,21 @@ pub struct SpanData {\n     pub ctxt: SyntaxContext,\n }\n \n+impl SpanData {\n+    #[inline]\n+    pub fn with_lo(&self, lo: BytePos) -> Span {\n+        Span::new(lo, self.hi, self.ctxt)\n+    }\n+    #[inline]\n+    pub fn with_hi(&self, hi: BytePos) -> Span {\n+        Span::new(self.lo, hi, self.ctxt)\n+    }\n+    #[inline]\n+    pub fn with_ctxt(&self, ctxt: SyntaxContext) -> Span {\n+        Span::new(self.lo, self.hi, ctxt)\n+    }\n+}\n+\n // The interner in thread-local, so `Span` shouldn't move between threads.\n impl !Send for Span {}\n impl !Sync for Span {}\n@@ -109,38 +124,37 @@ impl Span {\n     }\n     #[inline]\n     pub fn with_lo(self, lo: BytePos) -> Span {\n-        let base = self.data();\n-        Span::new(lo, base.hi, base.ctxt)\n+        self.data().with_lo(lo)\n     }\n     #[inline]\n     pub fn hi(self) -> BytePos {\n         self.data().hi\n     }\n     #[inline]\n     pub fn with_hi(self, hi: BytePos) -> Span {\n-        let base = self.data();\n-        Span::new(base.lo, hi, base.ctxt)\n+        self.data().with_hi(hi)\n     }\n     #[inline]\n     pub fn ctxt(self) -> SyntaxContext {\n         self.data().ctxt\n     }\n     #[inline]\n     pub fn with_ctxt(self, ctxt: SyntaxContext) -> Span {\n-        let base = self.data();\n-        Span::new(base.lo, base.hi, ctxt)\n+        self.data().with_ctxt(ctxt)\n     }\n \n     /// Returns a new span representing just the end-point of this span\n     pub fn end_point(self) -> Span {\n-        let lo = cmp::max(self.hi().0 - 1, self.lo().0);\n-        self.with_lo(BytePos(lo))\n+        let span = self.data();\n+        let lo = cmp::max(span.hi.0 - 1, span.lo.0);\n+        span.with_lo(BytePos(lo))\n     }\n \n     /// Returns a new span representing the next character after the end-point of this span\n     pub fn next_point(self) -> Span {\n-        let lo = cmp::max(self.hi().0, self.lo().0 + 1);\n-        Span::new(BytePos(lo), BytePos(lo), self.ctxt())\n+        let span = self.data();\n+        let lo = cmp::max(span.hi.0, span.lo.0 + 1);\n+        Span::new(BytePos(lo), BytePos(lo), span.ctxt)\n     }\n \n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n@@ -150,21 +164,27 @@ impl Span {\n \n     /// Return true if `self` fully encloses `other`.\n     pub fn contains(self, other: Span) -> bool {\n-        self.lo() <= other.lo() && other.hi() <= self.hi()\n+        let span = self.data();\n+        let other = other.data();\n+        span.lo <= other.lo && other.hi <= span.hi\n     }\n \n     /// Return true if the spans are equal with regards to the source text.\n     ///\n     /// Use this instead of `==` when either span could be generated code,\n     /// and you only care that they point to the same bytes of source text.\n     pub fn source_equal(&self, other: &Span) -> bool {\n-        self.lo() == other.lo() && self.hi() == other.hi()\n+        let span = self.data();\n+        let other = other.data();\n+        span.lo == other.lo && span.hi == other.hi\n     }\n \n     /// Returns `Some(span)`, where the start is trimmed by the end of `other`\n     pub fn trim_start(self, other: Span) -> Option<Span> {\n-        if self.hi() > other.hi() {\n-            Some(self.with_lo(cmp::max(self.lo(), other.hi())))\n+        let span = self.data();\n+        let other = other.data();\n+        if span.hi > other.hi {\n+            Some(span.with_lo(cmp::max(span.lo, other.hi)))\n         } else {\n             None\n         }\n@@ -268,29 +288,35 @@ impl Span {\n \n     /// Return a `Span` that would enclose both `self` and `end`.\n     pub fn to(self, end: Span) -> Span {\n+        let span = self.data();\n+        let end = end.data();\n         Span::new(\n-            cmp::min(self.lo(), end.lo()),\n-            cmp::max(self.hi(), end.hi()),\n+            cmp::min(span.lo, end.lo),\n+            cmp::max(span.hi, end.hi),\n             // FIXME(jseyfried): self.ctxt should always equal end.ctxt here (c.f. issue #23480)\n-            if self.ctxt() == SyntaxContext::empty() { end.ctxt() } else { self.ctxt() },\n+            if span.ctxt == SyntaxContext::empty() { end.ctxt } else { span.ctxt },\n         )\n     }\n \n     /// Return a `Span` between the end of `self` to the beginning of `end`.\n     pub fn between(self, end: Span) -> Span {\n+        let span = self.data();\n+        let end = end.data();\n         Span::new(\n-            self.hi(),\n-            end.lo(),\n-            if end.ctxt() == SyntaxContext::empty() { end.ctxt() } else { self.ctxt() },\n+            span.hi,\n+            end.lo,\n+            if end.ctxt == SyntaxContext::empty() { end.ctxt } else { span.ctxt },\n         )\n     }\n \n     /// Return a `Span` between the beginning of `self` to the beginning of `end`.\n     pub fn until(self, end: Span) -> Span {\n+        let span = self.data();\n+        let end = end.data();\n         Span::new(\n-            self.lo(),\n-            end.lo(),\n-            if end.ctxt() == SyntaxContext::empty() { end.ctxt() } else { self.ctxt() },\n+            span.lo,\n+            end.lo,\n+            if end.ctxt == SyntaxContext::empty() { end.ctxt } else { span.ctxt },\n         )\n     }\n }\n@@ -316,13 +342,14 @@ impl Default for Span {\n \n impl serialize::UseSpecializedEncodable for Span {\n     fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        let span = self.data();\n         s.emit_struct(\"Span\", 2, |s| {\n             s.emit_struct_field(\"lo\", 0, |s| {\n-                self.lo().encode(s)\n+                span.lo.encode(s)\n             })?;\n \n             s.emit_struct_field(\"hi\", 1, |s| {\n-                self.hi().encode(s)\n+                span.hi.encode(s)\n             })\n         })\n     }"}]}