{"sha": "ebaa122d34b37c5335fd683b86c380395e9d201c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViYWExMjJkMzRiMzdjNTMzNWZkNjgzYjg2YzM4MDM5NWU5ZDIwMWM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-27T17:27:20Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-29T14:58:32Z"}, "message": "Fix non-closure rust-call functions and fix a field projection bug", "tree": {"sha": "39f2d2fc3c98631d1581b6e0398c186f308caf2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39f2d2fc3c98631d1581b6e0398c186f308caf2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebaa122d34b37c5335fd683b86c380395e9d201c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebaa122d34b37c5335fd683b86c380395e9d201c", "html_url": "https://github.com/rust-lang/rust/commit/ebaa122d34b37c5335fd683b86c380395e9d201c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebaa122d34b37c5335fd683b86c380395e9d201c/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d470a61d0b7044df989c70ec3acd732e801682b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d470a61d0b7044df989c70ec3acd732e801682b6", "html_url": "https://github.com/rust-lang/rust/commit/d470a61d0b7044df989c70ec3acd732e801682b6"}], "stats": {"total": 154, "additions": 108, "deletions": 46}, "files": [{"sha": "37161b873801c01a1960ec05c20cb6b11c2b5b98", "filename": "example.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ebaa122d34b37c5335fd683b86c380395e9d201c/example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaa122d34b37c5335fd683b86c380395e9d201c/example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example.rs?ref=ebaa122d34b37c5335fd683b86c380395e9d201c", "patch": "@@ -1,4 +1,4 @@\n-#![feature(no_core)]\n+#![feature(no_core, unboxed_closures)]\n #![no_core]\n #![allow(dead_code)]\n \n@@ -122,6 +122,24 @@ fn call_closure_2arg() {\n     })(0u8, 42u16)\n }\n \n+struct IsNotEmpty;\n+\n+impl<'a, 'b> FnOnce<(&'a &'b [u16], )> for IsNotEmpty {\n+    type Output = bool;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u16], )) -> bool {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a, 'b> FnMut<(&'a &'b [u16], )> for IsNotEmpty {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b [u16], )) -> bool {\n+        true\n+    }\n+}\n+\n fn eq_char(a: char, b: char) -> bool {\n     a == b\n }"}, {"sha": "115746d61c9e19a2ad6197195c2ffd3359528e0a", "filename": "mini_core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebaa122d34b37c5335fd683b86c380395e9d201c/mini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaa122d34b37c5335fd683b86c380395e9d201c/mini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mini_core.rs?ref=ebaa122d34b37c5335fd683b86c380395e9d201c", "patch": "@@ -88,15 +88,15 @@ impl<T: ?Sized> PartialEq for *const T {\n \n #[lang = \"fn_once\"]\n #[rustc_paren_sugar]\n-trait FnOnce<Args> {\n+pub trait FnOnce<Args> {\n     type Output;\n \n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-trait FnMut<Args> : FnOnce<Args> {\n+pub trait FnMut<Args> : FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n "}, {"sha": "6bef83a5bb735855c50224415f74dc6b274b34e7", "filename": "src/abi.rs", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ebaa122d34b37c5335fd683b86c380395e9d201c/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaa122d34b37c5335fd683b86c380395e9d201c/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=ebaa122d34b37c5335fd683b86c380395e9d201c", "patch": "@@ -26,7 +26,6 @@ pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, fn_ty: Ty<\n             )\n         }\n         Abi::System => bug!(\"system abi should be selected elsewhere\"),\n-        // TODO: properly implement intrinsics\n         Abi::RustIntrinsic => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n         _ => unimplemented!(\"unsupported abi {:?}\", sig.abi),\n     };\n@@ -122,27 +121,70 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, start_ebb\n         offset: None,\n     }); // Dummy stack slot for debugging\n \n+    enum ArgKind {\n+        Normal(Value),\n+        Spread(Vec<Value>),\n+    }\n+\n     let func_params = fx.mir.args_iter().map(|local| {\n-        let layout = fx.layout_of(fx.mir.local_decls[local].ty);\n+        let arg_ty = fx.mir.local_decls[local].ty;\n+\n+        // Adapted from https://github.com/rust-lang/rust/blob/145155dc96757002c7b2e9de8489416e2fdbbd57/src/librustc_codegen_llvm/mir/mod.rs#L442-L482\n+        if Some(local) == fx.mir.spread_arg {\n+            // This argument (e.g. the last argument in the \"rust-call\" ABI)\n+            // is a tuple that was spread at the ABI level and now we have\n+            // to reconstruct it into a tuple local variable, from multiple\n+            // individual function arguments.\n+\n+            let tupled_arg_tys = match arg_ty.sty {\n+                ty::TyTuple(ref tys) => tys,\n+                _ => bug!(\"spread argument isn't a tuple?!\")\n+            };\n+\n+            let mut ebb_params = Vec::new();\n+            for arg_ty in tupled_arg_tys.iter() {\n+                let cton_type = fx.cton_type(arg_ty).unwrap_or(types::I64);\n+                ebb_params.push(fx.bcx.append_ebb_param(start_ebb, cton_type));\n+            }\n+\n+            (local, ArgKind::Spread(ebb_params), arg_ty)\n+        } else {\n+            let cton_type = fx.cton_type(arg_ty).unwrap_or(types::I64);\n+            (local, ArgKind::Normal(fx.bcx.append_ebb_param(start_ebb, cton_type)), arg_ty)\n+        }\n+    }).collect::<Vec<(Local, ArgKind, Ty)>>();\n+\n+    let ret_layout = fx.layout_of(fx.return_type());\n+    fx.local_map.insert(RETURN_PLACE, CPlace::Addr(ret_param, ret_layout));\n+\n+    for (local, arg_kind, ty) in func_params {\n+        let layout = fx.layout_of(ty);\n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             size: layout.size.bytes() as u32,\n             offset: None,\n         });\n-        let ty = fx.mir.local_decls[local].ty;\n-        let cton_type = fx.cton_type(ty).unwrap_or(types::I64);\n-        (local, fx.bcx.append_ebb_param(start_ebb, cton_type), ty, stack_slot)\n-    }).collect::<Vec<(Local, Value, Ty, StackSlot)>>();\n-\n-    let ret_layout = fx.layout_of(fx.return_type());\n-    fx.local_map.insert(RETURN_PLACE, CPlace::Addr(ret_param, ret_layout));\n \n-    for (local, ebb_param, ty, stack_slot) in func_params {\n         let place = CPlace::from_stack_slot(fx, stack_slot, ty);\n-        if fx.cton_type(ty).is_some() {\n-            place.write_cvalue(fx, CValue::ByVal(ebb_param, place.layout()));\n-        } else {\n-            place.write_cvalue(fx, CValue::ByRef(ebb_param, place.layout()));\n+\n+        match arg_kind {\n+            ArgKind::Normal(ebb_param) => {\n+                if fx.cton_type(ty).is_some() {\n+                    place.write_cvalue(fx, CValue::ByVal(ebb_param, place.layout()));\n+                } else {\n+                    place.write_cvalue(fx, CValue::ByRef(ebb_param, place.layout()));\n+                }\n+            }\n+            ArgKind::Spread(ebb_params) => {\n+                for (i, ebb_param) in ebb_params.into_iter().enumerate() {\n+                    let sub_place = place.place_field(fx, mir::Field::new(i));\n+                    if fx.cton_type(sub_place.layout().ty).is_some() {\n+                        sub_place.write_cvalue(fx, CValue::ByVal(ebb_param, sub_place.layout()));\n+                    } else {\n+                        sub_place.write_cvalue(fx, CValue::ByRef(ebb_param, sub_place.layout()));\n+                    }\n+                }\n+            }\n         }\n         fx.local_map.insert(local, place);\n     }\n@@ -191,6 +233,7 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n             },\n             _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n         }\n+        println!(\"{:?} {:?}\", pack_arg.layout().ty, args.iter().map(|a|a.layout().ty).collect::<Vec<_>>());\n         args\n     } else {\n         args\n@@ -209,7 +252,7 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n             let usize_layout = fx.layout_of(fx.tcx.types.usize);\n             let ret = return_place.unwrap();\n             match intrinsic {\n-                \"copy\" => {\n+                \"copy\" | \"copy_nonoverlapping\" => {\n                     /*let elem_ty = substs.type_at(0);\n                     assert_eq!(args.len(), 3);\n                     let src = args[0];"}, {"sha": "84f7c0fd83de3f1e6fac149cbd4aca918d19ed36", "filename": "src/common.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ebaa122d34b37c5335fd683b86c380395e9d201c/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaa122d34b37c5335fd683b86c380395e9d201c/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=ebaa122d34b37c5335fd683b86c380395e9d201c", "patch": "@@ -1,6 +1,6 @@\n use std::fmt;\n \n-use syntax::ast::{IntTy, UintTy};\n+use syntax::ast::{IntTy, UintTy, FloatTy};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n use cranelift_module::{Module, FuncId, DataId};\n@@ -46,6 +46,12 @@ pub fn cton_type_from_ty<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>\n             }\n         }\n         TypeVariants::TyChar => types::I32,\n+        TypeVariants::TyFloat(size) => {\n+            match size {\n+                FloatTy::F32 => types::I32,\n+                FloatTy::F64 => types::I64,\n+            }\n+        }\n         TypeVariants::TyFnPtr(_) => types::I64,\n         TypeVariants::TyRawPtr(TypeAndMut { ty, mutbl: _ }) | TypeVariants::TyRef(_, ty, _) => {\n             if ty.is_sized(tcx.at(DUMMY_SP), ParamEnv::reveal_all()) {\n@@ -59,6 +65,22 @@ pub fn cton_type_from_ty<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>\n     })\n }\n \n+fn codegen_field<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    base: Value,\n+    layout: TyLayout<'tcx>,\n+    field: mir::Field\n+) -> (Value, TyLayout<'tcx>) {\n+    let field_offset = layout.fields.offset(field.index());\n+    let field_ty = layout.field(&*fx, field.index());\n+    if field_offset.bytes() > 0 {\n+        let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n+        (fx.bcx.ins().iadd(base, field_offset), field_ty)\n+    } else {\n+        (base, field_ty)\n+    }\n+}\n+\n /// A read-only value\n #[derive(Debug, Copy, Clone)]\n pub enum CValue<'tcx> {\n@@ -117,29 +139,13 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     pub fn value_field<'a>(self, fx: &mut FunctionCx<'a, 'tcx>, field: mir::Field) -> CValue<'tcx> where 'tcx: 'a {\n-        use rustc::ty::util::IntTypeExt;\n-\n         let (base, layout) = match self {\n             CValue::ByRef(addr, layout) => (addr, layout),\n             _ => bug!(\"place_field for {:?}\", self),\n         };\n-        let field_offset = layout.fields.offset(field.index());\n-        let field_layout = if field.index() == 0 {\n-            fx.layout_of(if let ty::TyAdt(adt_def, _) = layout.ty.sty {\n-                adt_def.repr.discr_type().to_ty(fx.tcx)\n-            } else {\n-                // This can only be `0`, for now, so `u8` will suffice.\n-                fx.tcx.types.u8\n-            })\n-        } else {\n-            layout.field(&*fx, field.index())\n-        };\n-        if field_offset.bytes() > 0 {\n-            let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n-            CValue::ByRef(fx.bcx.ins().iadd(base, field_offset), field_layout)\n-        } else {\n-            CValue::ByRef(base, field_layout)\n-        }\n+\n+        let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n+        CValue::ByRef(field_ptr, field_layout)\n     }\n \n     pub fn const_val<'a>(fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>, const_val: i64) -> CValue<'tcx> where 'tcx: 'a {\n@@ -252,14 +258,9 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     pub fn place_field(self, fx: &mut FunctionCx<'a, 'tcx>, field: mir::Field) -> CPlace<'tcx> {\n         let base = self.expect_addr();\n         let layout = self.layout();\n-        let field_offset = layout.fields.offset(field.index());\n-        let field_ty = layout.field(&*fx, field.index());\n-        if field_offset.bytes() > 0 {\n-            let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n-            CPlace::Addr(fx.bcx.ins().iadd(base, field_offset), field_ty)\n-        } else {\n-            CPlace::Addr(base, field_ty)\n-        }\n+\n+        let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n+        CPlace::Addr(field_ptr, field_layout)\n     }\n \n     pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {"}]}