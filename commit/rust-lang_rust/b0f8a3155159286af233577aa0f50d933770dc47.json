{"sha": "b0f8a3155159286af233577aa0f50d933770dc47", "node_id": "C_kwDOAAsO6NoAKGIwZjhhMzE1NTE1OTI4NmFmMjMzNTc3YWEwZjUwZDkzMzc3MGRjNDc", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-06T13:53:20Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-06T14:12:30Z"}, "message": "Cleanup `manual_non_exhaustive`", "tree": {"sha": "4003ca3a4e6fe1f998714c28d8460fc881675bcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4003ca3a4e6fe1f998714c28d8460fc881675bcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0f8a3155159286af233577aa0f50d933770dc47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0f8a3155159286af233577aa0f50d933770dc47", "html_url": "https://github.com/rust-lang/rust/commit/b0f8a3155159286af233577aa0f50d933770dc47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0f8a3155159286af233577aa0f50d933770dc47/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4", "html_url": "https://github.com/rust-lang/rust/commit/6e20a634e7a87a8c0234397e9fdcd8d8dea4e0f4"}], "stats": {"total": 83, "additions": 32, "deletions": 51}, "files": [{"sha": "2501dd5bed4b738dc19df66c2ae2983e109b5f8a", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 32, "deletions": 51, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b0f8a3155159286af233577aa0f50d933770dc47/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f8a3155159286af233577aa0f50d933770dc47/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=b0f8a3155159286af233577aa0f50d933770dc47", "patch": "@@ -2,8 +2,7 @@ use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::{is_lint_allowed, meets_msrv, msrvs};\n-use if_chain::if_chain;\n-use rustc_ast::ast::{self, FieldDef, VisibilityKind};\n+use rustc_ast::ast::{self, VisibilityKind};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n@@ -104,67 +103,49 @@ impl EarlyLintPass for ManualNonExhaustiveStruct {\n         }\n \n         if let ast::ItemKind::Struct(variant_data, _) = &item.kind {\n-            if let ast::VariantData::Unit(..) = variant_data {\n+            let (fields, delimiter) = match variant_data {\n+                ast::VariantData::Struct(fields, _) => (&**fields, '{'),\n+                ast::VariantData::Tuple(fields, _) => (&**fields, '('),\n+                ast::VariantData::Unit(_) => return,\n+            };\n+            if fields.len() <= 1 {\n                 return;\n             }\n-\n-            check_manual_non_exhaustive_struct(cx, item, variant_data);\n-        }\n-    }\n-\n-    extract_msrv_attr!(EarlyContext);\n-}\n-\n-fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &ast::Item, data: &ast::VariantData) {\n-    fn is_private(field: &FieldDef) -> bool {\n-        matches!(field.vis.kind, VisibilityKind::Inherited)\n-    }\n-\n-    fn is_non_exhaustive_marker(field: &FieldDef) -> bool {\n-        is_private(field) && field.ty.kind.is_unit() && field.ident.map_or(true, |n| n.as_str().starts_with('_'))\n-    }\n-\n-    fn find_header_span(cx: &EarlyContext<'_>, item: &ast::Item, data: &ast::VariantData) -> Span {\n-        let delimiter = match data {\n-            ast::VariantData::Struct(..) => '{',\n-            ast::VariantData::Tuple(..) => '(',\n-            ast::VariantData::Unit(_) => unreachable!(\"`VariantData::Unit` is already handled above\"),\n-        };\n-\n-        cx.sess().source_map().span_until_char(item.span, delimiter)\n-    }\n-\n-    let fields = data.fields();\n-    let private_fields = fields.iter().filter(|f| is_private(f)).count();\n-    let public_fields = fields.iter().filter(|f| f.vis.kind.is_pub()).count();\n-\n-    if_chain! {\n-        if private_fields == 1 && public_fields >= 1 && public_fields == fields.len() - 1;\n-        if let Some(marker) = fields.iter().find(|f| is_non_exhaustive_marker(f));\n-        then {\n-            span_lint_and_then(\n-                cx,\n-                MANUAL_NON_EXHAUSTIVE,\n-                item.span,\n-                \"this seems like a manual implementation of the non-exhaustive pattern\",\n-                |diag| {\n-                    if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n-                        let header_span = find_header_span(cx, item, data);\n-                        if let Some(snippet) = snippet_opt(cx, header_span);\n-                        then {\n+            let mut iter = fields.iter().filter_map(|f| match f.vis.kind {\n+                VisibilityKind::Public => None,\n+                VisibilityKind::Inherited => Some(Ok(f)),\n+                _ => Some(Err(())),\n+            });\n+            if let Some(Ok(field)) = iter.next()\n+                && iter.next().is_none()\n+                && field.ty.kind.is_unit()\n+                && field.ident.map_or(true, |name| name.as_str().starts_with('_'))\n+            {\n+                span_lint_and_then(\n+                    cx,\n+                    MANUAL_NON_EXHAUSTIVE,\n+                    item.span,\n+                    \"this seems like a manual implementation of the non-exhaustive pattern\",\n+                    |diag| {\n+                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive))\n+                            && let header_span = cx.sess().source_map().span_until_char(item.span, delimiter)\n+                            && let Some(snippet) = snippet_opt(cx, header_span)\n+                        {\n                             diag.span_suggestion(\n                                 header_span,\n                                 \"add the attribute\",\n                                 format!(\"#[non_exhaustive] {}\", snippet),\n                                 Applicability::Unspecified,\n                             );\n                         }\n+                        diag.span_help(field.span, \"remove this field\");\n                     }\n-                    diag.span_help(marker.span, \"remove this field\");\n-                });\n+                );\n+            }\n         }\n     }\n+\n+    extract_msrv_attr!(EarlyContext);\n }\n \n impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {"}]}