{"sha": "8c9cb06c2ec287e4b9d2bce79390b444752c3686", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjOWNiMDZjMmVjMjg3ZTRiOWQyYmNlNzkzOTBiNDQ0NzUyYzM2ODY=", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-07-10T21:53:25Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-09-21T20:37:29Z"}, "message": "Deny unsafe op in unsafe fns without the unsafe keyword, first part for std/thread", "tree": {"sha": "3a0b5d8c7f902b9aacc3bbed8e38e7f29a36f6ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a0b5d8c7f902b9aacc3bbed8e38e7f29a36f6ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c9cb06c2ec287e4b9d2bce79390b444752c3686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c9cb06c2ec287e4b9d2bce79390b444752c3686", "html_url": "https://github.com/rust-lang/rust/commit/8c9cb06c2ec287e4b9d2bce79390b444752c3686", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c9cb06c2ec287e4b9d2bce79390b444752c3686/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eff9b0b29a8898c839d46f3c66526710afed68a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eff9b0b29a8898c839d46f3c66526710afed68a", "html_url": "https://github.com/rust-lang/rust/commit/4eff9b0b29a8898c839d46f3c66526710afed68a"}], "stats": {"total": 127, "additions": 91, "deletions": 36}, "files": [{"sha": "991631d91f0b2bdd66775717e5772b01eb72cf2d", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 71, "deletions": 28, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/8c9cb06c2ec287e4b9d2bce79390b444752c3686/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9cb06c2ec287e4b9d2bce79390b444752c3686/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=8c9cb06c2ec287e4b9d2bce79390b444752c3686", "patch": "@@ -288,7 +288,11 @@ mod lazy {\n         }\n \n         pub unsafe fn get(&self) -> Option<&'static T> {\n-            (*self.inner.get()).as_ref()\n+            // SAFETY: No reference is ever handed out to the inner cell nor\n+            // mutable reference to the Option<T> inside said cell. This make it\n+            // safe to hand a reference, though the lifetime of 'static\n+            // is itself unsafe, making the get method unsafe.\n+            unsafe { (*self.inner.get()).as_ref() }\n         }\n \n         pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n@@ -297,6 +301,8 @@ mod lazy {\n             let value = init();\n             let ptr = self.inner.get();\n \n+            // SAFETY:\n+            //\n             // note that this can in theory just be `*ptr = Some(value)`, but due to\n             // the compiler will currently codegen that pattern with something like:\n             //\n@@ -309,22 +315,31 @@ mod lazy {\n             // value (an aliasing violation). To avoid setting the \"I'm running a\n             // destructor\" flag we just use `mem::replace` which should sequence the\n             // operations a little differently and make this safe to call.\n-            let _ = mem::replace(&mut *ptr, Some(value));\n-\n-            // After storing `Some` we want to get a reference to the contents of\n-            // what we just stored. While we could use `unwrap` here and it should\n-            // always work it empirically doesn't seem to always get optimized away,\n-            // which means that using something like `try_with` can pull in\n-            // panicking code and cause a large size bloat.\n-            match *ptr {\n-                Some(ref x) => x,\n-                None => hint::unreachable_unchecked(),\n+            unsafe {\n+                let _ = mem::replace(&mut *ptr, Some(value));\n+            }\n+\n+            // SAFETY: the *ptr operation is made safe by the `mem::replace`\n+            // call above that made sure a valid value is present behind it.\n+            unsafe {\n+                // After storing `Some` we want to get a reference to the contents of\n+                // what we just stored. While we could use `unwrap` here and it should\n+                // always work it empirically doesn't seem to always get optimized away,\n+                // which means that using something like `try_with` can pull in\n+                // panicking code and cause a large size bloat.\n+                match *ptr {\n+                    Some(ref x) => x,\n+                    None => hint::unreachable_unchecked(),\n+                }\n             }\n         }\n \n         #[allow(unused)]\n         pub unsafe fn take(&mut self) -> Option<T> {\n-            (*self.inner.get()).take()\n+            // SAFETY: The other methods hand out references while taking &self.\n+            // As such, calling this method when such references are still alive\n+            // will fail because it takes a &mut self, conflicting with them.\n+            unsafe { (*self.inner.get()).take() }\n         }\n     }\n }\n@@ -413,9 +428,17 @@ pub mod fast {\n         }\n \n         pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n-            match self.inner.get() {\n-                Some(val) => Some(val),\n-                None => self.try_initialize(init),\n+            // SAFETY: See the definitions of `LazyKeyInner::get` and\n+            // `try_initialize` for more informations.\n+            //\n+            // The call to `get` is made safe because no mutable references are\n+            // ever handed out and the `try_initialize` is dependant on the\n+            // passed `init` function.\n+            unsafe {\n+                match self.inner.get() {\n+                    Some(val) => Some(val),\n+                    None => self.try_initialize(init),\n+                }\n             }\n         }\n \n@@ -428,8 +451,10 @@ pub mod fast {\n         // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n         #[inline(never)]\n         unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n-            if !mem::needs_drop::<T>() || self.try_register_dtor() {\n-                Some(self.inner.initialize(init))\n+            // SAFETY: See comment above.\n+            if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n+                // SAFETY: See comment above.\n+                Some(unsafe { self.inner.initialize(init) })\n             } else {\n                 None\n             }\n@@ -441,8 +466,12 @@ pub mod fast {\n         unsafe fn try_register_dtor(&self) -> bool {\n             match self.dtor_state.get() {\n                 DtorState::Unregistered => {\n-                    // dtor registration happens before initialization.\n-                    register_dtor(self as *const _ as *mut u8, destroy_value::<T>);\n+                    // SAFETY: dtor registration happens before initialization.\n+                    // Passing `self` as a pointer while using `destroy_value<T>`\n+                    // is safe because the function will build a pointer to a\n+                    // Key<T>, which is the type of self and so find the correct\n+                    // size.\n+                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n                     self.dtor_state.set(DtorState::Registered);\n                     true\n                 }\n@@ -458,13 +487,21 @@ pub mod fast {\n     unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n         let ptr = ptr as *mut Key<T>;\n \n+        // SAFETY:\n+        //\n+        // The pointer `ptr` has been built just above and comes from\n+        // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n+        // making it non-NUL and of the correct type.\n+        //\n         // Right before we run the user destructor be sure to set the\n         // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n         // causes future calls to `get` to run `try_initialize_drop` again,\n         // which will now fail, and return `None`.\n-        let value = (*ptr).inner.take();\n-        (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n-        drop(value);\n+        unsafe {\n+            let value = (*ptr).inner.take();\n+            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n+            drop(value);\n+        }\n     }\n }\n \n@@ -533,22 +570,28 @@ pub mod os {\n                 ptr\n             };\n \n-            Some((*ptr).inner.initialize(init))\n+            // SAFETY: ptr has been ensured as non-NUL just above an so can be\n+            // dereferenced safely.\n+            unsafe { Some((*ptr).inner.initialize(init)) }\n         }\n     }\n \n     unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n+        // SAFETY:\n+        //\n         // The OS TLS ensures that this key contains a NULL value when this\n         // destructor starts to run. We set it back to a sentinel value of 1 to\n         // ensure that any future calls to `get` for this thread will return\n         // `None`.\n         //\n         // Note that to prevent an infinite loop we reset it back to null right\n         // before we return from the destructor ourselves.\n-        let ptr = Box::from_raw(ptr as *mut Value<T>);\n-        let key = ptr.key;\n-        key.os.set(1 as *mut u8);\n-        drop(ptr);\n-        key.os.set(ptr::null_mut());\n+        unsafe {\n+            let ptr = Box::from_raw(ptr as *mut Value<T>);\n+            let key = ptr.key;\n+            key.os.set(1 as *mut u8);\n+            drop(ptr);\n+            key.os.set(ptr::null_mut());\n+        }\n     }\n }"}, {"sha": "8c353e2484ef2a6e7f5c836306dbb1f752c087ff", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c9cb06c2ec287e4b9d2bce79390b444752c3686/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c9cb06c2ec287e4b9d2bce79390b444752c3686/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=8c9cb06c2ec287e4b9d2bce79390b444752c3686", "patch": "@@ -144,6 +144,7 @@\n //! [`with`]: LocalKey::with\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n@@ -456,14 +457,23 @@ impl Builder {\n                 imp::Thread::set_name(name);\n             }\n \n-            thread_info::set(imp::guard::current(), their_thread);\n+            // SAFETY: the stack guard passed is the one for the current thread.\n+            // This means the current thread's stack and the new thread's stack\n+            // are properly set and protected from each other.\n+            thread_info::set(unsafe { imp::guard::current() }, their_thread);\n             let try_result = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n                 crate::sys_common::backtrace::__rust_begin_short_backtrace(f)\n             }));\n-            *their_packet.get() = Some(try_result);\n+            // SAFETY: `their_packet` as been built just above and moved by the\n+            // closure (it is an Arc<...>) and `my_packet` will be stored in the\n+            // same `JoinInner` as this closure meaning the mutation will be\n+            // safe (not modify it and affect a value far away).\n+            unsafe { *their_packet.get() = Some(try_result) };\n         };\n \n         Ok(JoinHandle(JoinInner {\n+            // SAFETY:\n+            //\n             // `imp::Thread::new` takes a closure with a `'static` lifetime, since it's passed\n             // through FFI or otherwise used with low-level threading primitives that have no\n             // notion of or way to enforce lifetimes.\n@@ -475,12 +485,14 @@ impl Builder {\n             // Similarly, the `sys` implementation must guarantee that no references to the closure\n             // exist after the thread has terminated, which is signaled by `Thread::join`\n             // returning.\n-            native: Some(imp::Thread::new(\n-                stack_size,\n-                mem::transmute::<Box<dyn FnOnce() + 'a>, Box<dyn FnOnce() + 'static>>(Box::new(\n-                    main,\n-                )),\n-            )?),\n+            native: unsafe {\n+                Some(imp::Thread::new(\n+                    stack_size,\n+                    mem::transmute::<Box<dyn FnOnce() + 'a>, Box<dyn FnOnce() + 'static>>(\n+                        Box::new(main),\n+                    ),\n+                )?)\n+            },\n             thread: my_thread,\n             packet: Packet(my_packet),\n         }))"}]}