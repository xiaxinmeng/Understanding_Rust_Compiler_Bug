{"sha": "8556e6620e4866526b3cea767ad8c20ae877a569", "node_id": "C_kwDOAAsO6NoAKDg1NTZlNjYyMGU0ODY2NTI2YjNjZWE3NjdhZDhjMjBhZTg3N2E1Njk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-16T05:13:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-16T05:13:38Z"}, "message": "Auto merge of #100611 - matthiaskrgr:rollup-rxj10ur, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #100338 (when there are 3 or more return statements in the loop)\n - #100384 (Add support for generating unique profraw files by default when using `-C instrument-coverage`)\n - #100460 (Update the minimum external LLVM to 13)\n - #100567 (Add missing closing quote)\n - #100590 (Suggest adding an array length if possible)\n - #100600 (Rename Machine memory hooks to suggest when they run)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "13d9f9ec09bd402a73d9e1e01f5b6bef7f486544", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13d9f9ec09bd402a73d9e1e01f5b6bef7f486544"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8556e6620e4866526b3cea767ad8c20ae877a569", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8556e6620e4866526b3cea767ad8c20ae877a569", "html_url": "https://github.com/rust-lang/rust/commit/8556e6620e4866526b3cea767ad8c20ae877a569", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8556e6620e4866526b3cea767ad8c20ae877a569/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef9810a3e2a9a16e79176cb0d3466ea82d239942", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9810a3e2a9a16e79176cb0d3466ea82d239942", "html_url": "https://github.com/rust-lang/rust/commit/ef9810a3e2a9a16e79176cb0d3466ea82d239942"}, {"sha": "88af506e948d3a5e1aca5fe68a2d926d7cabefdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/88af506e948d3a5e1aca5fe68a2d926d7cabefdd", "html_url": "https://github.com/rust-lang/rust/commit/88af506e948d3a5e1aca5fe68a2d926d7cabefdd"}], "stats": {"total": 653, "additions": 318, "deletions": 335}, "files": [{"sha": "7eb41fec36aba9615db2496eb479ad96106abbd0", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -43,7 +43,7 @@ jobs:\n           - name: mingw-check\n             os: ubuntu-20.04-xl\n             env: {}\n-          - name: x86_64-gnu-llvm-12\n+          - name: x86_64-gnu-llvm-13\n             os: ubuntu-20.04-xl\n             env: {}\n           - name: x86_64-gnu-tools\n@@ -274,11 +274,11 @@ jobs:\n           - name: x86_64-gnu-distcheck\n             os: ubuntu-20.04-xl\n             env: {}\n-          - name: x86_64-gnu-llvm-12\n+          - name: x86_64-gnu-llvm-13\n             env:\n               RUST_BACKTRACE: 1\n             os: ubuntu-20.04-xl\n-          - name: x86_64-gnu-llvm-12-stage1\n+          - name: x86_64-gnu-llvm-13-stage1\n             env:\n               RUST_BACKTRACE: 1\n             os: ubuntu-20.04-xl"}, {"sha": "488bd05fd6b895a4011b88f79dd0192ab812a604", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -48,7 +48,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{struct_span_err, Applicability, Handler};\n+use rustc_errors::{struct_span_err, Applicability, Handler, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -2233,7 +2233,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         c.value.span,\n                         \"using `_` for array lengths is unstable\",\n                     )\n-                    .emit();\n+                    .stash(c.value.span, StashKey::UnderscoreForArrayLengths);\n                     hir::ArrayLen::Body(self.lower_anon_const(c))\n                 }\n             }"}, {"sha": "2a6612eb86f12c62b41f516b41dfe18c5cd40806", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -3,7 +3,6 @@ use crate::builder::Builder;\n use crate::common::Funclet;\n use crate::context::CodegenCx;\n use crate::llvm;\n-use crate::llvm_util;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n@@ -419,13 +418,6 @@ pub(crate) fn inline_asm_call<'ll>(\n         let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons.as_ptr().cast(), cons.len());\n         debug!(\"constraint verification result: {:?}\", constraints_ok);\n         if constraints_ok {\n-            if unwind && llvm_util::get_version() < (13, 0, 0) {\n-                bx.cx.sess().span_fatal(\n-                    line_spans[0],\n-                    \"unwinding from inline assembly is only supported on llvm >= 13.\",\n-                );\n-            }\n-\n             let v = llvm::LLVMRustInlineAsm(\n                 fty,\n                 asm.as_ptr().cast(),"}, {"sha": "740a68d0772c1632ba54061cc8bb783591eecfd6", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -5,7 +5,7 @@ use crate::back::profiling::{\n use crate::base;\n use crate::common;\n use crate::consts;\n-use crate::llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic};\n+use crate::llvm::{self, DiagnosticInfo, PassManager};\n use crate::llvm_util;\n use crate::type_::Type;\n use crate::LlvmCodegenBackend;\n@@ -304,17 +304,14 @@ impl<'a> DiagnosticHandlers<'a> {\n                 remark_passes.as_ptr(),\n                 remark_passes.len(),\n             );\n-            llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, data.cast());\n             DiagnosticHandlers { data, llcx, old_handler }\n         }\n     }\n }\n \n impl<'a> Drop for DiagnosticHandlers<'a> {\n     fn drop(&mut self) {\n-        use std::ptr::null_mut;\n         unsafe {\n-            llvm::LLVMRustSetInlineAsmDiagnosticHandler(self.llcx, inline_asm_handler, null_mut());\n             llvm::LLVMRustContextSetDiagnosticHandler(self.llcx, self.old_handler);\n             drop(Box::from_raw(self.data));\n         }\n@@ -342,16 +339,6 @@ fn report_inline_asm(\n     cgcx.diag_emitter.inline_asm_error(cookie as u32, msg, level, source);\n }\n \n-unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic, user: *const c_void, cookie: c_uint) {\n-    if user.is_null() {\n-        return;\n-    }\n-    let (cgcx, _) = *(user as *const (&CodegenContext<LlvmCodegenBackend>, &Handler));\n-\n-    let smdiag = llvm::diagnostic::SrcMgrDiagnostic::unpack(diag);\n-    report_inline_asm(cgcx, smdiag.message, smdiag.level, cookie, smdiag.source);\n-}\n-\n unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void) {\n     if user.is_null() {\n         return;\n@@ -423,6 +410,14 @@ fn get_pgo_sample_use_path(config: &ModuleConfig) -> Option<CString> {\n         .map(|path_buf| CString::new(path_buf.to_string_lossy().as_bytes()).unwrap())\n }\n \n+fn get_instr_profile_output_path(config: &ModuleConfig) -> Option<CString> {\n+    if config.instrument_coverage {\n+        Some(CString::new(\"default_%m_%p.profraw\").unwrap())\n+    } else {\n+        None\n+    }\n+}\n+\n pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n@@ -438,6 +433,7 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n     let pgo_use_path = get_pgo_use_path(config);\n     let pgo_sample_use_path = get_pgo_sample_use_path(config);\n     let is_lto = opt_stage == llvm::OptStage::ThinLTO || opt_stage == llvm::OptStage::FatLTO;\n+    let instr_profile_output_path = get_instr_profile_output_path(config);\n     // Sanitizer instrumentation is only inserted during the pre-link optimization stage.\n     let sanitizer_options = if !is_lto {\n         Some(llvm::SanitizerOptions {\n@@ -488,6 +484,7 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n         pgo_gen_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n         pgo_use_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n         config.instrument_coverage,\n+        instr_profile_output_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n         config.instrument_gcov,\n         pgo_sample_use_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n         config.debug_info_for_profiling,"}, {"sha": "073feecb1647f1b37236479ff828f9c6ae938f09", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 25, "deletions": 54, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -3,7 +3,6 @@ use crate::common::Funclet;\n use crate::context::CodegenCx;\n use crate::llvm::{self, BasicBlock, False};\n use crate::llvm::{AtomicOrdering, AtomicRmwBinOp, SynchronizationScope};\n-use crate::llvm_util;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n@@ -1038,25 +1037,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         dst: &'ll Value,\n         cmp: &'ll Value,\n         src: &'ll Value,\n-        mut order: rustc_codegen_ssa::common::AtomicOrdering,\n+        order: rustc_codegen_ssa::common::AtomicOrdering,\n         failure_order: rustc_codegen_ssa::common::AtomicOrdering,\n         weak: bool,\n     ) -> &'ll Value {\n         let weak = if weak { llvm::True } else { llvm::False };\n-        if llvm_util::get_version() < (13, 0, 0) {\n-            use rustc_codegen_ssa::common::AtomicOrdering::*;\n-            // Older llvm has the pre-C++17 restriction on\n-            // success and failure memory ordering,\n-            // requiring the former to be at least as strong as the latter.\n-            // So, for llvm 12, we upgrade the success ordering to a stronger\n-            // one if necessary.\n-            match (order, failure_order) {\n-                (Relaxed, Acquire) => order = Acquire,\n-                (Release, Acquire) => order = AcquireRelease,\n-                (_, SequentiallyConsistent) => order = SequentiallyConsistent,\n-                _ => {}\n-            }\n-        }\n         unsafe {\n             llvm::LLVMRustBuildAtomicCmpXchg(\n                 self.llbuilder,\n@@ -1444,51 +1429,37 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn fptoint_sat_broken_in_llvm(&self) -> bool {\n-        match self.tcx.sess.target.arch.as_ref() {\n-            // FIXME - https://bugs.llvm.org/show_bug.cgi?id=50083\n-            \"riscv64\" => llvm_util::get_version() < (13, 0, 0),\n-            _ => false,\n-        }\n-    }\n-\n     fn fptoint_sat(\n         &mut self,\n         signed: bool,\n         val: &'ll Value,\n         dest_ty: &'ll Type,\n     ) -> Option<&'ll Value> {\n-        if !self.fptoint_sat_broken_in_llvm() {\n-            let src_ty = self.cx.val_ty(val);\n-            let (float_ty, int_ty, vector_length) = if self.cx.type_kind(src_ty) == TypeKind::Vector\n-            {\n-                assert_eq!(self.cx.vector_length(src_ty), self.cx.vector_length(dest_ty));\n-                (\n-                    self.cx.element_type(src_ty),\n-                    self.cx.element_type(dest_ty),\n-                    Some(self.cx.vector_length(src_ty)),\n-                )\n-            } else {\n-                (src_ty, dest_ty, None)\n-            };\n-            let float_width = self.cx.float_width(float_ty);\n-            let int_width = self.cx.int_width(int_ty);\n-\n-            let instr = if signed { \"fptosi\" } else { \"fptoui\" };\n-            let name = if let Some(vector_length) = vector_length {\n-                format!(\n-                    \"llvm.{}.sat.v{}i{}.v{}f{}\",\n-                    instr, vector_length, int_width, vector_length, float_width\n-                )\n-            } else {\n-                format!(\"llvm.{}.sat.i{}.f{}\", instr, int_width, float_width)\n-            };\n-            let f =\n-                self.declare_cfn(&name, llvm::UnnamedAddr::No, self.type_func(&[src_ty], dest_ty));\n-            Some(self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None))\n+        let src_ty = self.cx.val_ty(val);\n+        let (float_ty, int_ty, vector_length) = if self.cx.type_kind(src_ty) == TypeKind::Vector {\n+            assert_eq!(self.cx.vector_length(src_ty), self.cx.vector_length(dest_ty));\n+            (\n+                self.cx.element_type(src_ty),\n+                self.cx.element_type(dest_ty),\n+                Some(self.cx.vector_length(src_ty)),\n+            )\n         } else {\n-            None\n-        }\n+            (src_ty, dest_ty, None)\n+        };\n+        let float_width = self.cx.float_width(float_ty);\n+        let int_width = self.cx.int_width(int_ty);\n+\n+        let instr = if signed { \"fptosi\" } else { \"fptoui\" };\n+        let name = if let Some(vector_length) = vector_length {\n+            format!(\n+                \"llvm.{}.sat.v{}i{}.v{}f{}\",\n+                instr, vector_length, int_width, vector_length, float_width\n+            )\n+        } else {\n+            format!(\"llvm.{}.sat.i{}.f{}\", instr, int_width, float_width)\n+        };\n+        let f = self.declare_cfn(&name, llvm::UnnamedAddr::No, self.type_func(&[src_ty], dest_ty));\n+        Some(self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None))\n     }\n \n     pub(crate) fn landing_pad("}, {"sha": "d4d84147239068184b0f54bb68c34bfa6df4c3ac", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -142,17 +142,6 @@ pub unsafe fn create_module<'ll>(\n \n     let mut target_data_layout = sess.target.data_layout.to_string();\n     let llvm_version = llvm_util::get_version();\n-    if llvm_version < (13, 0, 0) {\n-        if sess.target.arch == \"powerpc64\" {\n-            target_data_layout = target_data_layout.replace(\"-S128\", \"\");\n-        }\n-        if sess.target.arch == \"wasm32\" {\n-            target_data_layout = \"e-m:e-p:32:32-i64:64-n32:64-S128\".to_string();\n-        }\n-        if sess.target.arch == \"wasm64\" {\n-            target_data_layout = \"e-m:e-p:64:64-i64:64-n32:64-S128\".to_string();\n-        }\n-    }\n     if llvm_version < (14, 0, 0) {\n         if sess.target.llvm_target == \"i686-pc-windows-msvc\"\n             || sess.target.llvm_target == \"i586-pc-windows-msvc\""}, {"sha": "4ca3dd78caedec2f22e9cb679f44c36451ff62b7", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -2360,6 +2360,7 @@ extern \"C\" {\n         PGOGenPath: *const c_char,\n         PGOUsePath: *const c_char,\n         InstrumentCoverage: bool,\n+        InstrProfileOutput: *const c_char,\n         InstrumentGCOV: bool,\n         PGOSampleUsePath: *const c_char,\n         DebugInfoForProfiling: bool,\n@@ -2423,12 +2424,6 @@ extern \"C\" {\n         cookie_out: &mut c_uint,\n     ) -> &'a SMDiagnostic;\n \n-    pub fn LLVMRustSetInlineAsmDiagnosticHandler(\n-        C: &Context,\n-        H: InlineAsmDiagHandlerTy,\n-        CX: *mut c_void,\n-    );\n-\n     #[allow(improper_ctypes)]\n     pub fn LLVMRustUnpackSMDiagnostic(\n         d: &SMDiagnostic,"}, {"sha": "f5d676c44e3428b83677bd237daf7e5ad9ca2782", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -92,16 +92,6 @@ unsafe fn configure_llvm(sess: &Session) {\n             add(\"-generate-arange-section\", false);\n         }\n \n-        // Disable the machine outliner by default in LLVM versions 11 and LLVM\n-        // version 12, where it leads to miscompilation.\n-        //\n-        // Ref:\n-        // - https://github.com/rust-lang/rust/issues/85351\n-        // - https://reviews.llvm.org/D103167\n-        if llvm_util::get_version() < (13, 0, 0) {\n-            add(\"-enable-machine-outliner=never\", false);\n-        }\n-\n         match sess.opts.unstable_opts.merge_functions.unwrap_or(sess.target.merge_functions) {\n             MergeFunctions::Disabled | MergeFunctions::Trampolines => {}\n             MergeFunctions::Aliases => {"}, {"sha": "dedbcf43755cb118af1d5d78a2b5d97199707fb1", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -343,7 +343,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// operations take `&self`. Use a `RefCell` in `AllocExtra` if you\n     /// need to mutate.\n     #[inline(always)]\n-    fn memory_read(\n+    fn before_memory_read(\n         _tcx: TyCtxt<'tcx>,\n         _machine: &Self,\n         _alloc_extra: &Self::AllocExtra,\n@@ -355,7 +355,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n \n     /// Hook for performing extra checks on a memory write access.\n     #[inline(always)]\n-    fn memory_written(\n+    fn before_memory_write(\n         _tcx: TyCtxt<'tcx>,\n         _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,\n@@ -367,7 +367,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n \n     /// Hook for performing extra operations on a memory deallocation.\n     #[inline(always)]\n-    fn memory_deallocated(\n+    fn before_memory_deallocation(\n         _tcx: TyCtxt<'tcx>,\n         _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,"}, {"sha": "98e0c8cd78ea4d3fb2ad8a33fee82c5b6ee2d7b0", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -327,7 +327,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // Let the machine take some extra action\n         let size = alloc.size();\n-        M::memory_deallocated(\n+        M::before_memory_deallocation(\n             *self.tcx,\n             &mut self.machine,\n             &mut alloc.extra,\n@@ -575,7 +575,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         )?;\n         if let Some((alloc_id, offset, prov, alloc)) = ptr_and_alloc {\n             let range = alloc_range(offset, size);\n-            M::memory_read(*self.tcx, &self.machine, &alloc.extra, (alloc_id, prov), range)?;\n+            M::before_memory_read(*self.tcx, &self.machine, &alloc.extra, (alloc_id, prov), range)?;\n             Ok(Some(AllocRef { alloc, range, tcx: *self.tcx, alloc_id }))\n         } else {\n             // Even in this branch we have to be sure that we actually access the allocation, in\n@@ -641,7 +641,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // We cannot call `get_raw_mut` inside `check_and_deref_ptr` as that would duplicate `&mut self`.\n             let (alloc, machine) = self.get_alloc_raw_mut(alloc_id)?;\n             let range = alloc_range(offset, size);\n-            M::memory_written(tcx, machine, &mut alloc.extra, (alloc_id, prov), range)?;\n+            M::before_memory_write(tcx, machine, &mut alloc.extra, (alloc_id, prov), range)?;\n             Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id }))\n         } else {\n             Ok(None)\n@@ -1078,7 +1078,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         let src_alloc = self.get_alloc_raw(src_alloc_id)?;\n         let src_range = alloc_range(src_offset, size);\n-        M::memory_read(*tcx, &self.machine, &src_alloc.extra, (src_alloc_id, src_prov), src_range)?;\n+        M::before_memory_read(\n+            *tcx,\n+            &self.machine,\n+            &src_alloc.extra,\n+            (src_alloc_id, src_prov),\n+            src_range,\n+        )?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n         let Some((dest_alloc_id, dest_offset, dest_prov)) = dest_parts else {\n@@ -1103,7 +1109,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Destination alloc preparations and access hooks.\n         let (dest_alloc, extra) = self.get_alloc_raw_mut(dest_alloc_id)?;\n         let dest_range = alloc_range(dest_offset, size * num_copies);\n-        M::memory_written(\n+        M::before_memory_write(\n             *tcx,\n             extra,\n             &mut dest_alloc.extra,"}, {"sha": "395bf5aad01b60cf47a67e016f11df7104829987", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -457,6 +457,7 @@ struct HandlerInner {\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub enum StashKey {\n     ItemNoType,\n+    UnderscoreForArrayLengths,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}"}, {"sha": "7d3bedbfe43199132310c6e9b134f573a9b637a2", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -277,7 +277,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(ignore, Normal, template!(Word, NameValueStr: \"reason\"), WarnFollowing),\n     ungated!(\n         should_panic, Normal,\n-        template!(Word, List: r#\"expected = \"reason\"#, NameValueStr: \"reason\"), FutureWarnFollowing,\n+        template!(Word, List: r#\"expected = \"reason\"\"#, NameValueStr: \"reason\"), FutureWarnFollowing,\n     ),\n     // FIXME(Centril): This can be used on stable but shouldn't.\n     ungated!(reexport_test_harness_main, CrateLevel, template!(NameValueStr: \"name\"), ErrorFollowing),"}, {"sha": "7da6ab71309ddff57b11120ed1f0450616c97b5f", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -24,17 +24,10 @@ extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n     const char* const Filenames[],\n     size_t FilenamesLen,\n     RustStringRef BufferOut) {\n-#if LLVM_VERSION_GE(13,0)\n   SmallVector<std::string,32> FilenameRefs;\n   for (size_t i = 0; i < FilenamesLen; i++) {\n     FilenameRefs.push_back(std::string(Filenames[i]));\n   }\n-#else\n-  SmallVector<StringRef,32> FilenameRefs;\n-  for (size_t i = 0; i < FilenamesLen; i++) {\n-    FilenameRefs.push_back(StringRef(Filenames[i]));\n-  }\n-#endif\n   auto FilenamesWriter = coverage::CoverageFilenamesSectionWriter(\n     makeArrayRef(FilenameRefs));\n   RawRustStringOstream OS(BufferOut);\n@@ -109,9 +102,5 @@ extern \"C\" void LLVMRustCoverageWriteMappingVarNameToString(RustStringRef Str) {\n }\n \n extern \"C\" uint32_t LLVMRustCoverageMappingVersion() {\n-#if LLVM_VERSION_GE(13, 0)\n   return coverage::CovMapVersion::Version6;\n-#else\n-  return coverage::CovMapVersion::Version5;\n-#endif\n }"}, {"sha": "b4314223722fce0aee8a975a23b7427a8506bef3", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -822,7 +822,8 @@ LLVMRustOptimizeWithNewPassManager(\n     bool DisableSimplifyLibCalls, bool EmitLifetimeMarkers,\n     LLVMRustSanitizerOptions *SanitizerOptions,\n     const char *PGOGenPath, const char *PGOUsePath,\n-    bool InstrumentCoverage, bool InstrumentGCOV,\n+    bool InstrumentCoverage, const char *InstrProfileOutput,\n+    bool InstrumentGCOV,\n     const char *PGOSampleUsePath, bool DebugInfoForProfiling,\n     void* LlvmSelfProfiler,\n     LLVMRustSelfProfileBeforePassCallback BeforePassCallback,\n@@ -869,19 +870,11 @@ LLVMRustOptimizeWithNewPassManager(\n                         PGOOptions::NoCSAction, DebugInfoForProfiling);\n   }\n \n-#if LLVM_VERSION_GE(13, 0)\n   PassBuilder PB(TM, PTO, PGOOpt, &PIC);\n   LoopAnalysisManager LAM;\n   FunctionAnalysisManager FAM;\n   CGSCCAnalysisManager CGAM;\n   ModuleAnalysisManager MAM;\n-#else\n-  PassBuilder PB(DebugPassManager, TM, PTO, PGOOpt, &PIC);\n-  LoopAnalysisManager LAM(DebugPassManager);\n-  FunctionAnalysisManager FAM(DebugPassManager);\n-  CGSCCAnalysisManager CGAM(DebugPassManager);\n-  ModuleAnalysisManager MAM(DebugPassManager);\n-#endif\n \n   FAM.registerPass([&] { return PB.buildDefaultAAPipeline(); });\n \n@@ -922,8 +915,11 @@ LLVMRustOptimizeWithNewPassManager(\n \n   if (InstrumentCoverage) {\n     PipelineStartEPCallbacks.push_back(\n-      [](ModulePassManager &MPM, OptimizationLevel Level) {\n+      [InstrProfileOutput](ModulePassManager &MPM, OptimizationLevel Level) {\n         InstrProfOptions Options;\n+        if (InstrProfileOutput) {\n+          Options.InstrProfileOutput = InstrProfileOutput;\n+        }\n         MPM.addPass(InstrProfiling(Options, false));\n       }\n     );\n@@ -1015,11 +1011,7 @@ LLVMRustOptimizeWithNewPassManager(\n     }\n   }\n \n-#if LLVM_VERSION_GE(13, 0)\n   ModulePassManager MPM;\n-#else\n-  ModulePassManager MPM(DebugPassManager);\n-#endif\n   bool NeedThinLTOBufferPasses = UseThinLTOBuffers;\n   if (!NoPrepopulatePasses) {\n     // The pre-link pipelines don't support O0 and require using budilO0DefaultPipeline() instead.\n@@ -1434,17 +1426,13 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n     Ret->ResolvedODR[ModuleIdentifier][GUID] = NewLinkage;\n   };\n \n-#if LLVM_VERSION_GE(13,0)\n   // Uses FromPrevailing visibility scheme which works for many binary\n   // formats. We probably could and should use ELF visibility scheme for many of\n   // our targets, however.\n   lto::Config conf;\n   thinLTOResolvePrevailingInIndex(conf, Ret->Index, isPrevailing, recordNewLinkage,\n                                   Ret->GUIDPreservedSymbols);\n-#else\n-  thinLTOResolvePrevailingInIndex(Ret->Index, isPrevailing, recordNewLinkage,\n-                                  Ret->GUIDPreservedSymbols);\n-#endif\n+\n   // Here we calculate an `ExportedGUIDs` set for use in the `isExported`\n   // callback below. This callback below will dictate the linkage for all\n   // summaries in the index, and we basically just only want to ensure that dead"}, {"sha": "931ce78721cb862b7b83d28352bd3bdbbfc6ff15", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -413,18 +413,12 @@ LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Target,\n                            LLVMValueRef Old, LLVMValueRef Source,\n                            LLVMAtomicOrdering Order,\n                            LLVMAtomicOrdering FailureOrder, LLVMBool Weak) {\n-#if LLVM_VERSION_GE(13,0)\n   // Rust probably knows the alignment of the target value and should be able to\n   // specify something more precise than MaybeAlign here. See also\n   // https://reviews.llvm.org/D97224 which may be a useful reference.\n   AtomicCmpXchgInst *ACXI = unwrap(B)->CreateAtomicCmpXchg(\n       unwrap(Target), unwrap(Old), unwrap(Source), llvm::MaybeAlign(), fromRust(Order),\n       fromRust(FailureOrder));\n-#else\n-  AtomicCmpXchgInst *ACXI = unwrap(B)->CreateAtomicCmpXchg(\n-      unwrap(Target), unwrap(Old), unwrap(Source), fromRust(Order),\n-      fromRust(FailureOrder));\n-#endif\n   ACXI->setWeak(Weak);\n   return wrap(ACXI);\n }\n@@ -472,19 +466,11 @@ LLVMRustInlineAsm(LLVMTypeRef Ty, char *AsmString, size_t AsmStringLen,\n                   char *Constraints, size_t ConstraintsLen,\n                   LLVMBool HasSideEffects, LLVMBool IsAlignStack,\n                   LLVMRustAsmDialect Dialect, LLVMBool CanThrow) {\n-#if LLVM_VERSION_GE(13, 0)\n   return wrap(InlineAsm::get(unwrap<FunctionType>(Ty),\n                              StringRef(AsmString, AsmStringLen),\n                              StringRef(Constraints, ConstraintsLen),\n                              HasSideEffects, IsAlignStack,\n                              fromRust(Dialect), CanThrow));\n-#else\n-  return wrap(InlineAsm::get(unwrap<FunctionType>(Ty),\n-                             StringRef(AsmString, AsmStringLen),\n-                             StringRef(Constraints, ConstraintsLen),\n-                             HasSideEffects, IsAlignStack,\n-                             fromRust(Dialect)));\n-#endif\n }\n \n extern \"C\" bool LLVMRustInlineAsmVerify(LLVMTypeRef Ty, char *Constraints,\n@@ -1274,10 +1260,8 @@ static LLVMRustDiagnosticKind toRust(DiagnosticKind Kind) {\n     return LLVMRustDiagnosticKind::Linker;\n   case DK_Unsupported:\n     return LLVMRustDiagnosticKind::Unsupported;\n-#if LLVM_VERSION_GE(13, 0)\n   case DK_SrcMgr:\n     return LLVMRustDiagnosticKind::SrcMgr;\n-#endif\n   default:\n     return (Kind >= DK_FirstRemark && Kind <= DK_LastRemark)\n                ? LLVMRustDiagnosticKind::OptimizationRemarkOther\n@@ -1351,30 +1335,11 @@ extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(SMDiagnostic, LLVMSMDiagnosticRef)\n \n-#if LLVM_VERSION_LT(13, 0)\n-using LLVMInlineAsmDiagHandlerTy = LLVMContext::InlineAsmDiagHandlerTy;\n-#else\n-using LLVMInlineAsmDiagHandlerTy = void*;\n-#endif\n-\n-extern \"C\" void LLVMRustSetInlineAsmDiagnosticHandler(\n-    LLVMContextRef C, LLVMInlineAsmDiagHandlerTy H, void *CX) {\n-  // Diagnostic handlers were unified in LLVM change 5de2d189e6ad, so starting\n-  // with LLVM 13 this function is gone.\n-#if LLVM_VERSION_LT(13, 0)\n-  unwrap(C)->setInlineAsmDiagnosticHandler(H, CX);\n-#endif\n-}\n-\n extern \"C\" LLVMSMDiagnosticRef LLVMRustGetSMDiagnostic(\n     LLVMDiagnosticInfoRef DI, unsigned *Cookie) {\n-#if LLVM_VERSION_GE(13, 0)\n   llvm::DiagnosticInfoSrcMgr *SM = static_cast<llvm::DiagnosticInfoSrcMgr *>(unwrap(DI));\n   *Cookie = SM->getLocCookie();\n   return wrap(&SM->getSMDiag());\n-#else\n-  report_fatal_error(\"Shouldn't get called on older versions\");\n-#endif\n }\n \n extern \"C\" bool LLVMRustUnpackSMDiagnostic(LLVMSMDiagnosticRef DRef,"}, {"sha": "da575cb1367b8ea23c164ec96f629275e09db5e9", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1594,7 +1594,9 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         let hir::ExprKind::Loop(_, _, _, loop_span) = expr.kind else { return;};\n         let mut span: MultiSpan = vec![loop_span].into();\n         span.push_span_label(loop_span, \"this might have zero elements to iterate on\");\n-        for ret_expr in ret_exprs {\n+        const MAXITER: usize = 3;\n+        let iter = ret_exprs.iter().take(MAXITER);\n+        for ret_expr in iter {\n             span.push_span_label(\n                 ret_expr.span,\n                 \"if the loop doesn't execute, this value would never get returned\",\n@@ -1604,6 +1606,12 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             span,\n             \"the function expects a value to always be returned, but loops might run zero times\",\n         );\n+        if MAXITER < ret_exprs.len() {\n+            err.note(&format!(\n+                \"if the loop doesn't execute, {} other values would never get returned\",\n+                ret_exprs.len() - MAXITER\n+            ));\n+        }\n         err.help(\n             \"return a value for the case when the loop has zero elements to iterate on, or \\\n            consider changing the return type to account for that possibility\","}, {"sha": "9c2fdd875164f3822a3b6a6168c08e5b884383e9", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -28,7 +28,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticId,\n-    ErrorGuaranteed,\n+    ErrorGuaranteed, StashKey,\n };\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n@@ -1307,7 +1307,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 span: expr.span,\n             })\n         };\n-        self.tcx.mk_array(element_ty, args.len() as u64)\n+        let array_len = args.len() as u64;\n+        self.suggest_array_len(expr, array_len);\n+        self.tcx.mk_array(element_ty, array_len)\n+    }\n+\n+    fn suggest_array_len(&self, expr: &'tcx hir::Expr<'tcx>, array_len: u64) {\n+        if let Some(parent_hir_id) = self.tcx.hir().find_parent_node(expr.hir_id) {\n+            let ty = match self.tcx.hir().find(parent_hir_id) {\n+                Some(\n+                    hir::Node::Local(hir::Local { ty: Some(ty), .. })\n+                    | hir::Node::Item(hir::Item { kind: hir::ItemKind::Const(ty, _), .. }),\n+                ) => Some(ty),\n+                _ => None,\n+            };\n+            if let Some(ty) = ty\n+                && let hir::TyKind::Array(_, length) = ty.kind\n+                && let hir::ArrayLen::Body(hir::AnonConst { hir_id, .. }) = length\n+                && let Some(span) = self.tcx.hir().opt_span(hir_id)\n+            {\n+                match self.tcx.sess.diagnostic().steal_diagnostic(span, StashKey::UnderscoreForArrayLengths) {\n+                    Some(mut err) => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"consider specifying the array length\",\n+                            array_len,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        err.emit();\n+                    }\n+                    None => ()\n+                }\n+            }\n+        }\n     }\n \n     fn check_expr_const_block(\n@@ -1333,10 +1365,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         element: &'tcx hir::Expr<'tcx>,\n         count: &'tcx hir::ArrayLen,\n         expected: Expectation<'tcx>,\n-        _expr: &'tcx hir::Expr<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let count = self.array_length_to_const(count);\n+        if let Some(count) = count.try_eval_usize(tcx, self.param_env) {\n+            self.suggest_array_len(expr, count);\n+        }\n \n         let uty = match expected {\n             ExpectHasType(uty) => match *uty.kind() {"}, {"sha": "171f49022369a8544a15a70e5bbf61b2611ca426", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1139,11 +1139,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn le(&self, other: &Rhs) -> bool {\n-        // Pattern `Some(Less | Eq)` optimizes worse than negating `None | Some(Greater)`.\n-        // FIXME: The root cause was fixed upstream in LLVM with:\n-        // https://github.com/llvm/llvm-project/commit/9bad7de9a3fb844f1ca2965f35d0c2a3d1e11775\n-        // Revert this workaround once support for LLVM 12 gets dropped.\n-        !matches!(self.partial_cmp(other), None | Some(Greater))\n+        matches!(self.partial_cmp(other), Some(Less | Equal))\n     }\n \n     /// This method tests greater than (for `self` and `other`) and is used by the `>` operator."}, {"sha": "1bba5e68be446be6cd88c931dfa0a13d84f1dd86", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -515,11 +515,11 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     let version = output(cmd.arg(\"--version\"));\n     let mut parts = version.split('.').take(2).filter_map(|s| s.parse::<u32>().ok());\n     if let (Some(major), Some(_minor)) = (parts.next(), parts.next()) {\n-        if major >= 12 {\n+        if major >= 13 {\n             return;\n         }\n     }\n-    panic!(\"\\n\\nbad LLVM version: {}, need >=12.0\\n\\n\", version)\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=13.0\\n\\n\", version)\n }\n \n fn configure_cmake("}, {"sha": "21891c1244d7c9a75d2300c93756a32df7bf9d14", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-13-stage1/Dockerfile", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13-stage1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13-stage1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13-stage1%2FDockerfile?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:20.04\n+FROM ubuntu:22.04\n \n ARG DEBIAN_FRONTEND=noninteractive\n RUN apt-get update && apt-get install -y --no-install-recommends \\\n@@ -14,8 +14,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n     cmake \\\n     sudo \\\n     gdb \\\n-    llvm-12-tools \\\n-    llvm-12-dev \\\n+    llvm-13-tools \\\n+    llvm-13-dev \\\n     libedit-dev \\\n     libssl-dev \\\n     pkg-config \\\n@@ -29,7 +29,7 @@ RUN sh /scripts/sccache.sh\n # using llvm-link-shared due to libffi issues -- see #34486\n ENV RUST_CONFIGURE_ARGS \\\n     --build=x86_64-unknown-linux-gnu \\\n-    --llvm-root=/usr/lib/llvm-12 \\\n+    --llvm-root=/usr/lib/llvm-13 \\\n     --enable-llvm-link-shared \\\n     --set rust.thin-lto-import-instr-limit=10\n \n@@ -41,4 +41,4 @@ ENV SCRIPT python2.7 ../x.py --stage 1 test --exclude src/tools/tidy && \\\n     # It will also detect tests lacking `// EMIT_MIR_FOR_EACH_BIT_WIDTH`,\n     # despite having different output on 32-bit vs 64-bit targets.\n     python2.7 ../x.py --stage 1 test src/test/mir-opt \\\n-    --host='' --target=i686-unknown-linux-gnu\n\\ No newline at end of file\n+    --host='' --target=i686-unknown-linux-gnu", "previous_filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-12-stage1/Dockerfile"}, {"sha": "5f3af2f47caec7205dcf777a14bba9dcc566a2e4", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-13/Dockerfile", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:20.04\n+FROM ubuntu:22.04\n \n ARG DEBIAN_FRONTEND=noninteractive\n \n@@ -17,8 +17,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n-  llvm-12-tools \\\n-  llvm-12-dev \\\n+  llvm-13-tools \\\n+  llvm-13-dev \\\n   libedit-dev \\\n   libssl-dev \\\n   pkg-config \\\n@@ -40,7 +40,7 @@ RUN sh /scripts/sccache.sh\n # using llvm-link-shared due to libffi issues -- see #34486\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-12 \\\n+      --llvm-root=/usr/lib/llvm-13 \\\n       --enable-llvm-link-shared \\\n       --set rust.thin-lto-import-instr-limit=10\n ", "previous_filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-12/Dockerfile"}, {"sha": "91204eb0b05725e7d89f8a74f220dd086c8f98b3", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -284,7 +284,7 @@ jobs:\n           - name: mingw-check\n             <<: *job-linux-xl\n \n-          - name: x86_64-gnu-llvm-12\n+          - name: x86_64-gnu-llvm-13\n             <<: *job-linux-xl\n             \n           - name: x86_64-gnu-tools\n@@ -431,12 +431,12 @@ jobs:\n           - name: x86_64-gnu-distcheck\n             <<: *job-linux-xl\n \n-          - name: x86_64-gnu-llvm-12\n+          - name: x86_64-gnu-llvm-13\n             env:\n               RUST_BACKTRACE: 1\n             <<: *job-linux-xl\n \n-          - name: x86_64-gnu-llvm-12-stage1\n+          - name: x86_64-gnu-llvm-13-stage1\n             env:\n               RUST_BACKTRACE: 1\n             <<: *job-linux-xl"}, {"sha": "38fd5c96997631d1ce77b3348e88b7754a8ca63b", "filename": "src/doc/rustc/src/instrument-coverage.md", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -97,7 +97,17 @@ $ echo \"{some: 'thing'}\" | target/debug/examples/formatjson5 -\n }\n ```\n \n-After running this program, a new file, `default.profraw`, should be in the current working directory. It's often preferable to set a specific file name or path. You can change the output file using the environment variable `LLVM_PROFILE_FILE`:\n+After running this program, a new file named like `default_11699812450447639123_0_20944` should be in the current working directory.\n+A new, unique file name will be generated each time the program is run to avoid overwriting previous data.\n+\n+```shell\n+$ echo \"{some: 'thing'}\" | target/debug/examples/formatjson5 -\n+...\n+$ ls default_*.profraw\n+default_11699812450447639123_0_20944.profraw\n+```\n+\n+You can also set a specific file name or path for the generated `.profraw` files by using the environment variable `LLVM_PROFILE_FILE`:\n \n ```shell\n $ echo \"{some: 'thing'}\" \\\n@@ -115,6 +125,9 @@ If `LLVM_PROFILE_FILE` contains a path to a non-existent directory, the missing\n -   `%Nm` - the instrumented binary\u2019s signature: The runtime creates a pool of N raw profiles, used for on-line profile merging. The runtime takes care of selecting a raw profile from the pool, locking it, and updating it before the program exits. `N` must be between `1` and `9`, and defaults to `1` if omitted (with simply `%m`).\n -   `%c` - Does not add anything to the filename, but enables a mode (on some platforms, including Darwin) in which profile counter updates are continuously synced to a file. This means that if the instrumented program crashes, or is killed by a signal, perfect coverage information can still be recovered.\n \n+In the first example above, the value `11699812450447639123_0` in the generated filename is the instrumented binary's signature,\n+which replaced the `%m` pattern and the value `20944` is the process ID of the binary being executed.\n+\n ## Installing LLVM coverage tools\n \n LLVM's supplies two tools\u2014`llvm-profdata` and `llvm-cov`\u2014that process coverage data and generate reports. There are several ways to find and/or install these tools, but note that the coverage mapping data generated by the Rust compiler requires LLVM version 12 or higher, and processing the *raw* data may require exactly the LLVM version used by the compiler. (`llvm-cov --version` typically shows the tool's LLVM version number, and `rustc --verbose --version` shows the version of LLVM used by the Rust compiler.)\n@@ -181,11 +194,10 @@ A typical use case for coverage analysis is test coverage. Rust's source-based c\n \n The following example (using the [`json5format`] crate, for demonstration purposes) show how to generate and analyze coverage results for all tests in a crate.\n \n-Since `cargo test` both builds and runs the tests, we set both the additional `RUSTFLAGS`, to add the `-C instrument-coverage` flag, and `LLVM_PROFILE_FILE`, to set a custom filename for the raw profiling data generated during the test runs. Since there may be more than one test binary, apply `%m` in the filename pattern. This generates unique names for each test binary. (Otherwise, each executed test binary would overwrite the coverage results from the previous binary.)\n+Since `cargo test` both builds and runs the tests, we set the additional `RUSTFLAGS`, to add the `-C instrument-coverage` flag.\n \n ```shell\n $ RUSTFLAGS=\"-C instrument-coverage\" \\\n-    LLVM_PROFILE_FILE=\"json5format-%m.profraw\" \\\n     cargo test --tests\n ```\n \n@@ -210,7 +222,7 @@ test result: ok. 31 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n You should have one or more `.profraw` files now, one for each test binary. Run the `profdata` tool to merge them:\n \n ```shell\n-$ llvm-profdata merge -sparse json5format-*.profraw -o json5format.profdata\n+$ llvm-profdata merge -sparse default_*.profraw -o json5format.profdata\n ```\n \n Then run the `cov` tool, with the `profdata` file and all test binaries:\n@@ -230,6 +242,8 @@ $ llvm-cov show \\\n     --Xdemangler=rustfilt | less -R\n ```\n \n+> **Note**: If overriding the default `profraw` file name via the `LLVM_PROFILE_FILE` environment variable, it's highly recommended to use the `%m` and `%p` special pattern strings to generate unique file names in the case of more than a single test binary being executed.\n+\n > **Note**: The command line option `--ignore-filename-regex=/.cargo/registry`, which excludes the sources for dependencies from the coverage results.\\_\n \n ### Tips for listing the binaries automatically\n@@ -271,9 +285,8 @@ To include doc tests in the coverage results, drop the `--tests` flag, and apply\n ```bash\n $ RUSTFLAGS=\"-C instrument-coverage\" \\\n   RUSTDOCFLAGS=\"-C instrument-coverage -Z unstable-options --persist-doctests target/debug/doctestbins\" \\\n-  LLVM_PROFILE_FILE=\"json5format-%m.profraw\" \\\n     cargo test\n-$ llvm-profdata merge -sparse json5format-*.profraw -o json5format.profdata\n+$ llvm-profdata merge -sparse default_*.profraw -o json5format.profdata\n ```\n \n The `-Z unstable-options --persist-doctests` flag is required, to save the test binaries\n@@ -302,8 +315,7 @@ $ llvm-cov report \\\n > version without doc tests, include:\n \n -   The `cargo test ... --no-run` command is updated with the same environment variables\n-    and flags used to _build_ the tests, _including_ the doc tests. (`LLVM_PROFILE_FILE`\n-    is only used when _running_ the tests.)\n+    and flags used to _build_ the tests, _including_ the doc tests.\n -   The file glob pattern `target/debug/doctestbins/*/rust_out` adds the `rust_out`\n     binaries generated for doc tests (note, however, that some `rust_out` files may not\n     be executable binaries)."}, {"sha": "da14cd026780a0dba968ddb1205e52140d4c130a", "filename": "src/test/assembly/aarch64-pointer-auth.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Faarch64-pointer-auth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Faarch64-pointer-auth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Faarch64-pointer-auth.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,6 +1,5 @@\n // Test that PAC instructions are emitted when branch-protection is specified.\n \n-// min-llvm-version: 10.0.1\n // assembly-output: emit-asm\n // compile-flags: --target aarch64-unknown-linux-gnu\n // compile-flags: -Z branch-protection=pac-ret,leaf"}, {"sha": "ffdc8f2e351dd0b1ab5256080e7dea03f3b83bcd", "filename": "src/test/assembly/asm/avr-modifiers.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fasm%2Favr-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fasm%2Favr-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Favr-modifiers.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,3 @@\n-// min-llvm-version: 13.0\n // assembly-output: emit-asm\n // compile-flags: --target avr-unknown-gnu-atmega328\n // needs-llvm-components: avr"}, {"sha": "58bf1ad9e35eb1429e43c0f2308e91689610e269", "filename": "src/test/assembly/asm/avr-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fasm%2Favr-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fasm%2Favr-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Favr-types.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,3 @@\n-// min-llvm-version: 13.0\n // assembly-output: emit-asm\n // compile-flags: --target avr-unknown-gnu-atmega328\n // needs-llvm-components: avr"}, {"sha": "f894644cc20ee50cab09aff52b2770c9541124ae", "filename": "src/test/assembly/asm/bpf-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fasm%2Fbpf-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fasm%2Fbpf-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fbpf-types.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,3 @@\n-// min-llvm-version: 13.0\n // assembly-output: emit-asm\n // compile-flags: --target bpfel-unknown-none -C target_feature=+alu32\n // needs-llvm-components: bpf"}, {"sha": "4fa2e8081f816bbf32fb28a964ee2cb84c0c9219", "filename": "src/test/assembly/asm/msp430-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fasm%2Fmsp430-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fasm%2Fmsp430-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fmsp430-types.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,3 @@\n-// min-llvm-version: 13.0\n // assembly-output: emit-asm\n // compile-flags: --target msp430-none-elf\n // needs-llvm-components: msp430"}, {"sha": "0ca8908497ad7b74f2ae23dab7420aedcbb35c29", "filename": "src/test/assembly/asm/powerpc-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fasm%2Fpowerpc-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fasm%2Fpowerpc-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fpowerpc-types.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,3 @@\n-// min-llvm-version: 12.0.1\n // revisions: powerpc powerpc64\n // assembly-output: emit-asm\n //[powerpc] compile-flags: --target powerpc-unknown-linux-gnu"}, {"sha": "2fb62e93ea36c0909f699aa2be526809afabc334", "filename": "src/test/assembly/stack-protector/stack-protector-target-support.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-target-support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-target-support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-target-support.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -156,7 +156,6 @@\n // [r74] needs-llvm-components: x86\n // [r75] compile-flags:--target x86_64-fortanix-unknown-sgx\n // [r75] needs-llvm-components: x86\n-// [r75] min-llvm-version: 11.0.0\n // [r76] compile-flags:--target x86_64-fuchsia\n // [r76] needs-llvm-components: x86\n // [r77] compile-flags:--target x86_64-linux-android"}, {"sha": "c97933035d101898a690d27ab9c62388d2649422", "filename": "src/test/codegen/asm-may_unwind.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fcodegen%2Fasm-may_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fcodegen%2Fasm-may_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasm-may_unwind.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,3 @@\n-// min-llvm-version: 13.0.0\n // compile-flags: -O\n // only-x86_64\n "}, {"sha": "bd4c63dcff1d726033c7ece216065f7beb583a44", "filename": "src/test/codegen/atomic-operations-llvm-12.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ef9810a3e2a9a16e79176cb0d3466ea82d239942/src%2Ftest%2Fcodegen%2Fatomic-operations-llvm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9810a3e2a9a16e79176cb0d3466ea82d239942/src%2Ftest%2Fcodegen%2Fatomic-operations-llvm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fatomic-operations-llvm-12.rs?ref=ef9810a3e2a9a16e79176cb0d3466ea82d239942", "patch": "@@ -1,84 +0,0 @@\n-// Code generation of atomic operations for LLVM 12\n-// ignore-llvm-version: 13 - 99\n-// compile-flags: -O\n-#![crate_type = \"lib\"]\n-\n-use std::sync::atomic::{AtomicI32, Ordering::*};\n-\n-// CHECK-LABEL: @compare_exchange\n-#[no_mangle]\n-pub fn compare_exchange(a: &AtomicI32) {\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 10 monotonic monotonic\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 11 acquire acquire\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 12 seq_cst seq_cst\n-    let _ = a.compare_exchange(0, 10, Relaxed, Relaxed);\n-    let _ = a.compare_exchange(0, 11, Relaxed, Acquire);\n-    let _ = a.compare_exchange(0, 12, Relaxed, SeqCst);\n-\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 20 release monotonic\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 21 acq_rel acquire\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 22 seq_cst seq_cst\n-    let _ = a.compare_exchange(0, 20, Release, Relaxed);\n-    let _ = a.compare_exchange(0, 21, Release, Acquire);\n-    let _ = a.compare_exchange(0, 22, Release, SeqCst);\n-\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 30 acquire monotonic\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 31 acquire acquire\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 32 seq_cst seq_cst\n-    let _ = a.compare_exchange(0, 30, Acquire, Relaxed);\n-    let _ = a.compare_exchange(0, 31, Acquire, Acquire);\n-    let _ = a.compare_exchange(0, 32, Acquire, SeqCst);\n-\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 40 acq_rel monotonic\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 41 acq_rel acquire\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 42 seq_cst seq_cst\n-    let _ = a.compare_exchange(0, 40, AcqRel, Relaxed);\n-    let _ = a.compare_exchange(0, 41, AcqRel, Acquire);\n-    let _ = a.compare_exchange(0, 42, AcqRel, SeqCst);\n-\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 50 seq_cst monotonic\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 51 seq_cst acquire\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 52 seq_cst seq_cst\n-    let _ = a.compare_exchange(0, 50, SeqCst, Relaxed);\n-    let _ = a.compare_exchange(0, 51, SeqCst, Acquire);\n-    let _ = a.compare_exchange(0, 52, SeqCst, SeqCst);\n-}\n-\n-// CHECK-LABEL: @compare_exchange_weak\n-#[no_mangle]\n-pub fn compare_exchange_weak(w: &AtomicI32) {\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 10 monotonic monotonic\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 11 acquire acquire\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 12 seq_cst seq_cst\n-    let _ = w.compare_exchange_weak(1, 10, Relaxed, Relaxed);\n-    let _ = w.compare_exchange_weak(1, 11, Relaxed, Acquire);\n-    let _ = w.compare_exchange_weak(1, 12, Relaxed, SeqCst);\n-\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 20 release monotonic\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 21 acq_rel acquire\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 22 seq_cst seq_cst\n-    let _ = w.compare_exchange_weak(1, 20, Release, Relaxed);\n-    let _ = w.compare_exchange_weak(1, 21, Release, Acquire);\n-    let _ = w.compare_exchange_weak(1, 22, Release, SeqCst);\n-\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 30 acquire monotonic\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 31 acquire acquire\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 32 seq_cst seq_cst\n-    let _ = w.compare_exchange_weak(1, 30, Acquire, Relaxed);\n-    let _ = w.compare_exchange_weak(1, 31, Acquire, Acquire);\n-    let _ = w.compare_exchange_weak(1, 32, Acquire, SeqCst);\n-\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 40 acq_rel monotonic\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 41 acq_rel acquire\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 42 seq_cst seq_cst\n-    let _ = w.compare_exchange_weak(1, 40, AcqRel, Relaxed);\n-    let _ = w.compare_exchange_weak(1, 41, AcqRel, Acquire);\n-    let _ = w.compare_exchange_weak(1, 42, AcqRel, SeqCst);\n-\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 50 seq_cst monotonic\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 51 seq_cst acquire\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 52 seq_cst seq_cst\n-    let _ = w.compare_exchange_weak(1, 50, SeqCst, Relaxed);\n-    let _ = w.compare_exchange_weak(1, 51, SeqCst, Acquire);\n-    let _ = w.compare_exchange_weak(1, 52, SeqCst, SeqCst);\n-}"}, {"sha": "d2bc618dfc528f35318a093ee892b6e421c2b26c", "filename": "src/test/codegen/atomic-operations.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fcodegen%2Fatomic-operations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fcodegen%2Fatomic-operations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fatomic-operations.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,5 +1,4 @@\n // Code generation of atomic operations.\n-// min-llvm-version: 13.0\n // compile-flags: -O\n #![crate_type = \"lib\"]\n "}, {"sha": "994c71b261982e599b51721d8134f04aea4878dc", "filename": "src/test/codegen/branch-protection.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fcodegen%2Fbranch-protection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fcodegen%2Fbranch-protection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fbranch-protection.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,7 +1,6 @@\n // Test that the correct module flags are emitted with different branch protection flags.\n \n // revisions: BTI PACRET LEAF BKEY NONE\n-// min-llvm-version: 12.0.0\n // needs-llvm-components: aarch64\n // [BTI] compile-flags: -Z branch-protection=bti\n // [PACRET] compile-flags: -Z branch-protection=pac-ret"}, {"sha": "78f8875a2d90c5bb11aab95226772d7fb0465943", "filename": "src/test/codegen/instrument-coverage.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fcodegen%2Finstrument-coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fcodegen%2Finstrument-coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Finstrument-coverage.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -0,0 +1,17 @@\n+// Test that `-Cinstrument-coverage` creates expected __llvm_profile_filename symbol in LLVM IR.\n+\n+// needs-profiler-support\n+// compile-flags: -Cinstrument-coverage\n+\n+// CHECK: @__llvm_profile_filename = {{.*}}\"default_%m_%p.profraw\\00\"{{.*}}\n+\n+#![crate_type=\"lib\"]\n+\n+#[inline(never)]\n+fn some_function() {\n+\n+}\n+\n+pub fn some_other_function() {\n+    some_function();\n+}"}, {"sha": "8e8fe5c964d3c9b15f8895b7ed5c5d13636e6ad1", "filename": "src/test/codegen/merge-functions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fcodegen%2Fmerge-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fcodegen%2Fmerge-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmerge-functions.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,3 +1,4 @@\n+// min-llvm-version: 14.0\n // revisions: O Os\n //[Os] compile-flags: -Copt-level=s\n //[O] compile-flags: -O"}, {"sha": "ad8f9398e7f3c06237103c385fef64ca7c34e39b", "filename": "src/test/mir-opt/asm_unwind_panic_abort.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fmir-opt%2Fasm_unwind_panic_abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fmir-opt%2Fasm_unwind_panic_abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fasm_unwind_panic_abort.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,7 +1,6 @@\n //! Tests that unwinding from an asm block is caught and forced to abort\n //! when `-C panic=abort`.\n \n-// min-llvm-version: 13.0.0\n // only-x86_64\n // compile-flags: -C panic=abort\n // no-prefer-dynamic"}, {"sha": "bae3ab74af676db8da8f3786edeff26580e41a3a", "filename": "src/test/ui/array-slice-vec/suggest-array-length.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Farray-slice-vec%2Fsuggest-array-length.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Farray-slice-vec%2Fsuggest-array-length.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsuggest-array-length.fixed?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+#![allow(unused_variables, dead_code, non_upper_case_globals)]\n+\n+fn main() {\n+    const Foo: [i32; 3] = [1, 2, 3];\n+    //~^ ERROR in expressions, `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR using `_` for array lengths is unstable\n+    let foo: [i32; 3] = [1, 2, 3];\n+    //~^ ERROR in expressions, `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR using `_` for array lengths is unstable\n+    let bar: [i32; 3] = [0; 3];\n+    //~^ ERROR in expressions, `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR using `_` for array lengths is unstable\n+}"}, {"sha": "b0867f4e39676f033b83cf0f984629c5fe3ea72b", "filename": "src/test/ui/array-slice-vec/suggest-array-length.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Farray-slice-vec%2Fsuggest-array-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Farray-slice-vec%2Fsuggest-array-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsuggest-array-length.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+#![allow(unused_variables, dead_code, non_upper_case_globals)]\n+\n+fn main() {\n+    const Foo: [i32; _] = [1, 2, 3];\n+    //~^ ERROR in expressions, `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR using `_` for array lengths is unstable\n+    let foo: [i32; _] = [1, 2, 3];\n+    //~^ ERROR in expressions, `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR using `_` for array lengths is unstable\n+    let bar: [i32; _] = [0; 3];\n+    //~^ ERROR in expressions, `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR using `_` for array lengths is unstable\n+}"}, {"sha": "9000f71602850453b4c8c2c50a0b019ac990092c", "filename": "src/test/ui/array-slice-vec/suggest-array-length.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Farray-slice-vec%2Fsuggest-array-length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Farray-slice-vec%2Fsuggest-array-length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsuggest-array-length.stderr?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -0,0 +1,48 @@\n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n+  --> $DIR/suggest-array-length.rs:8:20\n+   |\n+LL |     let foo: [i32; _] = [1, 2, 3];\n+   |                    ^ `_` not allowed here\n+\n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n+  --> $DIR/suggest-array-length.rs:11:20\n+   |\n+LL |     let bar: [i32; _] = [0; 3];\n+   |                    ^ `_` not allowed here\n+\n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n+  --> $DIR/suggest-array-length.rs:5:22\n+   |\n+LL |     const Foo: [i32; _] = [1, 2, 3];\n+   |                      ^ `_` not allowed here\n+\n+error[E0658]: using `_` for array lengths is unstable\n+  --> $DIR/suggest-array-length.rs:5:22\n+   |\n+LL |     const Foo: [i32; _] = [1, 2, 3];\n+   |                      ^ help: consider specifying the array length: `3`\n+   |\n+   = note: see issue #85077 <https://github.com/rust-lang/rust/issues/85077> for more information\n+   = help: add `#![feature(generic_arg_infer)]` to the crate attributes to enable\n+\n+error[E0658]: using `_` for array lengths is unstable\n+  --> $DIR/suggest-array-length.rs:8:20\n+   |\n+LL |     let foo: [i32; _] = [1, 2, 3];\n+   |                    ^ help: consider specifying the array length: `3`\n+   |\n+   = note: see issue #85077 <https://github.com/rust-lang/rust/issues/85077> for more information\n+   = help: add `#![feature(generic_arg_infer)]` to the crate attributes to enable\n+\n+error[E0658]: using `_` for array lengths is unstable\n+  --> $DIR/suggest-array-length.rs:11:20\n+   |\n+LL |     let bar: [i32; _] = [0; 3];\n+   |                    ^ help: consider specifying the array length: `3`\n+   |\n+   = note: see issue #85077 <https://github.com/rust-lang/rust/issues/85077> for more information\n+   = help: add `#![feature(generic_arg_infer)]` to the crate attributes to enable\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "dfd891b4212d53eb2fdfc527d44541d2cf4d4486", "filename": "src/test/ui/asm/aarch64/may_unwind.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fmay_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fmay_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fmay_unwind.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,3 @@\n-// min-llvm-version: 13.0.0\n // only-aarch64\n // run-pass\n // needs-asm-support"}, {"sha": "b9479c44bf11d7ab4a93d2b95364c053938cc097", "filename": "src/test/ui/asm/may_unwind.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fasm%2Fmay_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fasm%2Fmay_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fmay_unwind.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,3 @@\n-// min-llvm-version: 13.0.0\n // run-pass\n // needs-asm-support\n "}, {"sha": "badc4fec82248cc09dfb0983a13485799163b467", "filename": "src/test/ui/asm/x86_64/may_unwind.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fmay_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fmay_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fmay_unwind.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,3 @@\n-// min-llvm-version: 13.0.0\n // only-x86_64\n // run-pass\n // needs-asm-support"}, {"sha": "447e11e6eabcae9abc64b54db92371ce4dfe7886", "filename": "src/test/ui/asm/x86_64/sym.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fsym.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,4 +1,3 @@\n-// min-llvm-version: 12.0.1\n // only-x86_64\n // only-linux\n // needs-asm-support"}, {"sha": "29aebb719d66f506e61e68bb13c871be8456263e", "filename": "src/test/ui/async-await/issues/issue-95307.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-95307.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-95307.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-95307.stderr?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -9,6 +9,12 @@ LL |     async fn new() -> [u8; _];\n    = note: `async` trait functions are not currently supported\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n+  --> $DIR/issue-95307.rs:7:28\n+   |\n+LL |     async fn new() -> [u8; _];\n+   |                            ^ `_` not allowed here\n+\n error[E0658]: using `_` for array lengths is unstable\n   --> $DIR/issue-95307.rs:7:28\n    |\n@@ -18,12 +24,6 @@ LL |     async fn new() -> [u8; _];\n    = note: see issue #85077 <https://github.com/rust-lang/rust/issues/85077> for more information\n    = help: add `#![feature(generic_arg_infer)]` to the crate attributes to enable\n \n-error: in expressions, `_` can only be used on the left-hand side of an assignment\n-  --> $DIR/issue-95307.rs:7:28\n-   |\n-LL |     async fn new() -> [u8; _];\n-   |                            ^ `_` not allowed here\n-\n error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0658, E0706."}, {"sha": "56123a983b34f8c02f7432ff8e6579db60e4e75a", "filename": "src/test/ui/feature-gates/feature-gate-generic_arg_infer.normal.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_arg_infer.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_arg_infer.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_arg_infer.normal.stderr?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,33 +1,24 @@\n-error[E0658]: using `_` for array lengths is unstable\n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n   --> $DIR/feature-gate-generic_arg_infer.rs:11:27\n    |\n LL |     let _x: [u8; 3] = [0; _];\n-   |                           ^\n-   |\n-   = note: see issue #85077 <https://github.com/rust-lang/rust/issues/85077> for more information\n-   = help: add `#![feature(generic_arg_infer)]` to the crate attributes to enable\n+   |                           ^ `_` not allowed here\n \n error: in expressions, `_` can only be used on the left-hand side of an assignment\n-  --> $DIR/feature-gate-generic_arg_infer.rs:11:27\n+  --> $DIR/feature-gate-generic_arg_infer.rs:14:18\n    |\n-LL |     let _x: [u8; 3] = [0; _];\n-   |                           ^ `_` not allowed here\n+LL |     let _y: [u8; _] = [0; 3];\n+   |                  ^ `_` not allowed here\n \n error[E0658]: using `_` for array lengths is unstable\n   --> $DIR/feature-gate-generic_arg_infer.rs:14:18\n    |\n LL |     let _y: [u8; _] = [0; 3];\n-   |                  ^\n+   |                  ^ help: consider specifying the array length: `3`\n    |\n    = note: see issue #85077 <https://github.com/rust-lang/rust/issues/85077> for more information\n    = help: add `#![feature(generic_arg_infer)]` to the crate attributes to enable\n \n-error: in expressions, `_` can only be used on the left-hand side of an assignment\n-  --> $DIR/feature-gate-generic_arg_infer.rs:14:18\n-   |\n-LL |     let _y: [u8; _] = [0; 3];\n-   |                  ^ `_` not allowed here\n-\n error[E0747]: type provided when a constant was expected\n   --> $DIR/feature-gate-generic_arg_infer.rs:20:20\n    |\n@@ -37,6 +28,15 @@ LL |     let _x = foo::<_>([1,2]);\n    = help: const arguments cannot yet be inferred with `_`\n    = help: add `#![feature(generic_arg_infer)]` to the crate attributes to enable\n \n+error[E0658]: using `_` for array lengths is unstable\n+  --> $DIR/feature-gate-generic_arg_infer.rs:11:27\n+   |\n+LL |     let _x: [u8; 3] = [0; _];\n+   |                           ^\n+   |\n+   = note: see issue #85077 <https://github.com/rust-lang/rust/issues/85077> for more information\n+   = help: add `#![feature(generic_arg_infer)]` to the crate attributes to enable\n+\n error: aborting due to 5 previous errors\n \n Some errors have detailed explanations: E0658, E0747."}, {"sha": "8a4ff16694bdb0c787c4f389bc356b4d9d9eb852", "filename": "src/test/ui/ptr_ops/issue-80309-safe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fptr_ops%2Fissue-80309-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fptr_ops%2Fissue-80309-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fptr_ops%2Fissue-80309-safe.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-// min-llvm-version: 13.0\n // compile-flags: -O\n \n // Regression test for issue #80309"}, {"sha": "c13ce3c9cd2c1d2f21e677cbf412efd03e246ccf", "filename": "src/test/ui/ptr_ops/issue-80309.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fptr_ops%2Fissue-80309.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Fptr_ops%2Fissue-80309.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fptr_ops%2Fissue-80309.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-// min-llvm-version: 13.0\n // compile-flags: -O\n \n // Regression test for issue #80309"}, {"sha": "e206469b85f55d54867b43424b70997e3db278d2", "filename": "src/test/ui/typeck/issue-100285.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Ftypeck%2Fissue-100285.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Ftypeck%2Fissue-100285.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-100285.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -0,0 +1,22 @@\n+fn foo(n: i32) -> i32 {\n+    for i in 0..0 {\n+    //~^ ERROR: mismatched types [E0308]\n+       if n < 0 {\n+        return i;\n+        } else if n < 10 {\n+          return 1;\n+        } else if n < 20 {\n+          return 2;\n+        } else if n < 30 {\n+          return 3;\n+        } else if n < 40 {\n+          return 4;\n+        } else {\n+          return 5;\n+        }\n+\n+    }\n+    //~| help: return a value for the case when the loop has zero elements to iterate on, or consider changing the return type to account for that possibility\n+}\n+\n+fn main() {}"}, {"sha": "42c64b03918c503fe5cfa8952b00405c7e1b615b", "filename": "src/test/ui/typeck/issue-100285.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Ftypeck%2Fissue-100285.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftest%2Fui%2Ftypeck%2Fissue-100285.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-100285.stderr?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -0,0 +1,34 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-100285.rs:2:5\n+   |\n+LL |   fn foo(n: i32) -> i32 {\n+   |                     --- expected `i32` because of return type\n+LL | /     for i in 0..0 {\n+LL | |\n+LL | |        if n < 0 {\n+LL | |         return i;\n+...  |\n+LL | |\n+LL | |     }\n+   | |_____^ expected `i32`, found `()`\n+   |\n+note: the function expects a value to always be returned, but loops might run zero times\n+  --> $DIR/issue-100285.rs:2:5\n+   |\n+LL |     for i in 0..0 {\n+   |     ^^^^^^^^^^^^^ this might have zero elements to iterate on\n+...\n+LL |         return i;\n+   |         -------- if the loop doesn't execute, this value would never get returned\n+LL |         } else if n < 10 {\n+LL |           return 1;\n+   |           -------- if the loop doesn't execute, this value would never get returned\n+LL |         } else if n < 20 {\n+LL |           return 2;\n+   |           -------- if the loop doesn't execute, this value would never get returned\n+   = note: if the loop doesn't execute, 3 other values would never get returned\n+   = help: return a value for the case when the loop has zero elements to iterate on, or consider changing the return type to account for that possibility\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}