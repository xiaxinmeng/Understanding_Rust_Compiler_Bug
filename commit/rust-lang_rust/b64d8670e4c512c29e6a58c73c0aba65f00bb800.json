{"sha": "b64d8670e4c512c29e6a58c73c0aba65f00bb800", "node_id": "C_kwDOAAsO6NoAKGI2NGQ4NjcwZTRjNTEyYzI5ZTZhNThjNzNjMGFiYTY1ZjAwYmI4MDA", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-02T17:16:08Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-02T17:16:08Z"}, "message": "Merge from rustc", "tree": {"sha": "8ab5152a8172f85f987a6e84fa1e088e7d67339a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ab5152a8172f85f987a6e84fa1e088e7d67339a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b64d8670e4c512c29e6a58c73c0aba65f00bb800", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b64d8670e4c512c29e6a58c73c0aba65f00bb800", "html_url": "https://github.com/rust-lang/rust/commit/b64d8670e4c512c29e6a58c73c0aba65f00bb800", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b64d8670e4c512c29e6a58c73c0aba65f00bb800/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80ab672b8611d34bf811d4498b9b9d116a085e7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/80ab672b8611d34bf811d4498b9b9d116a085e7c", "html_url": "https://github.com/rust-lang/rust/commit/80ab672b8611d34bf811d4498b9b9d116a085e7c"}, {"sha": "cef44f53034eac46be3a0e3eec7b2b3d4ef5140b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cef44f53034eac46be3a0e3eec7b2b3d4ef5140b", "html_url": "https://github.com/rust-lang/rust/commit/cef44f53034eac46be3a0e3eec7b2b3d4ef5140b"}], "stats": {"total": 17565, "additions": 10491, "deletions": 7074}, "files": [{"sha": "022cdd0fd50c161b9c3f0c2756fa5a9cd608818f", "filename": ".mailmap", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -73,6 +73,8 @@ Bj\u00f6rn Steinbrink <bsteinbr@gmail.com> <B.Steinbrink@gmx.de>\n blake2-ppc <ulrik.sverdrup@gmail.com> <blake2-ppc>\n boolean_coercion <booleancoercion@gmail.com>\n Boris Egorov <jightuse@gmail.com> <egorov@linux.com>\n+bors <bors@rust-lang.org> bors[bot] <26634292+bors[bot]@users.noreply.github.com>\n+bors <bors@rust-lang.org> bors[bot] <bors[bot]@users.noreply.github.com>\n Braden Nelson <moonheart08@users.noreply.github.com>\n Brandon Sanderson <singingboyo@gmail.com> Brandon Sanderson <singingboyo@hotmail.com>\n Brett Cannon <brett@python.org> Brett Cannon <brettcannon@users.noreply.github.com>\n@@ -139,6 +141,10 @@ David Ross <daboross@daboross.net>\n David Wood <david@davidtw.co> <david.wood@huawei.com>\n Deadbeef <ent3rm4n@gmail.com>\n Deadbeef <ent3rm4n@gmail.com> <fee1-dead-beef@protonmail.com>\n+dependabot[bot] <dependabot[bot]@users.noreply.github.com> <27856297+dependabot-preview[bot]@users.noreply.github.com>\n+dependabot[bot] <dependabot[bot]@users.noreply.github.com> <49699333+dependabot[bot]@users.noreply.github.com>\n+dependabot[bot] <dependabot[bot]@users.noreply.github.com> <dependabot-preview[bot]@users.noreply.github.com>\n+dependabot[bot] <dependabot[bot]@users.noreply.github.com> <support@dependabot.com>\n Derek Chiang <derekchiang93@gmail.com> Derek Chiang (Enchi Jiang) <derekchiang93@gmail.com>\n DeveloperC <DeveloperC@protonmail.com>\n Devin Ragotzy <devin.ragotzy@gmail.com>\n@@ -229,7 +235,7 @@ Jacob <jacob.macritchie@gmail.com>\n Jacob Greenfield <xales@naveria.com>\n Jacob Pratt <jacob@jhpratt.dev> <the.z.cuber@gmail.com>\n Jake Vossen <jake@vossen.dev>\n-Jakob Degen <jakob@degen.com>\n+Jakob Degen <jakob.e.degen@gmail.com> <jakob@degen.com>\n Jakob Lautrup Nysom <jako3047@gmail.com>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub.bukaj@yahoo.com>\n@@ -396,6 +402,10 @@ Nathaniel Herman <nherman@post.harvard.edu> Nathaniel Herman <nherman@college.ha\n Neil Pankey <npankey@gmail.com> <neil@wire.im>\n Ngo Iok Ui (Wu Yu Wei) <wusyong9104@gmail.com>\n Nicholas Baron <nicholas.baron.ten@gmail.com>\n+Nicholas Bishop <nbishop@nbishop.net> <nicholasbishop@gmail.com>\n+Nicholas Bishop <nbishop@nbishop.net> <nicholasbishop@google.com>\n+Nicholas Nethercote <n.nethercote@gmail.com> <nnethercote@apple.com>\n+Nicholas Nethercote <n.nethercote@gmail.com> <nnethercote@mozilla.com>\n Nick Platt <platt.nicholas@gmail.com>\n Niclas Schwarzlose <15schnic@gmail.com>\n Nicolas Abram <abramlujan@gmail.com>\n@@ -522,6 +532,7 @@ Tomas Koutsky <tomas@stepnivlk.net>\n Torsten Weber <TorstenWeber12@gmail.com>\n Torsten Weber <TorstenWeber12@gmail.com> <torstenweber12@gmail.com>\n Trevor Spiteri <tspiteri@ieee.org> <trevor.spiteri@um.edu.mt>\n+Tshepang Mbambo <tshepang@gmail.com>\n Ty Overby <ty@pre-alpha.com>\n Tyler Mandry <tmandry@gmail.com> <tmandry@google.com>\n Tyler Ruckinger <t.ruckinger@gmail.com>"}, {"sha": "7d43dbc9e0640e35e88a129d78b2b46450ea3ffa", "filename": "Cargo.lock", "status": "modified", "additions": 99, "deletions": 2, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -288,7 +288,6 @@ name = \"cargo\"\n version = \"0.68.0\"\n dependencies = [\n  \"anyhow\",\n- \"atty\",\n  \"bytesize\",\n  \"cargo-platform 0.1.2\",\n  \"cargo-test-macro\",\n@@ -298,7 +297,7 @@ dependencies = [\n  \"crates-io\",\n  \"curl\",\n  \"curl-sys\",\n- \"env_logger 0.9.0\",\n+ \"env_logger 0.10.0\",\n  \"filetime\",\n  \"flate2\",\n  \"fwdansi\",\n@@ -312,6 +311,7 @@ dependencies = [\n  \"ignore\",\n  \"im-rc\",\n  \"indexmap\",\n+ \"is-terminal\",\n  \"itertools\",\n  \"jobserver\",\n  \"lazy_static\",\n@@ -870,6 +870,12 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"convert_case\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6245d59a3e82a7fc217c5828a6692dbc6dfb63a0c8c90495621f7b9d79704a0e\"\n+\n [[package]]\n name = \"core\"\n version = \"0.0.0\"\n@@ -1060,6 +1066,19 @@ dependencies = [\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"derive_more\"\n+version = \"0.99.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4fb810d30a7c1953f91334de7244731fc3f3c10d7fe163338a35b9f640960321\"\n+dependencies = [\n+ \"convert_case\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"rustc_version\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"diff\"\n version = \"0.1.13\"\n@@ -1213,6 +1232,40 @@ dependencies = [\n  \"termcolor\",\n ]\n \n+[[package]]\n+name = \"env_logger\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"85cdab6a89accf66733ad5a1693a4dcced6aeff64602b634530dd73c1f3ee9f0\"\n+dependencies = [\n+ \"humantime 2.0.1\",\n+ \"is-terminal\",\n+ \"log\",\n+ \"regex\",\n+ \"termcolor\",\n+]\n+\n+[[package]]\n+name = \"errno\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f639046355ee4f37944e44f60642c6f3a7efa3cf6b78c78a0d989a8ce6c396a1\"\n+dependencies = [\n+ \"errno-dragonfly\",\n+ \"libc\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"errno-dragonfly\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aa68f1b12764fab894d2755d2518754e71b4fd80ecfb822714a1206c2aab39bf\"\n+dependencies = [\n+ \"cc\",\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"error_index_generator\"\n version = \"0.0.0\"\n@@ -1907,6 +1960,28 @@ dependencies = [\n  \"unic-langid\",\n ]\n \n+[[package]]\n+name = \"io-lifetimes\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e394faa0efb47f9f227f1cd89978f854542b318a6f64fa695489c9c993056656\"\n+dependencies = [\n+ \"libc\",\n+ \"windows-sys\",\n+]\n+\n+[[package]]\n+name = \"is-terminal\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aae5bc6e2eb41c9def29a3e0f1306382807764b9b53112030eff57435667352d\"\n+dependencies = [\n+ \"hermit-abi 0.2.6\",\n+ \"io-lifetimes\",\n+ \"rustix\",\n+ \"windows-sys\",\n+]\n+\n [[package]]\n name = \"itertools\"\n version = \"0.10.5\"\n@@ -2116,6 +2191,12 @@ dependencies = [\n  \"walkdir\",\n ]\n \n+[[package]]\n+name = \"linux-raw-sys\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8f9f08d8963a6c613f4b1a78f4f4a4dbfadf8e6545b2d72861731e4858b8b47f\"\n+\n [[package]]\n name = \"litemap\"\n version = \"0.6.0\"\n@@ -3193,6 +3274,7 @@ version = \"1.0.0\"\n dependencies = [\n  \"bstr 0.2.17\",\n  \"clap 3.2.20\",\n+ \"libc\",\n  \"libz-sys\",\n  \"rand 0.8.5\",\n  \"regex\",\n@@ -3916,6 +3998,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-ir\",\n+ \"derive_more\",\n  \"either\",\n  \"gsgdt\",\n  \"polonius-engine\",\n@@ -4508,6 +4591,20 @@ dependencies = [\n  \"unicode_categories\",\n ]\n \n+[[package]]\n+name = \"rustix\"\n+version = \"0.36.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0b1fbb4dfc4eb1d390c02df47760bb19a84bb80b301ecc947ab5406394d8223e\"\n+dependencies = [\n+ \"bitflags\",\n+ \"errno\",\n+ \"io-lifetimes\",\n+ \"libc\",\n+ \"linux-raw-sys\",\n+ \"windows-sys\",\n+]\n+\n [[package]]\n name = \"rustversion\"\n version = \"1.0.5\""}, {"sha": "85693259cd0153eb02fbb6b0b8424a9fe69a7124", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -211,6 +211,102 @@ pub enum TargetDataLayoutErrors<'a> {\n }\n \n impl TargetDataLayout {\n+    /// Parse data layout from an [llvm data layout string](https://llvm.org/docs/LangRef.html#data-layout)\n+    ///\n+    /// This function doesn't fill `c_enum_min_size` and it will always be `I32` since it can not be\n+    /// determined from llvm string.\n+    pub fn parse_from_llvm_datalayout_string<'a>(\n+        input: &'a str,\n+    ) -> Result<TargetDataLayout, TargetDataLayoutErrors<'a>> {\n+        // Parse an address space index from a string.\n+        let parse_address_space = |s: &'a str, cause: &'a str| {\n+            s.parse::<u32>().map(AddressSpace).map_err(|err| {\n+                TargetDataLayoutErrors::InvalidAddressSpace { addr_space: s, cause, err }\n+            })\n+        };\n+\n+        // Parse a bit count from a string.\n+        let parse_bits = |s: &'a str, kind: &'a str, cause: &'a str| {\n+            s.parse::<u64>().map_err(|err| TargetDataLayoutErrors::InvalidBits {\n+                kind,\n+                bit: s,\n+                cause,\n+                err,\n+            })\n+        };\n+\n+        // Parse a size string.\n+        let size = |s: &'a str, cause: &'a str| parse_bits(s, \"size\", cause).map(Size::from_bits);\n+\n+        // Parse an alignment string.\n+        let align = |s: &[&'a str], cause: &'a str| {\n+            if s.is_empty() {\n+                return Err(TargetDataLayoutErrors::MissingAlignment { cause });\n+            }\n+            let align_from_bits = |bits| {\n+                Align::from_bits(bits)\n+                    .map_err(|err| TargetDataLayoutErrors::InvalidAlignment { cause, err })\n+            };\n+            let abi = parse_bits(s[0], \"alignment\", cause)?;\n+            let pref = s.get(1).map_or(Ok(abi), |pref| parse_bits(pref, \"alignment\", cause))?;\n+            Ok(AbiAndPrefAlign { abi: align_from_bits(abi)?, pref: align_from_bits(pref)? })\n+        };\n+\n+        let mut dl = TargetDataLayout::default();\n+        let mut i128_align_src = 64;\n+        for spec in input.split('-') {\n+            let spec_parts = spec.split(':').collect::<Vec<_>>();\n+\n+            match &*spec_parts {\n+                [\"e\"] => dl.endian = Endian::Little,\n+                [\"E\"] => dl.endian = Endian::Big,\n+                [p] if p.starts_with('P') => {\n+                    dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n+                }\n+                [\"a\", ref a @ ..] => dl.aggregate_align = align(a, \"a\")?,\n+                [\"f32\", ref a @ ..] => dl.f32_align = align(a, \"f32\")?,\n+                [\"f64\", ref a @ ..] => dl.f64_align = align(a, \"f64\")?,\n+                [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n+                    dl.pointer_size = size(s, p)?;\n+                    dl.pointer_align = align(a, p)?;\n+                }\n+                [s, ref a @ ..] if s.starts_with('i') => {\n+                    let Ok(bits) = s[1..].parse::<u64>() else {\n+                        size(&s[1..], \"i\")?; // For the user error.\n+                        continue;\n+                    };\n+                    let a = align(a, s)?;\n+                    match bits {\n+                        1 => dl.i1_align = a,\n+                        8 => dl.i8_align = a,\n+                        16 => dl.i16_align = a,\n+                        32 => dl.i32_align = a,\n+                        64 => dl.i64_align = a,\n+                        _ => {}\n+                    }\n+                    if bits >= i128_align_src && bits <= 128 {\n+                        // Default alignment for i128 is decided by taking the alignment of\n+                        // largest-sized i{64..=128}.\n+                        i128_align_src = bits;\n+                        dl.i128_align = a;\n+                    }\n+                }\n+                [s, ref a @ ..] if s.starts_with('v') => {\n+                    let v_size = size(&s[1..], \"v\")?;\n+                    let a = align(a, s)?;\n+                    if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {\n+                        v.1 = a;\n+                        continue;\n+                    }\n+                    // No existing entry, add a new one.\n+                    dl.vector_align.push((v_size, a));\n+                }\n+                _ => {} // Ignore everything else.\n+            }\n+        }\n+        Ok(dl)\n+    }\n+\n     /// Returns exclusive upper bound on object size.\n     ///\n     /// The theoretical maximum object size is defined as the maximum positive `isize` value."}, {"sha": "f2f8e1386a5c7dcae63a8111a4663eaaca2fd349", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -13,7 +13,7 @@\n //! - [`FnDecl`], [`FnHeader`] and [`Param`]: Metadata associated with a function declaration.\n //! - [`Generics`], [`GenericParam`], [`WhereClause`]: Metadata associated with generic parameters.\n //! - [`EnumDef`] and [`Variant`]: Enum declaration.\n-//! - [`Lit`] and [`LitKind`]: Literal expressions.\n+//! - [`MetaItemLit`] and [`LitKind`]: Literal expressions.\n //! - [`MacroDef`], [`MacStmtStyle`], [`MacCall`], [`MacDelimiter`]: Macro definition and invocation.\n //! - [`Attribute`]: Metadata associated with item.\n //! - [`UnOp`], [`BinOp`], and [`BinOpKind`]: Unary and binary operators.\n@@ -111,8 +111,8 @@ impl<CTX: rustc_span::HashStableContext> HashStable<CTX> for Path {\n }\n \n impl Path {\n-    // Convert a span and an identifier to the corresponding\n-    // one-segment path.\n+    /// Convert a span and an identifier to the corresponding\n+    /// one-segment path.\n     pub fn from_ident(ident: Ident) -> Path {\n         Path { segments: thin_vec![PathSegment::from_ident(ident)], span: ident.span, tokens: None }\n     }\n@@ -479,20 +479,10 @@ pub struct Crate {\n     pub is_placeholder: bool,\n }\n \n-/// Possible values inside of compile-time attribute lists.\n-///\n-/// E.g., the '..' in `#[name(..)]`.\n-#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n-pub enum NestedMetaItem {\n-    /// A full MetaItem, for recursive meta items.\n-    MetaItem(MetaItem),\n-    /// A literal.\n-    ///\n-    /// E.g., `\"foo\"`, `64`, `true`.\n-    Literal(Lit),\n-}\n-\n-/// A spanned compile-time attribute item.\n+/// A semantic representation of a meta item. A meta item is a slightly\n+/// restricted form of an attribute -- it can only contain expressions in\n+/// certain leaf positions, rather than arbitrary token streams -- that is used\n+/// for most built-in attributes.\n ///\n /// E.g., `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n@@ -502,23 +492,37 @@ pub struct MetaItem {\n     pub span: Span,\n }\n \n-/// A compile-time attribute item.\n-///\n-/// E.g., `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`.\n+/// The meta item kind, containing the data after the initial path.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n-    /// E.g., `test` as in `#[test]`.\n+    /// E.g., `#[test]`, which lacks any arguments after `test`.\n     Word,\n+\n     /// List meta item.\n     ///\n-    /// E.g., `derive(..)` as in `#[derive(..)]`.\n+    /// E.g., `#[derive(..)]`, where the field represents the `..`.\n     List(Vec<NestedMetaItem>),\n+\n     /// Name value meta item.\n     ///\n-    /// E.g., `feature = \"foo\"` as in `#[feature = \"foo\"]`.\n-    NameValue(Lit),\n+    /// E.g., `#[feature = \"foo\"]`, where the field represents the `\"foo\"`.\n+    NameValue(MetaItemLit),\n+}\n+\n+/// Values inside meta item lists.\n+///\n+/// E.g., each of `Clone`, `Copy` in `#[derive(Clone, Copy)]`.\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n+pub enum NestedMetaItem {\n+    /// A full MetaItem, for recursive meta items.\n+    MetaItem(MetaItem),\n+\n+    /// A literal.\n+    ///\n+    /// E.g., `\"foo\"`, `64`, `true`.\n+    Lit(MetaItemLit),\n }\n \n /// A block (`{ .. }`).\n@@ -1283,7 +1287,7 @@ impl Expr {\n         )\n     }\n \n-    // To a first-order approximation, is this a pattern\n+    /// To a first-order approximation, is this a pattern?\n     pub fn is_approximately_pattern(&self) -> bool {\n         match &self.peel_parens().kind {\n             ExprKind::Box(_)\n@@ -1599,12 +1603,12 @@ pub enum AttrArgs {\n }\n \n // The RHS of an `AttrArgs::Eq` starts out as an expression. Once macro\n-// expansion is completed, all cases end up either as a literal, which is the\n-// form used after lowering to HIR, or as an error.\n+// expansion is completed, all cases end up either as a meta item literal,\n+// which is the form used after lowering to HIR, or as an error.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AttrArgsEq {\n     Ast(P<Expr>),\n-    Hir(Lit),\n+    Hir(MetaItemLit),\n }\n \n impl AttrArgs {\n@@ -1726,19 +1730,18 @@ pub enum StrStyle {\n     Raw(u8),\n }\n \n-/// An AST literal.\n+/// A literal in a meta item.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n-pub struct Lit {\n+pub struct MetaItemLit {\n     /// The original literal token as written in source code.\n     pub token_lit: token::Lit,\n     /// The \"semantic\" representation of the literal lowered from the original tokens.\n     /// Strings are unescaped, hexadecimal forms are eliminated, etc.\n-    /// FIXME: Remove this and only create the semantic representation during lowering to HIR.\n     pub kind: LitKind,\n     pub span: Span,\n }\n \n-/// Same as `Lit`, but restricted to string literals.\n+/// Similar to `MetaItemLit`, but restricted to string literals.\n #[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct StrLit {\n     /// The original literal token as written in source code.\n@@ -1747,7 +1750,6 @@ pub struct StrLit {\n     pub suffix: Option<Symbol>,\n     pub span: Span,\n     /// The unescaped \"semantic\" representation of the literal lowered from the original token.\n-    /// FIXME: Remove this and only create the semantic representation during lowering to HIR.\n     pub symbol_unescaped: Symbol,\n }\n \n@@ -1783,6 +1785,8 @@ pub enum LitFloatType {\n     Unsuffixed,\n }\n \n+/// This type is used within both `ast::MetaItemLit` and `hir::Lit`.\n+///\n /// Note that the entire literal (including the suffix) is considered when\n /// deciding the `LitKind`. This means that float literals like `1f32` are\n /// classified by this type as `Float`. This is different to `token::LitKind`\n@@ -2513,10 +2517,7 @@ pub struct Variant {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum UseTreeKind {\n     /// `use prefix` or `use prefix as rename`\n-    ///\n-    /// The extra `NodeId`s are for HIR lowering, when additional statements are created for each\n-    /// namespace.\n-    Simple(Option<Ident>, NodeId, NodeId),\n+    Simple(Option<Ident>),\n     /// `use prefix::{...}`\n     Nested(Vec<(UseTree, NodeId)>),\n     /// `use prefix::*`\n@@ -2535,8 +2536,8 @@ pub struct UseTree {\n impl UseTree {\n     pub fn ident(&self) -> Ident {\n         match self.kind {\n-            UseTreeKind::Simple(Some(rename), ..) => rename,\n-            UseTreeKind::Simple(None, ..) => {\n+            UseTreeKind::Simple(Some(rename)) => rename,\n+            UseTreeKind::Simple(None) => {\n                 self.prefix.segments.last().expect(\"empty prefix in a simple import\").ident\n             }\n             _ => panic!(\"`UseTree::ident` can only be used on a simple import\"),\n@@ -2570,17 +2571,10 @@ impl<D: Decoder> Decodable<D> for AttrId {\n     }\n }\n \n-#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n-pub struct AttrItem {\n-    pub path: Path,\n-    pub args: AttrArgs,\n-    pub tokens: Option<LazyAttrTokenStream>,\n-}\n-\n /// A list of attributes.\n pub type AttrVec = ThinVec<Attribute>;\n \n-/// Metadata associated with an item.\n+/// A syntax-level representation of an attribute.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Attribute {\n     pub kind: AttrKind,\n@@ -2591,12 +2585,6 @@ pub struct Attribute {\n     pub span: Span,\n }\n \n-#[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct NormalAttr {\n-    pub item: AttrItem,\n-    pub tokens: Option<LazyAttrTokenStream>,\n-}\n-\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AttrKind {\n     /// A normal attribute.\n@@ -2608,6 +2596,19 @@ pub enum AttrKind {\n     DocComment(CommentKind, Symbol),\n }\n \n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct NormalAttr {\n+    pub item: AttrItem,\n+    pub tokens: Option<LazyAttrTokenStream>,\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n+pub struct AttrItem {\n+    pub path: Path,\n+    pub args: AttrArgs,\n+    pub tokens: Option<LazyAttrTokenStream>,\n+}\n+\n /// `TraitRef`s appear in impls.\n ///\n /// Resolution maps each `TraitRef`'s `ref_id` to its defining trait; that's all\n@@ -3096,9 +3097,9 @@ mod size_asserts {\n     static_assert_size!(Impl, 184);\n     static_assert_size!(Item, 184);\n     static_assert_size!(ItemKind, 112);\n-    static_assert_size!(Lit, 48);\n     static_assert_size!(LitKind, 24);\n     static_assert_size!(Local, 72);\n+    static_assert_size!(MetaItemLit, 48);\n     static_assert_size!(Param, 40);\n     static_assert_size!(Pat, 88);\n     static_assert_size!(Path, 24);"}, {"sha": "057cc26b5799e7eff82d0d6b7ad30eade281be53", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 72, "deletions": 133, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,18 +1,17 @@\n //! Functions dealing with attributes and meta items.\n \n use crate::ast;\n-use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n-use crate::ast::{DelimArgs, Lit, LitKind};\n-use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n-use crate::ast::{Path, PathSegment};\n+use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, AttrVec, Attribute};\n+use crate::ast::{DelimArgs, Expr, ExprKind, LitKind, MetaItemLit};\n+use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem, NormalAttr};\n+use crate::ast::{Path, PathSegment, StrStyle, DUMMY_NODE_ID};\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter, Token};\n use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n use crate::tokenstream::{LazyAttrTokenStream, TokenStream};\n use crate::util::comments;\n use rustc_data_structures::sync::WorkerLocal;\n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_span::source_map::BytePos;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n use std::cell::Cell;\n@@ -26,9 +25,9 @@ use thin_vec::thin_vec;\n pub struct MarkedAttrs(GrowableBitSet<AttrId>);\n \n impl MarkedAttrs {\n-    // We have no idea how many attributes there will be, so just\n-    // initiate the vectors with 0 bits. We'll grow them as necessary.\n     pub fn new() -> Self {\n+        // We have no idea how many attributes there will be, so just\n+        // initiate the vectors with 0 bits. We'll grow them as necessary.\n         MarkedAttrs(GrowableBitSet::new_empty())\n     }\n \n@@ -50,10 +49,10 @@ impl NestedMetaItem {\n         }\n     }\n \n-    /// Returns the `Lit` if `self` is a `NestedMetaItem::Literal`s.\n-    pub fn literal(&self) -> Option<&Lit> {\n+    /// Returns the `MetaItemLit` if `self` is a `NestedMetaItem::Literal`s.\n+    pub fn lit(&self) -> Option<&MetaItemLit> {\n         match self {\n-            NestedMetaItem::Literal(lit) => Some(lit),\n+            NestedMetaItem::Lit(lit) => Some(lit),\n             _ => None,\n         }\n     }\n@@ -78,12 +77,12 @@ impl NestedMetaItem {\n     }\n \n     /// Returns a name and single literal value tuple of the `MetaItem`.\n-    pub fn name_value_literal(&self) -> Option<(Symbol, &Lit)> {\n+    pub fn name_value_literal(&self) -> Option<(Symbol, &MetaItemLit)> {\n         self.meta_item().and_then(|meta_item| {\n             meta_item.meta_item_list().and_then(|meta_item_list| {\n                 if meta_item_list.len() == 1\n                     && let Some(ident) = meta_item.ident()\n-                    && let Some(lit) = meta_item_list[0].literal()\n+                    && let Some(lit) = meta_item_list[0].lit()\n                 {\n                     return Some((ident.name, lit));\n                 }\n@@ -174,10 +173,12 @@ impl MetaItem {\n         self.ident().unwrap_or_else(Ident::empty).name\n     }\n \n-    // Example:\n-    //     #[attribute(name = \"value\")]\n-    //                 ^^^^^^^^^^^^^^\n-    pub fn name_value_literal(&self) -> Option<&Lit> {\n+    /// ```text\n+    /// Example:\n+    ///     #[attribute(name = \"value\")]\n+    ///                 ^^^^^^^^^^^^^^\n+    /// ```\n+    pub fn name_value_literal(&self) -> Option<&MetaItemLit> {\n         match &self.kind {\n             MetaItemKind::NameValue(v) => Some(v),\n             _ => None,\n@@ -221,11 +222,7 @@ impl AttrItem {\n     }\n \n     pub fn meta(&self, span: Span) -> Option<MetaItem> {\n-        Some(MetaItem {\n-            path: self.path.clone(),\n-            kind: MetaItemKind::from_attr_args(&self.args)?,\n-            span,\n-        })\n+        Some(MetaItem { path: self.path.clone(), kind: self.meta_kind()?, span })\n     }\n \n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n@@ -327,26 +324,13 @@ impl Attribute {\n /* Constructors */\n \n pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> MetaItem {\n-    let lit_kind = LitKind::Str(str, ast::StrStyle::Cooked);\n-    mk_name_value_item(ident, lit_kind, str_span)\n+    mk_name_value_item(ident, LitKind::Str(str, ast::StrStyle::Cooked), str_span)\n }\n \n-pub fn mk_name_value_item(ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n-    let lit = Lit::from_lit_kind(lit_kind, lit_span);\n+pub fn mk_name_value_item(ident: Ident, kind: LitKind, lit_span: Span) -> MetaItem {\n+    let lit = MetaItemLit { token_lit: kind.to_token_lit(), kind, span: lit_span };\n     let span = ident.span.to(lit_span);\n-    MetaItem { path: Path::from_ident(ident), span, kind: MetaItemKind::NameValue(lit) }\n-}\n-\n-pub fn mk_list_item(ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::List(items) }\n-}\n-\n-pub fn mk_word_item(ident: Ident) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::Word }\n-}\n-\n-pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n-    NestedMetaItem::MetaItem(mk_word_item(ident))\n+    MetaItem { path: Path::from_ident(ident), kind: MetaItemKind::NameValue(lit), span }\n }\n \n pub struct AttrIdGenerator(WorkerLocal<Cell<u32>>);\n@@ -404,21 +388,58 @@ pub fn mk_attr_from_item(\n     span: Span,\n ) -> Attribute {\n     Attribute {\n-        kind: AttrKind::Normal(P(ast::NormalAttr { item, tokens })),\n+        kind: AttrKind::Normal(P(NormalAttr { item, tokens })),\n         id: g.mk_attr_id(),\n         style,\n         span,\n     }\n }\n \n-/// Returns an inner attribute with the given value and span.\n-pub fn mk_attr_inner(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Inner, item.path, item.kind.attr_args(item.span), item.span)\n+pub fn mk_attr_word(g: &AttrIdGenerator, style: AttrStyle, name: Symbol, span: Span) -> Attribute {\n+    let path = Path::from_ident(Ident::new(name, span));\n+    let args = AttrArgs::Empty;\n+    mk_attr(g, style, path, args, span)\n }\n \n-/// Returns an outer attribute with the given value and span.\n-pub fn mk_attr_outer(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Outer, item.path, item.kind.attr_args(item.span), item.span)\n+pub fn mk_attr_name_value_str(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    name: Symbol,\n+    val: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    let lit = LitKind::Str(val, StrStyle::Cooked).to_token_lit();\n+    let expr = P(Expr {\n+        id: DUMMY_NODE_ID,\n+        kind: ExprKind::Lit(lit),\n+        span,\n+        attrs: AttrVec::new(),\n+        tokens: None,\n+    });\n+    let path = Path::from_ident(Ident::new(name, span));\n+    let args = AttrArgs::Eq(span, AttrArgsEq::Ast(expr));\n+    mk_attr(g, style, path, args, span)\n+}\n+\n+pub fn mk_attr_nested_word(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    outer: Symbol,\n+    inner: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    let inner_tokens = TokenStream::new(vec![TokenTree::Token(\n+        Token::from_ast_ident(Ident::new(inner, span)),\n+        Spacing::Alone,\n+    )]);\n+    let outer_ident = Ident::new(outer, span);\n+    let path = Path::from_ident(outer_ident);\n+    let attr_args = AttrArgs::Delimited(DelimArgs {\n+        dspan: DelimSpan::from_single(span),\n+        delim: MacDelimiter::Parenthesis,\n+        tokens: inner_tokens,\n+    });\n+    mk_attr(g, style, path, attr_args, span)\n }\n \n pub fn mk_doc_comment(\n@@ -436,23 +457,6 @@ pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n }\n \n impl MetaItem {\n-    fn token_trees(&self) -> Vec<TokenTree> {\n-        let mut idents = vec![];\n-        let mut last_pos = BytePos(0_u32);\n-        for (i, segment) in self.path.segments.iter().enumerate() {\n-            let is_first = i == 0;\n-            if !is_first {\n-                let mod_sep_span =\n-                    Span::new(last_pos, segment.ident.span.lo(), segment.ident.span.ctxt(), None);\n-                idents.push(TokenTree::token_alone(token::ModSep, mod_sep_span));\n-            }\n-            idents.push(TokenTree::Token(Token::from_ast_ident(segment.ident), Spacing::Alone));\n-            last_pos = segment.ident.span.hi();\n-        }\n-        idents.extend(self.kind.token_trees(self.span));\n-        idents\n-    }\n-\n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n     where\n         I: Iterator<Item = TokenTree>,\n@@ -524,62 +528,6 @@ impl MetaItemKind {\n         }\n     }\n \n-    pub fn attr_args(&self, span: Span) -> AttrArgs {\n-        match self {\n-            MetaItemKind::Word => AttrArgs::Empty,\n-            MetaItemKind::NameValue(lit) => {\n-                let expr = P(ast::Expr {\n-                    id: ast::DUMMY_NODE_ID,\n-                    kind: ast::ExprKind::Lit(lit.token_lit.clone()),\n-                    span: lit.span,\n-                    attrs: ast::AttrVec::new(),\n-                    tokens: None,\n-                });\n-                AttrArgs::Eq(span, AttrArgsEq::Ast(expr))\n-            }\n-            MetaItemKind::List(list) => {\n-                let mut tts = Vec::new();\n-                for (i, item) in list.iter().enumerate() {\n-                    if i > 0 {\n-                        tts.push(TokenTree::token_alone(token::Comma, span));\n-                    }\n-                    tts.extend(item.token_trees())\n-                }\n-                AttrArgs::Delimited(DelimArgs {\n-                    dspan: DelimSpan::from_single(span),\n-                    delim: MacDelimiter::Parenthesis,\n-                    tokens: TokenStream::new(tts),\n-                })\n-            }\n-        }\n-    }\n-\n-    fn token_trees(&self, span: Span) -> Vec<TokenTree> {\n-        match self {\n-            MetaItemKind::Word => vec![],\n-            MetaItemKind::NameValue(lit) => {\n-                vec![\n-                    TokenTree::token_alone(token::Eq, span),\n-                    TokenTree::Token(lit.to_token(), Spacing::Alone),\n-                ]\n-            }\n-            MetaItemKind::List(list) => {\n-                let mut tokens = Vec::new();\n-                for (i, item) in list.iter().enumerate() {\n-                    if i > 0 {\n-                        tokens.push(TokenTree::token_alone(token::Comma, span));\n-                    }\n-                    tokens.extend(item.token_trees())\n-                }\n-                vec![TokenTree::Delimited(\n-                    DelimSpan::from_single(span),\n-                    Delimiter::Parenthesis,\n-                    TokenStream::new(tokens),\n-                )]\n-            }\n-        }\n-    }\n-\n     fn list_from_tokens(tokens: TokenStream) -> Option<MetaItemKind> {\n         let mut tokens = tokens.into_trees().peekable();\n         let mut result = Vec::new();\n@@ -602,7 +550,7 @@ impl MetaItemKind {\n                 MetaItemKind::name_value_from_tokens(&mut inner_tokens.into_trees())\n             }\n             Some(TokenTree::Token(token, _)) => {\n-                Lit::from_token(&token).map(MetaItemKind::NameValue)\n+                MetaItemLit::from_token(&token).map(MetaItemKind::NameValue)\n             }\n             _ => None,\n         }\n@@ -618,9 +566,9 @@ impl MetaItemKind {\n             }) => MetaItemKind::list_from_tokens(tokens.clone()),\n             AttrArgs::Delimited(..) => None,\n             AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n-                ast::ExprKind::Lit(token_lit) => {\n+                ExprKind::Lit(token_lit) => {\n                     // Turn failures to `None`, we'll get parse errors elsewhere.\n-                    Lit::from_token_lit(token_lit, expr.span)\n+                    MetaItemLit::from_token_lit(token_lit, expr.span)\n                         .ok()\n                         .map(|lit| MetaItemKind::NameValue(lit))\n                 }\n@@ -653,16 +601,7 @@ impl NestedMetaItem {\n     pub fn span(&self) -> Span {\n         match self {\n             NestedMetaItem::MetaItem(item) => item.span,\n-            NestedMetaItem::Literal(lit) => lit.span,\n-        }\n-    }\n-\n-    fn token_trees(&self) -> Vec<TokenTree> {\n-        match self {\n-            NestedMetaItem::MetaItem(item) => item.token_trees(),\n-            NestedMetaItem::Literal(lit) => {\n-                vec![TokenTree::Token(lit.to_token(), Spacing::Alone)]\n-            }\n+            NestedMetaItem::Lit(lit) => lit.span,\n         }\n     }\n \n@@ -672,10 +611,10 @@ impl NestedMetaItem {\n     {\n         match tokens.peek() {\n             Some(TokenTree::Token(token, _))\n-                if let Some(lit) = Lit::from_token(token) =>\n+                if let Some(lit) = MetaItemLit::from_token(token) =>\n             {\n                 tokens.next();\n-                return Some(NestedMetaItem::Literal(lit));\n+                return Some(NestedMetaItem::Lit(lit));\n             }\n             Some(TokenTree::Delimited(_, Delimiter::Invisible, inner_tokens)) => {\n                 let inner_tokens = inner_tokens.clone();"}, {"sha": "963e5a608a4927ecc24551fa6cee3f39f957754e", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -410,11 +410,7 @@ pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n     let UseTree { prefix, kind, span } = use_tree;\n     vis.visit_path(prefix);\n     match kind {\n-        UseTreeKind::Simple(rename, id1, id2) => {\n-            visit_opt(rename, |rename| vis.visit_ident(rename));\n-            vis.visit_id(id1);\n-            vis.visit_id(id2);\n-        }\n+        UseTreeKind::Simple(rename) => visit_opt(rename, |rename| vis.visit_ident(rename)),\n         UseTreeKind::Nested(items) => {\n             for (tree, id) in items {\n                 vis.visit_use_tree(tree);\n@@ -628,7 +624,7 @@ pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T\n pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &mut T) {\n     match li {\n         NestedMetaItem::MetaItem(mi) => vis.visit_meta_item(mi),\n-        NestedMetaItem::Literal(_lit) => {}\n+        NestedMetaItem::Lit(_lit) => {}\n     }\n }\n \n@@ -725,10 +721,10 @@ pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyAttrTokenStream>,\n     visit_lazy_tts_opt_mut(lazy_tts.as_mut(), vis);\n }\n \n+/// Applies ident visitor if it's an ident; applies other visits to interpolated nodes.\n+/// In practice the ident part is not actually used by specific visitors right now,\n+/// but there's a test below checking that it works.\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-// Applies ident visitor if it's an ident; applies other visits to interpolated nodes.\n-// In practice the ident part is not actually used by specific visitors right now,\n-// but there's a test below checking that it works.\n pub fn visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n     let Token { kind, span } = t;\n     match kind {"}, {"sha": "c0cc4e79a3d53161b3e985c45ba1daae69ee0efc", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -302,9 +302,9 @@ impl TokenKind {\n         Literal(Lit::new(kind, symbol, suffix))\n     }\n \n-    // An approximation to proc-macro-style single-character operators used by rustc parser.\n-    // If the operator token can be broken into two tokens, the first of which is single-character,\n-    // then this function performs that operation, otherwise it returns `None`.\n+    /// An approximation to proc-macro-style single-character operators used by rustc parser.\n+    /// If the operator token can be broken into two tokens, the first of which is single-character,\n+    /// then this function performs that operation, otherwise it returns `None`.\n     pub fn break_two_token_op(&self) -> Option<(TokenKind, TokenKind)> {\n         Some(match *self {\n             Le => (Lt, Eq),\n@@ -538,10 +538,10 @@ impl Token {\n         }\n     }\n \n-    // A convenience function for matching on identifiers during parsing.\n-    // Turns interpolated identifier (`$i: ident`) or lifetime (`$l: lifetime`) token\n-    // into the regular identifier or lifetime token it refers to,\n-    // otherwise returns the original token.\n+    /// A convenience function for matching on identifiers during parsing.\n+    /// Turns interpolated identifier (`$i: ident`) or lifetime (`$l: lifetime`) token\n+    /// into the regular identifier or lifetime token it refers to,\n+    /// otherwise returns the original token.\n     pub fn uninterpolate(&self) -> Cow<'_, Token> {\n         match &self.kind {\n             Interpolated(nt) => match **nt {\n@@ -621,7 +621,7 @@ impl Token {\n         false\n     }\n \n-    // Is the token an interpolated block (`$b:block`)?\n+    /// Is the token an interpolated block (`$b:block`)?\n     pub fn is_whole_block(&self) -> bool {\n         if let Interpolated(nt) = &self.kind && let NtBlock(..) = **nt {\n             return true;\n@@ -665,8 +665,8 @@ impl Token {\n         self.is_non_raw_ident_where(Ident::is_path_segment_keyword)\n     }\n \n-    // Returns true for reserved identifiers used internally for elided lifetimes,\n-    // unnamed method parameters, crate root module, error recovery etc.\n+    /// Returns true for reserved identifiers used internally for elided lifetimes,\n+    /// unnamed method parameters, crate root module, error recovery etc.\n     pub fn is_special_ident(&self) -> bool {\n         self.is_non_raw_ident_where(Ident::is_special)\n     }"}, {"sha": "58c6d397ea2706380e3839f23c4467ee3b47b712", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -86,12 +86,12 @@ impl TokenTree {\n         }\n     }\n \n-    // Create a `TokenTree::Token` with alone spacing.\n+    /// Create a `TokenTree::Token` with alone spacing.\n     pub fn token_alone(kind: TokenKind, span: Span) -> TokenTree {\n         TokenTree::Token(Token::new(kind, span), Spacing::Alone)\n     }\n \n-    // Create a `TokenTree::Token` with joint spacing.\n+    /// Create a `TokenTree::Token` with joint spacing.\n     pub fn token_joint(kind: TokenKind, span: Span) -> TokenTree {\n         TokenTree::Token(Token::new(kind, span), Spacing::Joint)\n     }\n@@ -413,17 +413,17 @@ impl TokenStream {\n         TokenStream(Lrc::new(self.0.iter().enumerate().map(|(i, tree)| f(i, tree)).collect()))\n     }\n \n-    // Create a token stream containing a single token with alone spacing.\n+    /// Create a token stream containing a single token with alone spacing.\n     pub fn token_alone(kind: TokenKind, span: Span) -> TokenStream {\n         TokenStream::new(vec![TokenTree::token_alone(kind, span)])\n     }\n \n-    // Create a token stream containing a single token with joint spacing.\n+    /// Create a token stream containing a single token with joint spacing.\n     pub fn token_joint(kind: TokenKind, span: Span) -> TokenStream {\n         TokenStream::new(vec![TokenTree::token_joint(kind, span)])\n     }\n \n-    // Create a token stream containing a single `Delimited`.\n+    /// Create a token stream containing a single `Delimited`.\n     pub fn delimited(span: DelimSpan, delim: Delimiter, tts: TokenStream) -> TokenStream {\n         TokenStream::new(vec![TokenTree::Delimited(span, delim, tts)])\n     }\n@@ -522,8 +522,8 @@ impl TokenStream {\n         }\n     }\n \n-    // Push `tt` onto the end of the stream, possibly gluing it to the last\n-    // token. Uses `make_mut` to maximize efficiency.\n+    /// Push `tt` onto the end of the stream, possibly gluing it to the last\n+    /// token. Uses `make_mut` to maximize efficiency.\n     pub fn push_tree(&mut self, tt: TokenTree) {\n         let vec_mut = Lrc::make_mut(&mut self.0);\n \n@@ -534,9 +534,9 @@ impl TokenStream {\n         }\n     }\n \n-    // Push `stream` onto the end of the stream, possibly gluing the first\n-    // token tree to the last token. (No other token trees will be glued.)\n-    // Uses `make_mut` to maximize efficiency.\n+    /// Push `stream` onto the end of the stream, possibly gluing the first\n+    /// token tree to the last token. (No other token trees will be glued.)\n+    /// Uses `make_mut` to maximize efficiency.\n     pub fn push_stream(&mut self, stream: TokenStream) {\n         let vec_mut = Lrc::make_mut(&mut self.0);\n "}, {"sha": "1d6e7914f3a5c8d0395de312564765bc7dbcb688", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,8 +1,7 @@\n //! Code related to parsing literals.\n \n-use crate::ast::{self, Lit, LitKind};\n+use crate::ast::{self, LitKind, MetaItemLit};\n use crate::token::{self, Token};\n-use rustc_data_structures::sync::Lrc;\n use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n@@ -196,39 +195,16 @@ impl LitKind {\n     }\n }\n \n-impl Lit {\n-    /// Converts literal token into an AST literal.\n-    pub fn from_token_lit(token_lit: token::Lit, span: Span) -> Result<Lit, LitError> {\n-        Ok(Lit { token_lit, kind: LitKind::from_token_lit(token_lit)?, span })\n+impl MetaItemLit {\n+    /// Converts token literal into a meta item literal.\n+    pub fn from_token_lit(token_lit: token::Lit, span: Span) -> Result<MetaItemLit, LitError> {\n+        Ok(MetaItemLit { token_lit, kind: LitKind::from_token_lit(token_lit)?, span })\n     }\n \n-    /// Converts an arbitrary token into an AST literal.\n-    pub fn from_token(token: &Token) -> Option<Lit> {\n+    /// Converts an arbitrary token into meta item literal.\n+    pub fn from_token(token: &Token) -> Option<MetaItemLit> {\n         token::Lit::from_token(token)\n-            .and_then(|token_lit| Lit::from_token_lit(token_lit, token.span).ok())\n-    }\n-\n-    /// Attempts to recover an AST literal from semantic literal.\n-    /// This function is used when the original token doesn't exist (e.g. the literal is created\n-    /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n-    pub fn from_lit_kind(kind: LitKind, span: Span) -> Lit {\n-        Lit { token_lit: kind.to_token_lit(), kind, span }\n-    }\n-\n-    /// Recovers an AST literal from a string of bytes produced by `include_bytes!`.\n-    /// This requires ASCII-escaping the string, which can result in poor performance\n-    /// for very large strings of bytes.\n-    pub fn from_included_bytes(bytes: &Lrc<[u8]>, span: Span) -> Lit {\n-        Self::from_lit_kind(LitKind::ByteStr(bytes.clone()), span)\n-    }\n-\n-    /// Losslessly convert an AST literal into a token.\n-    pub fn to_token(&self) -> Token {\n-        let kind = match self.token_lit.kind {\n-            token::Bool => token::Ident(self.token_lit.symbol, false),\n-            _ => token::Literal(self.token_lit),\n-        };\n-        Token::new(kind, self.span)\n+            .and_then(|token_lit| MetaItemLit::from_token_lit(token_lit, token.span).ok())\n     }\n }\n "}, {"sha": "fe27d7fa8de172bb87587435d18c2b6c256d884b", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -439,7 +439,7 @@ pub fn walk_path<'a, V: Visitor<'a>>(visitor: &mut V, path: &'a Path) {\n pub fn walk_use_tree<'a, V: Visitor<'a>>(visitor: &mut V, use_tree: &'a UseTree, id: NodeId) {\n     visitor.visit_path(&use_tree.prefix, id);\n     match &use_tree.kind {\n-        UseTreeKind::Simple(rename, ..) => {\n+        UseTreeKind::Simple(rename) => {\n             // The extra IDs are handled during HIR lowering.\n             if let &Some(rename) = rename {\n                 visitor.visit_ident(rename);"}, {"sha": "82912a733d55222ca2a29b324eb0f106934054ae", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1606,16 +1606,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         // `#[allow(unreachable_code)]`\n-        let attr = {\n-            // `allow(unreachable_code)`\n-            let allow = {\n-                let allow_ident = Ident::new(sym::allow, self.lower_span(span));\n-                let uc_ident = Ident::new(sym::unreachable_code, self.lower_span(span));\n-                let uc_nested = attr::mk_nested_word_item(uc_ident);\n-                attr::mk_list_item(allow_ident, vec![uc_nested])\n-            };\n-            attr::mk_attr_outer(&self.tcx.sess.parse_sess.attr_id_generator, allow)\n-        };\n+        let attr = attr::mk_attr_nested_word(\n+            &self.tcx.sess.parse_sess.attr_id_generator,\n+            AttrStyle::Outer,\n+            sym::allow,\n+            sym::unreachable_code,\n+            self.lower_span(span),\n+        );\n         let attrs: AttrVec = thin_vec![attr];\n \n         // `ControlFlow::Continue(val) => #[allow(unreachable_code)] val,`"}, {"sha": "fe0bd43815d7f4393d71c2ec91c033f19557964b", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             if hir_id.owner != self.owner {\n                 span_bug!(\n                     span,\n-                    \"inconsistent DepNode at `{:?}` for `{:?}`: \\\n+                    \"inconsistent HirId at `{:?}` for `{:?}`: \\\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n                     self.source_map.span_to_diagnostic_string(span),\n                     node,"}, {"sha": "f6275433fc51bcde5fb9edf669094fd338c4ba6c", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 15, "deletions": 80, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -19,7 +19,6 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, Symbol};\n use rustc_target::spec::abi;\n use smallvec::{smallvec, SmallVec};\n-use std::iter;\n use thin_vec::ThinVec;\n \n pub(super) struct ItemLowerer<'a, 'hir> {\n@@ -179,36 +178,22 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let mut node_ids =\n             smallvec![hir::ItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n         if let ItemKind::Use(use_tree) = &i.kind {\n-            self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n+            self.lower_item_id_use_tree(use_tree, &mut node_ids);\n         }\n         node_ids\n     }\n \n-    fn lower_item_id_use_tree(\n-        &mut self,\n-        tree: &UseTree,\n-        base_id: NodeId,\n-        vec: &mut SmallVec<[hir::ItemId; 1]>,\n-    ) {\n+    fn lower_item_id_use_tree(&mut self, tree: &UseTree, vec: &mut SmallVec<[hir::ItemId; 1]>) {\n         match &tree.kind {\n             UseTreeKind::Nested(nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n                     vec.push(hir::ItemId {\n                         owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n                     });\n-                    self.lower_item_id_use_tree(nested, id, vec);\n-                }\n-            }\n-            UseTreeKind::Glob => {}\n-            UseTreeKind::Simple(_, id1, id2) => {\n-                for (_, id) in\n-                    iter::zip(self.expect_full_res_from_use(base_id).skip(1), [*id1, *id2])\n-                {\n-                    vec.push(hir::ItemId {\n-                        owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n-                    });\n+                    self.lower_item_id_use_tree(nested, vec);\n                 }\n             }\n+            UseTreeKind::Simple(..) | UseTreeKind::Glob => {}\n         }\n     }\n \n@@ -489,7 +474,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let segments = prefix.segments.iter().chain(path.segments.iter()).cloned().collect();\n \n         match tree.kind {\n-            UseTreeKind::Simple(rename, id1, id2) => {\n+            UseTreeKind::Simple(rename) => {\n                 *ident = tree.ident();\n \n                 // First, apply the prefix to the path.\n@@ -505,66 +490,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     }\n                 }\n \n-                let mut resolutions = self.expect_full_res_from_use(id).fuse();\n-                // We want to return *something* from this function, so hold onto the first item\n-                // for later.\n-                let ret_res = self.lower_res(resolutions.next().unwrap_or(Res::Err));\n-\n-                // Here, we are looping over namespaces, if they exist for the definition\n-                // being imported. We only handle type and value namespaces because we\n-                // won't be dealing with macros in the rest of the compiler.\n-                // Essentially a single `use` which imports two names is desugared into\n-                // two imports.\n-                for new_node_id in [id1, id2] {\n-                    let new_id = self.local_def_id(new_node_id);\n-                    let Some(res) = resolutions.next() else {\n-                        debug_assert!(self.children.iter().find(|(id, _)| id == &new_id).is_none());\n-                        // Associate an HirId to both ids even if there is no resolution.\n-                        self.children.push((\n-                            new_id,\n-                            hir::MaybeOwner::NonOwner(hir::HirId::make_owner(new_id))),\n-                        );\n-                        continue;\n-                    };\n-                    let ident = *ident;\n-                    let mut path = path.clone();\n-                    for seg in &mut path.segments {\n-                        // Give the cloned segment the same resolution information\n-                        // as the old one (this is needed for stability checking).\n-                        let new_id = self.next_node_id();\n-                        self.resolver.clone_res(seg.id, new_id);\n-                        seg.id = new_id;\n-                    }\n-                    let span = path.span;\n-\n-                    self.with_hir_id_owner(new_node_id, |this| {\n-                        let res = this.lower_res(res);\n-                        let path = this.lower_path_extra(res, &path, ParamMode::Explicit);\n-                        let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n-                        if let Some(attrs) = attrs {\n-                            this.attrs.insert(hir::ItemLocalId::new(0), attrs);\n-                        }\n-\n-                        let item = hir::Item {\n-                            owner_id: hir::OwnerId { def_id: new_id },\n-                            ident: this.lower_ident(ident),\n-                            kind,\n-                            vis_span,\n-                            span: this.lower_span(span),\n-                        };\n-                        hir::OwnerNode::Item(this.arena.alloc(item))\n-                    });\n-                }\n-\n-                let path = self.lower_path_extra(ret_res, &path, ParamMode::Explicit);\n+                let res =\n+                    self.expect_full_res_from_use(id).map(|res| self.lower_res(res)).collect();\n+                let path = self.lower_use_path(res, &path, ParamMode::Explicit);\n                 hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n-                let path = self.lower_path(\n-                    id,\n-                    &Path { segments, span: path.span, tokens: None },\n-                    ParamMode::Explicit,\n-                );\n+                let res = self.expect_full_res(id);\n+                let res = smallvec![self.lower_res(res)];\n+                let path = Path { segments, span: path.span, tokens: None };\n+                let path = self.lower_use_path(res, &path, ParamMode::Explicit);\n                 hir::ItemKind::Use(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n@@ -634,9 +569,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     });\n                 }\n \n-                let res = self.expect_full_res_from_use(id).next().unwrap_or(Res::Err);\n-                let res = self.lower_res(res);\n-                let path = self.lower_path_extra(res, &prefix, ParamMode::Explicit);\n+                let res =\n+                    self.expect_full_res_from_use(id).map(|res| self.lower_res(res)).collect();\n+                let path = self.lower_use_path(res, &prefix, ParamMode::Explicit);\n                 hir::ItemKind::Use(path, hir::UseKind::ListStem)\n             }\n         }"}, {"sha": "1d27970627854558902e9b661a9a34f07a14733e", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.tcx.hir().def_key(self.local_def_id(node_id)),\n         );\n \n-        let def_id = self.tcx.create_def(parent, data);\n+        let def_id = self.tcx.create_def(parent, data).def_id();\n \n         debug!(\"create_def: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n         self.resolver.node_id_to_def_id.insert(node_id, def_id);\n@@ -948,17 +948,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => {\n                 // In valid code the value always ends up as a single literal. Otherwise, a dummy\n                 // literal suffices because the error is handled elsewhere.\n-                let lit = if let ExprKind::Lit(token_lit) = expr.kind {\n-                    match Lit::from_token_lit(token_lit, expr.span) {\n-                        Ok(lit) => lit,\n-                        Err(_err) => Lit {\n-                            token_lit: token::Lit::new(token::LitKind::Err, kw::Empty, None),\n-                            kind: LitKind::Err,\n-                            span: DUMMY_SP,\n-                        },\n-                    }\n+                let lit = if let ExprKind::Lit(token_lit) = expr.kind\n+                    && let Ok(lit) = MetaItemLit::from_token_lit(token_lit, expr.span)\n+                {\n+                    lit\n                 } else {\n-                    Lit {\n+                    MetaItemLit {\n                         token_lit: token::Lit::new(token::LitKind::Err, kw::Empty, None),\n                         kind: LitKind::Err,\n                         span: DUMMY_SP,"}, {"sha": "8d23c26e603b77bf035aded708af0676d47dff59", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::GenericArg;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{BytePos, Span, DUMMY_SP};\n \n-use smallvec::smallvec;\n+use smallvec::{smallvec, SmallVec};\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     #[instrument(level = \"trace\", skip(self))]\n@@ -144,13 +144,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         );\n     }\n \n-    pub(crate) fn lower_path_extra(\n+    pub(crate) fn lower_use_path(\n         &mut self,\n-        res: Res,\n+        res: SmallVec<[Res; 3]>,\n         p: &Path,\n         param_mode: ParamMode,\n-    ) -> &'hir hir::Path<'hir> {\n-        self.arena.alloc(hir::Path {\n+    ) -> &'hir hir::UsePath<'hir> {\n+        self.arena.alloc(hir::UsePath {\n             res,\n             segments: self.arena.alloc_from_iter(p.segments.iter().map(|segment| {\n                 self.lower_path_segment(\n@@ -165,17 +165,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         })\n     }\n \n-    pub(crate) fn lower_path(\n-        &mut self,\n-        id: NodeId,\n-        p: &Path,\n-        param_mode: ParamMode,\n-    ) -> &'hir hir::Path<'hir> {\n-        let res = self.expect_full_res(id);\n-        let res = self.lower_res(res);\n-        self.lower_path_extra(res, p, param_mode)\n-    }\n-\n     pub(crate) fn lower_path_segment(\n         &mut self,\n         path_span: Span,"}, {"sha": "eb9c841d80c16b05a74f3f0e7be3404b5c59a974", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -209,15 +209,15 @@ impl<'a> AstValidator<'a> {\n \n     // Mirrors `visit::walk_ty`, but tracks relevant state.\n     fn walk_ty(&mut self, t: &'a Ty) {\n-        match t.kind {\n+        match &t.kind {\n             TyKind::ImplTrait(..) => {\n                 self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t))\n             }\n             TyKind::TraitObject(..) => self\n                 .with_banned_tilde_const(DisallowTildeConstContext::TraitObject, |this| {\n                     visit::walk_ty(this, t)\n                 }),\n-            TyKind::Path(ref qself, ref path) => {\n+            TyKind::Path(qself, path) => {\n                 // We allow these:\n                 //  - `Option<impl Trait>`\n                 //  - `option::Option<impl Trait>`\n@@ -231,7 +231,7 @@ impl<'a> AstValidator<'a> {\n                 // (for cases like `<impl Trait>::Foo>`)\n                 // but we allow `impl Trait` in `GenericArgs`\n                 // iff there are no more PathSegments.\n-                if let Some(ref qself) = *qself {\n+                if let Some(qself) = qself {\n                     // `impl Trait` in `qself` is always illegal\n                     self.with_banned_impl_trait(|this| this.visit_ty(&qself.ty));\n                 }\n@@ -738,8 +738,8 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn visit_ty_common(&mut self, ty: &'a Ty) {\n-        match ty.kind {\n-            TyKind::BareFn(ref bfty) => {\n+        match &ty.kind {\n+            TyKind::BareFn(bfty) => {\n                 self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n                 Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n                     struct_span_err!(\n@@ -756,10 +756,10 @@ impl<'a> AstValidator<'a> {\n                     self.maybe_lint_missing_abi(sig_span, ty.id);\n                 }\n             }\n-            TyKind::TraitObject(ref bounds, ..) => {\n+            TyKind::TraitObject(bounds, ..) => {\n                 let mut any_lifetime_bounds = false;\n                 for bound in bounds {\n-                    if let GenericBound::Outlives(ref lifetime) = *bound {\n+                    if let GenericBound::Outlives(lifetime) = bound {\n                         if any_lifetime_bounds {\n                             struct_span_err!(\n                                 self.session,\n@@ -774,7 +774,7 @@ impl<'a> AstValidator<'a> {\n                     }\n                 }\n             }\n-            TyKind::ImplTrait(_, ref bounds) => {\n+            TyKind::ImplTrait(_, bounds) => {\n                 if self.is_impl_trait_banned {\n                     struct_span_err!(\n                         self.session,\n@@ -842,8 +842,8 @@ fn validate_generic_param_order(\n         let (kind, bounds, span) = (&param.kind, &param.bounds, ident.span);\n         let (ord_kind, ident) = match &param.kind {\n             GenericParamKind::Lifetime => (ParamKindOrd::Lifetime, ident.to_string()),\n-            GenericParamKind::Type { default: _ } => (ParamKindOrd::TypeOrConst, ident.to_string()),\n-            GenericParamKind::Const { ref ty, kw_span: _, default: _ } => {\n+            GenericParamKind::Type { .. } => (ParamKindOrd::TypeOrConst, ident.to_string()),\n+            GenericParamKind::Const { ty, .. } => {\n                 let ty = pprust::ty_to_string(ty);\n                 (ParamKindOrd::TypeOrConst, format!(\"const {}: {}\", ident, ty))\n             }\n@@ -912,7 +912,7 @@ fn validate_generic_param_order(\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {\n-        validate_attr::check_meta(&self.session.parse_sess, attr);\n+        validate_attr::check_attr(&self.session.parse_sess, attr);\n     }\n \n     fn visit_expr(&mut self, expr: &'a Expr) {\n@@ -948,8 +948,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 ExprKind::Paren(local_expr) => {\n                     fn has_let_expr(expr: &Expr) -> bool {\n-                        match expr.kind {\n-                            ExprKind::Binary(_, ref lhs, ref rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n+                        match &expr.kind {\n+                            ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n                             ExprKind::Let(..) => true,\n                             _ => false,\n                         }\n@@ -1005,18 +1005,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n \n-        match item.kind {\n+        match &item.kind {\n             ItemKind::Impl(box Impl {\n                 unsafety,\n                 polarity,\n                 defaultness: _,\n                 constness,\n-                ref generics,\n-                of_trait: Some(ref t),\n-                ref self_ty,\n-                ref items,\n+                generics,\n+                of_trait: Some(t),\n+                self_ty,\n+                items,\n             }) => {\n-                self.with_in_trait_impl(true, Some(constness), |this| {\n+                self.with_in_trait_impl(true, Some(*constness), |this| {\n                     this.invalid_visibility(&item.vis, None);\n                     if let TyKind::Err = self_ty.kind {\n                         this.err_handler()\n@@ -1027,7 +1027,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                             .help(\"use `auto trait Trait {}` instead\")\n                             .emit();\n                     }\n-                    if let (Unsafe::Yes(span), ImplPolarity::Negative(sp)) = (unsafety, polarity) {\n+                    if let (&Unsafe::Yes(span), &ImplPolarity::Negative(sp)) = (unsafety, polarity)\n+                    {\n                         struct_span_err!(\n                             this.session,\n                             sp.to(t.path.span),\n@@ -1061,7 +1062,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 constness,\n                 generics: _,\n                 of_trait: None,\n-                ref self_ty,\n+                self_ty,\n                 items: _,\n             }) => {\n                 let error = |annotation_span, annotation| {\n@@ -1078,25 +1079,25 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     &item.vis,\n                     Some(InvalidVisibilityNote::IndividualImplItems),\n                 );\n-                if let Unsafe::Yes(span) = unsafety {\n+                if let &Unsafe::Yes(span) = unsafety {\n                     error(span, \"unsafe\").code(error_code!(E0197)).emit();\n                 }\n-                if let ImplPolarity::Negative(span) = polarity {\n+                if let &ImplPolarity::Negative(span) = polarity {\n                     error(span, \"negative\").emit();\n                 }\n-                if let Defaultness::Default(def_span) = defaultness {\n+                if let &Defaultness::Default(def_span) = defaultness {\n                     error(def_span, \"`default`\")\n                         .note(\"only trait implementations may be annotated with `default`\")\n                         .emit();\n                 }\n-                if let Const::Yes(span) = constness {\n+                if let &Const::Yes(span) = constness {\n                     error(span, \"`const`\")\n                         .note(\"only trait implementations may be annotated with `const`\")\n                         .emit();\n                 }\n             }\n-            ItemKind::Fn(box Fn { defaultness, ref sig, ref generics, ref body }) => {\n-                self.check_defaultness(item.span, defaultness);\n+            ItemKind::Fn(box Fn { defaultness, sig, generics, body }) => {\n+                self.check_defaultness(item.span, *defaultness);\n \n                 if body.is_none() {\n                     self.session.emit_err(FnWithoutBody {\n@@ -1132,7 +1133,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     &item.vis,\n                     Some(InvalidVisibilityNote::IndividualForeignItems),\n                 );\n-                if let Unsafe::Yes(span) = unsafety {\n+                if let &Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n                 }\n                 if abi.is_none() {\n@@ -1142,16 +1143,16 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.extern_mod = old_item;\n                 return; // Avoid visiting again.\n             }\n-            ItemKind::Enum(ref def, _) => {\n+            ItemKind::Enum(def, _) => {\n                 for variant in &def.variants {\n                     self.invalid_visibility(&variant.vis, None);\n                     for field in variant.data.fields() {\n                         self.invalid_visibility(&field.vis, None);\n                     }\n                 }\n             }\n-            ItemKind::Trait(box Trait { is_auto, ref generics, ref bounds, ref items, .. }) => {\n-                if is_auto == IsAuto::Yes {\n+            ItemKind::Trait(box Trait { is_auto, generics, bounds, items, .. }) => {\n+                if *is_auto == IsAuto::Yes {\n                     // Auto traits cannot have generics, super traits nor contain items.\n                     self.deny_generic_params(generics, item.ident.span);\n                     self.deny_super_traits(bounds, item.ident.span);\n@@ -1171,8 +1172,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return; // Avoid visiting again\n             }\n-            ItemKind::Mod(unsafety, ref mod_kind) => {\n-                if let Unsafe::Yes(span) = unsafety {\n+            ItemKind::Mod(unsafety, mod_kind) => {\n+                if let &Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n@@ -1182,13 +1183,13 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }\n-            ItemKind::Union(ref vdata, ..) => {\n+            ItemKind::Union(vdata, ..) => {\n                 if vdata.fields().is_empty() {\n                     self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n                 }\n             }\n             ItemKind::Const(def, .., None) => {\n-                self.check_defaultness(item.span, def);\n+                self.check_defaultness(item.span, *def);\n                 self.session.emit_err(ConstWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n@@ -1200,14 +1201,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n-            ItemKind::TyAlias(box TyAlias {\n-                defaultness,\n-                where_clauses,\n-                ref bounds,\n-                ref ty,\n-                ..\n-            }) => {\n-                self.check_defaultness(item.span, defaultness);\n+            ItemKind::TyAlias(box TyAlias { defaultness, where_clauses, bounds, ty, .. }) => {\n+                self.check_defaultness(item.span, *defaultness);\n                 if ty.is_none() {\n                     self.session.emit_err(TyAliasWithoutBody {\n                         span: item.span,\n@@ -1266,8 +1261,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n     // Mirrors `visit::walk_generic_args`, but tracks relevant state.\n     fn visit_generic_args(&mut self, generic_args: &'a GenericArgs) {\n-        match *generic_args {\n-            GenericArgs::AngleBracketed(ref data) => {\n+        match generic_args {\n+            GenericArgs::AngleBracketed(data) => {\n                 self.check_generic_args_before_constraints(data);\n \n                 for arg in &data.args {\n@@ -1283,7 +1278,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     }\n                 }\n             }\n-            GenericArgs::Parenthesized(ref data) => {\n+            GenericArgs::Parenthesized(data) => {\n                 walk_list!(self, visit_ty, &data.inputs);\n                 if let FnRetTy::Ty(ty) = &data.output {\n                     // `-> Foo` syntax is essentially an associated type binding,\n@@ -1319,7 +1314,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         validate_generic_param_order(self.err_handler(), &generics.params, generics.span);\n \n         for predicate in &generics.where_clause.predicates {\n-            if let WherePredicate::EqPredicate(ref predicate) = *predicate {\n+            if let WherePredicate::EqPredicate(predicate) = predicate {\n                 deny_equality_constraints(self, predicate, generics);\n             }\n         }\n@@ -1368,7 +1363,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_param_bound(&mut self, bound: &'a GenericBound, ctxt: BoundKind) {\n-        if let GenericBound::Trait(ref poly, modify) = *bound {\n+        if let GenericBound::Trait(poly, modify) = bound {\n             match (ctxt, modify) {\n                 (BoundKind::SuperTraits, TraitBoundModifier::Maybe) => {\n                     let mut err = self\n@@ -1573,8 +1568,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.check_item_named(item.ident, \"const\");\n         }\n \n-        match item.kind {\n-            AssocItemKind::Type(box TyAlias { ref generics, ref bounds, ref ty, .. })\n+        match &item.kind {\n+            AssocItemKind::Type(box TyAlias { generics, bounds, ty, .. })\n                 if ctxt == AssocCtxt::Trait =>\n             {\n                 self.visit_vis(&item.vis);\n@@ -1586,7 +1581,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 });\n                 walk_list!(self, visit_ty, ty);\n             }\n-            AssocItemKind::Fn(box Fn { ref sig, ref generics, ref body, .. })\n+            AssocItemKind::Fn(box Fn { sig, generics, body, .. })\n                 if self.in_const_trait_impl\n                     || ctxt == AssocCtxt::Trait\n                     || matches!(sig.header.constness, Const::Yes(_)) =>"}, {"sha": "32f45f8b59e90a4050a7a41fb525d93ed9609ae5", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -198,8 +198,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_item(&mut self, i: &'a ast::Item) {\n-        match i.kind {\n-            ast::ItemKind::ForeignMod(ref foreign_module) => {\n+        match &i.kind {\n+            ast::ItemKind::ForeignMod(foreign_module) => {\n                 if let Some(abi) = foreign_module.abi {\n                     self.check_abi(abi, ast::Const::No);\n                 }\n@@ -233,8 +233,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemKind::Impl(box ast::Impl { polarity, defaultness, ref of_trait, .. }) => {\n-                if let ast::ImplPolarity::Negative(span) = polarity {\n+            ast::ItemKind::Impl(box ast::Impl { polarity, defaultness, of_trait, .. }) => {\n+                if let &ast::ImplPolarity::Negative(span) = polarity {\n                     gate_feature_post!(\n                         &self,\n                         negative_impls,\n@@ -267,7 +267,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, decl_macro, i.span, msg);\n             }\n \n-            ast::ItemKind::TyAlias(box ast::TyAlias { ty: Some(ref ty), .. }) => {\n+            ast::ItemKind::TyAlias(box ast::TyAlias { ty: Some(ty), .. }) => {\n                 self.check_impl_trait(&ty)\n             }\n \n@@ -302,8 +302,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-        match ty.kind {\n-            ast::TyKind::BareFn(ref bare_fn_ty) => {\n+        match &ty.kind {\n+            ast::TyKind::BareFn(bare_fn_ty) => {\n                 // Function pointers cannot be `const`\n                 self.check_extern(bare_fn_ty.ext, ast::Const::No);\n             }\n@@ -319,7 +319,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FnRetTy) {\n-        if let ast::FnRetTy::Ty(ref output_ty) = *ret_ty {\n+        if let ast::FnRetTy::Ty(output_ty) = ret_ty {\n             if let ast::TyKind::Never = output_ty.kind {\n                 // Do nothing.\n             } else {\n@@ -455,9 +455,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_assoc_item(&mut self, i: &'a ast::AssocItem, ctxt: AssocCtxt) {\n-        let is_fn = match i.kind {\n+        let is_fn = match &i.kind {\n             ast::AssocItemKind::Fn(_) => true,\n-            ast::AssocItemKind::Type(box ast::TyAlias { ref ty, .. }) => {\n+            ast::AssocItemKind::Type(box ast::TyAlias { ty, .. }) => {\n                 if let (Some(_), AssocCtxt::Trait) = (ty, ctxt) {\n                     gate_feature_post!(\n                         &self,"}, {"sha": "c3e0eccd3d4046a98fb52bb231f7eb1b018dd2c4", "filename": "compiler/rustc_ast_pretty/src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -36,8 +36,8 @@ impl Printer {\n         self.nbsp()\n     }\n \n-    // Synthesizes a comment that was not textually present in the original\n-    // source file.\n+    /// Synthesizes a comment that was not textually present in the original\n+    /// source file.\n     pub fn synth_comment(&mut self, text: impl Into<Cow<'static, str>>) {\n         self.word(\"/*\");\n         self.space();"}, {"sha": "ebe55a4b7718331a86c5b3dede461c11eeb9d6e7", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 104, "deletions": 100, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -11,15 +11,15 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser;\n-use rustc_ast::{self as ast, AttrArgs, AttrArgsEq, BlockCheckMode, Mutability, PatKind};\n+use rustc_ast::{self as ast, AttrArgs, AttrArgsEq, BlockCheckMode, PatKind};\n use rustc_ast::{attr, BindingAnnotation, ByRef, DelimArgs, RangeEnd, RangeSyntax, Term};\n use rustc_ast::{GenericArg, GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, IdentPrinter, Symbol};\n-use rustc_span::{BytePos, FileName, Span};\n+use rustc_span::{BytePos, FileName, Span, DUMMY_SP};\n \n use rustc_ast::attr::AttrIdGenerator;\n use std::borrow::Cow;\n@@ -64,6 +64,7 @@ impl<'a> Comments<'a> {\n         Comments { sm, comments, current: 0 }\n     }\n \n+    // FIXME: This shouldn't probably clone lmao\n     pub fn next(&self) -> Option<Comment> {\n         self.comments.get(self.current).cloned()\n     }\n@@ -119,17 +120,20 @@ pub fn print_crate<'a>(\n         // of the feature gate, so we fake them up here.\n \n         // `#![feature(prelude_import)]`\n-        let pi_nested = attr::mk_nested_word_item(Ident::with_dummy_span(sym::prelude_import));\n-        let list = attr::mk_list_item(Ident::with_dummy_span(sym::feature), vec![pi_nested]);\n-        let fake_attr = attr::mk_attr_inner(g, list);\n+        let fake_attr = attr::mk_attr_nested_word(\n+            g,\n+            ast::AttrStyle::Inner,\n+            sym::feature,\n+            sym::prelude_import,\n+            DUMMY_SP,\n+        );\n         s.print_attribute(&fake_attr);\n \n         // Currently, in Rust 2018 we don't have `extern crate std;` at the crate\n         // root, so this is not needed, and actually breaks things.\n         if edition == Edition::Edition2015 {\n             // `#![no_std]`\n-            let no_std_meta = attr::mk_word_item(Ident::with_dummy_span(sym::no_std));\n-            let fake_attr = attr::mk_attr_inner(g, no_std_meta);\n+            let fake_attr = attr::mk_attr_word(g, ast::AttrStyle::Inner, sym::no_std, DUMMY_SP);\n             s.print_attribute(&fake_attr);\n         }\n     }\n@@ -268,10 +272,10 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n \n     fn maybe_print_comment(&mut self, pos: BytePos) -> bool {\n         let mut has_comment = false;\n-        while let Some(ref cmnt) = self.next_comment() {\n+        while let Some(cmnt) = self.next_comment() {\n             if cmnt.pos < pos {\n                 has_comment = true;\n-                self.print_comment(cmnt);\n+                self.print_comment(&cmnt);\n             } else {\n                 break;\n             }\n@@ -366,12 +370,12 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         if self.next_comment().is_none() {\n             self.hardbreak();\n         }\n-        while let Some(ref cmnt) = self.next_comment() {\n-            self.print_comment(cmnt)\n+        while let Some(cmnt) = self.next_comment() {\n+            self.print_comment(&cmnt)\n         }\n     }\n \n-    fn print_literal(&mut self, lit: &ast::Lit) {\n+    fn print_meta_item_lit(&mut self, lit: &ast::MetaItemLit) {\n         self.print_token_literal(lit.token_lit, lit.span)\n     }\n \n@@ -446,8 +450,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             self.hardbreak_if_not_bol();\n         }\n         self.maybe_print_comment(attr.span.lo());\n-        match attr.kind {\n-            ast::AttrKind::Normal(ref normal) => {\n+        match &attr.kind {\n+            ast::AttrKind::Normal(normal) => {\n                 match attr.style {\n                     ast::AttrStyle::Inner => self.word(\"#![\"),\n                     ast::AttrStyle::Outer => self.word(\"#[\"),\n@@ -456,7 +460,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 self.word(\"]\");\n             }\n             ast::AttrKind::DocComment(comment_kind, data) => {\n-                self.word(doc_comment_to_string(comment_kind, attr.style, data));\n+                self.word(doc_comment_to_string(*comment_kind, attr.style, *data));\n                 self.hardbreak()\n             }\n         }\n@@ -488,7 +492,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n-                let token_str = self.literal_to_string(lit);\n+                let token_str = self.meta_item_lit_to_string(lit);\n                 self.word(token_str);\n             }\n         }\n@@ -497,22 +501,22 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n \n     fn print_meta_list_item(&mut self, item: &ast::NestedMetaItem) {\n         match item {\n-            ast::NestedMetaItem::MetaItem(ref mi) => self.print_meta_item(mi),\n-            ast::NestedMetaItem::Literal(ref lit) => self.print_literal(lit),\n+            ast::NestedMetaItem::MetaItem(mi) => self.print_meta_item(mi),\n+            ast::NestedMetaItem::Lit(lit) => self.print_meta_item_lit(lit),\n         }\n     }\n \n     fn print_meta_item(&mut self, item: &ast::MetaItem) {\n         self.ibox(INDENT_UNIT);\n-        match item.kind {\n+        match &item.kind {\n             ast::MetaItemKind::Word => self.print_path(&item.path, false, 0),\n-            ast::MetaItemKind::NameValue(ref value) => {\n+            ast::MetaItemKind::NameValue(value) => {\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n-                self.print_literal(value);\n+                self.print_meta_item_lit(value);\n             }\n-            ast::MetaItemKind::List(ref items) => {\n+            ast::MetaItemKind::List(items) => {\n                 self.print_path(&item.path, false, 0);\n                 self.popen();\n                 self.commasep(Consistent, &items, |s, i| s.print_meta_list_item(i));\n@@ -657,7 +661,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_path_segment(&mut self, segment: &ast::PathSegment, colons_before_params: bool) {\n         if segment.ident.name != kw::PathRoot {\n             self.print_ident(segment.ident);\n-            if let Some(ref args) = segment.args {\n+            if let Some(args) = &segment.args {\n                 self.print_generic_args(args, colons_before_params);\n             }\n         }\n@@ -712,19 +716,19 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     }\n \n     fn nonterminal_to_string(&self, nt: &Nonterminal) -> String {\n-        match *nt {\n-            token::NtExpr(ref e) => self.expr_to_string(e),\n-            token::NtMeta(ref e) => self.attr_item_to_string(e),\n-            token::NtTy(ref e) => self.ty_to_string(e),\n-            token::NtPath(ref e) => self.path_to_string(e),\n-            token::NtItem(ref e) => self.item_to_string(e),\n-            token::NtBlock(ref e) => self.block_to_string(e),\n-            token::NtStmt(ref e) => self.stmt_to_string(e),\n-            token::NtPat(ref e) => self.pat_to_string(e),\n-            token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n+        match nt {\n+            token::NtExpr(e) => self.expr_to_string(e),\n+            token::NtMeta(e) => self.attr_item_to_string(e),\n+            token::NtTy(e) => self.ty_to_string(e),\n+            token::NtPath(e) => self.path_to_string(e),\n+            token::NtItem(e) => self.item_to_string(e),\n+            token::NtBlock(e) => self.block_to_string(e),\n+            token::NtStmt(e) => self.stmt_to_string(e),\n+            token::NtPat(e) => self.pat_to_string(e),\n+            token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(*e, *is_raw).to_string(),\n             token::NtLifetime(e) => e.to_string(),\n-            token::NtLiteral(ref e) => self.expr_to_string(e),\n-            token::NtVis(ref e) => self.vis_to_string(e),\n+            token::NtLiteral(e) => self.expr_to_string(e),\n+            token::NtVis(e) => self.vis_to_string(e),\n         }\n     }\n \n@@ -825,8 +829,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         Self::to_string(|s| s.print_expr(e))\n     }\n \n-    fn literal_to_string(&self, lit: &ast::Lit) -> String {\n-        Self::to_string(|s| s.print_literal(lit))\n+    fn meta_item_lit_to_string(&self, lit: &ast::MetaItemLit) -> String {\n+        Self::to_string(|s| s.print_meta_item_lit(lit))\n     }\n \n     fn tt_to_string(&self, tt: &TokenTree) -> String {\n@@ -917,8 +921,8 @@ impl<'a> PrintState<'a> for State<'a> {\n             self.word(\"::\")\n         }\n \n-        match *args {\n-            ast::GenericArgs::AngleBracketed(ref data) => {\n+        match args {\n+            ast::GenericArgs::AngleBracketed(data) => {\n                 self.word(\"<\");\n                 self.commasep(Inconsistent, &data.args, |s, arg| match arg {\n                     ast::AngleBracketedArg::Arg(a) => s.print_generic_arg(a),\n@@ -927,7 +931,7 @@ impl<'a> PrintState<'a> for State<'a> {\n                 self.word(\">\")\n             }\n \n-            ast::GenericArgs::Parenthesized(ref data) => {\n+            ast::GenericArgs::Parenthesized(data) => {\n                 self.word(\"(\");\n                 self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(ty));\n                 self.word(\")\");\n@@ -1011,62 +1015,62 @@ impl<'a> State<'a> {\n     pub fn print_type(&mut self, ty: &ast::Ty) {\n         self.maybe_print_comment(ty.span.lo());\n         self.ibox(0);\n-        match ty.kind {\n-            ast::TyKind::Slice(ref ty) => {\n+        match &ty.kind {\n+            ast::TyKind::Slice(ty) => {\n                 self.word(\"[\");\n                 self.print_type(ty);\n                 self.word(\"]\");\n             }\n-            ast::TyKind::Ptr(ref mt) => {\n+            ast::TyKind::Ptr(mt) => {\n                 self.word(\"*\");\n                 self.print_mt(mt, true);\n             }\n-            ast::TyKind::Rptr(ref lifetime, ref mt) => {\n+            ast::TyKind::Rptr(lifetime, mt) => {\n                 self.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n                 self.print_mt(mt, false);\n             }\n             ast::TyKind::Never => {\n                 self.word(\"!\");\n             }\n-            ast::TyKind::Tup(ref elts) => {\n+            ast::TyKind::Tup(elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts, |s, ty| s.print_type(ty));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n                 self.pclose();\n             }\n-            ast::TyKind::Paren(ref typ) => {\n+            ast::TyKind::Paren(typ) => {\n                 self.popen();\n                 self.print_type(typ);\n                 self.pclose();\n             }\n-            ast::TyKind::BareFn(ref f) => {\n+            ast::TyKind::BareFn(f) => {\n                 self.print_ty_fn(f.ext, f.unsafety, &f.decl, None, &f.generic_params);\n             }\n-            ast::TyKind::Path(None, ref path) => {\n+            ast::TyKind::Path(None, path) => {\n                 self.print_path(path, false, 0);\n             }\n-            ast::TyKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, false),\n-            ast::TyKind::TraitObject(ref bounds, syntax) => {\n-                if syntax == ast::TraitObjectSyntax::Dyn {\n+            ast::TyKind::Path(Some(qself), path) => self.print_qpath(path, qself, false),\n+            ast::TyKind::TraitObject(bounds, syntax) => {\n+                if *syntax == ast::TraitObjectSyntax::Dyn {\n                     self.word_nbsp(\"dyn\");\n                 }\n                 self.print_type_bounds(bounds);\n             }\n-            ast::TyKind::ImplTrait(_, ref bounds) => {\n+            ast::TyKind::ImplTrait(_, bounds) => {\n                 self.word_nbsp(\"impl\");\n                 self.print_type_bounds(bounds);\n             }\n-            ast::TyKind::Array(ref ty, ref length) => {\n+            ast::TyKind::Array(ty, length) => {\n                 self.word(\"[\");\n                 self.print_type(ty);\n                 self.word(\"; \");\n                 self.print_expr(&length.value);\n                 self.word(\"]\");\n             }\n-            ast::TyKind::Typeof(ref e) => {\n+            ast::TyKind::Typeof(e) => {\n                 self.word(\"typeof(\");\n                 self.print_expr(&e.value);\n                 self.word(\")\");\n@@ -1082,7 +1086,7 @@ impl<'a> State<'a> {\n             ast::TyKind::ImplicitSelf => {\n                 self.word(\"Self\");\n             }\n-            ast::TyKind::MacCall(ref m) => {\n+            ast::TyKind::MacCall(m) => {\n                 self.print_mac(m);\n             }\n             ast::TyKind::CVarArgs => {\n@@ -1111,8 +1115,8 @@ impl<'a> State<'a> {\n \n     pub(crate) fn print_stmt(&mut self, st: &ast::Stmt) {\n         self.maybe_print_comment(st.span.lo());\n-        match st.kind {\n-            ast::StmtKind::Local(ref loc) => {\n+        match &st.kind {\n+            ast::StmtKind::Local(loc) => {\n                 self.print_outer_attributes(&loc.attrs);\n                 self.space_if_not_bol();\n                 self.ibox(INDENT_UNIT);\n@@ -1135,15 +1139,15 @@ impl<'a> State<'a> {\n                 self.word(\";\");\n                 self.end(); // `let` ibox\n             }\n-            ast::StmtKind::Item(ref item) => self.print_item(item),\n-            ast::StmtKind::Expr(ref expr) => {\n+            ast::StmtKind::Item(item) => self.print_item(item),\n+            ast::StmtKind::Expr(expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr_outer_attr_style(expr, false);\n                 if classify::expr_requires_semi_to_be_stmt(expr) {\n                     self.word(\";\");\n                 }\n             }\n-            ast::StmtKind::Semi(ref expr) => {\n+            ast::StmtKind::Semi(expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr_outer_attr_style(expr, false);\n                 self.word(\";\");\n@@ -1152,7 +1156,7 @@ impl<'a> State<'a> {\n                 self.space_if_not_bol();\n                 self.word(\";\");\n             }\n-            ast::StmtKind::MacCall(ref mac) => {\n+            ast::StmtKind::MacCall(mac) => {\n                 self.space_if_not_bol();\n                 self.print_outer_attributes(&mac.attrs);\n                 self.print_mac(&mac.mac);\n@@ -1193,8 +1197,8 @@ impl<'a> State<'a> {\n         let has_attrs = self.print_inner_attributes(attrs);\n \n         for (i, st) in blk.stmts.iter().enumerate() {\n-            match st.kind {\n-                ast::StmtKind::Expr(ref expr) if i == blk.stmts.len() - 1 => {\n+            match &st.kind {\n+                ast::StmtKind::Expr(expr) if i == blk.stmts.len() - 1 => {\n                     self.maybe_print_comment(st.span.lo());\n                     self.space_if_not_bol();\n                     self.print_expr_outer_attr_style(expr, false);\n@@ -1362,7 +1366,7 @@ impl<'a> State<'a> {\n \n     pub(crate) fn print_local_decl(&mut self, loc: &ast::Local) {\n         self.print_pat(&loc.pat);\n-        if let Some(ref ty) = loc.ty {\n+        if let Some(ty) = &loc.ty {\n             self.word_space(\":\");\n             self.print_type(ty);\n         }\n@@ -1386,7 +1390,7 @@ impl<'a> State<'a> {\n         for item_segment in &path.segments[qself.position..] {\n             self.word(\"::\");\n             self.print_ident(item_segment.ident);\n-            if let Some(ref args) = item_segment.args {\n+            if let Some(args) = &item_segment.args {\n                 self.print_generic_args(args, colons_before_params)\n             }\n         }\n@@ -1397,23 +1401,23 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Pat(pat));\n         /* Pat isn't normalized, but the beauty of it\n         is that it doesn't matter */\n-        match pat.kind {\n+        match &pat.kind {\n             PatKind::Wild => self.word(\"_\"),\n-            PatKind::Ident(BindingAnnotation(by_ref, mutbl), ident, ref sub) => {\n-                if by_ref == ByRef::Yes {\n+            PatKind::Ident(BindingAnnotation(by_ref, mutbl), ident, sub) => {\n+                if *by_ref == ByRef::Yes {\n                     self.word_nbsp(\"ref\");\n                 }\n-                if mutbl == Mutability::Mut {\n+                if mutbl.is_mut() {\n                     self.word_nbsp(\"mut\");\n                 }\n-                self.print_ident(ident);\n-                if let Some(ref p) = *sub {\n+                self.print_ident(*ident);\n+                if let Some(p) = sub {\n                     self.space();\n                     self.word_space(\"@\");\n                     self.print_pat(p);\n                 }\n             }\n-            PatKind::TupleStruct(ref qself, ref path, ref elts) => {\n+            PatKind::TupleStruct(qself, path, elts) => {\n                 if let Some(qself) = qself {\n                     self.print_qpath(path, qself, true);\n                 } else {\n@@ -1423,16 +1427,16 @@ impl<'a> State<'a> {\n                 self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n                 self.pclose();\n             }\n-            PatKind::Or(ref pats) => {\n+            PatKind::Or(pats) => {\n                 self.strsep(\"|\", true, Inconsistent, &pats, |s, p| s.print_pat(p));\n             }\n-            PatKind::Path(None, ref path) => {\n+            PatKind::Path(None, path) => {\n                 self.print_path(path, true, 0);\n             }\n-            PatKind::Path(Some(ref qself), ref path) => {\n+            PatKind::Path(Some(qself), path) => {\n                 self.print_qpath(path, qself, false);\n             }\n-            PatKind::Struct(ref qself, ref path, ref fields, etc) => {\n+            PatKind::Struct(qself, path, fields, etc) => {\n                 if let Some(qself) = qself {\n                     self.print_qpath(path, qself, true);\n                 } else {\n@@ -1458,7 +1462,7 @@ impl<'a> State<'a> {\n                     },\n                     |f| f.pat.span,\n                 );\n-                if etc {\n+                if *etc {\n                     if !fields.is_empty() {\n                         self.word_space(\",\");\n                     }\n@@ -1469,21 +1473,21 @@ impl<'a> State<'a> {\n                 }\n                 self.word(\"}\");\n             }\n-            PatKind::Tuple(ref elts) => {\n+            PatKind::Tuple(elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n                 self.pclose();\n             }\n-            PatKind::Box(ref inner) => {\n+            PatKind::Box(inner) => {\n                 self.word(\"box \");\n                 self.print_pat(inner);\n             }\n-            PatKind::Ref(ref inner, mutbl) => {\n+            PatKind::Ref(inner, mutbl) => {\n                 self.word(\"&\");\n-                if mutbl == Mutability::Mut {\n+                if mutbl.is_mut() {\n                     self.word(\"mut \");\n                 }\n                 if let PatKind::Ident(ast::BindingAnnotation::MUT, ..) = inner.kind {\n@@ -1494,12 +1498,12 @@ impl<'a> State<'a> {\n                     self.print_pat(inner);\n                 }\n             }\n-            PatKind::Lit(ref e) => self.print_expr(&**e),\n-            PatKind::Range(ref begin, ref end, Spanned { node: ref end_kind, .. }) => {\n+            PatKind::Lit(e) => self.print_expr(&**e),\n+            PatKind::Range(begin, end, Spanned { node: end_kind, .. }) => {\n                 if let Some(e) = begin {\n                     self.print_expr(e);\n                 }\n-                match *end_kind {\n+                match end_kind {\n                     RangeEnd::Included(RangeSyntax::DotDotDot) => self.word(\"...\"),\n                     RangeEnd::Included(RangeSyntax::DotDotEq) => self.word(\"..=\"),\n                     RangeEnd::Excluded => self.word(\"..\"),\n@@ -1508,36 +1512,36 @@ impl<'a> State<'a> {\n                     self.print_expr(e);\n                 }\n             }\n-            PatKind::Slice(ref elts) => {\n+            PatKind::Slice(elts) => {\n                 self.word(\"[\");\n                 self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n                 self.word(\"]\");\n             }\n             PatKind::Rest => self.word(\"..\"),\n-            PatKind::Paren(ref inner) => {\n+            PatKind::Paren(inner) => {\n                 self.popen();\n                 self.print_pat(inner);\n                 self.pclose();\n             }\n-            PatKind::MacCall(ref m) => self.print_mac(m),\n+            PatKind::MacCall(m) => self.print_mac(m),\n         }\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n     fn print_explicit_self(&mut self, explicit_self: &ast::ExplicitSelf) {\n-        match explicit_self.node {\n+        match &explicit_self.node {\n             SelfKind::Value(m) => {\n-                self.print_mutability(m, false);\n+                self.print_mutability(*m, false);\n                 self.word(\"self\")\n             }\n-            SelfKind::Region(ref lt, m) => {\n+            SelfKind::Region(lt, m) => {\n                 self.word(\"&\");\n                 self.print_opt_lifetime(lt);\n-                self.print_mutability(m, false);\n+                self.print_mutability(*m, false);\n                 self.word(\"self\")\n             }\n-            SelfKind::Explicit(ref typ, m) => {\n-                self.print_mutability(m, false);\n+            SelfKind::Explicit(typ, m) => {\n+                self.print_mutability(*m, false);\n                 self.word(\"self\");\n                 self.word_space(\":\");\n                 self.print_type(typ)\n@@ -1599,7 +1603,7 @@ impl<'a> State<'a> {\n         self.commasep(Inconsistent, &generic_params, |s, param| {\n             s.print_outer_attributes_inline(&param.attrs);\n \n-            match param.kind {\n+            match &param.kind {\n                 ast::GenericParamKind::Lifetime => {\n                     let lt = ast::Lifetime { id: param.id, ident: param.ident };\n                     s.print_lifetime(lt);\n@@ -1608,19 +1612,19 @@ impl<'a> State<'a> {\n                         s.print_lifetime_bounds(&param.bounds)\n                     }\n                 }\n-                ast::GenericParamKind::Type { ref default } => {\n+                ast::GenericParamKind::Type { default } => {\n                     s.print_ident(param.ident);\n                     if !param.bounds.is_empty() {\n                         s.word_nbsp(\":\");\n                         s.print_type_bounds(&param.bounds);\n                     }\n-                    if let Some(ref default) = default {\n+                    if let Some(default) = default {\n                         s.space();\n                         s.word_space(\"=\");\n                         s.print_type(default)\n                     }\n                 }\n-                ast::GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n+                ast::GenericParamKind::Const { ty, default, .. } => {\n                     s.word_space(\"const\");\n                     s.print_ident(param.ident);\n                     s.space();\n@@ -1630,7 +1634,7 @@ impl<'a> State<'a> {\n                         s.word_nbsp(\":\");\n                         s.print_type_bounds(&param.bounds);\n                     }\n-                    if let Some(ref default) = default {\n+                    if let Some(default) = default {\n                         s.space();\n                         s.word_space(\"=\");\n                         s.print_expr(&default.value);\n@@ -1712,9 +1716,9 @@ impl<'a> State<'a> {\n             where_clause: ast::WhereClause {\n                 has_where_token: false,\n                 predicates: Vec::new(),\n-                span: rustc_span::DUMMY_SP,\n+                span: DUMMY_SP,\n             },\n-            span: rustc_span::DUMMY_SP,\n+            span: DUMMY_SP,\n         };\n         let header = ast::FnHeader { unsafety, ext, ..ast::FnHeader::default() };\n         self.print_fn(decl, header, name, &generics);"}, {"sha": "81483ac30d1de21bc5c1355832aa394fb58629bc", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 74, "deletions": 82, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -8,9 +8,9 @@ use rustc_ast::{self as ast, BlockCheckMode};\n impl<'a> State<'a> {\n     fn print_else(&mut self, els: Option<&ast::Expr>) {\n         if let Some(_else) = els {\n-            match _else.kind {\n+            match &_else.kind {\n                 // Another `else if` block.\n-                ast::ExprKind::If(ref i, ref then, ref e) => {\n+                ast::ExprKind::If(i, then, e) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n                     self.word(\" else if \");\n@@ -20,7 +20,7 @@ impl<'a> State<'a> {\n                     self.print_else(e.as_deref())\n                 }\n                 // Final `else` block.\n-                ast::ExprKind::Block(ref b, _) => {\n+                ast::ExprKind::Block(b, _) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n                     self.word(\" else \");\n@@ -58,10 +58,10 @@ impl<'a> State<'a> {\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n     }\n \n-    // Does `expr` need parentheses when printed in a condition position?\n-    //\n-    // These cases need parens due to the parse error observed in #26461: `if return {}`\n-    // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n+    /// Does `expr` need parentheses when printed in a condition position?\n+    ///\n+    /// These cases need parens due to the parse error observed in #26461: `if return {}`\n+    /// parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n     pub(super) fn cond_needs_par(expr: &ast::Expr) -> bool {\n         match expr.kind {\n             ast::ExprKind::Break(..)\n@@ -202,7 +202,7 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(receiver, parser::PREC_POSTFIX);\n         self.word(\".\");\n         self.print_ident(segment.ident);\n-        if let Some(ref args) = segment.args {\n+        if let Some(args) = &segment.args {\n             self.print_generic_args(args, true);\n         }\n         self.print_call_post(base_args)\n@@ -284,73 +284,66 @@ impl<'a> State<'a> {\n \n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n-        match expr.kind {\n-            ast::ExprKind::Box(ref expr) => {\n+        match &expr.kind {\n+            ast::ExprKind::Box(expr) => {\n                 self.word_space(\"box\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n             }\n-            ast::ExprKind::Array(ref exprs) => {\n+            ast::ExprKind::Array(exprs) => {\n                 self.print_expr_vec(exprs);\n             }\n-            ast::ExprKind::ConstBlock(ref anon_const) => {\n+            ast::ExprKind::ConstBlock(anon_const) => {\n                 self.print_expr_anon_const(anon_const, attrs);\n             }\n-            ast::ExprKind::Repeat(ref element, ref count) => {\n+            ast::ExprKind::Repeat(element, count) => {\n                 self.print_expr_repeat(element, count);\n             }\n-            ast::ExprKind::Struct(ref se) => {\n+            ast::ExprKind::Struct(se) => {\n                 self.print_expr_struct(&se.qself, &se.path, &se.fields, &se.rest);\n             }\n-            ast::ExprKind::Tup(ref exprs) => {\n+            ast::ExprKind::Tup(exprs) => {\n                 self.print_expr_tup(exprs);\n             }\n-            ast::ExprKind::Call(ref func, ref args) => {\n+            ast::ExprKind::Call(func, args) => {\n                 self.print_expr_call(func, &args);\n             }\n-            ast::ExprKind::MethodCall(box ast::MethodCall {\n-                ref seg,\n-                ref receiver,\n-                ref args,\n-                ..\n-            }) => {\n+            ast::ExprKind::MethodCall(box ast::MethodCall { seg, receiver, args, .. }) => {\n                 self.print_expr_method_call(seg, &receiver, &args);\n             }\n-            ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                self.print_expr_binary(op, lhs, rhs);\n+            ast::ExprKind::Binary(op, lhs, rhs) => {\n+                self.print_expr_binary(*op, lhs, rhs);\n             }\n-            ast::ExprKind::Unary(op, ref expr) => {\n-                self.print_expr_unary(op, expr);\n+            ast::ExprKind::Unary(op, expr) => {\n+                self.print_expr_unary(*op, expr);\n             }\n-            ast::ExprKind::AddrOf(k, m, ref expr) => {\n-                self.print_expr_addr_of(k, m, expr);\n+            ast::ExprKind::AddrOf(k, m, expr) => {\n+                self.print_expr_addr_of(*k, *m, expr);\n             }\n             ast::ExprKind::Lit(token_lit) => {\n-                self.print_token_literal(token_lit, expr.span);\n+                self.print_token_literal(*token_lit, expr.span);\n             }\n-            ast::ExprKind::IncludedBytes(ref bytes) => {\n-                let lit = ast::Lit::from_included_bytes(bytes, expr.span);\n-                self.print_literal(&lit)\n+            ast::ExprKind::IncludedBytes(bytes) => {\n+                let lit = ast::LitKind::ByteStr(bytes.clone()).to_token_lit();\n+                self.print_token_literal(lit, expr.span)\n             }\n-            ast::ExprKind::Cast(ref expr, ref ty) => {\n+            ast::ExprKind::Cast(expr, ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n                 self.print_expr_maybe_paren(expr, prec);\n                 self.space();\n                 self.word_space(\"as\");\n                 self.print_type(ty);\n             }\n-            ast::ExprKind::Type(ref expr, ref ty) => {\n+            ast::ExprKind::Type(expr, ty) => {\n                 let prec = AssocOp::Colon.precedence() as i8;\n                 self.print_expr_maybe_paren(expr, prec);\n                 self.word_space(\":\");\n                 self.print_type(ty);\n             }\n-            ast::ExprKind::Let(ref pat, ref scrutinee, _) => {\n+            ast::ExprKind::Let(pat, scrutinee, _) => {\n                 self.print_let(pat, scrutinee);\n             }\n-            ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                self.print_if(test, blk, elseopt.as_deref())\n-            }\n-            ast::ExprKind::While(ref test, ref blk, opt_label) => {\n+            ast::ExprKind::If(test, blk, elseopt) => self.print_if(test, blk, elseopt.as_deref()),\n+            ast::ExprKind::While(test, blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -362,7 +355,7 @@ impl<'a> State<'a> {\n                 self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n+            ast::ExprKind::ForLoop(pat, iter, blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -377,7 +370,7 @@ impl<'a> State<'a> {\n                 self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Loop(ref blk, opt_label, _) => {\n+            ast::ExprKind::Loop(blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -387,7 +380,7 @@ impl<'a> State<'a> {\n                 self.word_nbsp(\"loop\");\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Match(ref expr, ref arms) => {\n+            ast::ExprKind::Match(expr, arms) => {\n                 self.cbox(0);\n                 self.ibox(0);\n                 self.word_nbsp(\"match\");\n@@ -402,18 +395,18 @@ impl<'a> State<'a> {\n                 self.bclose(expr.span, empty);\n             }\n             ast::ExprKind::Closure(box ast::Closure {\n-                ref binder,\n+                binder,\n                 capture_clause,\n                 asyncness,\n                 movability,\n-                ref fn_decl,\n-                ref body,\n+                fn_decl,\n+                body,\n                 fn_decl_span: _,\n             }) => {\n                 self.print_closure_binder(binder);\n-                self.print_movability(movability);\n-                self.print_asyncness(asyncness);\n-                self.print_capture_clause(capture_clause);\n+                self.print_movability(*movability);\n+                self.print_asyncness(*asyncness);\n+                self.print_capture_clause(*capture_clause);\n \n                 self.print_fn_params_and_ret(fn_decl, true);\n                 self.space();\n@@ -425,7 +418,7 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 self.ibox(0);\n             }\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n+            ast::ExprKind::Block(blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -436,72 +429,71 @@ impl<'a> State<'a> {\n                 self.ibox(0);\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Async(capture_clause, _, ref blk) => {\n+            ast::ExprKind::Async(capture_clause, _, blk) => {\n                 self.word_nbsp(\"async\");\n-                self.print_capture_clause(capture_clause);\n+                self.print_capture_clause(*capture_clause);\n                 // cbox/ibox in analogy to the `ExprKind::Block` arm above\n                 self.cbox(0);\n                 self.ibox(0);\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Await(ref expr) => {\n+            ast::ExprKind::Await(expr) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\".await\");\n             }\n-            ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            ast::ExprKind::Assign(lhs, rhs, _) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1);\n                 self.space();\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(rhs, prec);\n             }\n-            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+            ast::ExprKind::AssignOp(op, lhs, rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1);\n                 self.space();\n                 self.word(op.node.to_string());\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(rhs, prec);\n             }\n-            ast::ExprKind::Field(ref expr, ident) => {\n+            ast::ExprKind::Field(expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\".\");\n-                self.print_ident(ident);\n+                self.print_ident(*ident);\n             }\n-            ast::ExprKind::Index(ref expr, ref index) => {\n+            ast::ExprKind::Index(expr, index) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\"[\");\n                 self.print_expr(index);\n                 self.word(\"]\");\n             }\n-            ast::ExprKind::Range(ref start, ref end, limits) => {\n+            ast::ExprKind::Range(start, end, limits) => {\n                 // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n                 // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n                 // Here we use a fake precedence value so that any child with lower precedence than\n                 // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n                 let fake_prec = AssocOp::LOr.precedence() as i8;\n-                if let Some(ref e) = *start {\n+                if let Some(e) = start {\n                     self.print_expr_maybe_paren(e, fake_prec);\n                 }\n-                if limits == ast::RangeLimits::HalfOpen {\n-                    self.word(\"..\");\n-                } else {\n-                    self.word(\"..=\");\n+                match limits {\n+                    ast::RangeLimits::HalfOpen => self.word(\"..\"),\n+                    ast::RangeLimits::Closed => self.word(\"..=\"),\n                 }\n-                if let Some(ref e) = *end {\n+                if let Some(e) = end {\n                     self.print_expr_maybe_paren(e, fake_prec);\n                 }\n             }\n             ast::ExprKind::Underscore => self.word(\"_\"),\n-            ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n-            ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n-            ast::ExprKind::Break(opt_label, ref opt_expr) => {\n+            ast::ExprKind::Path(None, path) => self.print_path(path, true, 0),\n+            ast::ExprKind::Path(Some(qself), path) => self.print_qpath(path, qself, true),\n+            ast::ExprKind::Break(opt_label, opt_expr) => {\n                 self.word(\"break\");\n                 if let Some(label) = opt_label {\n                     self.space();\n                     self.print_ident(label.ident);\n                 }\n-                if let Some(ref expr) = *opt_expr {\n+                if let Some(expr) = opt_expr {\n                     self.space();\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n@@ -513,45 +505,45 @@ impl<'a> State<'a> {\n                     self.print_ident(label.ident);\n                 }\n             }\n-            ast::ExprKind::Ret(ref result) => {\n+            ast::ExprKind::Ret(result) => {\n                 self.word(\"return\");\n-                if let Some(ref expr) = *result {\n+                if let Some(expr) = result {\n                     self.word(\" \");\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n-            ast::ExprKind::Yeet(ref result) => {\n+            ast::ExprKind::Yeet(result) => {\n                 self.word(\"do\");\n                 self.word(\" \");\n                 self.word(\"yeet\");\n-                if let Some(ref expr) = *result {\n+                if let Some(expr) = result {\n                     self.word(\" \");\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n-            ast::ExprKind::InlineAsm(ref a) => {\n+            ast::ExprKind::InlineAsm(a) => {\n                 self.word(\"asm!\");\n                 self.print_inline_asm(a);\n             }\n-            ast::ExprKind::MacCall(ref m) => self.print_mac(m),\n-            ast::ExprKind::Paren(ref e) => {\n+            ast::ExprKind::MacCall(m) => self.print_mac(m),\n+            ast::ExprKind::Paren(e) => {\n                 self.popen();\n                 self.print_expr(e);\n                 self.pclose();\n             }\n-            ast::ExprKind::Yield(ref e) => {\n+            ast::ExprKind::Yield(e) => {\n                 self.word(\"yield\");\n \n-                if let Some(ref expr) = *e {\n+                if let Some(expr) = e {\n                     self.space();\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n-            ast::ExprKind::Try(ref e) => {\n+            ast::ExprKind::Try(e) => {\n                 self.print_expr_maybe_paren(e, parser::PREC_POSTFIX);\n                 self.word(\"?\")\n             }\n-            ast::ExprKind::TryBlock(ref blk) => {\n+            ast::ExprKind::TryBlock(blk) => {\n                 self.cbox(0);\n                 self.ibox(0);\n                 self.word_nbsp(\"try\");\n@@ -578,15 +570,15 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&arm.attrs);\n         self.print_pat(&arm.pat);\n         self.space();\n-        if let Some(ref e) = arm.guard {\n+        if let Some(e) = &arm.guard {\n             self.word_space(\"if\");\n             self.print_expr(e);\n             self.space();\n         }\n         self.word_space(\"=>\");\n \n-        match arm.body.kind {\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n+        match &arm.body.kind {\n+            ast::ExprKind::Block(blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");"}, {"sha": "e68a7b3f202b3e4238d26675bca20291e5d7df14", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 59, "deletions": 54, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -136,10 +136,10 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n         self.ann.pre(self, AnnNode::Item(item));\n-        match item.kind {\n+        match &item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 self.head(visibility_qualified(&item.vis, \"extern crate\"));\n-                if let Some(orig_name) = orig_name {\n+                if let &Some(orig_name) = orig_name {\n                     self.print_name(orig_name);\n                     self.space();\n                     self.word(\"as\");\n@@ -150,35 +150,41 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            ast::ItemKind::Use(ref tree) => {\n+            ast::ItemKind::Use(tree) => {\n                 self.print_visibility(&item.vis);\n                 self.word_nbsp(\"use\");\n                 self.print_use_tree(tree);\n                 self.word(\";\");\n             }\n-            ast::ItemKind::Static(ref ty, mutbl, ref body) => {\n+            ast::ItemKind::Static(ty, mutbl, body) => {\n                 let def = ast::Defaultness::Final;\n-                self.print_item_const(item.ident, Some(mutbl), ty, body.as_deref(), &item.vis, def);\n+                self.print_item_const(\n+                    item.ident,\n+                    Some(*mutbl),\n+                    ty,\n+                    body.as_deref(),\n+                    &item.vis,\n+                    def,\n+                );\n             }\n-            ast::ItemKind::Const(def, ref ty, ref body) => {\n-                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, def);\n+            ast::ItemKind::Const(def, ty, body) => {\n+                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, *def);\n             }\n-            ast::ItemKind::Fn(box ast::Fn { defaultness, ref sig, ref generics, ref body }) => {\n-                let body = body.as_deref();\n+            ast::ItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n                 self.print_fn_full(\n                     sig,\n                     item.ident,\n                     generics,\n                     &item.vis,\n-                    defaultness,\n-                    body,\n+                    *defaultness,\n+                    body.as_deref(),\n                     &item.attrs,\n                 );\n             }\n-            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n+            ast::ItemKind::Mod(unsafety, mod_kind) => {\n                 self.head(Self::to_string(|s| {\n                     s.print_visibility(&item.vis);\n-                    s.print_unsafety(unsafety);\n+                    s.print_unsafety(*unsafety);\n                     s.word(\"mod\");\n                 }));\n                 self.print_ident(item.ident);\n@@ -201,7 +207,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n             }\n-            ast::ItemKind::ForeignMod(ref nmod) => {\n+            ast::ItemKind::ForeignMod(nmod) => {\n                 self.head(Self::to_string(|s| {\n                     s.print_unsafety(nmod.unsafety);\n                     s.word(\"extern\");\n@@ -215,7 +221,7 @@ impl<'a> State<'a> {\n                 let empty = item.attrs.is_empty() && nmod.items.is_empty();\n                 self.bclose(item.span, empty);\n             }\n-            ast::ItemKind::GlobalAsm(ref asm) => {\n+            ast::ItemKind::GlobalAsm(asm) => {\n                 self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n                 self.print_inline_asm(asm);\n                 self.word(\";\");\n@@ -224,32 +230,31 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::TyAlias(box ast::TyAlias {\n                 defaultness,\n-                ref generics,\n+                generics,\n                 where_clauses,\n                 where_predicates_split,\n-                ref bounds,\n-                ref ty,\n+                bounds,\n+                ty,\n             }) => {\n-                let ty = ty.as_deref();\n                 self.print_associated_type(\n                     item.ident,\n                     generics,\n-                    where_clauses,\n-                    where_predicates_split,\n+                    *where_clauses,\n+                    *where_predicates_split,\n                     bounds,\n-                    ty,\n+                    ty.as_deref(),\n                     &item.vis,\n-                    defaultness,\n+                    *defaultness,\n                 );\n             }\n-            ast::ItemKind::Enum(ref enum_definition, ref params) => {\n+            ast::ItemKind::Enum(enum_definition, params) => {\n                 self.print_enum_def(enum_definition, params, item.ident, item.span, &item.vis);\n             }\n-            ast::ItemKind::Struct(ref struct_def, ref generics) => {\n+            ast::ItemKind::Struct(struct_def, generics) => {\n                 self.head(visibility_qualified(&item.vis, \"struct\"));\n                 self.print_struct(struct_def, generics, item.ident, item.span, true);\n             }\n-            ast::ItemKind::Union(ref struct_def, ref generics) => {\n+            ast::ItemKind::Union(struct_def, generics) => {\n                 self.head(visibility_qualified(&item.vis, \"union\"));\n                 self.print_struct(struct_def, generics, item.ident, item.span, true);\n             }\n@@ -258,15 +263,15 @@ impl<'a> State<'a> {\n                 polarity,\n                 defaultness,\n                 constness,\n-                ref generics,\n-                ref of_trait,\n-                ref self_ty,\n-                ref items,\n+                generics,\n+                of_trait,\n+                self_ty,\n+                items,\n             }) => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n-                self.print_defaultness(defaultness);\n-                self.print_unsafety(unsafety);\n+                self.print_defaultness(*defaultness);\n+                self.print_unsafety(*unsafety);\n                 self.word(\"impl\");\n \n                 if generics.params.is_empty() {\n@@ -276,13 +281,13 @@ impl<'a> State<'a> {\n                     self.space();\n                 }\n \n-                self.print_constness(constness);\n+                self.print_constness(*constness);\n \n                 if let ast::ImplPolarity::Negative(_) = polarity {\n                     self.word(\"!\");\n                 }\n \n-                if let Some(ref t) = *of_trait {\n+                if let Some(t) = of_trait {\n                     self.print_trait_ref(t);\n                     self.space();\n                     self.word_space(\"for\");\n@@ -303,21 +308,21 @@ impl<'a> State<'a> {\n             ast::ItemKind::Trait(box ast::Trait {\n                 is_auto,\n                 unsafety,\n-                ref generics,\n-                ref bounds,\n-                ref items,\n+                generics,\n+                bounds,\n+                items,\n                 ..\n             }) => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n-                self.print_unsafety(unsafety);\n-                self.print_is_auto(is_auto);\n+                self.print_unsafety(*unsafety);\n+                self.print_is_auto(*is_auto);\n                 self.word_nbsp(\"trait\");\n                 self.print_ident(item.ident);\n                 self.print_generic_params(&generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                    if let GenericBound::Trait(ptr, ast::TraitBoundModifier::Maybe) = b {\n                         self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n@@ -339,14 +344,14 @@ impl<'a> State<'a> {\n                 let empty = item.attrs.is_empty() && items.is_empty();\n                 self.bclose(item.span, empty);\n             }\n-            ast::ItemKind::TraitAlias(ref generics, ref bounds) => {\n+            ast::ItemKind::TraitAlias(generics, bounds) => {\n                 self.head(visibility_qualified(&item.vis, \"trait\"));\n                 self.print_ident(item.ident);\n                 self.print_generic_params(&generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 // FIXME(durka) this seems to be some quite outdated syntax\n                 for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                    if let GenericBound::Trait(ptr, ast::TraitBoundModifier::Maybe) = b {\n                         self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n@@ -364,13 +369,13 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            ast::ItemKind::MacCall(ref mac) => {\n+            ast::ItemKind::MacCall(mac) => {\n                 self.print_mac(mac);\n                 if mac.args.need_semicolon() {\n                     self.word(\";\");\n                 }\n             }\n-            ast::ItemKind::MacroDef(ref macro_def) => {\n+            ast::ItemKind::MacroDef(macro_def) => {\n                 self.print_mac_def(macro_def, &item.ident, item.span, |state| {\n                     state.print_visibility(&item.vis)\n                 });\n@@ -412,11 +417,11 @@ impl<'a> State<'a> {\n     }\n \n     pub(crate) fn print_visibility(&mut self, vis: &ast::Visibility) {\n-        match vis.kind {\n+        match &vis.kind {\n             ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n-            ast::VisibilityKind::Restricted { ref path, id: _, shorthand } => {\n+            ast::VisibilityKind::Restricted { path, shorthand, .. } => {\n                 let path = Self::to_string(|s| s.print_path(path, false, 0));\n-                if shorthand && (path == \"crate\" || path == \"self\" || path == \"super\") {\n+                if *shorthand && (path == \"crate\" || path == \"self\" || path == \"super\") {\n                     self.word_nbsp(format!(\"pub({})\", path))\n                 } else {\n                     self.word_nbsp(format!(\"pub(in {})\", path))\n@@ -465,7 +470,7 @@ impl<'a> State<'a> {\n     ) {\n         self.print_ident(ident);\n         self.print_generic_params(&generics.params);\n-        match struct_def {\n+        match &struct_def {\n             ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n                 if let ast::VariantData::Tuple(..) = struct_def {\n                     self.popen();\n@@ -484,7 +489,7 @@ impl<'a> State<'a> {\n                 self.end();\n                 self.end(); // Close the outer-box.\n             }\n-            ast::VariantData::Struct(ref fields, ..) => {\n+            ast::VariantData::Struct(fields, ..) => {\n                 self.print_where_clause(&generics.where_clause);\n                 self.print_record_struct_body(fields, span);\n             }\n@@ -496,7 +501,7 @@ impl<'a> State<'a> {\n         self.print_visibility(&v.vis);\n         let generics = ast::Generics::default();\n         self.print_struct(&v.data, &generics, v.ident, v.span, false);\n-        if let Some(ref d) = v.disr_expr {\n+        if let Some(d) = &v.disr_expr {\n             self.space();\n             self.word_space(\"=\");\n             self.print_expr(&d.value)\n@@ -657,10 +662,10 @@ impl<'a> State<'a> {\n     }\n \n     fn print_use_tree(&mut self, tree: &ast::UseTree) {\n-        match tree.kind {\n-            ast::UseTreeKind::Simple(rename, ..) => {\n+        match &tree.kind {\n+            ast::UseTreeKind::Simple(rename) => {\n                 self.print_path(&tree.prefix, false, 0);\n-                if let Some(rename) = rename {\n+                if let &Some(rename) = rename {\n                     self.nbsp();\n                     self.word_nbsp(\"as\");\n                     self.print_ident(rename);\n@@ -673,7 +678,7 @@ impl<'a> State<'a> {\n                 }\n                 self.word(\"*\");\n             }\n-            ast::UseTreeKind::Nested(ref items) => {\n+            ast::UseTreeKind::Nested(items) => {\n                 if !tree.prefix.segments.is_empty() {\n                     self.print_path(&tree.prefix, false, 0);\n                     self.word(\"::\");"}, {"sha": "13b48d8f89ab4a6eea6f60a986d88369be7235d4", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,7 +1,7 @@\n //! Parsing and validation of builtin attributes\n \n use rustc_ast as ast;\n-use rustc_ast::{Attribute, Lit, LitKind, MetaItem, MetaItemKind, NestedMetaItem, NodeId};\n+use rustc_ast::{Attribute, LitKind, MetaItem, MetaItemKind, MetaItemLit, NestedMetaItem, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n@@ -486,7 +486,7 @@ where\n                                     continue 'outer;\n                                 }\n                             },\n-                            NestedMetaItem::Literal(lit) => {\n+                            NestedMetaItem::Lit(lit) => {\n                                 handle_errors(\n                                     &sess.parse_sess,\n                                     lit.span,\n@@ -658,11 +658,11 @@ pub fn eval_condition(\n         ast::MetaItemKind::List(ref mis) if cfg.name_or_empty() == sym::version => {\n             try_gate_cfg(sym::version, cfg.span, sess, features);\n             let (min_version, span) = match &mis[..] {\n-                [NestedMetaItem::Literal(Lit { kind: LitKind::Str(sym, ..), span, .. })] => {\n+                [NestedMetaItem::Lit(MetaItemLit { kind: LitKind::Str(sym, ..), span, .. })] => {\n                     (sym, span)\n                 }\n                 [\n-                    NestedMetaItem::Literal(Lit { span, .. })\n+                    NestedMetaItem::Lit(MetaItemLit { span, .. })\n                     | NestedMetaItem::MetaItem(MetaItem { span, .. }),\n                 ] => {\n                     sess.emit_err(session_diagnostics::ExpectedVersionLiteral { span: *span });\n@@ -899,7 +899,7 @@ where\n                                 continue 'outer;\n                             }\n                         },\n-                        NestedMetaItem::Literal(lit) => {\n+                        NestedMetaItem::Lit(lit) => {\n                             handle_errors(\n                                 &sess.parse_sess,\n                                 lit.span,"}, {"sha": "91c6bcb08a079db59feaaa82615000fcef6fc0a9", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -41,7 +41,7 @@ pub(crate) struct IncorrectMetaItem {\n     pub span: Span,\n }\n \n-// Error code: E0541\n+/// Error code: E0541\n pub(crate) struct UnknownMetaItem<'a> {\n     pub span: Span,\n     pub item: String,\n@@ -200,7 +200,7 @@ pub(crate) struct InvalidReprHintNoValue {\n     pub name: String,\n }\n \n-// Error code: E0565\n+/// Error code: E0565\n pub(crate) struct UnsupportedLiteral {\n     pub span: Span,\n     pub reason: UnsupportedLiteralReason,"}, {"sha": "e05566dc2c745151833d3523ca1b60d6682f964f", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -291,11 +291,11 @@ where\n         // FIXME(lqd): Unify and de-duplicate the following with the actual\n         // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n         // `ObligationCause`. The normalization results are currently different between\n-        // `AtExt::normalize` used in the query and `normalize` called below: the former fails\n-        // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n-        // after #85499 lands to see if its fixes have erased this difference.\n+        // `QueryNormalizeExt::query_normalize` used in the query and `normalize` called below:\n+        // the former fails to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test.\n+        // Check after #85499 lands to see if its fixes have erased this difference.\n         let (param_env, value) = key.into_parts();\n-        let _ = ocx.normalize(cause, param_env, value.value);\n+        let _ = ocx.normalize(&cause, param_env, value.value);\n \n         try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }"}, {"sha": "d221da5c17ed0bd31d20d107933e548b89df2744", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -732,13 +732,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         // Try to find predicates on *generic params* that would allow copying `ty`\n         let infcx = tcx.infer_ctxt().build();\n-        if infcx\n-            .type_implements_trait(\n-                tcx.lang_items().clone_trait().unwrap(),\n-                [tcx.erase_regions(ty)],\n-                self.param_env,\n-            )\n-            .must_apply_modulo_regions()\n+\n+        if let Some(clone_trait_def) = tcx.lang_items().clone_trait()\n+            && infcx\n+                .type_implements_trait(\n+                    clone_trait_def,\n+                    [tcx.erase_regions(ty)],\n+                    self.param_env,\n+                )\n+                .must_apply_modulo_regions()\n         {\n             err.span_suggestion_verbose(\n                 span.shrink_to_hi(),"}, {"sha": "86c5d9cfa8121c6885338bd6e0e8765795c151bf", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -590,7 +590,7 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    // Add a span label to the arguments of the closure, if it exists.\n+    /// Add a span label to the arguments of the closure, if it exists.\n     pub(super) fn args_span_label(self, err: &mut Diagnostic, message: impl Into<String>) {\n         if let UseSpans::ClosureUse { args_span, .. } = self {\n             err.span_label(args_span, message);\n@@ -628,7 +628,7 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    // Add a span label to the use of the captured variable, if it exists.\n+    /// Add a span label to the use of the captured variable, if it exists.\n     pub(super) fn var_span_label(\n         self,\n         err: &mut Diagnostic,"}, {"sha": "7aa099433a76d902145decf600c3fac97be5ded7", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -514,12 +514,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             span: *span,\n             ty_err: match output_ty.kind() {\n                 ty::Closure(_, _) => FnMutReturnTypeErr::ReturnClosure { span: *span },\n-                ty::Generator(def, ..)\n-                    if matches!(\n-                        self.infcx.tcx.generator_kind(def),\n-                        Some(hir::GeneratorKind::Async(_))\n-                    ) =>\n-                {\n+                ty::Generator(def, ..) if self.infcx.tcx.generator_is_async(*def) => {\n                     FnMutReturnTypeErr::ReturnAsyncBlock { span: *span }\n                 }\n                 _ => FnMutReturnTypeErr::ReturnRef { span: *span },"}, {"sha": "4d87ecf5e44be224f7a692e233bac2b472d56d51", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -83,7 +83,7 @@ mod type_check;\n mod universal_regions;\n mod used_muts;\n \n-// A public API provided for the Rust compiler consumers.\n+/// A public API provided for the Rust compiler consumers.\n pub mod consumers;\n \n use borrow_set::{BorrowData, BorrowSet};"}, {"sha": "90e2b6b698cf832ec4a2d45e266e173369a3062f", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1705,29 +1705,29 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         });\n     }\n \n+    #[instrument(level = \"debug\", skip(self, infcx, errors_buffer))]\n     fn check_member_constraints(\n         &self,\n         infcx: &InferCtxt<'tcx>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n         let member_constraints = self.member_constraints.clone();\n         for m_c_i in member_constraints.all_indices() {\n-            debug!(\"check_member_constraint(m_c_i={:?})\", m_c_i);\n+            debug!(?m_c_i);\n             let m_c = &member_constraints[m_c_i];\n             let member_region_vid = m_c.member_region_vid;\n             debug!(\n-                \"check_member_constraint: member_region_vid={:?} with value {}\",\n-                member_region_vid,\n-                self.region_value_str(member_region_vid),\n+                ?member_region_vid,\n+                value = ?self.region_value_str(member_region_vid),\n             );\n             let choice_regions = member_constraints.choice_regions(m_c_i);\n-            debug!(\"check_member_constraint: choice_regions={:?}\", choice_regions);\n+            debug!(?choice_regions);\n \n             // Did the member region wind up equal to any of the option regions?\n             if let Some(o) =\n                 choice_regions.iter().find(|&&o_r| self.eval_equal(o_r, m_c.member_region_vid))\n             {\n-                debug!(\"check_member_constraint: evaluated as equal to {:?}\", o);\n+                debug!(\"evaluated as equal to {:?}\", o);\n                 continue;\n             }\n "}, {"sha": "b344ab46adbde37ba6f064beb3dc68bf2e8bfa83", "filename": "compiler/rustc_borrowck/src/type_check/liveness/polonius.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -121,8 +121,8 @@ pub(super) fn populate_access_facts<'a, 'tcx>(\n     }\n }\n \n-// For every potentially drop()-touched region `region` in `local`'s type\n-// (`kind`), emit a Polonius `use_of_var_derefs_origin(local, origin)` fact.\n+/// For every potentially drop()-touched region `region` in `local`'s type\n+/// (`kind`), emit a Polonius `use_of_var_derefs_origin(local, origin)` fact.\n pub(super) fn add_drop_of_var_derefs_origin<'tcx>(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n     local: Local,"}, {"sha": "460175ed2ac84bb35abb7d29181ac418ecb5cd61", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -95,9 +95,7 @@ fn generate_handler(cx: &ExtCtxt<'_>, handler: Ident, span: Span, sig_span: Span\n         body,\n     }));\n \n-    let special = sym::rustc_std_internal_symbol;\n-    let special = cx.meta_word(span, special);\n-    let attrs = thin_vec![cx.attribute(special)];\n+    let attrs = thin_vec![cx.attr_word(sym::rustc_std_internal_symbol, span)];\n \n     let item = cx.item(span, Ident::from_str_and_span(\"__rg_oom\", span), attrs, kind);\n     cx.stmt_item(sig_span, item)"}, {"sha": "d82bc0453f5722c0912c4a9463dcf461daf941ec", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,5 +1,4 @@\n use rustc_ast::{\n-    attr,\n     ptr::P,\n     token,\n     tokenstream::{DelimSpan, TokenStream, TokenTree},\n@@ -107,7 +106,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             (\n                 UseTree {\n                     prefix: this.cx.path(this.span, vec![Ident::with_dummy_span(sym)]),\n-                    kind: UseTreeKind::Simple(None, DUMMY_NODE_ID, DUMMY_NODE_ID),\n+                    kind: UseTreeKind::Simple(None),\n                     span: this.span,\n                 },\n                 DUMMY_NODE_ID,\n@@ -118,10 +117,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             self.cx.item(\n                 self.span,\n                 Ident::empty(),\n-                thin_vec![self.cx.attribute(attr::mk_list_item(\n-                    Ident::new(sym::allow, self.span),\n-                    vec![attr::mk_nested_word_item(Ident::new(sym::unused_imports, self.span))],\n-                ))],\n+                thin_vec![self.cx.attr_nested_word(sym::allow, sym::unused_imports, self.span)],\n                 ItemKind::Use(UseTree {\n                     prefix: self.cx.path(self.span, self.cx.std_path(&[sym::asserting])),\n                     kind: UseTreeKind::Nested(vec!["}, {"sha": "4e4cafc71823aef1ed384ff4e76de0efad11c815", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -37,10 +37,10 @@ impl MultiItemModifier for Expander {\n         _is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let template = AttributeTemplate { list: Some(\"path\"), ..Default::default() };\n-        let attr = &ecx.attribute(meta_item.clone());\n-        validate_attr::check_builtin_attribute(\n+        validate_attr::check_builtin_meta_item(\n             &ecx.sess.parse_sess,\n-            attr,\n+            &meta_item,\n+            ast::AttrStyle::Outer,\n             sym::cfg_accessible,\n             template,\n         );"}, {"sha": "161e3499584e24cb54b5fa206d1cc02a06332d68", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2,6 +2,7 @@ use rustc_ast as ast;\n use rustc_ast::{ptr::P, tokenstream::TokenStream};\n use rustc_errors::Applicability;\n use rustc_expand::base::{self, DummyResult};\n+use rustc_session::errors::report_lit_error;\n use rustc_span::Span;\n \n /// Emits errors for literal expressions that are invalid inside and outside of an array.\n@@ -68,7 +69,10 @@ fn invalid_type_err(\n         Ok(ast::LitKind::Int(_, _)) => {\n             cx.span_err(span, \"numeric literal is not a `u8`\");\n         }\n-        _ => unreachable!(),\n+        Ok(ast::LitKind::ByteStr(_) | ast::LitKind::Byte(_)) => unreachable!(),\n+        Err(err) => {\n+            report_lit_error(&cx.sess.parse_sess, err, token_lit, span);\n+        }\n     }\n }\n "}, {"sha": "fa5a45730ac7afd8379eb696f2ef7098df42d389", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,7 +1,7 @@\n use crate::cfg_eval::cfg_eval;\n \n use rustc_ast as ast;\n-use rustc_ast::{attr, token, GenericParamKind, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n+use rustc_ast::{token, GenericParamKind, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n@@ -33,34 +33,36 @@ impl MultiItemModifier for Expander {\n             ecx.resolver.resolve_derives(ecx.current_expansion.id, ecx.force_mode, &|| {\n                 let template =\n                     AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n-                let attr =\n-                    attr::mk_attr_outer(&sess.parse_sess.attr_id_generator, meta_item.clone());\n-                validate_attr::check_builtin_attribute(\n+                validate_attr::check_builtin_meta_item(\n                     &sess.parse_sess,\n-                    &attr,\n+                    &meta_item,\n+                    ast::AttrStyle::Outer,\n                     sym::derive,\n                     template,\n                 );\n \n-                let mut resolutions: Vec<_> = attr\n-                    .meta_item_list()\n-                    .unwrap_or_default()\n-                    .into_iter()\n-                    .filter_map(|nested_meta| match nested_meta {\n-                        NestedMetaItem::MetaItem(meta) => Some(meta),\n-                        NestedMetaItem::Literal(lit) => {\n-                            // Reject `#[derive(\"Debug\")]`.\n-                            report_unexpected_literal(sess, &lit);\n-                            None\n-                        }\n-                    })\n-                    .map(|meta| {\n-                        // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the paths.\n-                        report_path_args(sess, &meta);\n-                        meta.path\n-                    })\n-                    .map(|path| (path, dummy_annotatable(), None, self.0))\n-                    .collect();\n+                let mut resolutions = match &meta_item.kind {\n+                    MetaItemKind::List(list) => {\n+                        list.iter()\n+                            .filter_map(|nested_meta| match nested_meta {\n+                                NestedMetaItem::MetaItem(meta) => Some(meta),\n+                                NestedMetaItem::Lit(lit) => {\n+                                    // Reject `#[derive(\"Debug\")]`.\n+                                    report_unexpected_meta_item_lit(sess, &lit);\n+                                    None\n+                                }\n+                            })\n+                            .map(|meta| {\n+                                // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the\n+                                // paths.\n+                                report_path_args(sess, &meta);\n+                                meta.path.clone()\n+                            })\n+                            .map(|path| (path, dummy_annotatable(), None, self.0))\n+                            .collect()\n+                    }\n+                    _ => vec![],\n+                };\n \n                 // Do not configure or clone items unless necessary.\n                 match &mut resolutions[..] {\n@@ -127,7 +129,7 @@ fn report_bad_target(sess: &Session, item: &Annotatable, span: Span) -> bool {\n     bad_target\n }\n \n-fn report_unexpected_literal(sess: &Session, lit: &ast::Lit) {\n+fn report_unexpected_meta_item_lit(sess: &Session, lit: &ast::MetaItemLit) {\n     let help_msg = match lit.token_lit.kind {\n         token::Str if rustc_lexer::is_ident(lit.token_lit.symbol.as_str()) => {\n             format!(\"try using `#[derive({})]`\", lit.token_lit.symbol)"}, {"sha": "23b96d4176d3a27391d2d5d80491eae91b2b719e", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -68,8 +68,7 @@ pub fn expand_deriving_clone(\n         _ => cx.span_bug(span, \"`#[derive(Clone)]` on trait item or impl item\"),\n     }\n \n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(clone::Clone),"}, {"sha": "f861d47ed408e45fc02ecc6e7c75f76357d47a83", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -5,7 +5,7 @@ use crate::deriving::path_std;\n use rustc_ast::{self as ast, MetaItem};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n use thin_vec::thin_vec;\n \n@@ -18,11 +18,11 @@ pub fn expand_deriving_eq(\n     is_const: bool,\n ) {\n     let span = cx.with_def_site_ctxt(span);\n-    let inline = cx.meta_word(span, sym::inline);\n-    let hidden = rustc_ast::attr::mk_nested_word_item(Ident::new(sym::hidden, span));\n-    let doc = rustc_ast::attr::mk_list_item(Ident::new(sym::doc, span), vec![hidden]);\n-    let no_coverage = cx.meta_word(span, sym::no_coverage);\n-    let attrs = thin_vec![cx.attribute(inline), cx.attribute(doc), cx.attribute(no_coverage)];\n+    let attrs = thin_vec![\n+        cx.attr_word(sym::inline, span),\n+        cx.attr_nested_word(sym::doc, sym::hidden, span),\n+        cx.attr_word(sym::no_coverage, span)\n+    ];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Eq),"}, {"sha": "96d18c7afb924c56a6fb6d949a414cbfead310ae", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -15,8 +15,7 @@ pub fn expand_deriving_ord(\n     push: &mut dyn FnMut(Annotatable),\n     is_const: bool,\n ) {\n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Ord),"}, {"sha": "7f95551fc483a6bd69c4386a30191617581ec77e", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -68,8 +68,7 @@ pub fn expand_deriving_partial_eq(\n \n     // No need to generate `ne`, the default suffices, and not generating it is\n     // faster.\n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let methods = vec![MethodDef {\n         name: sym::eq,\n         generics: Bounds::empty(),"}, {"sha": "5c4e5b7f8167500c1fd16a51b43d2a099e6548f5", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -19,8 +19,7 @@ pub fn expand_deriving_partial_ord(\n     let ret_ty =\n         Path(Path::new_(pathvec_std!(option::Option), vec![Box::new(ordering_ty)], PathKind::Std));\n \n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n \n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,"}, {"sha": "e88d2e409c63b0c95e1e900a7bac12d5e14c4081", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -20,8 +20,7 @@ pub fn expand_deriving_default(\n ) {\n     item.visit_with(&mut DetectNonVariantDefaultAttr { cx });\n \n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let trait_def = TraitDef {\n         span,\n         path: Path::new(vec![kw::Default, sym::Default]),\n@@ -146,7 +145,7 @@ fn extract_default_variant<'a>(\n                 let suggestion = default_variants\n                     .iter()\n                     .filter_map(|v| {\n-                        if v.ident == variant.ident {\n+                        if v.span == variant.span {\n                             None\n                         } else {\n                             Some((cx.sess.find_by_name(&v.attrs, kw::Default)?.span, String::new()))"}, {"sha": "7fcaf0b436b9079742bd0261455ae0d613b9ad2f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -300,12 +300,12 @@ struct TypeParameter {\n     ty: P<ast::Ty>,\n }\n \n-// The code snippets built up for derived code are sometimes used as blocks\n-// (e.g. in a function body) and sometimes used as expressions (e.g. in a match\n-// arm). This structure avoids committing to either form until necessary,\n-// avoiding the insertion of any unnecessary blocks.\n-//\n-// The statements come before the expression.\n+/// The code snippets built up for derived code are sometimes used as blocks\n+/// (e.g. in a function body) and sometimes used as expressions (e.g. in a match\n+/// arm). This structure avoids committing to either form until necessary,\n+/// avoiding the insertion of any unnecessary blocks.\n+///\n+/// The statements come before the expression.\n pub struct BlockOrExpr(Vec<ast::Stmt>, Option<P<Expr>>);\n \n impl BlockOrExpr {\n@@ -718,7 +718,7 @@ impl<'a> TraitDef<'a> {\n         let path = cx.path_all(self.span, false, vec![type_ident], self_params);\n         let self_type = cx.ty_path(path);\n \n-        let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n+        let attr = cx.attr_word(sym::automatically_derived, self.span);\n         let attrs = thin_vec![attr];\n         let opt_trait_ref = Some(trait_ref);\n "}, {"sha": "13fdd4fa68c43cd1e70c3683c6ed6db7a5cd7e12", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -188,7 +188,7 @@ fn inject_impl_of_structural_trait(\n             .cloned(),\n     );\n     // Mark as `automatically_derived` to avoid some silly lints.\n-    attrs.push(cx.attribute(cx.meta_word(span, sym::automatically_derived)));\n+    attrs.push(cx.attr_word(sym::automatically_derived, span));\n \n     let newitem = cx.item(\n         span,"}, {"sha": "b2a21611db7f9833088b5da57f76bfc4947a6c38", "filename": "compiler/rustc_builtin_macros/src/edition_panic.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -6,15 +6,15 @@ use rustc_span::edition::Edition;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n-// This expands to either\n-// - `$crate::panic::panic_2015!(...)` or\n-// - `$crate::panic::panic_2021!(...)`\n-// depending on the edition.\n-//\n-// This is used for both std::panic!() and core::panic!().\n-//\n-// `$crate` will refer to either the `std` or `core` crate depending on which\n-// one we're expanding from.\n+/// This expands to either\n+/// - `$crate::panic::panic_2015!(...)` or\n+/// - `$crate::panic::panic_2021!(...)`\n+/// depending on the edition.\n+///\n+/// This is used for both std::panic!() and core::panic!().\n+///\n+/// `$crate` will refer to either the `std` or `core` crate depending on which\n+/// one we're expanding from.\n pub fn expand_panic<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n@@ -24,10 +24,10 @@ pub fn expand_panic<'cx>(\n     expand(mac, cx, sp, tts)\n }\n \n-// This expands to either\n-// - `$crate::panic::unreachable_2015!(...)` or\n-// - `$crate::panic::unreachable_2021!(...)`\n-// depending on the edition.\n+/// This expands to either\n+/// - `$crate::panic::unreachable_2015!(...)` or\n+/// - `$crate::panic::unreachable_2021!(...)`\n+/// depending on the edition.\n pub fn expand_unreachable<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,"}, {"sha": "0817aed037ef814aab672a3f132da1b57f2c865b", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -115,9 +115,7 @@ impl AllocFnFactory<'_, '_> {\n     }\n \n     fn attrs(&self) -> AttrVec {\n-        let special = sym::rustc_std_internal_symbol;\n-        let special = self.cx.meta_word(self.span, special);\n-        thin_vec![self.cx.attribute(special)]\n+        thin_vec![self.cx.attr_word(sym::rustc_std_internal_symbol, self.span)]\n     }\n \n     fn arg_ty("}, {"sha": "75cfac723848502729b868cc6bdb96f2018252af", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -45,6 +45,7 @@ mod log_syntax;\n mod source_util;\n mod test;\n mod trace_macros;\n+mod type_ascribe;\n mod util;\n \n pub mod asm;\n@@ -92,6 +93,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n         unreachable: edition_panic::expand_unreachable,\n         stringify: source_util::expand_stringify,\n         trace_macros: trace_macros::expand_trace_macros,\n+        type_ascribe: type_ascribe::expand_type_ascribe,\n     }\n \n     register_attr! {"}, {"sha": "ece660cf6f64506fd55ce481e369efcf0e98f6c8", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,6 +1,3 @@\n-use std::mem;\n-\n-use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, NodeId};\n@@ -13,6 +10,7 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::smallvec;\n+use std::mem;\n \n struct ProcMacroDerive {\n     id: NodeId,\n@@ -365,14 +363,8 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n             cx.expr_array_ref(span, decls),\n         )\n         .map(|mut i| {\n-            let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);\n-            i.attrs.push(cx.attribute(attr));\n-\n-            let deprecated_attr = attr::mk_nested_word_item(Ident::new(sym::deprecated, span));\n-            let allow_deprecated_attr =\n-                attr::mk_list_item(Ident::new(sym::allow, span), vec![deprecated_attr]);\n-            i.attrs.push(cx.attribute(allow_deprecated_attr));\n-\n+            i.attrs.push(cx.attr_word(sym::rustc_proc_macro_decls, span));\n+            i.attrs.push(cx.attr_nested_word(sym::allow, sym::deprecated, span));\n             i\n         });\n "}, {"sha": "0b17e92efe936d94a3dfeaa334a09ac0d49a4e7f", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -164,7 +164,7 @@ pub fn expand_include<'cx>(\n     Box::new(ExpandResult { p, node_id: cx.current_expansion.lint_node_id })\n }\n \n-// include_str! : read the given file, insert it as a literal string expr\n+/// `include_str!`: read the given file, insert it as a literal string expr\n pub fn expand_include_str(\n     cx: &mut ExtCtxt<'_>,\n     sp: Span,"}, {"sha": "f73f20c84a39d145911dbff56883d1dca807e565", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -52,7 +52,7 @@ pub fn inject(\n             cx.item(\n                 span,\n                 ident,\n-                thin_vec![cx.attribute(cx.meta_word(span, sym::macro_use))],\n+                thin_vec![cx.attr_word(sym::macro_use, span)],\n                 ast::ItemKind::ExternCrate(None),\n             ),\n         );\n@@ -79,7 +79,7 @@ pub fn inject(\n     let use_item = cx.item(\n         span,\n         Ident::empty(),\n-        thin_vec![cx.attribute(cx.meta_word(span, sym::prelude_import))],\n+        thin_vec![cx.attr_word(sym::prelude_import, span)],\n         ast::ItemKind::Use(ast::UseTree {\n             prefix: cx.path(span, import_path),\n             kind: ast::UseTreeKind::Glob,"}, {"sha": "3bcb60478efbc58db96665ce497c42373806fac3", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2,7 +2,6 @@\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n use crate::util::{check_builtin_macro_attribute, warn_on_duplicate_attribute};\n use rustc_ast as ast;\n-use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast_pretty::pprust;\n use rustc_errors::Applicability;\n@@ -13,13 +12,13 @@ use rustc_span::Span;\n use std::iter;\n use thin_vec::thin_vec;\n \n-// #[test_case] is used by custom test authors to mark tests\n-// When building for test, it needs to make the item public and gensym the name\n-// Otherwise, we'll omit the item. This behavior means that any item annotated\n-// with #[test_case] is never addressable.\n-//\n-// We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n-// logic will pick up on.\n+/// #[test_case] is used by custom test authors to mark tests\n+/// When building for test, it needs to make the item public and gensym the name\n+/// Otherwise, we'll omit the item. This behavior means that any item annotated\n+/// with #[test_case] is never addressable.\n+///\n+/// We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n+/// logic will pick up on.\n pub fn expand_test_case(\n     ecx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n@@ -47,11 +46,7 @@ pub fn expand_test_case(\n             tokens: None,\n         };\n         item.ident.span = item.ident.span.with_ctxt(sp.ctxt());\n-        item.attrs.push(ecx.attribute(attr::mk_name_value_item_str(\n-            Ident::new(sym::rustc_test_marker, sp),\n-            test_path_symbol,\n-            sp,\n-        )));\n+        item.attrs.push(ecx.attr_name_value_str(sym::rustc_test_marker, test_path_symbol, sp));\n         item\n     });\n \n@@ -241,16 +236,9 @@ pub fn expand_test_or_bench(\n         Ident::new(item.ident.name, sp),\n         thin_vec![\n             // #[cfg(test)]\n-            cx.attribute(attr::mk_list_item(\n-                Ident::new(sym::cfg, attr_sp),\n-                vec![attr::mk_nested_word_item(Ident::new(sym::test, attr_sp))],\n-            )),\n+            cx.attr_nested_word(sym::cfg, sym::test, attr_sp),\n             // #[rustc_test_marker = \"test_case_sort_key\"]\n-            cx.attribute(attr::mk_name_value_item_str(\n-                Ident::new(sym::rustc_test_marker, attr_sp),\n-                test_path_symbol,\n-                attr_sp,\n-            )),\n+            cx.attr_name_value_str(sym::rustc_test_marker, test_path_symbol, attr_sp),\n         ]\n         .into(),\n         // const $ident: test::TestDescAndFn ="}, {"sha": "b5bce9278a907311d22e90493dba96dff9aee7b2", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -34,8 +34,8 @@ struct TestCtxt<'a> {\n     test_runner: Option<ast::Path>,\n }\n \n-// Traverse the crate, collecting all the test functions, eliding any\n-// existing main functions, and synthesizing a main test harness\n+/// Traverse the crate, collecting all the test functions, eliding any\n+/// existing main functions, and synthesizing a main test harness\n pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast::Crate) {\n     let span_diagnostic = sess.diagnostic();\n     let panic_strategy = sess.panic_strategy();\n@@ -185,13 +185,12 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n         let item = match entry_point_type(self.sess, &item, self.depth) {\n             EntryPointType::MainNamed | EntryPointType::RustcMainAttr | EntryPointType::Start => {\n                 item.map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n-                    let allow_ident = Ident::new(sym::allow, self.def_site);\n-                    let dc_nested =\n-                        attr::mk_nested_word_item(Ident::new(sym::dead_code, self.def_site));\n-                    let allow_dead_code_item = attr::mk_list_item(allow_ident, vec![dc_nested]);\n-                    let allow_dead_code = attr::mk_attr_outer(\n+                    let allow_dead_code = attr::mk_attr_nested_word(\n                         &self.sess.parse_sess.attr_id_generator,\n-                        allow_dead_code_item,\n+                        ast::AttrStyle::Outer,\n+                        sym::allow,\n+                        sym::dead_code,\n+                        self.def_site,\n                     );\n                     let attrs = attrs\n                         .into_iter()\n@@ -309,8 +308,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     );\n \n     // #[rustc_main]\n-    let main_meta = ecx.meta_word(sp, sym::rustc_main);\n-    let main_attr = ecx.attribute(main_meta);\n+    let main_attr = ecx.attr_word(sym::rustc_main, sp);\n \n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));"}, {"sha": "72b85af1486384f61f5c2651ac40d054002020d1", "filename": "compiler/rustc_builtin_macros/src/type_ascribe.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Ftype_ascribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Ftype_ascribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftype_ascribe.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -0,0 +1,35 @@\n+use rustc_ast::ptr::P;\n+use rustc_ast::tokenstream::TokenStream;\n+use rustc_ast::{token, Expr, ExprKind, Ty};\n+use rustc_errors::PResult;\n+use rustc_expand::base::{self, DummyResult, ExtCtxt, MacEager};\n+use rustc_span::Span;\n+\n+pub fn expand_type_ascribe(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    tts: TokenStream,\n+) -> Box<dyn base::MacResult + 'static> {\n+    let (expr, ty) = match parse_ascribe(cx, tts) {\n+        Ok(parsed) => parsed,\n+        Err(mut err) => {\n+            err.emit();\n+            return DummyResult::any(span);\n+        }\n+    };\n+\n+    let asc_expr = cx.expr(span, ExprKind::Type(expr, ty));\n+\n+    return MacEager::expr(asc_expr);\n+}\n+\n+fn parse_ascribe<'a>(cx: &mut ExtCtxt<'a>, stream: TokenStream) -> PResult<'a, (P<Expr>, P<Ty>)> {\n+    let mut parser = cx.new_parser_from_tts(stream);\n+\n+    let expr = parser.parse_expr()?;\n+    parser.expect(&token::Comma)?;\n+\n+    let ty = parser.parse_ty()?;\n+\n+    Ok((expr, ty))\n+}"}, {"sha": "83812631c2ff729067e39df9480dc9a0916502eb", "filename": "compiler/rustc_builtin_macros/src/util.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::{Attribute, MetaItem};\n+use rustc_ast::{AttrStyle, Attribute, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_feature::AttributeTemplate;\n use rustc_lint_defs::builtin::DUPLICATE_MACRO_ATTRIBUTES;\n@@ -8,8 +8,13 @@ use rustc_span::Symbol;\n pub fn check_builtin_macro_attribute(ecx: &ExtCtxt<'_>, meta_item: &MetaItem, name: Symbol) {\n     // All the built-in macro attributes are \"words\" at the moment.\n     let template = AttributeTemplate { word: true, ..Default::default() };\n-    let attr = ecx.attribute(meta_item.clone());\n-    validate_attr::check_builtin_attribute(&ecx.sess.parse_sess, &attr, name, template);\n+    validate_attr::check_builtin_meta_item(\n+        &ecx.sess.parse_sess,\n+        &meta_item,\n+        AttrStyle::Outer,\n+        name,\n+        template,\n+    );\n }\n \n /// Emit a warning if the item is annotated with the given attribute. This is used to diagnose when"}, {"sha": "34746ff6b6645c11bdda409d0af1f627908e65a0", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -108,8 +108,8 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     // FIXME remove\n-    // Forces the data value of a dyn* value to the stack and returns a pointer to it as well as the\n-    // vtable pointer.\n+    /// Forces the data value of a dyn* value to the stack and returns a pointer to it as well as the\n+    /// vtable pointer.\n     pub(crate) fn dyn_star_force_data_on_stack(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}, {"sha": "fd01fcf1fc82c071e954c87da03120df72d26a67", "filename": "compiler/rustc_codegen_gcc/example/alloc_system.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -13,17 +13,17 @@\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values.\n-#[cfg(all(any(target_arch = \"x86\",\n+#[cfg(any(target_arch = \"x86\",\n               target_arch = \"arm\",\n               target_arch = \"mips\",\n               target_arch = \"powerpc\",\n-              target_arch = \"powerpc64\")))]\n+              target_arch = \"powerpc64\"))]\n const MIN_ALIGN: usize = 8;\n-#[cfg(all(any(target_arch = \"x86_64\",\n+#[cfg(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\",\n               target_arch = \"mips64\",\n               target_arch = \"s390x\",\n-              target_arch = \"sparc64\")))]\n+              target_arch = \"sparc64\"))]\n const MIN_ALIGN: usize = 16;\n \n pub struct System;"}, {"sha": "837708aeb0ea9a42aa4a36aced6b7a19a40bddd3", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -88,9 +88,9 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n     // TODO(antoyo): improve the SSA API to not require those.\n-    // Mapping from function pointer type to indexes of on stack parameters.\n+    /// Mapping from function pointer type to indexes of on stack parameters.\n     pub on_stack_params: RefCell<FxHashMap<FunctionPtrType<'gcc>, FxHashSet<usize>>>,\n-    // Mapping from function to indexes of on stack parameters.\n+    /// Mapping from function to indexes of on stack parameters.\n     pub on_stack_function_params: RefCell<FxHashMap<Function<'gcc>, FxHashSet<usize>>>,\n \n     /// Cache of emitted const globals (value -> global)"}, {"sha": "3c324359565c1081699b70ea2e432b23322ced98", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -295,8 +295,18 @@ impl<'ll> CodegenCx<'ll, '_> {\n             llvm::set_thread_local_mode(g, self.tls_model);\n         }\n \n+        let dso_local = unsafe { self.should_assume_dso_local(g, true) };\n+        if dso_local {\n+            unsafe {\n+                llvm::LLVMRustSetDSOLocal(g, true);\n+            }\n+        }\n+\n         if !def_id.is_local() {\n             let needs_dll_storage_attr = self.use_dll_storage_attrs && !self.tcx.is_foreign_item(def_id) &&\n+                // Local definitions can never be imported, so we must not apply\n+                // the DLLImport annotation.\n+                !dso_local &&\n                 // ThinLTO can't handle this workaround in all cases, so we don't\n                 // emit the attrs. Instead we make them unnecessary by disallowing\n                 // dynamic linking when linker plugin based LTO is enabled.\n@@ -340,12 +350,6 @@ impl<'ll> CodegenCx<'ll, '_> {\n             }\n         }\n \n-        unsafe {\n-            if self.should_assume_dso_local(g, true) {\n-                llvm::LLVMRustSetDSOLocal(g, true);\n-            }\n-        }\n-\n         self.instances.borrow_mut().insert(instance, g);\n         g\n     }"}, {"sha": "ace15cfb024775d285510d9f3a035910bc4b0140", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -37,7 +37,7 @@ const VAR_ALIGN_BYTES: usize = 8;\n \n /// A context object for maintaining all state needed by the coverageinfo module.\n pub struct CrateCoverageContext<'ll, 'tcx> {\n-    // Coverage data for each instrumented function identified by DefId.\n+    /// Coverage data for each instrumented function identified by DefId.\n     pub(crate) function_coverage_map: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverage<'tcx>>>,\n     pub(crate) pgo_func_name_var_map: RefCell<FxHashMap<Instance<'tcx>, &'ll llvm::Value>>,\n }"}, {"sha": "c14e1656291e87710f422f5abee59bb1eb13a072", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -35,7 +35,7 @@ pub enum LLVMRustResult {\n pub struct LLVMRustCOFFShortExport {\n     pub name: *const c_char,\n     pub ordinal_present: bool,\n-    // value of `ordinal` only important when `ordinal_present` is true\n+    /// value of `ordinal` only important when `ordinal_present` is true\n     pub ordinal: u16,\n }\n "}, {"sha": "c9f5dd0f2c68b86e3b13d4ac911fe8f1cf5edf44", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -194,8 +194,8 @@ pub fn to_llvm_features<'a>(sess: &Session, s: &'a str) -> SmallVec<[&'a str; 2]\n     }\n }\n \n-// Given a map from target_features to whether they are enabled or disabled,\n-// ensure only valid combinations are allowed.\n+/// Given a map from target_features to whether they are enabled or disabled,\n+/// ensure only valid combinations are allowed.\n pub fn check_tied_features(\n     sess: &Session,\n     features: &FxHashMap<&str, bool>,\n@@ -213,8 +213,8 @@ pub fn check_tied_features(\n     return None;\n }\n \n-// Used to generate cfg variables and apply features\n-// Must express features in the way Rust understands them\n+/// Used to generate cfg variables and apply features\n+/// Must express features in the way Rust understands them\n pub fn target_features(sess: &Session, allow_unstable: bool) -> Vec<Symbol> {\n     let target_machine = create_informational_target_machine(sess);\n     let mut features: Vec<Symbol> = supported_target_features(sess)\n@@ -292,30 +292,33 @@ fn llvm_target_features(tm: &llvm::TargetMachine) -> Vec<(&str, &str)> {\n }\n \n fn print_target_features(sess: &Session, tm: &llvm::TargetMachine) {\n-    let mut target_features = llvm_target_features(tm);\n+    let mut llvm_target_features = llvm_target_features(tm);\n+    let mut known_llvm_target_features = FxHashSet::<&'static str>::default();\n     let mut rustc_target_features = supported_target_features(sess)\n         .iter()\n-        .filter_map(|(feature, _gate)| {\n-            for llvm_feature in to_llvm_features(sess, *feature) {\n+        .map(|(feature, _gate)| {\n+            let desc = if let Some(llvm_feature) = to_llvm_features(sess, *feature).first() {\n                 // LLVM asserts that these are sorted. LLVM and Rust both use byte comparison for these strings.\n-                match target_features.binary_search_by_key(&llvm_feature, |(f, _d)| f).ok().map(\n-                    |index| {\n-                        let (_f, desc) = target_features.remove(index);\n-                        (*feature, desc)\n-                    },\n-                ) {\n-                    Some(v) => return Some(v),\n-                    None => {}\n+                match llvm_target_features.binary_search_by_key(&llvm_feature, |(f, _d)| f).ok() {\n+                    Some(index) => {\n+                        known_llvm_target_features.insert(llvm_feature);\n+                        llvm_target_features[index].1\n+                    }\n+                    None => \"\",\n                 }\n-            }\n-            None\n+            } else {\n+                \"\"\n+            };\n+            (*feature, desc)\n         })\n         .collect::<Vec<_>>();\n     rustc_target_features.extend_from_slice(&[(\n         \"crt-static\",\n         \"Enables C Run-time Libraries to be statically linked\",\n     )]);\n-    let max_feature_len = target_features\n+    llvm_target_features.retain(|(f, _d)| !known_llvm_target_features.contains(f));\n+\n+    let max_feature_len = llvm_target_features\n         .iter()\n         .chain(rustc_target_features.iter())\n         .map(|(feature, _desc)| feature.len())\n@@ -327,10 +330,10 @@ fn print_target_features(sess: &Session, tm: &llvm::TargetMachine) {\n         println!(\"    {1:0$} - {2}.\", max_feature_len, feature, desc);\n     }\n     println!(\"\\nCode-generation features supported by LLVM for this target:\");\n-    for (feature, desc) in &target_features {\n+    for (feature, desc) in &llvm_target_features {\n         println!(\"    {1:0$} - {2}.\", max_feature_len, feature, desc);\n     }\n-    if target_features.is_empty() {\n+    if llvm_target_features.is_empty() {\n         println!(\"    Target features listing is not supported by this LLVM version.\");\n     }\n     println!(\"\\nUse +feature to enable a feature, or -feature to disable it.\");"}, {"sha": "5772b7e1d812afa3c2566ecb3fd31e042e078f80", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -238,7 +238,7 @@ impl Type {\n         unsafe { llvm::LLVMInt8TypeInContext(llcx) }\n     }\n \n-    // Creates an integer type with the given number of bits, e.g., i24\n+    /// Creates an integer type with the given number of bits, e.g., i24\n     pub fn ix_llcx(llcx: &llvm::Context, num_bits: u64) -> &Type {\n         unsafe { llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint) }\n     }"}, {"sha": "7cb4f5503a101f1da94d1b78ed4020154c83317b", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -377,12 +377,8 @@ fn link_rlib<'a>(\n                 find_native_static_library(name.as_str(), lib.verbatim, &lib_search_paths, sess);\n             if sess.opts.unstable_opts.packed_bundled_libs && flavor == RlibFlavor::Normal {\n                 let filename = lib.filename.unwrap();\n-                let lib_path = find_native_static_library(\n-                    filename.as_str(),\n-                    Some(true),\n-                    &lib_search_paths,\n-                    sess,\n-                );\n+                let lib_path =\n+                    find_native_static_library(filename.as_str(), true, &lib_search_paths, sess);\n                 let src = read(lib_path)\n                     .map_err(|e| sess.emit_fatal(errors::ReadFileError { message: e }))?;\n                 let (data, _) = create_wrapper_file(sess, b\".bundled_lib\".to_vec(), &src);\n@@ -465,7 +461,7 @@ fn collate_raw_dylibs<'a, 'b>(\n \n     for lib in used_libraries {\n         if lib.kind == NativeLibKind::RawDylib {\n-            let ext = if matches!(lib.verbatim, Some(true)) { \"\" } else { \".dll\" };\n+            let ext = if lib.verbatim { \"\" } else { \".dll\" };\n             let name = format!(\"{}{}\", lib.name.expect(\"unnamed raw-dylib library\"), ext);\n             let imports = dylib_table.entry(name.clone()).or_default();\n             for import in &lib.dll_imports {\n@@ -1179,7 +1175,7 @@ pub fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool\n         && (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n }\n \n-// This functions tries to determine the appropriate linker (and corresponding LinkerFlavor) to use\n+/// This functions tries to determine the appropriate linker (and corresponding LinkerFlavor) to use\n pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n     fn infer_from(\n         sess: &Session,\n@@ -1335,7 +1331,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n                 NativeLibKind::Static { bundle: Some(false), .. }\n                 | NativeLibKind::Dylib { .. }\n                 | NativeLibKind::Unspecified => {\n-                    let verbatim = lib.verbatim.unwrap_or(false);\n+                    let verbatim = lib.verbatim;\n                     if sess.target.is_like_msvc {\n                         Some(format!(\"{}{}\", name, if verbatim { \"\" } else { \".lib\" }))\n                     } else if sess.target.linker_flavor.is_gnu() {\n@@ -2306,7 +2302,7 @@ fn add_native_libs_from_crate(\n         _ => &codegen_results.crate_info.native_libraries[&cnum],\n     };\n \n-    let mut last = (None, NativeLibKind::Unspecified, None);\n+    let mut last = (None, NativeLibKind::Unspecified, false);\n     for lib in native_libs {\n         let Some(name) = lib.name else {\n             continue;\n@@ -2323,7 +2319,7 @@ fn add_native_libs_from_crate(\n         };\n \n         let name = name.as_str();\n-        let verbatim = lib.verbatim.unwrap_or(false);\n+        let verbatim = lib.verbatim;\n         match lib.kind {\n             NativeLibKind::Static { bundle, whole_archive } => {\n                 if link_static {"}, {"sha": "f087d903e5568f835476c6a43d8dd8c4f7dda6ce", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -34,9 +34,9 @@ pub fn disable_localization(linker: &mut Command) {\n     linker.env(\"VSLANG\", \"1033\");\n }\n \n-// The third parameter is for env vars, used on windows to set up the\n-// path for MSVC to find its DLLs, and gcc to find its bundled\n-// toolchain\n+/// The third parameter is for env vars, used on windows to set up the\n+/// path for MSVC to find its DLLs, and gcc to find its bundled\n+/// toolchain\n pub fn get_linker<'a>(\n     sess: &'a Session,\n     linker: &Path,\n@@ -515,7 +515,7 @@ impl<'a> Linker for GccLinker<'a> {\n             // -force_load is the macOS equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n             self.linker_arg(\"-force_load\");\n-            let lib = find_native_static_library(lib, Some(verbatim), search_path, &self.sess);\n+            let lib = find_native_static_library(lib, verbatim, search_path, &self.sess);\n             self.linker_arg(&lib);\n         }\n     }"}, {"sha": "51c5c375d51913fabe116d1a52b6245224ab0006", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -191,38 +191,38 @@ pub enum MetadataPosition {\n     Last,\n }\n \n-// For rlibs we \"pack\" rustc metadata into a dummy object file.\n-//\n-// Historically it was needed because rustc linked rlibs as whole-archive in some cases.\n-// In that case linkers try to include all files located in an archive, so if metadata is stored\n-// in an archive then it needs to be of a form that the linker is able to process.\n-// Now it's not clear whether metadata still needs to be wrapped into an object file or not.\n-//\n-// Note, though, that we don't actually want this metadata to show up in any\n-// final output of the compiler. Instead this is purely for rustc's own\n-// metadata tracking purposes.\n-//\n-// With the above in mind, each \"flavor\" of object format gets special\n-// handling here depending on the target:\n-//\n-// * MachO - macos-like targets will insert the metadata into a section that\n-//   is sort of fake dwarf debug info. Inspecting the source of the macos\n-//   linker this causes these sections to be skipped automatically because\n-//   it's not in an allowlist of otherwise well known dwarf section names to\n-//   go into the final artifact.\n-//\n-// * WebAssembly - we actually don't have any container format for this\n-//   target. WebAssembly doesn't support the `dylib` crate type anyway so\n-//   there's no need for us to support this at this time. Consequently the\n-//   metadata bytes are simply stored as-is into an rlib.\n-//\n-// * COFF - Windows-like targets create an object with a section that has\n-//   the `IMAGE_SCN_LNK_REMOVE` flag set which ensures that if the linker\n-//   ever sees the section it doesn't process it and it's removed.\n-//\n-// * ELF - All other targets are similar to Windows in that there's a\n-//   `SHF_EXCLUDE` flag we can set on sections in an object file to get\n-//   automatically removed from the final output.\n+/// For rlibs we \"pack\" rustc metadata into a dummy object file.\n+///\n+/// Historically it was needed because rustc linked rlibs as whole-archive in some cases.\n+/// In that case linkers try to include all files located in an archive, so if metadata is stored\n+/// in an archive then it needs to be of a form that the linker is able to process.\n+/// Now it's not clear whether metadata still needs to be wrapped into an object file or not.\n+///\n+/// Note, though, that we don't actually want this metadata to show up in any\n+/// final output of the compiler. Instead this is purely for rustc's own\n+/// metadata tracking purposes.\n+///\n+/// With the above in mind, each \"flavor\" of object format gets special\n+/// handling here depending on the target:\n+///\n+/// * MachO - macos-like targets will insert the metadata into a section that\n+///   is sort of fake dwarf debug info. Inspecting the source of the macos\n+///   linker this causes these sections to be skipped automatically because\n+///   it's not in an allowlist of otherwise well known dwarf section names to\n+///   go into the final artifact.\n+///\n+/// * WebAssembly - we actually don't have any container format for this\n+///   target. WebAssembly doesn't support the `dylib` crate type anyway so\n+///   there's no need for us to support this at this time. Consequently the\n+///   metadata bytes are simply stored as-is into an rlib.\n+///\n+/// * COFF - Windows-like targets create an object with a section that has\n+///   the `IMAGE_SCN_LNK_REMOVE` flag set which ensures that if the linker\n+///   ever sees the section it doesn't process it and it's removed.\n+///\n+/// * ELF - All other targets are similar to Windows in that there's a\n+///   `SHF_EXCLUDE` flag we can set on sections in an object file to get\n+///   automatically removed from the final output.\n pub fn create_wrapper_file(\n     sess: &Session,\n     section_name: Vec<u8>,"}, {"sha": "12fca64968aac2adad6a60ceedcc2d7285b51880", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -340,20 +340,20 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub split_debuginfo: rustc_target::spec::SplitDebuginfo,\n     pub split_dwarf_kind: rustc_session::config::SplitDwarfKind,\n \n-    // Number of cgus excluding the allocator/metadata modules\n+    /// Number of cgus excluding the allocator/metadata modules\n     pub total_cgus: usize,\n-    // Handler to use for diagnostics produced during codegen.\n+    /// Handler to use for diagnostics produced during codegen.\n     pub diag_emitter: SharedEmitter,\n-    // LLVM optimizations for which we want to print remarks.\n+    /// LLVM optimizations for which we want to print remarks.\n     pub remark: Passes,\n-    // Worker thread number\n+    /// Worker thread number\n     pub worker: usize,\n-    // The incremental compilation session directory, or None if we are not\n-    // compiling incrementally\n+    /// The incremental compilation session directory, or None if we are not\n+    /// compiling incrementally\n     pub incr_comp_session_dir: Option<PathBuf>,\n-    // Used to update CGU re-use information during the thinlto phase.\n+    /// Used to update CGU re-use information during the thinlto phase.\n     pub cgu_reuse_tracker: CguReuseTracker,\n-    // Channel back to the main control thread to send messages to\n+    /// Channel back to the main control thread to send messages to\n     pub coordinator_send: Sender<Box<dyn Any + Send>>,\n }\n \n@@ -756,7 +756,7 @@ fn execute_work_item<B: ExtraBackendMethods>(\n     }\n }\n \n-// Actual LTO type we end up choosing based on multiple factors.\n+/// Actual LTO type we end up choosing based on multiple factors.\n pub enum ComputedLtoType {\n     No,\n     Thin,"}, {"sha": "b004fbf85a97f8bcbefa345dd17da85503dd777b", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,4 +1,4 @@\n-// Type Names for Debug Info.\n+//! Type Names for Debug Info.\n \n // Notes on targeting MSVC:\n // In general, MSVC's debugger attempts to parse all arguments as C++ expressions,\n@@ -26,10 +26,10 @@ use std::fmt::Write;\n \n use crate::debuginfo::wants_c_like_enum_debuginfo;\n \n-// Compute the name of the type as it should be stored in debuginfo. Does not do\n-// any caching, i.e., calling the function twice with the same type will also do\n-// the work twice. The `qualified` parameter only affects the first level of the\n-// type name, further levels (i.e., type parameters) are always fully qualified.\n+/// Compute the name of the type as it should be stored in debuginfo. Does not do\n+/// any caching, i.e., calling the function twice with the same type will also do\n+/// the work twice. The `qualified` parameter only affects the first level of the\n+/// type name, further levels (i.e., type parameters) are always fully qualified.\n pub fn compute_debuginfo_type_name<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     t: Ty<'tcx>,"}, {"sha": "def6390f6a36bcbd15d9610ceaa412eef883eeda", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -116,7 +116,7 @@ pub struct NativeLib {\n     pub name: Option<Symbol>,\n     pub filename: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n-    pub verbatim: Option<bool>,\n+    pub verbatim: bool,\n     pub dll_imports: Vec<cstore::DllImport>,\n }\n \n@@ -127,7 +127,7 @@ impl From<&cstore::NativeLib> for NativeLib {\n             filename: lib.filename,\n             name: lib.name,\n             cfg: lib.cfg.clone(),\n-            verbatim: lib.verbatim,\n+            verbatim: lib.verbatim.unwrap_or(false),\n             dll_imports: lib.dll_imports.clone(),\n         }\n     }"}, {"sha": "34a5b638d7ebaa7cc4e7bbf1b52b03a6a34242a5", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -40,10 +40,10 @@ pub enum OperandValue<V> {\n /// instead.\n #[derive(Copy, Clone)]\n pub struct OperandRef<'tcx, V> {\n-    // The value.\n+    /// The value.\n     pub val: OperandValue<V>,\n \n-    // The layout of value, based on its Rust type.\n+    /// The layout of value, based on its Rust type.\n     pub layout: TyAndLayout<'tcx>,\n }\n "}, {"sha": "c27790d8887a377a67a59da57daa99ca84f5f9b3", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -66,7 +66,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     )?;\n \n     // The main interpreter loop.\n-    ecx.run()?;\n+    while ecx.step()? {}\n \n     // Intern the result\n     let intern_kind = if cid.promoted.is_some() {"}, {"sha": "88d25be6bd861d66f8a0788b5a9243ebdf7b105b", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -417,8 +417,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     }\n }\n \n-// A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines\n-// (CTFE and ConstProp) use the same instance.  Here, we share that code.\n+/// A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines\n+/// (CTFE and ConstProp) use the same instance.  Here, we share that code.\n pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type Provenance = AllocId;\n     type ProvenanceExtra = ();"}, {"sha": "2ffd73eef3ef84e41bcd788570d7549cb6d30350", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -206,8 +206,8 @@ where\n         }\n     }\n \n-    // Iterates over all fields of an array. Much more efficient than doing the\n-    // same by repeatedly calling `operand_index`.\n+    /// Iterates over all fields of an array. Much more efficient than doing the\n+    /// same by repeatedly calling `operand_index`.\n     pub fn operand_array_fields<'a>(\n         &self,\n         base: &'a OpTy<'tcx, Prov>,"}, {"sha": "60578246eedcccb01cf885385d53caa5839602f7", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -32,11 +32,6 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    pub fn run(&mut self) -> InterpResult<'tcx> {\n-        while self.step()? {}\n-        Ok(())\n-    }\n-\n     /// Returns `true` as long as there are more things to do.\n     ///\n     /// This is used by [priroda](https://github.com/oli-obk/priroda)"}, {"sha": "1a10851a9f9013d92923c9347fac038fd14a7e17", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -324,7 +324,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n \n macro_rules! make_value_visitor {\n     ($visitor_trait:ident, $value_trait:ident, $($mutability:ident)?) => {\n-        // How to traverse a value and what to do when we are at the leaves.\n+        /// How to traverse a value and what to do when we are at the leaves.\n         pub trait $visitor_trait<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>: Sized {\n             type V: $value_trait<'mir, 'tcx, M>;\n "}, {"sha": "54213d55a2da7137b91b5f9e73fc369ddcf41810", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -761,8 +761,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             hir_id,\n                             ObligationCauseCode::ItemObligation(callee),\n                         );\n-                        let normalized_predicates =\n-                            ocx.normalize(cause.clone(), param_env, predicates);\n+                        let normalized_predicates = ocx.normalize(&cause, param_env, predicates);\n                         ocx.register_obligations(traits::predicates_for_generics(\n                             |_, _| cause.clone(),\n                             self.param_env,"}, {"sha": "655ec345ed3777197a771a038839b9b01ef6861a", "filename": "compiler/rustc_const_eval/src/transform/check_consts/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -75,14 +75,14 @@ pub fn rustc_allow_const_fn_unstable(\n     attr::rustc_allow_const_fn_unstable(&tcx.sess, attrs).any(|name| name == feature_gate)\n }\n \n-// Returns `true` if the given `const fn` is \"const-stable\".\n-//\n-// Panics if the given `DefId` does not refer to a `const fn`.\n-//\n-// Const-stability is only relevant for `const fn` within a `staged_api` crate. Only \"const-stable\"\n-// functions can be called in a const-context by users of the stable compiler. \"const-stable\"\n-// functions are subject to more stringent restrictions than \"const-unstable\" functions: They\n-// cannot use unstable features and can only call other \"const-stable\" functions.\n+/// Returns `true` if the given `const fn` is \"const-stable\".\n+///\n+/// Panics if the given `DefId` does not refer to a `const fn`.\n+///\n+/// Const-stability is only relevant for `const fn` within a `staged_api` crate. Only \"const-stable\"\n+/// functions can be called in a const-context by users of the stable compiler. \"const-stable\"\n+/// functions are subject to more stringent restrictions than \"const-unstable\" functions: They\n+/// cannot use unstable features and can only call other \"const-stable\" functions.\n pub fn is_const_stable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     // A default body in a `#[const_trait]` is not const-stable because const\n     // trait fns currently cannot be const-stable. We shouldn't"}, {"sha": "b19d270e61053391ec1df6325b56b2c8f94ccc0d", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -376,7 +376,7 @@ impl<'tcx> NonConstOp<'tcx> for Generator {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let msg = format!(\"{}s are not allowed in {}s\", self.0, ccx.const_kind());\n+        let msg = format!(\"{}s are not allowed in {}s\", self.0.descr(), ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n             ccx.tcx.sess.create_feature_err(\n                 UnallowedOpInConstContext { span, msg },\n@@ -686,7 +686,7 @@ impl<'tcx> NonConstOp<'tcx> for ThreadLocalAccess {\n     }\n }\n \n-// Types that cannot appear in the signature or locals of a `const fn`.\n+/// Types that cannot appear in the signature or locals of a `const fn`.\n pub mod ty {\n     use super::*;\n "}, {"sha": "6777fae74f1ca5d00018354072ef0ef5c15e62c3", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -318,14 +318,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let mut promotable = false;\n+                        // When a static is used by-value, that gets desugared to `*STATIC_ADDR`,\n+                        // and we need to be able to promote this. So check if this deref matches\n+                        // that specific pattern.\n+\n                         // We need to make sure this is a `Deref` of a local with no further projections.\n                         // Discussion can be found at\n                         // https://github.com/rust-lang/rust/pull/74945#discussion_r463063247\n                         if let Some(local) = place_base.as_local() {\n-                            // This is a special treatment for cases like *&STATIC where STATIC is a\n-                            // global static variable.\n-                            // This pattern is generated only when global static variables are directly\n-                            // accessed and is qualified for promotion safely.\n                             if let TempState::Defined { location, .. } = self.temps[local] {\n                                 let def_stmt = self.body[location.block]\n                                     .statements"}, {"sha": "c43de3368c62fd190ec6e242e287803f9a2b1d78", "filename": "compiler/rustc_const_eval/src/util/aggregate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -9,10 +9,11 @@ use std::iter::TrustedLen;\n /// Expand `lhs = Rvalue::Aggregate(kind, operands)` into assignments to the fields.\n ///\n /// Produces something like\n-///\n+/// ```ignore (ilustrative)\n /// (lhs as Variant).field0 = arg0;     // We only have a downcast if this is an enum\n /// (lhs as Variant).field1 = arg1;\n /// discriminant(lhs) = variant_index;  // If lhs is an enum or generator.\n+/// ```\n pub fn expand_aggregate<'tcx>(\n     orig_lhs: Place<'tcx>,\n     operands: impl Iterator<Item = (Operand<'tcx>, Ty<'tcx>)> + TrustedLen,"}, {"sha": "be786569cde3f52886abc4a16f1d635d6f58d54a", "filename": "compiler/rustc_const_eval/src/util/compare_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -46,8 +46,8 @@ pub fn is_subtype<'tcx>(\n     let infcx = builder.build();\n     let ocx = ObligationCtxt::new(&infcx);\n     let cause = ObligationCause::dummy();\n-    let src = ocx.normalize(cause.clone(), param_env, src);\n-    let dest = ocx.normalize(cause.clone(), param_env, dest);\n+    let src = ocx.normalize(&cause, param_env, src);\n+    let dest = ocx.normalize(&cause, param_env, dest);\n     match ocx.sub(&cause, param_env, src, dest) {\n         Ok(()) => {}\n         Err(_) => return false,"}, {"sha": "d607a5c8314e15d3d5cf091b9464c2c38dc47b21", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -10,8 +10,8 @@ mod index_map;\n pub use index_map::SortedIndexMultiMap;\n \n /// `SortedMap` is a data structure with similar characteristics as BTreeMap but\n-/// slightly different trade-offs: lookup, insertion, and removal are *O*(log(*n*))\n-/// and elements can be iterated in order cheaply.\n+/// slightly different trade-offs: lookup is *O*(log(*n*)), insertion and removal\n+/// are *O*(*n*) but elements can be iterated in order cheaply.\n ///\n /// `SortedMap` can be faster than a `BTreeMap` for small sizes (<50) since it\n /// stores data in a more compact way. It also supports accessing contiguous"}, {"sha": "e2c33e7e06268328a9d027e2e1b48eb6f1e8d778", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -399,7 +399,7 @@ where\n     }\n }\n \n-impl<A, CTX> HashStable<CTX> for SmallVec<[A; 1]>\n+impl<A, const N: usize, CTX> HashStable<CTX> for SmallVec<[A; N]>\n where\n     A: HashStable<CTX>,\n {"}, {"sha": "380fbd732d505ef7e784a47213520b9e0f9f9186", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1336,8 +1336,8 @@ mod signal_handler {\n         }\n     }\n \n-    // When an error signal (such as SIGABRT or SIGSEGV) is delivered to the\n-    // process, print a stack trace and then exit.\n+    /// When an error signal (such as SIGABRT or SIGSEGV) is delivered to the\n+    /// process, print a stack trace and then exit.\n     pub(super) fn install() {\n         unsafe {\n             const ALT_STACK_SIZE: usize = libc::MINSIGSTKSZ + 64 * 1024;"}, {"sha": "1fabe15ff83ba4563a5618988f9242640fa67835", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2282,7 +2282,7 @@ impl FileWithAnnotatedLines {\n         }\n \n         // Find overlapping multiline annotations, put them at different depths\n-        multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, ml.line_end));\n+        multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, usize::MAX - ml.line_end));\n         for (_, ann) in multiline_annotations.clone() {\n             for (_, a) in multiline_annotations.iter_mut() {\n                 // Move all other multiline annotations overlapping with this one\n@@ -2300,8 +2300,14 @@ impl FileWithAnnotatedLines {\n         }\n \n         let mut max_depth = 0; // max overlapping multiline spans\n-        for (file, ann) in multiline_annotations {\n+        for (_, ann) in &multiline_annotations {\n             max_depth = max(max_depth, ann.depth);\n+        }\n+        // Change order of multispan depth to minimize the number of overlaps in the ASCII art.\n+        for (_, a) in multiline_annotations.iter_mut() {\n+            a.depth = max_depth - a.depth + 1;\n+        }\n+        for (file, ann) in multiline_annotations {\n             let mut end_ann = ann.as_end();\n             if !ann.overlaps_exactly {\n                 // avoid output like"}, {"sha": "13e2d1ebbe7869530fc7e514d3884e3f6dd55926", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -16,6 +16,7 @@ use rustc_errors::{\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n+use rustc_session::errors::report_lit_error;\n use rustc_session::{parse::ParseSess, Limit, Session};\n use rustc_span::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_span::edition::Edition;\n@@ -242,8 +243,8 @@ pub enum ExpandResult<T, U> {\n     Retry(U),\n }\n \n-// `meta_item` is the attribute, and `item` is the item being modified.\n pub trait MultiItemModifier {\n+    /// `meta_item` is the attribute, and `item` is the item being modified.\n     fn expand(\n         &self,\n         ecx: &mut ExtCtxt<'_>,\n@@ -1245,7 +1246,10 @@ pub fn expr_to_spanned_string<'a>(\n                 Some((err, true))\n             }\n             Ok(ast::LitKind::Err) => None,\n-            Err(_) => None,\n+            Err(err) => {\n+                report_lit_error(&cx.sess.parse_sess, err, token_lit, expr.span);\n+                None\n+            }\n             _ => Some((cx.struct_span_err(expr.span, err_msg), false)),\n         },\n         ast::ExprKind::Err => None,"}, {"sha": "c978297295d4003420c0b978c5b4222e3b0097e8", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -193,7 +193,7 @@ impl<'a> ExtCtxt<'a> {\n         self.stmt_local(local, sp)\n     }\n \n-    // Generates `let _: Type;`, which is usually used for type assertions.\n+    /// Generates `let _: Type;`, which is usually used for type assertions.\n     pub fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n         let local = P(ast::Local {\n             pat: self.pat_wild(span),\n@@ -579,8 +579,6 @@ impl<'a> ExtCtxt<'a> {\n         attrs: ast::AttrVec,\n         kind: ast::ItemKind,\n     ) -> P<ast::Item> {\n-        // FIXME: Would be nice if our generated code didn't violate\n-        // Rust coding conventions\n         P(ast::Item {\n             ident: name,\n             attrs,\n@@ -618,11 +616,23 @@ impl<'a> ExtCtxt<'a> {\n         self.item(span, name, AttrVec::new(), ast::ItemKind::Const(def, ty, Some(expr)))\n     }\n \n-    pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {\n-        attr::mk_attr_outer(&self.sess.parse_sess.attr_id_generator, mi)\n+    // Builds `#[name]`.\n+    pub fn attr_word(&self, name: Symbol, span: Span) -> ast::Attribute {\n+        let g = &self.sess.parse_sess.attr_id_generator;\n+        attr::mk_attr_word(g, ast::AttrStyle::Outer, name, span)\n     }\n \n-    pub fn meta_word(&self, sp: Span, w: Symbol) -> ast::MetaItem {\n-        attr::mk_word_item(Ident::new(w, sp))\n+    // Builds `#[name = val]`.\n+    //\n+    // Note: `span` is used for both the identifer and the value.\n+    pub fn attr_name_value_str(&self, name: Symbol, val: Symbol, span: Span) -> ast::Attribute {\n+        let g = &self.sess.parse_sess.attr_id_generator;\n+        attr::mk_attr_name_value_str(g, ast::AttrStyle::Outer, name, val, span)\n+    }\n+\n+    // Builds `#[outer(inner)]`.\n+    pub fn attr_nested_word(&self, outer: Symbol, inner: Symbol, span: Span) -> ast::Attribute {\n+        let g = &self.sess.parse_sess.attr_id_generator;\n+        attr::mk_attr_nested_word(g, ast::AttrStyle::Outer, outer, inner, span)\n     }\n }"}, {"sha": "2510795c2e3ed5073c6aa07a2331b06c87f02e17", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -200,7 +200,7 @@ fn get_features(\n     features\n }\n \n-// `cfg_attr`-process the crate's attributes and compute the crate's features.\n+/// `cfg_attr`-process the crate's attributes and compute the crate's features.\n pub fn features(\n     sess: &Session,\n     mut krate: ast::Crate,"}, {"sha": "e799fa404f6fd127465d6e5c0bf8d571e55e745b", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         krate\n     }\n \n-    // Recursively expand all macro invocations in this AST fragment.\n+    /// Recursively expand all macro invocations in this AST fragment.\n     pub fn fully_expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n         let orig_force_mode = self.cx.force_mode;\n@@ -1644,7 +1644,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         let mut span: Option<Span> = None;\n         while let Some(attr) = attrs.next() {\n             rustc_ast_passes::feature_gate::check_attribute(attr, self.cx.sess, features);\n-            validate_attr::check_meta(&self.cx.sess.parse_sess, attr);\n+            validate_attr::check_attr(&self.cx.sess.parse_sess, attr);\n \n             let current_span = if let Some(sp) = span { sp.to(attr.span) } else { attr.span };\n             span = Some(current_span);\n@@ -1931,9 +1931,12 @@ pub struct ExpansionConfig<'feat> {\n     pub features: Option<&'feat Features>,\n     pub recursion_limit: Limit,\n     pub trace_mac: bool,\n-    pub should_test: bool,          // If false, strip `#[test]` nodes\n-    pub span_debug: bool,           // If true, use verbose debugging for `proc_macro::Span`\n-    pub proc_macro_backtrace: bool, // If true, show backtraces for proc-macro panics\n+    /// If false, strip `#[test]` nodes\n+    pub should_test: bool,\n+    /// If true, use verbose debugging for `proc_macro::Span`\n+    pub span_debug: bool,\n+    /// If true, show backtraces for proc-macro panics\n+    pub proc_macro_backtrace: bool,\n }\n \n impl<'feat> ExpansionConfig<'feat> {"}, {"sha": "7616579611711984161c740745240ab4a9bac203", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -526,11 +526,8 @@ impl server::TokenStream for Rustc<'_, '_> {\n                 Ok(tokenstream::TokenStream::token_alone(token::Literal(*token_lit), expr.span))\n             }\n             ast::ExprKind::IncludedBytes(bytes) => {\n-                let lit = ast::Lit::from_included_bytes(bytes, expr.span);\n-                Ok(tokenstream::TokenStream::token_alone(\n-                    token::TokenKind::Literal(lit.token_lit),\n-                    expr.span,\n-                ))\n+                let lit = ast::LitKind::ByteStr(bytes.clone()).to_token_lit();\n+                Ok(tokenstream::TokenStream::token_alone(token::TokenKind::Literal(lit), expr.span))\n             }\n             ast::ExprKind::Unary(ast::UnOp::Neg, e) => match &e.kind {\n                 ast::ExprKind::Lit(token_lit) => match token_lit {"}, {"sha": "539b04535a0d028f8f45f2cbabfe8828e97802ce", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -272,13 +272,13 @@ error: foo\n  --> test.rs:3:3\n   |\n 3 |      X0 Y0\n-  |  ____^__-\n-  | | ___|\n+  |   ___^__-\n+  |  |___|\n   | ||\n 4 | ||   X1 Y1\n 5 | ||   X2 Y2\n   | ||____^__- `Y` is a good letter too\n-  |  |____|\n+  | |_____|\n   |       `X` is a good letter\n \n \"#,\n@@ -311,12 +311,12 @@ error: foo\n  --> test.rs:3:3\n   |\n 3 |      X0 Y0\n-  |  ____^__-\n-  | | ___|\n+  |   ___^__-\n+  |  |___|\n   | ||\n 4 | ||   Y1 X1\n   | ||____-__^ `X` is a good letter\n-  | |_____|\n+  |  |____|\n   |       `Y` is a good letter too\n \n \"#,\n@@ -351,13 +351,13 @@ error: foo\n  --> test.rs:3:6\n   |\n 3 |      X0 Y0 Z0\n-  |   ______^\n-4 |  |   X1 Y1 Z1\n-  |  |_________-\n+  |  _______^\n+4 | |    X1 Y1 Z1\n+  | | _________-\n 5 | ||   X2 Y2 Z2\n   | ||____^ `X` is a good letter\n-6 | |    X3 Y3 Z3\n-  | |_____- `Y` is a good letter too\n+6 |  |   X3 Y3 Z3\n+  |  |____- `Y` is a good letter too\n \n \"#,\n     );\n@@ -395,15 +395,15 @@ error: foo\n  --> test.rs:3:3\n   |\n 3 |       X0 Y0 Z0\n-  |  _____^__-__-\n-  | | ____|__|\n-  | || ___|\n+  |    ___^__-__-\n+  |   |___|__|\n+  |  ||___|\n   | |||\n 4 | |||   X1 Y1 Z1\n 5 | |||   X2 Y2 Z2\n   | |||____^__-__- `Z` label\n-  |  ||____|__|\n-  |   |____|  `Y` is a good letter too\n+  | ||_____|__|\n+  | |______|  `Y` is a good letter too\n   |        `X` is a good letter\n \n \"#,\n@@ -487,17 +487,17 @@ error: foo\n  --> test.rs:3:6\n   |\n 3 |      X0 Y0 Z0\n-  |   ______^\n-4 |  |   X1 Y1 Z1\n-  |  |____^_-\n+  |  _______^\n+4 | |    X1 Y1 Z1\n+  | | ____^_-\n   | ||____|\n-  | |     `X` is a good letter\n-5 | |    X2 Y2 Z2\n-  | |____-______- `Y` is a good letter too\n-  |  ____|\n-  | |\n-6 | |    X3 Y3 Z3\n-  | |________- `Z`\n+  |  |    `X` is a good letter\n+5 |  |   X2 Y2 Z2\n+  |  |___-______- `Y` is a good letter too\n+  |   ___|\n+  |  |\n+6 |  |   X3 Y3 Z3\n+  |  |_______- `Z`\n \n \"#,\n     );\n@@ -570,14 +570,14 @@ error: foo\n  --> test.rs:3:6\n   |\n 3 |      X0 Y0 Z0\n-  |   ______^\n-4 |  |   X1 Y1 Z1\n-  |  |____^____-\n+  |  _______^\n+4 | |    X1 Y1 Z1\n+  | | ____^____-\n   | ||____|\n-  | |     `X` is a good letter\n-5 | |    X2 Y2 Z2\n-6 | |    X3 Y3 Z3\n-  | |___________- `Y` is a good letter too\n+  |  |    `X` is a good letter\n+5 |  |   X2 Y2 Z2\n+6 |  |   X3 Y3 Z3\n+  |  |__________- `Y` is a good letter too\n \n \"#,\n     );\n@@ -941,18 +941,18 @@ error: foo\n   --> test.rs:3:6\n    |\n 3  |      X0 Y0 Z0\n-   |   ______^\n-4  |  |   X1 Y1 Z1\n-   |  |____^____-\n+   |  _______^\n+4  | |    X1 Y1 Z1\n+   | | ____^____-\n    | ||____|\n-   | |     `X` is a good letter\n-5  | |  1\n-6  | |  2\n-7  | |  3\n-...  |\n-15 | |    X2 Y2 Z2\n-16 | |    X3 Y3 Z3\n-   | |___________- `Y` is a good letter too\n+   |  |    `X` is a good letter\n+5  |  | 1\n+6  |  | 2\n+7  |  | 3\n+...   |\n+15 |  |   X2 Y2 Z2\n+16 |  |   X3 Y3 Z3\n+   |  |__________- `Y` is a good letter too\n \n \"#,\n     );\n@@ -996,21 +996,21 @@ error: foo\n   --> test.rs:3:6\n    |\n 3  |      X0 Y0 Z0\n-   |   ______^\n-4  |  | 1\n-5  |  | 2\n-6  |  | 3\n-7  |  |   X1 Y1 Z1\n-   |  |_________-\n+   |  _______^\n+4  | |  1\n+5  | |  2\n+6  | |  3\n+7  | |    X1 Y1 Z1\n+   | | _________-\n 8  | || 4\n 9  | || 5\n 10 | || 6\n 11 | ||   X2 Y2 Z2\n    | ||__________- `Z` is a good letter too\n-...   |\n-15 |  | 10\n-16 |  |   X3 Y3 Z3\n-   |  |_______^ `Y` is a good letter\n+...  |\n+15 | |  10\n+16 | |    X3 Y3 Z3\n+   | |________^ `Y` is a good letter\n \n \"#,\n     );"}, {"sha": "7678ce323dfbc04fb0f254e47e214ca9ed833e68", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -237,6 +237,8 @@ declare_features! (\n     (accepted, native_link_modifiers, \"1.61.0\", Some(81490), None),\n     /// Allows specifying the bundle link modifier\n     (accepted, native_link_modifiers_bundle, \"1.63.0\", Some(81490), None),\n+    /// Allows specifying the verbatim link modifier\n+    (accepted, native_link_modifiers_verbatim, \"CURRENT_RUSTC_VERSION\", Some(81490), None),\n     /// Allows specifying the whole-archive link modifier\n     (accepted, native_link_modifiers_whole_archive, \"1.61.0\", Some(81490), None),\n     /// Allows using non lexical lifetimes (RFC 2094)."}, {"sha": "69c5297bf6b82564395b902052c9ce01ec38e3fa", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -455,8 +455,6 @@ declare_features! (\n     (active, naked_functions, \"1.9.0\", Some(32408), None),\n     /// Allows specifying the as-needed link modifier\n     (active, native_link_modifiers_as_needed, \"1.53.0\", Some(81490), None),\n-    /// Allows specifying the verbatim link modifier\n-    (active, native_link_modifiers_verbatim, \"1.53.0\", Some(81490), None),\n     /// Allow negative trait implementations.\n     (active, negative_impls, \"1.44.0\", Some(68318), None),\n     /// Allows the `!` type. Does not imply 'exhaustive_patterns' (below) any more."}, {"sha": "c89e7eb75f8f0d9480aa31e51435eabbb9ad6947", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -39,6 +39,7 @@ macro_rules! arena_types {\n             [] param: rustc_hir::Param<'tcx>,\n             [] pat: rustc_hir::Pat<'tcx>,\n             [] path: rustc_hir::Path<'tcx>,\n+            [] use_path: rustc_hir::UsePath<'tcx>,\n             [] path_segment: rustc_hir::PathSegment<'tcx>,\n             [] poly_trait_ref: rustc_hir::PolyTraitRef<'tcx>,\n             [] qpath: rustc_hir::QPath<'tcx>,"}, {"sha": "dd37efb6983b429e5db6869e707662775ec444c3", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -368,10 +368,6 @@ impl Definitions {\n         LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) }\n     }\n \n-    pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n-        self.table.def_path_hashes.indices().map(|local_def_index| LocalDefId { local_def_index })\n-    }\n-\n     #[inline(always)]\n     pub fn local_def_path_hash_to_def_id(\n         &self,\n@@ -389,6 +385,10 @@ impl Definitions {\n     pub fn def_path_hash_to_def_index_map(&self) -> &DefPathHashMap {\n         &self.table.def_path_hash_to_index\n     }\n+\n+    pub fn num_definitions(&self) -> usize {\n+        self.table.def_path_hashes.len()\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]"}, {"sha": "118eafe2910f0a8f504247c3a6f345b8ef1bcad0", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -183,14 +183,17 @@ impl Lifetime {\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n #[derive(Debug, HashStable_Generic)]\n-pub struct Path<'hir> {\n+pub struct Path<'hir, R = Res> {\n     pub span: Span,\n     /// The resolution for the path.\n-    pub res: Res,\n+    pub res: R,\n     /// The segments in the path: the things separated by `::`.\n     pub segments: &'hir [PathSegment<'hir>],\n }\n \n+/// Up to three resolutions for type, value and macro namespaces.\n+pub type UsePath<'hir> = Path<'hir, SmallVec<[Res; 3]>>;\n+\n impl Path<'_> {\n     pub fn is_global(&self) -> bool {\n         !self.segments.is_empty() && self.segments[0].ident.name == kw::PathRoot\n@@ -981,8 +984,8 @@ pub struct Pat<'hir> {\n     pub hir_id: HirId,\n     pub kind: PatKind<'hir>,\n     pub span: Span,\n-    // Whether to use default binding modes.\n-    // At present, this is false only for destructuring assignment.\n+    /// Whether to use default binding modes.\n+    /// At present, this is false only for destructuring assignment.\n     pub default_binding_modes: bool,\n }\n \n@@ -1090,7 +1093,7 @@ impl fmt::Display for RangeEnd {\n pub struct DotDotPos(u32);\n \n impl DotDotPos {\n-    // Panics if n >= u32::MAX.\n+    /// Panics if n >= u32::MAX.\n     pub fn new(n: Option<usize>) -> Self {\n         match n {\n             Some(n) => {\n@@ -1526,9 +1529,9 @@ pub enum AsyncGeneratorKind {\n impl fmt::Display for AsyncGeneratorKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(match self {\n-            AsyncGeneratorKind::Block => \"`async` block\",\n-            AsyncGeneratorKind::Closure => \"`async` closure body\",\n-            AsyncGeneratorKind::Fn => \"`async fn` body\",\n+            AsyncGeneratorKind::Block => \"async block\",\n+            AsyncGeneratorKind::Closure => \"async closure body\",\n+            AsyncGeneratorKind::Fn => \"async fn body\",\n         })\n     }\n }\n@@ -1694,10 +1697,10 @@ impl Expr<'_> {\n         }\n     }\n \n-    // Whether this looks like a place expr, without checking for deref\n-    // adjustments.\n-    // This will return `true` in some potentially surprising cases such as\n-    // `CONSTANT.field`.\n+    /// Whether this looks like a place expr, without checking for deref\n+    /// adjustments.\n+    /// This will return `true` in some potentially surprising cases such as\n+    /// `CONSTANT.field`.\n     pub fn is_syntactic_place_expr(&self) -> bool {\n         self.is_place_expr(|_| true)\n     }\n@@ -1838,7 +1841,7 @@ impl Expr<'_> {\n         }\n     }\n \n-    // To a first-order approximation, is this a pattern\n+    /// To a first-order approximation, is this a pattern?\n     pub fn is_approximately_pattern(&self) -> bool {\n         match &self.kind {\n             ExprKind::Box(_)\n@@ -2160,11 +2163,11 @@ impl fmt::Display for LoopIdError {\n \n #[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n pub struct Destination {\n-    // This is `Some(_)` iff there is an explicit user-specified `label\n+    /// This is `Some(_)` iff there is an explicit user-specified 'label\n     pub label: Option<Label>,\n \n-    // These errors are caught and then reported during the diagnostics pass in\n-    // librustc_passes/loops.rs\n+    /// These errors are caught and then reported during the diagnostics pass in\n+    /// `librustc_passes/loops.rs`\n     pub target_id: Result<HirId, LoopIdError>,\n }\n \n@@ -2335,7 +2338,7 @@ pub enum ImplItemKind<'hir> {\n     Type(&'hir Ty<'hir>),\n }\n \n-// The name of the associated type for `Fn` return types.\n+/// The name of the associated type for `Fn` return types.\n pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n \n /// Bind a type to an associated type (i.e., `A = Foo`).\n@@ -3068,7 +3071,7 @@ pub enum ItemKind<'hir> {\n     /// or just\n     ///\n     /// `use foo::bar::baz;` (with `as baz` implicitly on the right).\n-    Use(&'hir Path<'hir>, UseKind),\n+    Use(&'hir UsePath<'hir>, UseKind),\n \n     /// A `static` item.\n     Static(&'hir Ty<'hir>, Mutability, BodyId),\n@@ -3261,7 +3264,7 @@ pub enum ForeignItemKind<'hir> {\n /// A variable captured by a closure.\n #[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n pub struct Upvar {\n-    // First span where it is accessed (there can be multiple).\n+    /// First span where it is accessed (there can be multiple).\n     pub span: Span,\n }\n "}, {"sha": "cbb530424ca5d36d37a2c343f798ac70a48d4a26", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -367,7 +367,7 @@ pub trait Visitor<'v>: Sized {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl<'v>, b: BodyId, _: Span, id: HirId) {\n         walk_fn(self, fk, fd, b, id)\n     }\n-    fn visit_use(&mut self, path: &'v Path<'v>, hir_id: HirId) {\n+    fn visit_use(&mut self, path: &'v UsePath<'v>, hir_id: HirId) {\n         walk_use(self, path, hir_id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem<'v>) {\n@@ -422,7 +422,7 @@ pub trait Visitor<'v>: Sized {\n     fn visit_qpath(&mut self, qpath: &'v QPath<'v>, id: HirId, _span: Span) {\n         walk_qpath(self, qpath, id)\n     }\n-    fn visit_path(&mut self, path: &'v Path<'v>, _id: HirId) {\n+    fn visit_path(&mut self, path: &Path<'v>, _id: HirId) {\n         walk_path(self, path)\n     }\n     fn visit_path_segment(&mut self, path_segment: &'v PathSegment<'v>) {\n@@ -938,9 +938,12 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n     }\n }\n \n-pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n+pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v UsePath<'v>, hir_id: HirId) {\n     visitor.visit_id(hir_id);\n-    visitor.visit_path(path, hir_id);\n+    let UsePath { segments, ref res, span } = *path;\n+    for &res in res {\n+        visitor.visit_path(&Path { segments, res, span }, hir_id);\n+    }\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem<'v>) {\n@@ -1126,7 +1129,7 @@ pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath<'v>, id:\n     }\n }\n \n-pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n+pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &Path<'v>) {\n     for segment in path.segments {\n         visitor.visit_path_segment(segment);\n     }"}, {"sha": "82150310638270c4c69e74d917099c2d666c9e4e", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -109,6 +109,9 @@ pub trait AstConv<'tcx> {\n     ) -> Ty<'tcx>;\n \n     /// Normalize an associated type coming from the user.\n+    ///\n+    /// This should only be used by astconv. Use `FnCtxt::normalize`\n+    /// or `ObligationCtxt::normalize` in downstream crates.\n     fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx>;\n \n     /// Invoked when we encounter an error from some prior pass\n@@ -850,7 +853,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .is_some()\n     }\n \n-    // Sets `implicitly_sized` to true on `Bounds` if necessary\n+    /// Sets `implicitly_sized` to true on `Bounds` if necessary\n     pub(crate) fn add_implicitly_sized<'hir>(\n         &self,\n         bounds: &mut Bounds<'hir>,\n@@ -2391,7 +2394,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         path_segs\n     }\n \n-    // Check a type `Path` and convert it to a `Ty`.\n+    /// Check a type `Path` and convert it to a `Ty`.\n     pub fn res_to_ty(\n         &self,\n         opt_self_ty: Option<Ty<'tcx>>,"}, {"sha": "ba58672e7595a57e84872bec799a5ac88fe77d24", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -221,7 +221,7 @@ fn compare_predicate_entailment<'tcx>(\n     let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n     for (predicate, span) in iter::zip(impl_m_own_bounds.predicates, impl_m_own_bounds.spans) {\n         let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n-        let predicate = ocx.normalize(normalize_cause, param_env, predicate);\n+        let predicate = ocx.normalize(&normalize_cause, param_env, predicate);\n \n         let cause = ObligationCause::new(\n             span,\n@@ -260,7 +260,7 @@ fn compare_predicate_entailment<'tcx>(\n     );\n \n     let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n-    let impl_sig = ocx.normalize(norm_cause.clone(), param_env, impl_sig);\n+    let impl_sig = ocx.normalize(&norm_cause, param_env, impl_sig);\n     let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n     debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n@@ -271,7 +271,7 @@ fn compare_predicate_entailment<'tcx>(\n     // we have to do this before normalization, since the normalized ty may\n     // not contain the input parameters. See issue #87748.\n     wf_tys.extend(trait_sig.inputs_and_output.iter());\n-    let trait_sig = ocx.normalize(norm_cause, param_env, trait_sig);\n+    let trait_sig = ocx.normalize(&norm_cause, param_env, trait_sig);\n     // We also have to add the normalized trait signature\n     // as we don't normalize during implied bounds computation.\n     wf_tys.extend(trait_sig.inputs_and_output.iter());\n@@ -366,7 +366,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     // Normalize the impl signature with fresh variables for lifetime inference.\n     let norm_cause = ObligationCause::misc(return_span, impl_m_hir_id);\n     let impl_sig = ocx.normalize(\n-        norm_cause.clone(),\n+        &norm_cause,\n         param_env,\n         infcx.replace_bound_vars_with_fresh_vars(\n             return_span,\n@@ -387,7 +387,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n             tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs),\n         )\n         .fold_with(&mut collector);\n-    let trait_sig = ocx.normalize(norm_cause.clone(), param_env, unnormalized_trait_sig);\n+    let trait_sig = ocx.normalize(&norm_cause, param_env, unnormalized_trait_sig);\n     let trait_return_ty = trait_sig.output();\n \n     let wf_tys = FxIndexSet::from_iter(\n@@ -592,7 +592,7 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n             for (pred, pred_span) in self.tcx().bound_explicit_item_bounds(proj.item_def_id).subst_iter_copied(self.tcx(), proj.substs) {\n                 let pred = pred.fold_with(self);\n                 let pred = self.ocx.normalize(\n-                    ObligationCause::misc(self.span, self.body_id),\n+                    &ObligationCause::misc(self.span, self.body_id),\n                     self.param_env,\n                     pred,\n                 );\n@@ -1403,11 +1403,11 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n     );\n \n     // There is no \"body\" here, so just pass dummy id.\n-    let impl_ty = ocx.normalize(cause.clone(), param_env, impl_ty);\n+    let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n \n     debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n-    let trait_ty = ocx.normalize(cause.clone(), param_env, trait_ty);\n+    let trait_ty = ocx.normalize(&cause, param_env, trait_ty);\n \n     debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n@@ -1556,7 +1556,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     for (span, predicate) in std::iter::zip(impl_ty_own_bounds.spans, impl_ty_own_bounds.predicates)\n     {\n         let cause = ObligationCause::misc(span, impl_ty_hir_id);\n-        let predicate = ocx.normalize(cause, param_env, predicate);\n+        let predicate = ocx.normalize(&cause, param_env, predicate);\n \n         let cause = ObligationCause::new(\n             span,\n@@ -1778,7 +1778,7 @@ pub fn check_type_bounds<'tcx>(\n \n     for mut obligation in util::elaborate_obligations(tcx, obligations) {\n         let normalized_predicate =\n-            ocx.normalize(normalize_cause.clone(), normalize_param_env, obligation.predicate);\n+            ocx.normalize(&normalize_cause, normalize_param_env, obligation.predicate);\n         debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n         obligation.predicate = normalized_predicate;\n "}, {"sha": "d6e3ddb0a613964238574c6fbc46261d8a00f620", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -233,9 +233,10 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     result\n }\n \n-// This is an implementation of the TypeRelation trait with the\n-// aim of simply comparing for equality (without side-effects).\n-// It is not intended to be used anywhere else other than here.\n+/// This is an implementation of the [`TypeRelation`] trait with the\n+/// aim of simply comparing for equality (without side-effects).\n+///\n+/// It is not intended to be used anywhere else other than here.\n pub(crate) struct SimpleEqRelation<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "7daed74e9de83d6add8504792d4daad16ab468f9", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -53,12 +53,14 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n         self.ocx.infcx.tcx\n     }\n \n+    // Convenience function to normalize during wfcheck. This performs\n+    // `ObligationCtxt::normalize`, but provides a nice `ObligationCauseCode`.\n     fn normalize<T>(&self, span: Span, loc: Option<WellFormedLoc>, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         self.ocx.normalize(\n-            ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(loc)),\n+            &ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(loc)),\n             self.param_env,\n             value,\n         )"}, {"sha": "d623e726139442891d173b04829e287ede2cdc82", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -33,7 +33,7 @@ use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs}\n use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, IsSuggestable, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, IsSuggestable, ToPredicate, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -1366,12 +1366,14 @@ fn predicates_defined_on(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicate\n             \"predicates_defined_on: inferred_outlives_of({:?}) = {:?}\",\n             def_id, inferred_outlives,\n         );\n+        let inferred_outlives_iter =\n+            inferred_outlives.iter().map(|(clause, span)| ((*clause).to_predicate(tcx), *span));\n         if result.predicates.is_empty() {\n-            result.predicates = inferred_outlives;\n+            result.predicates = tcx.arena.alloc_from_iter(inferred_outlives_iter);\n         } else {\n-            result.predicates = tcx\n-                .arena\n-                .alloc_from_iter(result.predicates.iter().chain(inferred_outlives).copied());\n+            result.predicates = tcx.arena.alloc_from_iter(\n+                result.predicates.into_iter().copied().chain(inferred_outlives_iter),\n+            );\n         }\n     }\n \n@@ -2145,7 +2147,7 @@ fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n }\n \n fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n-    use rustc_ast::{Lit, LitIntType, LitKind};\n+    use rustc_ast::{LitIntType, LitKind, MetaItemLit};\n     if !tcx.features().raw_dylib && tcx.sess.target.arch == \"x86\" {\n         feature_err(\n             &tcx.sess.parse_sess,\n@@ -2158,7 +2160,7 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n     let meta_item_list = attr.meta_item_list();\n     let meta_item_list = meta_item_list.as_deref();\n     let sole_meta_list = match meta_item_list {\n-        Some([item]) => item.literal(),\n+        Some([item]) => item.lit(),\n         Some(_) => {\n             tcx.sess\n                 .struct_span_err(attr.span, \"incorrect number of arguments to `#[link_ordinal]`\")\n@@ -2168,7 +2170,9 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n         }\n         _ => None,\n     };\n-    if let Some(Lit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) = sole_meta_list {\n+    if let Some(MetaItemLit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) =\n+        sole_meta_list\n+    {\n         // According to the table at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-header,\n         // the ordinal must fit into 16 bits.  Similarly, the Ordinal field in COFFShortExport (defined\n         // in llvm/include/llvm/Object/COFFImportFile.h), which we use to communicate import information"}, {"sha": "9a7b261fffd4ded6cde9bc8bee5f84f8af042336", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -814,7 +814,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &hir::Path<'tcx>, _: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n             if let Some(ref args) = segment.args {"}, {"sha": "2058832d5fdc1035dc405812cc5d9a309b2382a6", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -332,7 +332,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n             ObligationCauseCode::MainFunctionType,\n         );\n         let ocx = traits::ObligationCtxt::new(&infcx);\n-        let norm_return_ty = ocx.normalize(cause.clone(), param_env, return_ty);\n+        let norm_return_ty = ocx.normalize(&cause, param_env, return_ty);\n         ocx.register_bound(cause, param_env, norm_return_ty, term_did);\n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {"}, {"sha": "81fe32000d3079450050b0937075c5f20bcdfae2", "filename": "compiler/rustc_hir_analysis/src/outlives/mod.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -3,7 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, CratePredicatesMap, ToPredicate, TyCtxt};\n+use rustc_middle::ty::{self, CratePredicatesMap, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -17,7 +17,7 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers { inferred_outlives_of, inferred_outlives_crate, ..*providers };\n }\n \n-fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate<'_>, Span)] {\n+fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Clause<'_>, Span)] {\n     let id = tcx.hir().local_def_id_to_hir_id(item_def_id.expect_local());\n \n     if matches!(tcx.def_kind(item_def_id), hir::def::DefKind::AnonConst) && tcx.lazy_normalization()\n@@ -50,12 +50,10 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n                 if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n-                        .map(|(out_pred, _)| match out_pred.kind().skip_binder() {\n-                            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(p)) => {\n-                                p.to_string()\n-                            }\n-                            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(p)) => p.to_string(),\n-                            err => bug!(\"unexpected predicate {:?}\", err),\n+                        .map(|(out_pred, _)| match out_pred {\n+                            ty::Clause::RegionOutlives(p) => p.to_string(),\n+                            ty::Clause::TypeOutlives(p) => p.to_string(),\n+                            err => bug!(\"unexpected clause {:?}\", err),\n                         })\n                         .collect();\n                     pred.sort();\n@@ -103,19 +101,11 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, (): ()) -> CratePredicatesMap<'_> {\n                 |(ty::OutlivesPredicate(kind1, region2), &span)| {\n                     match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => Some((\n-                            ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n-                                ty::OutlivesPredicate(ty1, *region2),\n-                            )))\n-                            .to_predicate(tcx),\n+                            ty::Clause::TypeOutlives(ty::OutlivesPredicate(ty1, *region2)),\n                             span,\n                         )),\n                         GenericArgKind::Lifetime(region1) => Some((\n-                            ty::Binder::dummy(ty::PredicateKind::Clause(\n-                                ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n-                                    region1, *region2,\n-                                )),\n-                            ))\n-                            .to_predicate(tcx),\n+                            ty::Clause::RegionOutlives(ty::OutlivesPredicate(region1, *region2)),\n                             span,\n                         )),\n                         GenericArgKind::Const(_) => {"}, {"sha": "3b286bb9c93cfd09bc2e38a9a90d31b8de8b95d9", "filename": "compiler/rustc_hir_analysis/src/variance/terms.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -42,22 +42,22 @@ impl<'a> fmt::Debug for VarianceTerm<'a> {\n     }\n }\n \n-// The first pass over the crate simply builds up the set of inferreds.\n+/// The first pass over the crate simply builds up the set of inferreds.\n \n pub struct TermsContext<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub arena: &'a DroplessArena,\n \n-    // For marker types, UnsafeCell, and other lang items where\n-    // variance is hardcoded, records the item-id and the hardcoded\n-    // variance.\n+    /// For marker types, `UnsafeCell`, and other lang items where\n+    /// variance is hardcoded, records the item-id and the hardcoded\n+    /// variance.\n     pub lang_items: Vec<(LocalDefId, Vec<ty::Variance>)>,\n \n-    // Maps from the node id of an item to the first inferred index\n-    // used for its type & region parameters.\n+    /// Maps from the node id of an item to the first inferred index\n+    /// used for its type & region parameters.\n     pub inferred_starts: LocalDefIdMap<InferredIndex>,\n \n-    // Maps from an InferredIndex to the term for that variable.\n+    /// Maps from an InferredIndex to the term for that variable.\n     pub inferred_terms: Vec<VarianceTermPtr<'a>>,\n }\n "}, {"sha": "2460a23bb3f34ff52fa9375bbb6e6c0ce913f9a9", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1591,7 +1591,7 @@ impl<'a> State<'a> {\n         self.print_ident(Ident::with_dummy_span(name))\n     }\n \n-    pub fn print_path(&mut self, path: &hir::Path<'_>, colons_before_params: bool) {\n+    pub fn print_path<R>(&mut self, path: &hir::Path<'_, R>, colons_before_params: bool) {\n         self.maybe_print_comment(path.span.lo());\n \n         for (i, segment) in path.segments.iter().enumerate() {"}, {"sha": "b09ddf80e2a52577292e3d602fca7e3cff198dc2", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -179,12 +179,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Hack: we know that there are traits implementing Fn for &F\n             // where F:Fn and so forth. In the particular case of types\n-            // like `x: &mut FnMut()`, if there is a call `x()`, we would\n-            // normally translate to `FnMut::call_mut(&mut x, ())`, but\n-            // that winds up requiring `mut x: &mut FnMut()`. A little\n-            // over the top. The simplest fix by far is to just ignore\n-            // this case and deref again, so we wind up with\n-            // `FnMut::call_mut(&mut *x, ())`.\n+            // like `f: &mut FnMut()`, if there is a call `f()`, we would\n+            // normally translate to `FnMut::call_mut(&mut f, ())`, but\n+            // that winds up potentially requiring the user to mark their\n+            // variable as `mut` which feels unnecessary and unexpected.\n+            //\n+            //     fn foo(f: &mut impl FnMut()) { f() }\n+            //            ^ without this hack `f` would have to be declared as mutable\n+            //\n+            // The simplest fix by far is to just ignore this case and deref again,\n+            // so we wind up with `FnMut::call_mut(&mut *f, ())`.\n             ty::Ref(..) if autoderef.step_count() == 0 => {\n                 return None;\n             }\n@@ -444,7 +448,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // previously appeared within a `Binder<>` and hence would not\n         // have been normalized before.\n         let fn_sig = self.replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, fn_sig);\n-        let fn_sig = self.normalize_associated_types_in(call_expr.span, fn_sig);\n+        let fn_sig = self.normalize(call_expr.span, fn_sig);\n \n         // Call the generic checker.\n         let expected_arg_tys = self.expected_inputs_for_expected_output("}, {"sha": "890a068a7befc8c78cc14ad9d9c0d4fe96851cb7", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -46,7 +46,6 @@ use rustc_span::def_id::{DefId, LOCAL_CRATE};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::error_reporting::report_object_safety_error;\n \n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n@@ -727,9 +726,6 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     debug!(\" -> CoercionCast\");\n                     fcx.typeck_results.borrow_mut().set_coercion_cast(self.expr.hir_id.local_id);\n                 }\n-                Err(ty::error::TypeError::ObjectUnsafeCoercion(did)) => {\n-                    self.report_object_unsafe_cast(&fcx, did);\n-                }\n                 Err(_) => {\n                     match self.do_check(fcx) {\n                         Ok(k) => {\n@@ -741,14 +737,6 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             };\n         }\n     }\n-\n-    fn report_object_unsafe_cast(&self, fcx: &FnCtxt<'a, 'tcx>, did: DefId) {\n-        let violations = fcx.tcx.object_safety_violations(did);\n-        let mut err = report_object_safety_error(fcx.tcx, self.cast_span, did, violations);\n-        err.note(&format!(\"required by cast to type '{}'\", fcx.ty_to_string(self.cast_ty)));\n-        err.emit();\n-    }\n-\n     /// Checks a cast, and report an error if one exists. In some cases, this\n     /// can return Ok and create type errors in the fcx rather than returning\n     /// directly. coercion-cast is handled in check instead of here.\n@@ -764,10 +752,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 match *self.expr_ty.kind() {\n                     ty::FnDef(..) => {\n                         // Attempt a coercion to a fn pointer type.\n-                        let f = fcx.normalize_associated_types_in(\n-                            self.expr_span,\n-                            self.expr_ty.fn_sig(fcx.tcx),\n-                        );\n+                        let f = fcx.normalize(self.expr_span, self.expr_ty.fn_sig(fcx.tcx));\n                         let res = fcx.try_coerce(\n                             self.expr,\n                             self.expr_ty,"}, {"sha": "0c9a350c295f4227866c20eb5e4ae887b027ed7d", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,6 +1,6 @@\n use crate::coercion::CoerceMany;\n use crate::gather_locals::GatherLocalsVisitor;\n-use crate::{FnCtxt, Inherited};\n+use crate::FnCtxt;\n use crate::{GeneratorTypes, UnsafetyState};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n@@ -20,21 +20,16 @@ use std::cell::RefCell;\n ///\n /// * ...\n /// * inherited: other fields inherited from the enclosing fn (if any)\n-#[instrument(skip(inherited, body), level = \"debug\")]\n+#[instrument(skip(fcx, body), level = \"debug\")]\n pub(super) fn check_fn<'a, 'tcx>(\n-    inherited: &'a Inherited<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    fcx: &mut FnCtxt<'a, 'tcx>,\n     fn_sig: ty::FnSig<'tcx>,\n     decl: &'tcx hir::FnDecl<'tcx>,\n     fn_def_id: LocalDefId,\n     body: &'tcx hir::Body<'tcx>,\n     can_be_generator: Option<hir::Movability>,\n-) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n-    let fn_id = inherited.tcx.hir().local_def_id_to_hir_id(fn_def_id);\n-\n-    // Create the function context. This is either derived from scratch or,\n-    // in the case of closures, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n+) -> Option<GeneratorTypes<'tcx>> {\n+    let fn_id = fcx.tcx.hir().local_def_id_to_hir_id(fn_def_id);\n     fcx.ps.set(UnsafetyState::function(fn_sig.unsafety, fn_id));\n \n     let tcx = fcx.tcx;\n@@ -47,7 +42,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n             declared_ret_ty,\n             body.value.hir_id,\n             decl.output.span(),\n-            param_env,\n+            fcx.param_env,\n         ));\n \n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n@@ -105,7 +100,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n         fcx.write_ty(param.hir_id, param_ty);\n     }\n \n-    inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n+    fcx.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n     if let ty::Dynamic(_, _, ty::Dyn) = declared_ret_ty.kind() {\n         // FIXME: We need to verify that the return type is `Sized` after the return expression has\n@@ -174,7 +169,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n         check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n     }\n \n-    (fcx, gen_ty)\n+    gen_ty\n }\n \n fn check_panic_info_fn("}, {"sha": "5d3419b3b6e66c16be7e11c09dc0d0630ef0454c", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -79,16 +79,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         debug!(?bound_sig, ?liberated_sig);\n \n+        let mut fcx = FnCtxt::new(self, self.param_env.without_const(), body.value.hir_id);\n         let generator_types = check_fn(\n-            self,\n-            self.param_env.without_const(),\n+            &mut fcx,\n             liberated_sig,\n             closure.fn_decl,\n             expr_def_id,\n             body,\n             closure.movability,\n-        )\n-        .1;\n+        );\n \n         let parent_substs = InternalSubsts::identity_for_item(\n             self.tcx,\n@@ -178,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 });\n                 let kind = object_type\n                     .principal_def_id()\n-                    .and_then(|did| self.tcx.fn_trait_kind_from_lang_item(did));\n+                    .and_then(|did| self.tcx.fn_trait_kind_from_def_id(did));\n                 (sig, kind)\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_signature_from_predicates(\n@@ -214,7 +213,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if expected_sig.is_none()\n                 && let ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) = bound_predicate.skip_binder()\n             {\n-                expected_sig = self.normalize_associated_types_in(\n+                expected_sig = self.normalize(\n                     obligation.cause.span,\n                     self.deduce_sig_from_projection(\n                     Some(obligation.cause.span),\n@@ -235,7 +234,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => None,\n             };\n             if let Some(closure_kind) =\n-                trait_def_id.and_then(|def_id| self.tcx.fn_trait_kind_from_lang_item(def_id))\n+                trait_def_id.and_then(|def_id| self.tcx.fn_trait_kind_from_def_id(def_id))\n             {\n                 expected_kind = Some(\n                     expected_kind\n@@ -263,7 +262,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let trait_def_id = projection.trait_def_id(tcx);\n \n-        let is_fn = tcx.fn_trait_kind_from_lang_item(trait_def_id).is_some();\n+        let is_fn = tcx.is_fn_trait(trait_def_id);\n         let gen_trait = tcx.require_lang_item(LangItem::Generator, cause_span);\n         let is_gen = gen_trait == trait_def_id;\n         if !is_fn && !is_gen {\n@@ -623,7 +622,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         // Astconv can't normalize inputs or outputs with escaping bound vars,\n         // so normalize them here, after we've wrapped them in a binder.\n-        let result = self.normalize_associated_types_in(self.tcx.hir().span(hir_id), result);\n+        let result = self.normalize(self.tcx.hir().span(hir_id), result);\n \n         let c_result = self.inh.infcx.canonicalize_response(result);\n         self.typeck_results.borrow_mut().user_provided_sigs.insert(expr_def_id, c_result);\n@@ -797,12 +796,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> ClosureSignatures<'tcx> {\n         let liberated_sig =\n             self.tcx().liberate_late_bound_regions(expr_def_id.to_def_id(), bound_sig);\n-        let liberated_sig = self.inh.normalize_associated_types_in(\n-            body.value.span,\n-            self.tcx.hir().local_def_id_to_hir_id(expr_def_id),\n-            self.param_env,\n-            liberated_sig,\n-        );\n+        let liberated_sig = self.normalize(body.value.span, liberated_sig);\n         ClosureSignatures { bound_sig, liberated_sig }\n     }\n }"}, {"sha": "f0b349f0c98dd667f349083ab9555df2aa758589", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -62,7 +62,9 @@ use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, ObligationCtxt};\n+use rustc_trait_selection::traits::{\n+    self, NormalizeExt, ObligationCause, ObligationCauseCode, ObligationCtxt,\n+};\n \n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n@@ -195,10 +197,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 debug!(\"coerce: unsize successful\");\n                 return unsize;\n             }\n-            Err(TypeError::ObjectUnsafeCoercion(did)) => {\n-                debug!(\"coerce: unsize not object safe\");\n-                return Err(TypeError::ObjectUnsafeCoercion(did));\n-            }\n             Err(error) => {\n                 debug!(?error, \"coerce: unsize failed\");\n             }\n@@ -498,27 +496,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         target = self.shallow_resolve(target);\n         debug!(?source, ?target);\n \n-        // These 'if' statements require some explanation.\n-        // The `CoerceUnsized` trait is special - it is only\n-        // possible to write `impl CoerceUnsized<B> for A` where\n-        // A and B have 'matching' fields. This rules out the following\n-        // two types of blanket impls:\n-        //\n-        // `impl<T> CoerceUnsized<T> for SomeType`\n-        // `impl<T> CoerceUnsized<SomeType> for T`\n-        //\n-        // Both of these trigger a special `CoerceUnsized`-related error (E0376)\n-        //\n-        // We can take advantage of this fact to avoid performing unnecessary work.\n-        // If either `source` or `target` is a type variable, then any applicable impl\n-        // would need to be generic over the self-type (`impl<T> CoerceUnsized<SomeType> for T`)\n-        // or generic over the `CoerceUnsized` type parameter (`impl<T> CoerceUnsized<T> for\n-        // SomeType`).\n-        //\n-        // However, these are exactly the kinds of impls which are forbidden by\n-        // the compiler! Therefore, we can be sure that coercion will always fail\n-        // when either the source or target type is a type variable. This allows us\n-        // to skip performing any trait selection, and immediately bail out.\n+        // We don't apply any coercions incase either the source or target\n+        // aren't sufficiently well known but tend to instead just equate\n+        // them both.\n         if source.is_ty_var() {\n             debug!(\"coerce_unsized: source is a TyVar, bailing out\");\n             return Err(TypeError::Mismatch);\n@@ -854,7 +834,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         let b = self.shallow_resolve(b);\n         let InferOk { value: b, mut obligations } =\n-            self.normalize_associated_types_in_as_infer_ok(self.cause.span, b);\n+            self.at(&self.cause, self.param_env).normalize(b);\n         debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n \n         match b.kind() {\n@@ -876,7 +856,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 }\n \n                 let InferOk { value: a_sig, obligations: o1 } =\n-                    self.normalize_associated_types_in_as_infer_ok(self.cause.span, a_sig);\n+                    self.at(&self.cause, self.param_env).normalize(a_sig);\n                 obligations.extend(o1);\n \n                 let a_fn_pointer = self.tcx.mk_fn_ptr(a_sig);\n@@ -1101,15 +1081,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Special-case that coercion alone cannot handle:\n         // Function items or non-capturing closures of differing IDs or InternalSubsts.\n         let (a_sig, b_sig) = {\n-            #[allow(rustc::usage_of_ty_tykind)]\n-            let is_capturing_closure = |ty: &ty::TyKind<'tcx>| {\n-                if let &ty::Closure(closure_def_id, _substs) = ty {\n+            let is_capturing_closure = |ty: Ty<'tcx>| {\n+                if let &ty::Closure(closure_def_id, _substs) = ty.kind() {\n                     self.tcx.upvars_mentioned(closure_def_id.expect_local()).is_some()\n                 } else {\n                     false\n                 }\n             };\n-            if is_capturing_closure(prev_ty.kind()) || is_capturing_closure(new_ty.kind()) {\n+            if is_capturing_closure(prev_ty) || is_capturing_closure(new_ty) {\n                 (None, None)\n             } else {\n                 match (prev_ty.kind(), new_ty.kind()) {\n@@ -1164,8 +1143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return Err(TypeError::IntrinsicCast);\n             }\n             // The signature must match.\n-            let a_sig = self.normalize_associated_types_in(new.span, a_sig);\n-            let b_sig = self.normalize_associated_types_in(new.span, b_sig);\n+            let (a_sig, b_sig) = self.normalize(new.span, (a_sig, b_sig));\n             let sig = self\n                 .at(cause, self.param_env)\n                 .trace(prev_ty, new_ty)"}, {"sha": "24184bdbf5cdcd74b125f185243919086905910f", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -57,8 +57,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n     }\n \n-    // Requires that the two types unify, and prints an error message if\n-    // they don't.\n+    /// Requires that the two types unify, and prints an error message if\n+    /// they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n         if let Some(mut e) = self.demand_suptype_diag(sp, expected, actual) {\n             e.emit();"}, {"sha": "4f086cf597d8826dd4a4b512f73a6ae9d661f4ab", "filename": "compiler/rustc_hir_typeck/src/expectation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -79,9 +79,9 @@ impl<'a, 'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    // Resolves `expected` by a single level if it is a variable. If\n-    // there is no expected type or resolution is not possible (e.g.,\n-    // no constraints yet present), just returns `self`.\n+    /// Resolves `expected` by a single level if it is a variable. If\n+    /// there is no expected type or resolution is not possible (e.g.,\n+    /// no constraints yet present), just returns `self`.\n     fn resolve(self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n         match self {\n             NoExpectation => NoExpectation,"}, {"sha": "0c5bbb3e20be32cc3a83e063e1d36006be387b30", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -914,8 +914,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     // Check if an expression `original_expr_id` comes from the condition of a while loop,\n-    // as opposed from the body of a while loop, which we can naively check by iterating\n-    // parents until we find a loop...\n+    /// as opposed from the body of a while loop, which we can naively check by iterating\n+    /// parents until we find a loop...\n     pub(super) fn comes_from_while_condition(\n         &self,\n         original_expr_id: HirId,\n@@ -1664,7 +1664,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .fields\n                         .iter()\n                         .map(|f| {\n-                            let fru_ty = self.normalize_associated_types_in(\n+                            let fru_ty = self.normalize(\n                                 expr_span,\n                                 self.field_ty(base_expr.span, f, fresh_substs),\n                             );\n@@ -1748,9 +1748,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ty::Adt(adt, substs) if adt.is_struct() => variant\n                         .fields\n                         .iter()\n-                        .map(|f| {\n-                            self.normalize_associated_types_in(expr_span, f.ty(self.tcx, substs))\n-                        })\n+                        .map(|f| self.normalize(expr_span, f.ty(self.tcx, substs)))\n                         .collect(),\n                     _ => {\n                         self.tcx"}, {"sha": "e5e798f4b933f2ec18ae1dc5bdc8c4e6bd411cbe", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -252,11 +252,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n             hir::ExprKind::Match(ref discr, arms, _) => {\n                 let discr_place = return_if_err!(self.mc.cat_expr(discr));\n-                self.maybe_read_scrutinee(\n+                return_if_err!(self.maybe_read_scrutinee(\n                     discr,\n                     discr_place.clone(),\n                     arms.iter().map(|arm| arm.pat),\n-                );\n+                ));\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n@@ -390,15 +390,15 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         discr: &Expr<'_>,\n         discr_place: PlaceWithHirId<'tcx>,\n         pats: impl Iterator<Item = &'t hir::Pat<'t>>,\n-    ) {\n+    ) -> Result<(), ()> {\n         // Matching should not always be considered a use of the place, hence\n         // discr does not necessarily need to be borrowed.\n         // We only want to borrow discr if the pattern contain something other\n         // than wildcards.\n         let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n         let mut needs_to_be_read = false;\n         for pat in pats {\n-            return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n+            mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n                 match &pat.kind {\n                     PatKind::Binding(.., opt_sub_pat) => {\n                         // If the opt_sub_pat is None, than the binding does not count as\n@@ -453,7 +453,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         // examined\n                     }\n                 }\n-            }));\n+            })?\n         }\n \n         if needs_to_be_read {\n@@ -474,6 +474,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             // that the discriminant has been initialized.\n             self.walk_expr(discr);\n         }\n+        Ok(())\n     }\n \n     fn walk_local<F>(\n@@ -490,7 +491,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         f(self);\n         if let Some(els) = els {\n             // borrowing because we need to test the discriminant\n-            self.maybe_read_scrutinee(expr, expr_place.clone(), from_ref(pat).iter());\n+            return_if_err!(self.maybe_read_scrutinee(\n+                expr,\n+                expr_place.clone(),\n+                from_ref(pat).iter()\n+            ));\n             self.walk_block(els)\n         }\n         self.walk_irrefutable_pat(&expr_place, &pat);"}, {"sha": "952d2726259187c736488ccd827d17973b571ed7", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 10, "deletions": 49, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -16,7 +16,7 @@ use rustc_hir_analysis::astconv::{\n };\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n-use rustc_infer::infer::{InferOk, InferResult};\n+use rustc_infer::infer::InferResult;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -30,9 +30,8 @@ use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, ObligationCtxt};\n+use rustc_trait_selection::traits::{self, NormalizeExt, ObligationCauseCode, ObligationCtxt};\n \n use std::collections::hash_map::Entry;\n use std::slice;\n@@ -343,7 +342,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         debug!(\"instantiate_type_scheme(value={:?}, substs={:?})\", value, substs);\n         let value = EarlyBinder(value).subst(self.tcx, substs);\n-        let result = self.normalize_associated_types_in(span, value);\n+        let result = self.normalize(span, value);\n         debug!(\"instantiate_type_scheme = {:?}\", result);\n         result\n     }\n@@ -359,58 +358,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let bounds = self.tcx.predicates_of(def_id);\n         let spans: Vec<Span> = bounds.predicates.iter().map(|(_, span)| *span).collect();\n         let result = bounds.instantiate(self.tcx, substs);\n-        let result = self.normalize_associated_types_in(span, result);\n+        let result = self.normalize(span, result);\n         debug!(\n             \"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}, {:?}\",\n             bounds, substs, result, spans,\n         );\n         (result, spans)\n     }\n \n-    pub(in super::super) fn normalize_associated_types_in<T>(&self, span: Span, value: T) -> T\n+    pub(in super::super) fn normalize<T>(&self, span: Span, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.inh.normalize_associated_types_in(span, self.body_id, self.param_env, value)\n-    }\n-\n-    pub(in super::super) fn normalize_associated_types_in_as_infer_ok<T>(\n-        &self,\n-        span: Span,\n-        value: T,\n-    ) -> InferOk<'tcx, T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.inh.partially_normalize_associated_types_in(\n-            ObligationCause::misc(span, self.body_id),\n-            self.param_env,\n-            value,\n-        )\n-    }\n-\n-    pub(in super::super) fn normalize_op_associated_types_in_as_infer_ok<T>(\n-        &self,\n-        span: Span,\n-        value: T,\n-        opt_input_expr: Option<&hir::Expr<'_>>,\n-    ) -> InferOk<'tcx, T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.inh.partially_normalize_associated_types_in(\n-            ObligationCause::new(\n-                span,\n-                self.body_id,\n-                traits::BinOp {\n-                    rhs_span: opt_input_expr.map(|expr| expr.span),\n-                    is_lit: opt_input_expr\n-                        .map_or(false, |expr| matches!(expr.kind, ExprKind::Lit(_))),\n-                    output_ty: None,\n-                },\n-            ),\n-            self.param_env,\n-            value,\n+        self.register_infer_ok_obligations(\n+            self.at(&self.misc(span), self.param_env).normalize(value),\n         )\n     }\n \n@@ -490,7 +451,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let span = self.tcx.def_span(anon_const.def_id);\n                 let c = ty::Const::from_anon_const(self.tcx, anon_const.def_id);\n                 self.register_wf_obligation(c.into(), span, ObligationCauseCode::WellFormed(None));\n-                self.normalize_associated_types_in(span, c)\n+                self.normalize(span, c)\n             }\n         }\n     }\n@@ -583,7 +544,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: &'tcx ty::FieldDef,\n         substs: SubstsRef<'tcx>,\n     ) -> Ty<'tcx> {\n-        self.normalize_associated_types_in(span, field.ty(self.tcx, substs))\n+        self.normalize(span, field.ty(self.tcx, substs))\n     }\n \n     pub(in super::super) fn resolve_rvalue_scopes(&self, def_id: DefId) {\n@@ -1110,7 +1071,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Res::Local(hid) = res {\n             let ty = self.local_ty(span, hid).decl_ty;\n-            let ty = self.normalize_associated_types_in(span, ty);\n+            let ty = self.normalize(span, ty);\n             self.write_ty(hir_id, ty);\n             return (ty, res);\n         }"}, {"sha": "86384c7b93e717692b04087fe27038904e501673", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2089,7 +2089,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             && let maybe_trait_item_def_id = assoc_item.trait_item_def_id.unwrap_or(def_id)\n             && let maybe_trait_def_id = self.tcx.parent(maybe_trait_item_def_id)\n             // Just an easy way to check \"trait_def_id == Fn/FnMut/FnOnce\"\n-            && let Some(call_kind) = ty::ClosureKind::from_def_id(self.tcx, maybe_trait_def_id)\n+            && let Some(call_kind) = self.tcx.fn_trait_kind_from_def_id(maybe_trait_def_id)\n             && let Some(callee_ty) = callee_ty\n         {\n             let callee_ty = callee_ty.peel_refs();\n@@ -2115,7 +2115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         {\n                             if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = predicate.kind().skip_binder()\n                                 && pred.self_ty().peel_refs() == callee_ty\n-                                && ty::ClosureKind::from_def_id(self.tcx, pred.def_id()).is_some()\n+                                && self.tcx.is_fn_trait(pred.def_id())\n                             {\n                                 err.span_note(span, \"callable defined here\");\n                                 return;"}, {"sha": "ea141e815bf4a9c268d1f3652f20a795863c137b", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -288,7 +288,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         if ty.has_escaping_bound_vars() {\n             ty // FIXME: normalization and escaping regions\n         } else {\n-            self.normalize_associated_types_in(span, ty)\n+            self.normalize(span, ty)\n         }\n     }\n "}, {"sha": "b9a8d16311c93a7f0465c5035f37c95d19375ca8", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -20,6 +20,7 @@ use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n+use rustc_trait_selection::traits::NormalizeExt;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(crate) fn body_fn_sig(&self) -> Option<ty::FnSig<'tcx>> {\n@@ -245,7 +246,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // implied by wf, but also because that would possibly result in\n         // erroneous errors later on.\n         let infer::InferOk { value: output, obligations: _ } =\n-            self.normalize_associated_types_in_as_infer_ok(expr.span, output);\n+            self.at(&self.misc(expr.span), self.param_env).normalize(output);\n \n         if output.is_ty_var() { None } else { Some((def_id_or_name, output, inputs)) }\n     }\n@@ -759,7 +760,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n                 let bound_vars = self.tcx.late_bound_vars(fn_id);\n                 let ty = Binder::bind_with_vars(ty, bound_vars);\n-                let ty = self.normalize_associated_types_in(span, ty);\n+                let ty = self.normalize(span, ty);\n                 let ty = self.tcx.erase_late_bound_regions(ty);\n                 if self.can_coerce(expected, ty) {\n                     err.subdiagnostic(ExpectedReturnTypeLabel::Other { span, expected });\n@@ -920,7 +921,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n             let bound_vars = self.tcx.late_bound_vars(fn_id);\n             let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n-            let ty = self.normalize_associated_types_in(expr.span, ty);\n+            let ty = self.normalize(expr.span, ty);\n             let ty = match self.tcx.asyncness(fn_id.owner) {\n                 hir::IsAsync::Async => {\n                     let infcx = self.tcx.infer_ctxt().build();"}, {"sha": "3b1518ff79b4e8e0859f8436615258b3587ea096", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -118,7 +118,8 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 } else {\n                     let note = format!(\n                         \"the type is part of the {} because of this {}\",\n-                        self.kind, yield_data.source\n+                        self.kind.descr(),\n+                        yield_data.source\n                     );\n \n                     self.fcx\n@@ -234,7 +235,7 @@ pub fn resolve_interior<'a, 'tcx>(\n                 counter += 1;\n                 ty::BoundRegion { var, kind }\n             };\n-            let ty = fcx.normalize_associated_types_in(cause.span, cause.ty);\n+            let ty = fcx.normalize(cause.span, cause.ty);\n             let ty = fcx.tcx.fold_regions(ty, |region, current_depth| {\n                 let br = match region.kind() {\n                     ty::ReVar(vid) => {"}, {"sha": "869ad07c00d61a8511b55f28f9af7d9315907950", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 11, "deletions": 44, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -7,12 +7,10 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n use rustc_infer::infer;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, InferOk, TyCtxtInferExt};\n-use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefIdMap;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCtxt, TraitEngine, TraitEngineExt as _,\n };\n@@ -38,19 +36,19 @@ pub struct Inherited<'tcx> {\n \n     pub(super) fulfillment_cx: RefCell<Box<dyn TraitEngine<'tcx>>>,\n \n-    // Some additional `Sized` obligations badly affect type inference.\n-    // These obligations are added in a later stage of typeck.\n-    // Removing these may also cause additional complications, see #101066.\n+    /// Some additional `Sized` obligations badly affect type inference.\n+    /// These obligations are added in a later stage of typeck.\n+    /// Removing these may also cause additional complications, see #101066.\n     pub(super) deferred_sized_obligations:\n         RefCell<Vec<(Ty<'tcx>, Span, traits::ObligationCauseCode<'tcx>)>>,\n \n-    // When we process a call like `c()` where `c` is a closure type,\n-    // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n-    // `FnOnce` closure. In that case, we defer full resolution of the\n-    // call until upvar inference can kick in and make the\n-    // decision. We keep these deferred resolutions grouped by the\n-    // def-id of the closure, so that once we decide, we can easily go\n-    // back and process them.\n+    /// When we process a call like `c()` where `c` is a closure type,\n+    /// we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n+    /// `FnOnce` closure. In that case, we defer full resolution of the\n+    /// call until upvar inference can kick in and make the\n+    /// decision. We keep these deferred resolutions grouped by the\n+    /// def-id of the closure, so that once we decide, we can easily go\n+    /// back and process them.\n     pub(super) deferred_call_resolutions: RefCell<LocalDefIdMap<Vec<DeferredCallResolution<'tcx>>>>,\n \n     pub(super) deferred_cast_checks: RefCell<Vec<super::cast::CastCheck<'tcx>>>,\n@@ -102,7 +100,7 @@ impl<'tcx> Inherited<'tcx> {\n                     infcx.probe(|_| {\n                         let ocx = ObligationCtxt::new_in_snapshot(infcx);\n                         let normalized_fn_sig = ocx.normalize(\n-                            ObligationCause::dummy(),\n+                            &ObligationCause::dummy(),\n                             // FIXME(compiler-errors): This is probably not the right param-env...\n                             infcx.tcx.param_env(def_id),\n                             fn_sig,\n@@ -179,35 +177,4 @@ impl<'tcx> Inherited<'tcx> {\n         self.register_predicates(infer_ok.obligations);\n         infer_ok.value\n     }\n-\n-    pub(super) fn normalize_associated_types_in<T>(\n-        &self,\n-        span: Span,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.normalize_associated_types_in_with_cause(\n-            ObligationCause::misc(span, body_id),\n-            param_env,\n-            value,\n-        )\n-    }\n-\n-    pub(super) fn normalize_associated_types_in_with_cause<T>(\n-        &self,\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let ok = self.partially_normalize_associated_types_in(cause, param_env, value);\n-        debug!(?ok);\n-        self.register_infer_ok_obligations(ok)\n-    }\n }"}, {"sha": "09bd123350dfd1e3f794a4f7e13210a7acf50f3e", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -233,9 +233,10 @@ fn typeck_with_fallback<'tcx>(\n \n     let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n-        let mut fcx = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n+        let mut fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n+\n+        if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n             let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n-                let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n                 <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n             } else {\n                 tcx.fn_sig(def_id)\n@@ -245,15 +246,10 @@ fn typeck_with_fallback<'tcx>(\n \n             // Compute the function signature from point of view of inside the fn.\n             let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n-            let fn_sig = inh.normalize_associated_types_in(\n-                body.value.span,\n-                body_id.hir_id,\n-                param_env,\n-                fn_sig,\n-            );\n-            check_fn(&inh, param_env, fn_sig, decl, def_id, body, None).0\n+            let fn_sig = fcx.normalize(body.value.span, fn_sig);\n+\n+            check_fn(&mut fcx, fn_sig, decl, def_id, body, None);\n         } else {\n-            let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n             let expected_type = body_ty\n                 .and_then(|ty| match ty.kind {\n                     hir::TyKind::Infer => Some(<dyn AstConv<'_>>::ast_ty_to_ty(&fcx, ty)),\n@@ -304,7 +300,7 @@ fn typeck_with_fallback<'tcx>(\n                     _ => fallback(),\n                 });\n \n-            let expected_type = fcx.normalize_associated_types_in(body.value.span, expected_type);\n+            let expected_type = fcx.normalize(body.value.span, expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n             // Gather locals in statics (because of block expressions).\n@@ -313,8 +309,6 @@ fn typeck_with_fallback<'tcx>(\n             fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n \n             fcx.write_ty(id, expected_type);\n-\n-            fcx\n         };\n \n         fcx.type_inference_fallback();"}, {"sha": "03d0e7926de1166fc5103cc7f0167ea4eb153048", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -106,15 +106,15 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // traits, no trait system method can be called before this point because they\n         // could alter our Self-type, except for normalizing the receiver from the\n         // signature (which is also done during probing).\n-        let method_sig_rcvr = self.normalize_associated_types_in(self.span, method_sig.inputs()[0]);\n+        let method_sig_rcvr = self.normalize(self.span, method_sig.inputs()[0]);\n         debug!(\n             \"confirm: self_ty={:?} method_sig_rcvr={:?} method_sig={:?} method_predicates={:?}\",\n             self_ty, method_sig_rcvr, method_sig, method_predicates\n         );\n         self.unify_receivers(self_ty, method_sig_rcvr, &pick, all_substs);\n \n         let (method_sig, method_predicates) =\n-            self.normalize_associated_types_in(self.span, (method_sig, method_predicates));\n+            self.normalize(self.span, (method_sig, method_predicates));\n         let method_sig = ty::Binder::dummy(method_sig);\n \n         // Make sure nobody calls `drop()` explicitly."}, {"sha": "ebbd5eb1e6478cafdb717373c908f1f5724ff01b", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -23,8 +23,8 @@ use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, Ty, TypeVisitable};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n-use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, NormalizeExt};\n \n use self::probe::{IsSuggestion, ProbeScope};\n \n@@ -465,11 +465,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n         let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig);\n \n-        let InferOk { value, obligations: o } = if is_op {\n-            self.normalize_op_associated_types_in_as_infer_ok(span, fn_sig, opt_input_expr)\n+        let cause = if is_op {\n+            ObligationCause::new(\n+                span,\n+                self.body_id,\n+                traits::BinOp {\n+                    rhs_span: opt_input_expr.map(|expr| expr.span),\n+                    is_lit: opt_input_expr\n+                        .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                    output_ty: None,\n+                },\n+            )\n         } else {\n-            self.normalize_associated_types_in_as_infer_ok(span, fn_sig)\n+            traits::ObligationCause::misc(span, self.body_id)\n         };\n+\n+        let InferOk { value, obligations: o } = self.at(&cause, self.param_env).normalize(fn_sig);\n         let fn_sig = {\n             obligations.extend(o);\n             value\n@@ -485,32 +496,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // any late-bound regions appearing in its bounds.\n         let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n \n-        let InferOk { value, obligations: o } = if is_op {\n-            self.normalize_op_associated_types_in_as_infer_ok(span, bounds, opt_input_expr)\n-        } else {\n-            self.normalize_associated_types_in_as_infer_ok(span, bounds)\n-        };\n+        let InferOk { value, obligations: o } = self.at(&cause, self.param_env).normalize(bounds);\n         let bounds = {\n             obligations.extend(o);\n             value\n         };\n \n         assert!(!bounds.has_escaping_bound_vars());\n \n-        let cause = if is_op {\n-            ObligationCause::new(\n-                span,\n-                self.body_id,\n-                traits::BinOp {\n-                    rhs_span: opt_input_expr.map(|expr| expr.span),\n-                    is_lit: opt_input_expr\n-                        .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                    output_ty: None,\n-                },\n-            )\n-        } else {\n-            traits::ObligationCause::misc(span, self.body_id)\n-        };\n         let predicates_cause = cause.clone();\n         obligations.extend(traits::predicates_for_generics(\n             move |_, _| predicates_cause.clone(),"}, {"sha": "c78a32c29dcdafe1bba9f32eaf3bc0b4e5d25cea", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -31,13 +31,13 @@ use rustc_span::lev_distance::{\n use rustc_span::symbol::sym;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::autoderef::{self, Autoderef};\n-use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::query::method_autoderef::MethodAutoderefBadTy;\n use rustc_trait_selection::traits::query::method_autoderef::{\n     CandidateStep, MethodAutoderefStepsResult,\n };\n use rustc_trait_selection::traits::query::CanonicalTyGoal;\n+use rustc_trait_selection::traits::NormalizeExt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n use std::cmp::max;\n use std::iter;\n@@ -343,10 +343,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             &mut orig_values,\n         );\n \n-        let steps = if mode == Mode::MethodCall {\n-            self.tcx.method_autoderef_steps(param_env_and_self_ty)\n-        } else {\n-            self.probe(|_| {\n+        let steps = match mode {\n+            Mode::MethodCall => self.tcx.method_autoderef_steps(param_env_and_self_ty),\n+            Mode::Path => self.probe(|_| {\n                 // Mode::Path - the deref steps is \"trivial\". This turns\n                 // our CanonicalQuery into a \"trivial\" QueryResponse. This\n                 // is a bit inefficient, but I don't think that writing\n@@ -375,7 +374,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     opt_bad_ty: None,\n                     reached_recursion_limit: false,\n                 }\n-            })\n+            }),\n         };\n \n         // If our autoderef loop had reached the recursion limit,\n@@ -717,9 +716,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // maybe shouldn't include `Param`s, but rather fresh variables or be canonicalized,\n             // see issue #89650\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-            let InferOk { value: xform_self_ty, obligations } = self\n-                .fcx\n-                .partially_normalize_associated_types_in(cause, self.param_env, xform_self_ty);\n+            let InferOk { value: xform_self_ty, obligations } =\n+                self.fcx.at(&cause, self.param_env).normalize(xform_self_ty);\n \n             debug!(\n                 \"assemble_inherent_impl_probe after normalization: xform_self_ty = {:?}/{:?}\",\n@@ -1508,11 +1506,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     let InferOk {\n                         value: normalized_xform_ret_ty,\n                         obligations: normalization_obligations,\n-                    } = self.fcx.partially_normalize_associated_types_in(\n-                        cause.clone(),\n-                        self.param_env,\n-                        probe.xform_ret_ty,\n-                    );\n+                    } = self.fcx.at(&cause, self.param_env).normalize(probe.xform_ret_ty);\n                     xform_ret_ty = normalized_xform_ret_ty;\n                     debug!(\"xform_ret_ty after normalization: {:?}\", xform_ret_ty);\n \n@@ -1522,11 +1516,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n \n                     let InferOk { value: impl_bounds, obligations: norm_obligations } =\n-                        self.fcx.partially_normalize_associated_types_in(\n-                            cause.clone(),\n-                            self.param_env,\n-                            impl_bounds,\n-                        );\n+                        self.fcx.at(&cause, self.param_env).normalize(impl_bounds);\n \n                     // Convert the bounds into obligations.\n                     let impl_obligations = traits::predicates_for_generics("}, {"sha": "0f46972019e522f7cd9f312c36958a8e5885d658", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2168,7 +2168,7 @@ fn determine_place_ancestry_relation<'tcx>(\n     place_a: &Place<'tcx>,\n     place_b: &Place<'tcx>,\n ) -> PlaceAncestryRelation {\n-    // If Place A and Place B, don't start off from the same root variable, they are divergent.\n+    // If Place A and Place B don't start off from the same root variable, they are divergent.\n     if place_a.base != place_b.base {\n         return PlaceAncestryRelation::Divergent;\n     }"}, {"sha": "a8acaf6597aaba3064b261dc005ac964ee241598", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -438,9 +438,9 @@ fn expect_associated_value(tcx: TyCtxt<'_>, item: &NestedMetaItem) -> Symbol {\n     }\n }\n \n-// A visitor that collects all #[rustc_clean] attributes from\n-// the HIR. It is used to verify that we really ran checks for all annotated\n-// nodes.\n+/// A visitor that collects all `#[rustc_clean]` attributes from\n+/// the HIR. It is used to verify that we really ran checks for all annotated\n+/// nodes.\n pub struct FindAllAttrs<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     found_attrs: Vec<&'tcx Attribute>,"}, {"sha": "e59715b706b29c0c4da6afde7ba99fe9b5a3f737", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -41,7 +41,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// inference variables and applies it to the canonical value.\n     /// Returns both the instantiated result *and* the substitution S.\n     ///\n-    /// This is only meant to be invoked as part of constructing an\n+    /// This can be invoked as part of constructing an\n     /// inference context at the start of a query (see\n     /// `InferCtxtBuilder::build_with_canonical`). It basically\n     /// brings the canonical value \"into scope\" within your new infcx.\n@@ -63,8 +63,11 @@ impl<'tcx> InferCtxt<'tcx> {\n         // in them, so this code has no effect, but it is looking\n         // forward to the day when we *do* want to carry universes\n         // through into queries.\n-        let universes: IndexVec<ty::UniverseIndex, _> = std::iter::once(ty::UniverseIndex::ROOT)\n-            .chain((0..canonical.max_universe.as_u32()).map(|_| self.create_next_universe()))\n+        //\n+        // Instantiate the root-universe content into the current universe,\n+        // and create fresh universes for the higher universes.\n+        let universes: IndexVec<ty::UniverseIndex, _> = std::iter::once(self.universe())\n+            .chain((1..=canonical.max_universe.as_u32()).map(|_| self.create_next_universe()))\n             .collect();\n \n         let canonical_inference_vars =\n@@ -147,7 +150,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             CanonicalVarKind::PlaceholderConst(ty::PlaceholderConst { universe, name }, ty) => {\n                 let universe_mapped = universe_map(universe);\n                 let placeholder_mapped = ty::PlaceholderConst { universe: universe_mapped, name };\n-                self.tcx.mk_const(ty::ConstKind::Placeholder(placeholder_mapped), ty).into()\n+                self.tcx.mk_const(placeholder_mapped, ty).into()\n             }\n         }\n     }"}, {"sha": "cf895ed0d3e598ba23eb5effcb52345e75982045", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -753,7 +753,7 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                                 origin: var_value.origin,\n                                 val: ConstVariableValue::Unknown { universe: self.for_universe },\n                             });\n-                            Ok(self.tcx().mk_const_var(new_var_id, c.ty()))\n+                            Ok(self.tcx().mk_const(new_var_id, c.ty()))\n                         }\n                     }\n                 }\n@@ -765,10 +765,7 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     substs,\n                     substs,\n                 )?;\n-                Ok(self.tcx().mk_const(\n-                    ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }),\n-                    c.ty(),\n-                ))\n+                Ok(self.tcx().mk_const(ty::UnevaluatedConst { def, substs }, c.ty()))\n             }\n             _ => relate::super_relate_consts(self, c, c),\n         }\n@@ -975,7 +972,7 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                                         },\n                                     },\n                                 );\n-                            Ok(self.tcx().mk_const_var(new_var_id, c.ty()))\n+                            Ok(self.tcx().mk_const(new_var_id, c.ty()))\n                         }\n                     }\n                 }\n@@ -988,10 +985,7 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                     substs,\n                 )?;\n \n-                Ok(self.tcx().mk_const(\n-                    ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }),\n-                    c.ty(),\n-                ))\n+                Ok(self.tcx().mk_const(ty::UnevaluatedConst { def, substs }, c.ty()))\n             }\n             _ => relate::super_relate_consts(self, c, c),\n         }"}, {"sha": "e2be8fb12d0d0d976c877a73a1cde0b18bfdc07c", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1672,40 +1672,34 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             }\n         };\n \n-        match terr {\n-            // Ignore msg for object safe coercion\n-            // since E0038 message will be printed\n-            TypeError::ObjectUnsafeCoercion(_) => {}\n-            _ => {\n-                let mut label_or_note = |span: Span, msg: &str| {\n-                    if (prefer_label && is_simple_error) || &[span] == diag.span.primary_spans() {\n-                        diag.span_label(span, msg);\n-                    } else {\n-                        diag.span_note(span, msg);\n-                    }\n-                };\n-                if let Some((sp, msg)) = secondary_span {\n-                    if swap_secondary_and_primary {\n-                        let terr = if let Some(infer::ValuePairs::Terms(infer::ExpectedFound {\n-                            expected,\n-                            ..\n-                        })) = values\n-                        {\n-                            format!(\"expected this to be `{}`\", expected)\n-                        } else {\n-                            terr.to_string()\n-                        };\n-                        label_or_note(sp, &terr);\n-                        label_or_note(span, &msg);\n-                    } else {\n-                        label_or_note(span, &terr.to_string());\n-                        label_or_note(sp, &msg);\n-                    }\n-                } else {\n-                    label_or_note(span, &terr.to_string());\n-                }\n+        let mut label_or_note = |span: Span, msg: &str| {\n+            if (prefer_label && is_simple_error) || &[span] == diag.span.primary_spans() {\n+                diag.span_label(span, msg);\n+            } else {\n+                diag.span_note(span, msg);\n             }\n         };\n+        if let Some((sp, msg)) = secondary_span {\n+            if swap_secondary_and_primary {\n+                let terr = if let Some(infer::ValuePairs::Terms(infer::ExpectedFound {\n+                    expected,\n+                    ..\n+                })) = values\n+                {\n+                    format!(\"expected this to be `{}`\", expected)\n+                } else {\n+                    terr.to_string()\n+                };\n+                label_or_note(sp, &terr);\n+                label_or_note(span, &msg);\n+            } else {\n+                label_or_note(span, &terr.to_string());\n+                label_or_note(sp, &msg);\n+            }\n+        } else {\n+            label_or_note(span, &terr.to_string());\n+        }\n+\n         if let Some((expected, found)) = expected_found {\n             let (expected_label, found_label, exp_found) = match exp_found {\n                 Mismatch::Variable(ef) => (\n@@ -1875,9 +1869,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         );\n                     }\n                 }\n-                TypeError::ObjectUnsafeCoercion(_) => {\n-                    diag.note_unsuccessful_coercion(found, expected);\n-                }\n                 _ => {\n                     debug!(\n                         \"note_type_err: exp_found={:?}, expected={:?} found={:?}\",\n@@ -3122,7 +3113,6 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n                 TypeError::IntrinsicCast => {\n                     Error0308(\"cannot coerce intrinsics to function pointers\")\n                 }\n-                TypeError::ObjectUnsafeCoercion(did) => Error0038(did),\n                 _ => Error0308(\"mismatched types\"),\n             },\n         }"}, {"sha": "1f554c81eff8e1941453d2f0a544ec245cd16d51", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -399,10 +399,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n \n                 if self_ty.value.is_closure()\n-                    && self\n-                        .tcx()\n-                        .fn_trait_kind_from_lang_item(expected_trait_ref.value.def_id)\n-                        .is_some()\n+                    && self.tcx().is_fn_trait(expected_trait_ref.value.def_id)\n                 {\n                     let closure_sig = self_ty.map(|closure| {\n                         if let ty::Closure(_, substs) = closure.kind() {"}, {"sha": "2402a7ea7c741be7bae0441777b0345129f6f521", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -29,10 +29,10 @@ impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct FreeRegionMap<'tcx> {\n-    // Stores the relation `a < b`, where `a` and `b` are regions.\n-    //\n-    // Invariant: only free regions like `'x` or `'static` are stored\n-    // in this relation, not scopes.\n+    /// Stores the relation `a < b`, where `a` and `b` are regions.\n+    ///\n+    /// Invariant: only free regions like `'x` or `'static` are stored\n+    /// in this relation, not scopes.\n     pub(crate) relation: TransitiveRelation<Region<'tcx>>,\n }\n "}, {"sha": "f6946929bd23f58dbdd62d37fbbcedb6572f3831", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -102,7 +102,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n             Entry::Vacant(entry) => {\n                 let index = self.const_freshen_count;\n                 self.const_freshen_count += 1;\n-                let ct = self.infcx.tcx.mk_const_infer(freshener(index), ty);\n+                let ct = self.infcx.tcx.mk_const(freshener(index), ty);\n                 entry.insert(ct);\n                 ct\n             }"}, {"sha": "817ae10c7608712d9c3d581ceff14586e73ee990", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -94,13 +94,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                 }))\n             },\n             consts: &mut |bound_var: ty::BoundVar, ty| {\n-                self.tcx.mk_const(\n-                    ty::ConstKind::Placeholder(ty::PlaceholderConst {\n-                        universe: next_universe,\n-                        name: bound_var,\n-                    }),\n-                    ty,\n-                )\n+                self.tcx\n+                    .mk_const(ty::PlaceholderConst { universe: next_universe, name: bound_var }, ty)\n             },\n         };\n "}, {"sha": "2bcb47cc38399f85b07436e792a707f3ab68bf1f", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1065,7 +1065,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     }\n \n     pub fn next_const_var(&self, ty: Ty<'tcx>, origin: ConstVariableOrigin) -> ty::Const<'tcx> {\n-        self.tcx.mk_const_var(self.next_const_var_id(origin), ty)\n+        self.tcx.mk_const(self.next_const_var_id(origin), ty)\n     }\n \n     pub fn next_const_var_in_universe(\n@@ -1079,7 +1079,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             .borrow_mut()\n             .const_unification_table()\n             .new_key(ConstVarValue { origin, val: ConstVariableValue::Unknown { universe } });\n-        self.tcx.mk_const_var(vid, ty)\n+        self.tcx.mk_const(vid, ty)\n     }\n \n     pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n@@ -1195,7 +1195,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                         origin,\n                         val: ConstVariableValue::Unknown { universe: self.universe() },\n                     });\n-                self.tcx.mk_const_var(const_var_id, self.tcx.type_of(param.def_id)).into()\n+                self.tcx.mk_const(const_var_id, self.tcx.type_of(param.def_id)).into()\n             }\n         }\n     }\n@@ -1580,7 +1580,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         span: Option<Span>,\n     ) -> Result<ty::Const<'tcx>, ErrorHandled> {\n         match self.const_eval_resolve(param_env, unevaluated, span) {\n-            Ok(Some(val)) => Ok(ty::Const::from_value(self.tcx, val, ty)),\n+            Ok(Some(val)) => Ok(self.tcx.mk_const(val, ty)),\n             Ok(None) => {\n                 let tcx = self.tcx;\n                 let def_id = unevaluated.def.did;\n@@ -2049,10 +2049,10 @@ fn replace_param_and_infer_substs_with_placeholder<'tcx>(\n                     bug!(\"const `{ct}`'s type should not reference params or types\");\n                 }\n                 tcx.mk_const(\n-                    ty::ConstKind::Placeholder(ty::PlaceholderConst {\n+                    ty::PlaceholderConst {\n                         universe: ty::UniverseIndex::ROOT,\n                         name: ty::BoundVar::from_usize(idx),\n-                    }),\n+                    },\n                     ty,\n                 )\n                 .into()"}, {"sha": "f6bc4db0d59dfc5466f3927e3a6c10ce55d552c3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1087,7 +1087,7 @@ where\n                             origin: var_value.origin,\n                             val: ConstVariableValue::Unknown { universe: self.universe },\n                         });\n-                        Ok(self.tcx().mk_const_var(new_var_id, a.ty()))\n+                        Ok(self.tcx().mk_const(new_var_id, a.ty()))\n                     }\n                 }\n             }"}, {"sha": "524f7a39ebbfb8f72077340dd534b13d8aafa330", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -410,19 +410,19 @@ impl<'tcx> InferCtxt<'tcx> {\n     }\n }\n \n-// Visitor that requires that (almost) all regions in the type visited outlive\n-// `least_region`. We cannot use `push_outlives_components` because regions in\n-// closure signatures are not included in their outlives components. We need to\n-// ensure all regions outlive the given bound so that we don't end up with,\n-// say, `ReVar` appearing in a return type and causing ICEs when other\n-// functions end up with region constraints involving regions from other\n-// functions.\n-//\n-// We also cannot use `for_each_free_region` because for closures it includes\n-// the regions parameters from the enclosing item.\n-//\n-// We ignore any type parameters because impl trait values are assumed to\n-// capture all the in-scope type parameters.\n+/// Visitor that requires that (almost) all regions in the type visited outlive\n+/// `least_region`. We cannot use `push_outlives_components` because regions in\n+/// closure signatures are not included in their outlives components. We need to\n+/// ensure all regions outlive the given bound so that we don't end up with,\n+/// say, `ReVar` appearing in a return type and causing ICEs when other\n+/// functions end up with region constraints involving regions from other\n+/// functions.\n+///\n+/// We also cannot use `for_each_free_region` because for closures it includes\n+/// the regions parameters from the enclosing item.\n+///\n+/// We ignore any type parameters because impl trait values are assumed to\n+/// capture all the in-scope type parameters.\n pub struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP: FnMut(ty::Region<'tcx>)> {\n     pub tcx: TyCtxt<'tcx>,\n     pub op: OP,"}, {"sha": "c146902d594afd3410c42de40e99f6f926045207", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -9,10 +9,10 @@ use super::{OpaqueTypeDecl, OpaqueTypeMap};\n \n #[derive(Default, Debug, Clone)]\n pub struct OpaqueTypeStorage<'tcx> {\n-    // Opaque types found in explicit return types and their\n-    // associated fresh inference variable. Writeback resolves these\n-    // variables to get the concrete type, which can be used to\n-    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n+    /// Opaque types found in explicit return types and their\n+    /// associated fresh inference variable. Writeback resolves these\n+    /// variables to get the concrete type, which can be used to\n+    /// 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n     pub opaque_types: OpaqueTypeMap<'tcx>,\n }\n "}, {"sha": "10b474efd5aebdc9337b0a3d863fa04d0badc674", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -155,14 +155,17 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         bug!()\n     }\n \n+    #[instrument(level = \"trace\", skip(self))]\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n-        _: ty::Variance,\n+        variance: ty::Variance,\n         _: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n-        self.relate(a, b)\n+        // Opaque types substs have lifetime parameters.\n+        // We must not check them to be equal, as we never insert anything to make them so.\n+        if variance != ty::Bivariant { self.relate(a, b) } else { Ok(a) }\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "4c22ab68a5681f227aa4a644c64a346be1689311", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -194,7 +194,7 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n \n                                         for val in values {\n                                             if let Some(LitKind::Str(s, _)) =\n-                                                val.literal().map(|lit| &lit.kind)\n+                                                val.lit().map(|lit| &lit.kind)\n                                             {\n                                                 ident_values.insert(s.to_string());\n                                             } else {"}, {"sha": "825093384fba7f4688948e4f1eb963decf7fc9e3", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2046,16 +2046,13 @@ declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMEN\n \n impl ExplicitOutlivesRequirements {\n     fn lifetimes_outliving_lifetime<'tcx>(\n-        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n+        inferred_outlives: &'tcx [(ty::Clause<'tcx>, Span)],\n         def_id: DefId,\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n-                    a,\n-                    b,\n-                ))) => match *a {\n+            .filter_map(|(clause, _)| match *clause {\n+                ty::Clause::RegionOutlives(ty::OutlivesPredicate(a, b)) => match *a {\n                     ty::ReEarlyBound(ebr) if ebr.def_id == def_id => Some(b),\n                     _ => None,\n                 },\n@@ -2065,16 +2062,15 @@ impl ExplicitOutlivesRequirements {\n     }\n \n     fn lifetimes_outliving_type<'tcx>(\n-        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n+        inferred_outlives: &'tcx [(ty::Clause<'tcx>, Span)],\n         index: u32,\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                    a,\n-                    b,\n-                ))) => a.is_param(index).then_some(b),\n+            .filter_map(|(clause, _)| match *clause {\n+                ty::Clause::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n+                    a.is_param(index).then_some(b)\n+                }\n                 _ => None,\n             })\n             .collect()"}, {"sha": "e6a0d7e60ca772b10cd67b0630dbdc50724a4907", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -206,7 +206,7 @@ impl LintStore {\n         self.late_module_passes.push(Box::new(pass));\n     }\n \n-    // Helper method for register_early/late_pass\n+    /// Helper method for register_early/late_pass\n     pub fn register_lints(&mut self, lints: &[&'static Lint]) {\n         for lint in lints {\n             self.lints.push(lint);"}, {"sha": "4f92661dbd3342198d286c717b67a26bd7039bf6", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n     fn check_path(\n         &mut self,\n         cx: &LateContext<'tcx>,\n-        path: &'tcx rustc_hir::Path<'tcx>,\n+        path: &rustc_hir::Path<'tcx>,\n         _: rustc_hir::HirId,\n     ) {\n         if let Some(segment) = path.segments.iter().nth_back(1)\n@@ -462,8 +462,8 @@ impl LateLintPass<'_> for BadOptAccess {\n                 let Some(attr) = cx.tcx.get_attr(field.did, sym::rustc_lint_opt_deny_field_access) &&\n                 let Some(items) = attr.meta_item_list()  &&\n                 let Some(item) = items.first()  &&\n-                let Some(literal) = item.literal()  &&\n-                let ast::LitKind::Str(val, _) = literal.kind\n+                let Some(lit) = item.lit()  &&\n+                let ast::LitKind::Str(val, _) = lit.kind\n             {\n                 cx.struct_span_lint(BAD_OPT_ACCESS, expr.span, val.as_str(), |lint|\n                     lint"}, {"sha": "1d0b3f34d5d7830f2dfe6e19a2ca81bebdf173d0", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -292,7 +292,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         hir_visit::walk_lifetime(self, lt);\n     }\n \n-    fn visit_path(&mut self, p: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n+    fn visit_path(&mut self, p: &hir::Path<'tcx>, id: hir::HirId) {\n         lint_callback!(self, check_path, p, id);\n         hir_visit::walk_path(self, p);\n     }"}, {"sha": "fc11d092ccb4b084b26b2315e64206c414aef7a3", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -44,7 +44,7 @@ macro_rules! late_lint_methods {\n             fn check_struct_def(a: &$hir hir::VariantData<$hir>);\n             fn check_field_def(a: &$hir hir::FieldDef<$hir>);\n             fn check_variant(a: &$hir hir::Variant<$hir>);\n-            fn check_path(a: &$hir hir::Path<$hir>, b: hir::HirId);\n+            fn check_path(a: &hir::Path<$hir>, b: hir::HirId);\n             fn check_attribute(a: &$hir ast::Attribute);\n \n             /// Called when entering a syntax node that can have lint attributes such"}, {"sha": "a7836ea8e7a4bc5fdd6136e612d92ec28dbdc542", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -322,10 +322,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 ty::Closure(..) => Some(MustUsePath::Closure(span)),\n                 ty::Generator(def_id, ..) => {\n                     // async fn should be treated as \"implementor of `Future`\"\n-                    let must_use = if matches!(\n-                        cx.tcx.generator_kind(def_id),\n-                        Some(hir::GeneratorKind::Async(..))\n-                    ) {\n+                    let must_use = if cx.tcx.generator_is_async(def_id) {\n                         let def_id = cx.tcx.lang_items().future_trait().unwrap();\n                         is_def_must_use(cx, def_id, span)\n                             .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n@@ -1267,7 +1264,7 @@ impl UnusedImportBraces {\n \n             // Trigger the lint if the nested item is a non-self single item\n             let node_name = match items[0].0.kind {\n-                ast::UseTreeKind::Simple(rename, ..) => {\n+                ast::UseTreeKind::Simple(rename) => {\n                     let orig_ident = items[0].0.prefix.segments.last().unwrap().ident;\n                     if orig_ident.name == kw::SelfLower {\n                         return;"}, {"sha": "4047969724aa93bcca3ea9e9a9a54f45f2b26e9d", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -114,6 +114,9 @@ struct QueryModifiers {\n \n     /// Always remap the ParamEnv's constness before hashing.\n     remap_env_constness: Option<Ident>,\n+\n+    /// Generate a `feed` method to set the query's value from another query.\n+    feedable: Option<Ident>,\n }\n \n fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n@@ -128,6 +131,7 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n     let mut depth_limit = None;\n     let mut separate_provide_extern = None;\n     let mut remap_env_constness = None;\n+    let mut feedable = None;\n \n     while !input.is_empty() {\n         let modifier: Ident = input.parse()?;\n@@ -187,6 +191,8 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n             try_insert!(separate_provide_extern = modifier);\n         } else if modifier == \"remap_env_constness\" {\n             try_insert!(remap_env_constness = modifier);\n+        } else if modifier == \"feedable\" {\n+            try_insert!(feedable = modifier);\n         } else {\n             return Err(Error::new(modifier.span(), \"unknown query modifier\"));\n         }\n@@ -206,6 +212,7 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n         depth_limit,\n         separate_provide_extern,\n         remap_env_constness,\n+        feedable,\n     })\n }\n \n@@ -296,6 +303,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut query_stream = quote! {};\n     let mut query_description_stream = quote! {};\n     let mut query_cached_stream = quote! {};\n+    let mut feedable_queries = quote! {};\n \n     for query in queries.0 {\n         let Query { name, arg, modifiers, .. } = &query;\n@@ -350,6 +358,22 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             [#attribute_stream] fn #name(#arg) #result,\n         });\n \n+        if modifiers.feedable.is_some() {\n+            assert!(modifiers.anon.is_none(), \"Query {name} cannot be both `feedable` and `anon`.\");\n+            assert!(\n+                modifiers.eval_always.is_none(),\n+                \"Query {name} cannot be both `feedable` and `eval_always`.\"\n+            );\n+            assert!(\n+                modifiers.no_hash.is_none(),\n+                \"Query {name} cannot be both `feedable` and `no_hash`.\"\n+            );\n+            feedable_queries.extend(quote! {\n+                #(#doc_comments)*\n+                [#attribute_stream] fn #name(#arg) #result,\n+            });\n+        }\n+\n         add_query_desc_cached_impl(&query, &mut query_description_stream, &mut query_cached_stream);\n     }\n \n@@ -363,7 +387,11 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 }\n             }\n         }\n-\n+        macro_rules! rustc_feedable_queries {\n+            ( $macro:ident! ) => {\n+                $macro!(#feedable_queries);\n+            }\n+        }\n         pub mod descs {\n             use super::*;\n             #query_description_stream"}, {"sha": "1fd35adf1bd2cc4c4ac7f865e10d55d0d1a04b82", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -29,11 +29,11 @@ use std::path::PathBuf;\n \n pub fn find_native_static_library(\n     name: &str,\n-    verbatim: Option<bool>,\n+    verbatim: bool,\n     search_paths: &[PathBuf],\n     sess: &Session,\n ) -> PathBuf {\n-    let formats = if verbatim.unwrap_or(false) {\n+    let formats = if verbatim {\n         vec![(\"\".into(), \"\".into())]\n     } else {\n         let os = (sess.target.staticlib_prefix.clone(), sess.target.staticlib_suffix.clone());\n@@ -52,7 +52,7 @@ pub fn find_native_static_library(\n         }\n     }\n \n-    sess.emit_fatal(MissingNativeLibrary::new(name, verbatim.unwrap_or(false)));\n+    sess.emit_fatal(MissingNativeLibrary::new(name, verbatim));\n }\n \n fn find_bundled_library(\n@@ -66,7 +66,7 @@ fn find_bundled_library(\n             let NativeLibKind::Static { bundle: Some(true) | None, .. } = kind {\n         find_native_static_library(\n             name.unwrap().as_str(),\n-            verbatim,\n+            verbatim.unwrap_or(false),\n             &sess.target_filesearch(PathKind::Native).search_path_dirs(),\n             sess,\n         ).file_name().and_then(|s| s.to_str()).map(Symbol::intern)\n@@ -311,10 +311,7 @@ impl<'tcx> Collector<'tcx> {\n                             sess.emit_err(BundleNeedsStatic { span });\n                         }\n \n-                        (\"verbatim\", _) => {\n-                            report_unstable_modifier!(native_link_modifiers_verbatim);\n-                            assign_modifier(&mut verbatim)\n-                        }\n+                        (\"verbatim\", _) => assign_modifier(&mut verbatim),\n \n                         (\"whole-archive\", Some(NativeLibKind::Static { whole_archive, .. })) => {\n                             assign_modifier(whole_archive)"}, {"sha": "af7b0793a957413b38283188befe5def41f1e234", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -67,10 +67,10 @@ impl std::ops::Deref for MetadataBlob {\n     }\n }\n \n-// A map from external crate numbers (as decoded from some crate file) to\n-// local crate numbers (as generated during this session). Each external\n-// crate may refer to types in other external crates, and each has their\n-// own crate numbers.\n+/// A map from external crate numbers (as decoded from some crate file) to\n+/// local crate numbers (as generated during this session). Each external\n+/// crate may refer to types in other external crates, and each has their\n+/// own crate numbers.\n pub(crate) type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n pub(crate) struct CrateMetadata {"}, {"sha": "6b60577c9023fff91ffa1fa29675a9523afa3be3", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -353,7 +353,7 @@ define_tables! {\n     explicit_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     generics_of: Table<DefIndex, LazyValue<ty::Generics>>,\n     // As an optimization, a missing entry indicates an empty `&[]`.\n-    inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Predicate<'static>, Span)>>,\n+    inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Clause<'static>, Span)>>,\n     super_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     type_of: Table<DefIndex, LazyValue<Ty<'static>>>,\n     variances_of: Table<DefIndex, LazyArray<ty::Variance>>,"}, {"sha": "cf1ab47de861a1c078a3a103dd41768734246169", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -8,6 +8,7 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.2.1\"\n chalk-ir = \"0.87.0\"\n+derive_more = \"0.99.17\"\n either = \"1.5.0\"\n gsgdt = \"0.1.2\"\n polonius-engine = \"0.13.0\""}, {"sha": "e83106b1ee51507cc6807e5c4947c833136c25a7", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -89,7 +89,7 @@ macro_rules! arena_types {\n \n             // Interned types\n             [] tys: rustc_data_structures::intern::WithStableHash<rustc_middle::ty::TyS<'tcx>>,\n-            [] predicates: rustc_middle::ty::PredicateS<'tcx>,\n+            [] predicates: rustc_data_structures::intern::WithStableHash<rustc_middle::ty::PredicateS<'tcx>>,\n             [] consts: rustc_middle::ty::ConstS<'tcx>,\n \n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,"}, {"sha": "02fd03c02839a69f7eb6e847d14248ebc06470c4", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -133,13 +133,8 @@ pub fn provide(providers: &mut Providers) {\n         // Accessing the local_parent is ok since its value is hashed as part of `id`'s DefPathHash.\n         tcx.opt_local_parent(id.def_id).map_or(CRATE_HIR_ID, |parent| {\n             let mut parent_hir_id = tcx.hir().local_def_id_to_hir_id(parent);\n-            if let Some(local_id) = tcx.hir_crate(()).owners[parent_hir_id.owner.def_id]\n-                .unwrap()\n-                .parenting\n-                .get(&id.def_id)\n-            {\n-                parent_hir_id.local_id = *local_id;\n-            }\n+            parent_hir_id.local_id =\n+                tcx.hir_crate(()).owners[parent_hir_id.owner.def_id].unwrap().parenting[&id.def_id];\n             parent_hir_id\n         })\n     };"}, {"sha": "7e4063c2ffd78fb0f0f2280dbcfade275fce56ad", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -30,8 +30,10 @@\n #![feature(core_intrinsics)]\n #![feature(discriminant_kind)]\n #![feature(exhaustive_patterns)]\n+#![feature(generators)]\n #![feature(get_mut_unchecked)]\n #![feature(if_let_guard)]\n+#![feature(iter_from_generator)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n #![feature(extern_types)]"}, {"sha": "343ea1f00f58bc7c4b982485e284593cb13e8c5f", "filename": "compiler/rustc_middle/src/middle/lang_items.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -27,7 +27,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn fn_trait_kind_from_lang_item(self, id: DefId) -> Option<ty::ClosureKind> {\n+    /// Given a [`DefId`] of a [`Fn`], [`FnMut`] or [`FnOnce`] traits,\n+    /// returns a corresponding [`ty::ClosureKind`].\n+    /// For any other [`DefId`] return `None`.\n+    pub fn fn_trait_kind_from_def_id(self, id: DefId) -> Option<ty::ClosureKind> {\n         let items = self.lang_items();\n         match Some(id) {\n             x if x == items.fn_trait() => Some(ty::ClosureKind::Fn),\n@@ -36,6 +39,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    /// Returns `true` if `id` is a `DefId` of [`Fn`], [`FnMut`] or [`FnOnce`] traits.\n+    pub fn is_fn_trait(self, id: DefId) -> bool {\n+        self.fn_trait_kind_from_def_id(id).is_some()\n+    }\n }\n \n /// Returns `true` if the specified `lang_item` must be present for this"}, {"sha": "5f911d5884a3353019f39ee10521beaab33bdcd1", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -36,7 +36,7 @@ pub use init_mask::{InitChunk, InitChunkIter};\n /// module provides higher-level access.\n // Note: for performance reasons when interning, some of the `Allocation` fields can be partially\n // hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n-#[derive(Clone, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n+#[derive(Clone, Eq, PartialEq, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct Allocation<Prov: Provenance = AllocId, Extra = ()> {\n     /// The actual bytes of the allocation.\n@@ -108,7 +108,7 @@ impl hash::Hash for Allocation {\n /// Here things are different because only const allocations are interned. This\n /// means that both the inner type (`Allocation`) and the outer type\n /// (`ConstAllocation`) are used quite a bit.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n #[rustc_pass_by_value]\n pub struct ConstAllocation<'tcx>(pub Interned<'tcx, Allocation>);\n "}, {"sha": "82e9a961a2bfb73a3b703917b29231d4588e6911", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/init_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -12,7 +12,7 @@ type Block = u64;\n /// is initialized. If it is `false` the byte is uninitialized.\n // Note: for performance reasons when interning, some of the `InitMask` fields can be partially\n // hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct InitMask {\n     blocks: Vec<Block>,"}, {"sha": "ddd3f394358a311d059dae14a971f204308b71a6", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/provenance_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -10,7 +10,7 @@ use super::{alloc_range, AllocError, AllocId, AllocRange, AllocResult, Provenanc\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n \n /// Stores the provenance information of pointers stored in memory.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n #[derive(HashStable)]\n pub struct ProvenanceMap<Prov = AllocId> {\n     /// Provenance in this map applies from the given offset for an entire pointer-size worth of"}, {"sha": "9c270ba1ec179939e18834ca0f773c9efbea4836", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -173,7 +173,7 @@ impl Provenance for AllocId {\n /// Represents a pointer in the Miri engine.\n ///\n /// Pointers are \"tagged\" with provenance information; typically the `AllocId` they belong to.\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n+#[derive(Copy, Clone, Eq, PartialEq, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub struct Pointer<Prov = AllocId> {\n     pub(super) offset: Size, // kept private to avoid accidental misinterpretation (meaning depends on `Prov` type)"}, {"sha": "e6636e50e6e7ab0a1acf50e90cf57ed963c70c6a", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -20,15 +20,15 @@ use super::{\n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n #[derive(Copy, Clone, HashStable, TyEncodable, TyDecodable, Debug, Hash, Eq, PartialEq)]\n pub struct ConstAlloc<'tcx> {\n-    // the value lives here, at offset 0, and that allocation definitely is an `AllocKind::Memory`\n-    // (so you can use `AllocMap::unwrap_memory`).\n+    /// The value lives here, at offset 0, and that allocation definitely is an `AllocKind::Memory`\n+    /// (so you can use `AllocMap::unwrap_memory`).\n     pub alloc_id: AllocId,\n     pub ty: Ty<'tcx>,\n }\n \n /// Represents a constant value in Rust. `Scalar` and `Slice` are optimizations for\n /// array length computations, enum discriminants and the pattern matching logic.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable, Lift)]\n pub enum ConstValue<'tcx> {\n     /// Used only for types with `layout::abi::Scalar` ABI.\n@@ -110,7 +110,7 @@ impl<'tcx> ConstValue<'tcx> {\n ///\n /// These variants would be private if there was a convenient way to achieve that in Rust.\n /// Do *not* match on a `Scalar`! Use the various `to_*` methods instead.\n-#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n+#[derive(Clone, Copy, Eq, PartialEq, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub enum Scalar<Prov = AllocId> {\n     /// The raw bytes of a simple value."}, {"sha": "20dde64e51b0118e52e0927fa631e0e989d50629", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2527,8 +2527,7 @@ impl<'tcx> ConstantKind<'tcx> {\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n                 let name = tcx.item_name(def_id);\n-                let ty_const =\n-                    tcx.mk_const(ty::ConstKind::Param(ty::ParamConst::new(index, name)), ty);\n+                let ty_const = tcx.mk_const(ty::ParamConst::new(index, name), ty);\n                 debug!(?ty_const);\n \n                 return Self::Ty(ty_const);"}, {"sha": "e1220320eea1b5732808dea43d0644f1e48565e9", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -562,7 +562,7 @@ rustc_queries! {\n \n     /// Returns the inferred outlives predicates (e.g., for `struct\n     /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n-    query inferred_outlives_of(key: DefId) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    query inferred_outlives_of(key: DefId) -> &'tcx [(ty::Clause<'tcx>, Span)] {\n         desc { |tcx| \"computing inferred outlives predicates of `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern"}, {"sha": "143435cb2a1f47bcbf11929aa4aba4a4b6e9b1da", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -471,7 +471,7 @@ pub struct ImplDerivedObligationCause<'tcx> {\n }\n \n impl<'tcx> ObligationCauseCode<'tcx> {\n-    // Return the base obligation, ignoring derived obligations.\n+    /// Returns the base obligation, ignoring derived obligations.\n     pub fn peel_derives(&self) -> &Self {\n         let mut base_cause = self;\n         while let Some((parent_code, _)) = base_cause.parent() {"}, {"sha": "d00553cbad131753dda62ca19b9bfa69cb1191c4", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -15,8 +15,8 @@ use super::{Ty, TyCtxt};\n \n use self::BorrowKind::*;\n \n-// Captures are represented using fields inside a structure.\n-// This represents accessing self in the closure structure\n+/// Captures are represented using fields inside a structure.\n+/// This represents accessing self in the closure structure\n pub const CAPTURE_STRUCT_LOCAL: mir::Local = mir::Local::from_u32(1);\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n@@ -91,45 +91,18 @@ pub enum ClosureKind {\n }\n \n impl<'tcx> ClosureKind {\n-    // This is the initial value used when doing upvar inference.\n+    /// This is the initial value used when doing upvar inference.\n     pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n \n     /// Returns `true` if a type that impls this closure kind\n     /// must also implement `other`.\n     pub fn extends(self, other: ty::ClosureKind) -> bool {\n-        matches!(\n-            (self, other),\n-            (ClosureKind::Fn, ClosureKind::Fn)\n-                | (ClosureKind::Fn, ClosureKind::FnMut)\n-                | (ClosureKind::Fn, ClosureKind::FnOnce)\n-                | (ClosureKind::FnMut, ClosureKind::FnMut)\n-                | (ClosureKind::FnMut, ClosureKind::FnOnce)\n-                | (ClosureKind::FnOnce, ClosureKind::FnOnce)\n-        )\n-    }\n-\n-    /// Returns the representative scalar type for this closure kind.\n-    /// See `Ty::to_opt_closure_kind` for more details.\n-    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        match self {\n-            ClosureKind::Fn => tcx.types.i8,\n-            ClosureKind::FnMut => tcx.types.i16,\n-            ClosureKind::FnOnce => tcx.types.i32,\n-        }\n-    }\n-\n-    pub fn from_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ClosureKind> {\n-        if Some(def_id) == tcx.lang_items().fn_once_trait() {\n-            Some(ClosureKind::FnOnce)\n-        } else if Some(def_id) == tcx.lang_items().fn_mut_trait() {\n-            Some(ClosureKind::FnMut)\n-        } else if Some(def_id) == tcx.lang_items().fn_trait() {\n-            Some(ClosureKind::Fn)\n-        } else {\n-            None\n-        }\n+        self <= other\n     }\n \n+    /// Converts `self` to a [`DefId`] of the corresponding trait.\n+    ///\n+    /// Note: the inverse of this function is [`TyCtxt::fn_trait_kind_from_def_id`].\n     pub fn to_def_id(&self, tcx: TyCtxt<'_>) -> DefId {\n         tcx.require_lang_item(\n             match self {\n@@ -140,6 +113,16 @@ impl<'tcx> ClosureKind {\n             None,\n         )\n     }\n+\n+    /// Returns the representative scalar type for this closure kind.\n+    /// See `Ty::to_opt_closure_kind` for more details.\n+    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        match self {\n+            ClosureKind::Fn => tcx.types.i8,\n+            ClosureKind::FnMut => tcx.types.i16,\n+            ClosureKind::FnOnce => tcx.types.i32,\n+        }\n+    }\n }\n \n /// A composite describing a `Place` that is captured by a closure."}, {"sha": "75f2d45eadb81dbdea74246cedd6188b6002b6eb", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -345,6 +345,14 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n     }\n }\n \n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for [(ty::Clause<'tcx>, Span)] {\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        decoder.interner().arena.alloc_from_iter(\n+            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n+        )\n+    }\n+}\n+\n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n     for ty::List<ty::BoundVariableKind>\n {"}, {"sha": "c2be08e497e5bf85bc9174c7a05daf806eb91b51", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -76,10 +76,10 @@ impl<'tcx> Const<'tcx> {\n         match Self::try_eval_lit_or_param(tcx, ty, expr) {\n             Some(v) => v,\n             None => tcx.mk_const(\n-                ty::ConstKind::Unevaluated(ty::UnevaluatedConst {\n+                ty::UnevaluatedConst {\n                     def: def.to_global(),\n                     substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n-                }),\n+                },\n                 ty,\n             ),\n         }\n@@ -134,18 +134,12 @@ impl<'tcx> Const<'tcx> {\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n                 let name = tcx.item_name(def_id);\n-                Some(tcx.mk_const(ty::ConstKind::Param(ty::ParamConst::new(index, name)), ty))\n+                Some(tcx.mk_const(ty::ParamConst::new(index, name), ty))\n             }\n             _ => None,\n         }\n     }\n \n-    /// Interns the given value as a constant.\n-    #[inline]\n-    pub fn from_value(tcx: TyCtxt<'tcx>, val: ty::ValTree<'tcx>, ty: Ty<'tcx>) -> Self {\n-        tcx.mk_const(ConstKind::Value(val), ty)\n-    }\n-\n     /// Panics if self.kind != ty::ConstKind::Value\n     pub fn to_valtree(self) -> ty::ValTree<'tcx> {\n         match self.kind() {\n@@ -154,26 +148,23 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn from_scalar_int(tcx: TyCtxt<'tcx>, i: ScalarInt, ty: Ty<'tcx>) -> Self {\n-        let valtree = ty::ValTree::from_scalar_int(i);\n-        Self::from_value(tcx, valtree, ty)\n-    }\n-\n     #[inline]\n     /// Creates a constant with the given integer value and interns it.\n     pub fn from_bits(tcx: TyCtxt<'tcx>, bits: u128, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Self {\n         let size = tcx\n             .layout_of(ty)\n             .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n             .size;\n-        Self::from_scalar_int(tcx, ScalarInt::try_from_uint(bits, size).unwrap(), ty.value)\n+        tcx.mk_const(\n+            ty::ValTree::from_scalar_int(ScalarInt::try_from_uint(bits, size).unwrap()),\n+            ty.value,\n+        )\n     }\n \n     #[inline]\n     /// Creates an interned zst constant.\n     pub fn zero_sized(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Self {\n-        let valtree = ty::ValTree::zst();\n-        Self::from_value(tcx, valtree, ty)\n+        tcx.mk_const(ty::ValTree::zst(), ty)\n     }\n \n     #[inline]\n@@ -220,7 +211,7 @@ impl<'tcx> Const<'tcx> {\n     pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Const<'tcx> {\n         if let Some(val) = self.kind().try_eval_for_typeck(tcx, param_env) {\n             match val {\n-                Ok(val) => Const::from_value(tcx, val, self.ty()),\n+                Ok(val) => tcx.mk_const(val, self.ty()),\n                 Err(guar) => tcx.const_error_with_guaranteed(self.ty(), guar),\n             }\n         } else {"}, {"sha": "becc2b805dd1ee9ffb3ca9c50eb6b346e697a996", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -49,6 +49,7 @@ impl<'tcx> UnevaluatedConst<'tcx> {\n /// Represents a constant in Rust.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n #[derive(Hash, HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(derive_more::From)]\n pub enum ConstKind<'tcx> {\n     /// A const generic parameter.\n     Param(ty::ParamConst),\n@@ -71,12 +72,19 @@ pub enum ConstKind<'tcx> {\n \n     /// A placeholder for a const which could not be computed; this is\n     /// propagated to avoid useless error messages.\n+    #[from(ignore)]\n     Error(ErrorGuaranteed),\n \n     /// Expr which contains an expression which has partially evaluated items.\n     Expr(Expr<'tcx>),\n }\n \n+impl<'tcx> From<ty::ConstVid<'tcx>> for ConstKind<'tcx> {\n+    fn from(const_vid: ty::ConstVid<'tcx>) -> Self {\n+        InferConst::Var(const_vid).into()\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n #[derive(HashStable, TyEncodable, TyDecodable, TypeVisitable, TypeFoldable)]\n pub enum Expr<'tcx> {"}, {"sha": "a9a7a2c8b01cced710a674156f94c20ce246a95f", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 136, "deletions": 75, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -17,8 +17,8 @@ use crate::traits;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n-    ClosureSizeProfileData, Const, ConstS, ConstVid, DefIdTree, FloatTy, FloatVar, FloatVid,\n-    GenericParamDefKind, InferConst, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n+    ClosureSizeProfileData, Const, ConstS, DefIdTree, FloatTy, FloatVar, FloatVid,\n+    GenericParamDefKind, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n     PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, PredicateS, ProjectionTy,\n     Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut,\n     UintTy, Visibility,\n@@ -53,6 +53,7 @@ use rustc_hir::{\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_middle::mir::FakeReadCause;\n+use rustc_query_system::dep_graph::DepNodeIndex;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{CrateType, OutputFilenames};\n@@ -142,7 +143,7 @@ pub struct CtxtInterners<'tcx> {\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind<'tcx>>,\n     poly_existential_predicates: InternedSet<'tcx, List<PolyExistentialPredicate<'tcx>>>,\n-    predicate: InternedSet<'tcx, PredicateS<'tcx>>,\n+    predicate: InternedSet<'tcx, WithStableHash<PredicateS<'tcx>>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n@@ -190,20 +191,8 @@ impl<'tcx> CtxtInterners<'tcx> {\n             self.type_\n                 .intern(kind, |kind| {\n                     let flags = super::flags::FlagComputation::for_kind(&kind);\n-\n-                    // It's impossible to hash inference variables (and will ICE), so we don't need to try to cache them.\n-                    // Without incremental, we rarely stable-hash types, so let's not do it proactively.\n-                    let stable_hash = if flags.flags.intersects(TypeFlags::NEEDS_INFER)\n-                        || sess.opts.incremental.is_none()\n-                    {\n-                        Fingerprint::ZERO\n-                    } else {\n-                        let mut hasher = StableHasher::new();\n-                        let mut hcx =\n-                            StableHashingContext::new(sess, definitions, cstore, source_span);\n-                        kind.hash_stable(&mut hcx, &mut hasher);\n-                        hasher.finish()\n-                    };\n+                    let stable_hash =\n+                        self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n \n                     let ty_struct = TyS {\n                         kind,\n@@ -219,20 +208,54 @@ impl<'tcx> CtxtInterners<'tcx> {\n         ))\n     }\n \n+    fn stable_hash<'a, T: HashStable<StableHashingContext<'a>>>(\n+        &self,\n+        flags: &ty::flags::FlagComputation,\n+        sess: &'a Session,\n+        definitions: &'a rustc_hir::definitions::Definitions,\n+        cstore: &'a CrateStoreDyn,\n+        source_span: &'a IndexVec<LocalDefId, Span>,\n+        val: &T,\n+    ) -> Fingerprint {\n+        // It's impossible to hash inference variables (and will ICE), so we don't need to try to cache them.\n+        // Without incremental, we rarely stable-hash types, so let's not do it proactively.\n+        if flags.flags.intersects(TypeFlags::NEEDS_INFER) || sess.opts.incremental.is_none() {\n+            Fingerprint::ZERO\n+        } else {\n+            let mut hasher = StableHasher::new();\n+            let mut hcx = StableHashingContext::new(sess, definitions, cstore, source_span);\n+            val.hash_stable(&mut hcx, &mut hasher);\n+            hasher.finish()\n+        }\n+    }\n+\n     #[inline(never)]\n-    fn intern_predicate(&self, kind: Binder<'tcx, PredicateKind<'tcx>>) -> Predicate<'tcx> {\n+    fn intern_predicate(\n+        &self,\n+        kind: Binder<'tcx, PredicateKind<'tcx>>,\n+        sess: &Session,\n+        definitions: &rustc_hir::definitions::Definitions,\n+        cstore: &CrateStoreDyn,\n+        source_span: &IndexVec<LocalDefId, Span>,\n+    ) -> Predicate<'tcx> {\n         Predicate(Interned::new_unchecked(\n             self.predicate\n                 .intern(kind, |kind| {\n                     let flags = super::flags::FlagComputation::for_predicate(kind);\n \n+                    let stable_hash =\n+                        self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n+\n                     let predicate_struct = PredicateS {\n                         kind,\n                         flags: flags.flags,\n                         outer_exclusive_binder: flags.outer_exclusive_binder,\n                     };\n \n-                    InternedInSet(self.arena.alloc(predicate_struct))\n+                    InternedInSet(\n+                        self.arena\n+                            .alloc(WithStableHash { internee: predicate_struct, stable_hash }),\n+                    )\n                 })\n                 .0,\n         ))\n@@ -713,22 +736,24 @@ impl<'tcx> TypeckResults<'tcx> {\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n-    // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n-    // doesn't provide type parameter substitutions.\n+    /// Returns the type of a pattern as a monotype. Like [`expr_ty`], this function\n+    /// doesn't provide type parameter substitutions.\n+    ///\n+    /// [`expr_ty`]: TypeckResults::expr_ty\n     pub fn pat_ty(&self, pat: &hir::Pat<'_>) -> Ty<'tcx> {\n         self.node_type(pat.hir_id)\n     }\n \n-    // Returns the type of an expression as a monotype.\n-    //\n-    // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n-    // some cases, we insert `Adjustment` annotations such as auto-deref or\n-    // auto-ref.  The type returned by this function does not consider such\n-    // adjustments.  See `expr_ty_adjusted()` instead.\n-    //\n-    // NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n-    // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n-    // instead of \"fn(ty) -> T with T = isize\".\n+    /// Returns the type of an expression as a monotype.\n+    ///\n+    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+    /// some cases, we insert `Adjustment` annotations such as auto-deref or\n+    /// auto-ref.  The type returned by this function does not consider such\n+    /// adjustments.  See `expr_ty_adjusted()` instead.\n+    ///\n+    /// NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n+    /// ask for the type of `id` in `id(3)`, it will return `fn(&isize) -> isize`\n+    /// instead of `fn(ty) -> T with T = isize`.\n     pub fn expr_ty(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n         self.node_type(expr.hir_id)\n     }\n@@ -995,18 +1020,33 @@ impl<'tcx> CommonConsts<'tcx> {\n     }\n }\n \n-// This struct contains information regarding the `ReFree(FreeRegion)` corresponding to a lifetime\n-// conflict.\n+/// This struct contains information regarding the `ReFree(FreeRegion)` corresponding to a lifetime\n+/// conflict.\n #[derive(Debug)]\n pub struct FreeRegionInfo {\n-    // `LocalDefId` corresponding to FreeRegion\n+    /// `LocalDefId` corresponding to FreeRegion\n     pub def_id: LocalDefId,\n-    // the bound region corresponding to FreeRegion\n+    /// the bound region corresponding to FreeRegion\n     pub boundregion: ty::BoundRegionKind,\n-    // checks if bound region is in Impl Item\n+    /// checks if bound region is in Impl Item\n     pub is_impl_item: bool,\n }\n \n+/// This struct should only be created by `create_def`.\n+#[derive(Copy, Clone)]\n+pub struct TyCtxtFeed<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    // Do not allow direct access, as downstream code must not mutate this field.\n+    def_id: LocalDefId,\n+}\n+\n+impl<'tcx> TyCtxtFeed<'tcx> {\n+    #[inline(always)]\n+    pub fn def_id(&self) -> LocalDefId {\n+        self.def_id\n+    }\n+}\n+\n /// The central data structure of the compiler. It stores references\n /// to the various **arenas** and also houses the results of the\n /// various **compiler queries** that have been performed. See the\n@@ -1189,8 +1229,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             debug!(\"layout_scalar_valid_range: attr={:?}\", attr);\n             if let Some(\n                 &[\n-                    ast::NestedMetaItem::Literal(ast::Lit {\n-                        kind: ast::LitKind::Int(a, _), ..\n+                    ast::NestedMetaItem::Lit(ast::MetaItemLit {\n+                        kind: ast::LitKind::Int(a, _),\n+                        ..\n                     }),\n                 ],\n             ) = attr.meta_item_list().as_deref()\n@@ -1358,6 +1399,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.diagnostic_items(did.krate).name_to_id.get(&name) == Some(&did)\n     }\n \n+    /// Returns `true` if the node pointed to by `def_id` is a generator for an async construct.\n+    pub fn generator_is_async(self, def_id: DefId) -> bool {\n+        matches!(self.generator_kind(def_id), Some(hir::GeneratorKind::Async(_)))\n+    }\n+\n     pub fn stability(self) -> &'tcx stability::Index {\n         self.stability_index(())\n     }\n@@ -1463,12 +1509,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Create a new definition within the incr. comp. engine.\n-    pub fn create_def(self, parent: LocalDefId, data: hir::definitions::DefPathData) -> LocalDefId {\n+    pub fn create_def(\n+        self,\n+        parent: LocalDefId,\n+        data: hir::definitions::DefPathData,\n+    ) -> TyCtxtFeed<'tcx> {\n         // This function modifies `self.definitions` using a side-effect.\n         // We need to ensure that these side effects are re-run by the incr. comp. engine.\n         // Depending on the forever-red node will tell the graph that the calling query\n         // needs to be re-evaluated.\n-        use rustc_query_system::dep_graph::DepNodeIndex;\n         self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);\n \n         // The following call has the side effect of modifying the tables inside `definitions`.\n@@ -1485,23 +1534,38 @@ impl<'tcx> TyCtxt<'tcx> {\n         // This is fine because:\n         // - those queries are `eval_always` so we won't miss their result changing;\n         // - this write will have happened before these queries are called.\n-        self.definitions.write().create_def(parent, data)\n+        let def_id = self.definitions.write().create_def(parent, data);\n+\n+        TyCtxtFeed { tcx: self, def_id }\n     }\n \n     pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'tcx {\n-        // Create a dependency to the crate to be sure we re-execute this when the amount of\n+        // Create a dependency to the red node to be sure we re-execute this when the amount of\n         // definitions change.\n-        self.ensure().hir_crate(());\n-        // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n-        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n-        let definitions = self.definitions.leak();\n-        definitions.iter_local_def_id()\n+        self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);\n+\n+        let definitions = &self.definitions;\n+        std::iter::from_generator(|| {\n+            let mut i = 0;\n+\n+            // Recompute the number of definitions each time, because our caller may be creating\n+            // new ones.\n+            while i < { definitions.read().num_definitions() } {\n+                let local_def_index = rustc_span::def_id::DefIndex::from_usize(i);\n+                yield LocalDefId { local_def_index };\n+                i += 1;\n+            }\n+\n+            // Leak a read lock once we finish iterating on definitions, to prevent adding new ones.\n+            definitions.leak();\n+        })\n     }\n \n     pub fn def_path_table(self) -> &'tcx rustc_hir::definitions::DefPathTable {\n         // Create a dependency to the crate to be sure we re-execute this when the amount of\n         // definitions change.\n-        self.ensure().hir_crate(());\n+        self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);\n+\n         // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n         // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n         let definitions = self.definitions.leak();\n@@ -1660,7 +1724,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    // Checks if the bound region is in Impl Item.\n+    /// Checks if the bound region is in Impl Item.\n     pub fn is_bound_region_in_impl_item(self, suitable_region_binding_scope: LocalDefId) -> bool {\n         let container_id = self.parent(suitable_region_binding_scope.to_def_id());\n         if self.impl_trait_ref(container_id).is_some() {\n@@ -2160,23 +2224,25 @@ impl<'tcx> Hash for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {\n     }\n }\n \n-impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>> for InternedInSet<'tcx, PredicateS<'tcx>> {\n+impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>>\n+    for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>>\n+{\n     fn borrow<'a>(&'a self) -> &'a Binder<'tcx, PredicateKind<'tcx>> {\n         &self.0.kind\n     }\n }\n \n-impl<'tcx> PartialEq for InternedInSet<'tcx, PredicateS<'tcx>> {\n-    fn eq(&self, other: &InternedInSet<'tcx, PredicateS<'tcx>>) -> bool {\n+impl<'tcx> PartialEq for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {\n+    fn eq(&self, other: &InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>>) -> bool {\n         // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n         // `x == y`.\n         self.0.kind == other.0.kind\n     }\n }\n \n-impl<'tcx> Eq for InternedInSet<'tcx, PredicateS<'tcx>> {}\n+impl<'tcx> Eq for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {}\n \n-impl<'tcx> Hash for InternedInSet<'tcx, PredicateS<'tcx>> {\n+impl<'tcx> Hash for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n         self.0.kind.hash(s)\n@@ -2378,7 +2444,14 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_predicate(self, binder: Binder<'tcx, PredicateKind<'tcx>>) -> Predicate<'tcx> {\n-        self.interners.intern_predicate(binder)\n+        self.interners.intern_predicate(\n+            binder,\n+            self.sess,\n+            &self.definitions.read(),\n+            &*self.untracked_resolutions.cstore,\n+            // This is only used to create a stable hashing context.\n+            &self.untracked_resolutions.source_span,\n+        )\n     }\n \n     #[inline]\n@@ -2596,13 +2669,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_const(self, kind: ty::ConstKind<'tcx>, ty: Ty<'tcx>) -> Const<'tcx> {\n-        self.mk_const_internal(ty::ConstS { kind, ty })\n-    }\n-\n-    #[inline]\n-    pub fn mk_const_var(self, v: ConstVid<'tcx>, ty: Ty<'tcx>) -> Const<'tcx> {\n-        self.mk_const(ty::ConstKind::Infer(InferConst::Var(v)), ty)\n+    pub fn mk_const(self, kind: impl Into<ty::ConstKind<'tcx>>, ty: Ty<'tcx>) -> Const<'tcx> {\n+        self.mk_const_internal(ty::ConstS { kind: kind.into(), ty })\n     }\n \n     #[inline]\n@@ -2620,30 +2688,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(Infer(it))\n     }\n \n-    #[inline]\n-    pub fn mk_const_infer(self, ic: InferConst<'tcx>, ty: Ty<'tcx>) -> ty::Const<'tcx> {\n-        self.mk_const(ty::ConstKind::Infer(ic), ty)\n-    }\n-\n     #[inline]\n     pub fn mk_ty_param(self, index: u32, name: Symbol) -> Ty<'tcx> {\n         self.mk_ty(Param(ParamTy { index, name }))\n     }\n \n-    #[inline]\n-    pub fn mk_const_param(self, index: u32, name: Symbol, ty: Ty<'tcx>) -> Const<'tcx> {\n-        self.mk_const(ty::ConstKind::Param(ParamConst { index, name }), ty)\n-    }\n-\n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> GenericArg<'tcx> {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n                 self.mk_region(ty::ReEarlyBound(param.to_early_bound_region_data())).into()\n             }\n             GenericParamDefKind::Type { .. } => self.mk_ty_param(param.index, param.name).into(),\n-            GenericParamDefKind::Const { .. } => {\n-                self.mk_const_param(param.index, param.name, self.type_of(param.def_id)).into()\n-            }\n+            GenericParamDefKind::Const { .. } => self\n+                .mk_const(\n+                    ParamConst { index: param.index, name: param.name },\n+                    self.type_of(param.def_id),\n+                )\n+                .into(),\n         }\n     }\n "}, {"sha": "511d51cd670fb94ff8bf013f3512e545f9ea881e", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -355,6 +355,12 @@ pub fn suggest_constraining_type_params<'a>(\n         ));\n     }\n \n+    // FIXME: remove the suggestions that are from derive, as the span is not correct\n+    suggestions = suggestions\n+        .into_iter()\n+        .filter(|(span, _, _)| !span.in_derive_expansion())\n+        .collect::<Vec<_>>();\n+\n     if suggestions.len() == 1 {\n         let (span, suggestion, msg) = suggestions.pop().unwrap();\n "}, {"sha": "d83e17574a09423c249b54034a35339c6f9f1b04", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -70,7 +70,6 @@ pub enum TypeError<'tcx> {\n     CyclicConst(ty::Const<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>>),\n-    ObjectUnsafeCoercion(DefId),\n     ConstMismatch(ExpectedFound<ty::Const<'tcx>>),\n \n     IntrinsicCast,\n@@ -222,7 +221,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                 f,\n                 \"cannot coerce functions with `#[target_feature]` to safe function pointers\"\n             ),\n-            ObjectUnsafeCoercion(_) => write!(f, \"coercion to object-unsafe trait object\"),\n         }\n     }\n }\n@@ -249,8 +247,7 @@ impl<'tcx> TypeError<'tcx> {\n             | ProjectionMismatched(_)\n             | ExistentialMismatch(_)\n             | ConstMismatch(_)\n-            | IntrinsicCast\n-            | ObjectUnsafeCoercion(_) => true,\n+            | IntrinsicCast => true,\n         }\n     }\n }"}, {"sha": "046a2660a1f6dd51b45d23616ef786ee69767ca8", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -6,7 +6,7 @@ use std::slice;\n pub struct FlagComputation {\n     pub flags: TypeFlags,\n \n-    // see `Ty::outer_exclusive_binder` for details\n+    /// see `Ty::outer_exclusive_binder` for details\n     pub outer_exclusive_binder: ty::DebruijnIndex,\n }\n "}, {"sha": "d431d008ddf06ed96489dcea92e5a542aa74e537", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -407,6 +407,7 @@ where\n         match *t.kind() {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.current_index => {\n                 let ty = self.delegate.replace_ty(bound_ty);\n+                debug_assert!(!ty.has_vars_bound_above(ty::INNERMOST));\n                 ty::fold::shift_vars(self.tcx, ty, self.current_index.as_u32())\n             }\n             _ if t.has_vars_bound_at_or_above(self.current_index) => t.super_fold_with(self),\n@@ -437,6 +438,7 @@ where\n         match ct.kind() {\n             ty::ConstKind::Bound(debruijn, bound_const) if debruijn == self.current_index => {\n                 let ct = self.delegate.replace_const(bound_const, ct.ty());\n+                debug_assert!(!ct.has_vars_bound_above(ty::INNERMOST));\n                 ty::fold::shift_vars(self.tcx, ct, self.current_index.as_u32())\n             }\n             _ => ct.super_fold_with(self),\n@@ -697,46 +699,41 @@ impl<'tcx> TypeFolder<'tcx> for Shifter<'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReLateBound(debruijn, br) => {\n-                if self.amount == 0 || debruijn < self.current_index {\n-                    r\n-                } else {\n-                    let debruijn = debruijn.shifted_in(self.amount);\n-                    let shifted = ty::ReLateBound(debruijn, br);\n-                    self.tcx.mk_region(shifted)\n-                }\n+            ty::ReLateBound(debruijn, br) if debruijn >= self.current_index => {\n+                let debruijn = debruijn.shifted_in(self.amount);\n+                let shifted = ty::ReLateBound(debruijn, br);\n+                self.tcx.mk_region(shifted)\n             }\n             _ => r,\n         }\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match *ty.kind() {\n-            ty::Bound(debruijn, bound_ty) => {\n-                if self.amount == 0 || debruijn < self.current_index {\n-                    ty\n-                } else {\n-                    let debruijn = debruijn.shifted_in(self.amount);\n-                    self.tcx.mk_ty(ty::Bound(debruijn, bound_ty))\n-                }\n+            ty::Bound(debruijn, bound_ty) if debruijn >= self.current_index => {\n+                let debruijn = debruijn.shifted_in(self.amount);\n+                self.tcx.mk_ty(ty::Bound(debruijn, bound_ty))\n             }\n \n-            _ => ty.super_fold_with(self),\n+            _ if ty.has_vars_bound_at_or_above(self.current_index) => ty.super_fold_with(self),\n+            _ => ty,\n         }\n     }\n \n     fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n-        if let ty::ConstKind::Bound(debruijn, bound_ct) = ct.kind() {\n-            if self.amount == 0 || debruijn < self.current_index {\n-                ct\n-            } else {\n-                let debruijn = debruijn.shifted_in(self.amount);\n-                self.tcx.mk_const(ty::ConstKind::Bound(debruijn, bound_ct), ct.ty())\n-            }\n+        if let ty::ConstKind::Bound(debruijn, bound_ct) = ct.kind()\n+            && debruijn >= self.current_index\n+        {\n+            let debruijn = debruijn.shifted_in(self.amount);\n+            self.tcx.mk_const(ty::ConstKind::Bound(debruijn, bound_ct), ct.ty())\n         } else {\n             ct.super_fold_with(self)\n         }\n     }\n+\n+    fn fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+        if p.has_vars_bound_at_or_above(self.current_index) { p.super_fold_with(self) } else { p }\n+    }\n }\n \n pub fn shift_region<'tcx>(\n@@ -758,5 +755,9 @@ where\n {\n     debug!(\"shift_vars(value={:?}, amount={})\", value, amount);\n \n+    if amount == 0 || !value.has_escaping_bound_vars() {\n+        return value;\n+    }\n+\n     value.fold_with(&mut Shifter::new(tcx, amount))\n }"}, {"sha": "dd4ab3e8d30bf24dff563a8273a90eb6ee2e2e73", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -414,7 +414,7 @@ impl Visibility<DefId> {\n         self.map_id(|id| id.expect_local())\n     }\n \n-    // Returns `true` if this item is visible anywhere in the local crate.\n+    /// Returns `true` if this item is visible anywhere in the local crate.\n     pub fn is_visible_locally(self) -> bool {\n         match self {\n             Visibility::Public => true,\n@@ -548,9 +548,9 @@ pub(crate) struct PredicateS<'tcx> {\n }\n \n /// Use this rather than `PredicateS`, whenever possible.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, HashStable)]\n #[rustc_pass_by_value]\n-pub struct Predicate<'tcx>(Interned<'tcx, PredicateS<'tcx>>);\n+pub struct Predicate<'tcx>(Interned<'tcx, WithStableHash<PredicateS<'tcx>>>);\n \n impl<'tcx> Predicate<'tcx> {\n     /// Gets the inner `Binder<'tcx, PredicateKind<'tcx>>`.\n@@ -631,7 +631,7 @@ impl<'tcx> Predicate<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for PredicateS<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let PredicateS {\n             ref kind,\n@@ -640,7 +640,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n             // also contained in `kind`, so no need to hash them.\n             flags: _,\n             outer_exclusive_binder: _,\n-        } = self.0.0;\n+        } = self;\n \n         kind.hash_stable(hcx, hasher);\n     }\n@@ -734,7 +734,7 @@ pub struct CratePredicatesMap<'tcx> {\n     /// For each struct with outlive bounds, maps to a vector of the\n     /// predicate of its outlive bounds. If an item has no outlives\n     /// bounds, it will have no entry.\n-    pub predicates: FxHashMap<DefId, &'tcx [(Predicate<'tcx>, Span)]>,\n+    pub predicates: FxHashMap<DefId, &'tcx [(Clause<'tcx>, Span)]>,\n }\n \n impl<'tcx> Predicate<'tcx> {\n@@ -926,9 +926,10 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n+/// `A: B`\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n-pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n+pub struct OutlivesPredicate<A, B>(pub A, pub B);\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;\n pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<'tcx, RegionOutlivesPredicate<'tcx>>;\n@@ -1166,6 +1167,13 @@ impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Binder<'tcx, PredicateKind<'tc\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Clause<'tcx> {\n+    #[inline(always)]\n+    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        tcx.mk_predicate(ty::Binder::dummy(ty::PredicateKind::Clause(self)))\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Binder<'tcx, TraitRef<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {"}, {"sha": "c7d6c6abd1c22ebe153c37ae240e8f572058eee3", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -5,7 +5,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use crate::middle::exported_symbols::ExportedSymbol;\n use crate::mir::Body;\n use crate::ty::{\n-    self, Const, FnSig, GeneratorDiagnosticData, GenericPredicates, Predicate, TraitRef, Ty,\n+    self, Clause, Const, FnSig, GeneratorDiagnosticData, GenericPredicates, Predicate, TraitRef, Ty,\n };\n \n pub trait ParameterizedOverTcx: 'static {\n@@ -121,6 +121,7 @@ parameterized_over_tcx! {\n     TraitRef,\n     Const,\n     Predicate,\n+    Clause,\n     GeneratorDiagnosticData,\n     Body,\n     ExportedSymbol,"}, {"sha": "5303341ba443c6c285fc170b96aa81535641b3ad", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -681,25 +681,20 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Str => p!(\"str\"),\n             ty::Generator(did, substs, movability) => {\n-                // FIXME(swatinem): async constructs used to be pretty printed\n-                // as `impl Future` previously due to the `from_generator` wrapping.\n-                // lets special case this here for now to avoid churn in diagnostics.\n-                let generator_kind = self.tcx().generator_kind(did);\n-                if matches!(generator_kind, Some(hir::GeneratorKind::Async(..))) {\n-                    let return_ty = substs.as_generator().return_ty();\n-                    p!(write(\"impl Future<Output = {}>\", return_ty));\n-\n-                    return Ok(self);\n-                }\n-\n                 p!(write(\"[\"));\n-                match movability {\n-                    hir::Movability::Movable => {}\n-                    hir::Movability::Static => p!(\"static \"),\n+                let generator_kind = self.tcx().generator_kind(did).unwrap();\n+                let should_print_movability =\n+                    self.should_print_verbose() || generator_kind == hir::GeneratorKind::Gen;\n+\n+                if should_print_movability {\n+                    match movability {\n+                        hir::Movability::Movable => {}\n+                        hir::Movability::Static => p!(\"static \"),\n+                    }\n                 }\n \n                 if !self.should_print_verbose() {\n-                    p!(\"generator\");\n+                    p!(write(\"{}\", generator_kind));\n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(did) = did.as_local() {\n                         let span = self.tcx().def_span(did);\n@@ -1085,7 +1080,7 @@ pub trait PrettyPrinter<'tcx>:\n                 let mut resugared = false;\n \n                 // Special-case `Fn(...) -> ...` and re-sugar it.\n-                let fn_trait_kind = cx.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n+                let fn_trait_kind = cx.tcx().fn_trait_kind_from_def_id(principal.def_id);\n                 if !cx.should_print_verbose() && fn_trait_kind.is_some() {\n                     if let ty::Tuple(tys) = principal.substs.type_at(0).kind() {\n                         let mut projections = predicates.projection_bounds();\n@@ -1473,8 +1468,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             // Aggregates, printed as array/tuple/struct/variant construction syntax.\n             (ty::ValTree::Branch(_), ty::Array(..) | ty::Tuple(..) | ty::Adt(..)) => {\n-                let contents =\n-                    self.tcx().destructure_const(ty::Const::from_value(self.tcx(), valtree, ty));\n+                let contents = self.tcx().destructure_const(self.tcx().mk_const(valtree, ty));\n                 let fields = contents.fields.iter().copied();\n                 match *ty.kind() {\n                     ty::Array(..) => {"}, {"sha": "47c1379b308ebd3fa3dcf1b9e7bd5e78c987265b", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -28,6 +28,7 @@ use crate::traits::query::{\n };\n use crate::traits::specialization_graph;\n use crate::traits::{self, ImplSource};\n+use crate::ty::context::TyCtxtFeed;\n use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::layout::TyAndLayout;\n use crate::ty::subst::{GenericArg, SubstsRef};\n@@ -327,6 +328,46 @@ macro_rules! define_callbacks {\n     };\n }\n \n+macro_rules! define_feedable {\n+    ($($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n+        impl<'tcx> TyCtxtFeed<'tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(self, value: $V) -> query_stored::$name<'tcx> {\n+                let key = self.def_id().into_query_param();\n+                opt_remap_env_constness!([$($modifiers)*][key]);\n+\n+                let tcx = self.tcx;\n+                let cache = &tcx.query_caches.$name;\n+\n+                let cached = try_get_cached(tcx, cache, &key, copy);\n+\n+                match cached {\n+                    Ok(old) => {\n+                        assert_eq!(\n+                            value, old,\n+                            \"Trying to feed an already recorded value for query {} key={key:?}\",\n+                            stringify!($name),\n+                        );\n+                        return old;\n+                    }\n+                    Err(()) => (),\n+                }\n+\n+                let dep_node = dep_graph::DepNode::construct(tcx, dep_graph::DepKind::$name, &key);\n+                let dep_node_index = tcx.dep_graph.with_feed_task(\n+                    dep_node,\n+                    tcx,\n+                    key,\n+                    &value,\n+                    dep_graph::hash_result,\n+                );\n+                cache.complete(key, value, dep_node_index)\n+            })*\n+        }\n+    }\n+}\n+\n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n // on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way\n@@ -340,6 +381,7 @@ macro_rules! define_callbacks {\n // as they will raise an fatal error on query cycles instead.\n \n rustc_query_append! { define_callbacks! }\n+rustc_feedable_queries! { define_feedable! }\n \n mod sealed {\n     use super::{DefId, LocalDefId, OwnerId};"}, {"sha": "c759fb6d5e4f4c50c05a7972032f83e6218f10b1", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -663,10 +663,7 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n                 au.substs,\n                 bu.substs,\n             )?;\n-            return Ok(tcx.mk_const(\n-                ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def: au.def, substs }),\n-                a.ty(),\n-            ));\n+            return Ok(tcx.mk_const(ty::UnevaluatedConst { def: au.def, substs }, a.ty()));\n         }\n         // Before calling relate on exprs, it is necessary to ensure that the nested consts\n         // have identical types."}, {"sha": "5984686044b7340dfb5a3f57eaba07990613384c", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2116,8 +2116,7 @@ impl<'tcx> Ty<'tcx> {\n     /// parameter. This is kind of a phantom type, except that the\n     /// most convenient thing for us to are the integral types. This\n     /// function converts such a special type into the closure\n-    /// kind. To go the other way, use\n-    /// `tcx.closure_kind_ty(closure_kind)`.\n+    /// kind. To go the other way, use `closure_kind.to_ty(tcx)`.\n     ///\n     /// Note that during type checking, we use an inference variable\n     /// to represent the closure kind, because it has not yet been\n@@ -2243,7 +2242,7 @@ impl<'tcx> Ty<'tcx> {\n         }\n     }\n \n-    // If `self` is a primitive, return its [`Symbol`].\n+    /// If `self` is a primitive, return its [`Symbol`].\n     pub fn primitive_symbol(self) -> Option<Symbol> {\n         match self.kind() {\n             ty::Bool => Some(sym::bool),"}, {"sha": "b38a5fbf20f5b26d17ab4b44b9b678236ec482aa", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -211,7 +211,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-// Query provider for `trait_impls_of`.\n+/// Query provider for `trait_impls_of`.\n pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> TraitImpls {\n     let mut impls = TraitImpls::default();\n \n@@ -255,7 +255,7 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n     impls\n }\n \n-// Query provider for `incoherent_impls`.\n+/// Query provider for `incoherent_impls`.\n pub(super) fn incoherent_impls_provider(tcx: TyCtxt<'_>, simp: SimplifiedType) -> &[DefId] {\n     let mut impls = Vec::new();\n "}, {"sha": "47c1ce8075674acd461a2cd8d90da3ca73dd76e4", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1208,11 +1208,11 @@ pub fn is_trivially_const_drop<'tcx>(ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-// Does the equivalent of\n-// ```\n-// let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-// folder.tcx().intern_*(&v)\n-// ```\n+/// Does the equivalent of\n+/// ```ignore (ilustrative)\n+/// let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+/// folder.tcx().intern_*(&v)\n+/// ```\n pub fn fold_list<'tcx, F, T>(\n     list: &'tcx ty::List<T>,\n     folder: &mut F,"}, {"sha": "4cdfd9e594042ba3550aa038094c7c707ad836b2", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -72,12 +72,18 @@ pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n         self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder }).is_break()\n     }\n \n-    /// Returns `true` if this `self` has any regions that escape `binder` (and\n+    /// Returns `true` if this type has any regions that escape `binder` (and\n     /// hence are not bound by it).\n     fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n         self.has_vars_bound_at_or_above(binder.shifted_in(1))\n     }\n \n+    /// Return `true` if this type has regions that are not a part of the type.\n+    /// For example, `for<'a> fn(&'a i32)` return `false`, while `fn(&'a i32)`\n+    /// would return `true`. The latter can occur when traversing through the\n+    /// former.\n+    ///\n+    /// See [`HasEscapingVarsVisitor`] for more information.\n     fn has_escaping_bound_vars(&self) -> bool {\n         self.has_vars_bound_at_or_above(ty::INNERMOST)\n     }"}, {"sha": "2412824efeb751c305af719d5fb4dccd3d2729e7", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -74,7 +74,7 @@ pub(super) fn build_custom_mir<'tcx>(\n     let mut pctxt = ParseCtxt {\n         tcx,\n         thir,\n-        source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n+        source_scope: OUTERMOST_SOURCE_SCOPE,\n         body: &mut body,\n         local_map: FxHashMap::default(),\n         block_map: FxHashMap::default(),\n@@ -128,7 +128,7 @@ fn parse_attribute(attr: &Attribute) -> MirPhase {\n struct ParseCtxt<'tcx, 'body> {\n     tcx: TyCtxt<'tcx>,\n     thir: &'body Thir<'tcx>,\n-    source_info: SourceInfo,\n+    source_scope: SourceScope,\n \n     body: &'body mut Body<'tcx>,\n     local_map: FxHashMap<LocalVarId, Local>,"}, {"sha": "d72770e70c7ece67e9f5d43b7251e1625311f227", "filename": "compiler/rustc_mir_build/src/build/custom/parse.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -23,6 +23,7 @@ macro_rules! parse_by_kind {\n     (\n         $self:ident,\n         $expr_id:expr,\n+        $expr_name:pat,\n         $expected:literal,\n         $(\n             @call($name:literal, $args:ident) => $call_expr:expr,\n@@ -33,6 +34,8 @@ macro_rules! parse_by_kind {\n     ) => {{\n         let expr_id = $self.preparse($expr_id);\n         let expr = &$self.thir[expr_id];\n+        debug!(\"Trying to parse {:?} as {}\", expr.kind, $expected);\n+        let $expr_name = expr;\n         match &expr.kind {\n             $(\n                 ExprKind::Call { ty, fun: _, args: $args, .. } if {\n@@ -137,26 +140,26 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     /// This allows us to easily parse the basic blocks declarations, local declarations, and\n     /// basic block definitions in order.\n     pub fn parse_body(&mut self, expr_id: ExprId) -> PResult<()> {\n-        let body = parse_by_kind!(self, expr_id, \"whole body\",\n+        let body = parse_by_kind!(self, expr_id, _, \"whole body\",\n             ExprKind::Block { block } => self.thir[*block].expr.unwrap(),\n         );\n-        let (block_decls, rest) = parse_by_kind!(self, body, \"body with block decls\",\n+        let (block_decls, rest) = parse_by_kind!(self, body, _, \"body with block decls\",\n             ExprKind::Block { block } => {\n                 let block = &self.thir[*block];\n                 (&block.stmts, block.expr.unwrap())\n             },\n         );\n         self.parse_block_decls(block_decls.iter().copied())?;\n \n-        let (local_decls, rest) = parse_by_kind!(self, rest, \"body with local decls\",\n+        let (local_decls, rest) = parse_by_kind!(self, rest, _, \"body with local decls\",\n             ExprKind::Block { block } => {\n                 let block = &self.thir[*block];\n                 (&block.stmts, block.expr.unwrap())\n             },\n         );\n         self.parse_local_decls(local_decls.iter().copied())?;\n \n-        let block_defs = parse_by_kind!(self, rest, \"body with block defs\",\n+        let block_defs = parse_by_kind!(self, rest, _, \"body with block defs\",\n             ExprKind::Block { block } => &self.thir[*block].stmts,\n         );\n         for (i, block_def) in block_defs.iter().enumerate() {\n@@ -223,22 +226,30 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_block_def(&self, expr_id: ExprId) -> PResult<BasicBlockData<'tcx>> {\n-        let block = parse_by_kind!(self, expr_id, \"basic block\",\n+        let block = parse_by_kind!(self, expr_id, _, \"basic block\",\n             ExprKind::Block { block } => &self.thir[*block],\n         );\n \n         let mut data = BasicBlockData::new(None);\n         for stmt_id in &*block.stmts {\n             let stmt = self.statement_as_expr(*stmt_id)?;\n+            let span = self.thir[stmt].span;\n             let statement = self.parse_statement(stmt)?;\n-            data.statements.push(Statement { source_info: self.source_info, kind: statement });\n+            data.statements.push(Statement {\n+                source_info: SourceInfo { span, scope: self.source_scope },\n+                kind: statement,\n+            });\n         }\n \n         let Some(trailing) = block.expr else {\n             return Err(self.expr_error(expr_id, \"terminator\"))\n         };\n+        let span = self.thir[trailing].span;\n         let terminator = self.parse_terminator(trailing)?;\n-        data.terminator = Some(Terminator { source_info: self.source_info, kind: terminator });\n+        data.terminator = Some(Terminator {\n+            source_info: SourceInfo { span, scope: self.source_scope },\n+            kind: terminator,\n+        });\n \n         Ok(data)\n     }"}, {"sha": "03206af33bfb5dc927da6348f64b84f7d4074a08", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,10 +1,11 @@\n+use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::{mir::*, thir::*, ty};\n \n use super::{parse_by_kind, PResult, ParseCtxt};\n \n impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     pub fn parse_statement(&self, expr_id: ExprId) -> PResult<StatementKind<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"statement\",\n+        parse_by_kind!(self, expr_id, _, \"statement\",\n             @call(\"mir_retag\", args) => {\n                 Ok(StatementKind::Retag(RetagKind::Default, Box::new(self.parse_place(args[0])?)))\n             },\n@@ -20,7 +21,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     pub fn parse_terminator(&self, expr_id: ExprId) -> PResult<TerminatorKind<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"terminator\",\n+        parse_by_kind!(self, expr_id, _, \"terminator\",\n             @call(\"mir_return\", _args) => {\n                 Ok(TerminatorKind::Return)\n             },\n@@ -31,7 +32,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"rvalue\",\n+        parse_by_kind!(self, expr_id, _, \"rvalue\",\n             ExprKind::Borrow { borrow_kind, arg } => Ok(\n                 Rvalue::Ref(self.tcx.lifetimes.re_erased, *borrow_kind, self.parse_place(*arg)?)\n             ),\n@@ -43,14 +44,26 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_operand(&self, expr_id: ExprId) -> PResult<Operand<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"operand\",\n+        parse_by_kind!(self, expr_id, expr, \"operand\",\n             @call(\"mir_move\", args) => self.parse_place(args[0]).map(Operand::Move),\n+            @call(\"mir_static\", args) => self.parse_static(args[0]),\n+            @call(\"mir_static_mut\", args) => self.parse_static(args[0]),\n+            ExprKind::Literal { .. }\n+            | ExprKind::NamedConst { .. }\n+            | ExprKind::NonHirLiteral { .. }\n+            | ExprKind::ZstLiteral { .. }\n+            | ExprKind::ConstParam { .. }\n+            | ExprKind::ConstBlock { .. } => {\n+                Ok(Operand::Constant(Box::new(\n+                    crate::build::expr::as_constant::as_constant_inner(expr, |_| None, self.tcx)\n+                )))\n+            },\n             _ => self.parse_place(expr_id).map(Operand::Copy),\n         )\n     }\n \n     fn parse_place(&self, expr_id: ExprId) -> PResult<Place<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"place\",\n+        parse_by_kind!(self, expr_id, _, \"place\",\n             ExprKind::Deref { arg } => Ok(\n                 self.parse_place(*arg)?.project_deeper(&[PlaceElem::Deref], self.tcx)\n             ),\n@@ -59,14 +72,34 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_local(&self, expr_id: ExprId) -> PResult<Local> {\n-        parse_by_kind!(self, expr_id, \"local\",\n+        parse_by_kind!(self, expr_id, _, \"local\",\n             ExprKind::VarRef { id } => Ok(self.local_map[id]),\n         )\n     }\n \n     fn parse_block(&self, expr_id: ExprId) -> PResult<BasicBlock> {\n-        parse_by_kind!(self, expr_id, \"basic block\",\n+        parse_by_kind!(self, expr_id, _, \"basic block\",\n             ExprKind::VarRef { id } => Ok(self.block_map[id]),\n         )\n     }\n+\n+    fn parse_static(&self, expr_id: ExprId) -> PResult<Operand<'tcx>> {\n+        let expr_id = parse_by_kind!(self, expr_id, _, \"static\",\n+            ExprKind::Deref { arg } => *arg,\n+        );\n+\n+        parse_by_kind!(self, expr_id, expr, \"static\",\n+            ExprKind::StaticRef { alloc_id, ty, .. } => {\n+                let const_val =\n+                    ConstValue::Scalar(Scalar::from_pointer((*alloc_id).into(), &self.tcx));\n+                let literal = ConstantKind::Val(const_val, *ty);\n+\n+                Ok(Operand::Constant(Box::new(Constant {\n+                    span: expr.span,\n+                    user_ty: None,\n+                    literal\n+                })))\n+            },\n+        )\n+    }\n }"}, {"sha": "717c62315745b303ca7cef8e1e4d539c24930b4d", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 71, "deletions": 66, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -8,7 +8,9 @@ use rustc_middle::mir::interpret::{\n };\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n-use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, TyCtxt};\n+use rustc_middle::ty::{\n+    self, CanonicalUserType, CanonicalUserTypeAnnotation, TyCtxt, UserTypeAnnotationIndex,\n+};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n \n@@ -19,84 +21,87 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let this = self;\n         let tcx = this.tcx;\n         let Expr { ty, temp_lifetime: _, span, ref kind } = *expr;\n-        match *kind {\n+        match kind {\n             ExprKind::Scope { region_scope: _, lint_level: _, value } => {\n-                this.as_constant(&this.thir[value])\n-            }\n-            ExprKind::Literal { lit, neg } => {\n-                let literal =\n-                    match lit_to_mir_constant(tcx, LitToConstInput { lit: &lit.node, ty, neg }) {\n-                        Ok(c) => c,\n-                        Err(LitToConstError::Reported(guar)) => {\n-                            ConstantKind::Ty(tcx.const_error_with_guaranteed(ty, guar))\n-                        }\n-                        Err(LitToConstError::TypeError) => {\n-                            bug!(\"encountered type error in `lit_to_mir_constant\")\n-                        }\n-                    };\n-\n-                Constant { span, user_ty: None, literal }\n+                this.as_constant(&this.thir[*value])\n             }\n-            ExprKind::NonHirLiteral { lit, ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|user_ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n+            _ => as_constant_inner(\n+                expr,\n+                |user_ty| {\n+                    Some(this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                         span,\n                         user_ty: user_ty.clone(),\n                         inferred_ty: ty,\n-                    })\n-                });\n-                let literal = ConstantKind::Val(ConstValue::Scalar(Scalar::Int(lit)), ty);\n+                    }))\n+                },\n+                tcx,\n+            ),\n+        }\n+    }\n+}\n \n-                Constant { span, user_ty: user_ty, literal }\n-            }\n-            ExprKind::ZstLiteral { ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|user_ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n-                        span,\n-                        user_ty: user_ty.clone(),\n-                        inferred_ty: ty,\n-                    })\n-                });\n-                let literal = ConstantKind::Val(ConstValue::ZeroSized, ty);\n+pub fn as_constant_inner<'tcx>(\n+    expr: &Expr<'tcx>,\n+    push_cuta: impl FnMut(&Box<CanonicalUserType<'tcx>>) -> Option<UserTypeAnnotationIndex>,\n+    tcx: TyCtxt<'tcx>,\n+) -> Constant<'tcx> {\n+    let Expr { ty, temp_lifetime: _, span, ref kind } = *expr;\n+    match *kind {\n+        ExprKind::Literal { lit, neg } => {\n+            let literal =\n+                match lit_to_mir_constant(tcx, LitToConstInput { lit: &lit.node, ty, neg }) {\n+                    Ok(c) => c,\n+                    Err(LitToConstError::Reported(guar)) => {\n+                        ConstantKind::Ty(tcx.const_error_with_guaranteed(ty, guar))\n+                    }\n+                    Err(LitToConstError::TypeError) => {\n+                        bug!(\"encountered type error in `lit_to_mir_constant\")\n+                    }\n+                };\n \n-                Constant { span, user_ty: user_ty, literal }\n-            }\n-            ExprKind::NamedConst { def_id, substs, ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|user_ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n-                        span,\n-                        user_ty: user_ty.clone(),\n-                        inferred_ty: ty,\n-                    })\n-                });\n+            Constant { span, user_ty: None, literal }\n+        }\n+        ExprKind::NonHirLiteral { lit, ref user_ty } => {\n+            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n \n-                let uneval =\n-                    mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n-                let literal = ConstantKind::Unevaluated(uneval, ty);\n+            let literal = ConstantKind::Val(ConstValue::Scalar(Scalar::Int(lit)), ty);\n \n-                Constant { user_ty, span, literal }\n-            }\n-            ExprKind::ConstParam { param, def_id: _ } => {\n-                let const_param = tcx.mk_const(ty::ConstKind::Param(param), expr.ty);\n-                let literal = ConstantKind::Ty(const_param);\n+            Constant { span, user_ty: user_ty, literal }\n+        }\n+        ExprKind::ZstLiteral { ref user_ty } => {\n+            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n \n-                Constant { user_ty: None, span, literal }\n-            }\n-            ExprKind::ConstBlock { did: def_id, substs } => {\n-                let uneval =\n-                    mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n-                let literal = ConstantKind::Unevaluated(uneval, ty);\n+            let literal = ConstantKind::Val(ConstValue::ZeroSized, ty);\n \n-                Constant { user_ty: None, span, literal }\n-            }\n-            ExprKind::StaticRef { alloc_id, ty, .. } => {\n-                let const_val = ConstValue::Scalar(Scalar::from_pointer(alloc_id.into(), &tcx));\n-                let literal = ConstantKind::Val(const_val, ty);\n+            Constant { span, user_ty: user_ty, literal }\n+        }\n+        ExprKind::NamedConst { def_id, substs, ref user_ty } => {\n+            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n \n-                Constant { span, user_ty: None, literal }\n-            }\n-            _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n+            let uneval = mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+            let literal = ConstantKind::Unevaluated(uneval, ty);\n+\n+            Constant { user_ty, span, literal }\n+        }\n+        ExprKind::ConstParam { param, def_id: _ } => {\n+            let const_param = tcx.mk_const(ty::ConstKind::Param(param), expr.ty);\n+            let literal = ConstantKind::Ty(const_param);\n+\n+            Constant { user_ty: None, span, literal }\n+        }\n+        ExprKind::ConstBlock { did: def_id, substs } => {\n+            let uneval = mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+            let literal = ConstantKind::Unevaluated(uneval, ty);\n+\n+            Constant { user_ty: None, span, literal }\n+        }\n+        ExprKind::StaticRef { alloc_id, ty, .. } => {\n+            let const_val = ConstValue::Scalar(Scalar::from_pointer(alloc_id.into(), &tcx));\n+            let literal = ConstantKind::Val(const_val, ty);\n+\n+            Constant { span, user_ty: None, literal }\n         }\n+        _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n     }\n }\n "}, {"sha": "d33401f07645e1db6f4a97a0ea570b341d0a04a4", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2,35 +2,35 @@ use rustc_middle::thir::*;\n \n #[derive(Debug, PartialEq)]\n pub(crate) enum Category {\n-    // An assignable memory location like `x`, `x.f`, `foo()[3]`, that\n-    // sort of thing. Something that could appear on the LHS of an `=`\n-    // sign.\n+    /// An assignable memory location like `x`, `x.f`, `foo()[3]`, that\n+    /// sort of thing. Something that could appear on the LHS of an `=`\n+    /// sign.\n     Place,\n \n-    // A literal like `23` or `\"foo\"`. Does not include constant\n-    // expressions like `3 + 5`.\n+    /// A literal like `23` or `\"foo\"`. Does not include constant\n+    /// expressions like `3 + 5`.\n     Constant,\n \n-    // Something that generates a new value at runtime, like `x + y`\n-    // or `foo()`.\n+    /// Something that generates a new value at runtime, like `x + y`\n+    /// or `foo()`.\n     Rvalue(RvalueFunc),\n }\n \n-// Rvalues fall into different \"styles\" that will determine which fn\n-// is best suited to generate them.\n+/// Rvalues fall into different \"styles\" that will determine which fn\n+/// is best suited to generate them.\n #[derive(Debug, PartialEq)]\n pub(crate) enum RvalueFunc {\n-    // Best generated by `into`. This is generally exprs that\n-    // cause branching, like `match`, but also includes calls.\n+    /// Best generated by `into`. This is generally exprs that\n+    /// cause branching, like `match`, but also includes calls.\n     Into,\n \n-    // Best generated by `as_rvalue`. This is usually the case.\n+    /// Best generated by `as_rvalue`. This is usually the case.\n     AsRvalue,\n }\n \n-/// Determines the category for a given expression. Note that scope\n-/// and paren expressions have no category.\n impl Category {\n+    /// Determines the category for a given expression. Note that scope\n+    /// and paren expressions have no category.\n     pub(crate) fn of(ek: &ExprKind<'_>) -> Option<Category> {\n         match *ek {\n             ExprKind::Scope { .. } => None,"}, {"sha": "baeb2718cae46414636eeafabd1bd414b639b5bd", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -34,8 +34,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         Operand::Constant(constant)\n     }\n \n-    // Returns a zero literal operand for the appropriate type, works for\n-    // bool, char and integers.\n+    /// Returns a zero literal operand for the appropriate type, works for\n+    /// bool, char and integers.\n     pub(crate) fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let literal = ConstantKind::from_bits(self.tcx, 0, ty::ParamEnv::empty().and(ty));\n "}, {"sha": "b456e2aa37a2791fae3f40a8868c9ff70bcea9b7", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -492,7 +492,7 @@ fn construct_fn<'tcx>(\n             arguments,\n             return_ty,\n             return_ty_span,\n-            span,\n+            span_with_body,\n             custom_mir_attr,\n         );\n     }"}, {"sha": "5ddae5f5300f664e5190d5ebfbf1286228274d7f", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -443,8 +443,9 @@ impl<'tcx> Scopes<'tcx> {\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Adding and removing scopes\n     // ==========================\n-    //  Start a breakable scope, which tracks where `continue`, `break` and\n-    //  `return` should branch to.\n+\n+    ///  Start a breakable scope, which tracks where `continue`, `break` and\n+    ///  `return` should branch to.\n     pub(crate) fn in_breakable_scope<F>(\n         &mut self,\n         loop_block: Option<BasicBlock>,\n@@ -799,6 +800,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     // Finding scopes\n     // ==============\n+\n     /// Returns the scope that we should use as the lifetime of an\n     /// operand. Basically, an operand must live until it is consumed.\n     /// This is similar to, but not quite the same as, the temporary\n@@ -824,6 +826,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     // Scheduling drops\n     // ================\n+\n     pub(crate) fn schedule_drop_storage_and_value(\n         &mut self,\n         span: Span,\n@@ -996,6 +999,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     // Other\n     // =====\n+\n     /// Returns the [DropIdx] for the innermost drop if the function unwound at\n     /// this point. The `DropIdx` will be created if it doesn't already exist.\n     fn diverge_cleanup(&mut self) -> DropIdx {"}, {"sha": "a9ed945d4a15a9b3356653fb623d40ed6b0ed6d5", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -61,5 +61,5 @@ pub(crate) fn lit_to_const<'tcx>(\n         _ => return Err(LitToConstError::TypeError),\n     };\n \n-    Ok(ty::Const::from_value(tcx, valtree, ty))\n+    Ok(tcx.mk_const(valtree, ty))\n }"}, {"sha": "9b2260f68251abeaafe883d76d192ee94e34d9cc", "filename": "compiler/rustc_mir_transform/src/add_moves_for_packed_drops.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -5,37 +5,36 @@ use crate::util;\n use crate::MirPass;\n use rustc_middle::mir::patch::MirPatch;\n \n-// This pass moves values being dropped that are within a packed\n-// struct to a separate local before dropping them, to ensure that\n-// they are dropped from an aligned address.\n-//\n-// For example, if we have something like\n-// ```Rust\n-//     #[repr(packed)]\n-//     struct Foo {\n-//         dealign: u8,\n-//         data: Vec<u8>\n-//     }\n-//\n-//     let foo = ...;\n-// ```\n-//\n-// We want to call `drop_in_place::<Vec<u8>>` on `data` from an aligned\n-// address. This means we can't simply drop `foo.data` directly, because\n-// its address is not aligned.\n-//\n-// Instead, we move `foo.data` to a local and drop that:\n-// ```\n-//     storage.live(drop_temp)\n-//     drop_temp = foo.data;\n-//     drop(drop_temp) -> next\n-// next:\n-//     storage.dead(drop_temp)\n-// ```\n-//\n-// The storage instructions are required to avoid stack space\n-// blowup.\n-\n+/// This pass moves values being dropped that are within a packed\n+/// struct to a separate local before dropping them, to ensure that\n+/// they are dropped from an aligned address.\n+///\n+/// For example, if we have something like\n+/// ```ignore (ilustrative)\n+/// #[repr(packed)]\n+/// struct Foo {\n+///     dealign: u8,\n+///     data: Vec<u8>\n+/// }\n+///\n+/// let foo = ...;\n+/// ```\n+///\n+/// We want to call `drop_in_place::<Vec<u8>>` on `data` from an aligned\n+/// address. This means we can't simply drop `foo.data` directly, because\n+/// its address is not aligned.\n+///\n+/// Instead, we move `foo.data` to a local and drop that:\n+/// ```ignore (ilustrative)\n+///     storage.live(drop_temp)\n+///     drop_temp = foo.data;\n+///     drop(drop_temp) -> next\n+/// next:\n+///     storage.dead(drop_temp)\n+/// ```\n+///\n+/// The storage instructions are required to avoid stack space\n+/// blowup.\n pub struct AddMovesForPackedDrops;\n \n impl<'tcx> MirPass<'tcx> for AddMovesForPackedDrops {"}, {"sha": "932134bd6318f44d6ccacbb06ac1b0ff8e4cf188", "filename": "compiler/rustc_mir_transform/src/elaborate_box_derefs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -25,7 +25,7 @@ pub fn build_ptr_tys<'tcx>(\n     (unique_ty, nonnull_ty, ptr_ty)\n }\n \n-// Constructs the projection needed to access a Box's pointer\n+/// Constructs the projection needed to access a Box's pointer\n pub fn build_projection<'tcx>(\n     unique_ty: Ty<'tcx>,\n     nonnull_ty: Ty<'tcx>,"}, {"sha": "a115bb2831a4b2c1c1ec7dc04d4015495200a30e", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -37,7 +37,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n         }\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n-            let adjustment = match tcx.fn_trait_kind_from_lang_item(trait_) {\n+            let adjustment = match tcx.fn_trait_kind_from_def_id(trait_) {\n                 Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n                 Some(ty::ClosureKind::FnMut | ty::ClosureKind::Fn) => Adjustment::Deref,\n                 None => bug!(\"fn pointer {:?} is not an fn\", ty),"}, {"sha": "cf7226a129ce7fb42aee119c6efccbe7104325eb", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -295,8 +295,8 @@ impl<'tcx> InliningMap<'tcx> {\n         assert!(self.index.insert(source, start_index..end_index).is_none());\n     }\n \n-    // Internally iterate over all items referenced by `source` which will be\n-    // made available for inlining.\n+    /// Internally iterate over all items referenced by `source` which will be\n+    /// made available for inlining.\n     pub fn with_inlining_candidates<F>(&self, source: MonoItem<'tcx>, mut f: F)\n     where\n         F: FnMut(MonoItem<'tcx>),\n@@ -310,7 +310,7 @@ impl<'tcx> InliningMap<'tcx> {\n         }\n     }\n \n-    // Internally iterate over all items and the things each accesses.\n+    /// Internally iterate over all items and the things each accesses.\n     pub fn iter_accesses<F>(&self, mut f: F)\n     where\n         F: FnMut(MonoItem<'tcx>, &[MonoItem<'tcx>]),"}, {"sha": "f1b50296e2565a858e0442b88e192e1fdf12e7e2", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,5 +1,5 @@\n-// Characters and their corresponding confusables were collected from\n-// https://www.unicode.org/Public/security/10.0.0/confusables.txt\n+//! Characters and their corresponding confusables were collected from\n+//! <https://www.unicode.org/Public/security/10.0.0/confusables.txt>\n \n use super::StringReader;\n use crate::token::{self, Delimiter};"}, {"sha": "c7d239b647f35b2bc273fdc0185a5cf224f13ac9", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -315,8 +315,9 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    pub(crate) fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n-        let lit = self.parse_ast_lit()?;\n+    // Note: must be unsuffixed.\n+    pub(crate) fn parse_unsuffixed_meta_item_lit(&mut self) -> PResult<'a, ast::MetaItemLit> {\n+        let lit = self.parse_meta_item_lit()?;\n         debug!(\"checking if {:?} is unsuffixed\", lit);\n \n         if !lit.kind.is_unsuffixed() {\n@@ -391,7 +392,7 @@ impl<'a> Parser<'a> {\n \n     pub(crate) fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n         Ok(if self.eat(&token::Eq) {\n-            ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n+            ast::MetaItemKind::NameValue(self.parse_unsuffixed_meta_item_lit()?)\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             // Matches `meta_seq = ( COMMASEP(meta_item_inner) )`.\n             let (list, _) = self.parse_paren_comma_seq(|p| p.parse_meta_item_inner())?;\n@@ -403,8 +404,8 @@ impl<'a> Parser<'a> {\n \n     /// Matches `meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;`.\n     fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n-        match self.parse_unsuffixed_lit() {\n-            Ok(lit) => return Ok(ast::NestedMetaItem::Literal(lit)),\n+        match self.parse_unsuffixed_meta_item_lit() {\n+            Ok(lit) => return Ok(ast::NestedMetaItem::Lit(lit)),\n             Err(err) => err.cancel(),\n         }\n "}, {"sha": "a084a7010885927344a3e24e834cd27e03e00fcb", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -50,7 +50,7 @@ impl AttrWrapper {\n         self.attrs\n     }\n \n-    // Prepend `self.attrs` to `attrs`.\n+    /// Prepend `self.attrs` to `attrs`.\n     // FIXME: require passing an NT to prevent misuse of this method\n     pub(crate) fn prepend_to_nt_inner(self, attrs: &mut AttrVec) {\n         let mut self_attrs = self.attrs;"}, {"sha": "c316a4dd6b41ad346527e1ff0b31512d06434a0f", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -224,9 +224,9 @@ impl MultiSugg {\n     }\n }\n \n-// SnapshotParser is used to create a snapshot of the parser\n-// without causing duplicate errors being emitted when the `Parser`\n-// is dropped.\n+/// SnapshotParser is used to create a snapshot of the parser\n+/// without causing duplicate errors being emitted when the `Parser`\n+/// is dropped.\n pub struct SnapshotParser<'a> {\n     parser: Parser<'a>,\n     unclosed_delims: Vec<UnmatchedBrace>,"}, {"sha": "e0443a697b50415fc950376706034f3aacdb9085", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -33,10 +33,10 @@ use rustc_ast::util::case::Case;\n use rustc_ast::util::classify;\n use rustc_ast::util::parser::{prec_let_scrutinee_needs_par, AssocOp, Fixity};\n use rustc_ast::visit::Visitor;\n-use rustc_ast::{self as ast, AttrStyle, AttrVec, CaptureBy, ExprField, Lit, UnOp, DUMMY_NODE_ID};\n+use rustc_ast::{self as ast, AttrStyle, AttrVec, CaptureBy, ExprField, UnOp, DUMMY_NODE_ID};\n use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty, TyKind};\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n-use rustc_ast::{ClosureBinder, StmtKind};\n+use rustc_ast::{ClosureBinder, MetaItemLit, StmtKind};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{\n     Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n@@ -1631,7 +1631,7 @@ impl<'a> Parser<'a> {\n         &self,\n         lifetime: Ident,\n         err: impl FnOnce(&Self) -> DiagnosticBuilder<'a, ErrorGuaranteed>,\n-    ) -> ast::Lit {\n+    ) -> ast::MetaItemLit {\n         if let Some(mut diag) =\n             self.sess.span_diagnostic.steal_diagnostic(lifetime.span, StashKey::LifetimeIsChar)\n         {\n@@ -1653,7 +1653,7 @@ impl<'a> Parser<'a> {\n                 .emit();\n         }\n         let name = lifetime.without_first_quote().name;\n-        ast::Lit {\n+        ast::MetaItemLit {\n             token_lit: token::Lit::new(token::LitKind::Char, name, None),\n             kind: ast::LitKind::Char(name.as_str().chars().next().unwrap_or('_')),\n             span: lifetime.span,\n@@ -1768,8 +1768,8 @@ impl<'a> Parser<'a> {\n     /// Returns a string literal if the next token is a string literal.\n     /// In case of error returns `Some(lit)` if the next token is a literal with a wrong kind,\n     /// and returns `None` if the next token is not literal at all.\n-    pub fn parse_str_lit(&mut self) -> Result<ast::StrLit, Option<Lit>> {\n-        match self.parse_opt_ast_lit() {\n+    pub fn parse_str_lit(&mut self) -> Result<ast::StrLit, Option<MetaItemLit>> {\n+        match self.parse_opt_meta_item_lit() {\n             Some(lit) => match lit.kind {\n                 ast::LitKind::Str(symbol_unescaped, style) => Ok(ast::StrLit {\n                     style,\n@@ -1784,7 +1784,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn handle_missing_lit(&mut self) -> PResult<'a, Lit> {\n+    fn handle_missing_lit(&mut self) -> PResult<'a, MetaItemLit> {\n         if let token::Interpolated(inner) = &self.token.kind {\n             let expr = match inner.as_ref() {\n                 token::NtExpr(expr) => Some(expr),\n@@ -1820,8 +1820,8 @@ impl<'a> Parser<'a> {\n             .or_else(|()| self.handle_missing_lit().map(|lit| (lit.token_lit, lit.span)))\n     }\n \n-    pub(super) fn parse_ast_lit(&mut self) -> PResult<'a, Lit> {\n-        self.parse_opt_ast_lit().ok_or(()).or_else(|()| self.handle_missing_lit())\n+    pub(super) fn parse_meta_item_lit(&mut self) -> PResult<'a, MetaItemLit> {\n+        self.parse_opt_meta_item_lit().ok_or(()).or_else(|()| self.handle_missing_lit())\n     }\n \n     fn recover_after_dot(&mut self) -> Option<Token> {\n@@ -1867,12 +1867,12 @@ impl<'a> Parser<'a> {\n \n     /// Matches `lit = true | false | token_lit`.\n     /// Returns `None` if the next token is not a literal.\n-    pub(super) fn parse_opt_ast_lit(&mut self) -> Option<Lit> {\n+    pub(super) fn parse_opt_meta_item_lit(&mut self) -> Option<MetaItemLit> {\n         let recovered = self.recover_after_dot();\n         let token = recovered.as_ref().unwrap_or(&self.token);\n         match token::Lit::from_token(token) {\n             Some(token_lit) => {\n-                match Lit::from_token_lit(token_lit, token.span) {\n+                match MetaItemLit::from_token_lit(token_lit, token.span) {\n                     Ok(lit) => {\n                         self.bump();\n                         Some(lit)\n@@ -1889,7 +1889,10 @@ impl<'a> Parser<'a> {\n                         let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n                         let symbol = Symbol::intern(&suffixless_lit.to_string());\n                         let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n-                        Some(Lit::from_token_lit(lit, span).unwrap_or_else(|_| unreachable!()))\n+                        Some(\n+                            MetaItemLit::from_token_lit(lit, span)\n+                                .unwrap_or_else(|_| unreachable!()),\n+                        )\n                     }\n                 }\n             }"}, {"sha": "84c632199203aa76b3a09759ee28309f258c5fe4", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1012,7 +1012,7 @@ impl<'a> Parser<'a> {\n                     prefix.span = lo.to(self.prev_token.span);\n                 }\n \n-                UseTreeKind::Simple(self.parse_rename()?, DUMMY_NODE_ID, DUMMY_NODE_ID)\n+                UseTreeKind::Simple(self.parse_rename()?)\n             }\n         };\n "}, {"sha": "ff1ddfd97dfc62dc52e183f64fb1280433d44ce7", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -358,7 +358,7 @@ impl<'a> Parser<'a> {\n     /// report error for `let 1x = 123`\n     pub fn report_invalid_identifier_error(&mut self) -> PResult<'a, ()> {\n         if let token::Literal(lit) = self.token.uninterpolate().kind &&\n-            rustc_ast::Lit::from_token(&self.token).is_none() &&\n+            rustc_ast::MetaItemLit::from_token(&self.token).is_none() &&\n             (lit.kind == token::LitKind::Integer || lit.kind == token::LitKind::Float) &&\n             self.look_ahead(1, |t| matches!(t.kind, token::Eq) || matches!(t.kind, token::Colon ) ) {\n                 return Err(self.sess.create_err(InvalidIdentiferStartsWithNumber { span: self.token.span }));"}, {"sha": "72402a200907afcd0387bca0687f8e0511ddb0f6", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -10,9 +10,9 @@ use rustc_errors::{Applicability, FatalError, PResult};\n use rustc_feature::{AttributeTemplate, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_session::lint::builtin::ILL_FORMED_ATTRIBUTE_INPUT;\n use rustc_session::parse::ParseSess;\n-use rustc_span::{sym, Symbol};\n+use rustc_span::{sym, Span, Symbol};\n \n-pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n+pub fn check_attr(sess: &ParseSess, attr: &Attribute) {\n     if attr.is_doc_comment() {\n         return;\n     }\n@@ -51,7 +51,7 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n             }\n             AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => {\n                 if let ast::ExprKind::Lit(token_lit) = expr.kind\n-                    && let Ok(lit) = ast::Lit::from_token_lit(token_lit, expr.span)\n+                    && let Ok(lit) = ast::MetaItemLit::from_token_lit(token_lit, expr.span)\n                 {\n                     if token_lit.suffix.is_some() {\n                         let mut err = sess.span_diagnostic.struct_span_err(\n@@ -115,25 +115,34 @@ pub fn check_builtin_attribute(\n     name: Symbol,\n     template: AttributeTemplate,\n ) {\n-    // Some special attributes like `cfg` must be checked\n-    // before the generic check, so we skip them here.\n-    let should_skip = |name| name == sym::cfg;\n-\n     match parse_meta(sess, attr) {\n-        Ok(meta) => {\n-            if !should_skip(name) && !is_attr_template_compatible(&template, &meta.kind) {\n-                emit_malformed_attribute(sess, attr, name, template);\n-            }\n-        }\n+        Ok(meta) => check_builtin_meta_item(sess, &meta, attr.style, name, template),\n         Err(mut err) => {\n             err.emit();\n         }\n     }\n }\n \n+pub fn check_builtin_meta_item(\n+    sess: &ParseSess,\n+    meta: &MetaItem,\n+    style: ast::AttrStyle,\n+    name: Symbol,\n+    template: AttributeTemplate,\n+) {\n+    // Some special attributes like `cfg` must be checked\n+    // before the generic check, so we skip them here.\n+    let should_skip = |name| name == sym::cfg;\n+\n+    if !should_skip(name) && !is_attr_template_compatible(&template, &meta.kind) {\n+        emit_malformed_attribute(sess, style, meta.span, name, template);\n+    }\n+}\n+\n fn emit_malformed_attribute(\n     sess: &ParseSess,\n-    attr: &Attribute,\n+    style: ast::AttrStyle,\n+    span: Span,\n     name: Symbol,\n     template: AttributeTemplate,\n ) {\n@@ -147,7 +156,7 @@ fn emit_malformed_attribute(\n     let mut msg = \"attribute must be of the form \".to_owned();\n     let mut suggestions = vec![];\n     let mut first = true;\n-    let inner = if attr.style == ast::AttrStyle::Inner { \"!\" } else { \"\" };\n+    let inner = if style == ast::AttrStyle::Inner { \"!\" } else { \"\" };\n     if template.word {\n         first = false;\n         let code = format!(\"#{}[{}]\", inner, name);\n@@ -172,12 +181,12 @@ fn emit_malformed_attribute(\n         suggestions.push(code);\n     }\n     if should_warn(name) {\n-        sess.buffer_lint(&ILL_FORMED_ATTRIBUTE_INPUT, attr.span, ast::CRATE_NODE_ID, &msg);\n+        sess.buffer_lint(&ILL_FORMED_ATTRIBUTE_INPUT, span, ast::CRATE_NODE_ID, &msg);\n     } else {\n         sess.span_diagnostic\n-            .struct_span_err(attr.span, &error_msg)\n+            .struct_span_err(span, &error_msg)\n             .span_suggestions(\n-                attr.span,\n+                span,\n                 if suggestions.len() == 1 {\n                     \"must be of the form\"\n                 } else {\n@@ -196,7 +205,7 @@ pub fn emit_fatal_malformed_builtin_attribute(\n     name: Symbol,\n ) -> ! {\n     let template = BUILTIN_ATTRIBUTE_MAP.get(&name).expect(\"builtin attr defined\").template;\n-    emit_malformed_attribute(sess, attr, name, template);\n+    emit_malformed_attribute(sess, attr.style, attr.span, name, template);\n     // This is fatal, otherwise it will likely cause a cascade of other errors\n     // (and an error here is expected to be very rare).\n     FatalError.raise()"}, {"sha": "2e2874dbccb9e4fb3749f901398f9310e9212f4b", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -8,7 +8,7 @@ use crate::errors::{\n     self, AttrApplication, DebugVisualizerUnreadable, InvalidAttrAtCrateLevel, ObjectLifetimeErr,\n     OnlyHasEffectOn, TransparentIncompatible, UnrecognizedReprHint,\n };\n-use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{ast, AttrStyle, Attribute, LitKind, MetaItemKind, MetaItemLit, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{fluent, Applicability, MultiSpan};\n use rustc_expand::base::resolve_path;\n@@ -715,7 +715,7 @@ impl CheckAttrVisitor<'_> {\n         if let Some(values) = meta.meta_item_list() {\n             let mut errors = 0;\n             for v in values {\n-                match v.literal() {\n+                match v.lit() {\n                     Some(l) => match l.kind {\n                         LitKind::Str(s, _) => {\n                             if !self.check_doc_alias_value(v, s, hir_id, target, true, aliases) {\n@@ -1355,7 +1355,7 @@ impl CheckAttrVisitor<'_> {\n             return false;\n         };\n \n-        if matches!(&list[..], &[NestedMetaItem::Literal(Lit { kind: LitKind::Int(..), .. })]) {\n+        if matches!(&list[..], &[NestedMetaItem::Lit(MetaItemLit { kind: LitKind::Int(..), .. })]) {\n             true\n         } else {\n             self.tcx.sess.emit_err(errors::RustcLayoutScalarValidRangeArg { attr_span: attr.span });\n@@ -1418,7 +1418,7 @@ impl CheckAttrVisitor<'_> {\n         let arg_count = decl.inputs.len() as u128 + generics.params.len() as u128;\n         let mut invalid_args = vec![];\n         for meta in list {\n-            if let Some(LitKind::Int(val, _)) = meta.literal().map(|lit| &lit.kind) {\n+            if let Some(LitKind::Int(val, _)) = meta.lit().map(|lit| &lit.kind) {\n                 if *val >= arg_count {\n                     let span = meta.span();\n                     self.tcx.sess.emit_err(errors::RustcLegacyConstGenericsIndexExceed {"}, {"sha": "da023fcf4c3b5c23405cacb7bca785998dd95c94", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -433,7 +433,7 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n         self.in_pat = false;\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &hir::Path<'tcx>, _: hir::HirId) {\n         self.handle_res(path.res);\n         intravisit::walk_path(self, path);\n     }"}, {"sha": "d143adb2eb9417c50e879e693296dedf428fba94", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,11 +1,11 @@\n use rustc_data_structures::sync::Lock;\n use rustc_hir as hir;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit;\n use rustc_hir::{HirId, ItemLocalId};\n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{DefIdTree, TyCtxt};\n \n pub fn check_crate(tcx: TyCtxt<'_>) {\n     tcx.dep_graph.assert_ignored();\n@@ -17,11 +17,10 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n     #[cfg(debug_assertions)]\n     {\n         let errors = Lock::new(Vec::new());\n-        let hir_map = tcx.hir();\n \n-        hir_map.par_for_each_module(|module_id| {\n+        tcx.hir().par_for_each_module(|module_id| {\n             let mut v = HirIdValidator {\n-                hir_map,\n+                tcx,\n                 owner: None,\n                 hir_ids_seen: Default::default(),\n                 errors: &errors,\n@@ -40,20 +39,15 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n }\n \n struct HirIdValidator<'a, 'hir> {\n-    hir_map: Map<'hir>,\n+    tcx: TyCtxt<'hir>,\n     owner: Option<hir::OwnerId>,\n     hir_ids_seen: GrowableBitSet<ItemLocalId>,\n     errors: &'a Lock<Vec<String>>,\n }\n \n impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n-    fn new_visitor(&self, hir_map: Map<'hir>) -> HirIdValidator<'a, 'hir> {\n-        HirIdValidator {\n-            hir_map,\n-            owner: None,\n-            hir_ids_seen: Default::default(),\n-            errors: self.errors,\n-        }\n+    fn new_visitor(&self, tcx: TyCtxt<'hir>) -> HirIdValidator<'a, 'hir> {\n+        HirIdValidator { tcx, owner: None, hir_ids_seen: Default::default(), errors: self.errors }\n     }\n \n     #[cold]\n@@ -96,36 +90,69 @@ impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n                 missing_items.push(format!(\n                     \"[local_id: {}, owner: {}]\",\n                     local_id,\n-                    self.hir_map.def_path(owner.def_id).to_string_no_crate_verbose()\n+                    self.tcx.hir().def_path(owner.def_id).to_string_no_crate_verbose()\n                 ));\n             }\n             self.error(|| {\n                 format!(\n                     \"ItemLocalIds not assigned densely in {}. \\\n                 Max ItemLocalId = {}, missing IDs = {:#?}; seens IDs = {:#?}\",\n-                    self.hir_map.def_path(owner.def_id).to_string_no_crate_verbose(),\n+                    self.tcx.hir().def_path(owner.def_id).to_string_no_crate_verbose(),\n                     max,\n                     missing_items,\n                     self.hir_ids_seen\n                         .iter()\n                         .map(|local_id| HirId { owner, local_id })\n-                        .map(|h| format!(\"({:?} {})\", h, self.hir_map.node_to_string(h)))\n+                        .map(|h| format!(\"({:?} {})\", h, self.tcx.hir().node_to_string(h)))\n                         .collect::<Vec<_>>()\n                 )\n             });\n         }\n     }\n+\n+    fn check_nested_id(&mut self, id: LocalDefId) {\n+        let Some(owner) = self.owner else { return };\n+        let def_parent = self.tcx.local_parent(id);\n+        let def_parent_hir_id = self.tcx.local_def_id_to_hir_id(def_parent);\n+        if def_parent_hir_id.owner != owner {\n+            self.error(|| {\n+                format!(\n+                    \"inconsistent Def parent at `{:?}` for `{:?}`:\\nexpected={:?}\\nfound={:?}\",\n+                    self.tcx.def_span(id),\n+                    id,\n+                    owner,\n+                    def_parent_hir_id\n+                )\n+            });\n+        }\n+    }\n }\n \n impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n     type NestedFilter = nested_filter::OnlyBodies;\n \n     fn nested_visit_map(&mut self) -> Self::Map {\n-        self.hir_map\n+        self.tcx.hir()\n+    }\n+\n+    fn visit_nested_item(&mut self, id: hir::ItemId) {\n+        self.check_nested_id(id.owner_id.def_id);\n+    }\n+\n+    fn visit_nested_trait_item(&mut self, id: hir::TraitItemId) {\n+        self.check_nested_id(id.owner_id.def_id);\n+    }\n+\n+    fn visit_nested_impl_item(&mut self, id: hir::ImplItemId) {\n+        self.check_nested_id(id.owner_id.def_id);\n+    }\n+\n+    fn visit_nested_foreign_item(&mut self, id: hir::ForeignItemId) {\n+        self.check_nested_id(id.owner_id.def_id);\n     }\n \n     fn visit_item(&mut self, i: &'hir hir::Item<'hir>) {\n-        let mut inner_visitor = self.new_visitor(self.hir_map);\n+        let mut inner_visitor = self.new_visitor(self.tcx);\n         inner_visitor.check(i.owner_id, |this| intravisit::walk_item(this, i));\n     }\n \n@@ -136,9 +163,9 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n             self.error(|| {\n                 format!(\n                     \"HirIdValidator: The recorded owner of {} is {} instead of {}\",\n-                    self.hir_map.node_to_string(hir_id),\n-                    self.hir_map.def_path(hir_id.owner.def_id).to_string_no_crate_verbose(),\n-                    self.hir_map.def_path(owner.def_id).to_string_no_crate_verbose()\n+                    self.tcx.hir().node_to_string(hir_id),\n+                    self.tcx.hir().def_path(hir_id.owner.def_id).to_string_no_crate_verbose(),\n+                    self.tcx.hir().def_path(owner.def_id).to_string_no_crate_verbose()\n                 )\n             });\n         }\n@@ -147,17 +174,17 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &'hir hir::ForeignItem<'hir>) {\n-        let mut inner_visitor = self.new_visitor(self.hir_map);\n+        let mut inner_visitor = self.new_visitor(self.tcx);\n         inner_visitor.check(i.owner_id, |this| intravisit::walk_foreign_item(this, i));\n     }\n \n     fn visit_trait_item(&mut self, i: &'hir hir::TraitItem<'hir>) {\n-        let mut inner_visitor = self.new_visitor(self.hir_map);\n+        let mut inner_visitor = self.new_visitor(self.tcx);\n         inner_visitor.check(i.owner_id, |this| intravisit::walk_trait_item(this, i));\n     }\n \n     fn visit_impl_item(&mut self, i: &'hir hir::ImplItem<'hir>) {\n-        let mut inner_visitor = self.new_visitor(self.hir_map);\n+        let mut inner_visitor = self.new_visitor(self.tcx);\n         inner_visitor.check(i.owner_id, |this| intravisit::walk_impl_item(this, i));\n     }\n }"}, {"sha": "a7854cd49988f721806864a33570b646bc5379d2", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -369,7 +369,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_fn(self, fk, fd, b, id)\n     }\n \n-    fn visit_use(&mut self, p: &'v hir::Path<'v>, hir_id: hir::HirId) {\n+    fn visit_use(&mut self, p: &'v hir::UsePath<'v>, hir_id: hir::HirId) {\n         // This is `visit_use`, but the type is `Path` so record it that way.\n         self.record(\"Path\", Id::None, p);\n         hir_visit::walk_use(self, p, hir_id)\n@@ -442,7 +442,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_lifetime(self, lifetime)\n     }\n \n-    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n+    fn visit_path(&mut self, path: &hir::Path<'v>, _id: hir::HirId) {\n         self.record(\"Path\", Id::None, path);\n         hir_visit::walk_path(self, path)\n     }"}, {"sha": "e7c3c712852ddc10b7993db636277a3eb3625cda", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -116,6 +116,17 @@ impl<'tcx> Visitor<'tcx> for ReachableContext<'tcx> {\n \n         intravisit::walk_expr(self, expr)\n     }\n+\n+    fn visit_inline_asm(&mut self, asm: &'tcx hir::InlineAsm<'tcx>, id: hir::HirId) {\n+        for (op, _) in asm.operands {\n+            if let hir::InlineAsmOperand::SymStatic { def_id, .. } = op {\n+                if let Some(def_id) = def_id.as_local() {\n+                    self.reachable_symbols.insert(def_id);\n+                }\n+            }\n+        }\n+        intravisit::walk_inline_asm(self, asm, id);\n+    }\n }\n \n impl<'tcx> ReachableContext<'tcx> {"}, {"sha": "da715523474f9bc6cb63c8da1b83880f71a67682", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -787,7 +787,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n+    fn visit_path(&mut self, path: &hir::Path<'tcx>, id: hir::HirId) {\n         if let Some(def_id) = path.res.opt_def_id() {\n             let method_span = path.segments.last().map(|s| s.ident.span);\n             let item_is_allowed = self.tcx.check_stability_allow_unstable(\n@@ -880,7 +880,7 @@ struct CheckTraitImplStable<'tcx> {\n }\n \n impl<'tcx> Visitor<'tcx> for CheckTraitImplStable<'tcx> {\n-    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _id: hir::HirId) {\n+    fn visit_path(&mut self, path: &hir::Path<'tcx>, _id: hir::HirId) {\n         if let Some(def_id) = path.res.opt_def_id() {\n             if let Some(stab) = self.tcx.lookup_stability(def_id) {\n                 self.fully_stable &= stab.level.is_stable();"}, {"sha": "605cf0a93b877aa255df7aaa99cb7e7823ccfdd5", "filename": "compiler/rustc_passes/src/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_passes%2Fsrc%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fupvars.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -66,7 +66,7 @@ impl CaptureCollector<'_, '_> {\n }\n \n impl<'tcx> Visitor<'tcx> for CaptureCollector<'_, 'tcx> {\n-    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &hir::Path<'tcx>, _: hir::HirId) {\n         if let Res::Local(var_id) = path.res {\n             self.visit_local_use(var_id, path.span);\n         }"}, {"sha": "ac9653b90071cdacd01923cd3bb2c6c42479be14", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -818,6 +818,12 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>\n     }\n }\n \n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Clause<'tcx>, Span)] {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [rustc_ast::InlineAsmTemplatePiece] {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)"}, {"sha": "8d5d84c5db48a17d553e6b532fa5a8b775f3ebce", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -252,6 +252,18 @@ macro_rules! depth_limit {\n     };\n }\n \n+macro_rules! feedable {\n+    ([]) => {{\n+        false\n+    }};\n+    ([(feedable) $($rest:tt)*]) => {{\n+        true\n+    }};\n+    ([$other:tt $($modifiers:tt)*]) => {\n+        feedable!([$($modifiers)*])\n+    };\n+}\n+\n macro_rules! hash_result {\n     ([]) => {{\n         Some(dep_graph::hash_result)\n@@ -309,7 +321,7 @@ pub(crate) fn create_query_frame<\n         ty::print::with_forced_impl_filename_line!(do_describe(tcx.tcx, key))\n     );\n     let description =\n-        if tcx.sess.verbose() { format!(\"{} [{}]\", description, name) } else { description };\n+        if tcx.sess.verbose() { format!(\"{} [{:?}]\", description, name) } else { description };\n     let span = if kind == dep_graph::DepKind::def_span {\n         // The `def_span` query is used to calculate `default_span`,\n         // so exit to avoid infinite recursion.\n@@ -491,6 +503,7 @@ macro_rules! define_queries {\n                     anon: is_anon!([$($modifiers)*]),\n                     eval_always: is_eval_always!([$($modifiers)*]),\n                     depth_limit: depth_limit!([$($modifiers)*]),\n+                    feedable: feedable!([$($modifiers)*]),\n                     dep_kind: dep_graph::DepKind::$name,\n                     hash_result: hash_result!([$($modifiers)*]),\n                     handle_cycle_error: handle_cycle_error!([$($modifiers)*]),"}, {"sha": "e44857a023857f4a928062c44ca6d776defcf48b", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 132, "deletions": 31, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -489,6 +489,91 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    /// Create a node when we force-feed a value into the query cache.\n+    /// This is used to remove cycles during type-checking const generic parameters.\n+    ///\n+    /// As usual in the query system, we consider the current state of the calling query\n+    /// only depends on the list of dependencies up to now.  As a consequence, the value\n+    /// that this query gives us can only depend on those dependencies too.  Therefore,\n+    /// it is sound to use the current dependency set for the created node.\n+    ///\n+    /// During replay, the order of the nodes is relevant in the dependency graph.\n+    /// So the unchanged replay will mark the caller query before trying to mark this one.\n+    /// If there is a change to report, the caller query will be re-executed before this one.\n+    ///\n+    /// FIXME: If the code is changed enough for this node to be marked before requiring the\n+    /// caller's node, we suppose that those changes will be enough to mark this node red and\n+    /// force a recomputation using the \"normal\" way.\n+    pub fn with_feed_task<Ctxt: DepContext<DepKind = K>, A: Debug, R: Debug>(\n+        &self,\n+        node: DepNode<K>,\n+        cx: Ctxt,\n+        key: A,\n+        result: &R,\n+        hash_result: fn(&mut StableHashingContext<'_>, &R) -> Fingerprint,\n+    ) -> DepNodeIndex {\n+        if let Some(data) = self.data.as_ref() {\n+            // The caller query has more dependencies than the node we are creating.  We may\n+            // encounter a case where this created node is marked as green, but the caller query is\n+            // subsequently marked as red or recomputed.  In this case, we will end up feeding a\n+            // value to an existing node.\n+            //\n+            // For sanity, we still check that the loaded stable hash and the new one match.\n+            if let Some(dep_node_index) = self.dep_node_index_of_opt(&node) {\n+                let _current_fingerprint =\n+                    crate::query::incremental_verify_ich(cx, result, &node, Some(hash_result));\n+\n+                #[cfg(debug_assertions)]\n+                data.current.record_edge(dep_node_index, node, _current_fingerprint);\n+\n+                return dep_node_index;\n+            }\n+\n+            let mut edges = SmallVec::new();\n+            K::read_deps(|task_deps| match task_deps {\n+                TaskDepsRef::Allow(deps) => edges.extend(deps.lock().reads.iter().copied()),\n+                TaskDepsRef::Ignore | TaskDepsRef::Forbid => {\n+                    panic!(\"Cannot summarize when dependencies are not recorded.\")\n+                }\n+            });\n+\n+            let hashing_timer = cx.profiler().incr_result_hashing();\n+            let current_fingerprint =\n+                cx.with_stable_hashing_context(|mut hcx| hash_result(&mut hcx, result));\n+\n+            let print_status = cfg!(debug_assertions) && cx.sess().opts.unstable_opts.dep_tasks;\n+\n+            // Intern the new `DepNode` with the dependencies up-to-now.\n+            let (dep_node_index, prev_and_color) = data.current.intern_node(\n+                cx.profiler(),\n+                &data.previous,\n+                node,\n+                edges,\n+                Some(current_fingerprint),\n+                print_status,\n+            );\n+\n+            hashing_timer.finish_with_query_invocation_id(dep_node_index.into());\n+\n+            if let Some((prev_index, color)) = prev_and_color {\n+                debug_assert!(\n+                    data.colors.get(prev_index).is_none(),\n+                    \"DepGraph::with_task() - Duplicate DepNodeColor insertion for {key:?}\",\n+                );\n+\n+                data.colors.insert(prev_index, color);\n+            }\n+\n+            dep_node_index\n+        } else {\n+            // Incremental compilation is turned off. We just execute the task\n+            // without tracking. We still provide a dep-node index that uniquely\n+            // identifies the task so that we have a cheap way of referring to\n+            // the query for self-profiling.\n+            self.next_virtual_depnode_index()\n+        }\n+    }\n+\n     #[inline]\n     pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n         self.dep_node_index_of_opt(dep_node).unwrap()\n@@ -779,26 +864,26 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n-    // Returns true if the given node has been marked as red during the\n-    // current compilation session. Used in various assertions\n+    /// Returns true if the given node has been marked as red during the\n+    /// current compilation session. Used in various assertions\n     pub fn is_red(&self, dep_node: &DepNode<K>) -> bool {\n         self.node_color(dep_node) == Some(DepNodeColor::Red)\n     }\n \n-    // Returns true if the given node has been marked as green during the\n-    // current compilation session. Used in various assertions\n+    /// Returns true if the given node has been marked as green during the\n+    /// current compilation session. Used in various assertions\n     pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n         self.node_color(dep_node).map_or(false, |c| c.is_green())\n     }\n \n-    // This method loads all on-disk cacheable query results into memory, so\n-    // they can be written out to the new cache file again. Most query results\n-    // will already be in memory but in the case where we marked something as\n-    // green but then did not need the value, that value will never have been\n-    // loaded from disk.\n-    //\n-    // This method will only load queries that will end up in the disk cache.\n-    // Other queries will not be executed.\n+    /// This method loads all on-disk cacheable query results into memory, so\n+    /// they can be written out to the new cache file again. Most query results\n+    /// will already be in memory but in the case where we marked something as\n+    /// green but then did not need the value, that value will never have been\n+    /// loaded from disk.\n+    ///\n+    /// This method will only load queries that will end up in the disk cache.\n+    /// Other queries will not be executed.\n     pub fn exec_cache_promotions<Tcx: DepContext<DepKind = K>>(&self, tcx: Tcx) {\n         let _prof_timer = tcx.profiler().generic_activity(\"incr_comp_query_cache_promotion\");\n \n@@ -916,6 +1001,11 @@ pub(super) struct CurrentDepGraph<K: DepKind> {\n     new_node_to_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n     prev_index_to_index: Lock<IndexVec<SerializedDepNodeIndex, Option<DepNodeIndex>>>,\n \n+    /// This is used to verify that fingerprints do not change between the creation of a node\n+    /// and its recomputation.\n+    #[cfg(debug_assertions)]\n+    fingerprints: Lock<FxHashMap<DepNode<K>, Fingerprint>>,\n+\n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n     #[cfg(debug_assertions)]\n@@ -999,17 +1089,27 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             anon_id_seed,\n             #[cfg(debug_assertions)]\n             forbidden_edge,\n+            #[cfg(debug_assertions)]\n+            fingerprints: Lock::new(Default::default()),\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n             node_intern_event_id,\n         }\n     }\n \n     #[cfg(debug_assertions)]\n-    fn record_edge(&self, dep_node_index: DepNodeIndex, key: DepNode<K>) {\n+    fn record_edge(&self, dep_node_index: DepNodeIndex, key: DepNode<K>, fingerprint: Fingerprint) {\n         if let Some(forbidden_edge) = &self.forbidden_edge {\n             forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n         }\n+        match self.fingerprints.lock().entry(key) {\n+            Entry::Vacant(v) => {\n+                v.insert(fingerprint);\n+            }\n+            Entry::Occupied(o) => {\n+                assert_eq!(*o.get(), fingerprint, \"Unstable fingerprints for {:?}\", key);\n+            }\n+        }\n     }\n \n     /// Writes the node to the current dep-graph and allocates a `DepNodeIndex` for it.\n@@ -1021,17 +1121,21 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         edges: EdgesVec,\n         current_fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        match self.new_node_to_index.get_shard_by_value(&key).lock().entry(key) {\n+        let dep_node_index = match self.new_node_to_index.get_shard_by_value(&key).lock().entry(key)\n+        {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 let dep_node_index =\n                     self.encoder.borrow().send(profiler, key, current_fingerprint, edges);\n                 entry.insert(dep_node_index);\n-                #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key);\n                 dep_node_index\n             }\n-        }\n+        };\n+\n+        #[cfg(debug_assertions)]\n+        self.record_edge(dep_node_index, key, current_fingerprint);\n+\n+        dep_node_index\n     }\n \n     fn intern_node(\n@@ -1072,7 +1176,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                     };\n \n                     #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key);\n+                    self.record_edge(dep_node_index, key, fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Green(dep_node_index))))\n                 } else {\n                     if print_status {\n@@ -1094,7 +1198,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                     };\n \n                     #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key);\n+                    self.record_edge(dep_node_index, key, fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n                 }\n             } else {\n@@ -1119,7 +1223,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                 };\n \n                 #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key);\n+                self.record_edge(dep_node_index, key, Fingerprint::ZERO);\n                 (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n             }\n         } else {\n@@ -1150,19 +1254,16 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             Some(dep_node_index) => dep_node_index,\n             None => {\n                 let key = prev_graph.index_to_node(prev_index);\n-                let dep_node_index = self.encoder.borrow().send(\n-                    profiler,\n-                    key,\n-                    prev_graph.fingerprint_by_index(prev_index),\n-                    prev_graph\n-                        .edge_targets_from(prev_index)\n-                        .iter()\n-                        .map(|i| prev_index_to_index[*i].unwrap())\n-                        .collect(),\n-                );\n+                let edges = prev_graph\n+                    .edge_targets_from(prev_index)\n+                    .iter()\n+                    .map(|i| prev_index_to_index[*i].unwrap())\n+                    .collect();\n+                let fingerprint = prev_graph.fingerprint_by_index(prev_index);\n+                let dep_node_index = self.encoder.borrow().send(profiler, key, fingerprint, edges);\n                 prev_index_to_index[prev_index] = Some(dep_node_index);\n                 #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key);\n+                self.record_edge(dep_node_index, key, fingerprint);\n                 dep_node_index\n             }\n         }"}, {"sha": "4c4680b5d8ea89b7d241e548a0e386da06e998df", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -117,6 +117,8 @@ where\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n+        // We may be overwriting another value.  This is all right, since the dep-graph\n+        // will check that the fingerprint matches.\n         lock.insert(key, (value.clone(), index));\n         value\n     }\n@@ -202,6 +204,8 @@ where\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n+        // We may be overwriting another value.  This is all right, since the dep-graph\n+        // will check that the fingerprint matches.\n         lock.insert(key, value);\n         &value.0\n     }"}, {"sha": "7d1b62ab10237d176ecf25aae385bc6376eaacfc", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -15,8 +15,8 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     const NAME: &'static str;\n \n     type Key: Eq + Hash + Clone + Debug;\n-    type Value;\n-    type Stored: Clone;\n+    type Value: Debug;\n+    type Stored: Debug + Clone + std::borrow::Borrow<Self::Value>;\n \n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n@@ -45,6 +45,7 @@ pub struct QueryVTable<Qcx: QueryContext, K, V> {\n     pub dep_kind: Qcx::DepKind,\n     pub eval_always: bool,\n     pub depth_limit: bool,\n+    pub feedable: bool,\n \n     pub compute: fn(Qcx::DepContext, K) -> V,\n     pub hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,"}, {"sha": "848fa67e3df25f4e1643b9ca06a004747ae092a7", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -3,6 +3,7 @@\n //! manage the caches, and so forth.\n \n use crate::dep_graph::{DepContext, DepNode, DepNodeIndex, DepNodeParams};\n+use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n use crate::query::config::QueryVTable;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n@@ -19,6 +20,7 @@ use rustc_data_structures::sync::Lock;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, FatalError};\n use rustc_session::Session;\n use rustc_span::{Span, DUMMY_SP};\n+use std::borrow::Borrow;\n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n@@ -369,11 +371,26 @@ where\n     C: QueryCache,\n     C::Key: Clone + DepNodeParams<Qcx::DepContext>,\n     C::Value: Value<Qcx::DepContext>,\n+    C::Stored: Debug + std::borrow::Borrow<C::Value>,\n     Qcx: QueryContext,\n {\n     match JobOwner::<'_, C::Key>::try_start(&qcx, state, span, key.clone()) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(qcx, key, dep_node, query, job.id);\n+            let (result, dep_node_index) = execute_job(qcx, key.clone(), dep_node, query, job.id);\n+            if query.feedable {\n+                // We may have put a value inside the cache from inside the execution.\n+                // Verify that it has the same hash as what we have now, to ensure consistency.\n+                let _ = cache.lookup(&key, |cached_result, _| {\n+                    let hasher = query.hash_result.expect(\"feedable forbids no_hash\");\n+                    let old_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, cached_result.borrow()));\n+                    let new_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, &result));\n+                    debug_assert_eq!(\n+                        old_hash, new_hash,\n+                        \"Computed query value for {:?}({:?}) is inconsistent with fed value,\\ncomputed={:#?}\\nfed={:#?}\",\n+                        query.dep_kind, key, result, cached_result,\n+                    );\n+                });\n+            }\n             let result = job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n@@ -525,7 +542,7 @@ where\n             if std::intrinsics::unlikely(\n                 try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n+                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result);\n             }\n \n             return Some((result, dep_node_index));\n@@ -558,39 +575,42 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n+    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result);\n \n     Some((result, dep_node_index))\n }\n \n-#[instrument(skip(qcx, result, query), level = \"debug\")]\n-fn incremental_verify_ich<Qcx, K, V: Debug>(\n-    qcx: Qcx::DepContext,\n+#[instrument(skip(tcx, result, hash_result), level = \"debug\")]\n+pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n+    tcx: Tcx,\n     result: &V,\n-    dep_node: &DepNode<Qcx::DepKind>,\n-    query: &QueryVTable<Qcx, K, V>,\n-) where\n-    Qcx: QueryContext,\n+    dep_node: &DepNode<Tcx::DepKind>,\n+    hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n+) -> Fingerprint\n+where\n+    Tcx: DepContext,\n {\n     assert!(\n-        qcx.dep_graph().is_green(dep_node),\n+        tcx.dep_graph().is_green(dep_node),\n         \"fingerprint for green query instance not loaded from cache: {:?}\",\n         dep_node,\n     );\n \n-    let new_hash = query.hash_result.map_or(Fingerprint::ZERO, |f| {\n-        qcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n+    let new_hash = hash_result.map_or(Fingerprint::ZERO, |f| {\n+        tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n \n-    let old_hash = qcx.dep_graph().prev_fingerprint_of(dep_node);\n+    let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n \n     if Some(new_hash) != old_hash {\n         incremental_verify_ich_failed(\n-            qcx.sess(),\n+            tcx.sess(),\n             DebugArg::from(&dep_node),\n             DebugArg::from(&result),\n         );\n     }\n+\n+    new_hash\n }\n \n // This DebugArg business is largely a mirror of std::fmt::ArgumentV1, which is"}, {"sha": "9c90d67aadf7194c4a79108ac0c35f041716030e", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -445,19 +445,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             prefix.is_empty() || prefix.len() == 1 && prefix[0].ident.name == kw::PathRoot\n         };\n         match use_tree.kind {\n-            ast::UseTreeKind::Simple(rename, id1, id2) => {\n+            ast::UseTreeKind::Simple(rename) => {\n                 let mut ident = use_tree.ident();\n                 let mut module_path = prefix;\n                 let mut source = module_path.pop().unwrap();\n                 let mut type_ns_only = false;\n \n                 self.r.visibilities.insert(self.r.local_def_id(id), vis);\n-                if id1 != ast::DUMMY_NODE_ID {\n-                    self.r.visibilities.insert(self.r.local_def_id(id1), vis);\n-                }\n-                if id2 != ast::DUMMY_NODE_ID {\n-                    self.r.visibilities.insert(self.r.local_def_id(id2), vis);\n-                }\n \n                 if nested {\n                     // Correctly handle `self`\n@@ -565,7 +559,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     type_ns_only,\n                     nested,\n                     id,\n-                    additional_ids: (id1, id2),\n                 };\n \n                 self.add_import(module_path, kind, use_tree.span, item, root_span, item.id, vis);\n@@ -621,11 +614,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     let new_span = prefix[prefix.len() - 1].ident.span;\n                     let tree = ast::UseTree {\n                         prefix: ast::Path::from_ident(Ident::new(kw::SelfLower, new_span)),\n-                        kind: ast::UseTreeKind::Simple(\n-                            Some(Ident::new(kw::Underscore, new_span)),\n-                            ast::DUMMY_NODE_ID,\n-                            ast::DUMMY_NODE_ID,\n-                        ),\n+                        kind: ast::UseTreeKind::Simple(Some(Ident::new(kw::Underscore, new_span))),\n                         span: use_tree.span,\n                     };\n                     self.build_reduced_graph_for_use_tree("}, {"sha": "2764a6c28a5e934bc7b74c27acfdf1ad372ece0a", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -158,14 +158,6 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n \n     fn visit_use_tree(&mut self, use_tree: &'a UseTree, id: NodeId, _nested: bool) {\n         self.create_def(id, DefPathData::Use, use_tree.span);\n-        match use_tree.kind {\n-            UseTreeKind::Simple(_, id1, id2) => {\n-                self.create_def(id1, DefPathData::Use, use_tree.prefix.span);\n-                self.create_def(id2, DefPathData::Use, use_tree.prefix.span);\n-            }\n-            UseTreeKind::Glob => (),\n-            UseTreeKind::Nested(..) => {}\n-        }\n         visit::walk_use_tree(self, use_tree, id);\n     }\n "}, {"sha": "85399385d1fd4fb2bd66a9b1244a869011aae057", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,4 +1,4 @@\n-use crate::{ImportKind, NameBinding, NameBindingKind, Resolver, ResolverTree};\n+use crate::{NameBinding, NameBindingKind, Resolver, ResolverTree};\n use rustc_ast::ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n@@ -104,28 +104,11 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n         for (binding, eff_vis) in visitor.import_effective_visibilities.iter() {\n             let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n             if let Some(node_id) = import.id() {\n-                let mut update = |node_id| {\n-                    r.effective_visibilities.update_eff_vis(\n-                        r.local_def_id(node_id),\n-                        eff_vis,\n-                        ResolverTree(&r.definitions, &r.crate_loader),\n-                    )\n-                };\n-                update(node_id);\n-                if let ImportKind::Single { additional_ids: (id1, id2), .. } = import.kind {\n-                    // In theory all the single import IDs have individual visibilities and\n-                    // effective visibilities, but in practice these IDs go straight to HIR\n-                    // where all their few uses assume that their (effective) visibility\n-                    // applies to the whole syntactic `use` item. So they all get the same\n-                    // value which is the maximum of all bindings. Maybe HIR for imports\n-                    // shouldn't use three IDs at all.\n-                    if id1 != ast::DUMMY_NODE_ID {\n-                        update(id1);\n-                    }\n-                    if id2 != ast::DUMMY_NODE_ID {\n-                        update(id2);\n-                    }\n-                }\n+                r.effective_visibilities.update_eff_vis(\n+                    r.local_def_id(node_id),\n+                    eff_vis,\n+                    ResolverTree(&r.definitions, &r.crate_loader),\n+                )\n             }\n         }\n "}, {"sha": "e6f4d7fcfcf06b92629d0ca423d9c0ef84ccabbe", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -56,9 +56,6 @@ pub enum ImportKind<'a> {\n         /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n         /// for `a` in this field.\n         id: NodeId,\n-        /// Additional `NodeId`s allocated to a `ast::UseTree` for automatically generated `use` statement\n-        /// (eg. implicit struct constructors)\n-        additional_ids: (NodeId, NodeId),\n     },\n     Glob {\n         is_prelude: bool,\n@@ -88,7 +85,6 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n                 ref type_ns_only,\n                 ref nested,\n                 ref id,\n-                ref additional_ids,\n                 // Ignore the following to avoid an infinite loop while printing.\n                 source_bindings: _,\n                 target_bindings: _,\n@@ -99,7 +95,6 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n                 .field(\"type_ns_only\", type_ns_only)\n                 .field(\"nested\", nested)\n                 .field(\"id\", id)\n-                .field(\"additional_ids\", additional_ids)\n                 .finish_non_exhaustive(),\n             Glob { ref is_prelude, ref max_vis, ref id } => f\n                 .debug_struct(\"Glob\")\n@@ -196,7 +191,7 @@ pub(crate) struct NameResolution<'a> {\n }\n \n impl<'a> NameResolution<'a> {\n-    // Returns the binding for the name if it is known or None if it not known.\n+    /// Returns the binding for the name if it is known or None if it not known.\n     pub(crate) fn binding(&self) -> Option<&'a NameBinding<'a>> {\n         self.binding.and_then(|binding| {\n             if !binding.is_glob_import() || self.single_imports.is_empty() {\n@@ -228,8 +223,8 @@ fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBindi\n }\n \n impl<'a> Resolver<'a> {\n-    // Given a binding and an import that resolves to it,\n-    // return the corresponding binding defined by the import.\n+    /// Given a binding and an import that resolves to it,\n+    /// return the corresponding binding defined by the import.\n     pub(crate) fn import(\n         &self,\n         binding: &'a NameBinding<'a>,\n@@ -261,7 +256,7 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    // Define the name or return the existing binding if there is a collision.\n+    /// Define the name or return the existing binding if there is a collision.\n     pub(crate) fn try_define(\n         &mut self,\n         module: Module<'a>,"}, {"sha": "df59a350ea7c9cfbd19dc89d3ab8556717e21d7e", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -282,6 +282,14 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                             \"you may want to use a bool value instead\",\n                             format!(\"{}\", item_typo),\n                         ))\n+                    // FIXME(vincenzopalazzo): make the check smarter,\n+                    // and maybe expand with levenshtein distance checks\n+                    } else if item_str.as_str() == \"printf\" {\n+                        Some((\n+                            item_span,\n+                            \"you may have meant to use the `print` macro\",\n+                            \"print!\".to_owned(),\n+                        ))\n                     } else {\n                         suggestion\n                     };"}, {"sha": "4ef89cfb2554fdbc13f0dde06cbb2582a81eeb30", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1989,7 +1989,7 @@ impl<'a> Resolver<'a> {\n                     .find(|a| a.has_name(sym::rustc_legacy_const_generics))?;\n                 let mut ret = Vec::new();\n                 for meta in attr.meta_item_list()? {\n-                    match meta.literal()?.kind {\n+                    match meta.lit()?.kind {\n                         LitKind::Int(a, _) => ret.push(a as usize),\n                         _ => panic!(\"invalid arg index\"),\n                     }"}, {"sha": "b45288538256f84e9c10b8a80409cd9a773c9bfc", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -185,13 +185,13 @@ impl<'tcx> DumpVisitor<'tcx> {\n         }\n     }\n \n-    fn write_sub_paths(&mut self, path: &'tcx hir::Path<'tcx>) {\n+    fn write_sub_paths<R>(&mut self, path: &'tcx hir::Path<'tcx, R>) {\n         self.write_segments(path.segments)\n     }\n \n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n     // will be processed elsewhere). See note on write_sub_paths about global.\n-    fn write_sub_paths_truncated(&mut self, path: &'tcx hir::Path<'tcx>) {\n+    fn write_sub_paths_truncated<R>(&mut self, path: &'tcx hir::Path<'tcx, R>) {\n         if let [segments @ .., _] = path.segments {\n             self.write_segments(segments)\n         }"}, {"sha": "f05eb2b7432b5cabd3c8eb1b0839acf7e5a1788e", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -94,7 +94,7 @@ impl<'tcx> SaveContext<'tcx> {\n         }\n     }\n \n-    // Returns path to the compilation output (e.g., libfoo-12345678.rmeta)\n+    /// Returns path to the compilation output (e.g., libfoo-12345678.rmeta)\n     pub fn compilation_output(&self, crate_name: &str) -> PathBuf {\n         let sess = &self.tcx.sess;\n         // Save-analysis is emitted per whole session, not per each crate type\n@@ -112,7 +112,7 @@ impl<'tcx> SaveContext<'tcx> {\n         }\n     }\n \n-    // List external crates used by the current crate.\n+    /// List external crates used by the current crate.\n     pub fn get_external_crates(&self) -> Vec<ExternalCrateData> {\n         let mut result = Vec::with_capacity(self.tcx.crates(()).len());\n \n@@ -594,7 +594,9 @@ impl<'tcx> SaveContext<'tcx> {\n         match self.tcx.hir().get(hir_id) {\n             Node::TraitRef(tr) => tr.path.res,\n \n-            Node::Item(&hir::Item { kind: hir::ItemKind::Use(path, _), .. }) => path.res,\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Use(path, _), .. }) => {\n+                path.res.get(0).copied().unwrap_or(Res::Err)\n+            }\n             Node::PathSegment(seg) => {\n                 if seg.res != Res::Err {\n                     seg.res"}, {"sha": "7dad9aa01fafdaac8525b54a8d7724b70b4c4f06", "filename": "compiler/rustc_serialize/src/leb128.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,22 +1,19 @@\n-#![macro_use]\n-\n-macro_rules! max_leb128_len {\n-    ($int_ty:ty) => {\n-        // The longest LEB128 encoding for an integer uses 7 bits per byte.\n-        (std::mem::size_of::<$int_ty>() * 8 + 6) / 7\n-    };\n+/// Returns the length of the longest LEB128 encoding for `T`, assuming `T` is an integer type\n+pub const fn max_leb128_len<T>() -> usize {\n+    // The longest LEB128 encoding for an integer uses 7 bits per byte.\n+    (std::mem::size_of::<T>() * 8 + 6) / 7\n }\n \n-// Returns the longest LEB128 encoding of all supported integer types.\n-pub const fn max_leb128_len() -> usize {\n-    max_leb128_len!(u128)\n+/// Returns the length of the longest LEB128 encoding of all supported integer types.\n+pub const fn largest_max_leb128_len() -> usize {\n+    max_leb128_len::<u128>()\n }\n \n macro_rules! impl_write_unsigned_leb128 {\n     ($fn_name:ident, $int_ty:ty) => {\n         #[inline]\n         pub fn $fn_name(\n-            out: &mut [::std::mem::MaybeUninit<u8>; max_leb128_len!($int_ty)],\n+            out: &mut [::std::mem::MaybeUninit<u8>; max_leb128_len::<$int_ty>()],\n             mut value: $int_ty,\n         ) -> &[u8] {\n             let mut i = 0;\n@@ -90,7 +87,7 @@ macro_rules! impl_write_signed_leb128 {\n     ($fn_name:ident, $int_ty:ty) => {\n         #[inline]\n         pub fn $fn_name(\n-            out: &mut [::std::mem::MaybeUninit<u8>; max_leb128_len!($int_ty)],\n+            out: &mut [::std::mem::MaybeUninit<u8>; max_leb128_len::<$int_ty>()],\n             mut value: $int_ty,\n         ) -> &[u8] {\n             let mut i = 0;"}, {"sha": "0afeb86fceb241611867c67ee4820f4e810507ac", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,4 +1,4 @@\n-use crate::leb128::{self, max_leb128_len};\n+use crate::leb128::{self, largest_max_leb128_len};\n use crate::serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::convert::TryInto;\n use std::fs::File;\n@@ -32,7 +32,7 @@ impl MemEncoder {\n \n macro_rules! write_leb128 {\n     ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{\n-        const MAX_ENCODED_LEN: usize = max_leb128_len!($int_ty);\n+        const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n         let old_len = $enc.data.len();\n \n         if MAX_ENCODED_LEN > $enc.data.capacity() - old_len {\n@@ -155,19 +155,19 @@ impl Encoder for MemEncoder {\n \n pub type FileEncodeResult = Result<usize, io::Error>;\n \n-// `FileEncoder` encodes data to file via fixed-size buffer.\n-//\n-// When encoding large amounts of data to a file, using `FileEncoder` may be\n-// preferred over using `MemEncoder` to encode to a `Vec`, and then writing the\n-// `Vec` to file, as the latter uses as much memory as there is encoded data,\n-// while the former uses the fixed amount of memory allocated to the buffer.\n-// `FileEncoder` also has the advantage of not needing to reallocate as data\n-// is appended to it, but the disadvantage of requiring more error handling,\n-// which has some runtime overhead.\n+/// `FileEncoder` encodes data to file via fixed-size buffer.\n+///\n+/// When encoding large amounts of data to a file, using `FileEncoder` may be\n+/// preferred over using `MemEncoder` to encode to a `Vec`, and then writing the\n+/// `Vec` to file, as the latter uses as much memory as there is encoded data,\n+/// while the former uses the fixed amount of memory allocated to the buffer.\n+/// `FileEncoder` also has the advantage of not needing to reallocate as data\n+/// is appended to it, but the disadvantage of requiring more error handling,\n+/// which has some runtime overhead.\n pub struct FileEncoder {\n-    // The input buffer. For adequate performance, we need more control over\n-    // buffering than `BufWriter` offers. If `BufWriter` ever offers a raw\n-    // buffer access API, we can use it, and remove `buf` and `buffered`.\n+    /// The input buffer. For adequate performance, we need more control over\n+    /// buffering than `BufWriter` offers. If `BufWriter` ever offers a raw\n+    /// buffer access API, we can use it, and remove `buf` and `buffered`.\n     buf: Box<[MaybeUninit<u8>]>,\n     buffered: usize,\n     flushed: usize,\n@@ -186,12 +186,12 @@ impl FileEncoder {\n     pub fn with_capacity<P: AsRef<Path>>(path: P, capacity: usize) -> io::Result<Self> {\n         // Require capacity at least as large as the largest LEB128 encoding\n         // here, so that we don't have to check or handle this on every write.\n-        assert!(capacity >= max_leb128_len());\n+        assert!(capacity >= largest_max_leb128_len());\n \n         // Require capacity small enough such that some capacity checks can be\n         // done using guaranteed non-overflowing add rather than sub, which\n         // shaves an instruction off those code paths (on x86 at least).\n-        assert!(capacity <= usize::MAX - max_leb128_len());\n+        assert!(capacity <= usize::MAX - largest_max_leb128_len());\n \n         // Create the file for reading and writing, because some encoders do both\n         // (e.g. the metadata encoder when -Zmeta-stats is enabled)\n@@ -411,7 +411,7 @@ impl Drop for FileEncoder {\n \n macro_rules! file_encoder_write_leb128 {\n     ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{\n-        const MAX_ENCODED_LEN: usize = max_leb128_len!($int_ty);\n+        const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n \n         // We ensure this during `FileEncoder` construction.\n         debug_assert!($enc.capacity() >= MAX_ENCODED_LEN);\n@@ -711,7 +711,7 @@ impl<'a> Decodable<MemDecoder<'a>> for Vec<u8> {\n     }\n }\n \n-// An integer that will always encode to 8 bytes.\n+/// An integer that will always encode to 8 bytes.\n pub struct IntEncodedWithFixedSize(pub u64);\n \n impl IntEncodedWithFixedSize {"}, {"sha": "927810351e958c1f73e7879bb8df49cbf75922f4", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2029,10 +2029,7 @@ fn parse_native_lib_modifiers(\n                 \"linking modifier `bundle` is only compatible with `static` linking kind\",\n             ),\n \n-            (\"verbatim\", _) => {\n-                report_unstable_modifier();\n-                assign_modifier(&mut verbatim)\n-            }\n+            (\"verbatim\", _) => assign_modifier(&mut verbatim),\n \n             (\"whole-archive\", NativeLibKind::Static { whole_archive, .. }) => {\n                 assign_modifier(whole_archive)"}, {"sha": "9aa8a06c6d36e3d39c5b51f0d2afee2712a300cc", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -197,12 +197,12 @@ pub enum UnleashedFeatureHelp {\n \n #[derive(Diagnostic)]\n #[diag(session_invalid_literal_suffix)]\n-pub(crate) struct InvalidLiteralSuffix {\n+pub(crate) struct InvalidLiteralSuffix<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     // FIXME(#100717)\n-    pub kind: String,\n+    pub kind: &'a str,\n     pub suffix: Symbol,\n }\n \n@@ -311,11 +311,7 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n         LitError::LexerError => {}\n         LitError::InvalidSuffix => {\n             if let Some(suffix) = suffix {\n-                sess.emit_err(InvalidLiteralSuffix {\n-                    span,\n-                    kind: format!(\"{}\", kind.descr()),\n-                    suffix,\n-                });\n+                sess.emit_err(InvalidLiteralSuffix { span, kind: kind.descr(), suffix });\n             }\n         }\n         LitError::InvalidIntSuffix => {"}, {"sha": "47aa4dfba42bb9fc288a561eaef5b6875e5e216e", "filename": "compiler/rustc_span/src/analyze_source_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -41,7 +41,7 @@ pub fn analyze_source_file(\n }\n \n cfg_if::cfg_if! {\n-    if #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\")))] {\n+    if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n         fn analyze_source_file_dispatch(src: &str,\n                                     source_file_start_pos: BytePos,\n                                     lines: &mut Vec<BytePos>,"}, {"sha": "1065cd384a94d21c5ba241154d870a0482c03fc0", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -78,10 +78,10 @@ use sha2::Sha256;\n #[cfg(test)]\n mod tests;\n \n-// Per-session global variables: this struct is stored in thread-local storage\n-// in such a way that it is accessible without any kind of handle to all\n-// threads within the compilation session, but is not accessible outside the\n-// session.\n+/// Per-session global variables: this struct is stored in thread-local storage\n+/// in such a way that it is accessible without any kind of handle to all\n+/// threads within the compilation session, but is not accessible outside the\n+/// session.\n pub struct SessionGlobals {\n     symbol_interner: symbol::Interner,\n     span_interner: Lock<span_encoding::SpanInterner>,\n@@ -359,8 +359,8 @@ impl FileName {\n         FileNameDisplay { inner: self, display_pref: FileNameDisplayPreference::Remapped }\n     }\n \n-    // This may include transient local filesystem information.\n-    // Must not be embedded in build outputs.\n+    /// This may include transient local filesystem information.\n+    /// Must not be embedded in build outputs.\n     pub fn prefer_local(&self) -> FileNameDisplay<'_> {\n         FileNameDisplay { inner: self, display_pref: FileNameDisplayPreference::Local }\n     }\n@@ -751,7 +751,7 @@ impl Span {\n \n     /// Checks if a span is \"internal\" to a macro in which `unsafe`\n     /// can be used without triggering the `unsafe_code` lint.\n-    //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n+    /// (that is, a macro marked with `#[allow_internal_unsafe]`).\n     pub fn allows_unsafe(self) -> bool {\n         self.ctxt().outer_expn_data().allow_internal_unsafe\n     }"}, {"sha": "2ae57d9e56d7c5ce3ec0ff45c06bb8986fe231c2", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -130,14 +130,14 @@ impl FileLoader for RealFileLoader {\n /// different has no real downsides.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable, Debug)]\n pub struct StableSourceFileId {\n-    // A hash of the source file's FileName. This is hash so that it's size\n-    // is more predictable than if we included the actual FileName value.\n+    /// A hash of the source file's [`FileName`]. This is hash so that it's size\n+    /// is more predictable than if we included the actual [`FileName`] value.\n     pub file_name_hash: u64,\n \n-    // The CrateNum of the crate this source file was originally parsed for.\n-    // We cannot include this information in the hash because at the time\n-    // of hashing we don't have the context to map from the CrateNum's numeric\n-    // value to a StableCrateId.\n+    /// The [`CrateNum`] of the crate this source file was originally parsed for.\n+    /// We cannot include this information in the hash because at the time\n+    /// of hashing we don't have the context to map from the [`CrateNum`]'s numeric\n+    /// value to a `StableCrateId`.\n     pub cnum: CrateNum,\n }\n \n@@ -402,7 +402,7 @@ impl SourceMap {\n         source_file\n     }\n \n-    // If there is a doctest offset, applies it to the line.\n+    /// If there is a doctest offset, applies it to the line.\n     pub fn doctest_offset_line(&self, file: &FileName, orig: usize) -> usize {\n         match file {\n             FileName::DocTest(_, offset) => {\n@@ -429,7 +429,7 @@ impl SourceMap {\n         Loc { file: sf, line, col, col_display }\n     }\n \n-    // If the corresponding `SourceFile` is empty, does not return a line number.\n+    /// If the corresponding `SourceFile` is empty, does not return a line number.\n     pub fn lookup_line(&self, pos: BytePos) -> Result<SourceFileAndLine, Lrc<SourceFile>> {\n         let f = self.lookup_source_file(pos);\n \n@@ -1053,9 +1053,9 @@ impl SourceMap {\n         SourceFileAndBytePos { sf, pos: offset }\n     }\n \n-    // Returns the index of the `SourceFile` (in `self.files`) that contains `pos`.\n-    // This index is guaranteed to be valid for the lifetime of this `SourceMap`,\n-    // since `source_files` is a `MonotonicVec`\n+    /// Returns the index of the [`SourceFile`] (in `self.files`) that contains `pos`.\n+    /// This index is guaranteed to be valid for the lifetime of this `SourceMap`,\n+    /// since `source_files` is a `MonotonicVec`\n     pub fn lookup_source_file_idx(&self, pos: BytePos) -> usize {\n         self.files\n             .borrow()"}, {"sha": "663cf65d1a5106457ace70350bf5abe76d5b4d55", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1488,6 +1488,7 @@ symbols! {\n         ty,\n         type_alias_enum_variants,\n         type_alias_impl_trait,\n+        type_ascribe,\n         type_ascription,\n         type_changing_struct_update,\n         type_id,\n@@ -2051,8 +2052,8 @@ impl Symbol {\n }\n \n impl Ident {\n-    // Returns `true` for reserved identifiers used internally for elided lifetimes,\n-    // unnamed method parameters, crate root module, error recovery etc.\n+    /// Returns `true` for reserved identifiers used internally for elided lifetimes,\n+    /// unnamed method parameters, crate root module, error recovery etc.\n     pub fn is_special(self) -> bool {\n         self.name.is_special()\n     }"}, {"sha": "78315afa759561080a7f479c8e595d5046a2c975", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 11, "deletions": 99, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -35,10 +35,7 @@\n //! to the list specified by the target, rather than replace.\n \n use crate::abi::call::Conv;\n-use crate::abi::{\n-    AbiAndPrefAlign, AddressSpace, Align, Endian, Integer, Size, TargetDataLayout,\n-    TargetDataLayoutErrors,\n-};\n+use crate::abi::{Endian, Integer, Size, TargetDataLayout, TargetDataLayoutErrors};\n use crate::json::{Json, ToJson};\n use crate::spec::abi::{lookup as lookup_abi, Abi};\n use crate::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n@@ -1250,8 +1247,8 @@ supported_targets! {\n \n     (\"mips64-openwrt-linux-musl\", mips64_openwrt_linux_musl),\n \n-    (\"aarch64-unknown-nto-qnx7.1.0\", aarch64_unknown_nto_qnx_710),\n-    (\"x86_64-pc-nto-qnx7.1.0\", x86_64_pc_nto_qnx710),\n+    (\"aarch64-unknown-nto-qnx710\", aarch64_unknown_nto_qnx_710),\n+    (\"x86_64-pc-nto-qnx710\", x86_64_pc_nto_qnx710),\n }\n \n /// Cow-Vec-Str: Cow<'static, [Cow<'static, str>]>\n@@ -1322,92 +1319,7 @@ pub struct Target {\n \n impl Target {\n     pub fn parse_data_layout<'a>(&'a self) -> Result<TargetDataLayout, TargetDataLayoutErrors<'a>> {\n-        // Parse an address space index from a string.\n-        let parse_address_space = |s: &'a str, cause: &'a str| {\n-            s.parse::<u32>().map(AddressSpace).map_err(|err| {\n-                TargetDataLayoutErrors::InvalidAddressSpace { addr_space: s, cause, err }\n-            })\n-        };\n-\n-        // Parse a bit count from a string.\n-        let parse_bits = |s: &'a str, kind: &'a str, cause: &'a str| {\n-            s.parse::<u64>().map_err(|err| TargetDataLayoutErrors::InvalidBits {\n-                kind,\n-                bit: s,\n-                cause,\n-                err,\n-            })\n-        };\n-\n-        // Parse a size string.\n-        let size = |s: &'a str, cause: &'a str| parse_bits(s, \"size\", cause).map(Size::from_bits);\n-\n-        // Parse an alignment string.\n-        let align = |s: &[&'a str], cause: &'a str| {\n-            if s.is_empty() {\n-                return Err(TargetDataLayoutErrors::MissingAlignment { cause });\n-            }\n-            let align_from_bits = |bits| {\n-                Align::from_bits(bits)\n-                    .map_err(|err| TargetDataLayoutErrors::InvalidAlignment { cause, err })\n-            };\n-            let abi = parse_bits(s[0], \"alignment\", cause)?;\n-            let pref = s.get(1).map_or(Ok(abi), |pref| parse_bits(pref, \"alignment\", cause))?;\n-            Ok(AbiAndPrefAlign { abi: align_from_bits(abi)?, pref: align_from_bits(pref)? })\n-        };\n-\n-        let mut dl = TargetDataLayout::default();\n-        let mut i128_align_src = 64;\n-        for spec in self.data_layout.split('-') {\n-            let spec_parts = spec.split(':').collect::<Vec<_>>();\n-\n-            match &*spec_parts {\n-                [\"e\"] => dl.endian = Endian::Little,\n-                [\"E\"] => dl.endian = Endian::Big,\n-                [p] if p.starts_with('P') => {\n-                    dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n-                }\n-                [\"a\", ref a @ ..] => dl.aggregate_align = align(a, \"a\")?,\n-                [\"f32\", ref a @ ..] => dl.f32_align = align(a, \"f32\")?,\n-                [\"f64\", ref a @ ..] => dl.f64_align = align(a, \"f64\")?,\n-                [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n-                    dl.pointer_size = size(s, p)?;\n-                    dl.pointer_align = align(a, p)?;\n-                }\n-                [s, ref a @ ..] if s.starts_with('i') => {\n-                    let Ok(bits) = s[1..].parse::<u64>() else {\n-                        size(&s[1..], \"i\")?; // For the user error.\n-                        continue;\n-                    };\n-                    let a = align(a, s)?;\n-                    match bits {\n-                        1 => dl.i1_align = a,\n-                        8 => dl.i8_align = a,\n-                        16 => dl.i16_align = a,\n-                        32 => dl.i32_align = a,\n-                        64 => dl.i64_align = a,\n-                        _ => {}\n-                    }\n-                    if bits >= i128_align_src && bits <= 128 {\n-                        // Default alignment for i128 is decided by taking the alignment of\n-                        // largest-sized i{64..=128}.\n-                        i128_align_src = bits;\n-                        dl.i128_align = a;\n-                    }\n-                }\n-                [s, ref a @ ..] if s.starts_with('v') => {\n-                    let v_size = size(&s[1..], \"v\")?;\n-                    let a = align(a, s)?;\n-                    if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {\n-                        v.1 = a;\n-                        continue;\n-                    }\n-                    // No existing entry, add a new one.\n-                    dl.vector_align.push((v_size, a));\n-                }\n-                _ => {} // Ignore everything else.\n-            }\n-        }\n+        let mut dl = TargetDataLayout::parse_from_llvm_datalayout_string(&self.data_layout)?;\n \n         // Perform consistency checks against the Target information.\n         if dl.endian != self.endian {\n@@ -1650,9 +1562,9 @@ pub struct TargetOptions {\n \n     /// Flag indicating whether #[thread_local] is available for this target.\n     pub has_thread_local: bool,\n-    // This is mainly for easy compatibility with emscripten.\n-    // If we give emcc .o files that are actually .bc files it\n-    // will 'just work'.\n+    /// This is mainly for easy compatibility with emscripten.\n+    /// If we give emcc .o files that are actually .bc files it\n+    /// will 'just work'.\n     pub obj_is_bitcode: bool,\n     /// Whether the target requires that emitted object code includes bitcode.\n     pub forces_embed_bitcode: bool,\n@@ -1792,12 +1704,12 @@ pub struct TargetOptions {\n     /// since this is most common among tier 1 and tier 2 targets.\n     pub supports_stack_protector: bool,\n \n-    // The name of entry function.\n-    // Default value is \"main\"\n+    /// The name of entry function.\n+    /// Default value is \"main\"\n     pub entry_name: StaticCow<str>,\n \n-    // The ABI of entry function.\n-    // Default value is `Conv::C`, i.e. C call convention\n+    /// The ABI of entry function.\n+    /// Default value is `Conv::C`, i.e. C call convention\n     pub entry_abi: Conv,\n }\n "}, {"sha": "e988c77a064f6a03733c9817ff25a34e10d472b2", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,6 +1,6 @@\n use crate::errors::AutoDerefReachedRecursionLimit;\n-use crate::infer::InferCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n+use crate::traits::NormalizeExt;\n use crate::traits::{self, TraitEngine, TraitEngineExt};\n use rustc_hir as hir;\n use rustc_infer::infer::InferCtxt;\n@@ -138,11 +138,10 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n             return None;\n         }\n \n-        let normalized_ty = self.infcx.partially_normalize_associated_types_in(\n-            cause,\n-            self.param_env,\n-            tcx.mk_projection(tcx.lang_items().deref_target()?, trait_ref.substs),\n-        );\n+        let normalized_ty = self\n+            .infcx\n+            .at(&cause, self.param_env)\n+            .normalize(tcx.mk_projection(tcx.lang_items().deref_target()?, trait_ref.substs));\n         let mut fulfillcx = <dyn TraitEngine<'tcx>>::new_in_snapshot(tcx);\n         let normalized_ty =\n             normalized_ty.into_value_registering_obligations(self.infcx, &mut *fulfillcx);"}, {"sha": "6c70bbf75163a83348a12cd5ca8415abf1a7e7e8", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -3,7 +3,6 @@ use crate::traits::{self, ObligationCtxt};\n \n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n-use rustc_infer::traits::ObligationCause;\n use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::infer::canonical::{Canonical, CanonicalizedQueryResponse, QueryResponse};\n use rustc_middle::traits::query::Fallible;\n@@ -30,15 +29,6 @@ pub trait InferCtxtExt<'tcx> {\n         span: Span,\n     ) -> bool;\n \n-    fn partially_normalize_associated_types_in<T>(\n-        &self,\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n-    ) -> InferOk<'tcx, T>\n-    where\n-        T: TypeFoldable<'tcx>;\n-\n     /// Check whether a `ty` implements given trait(trait_def_id).\n     /// The inputs are:\n     ///\n@@ -88,24 +78,6 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, lang_item, span)\n     }\n \n-    /// Normalizes associated types in `value`, potentially returning\n-    /// new obligations that must further be processed.\n-    #[instrument(level = \"debug\", skip(self, cause, param_env), ret)]\n-    fn partially_normalize_associated_types_in<T>(\n-        &self,\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n-    ) -> InferOk<'tcx, T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut selcx = traits::SelectionContext::new(self);\n-        let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, param_env, cause, value);\n-        InferOk { value, obligations }\n-    }\n-\n     #[instrument(level = \"debug\", skip(self, params), ret)]\n     fn type_implements_trait(\n         &self,"}, {"sha": "8e04da4f9be2479aa584270611a9607279b495d8", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -599,17 +599,17 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         computed_preds: &mut FxIndexSet<ty::Predicate<'tcx>>,\n         fresh_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n         predicates: &mut VecDeque<ty::PolyTraitPredicate<'tcx>>,\n-        select: &mut SelectionContext<'_, 'tcx>,\n+        selcx: &mut SelectionContext<'_, 'tcx>,\n         only_projections: bool,\n     ) -> bool {\n         let dummy_cause = ObligationCause::dummy();\n \n         for obligation in nested {\n             let is_new_pred =\n-                fresh_preds.insert(self.clean_pred(select.infcx(), obligation.predicate));\n+                fresh_preds.insert(self.clean_pred(selcx.infcx, obligation.predicate));\n \n             // Resolve any inference variables that we can, to help selection succeed\n-            let predicate = select.infcx().resolve_vars_if_possible(obligation.predicate);\n+            let predicate = selcx.infcx.resolve_vars_if_possible(obligation.predicate);\n \n             // We only add a predicate as a user-displayable bound if\n             // it involves a generic parameter, and doesn't contain\n@@ -717,10 +717,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                     // and turn them into an explicit negative impl for our type.\n                     debug!(\"Projecting and unifying projection predicate {:?}\", predicate);\n \n-                    match project::poly_project_and_unify_type(\n-                        select,\n-                        &obligation.with(self.tcx, p),\n-                    ) {\n+                    match project::poly_project_and_unify_type(selcx, &obligation.with(self.tcx, p))\n+                    {\n                         ProjectAndUnifyResult::MismatchedProjectionTypes(e) => {\n                             debug!(\n                                 \"evaluate_nested_obligations: Unable to unify predicate \\\n@@ -745,7 +743,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                                     computed_preds,\n                                     fresh_preds,\n                                     predicates,\n-                                    select,\n+                                    selcx,\n                                     only_projections,\n                                 ) {\n                                     return false;\n@@ -768,7 +766,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::RegionOutlives(binder)) => {\n                     let binder = bound_predicate.rebind(binder);\n-                    select.infcx().region_outlives_predicate(&dummy_cause, binder)\n+                    selcx.infcx.region_outlives_predicate(&dummy_cause, binder)\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::TypeOutlives(binder)) => {\n                     let binder = bound_predicate.rebind(binder);\n@@ -777,14 +775,14 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),\n                     ) {\n                         (None, Some(t_a)) => {\n-                            select.infcx().register_region_obligation_with_cause(\n+                            selcx.infcx.register_region_obligation_with_cause(\n                                 t_a,\n-                                select.infcx().tcx.lifetimes.re_static,\n+                                selcx.infcx.tcx.lifetimes.re_static,\n                                 &dummy_cause,\n                             );\n                         }\n                         (Some(ty::OutlivesPredicate(t_a, r_b)), _) => {\n-                            select.infcx().register_region_obligation_with_cause(\n+                            selcx.infcx.register_region_obligation_with_cause(\n                                 t_a,\n                                 r_b,\n                                 &dummy_cause,\n@@ -796,14 +794,12 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 ty::PredicateKind::ConstEquate(c1, c2) => {\n                     let evaluate = |c: ty::Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(unevaluated) = c.kind() {\n-                            match select.infcx().const_eval_resolve(\n+                            match selcx.infcx.const_eval_resolve(\n                                 obligation.param_env,\n                                 unevaluated,\n                                 Some(obligation.cause.span),\n                             ) {\n-                                Ok(Some(valtree)) => {\n-                                    Ok(ty::Const::from_value(select.tcx(), valtree, c.ty()))\n-                                }\n+                                Ok(Some(valtree)) => Ok(selcx.tcx().mk_const(valtree, c.ty())),\n                                 Ok(None) => {\n                                     let tcx = self.tcx;\n                                     let def_id = unevaluated.def.did;\n@@ -823,10 +819,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match select\n-                                .infcx()\n-                                .at(&obligation.cause, obligation.param_env)\n-                                .eq(c1, c2)\n+                            match selcx.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n                             {\n                                 Ok(_) => (),\n                                 Err(_) => return false,\n@@ -861,7 +854,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     }\n }\n \n-// Replaces all ReVars in a type with ty::Region's, using the provided map\n+/// Replaces all ReVars in a type with ty::Region's, using the provided map\n pub struct RegionReplacer<'a, 'tcx> {\n     vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n     tcx: TyCtxt<'tcx>,"}, {"sha": "99724fb28db1104ab90a8c7c04a6f54865d9377c", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -119,7 +119,7 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n     impl_def_id: DefId,\n ) -> ty::ImplHeader<'tcx> {\n     let tcx = selcx.tcx();\n-    let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+    let impl_substs = selcx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n \n     let header = ty::ImplHeader {\n         impl_def_id,\n@@ -149,7 +149,7 @@ fn overlap<'cx, 'tcx>(\n         impl1_def_id, impl2_def_id, overlap_mode\n     );\n \n-    selcx.infcx().probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n+    selcx.infcx.probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n         overlap_within_probe(selcx, impl1_def_id, impl2_def_id, overlap_mode, snapshot)\n     })\n }\n@@ -161,7 +161,7 @@ fn overlap_within_probe<'cx, 'tcx>(\n     overlap_mode: OverlapMode,\n     snapshot: &CombinedSnapshot<'tcx>,\n ) -> Option<OverlapResult<'tcx>> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n \n     if overlap_mode.use_negative_impl() {\n         if negative_impl(infcx.tcx, impl1_def_id, impl2_def_id)\n@@ -200,9 +200,9 @@ fn overlap_within_probe<'cx, 'tcx>(\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n \n     let involves_placeholder =\n-        matches!(selcx.infcx().region_constraints_added_in_snapshot(snapshot), Some(true));\n+        matches!(selcx.infcx.region_constraints_added_in_snapshot(snapshot), Some(true));\n \n-    let impl_header = selcx.infcx().resolve_vars_if_possible(impl1_header);\n+    let impl_header = selcx.infcx.resolve_vars_if_possible(impl1_header);\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n@@ -214,7 +214,7 @@ fn equate_impl_headers<'cx, 'tcx>(\n     // Do `a` and `b` unify? If not, no overlap.\n     debug!(\"equate_impl_headers(impl1_header={:?}, impl2_header={:?}\", impl1_header, impl2_header);\n     selcx\n-        .infcx()\n+        .infcx\n         .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n         .eq_impl_headers(impl1_header, impl2_header)\n         .map(|infer_ok| infer_ok.obligations)\n@@ -255,7 +255,7 @@ fn implicit_negative<'cx, 'tcx>(\n         \"implicit_negative(impl1_header={:?}, impl2_header={:?}, obligations={:?})\",\n         impl1_header, impl2_header, obligations\n     );\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let opt_failing_obligation = impl1_header\n         .predicates\n         .iter()"}, {"sha": "64d01ddb09a493bafff61f309e741d0709af66e6", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -3,7 +3,7 @@ use std::fmt::Debug;\n \n use super::TraitEngine;\n use super::{ChalkFulfillmentContext, FulfillmentContext};\n-use crate::infer::InferCtxtExt;\n+use crate::traits::NormalizeExt;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::at::ToTrace;\n@@ -104,11 +104,11 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n \n     pub fn normalize<T: TypeFoldable<'tcx>>(\n         &self,\n-        cause: ObligationCause<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         value: T,\n     ) -> T {\n-        let infer_ok = self.infcx.partially_normalize_associated_types_in(cause, param_env, value);\n+        let infer_ok = self.infcx.at(&cause, param_env).normalize(value);\n         self.register_infer_ok_obligations(infer_ok)\n     }\n \n@@ -185,7 +185,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n             // sound and then uncomment this line again.\n \n             // implied_bounds.insert(ty);\n-            let normalized = self.normalize(cause.clone(), param_env, ty);\n+            let normalized = self.normalize(&cause, param_env, ty);\n             implied_bounds.insert(normalized);\n         }\n         implied_bounds"}, {"sha": "752b53fbc3f9a2011c5cfa90afc2e32d2fbfb8b0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -17,11 +17,11 @@ pub fn recompute_applicable_impls<'tcx>(\n         let placeholder_obligation =\n             infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n         let obligation_trait_ref =\n-            ocx.normalize(dummy_cause.clone(), param_env, placeholder_obligation.trait_ref);\n+            ocx.normalize(&dummy_cause, param_env, placeholder_obligation.trait_ref);\n \n         let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n         let impl_trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap().subst(tcx, impl_substs);\n-        let impl_trait_ref = ocx.normalize(ObligationCause::dummy(), param_env, impl_trait_ref);\n+        let impl_trait_ref = ocx.normalize(&ObligationCause::dummy(), param_env, impl_trait_ref);\n \n         if let Err(_) = ocx.eq(&dummy_cause, param_env, obligation_trait_ref, impl_trait_ref) {\n             return false;"}, {"sha": "049b24b39975dd3ff7e21978d667a4d40d324ee1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -9,11 +9,11 @@ use super::{\n };\n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::infer::InferCtxtExt as _;\n use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use crate::traits::query::normalize::AtExt as _;\n+use crate::traits::query::normalize::QueryNormalizeExt as _;\n use crate::traits::specialize::to_pretty_impl_header;\n+use crate::traits::NormalizeExt;\n use on_unimplemented::OnUnimplementedNote;\n use on_unimplemented::TypeErrCtxtExt as _;\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n@@ -357,7 +357,8 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                 ocx.register_obligation(obligation);\n                 if ocx.select_all_or_error().is_empty() {\n                     return Ok((\n-                        ty::ClosureKind::from_def_id(self.tcx, trait_def_id)\n+                        self.tcx\n+                            .fn_trait_kind_from_def_id(trait_def_id)\n                             .expect(\"expected to map DefId to ClosureKind\"),\n                         ty.rebind(self.resolve_vars_if_possible(var)),\n                     ));\n@@ -686,7 +687,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 }\n                                 ObligationCauseCode::BindingObligation(def_id, _)\n                                 | ObligationCauseCode::ItemObligation(def_id)\n-                                    if ty::ClosureKind::from_def_id(tcx, *def_id).is_some() =>\n+                                    if tcx.is_fn_trait(*def_id) =>\n                                 {\n                                     err.code(rustc_errors::error_code!(E0059));\n                                     err.set_primary_message(format!(\n@@ -846,8 +847,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             );\n                         }\n \n-                        let is_fn_trait =\n-                            ty::ClosureKind::from_def_id(tcx, trait_ref.def_id()).is_some();\n+                        let is_fn_trait = tcx.is_fn_trait(trait_ref.def_id());\n                         let is_target_feature_fn = if let ty::FnDef(def_id, _) =\n                             *trait_ref.skip_binder().self_ty().kind()\n                         {\n@@ -877,7 +877,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             // Note if the `FnMut` or `FnOnce` is less general than the trait we're trying\n                             // to implement.\n                             let selected_kind =\n-                                ty::ClosureKind::from_def_id(self.tcx, trait_ref.def_id())\n+                                self.tcx.fn_trait_kind_from_def_id(trait_ref.def_id())\n                                     .expect(\"expected to map DefId to ClosureKind\");\n                             if !implemented_kind.extends(selected_kind) {\n                                 err.note(\n@@ -1595,6 +1595,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     bound_predicate.rebind(data),\n                 );\n                 let mut obligations = vec![];\n+                // FIXME(normalization): Change this to use `At::normalize`\n                 let normalized_ty = super::normalize_projection_type(\n                     &mut selcx,\n                     obligation.param_env,\n@@ -1933,7 +1934,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let infcx = self.tcx.infer_ctxt().build();\n             infcx\n                 .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n-                .normalize(candidate)\n+                .query_normalize(candidate)\n                 .map_or(candidate, |normalized| normalized.value)\n         };\n \n@@ -2155,7 +2156,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     if generics.params.iter().any(|p| p.name != kw::SelfUpper)\n                         && !snippet.ends_with('>')\n                         && !generics.has_impl_trait()\n-                        && !self.tcx.fn_trait_kind_from_lang_item(def_id).is_some()\n+                        && !self.tcx.is_fn_trait(def_id)\n                     {\n                         // FIXME: To avoid spurious suggestions in functions where type arguments\n                         // where already supplied, we check the snippet to make sure it doesn't\n@@ -2535,19 +2536,12 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n \n             let InferOk { value: cleaned_pred, .. } =\n-                self.infcx.partially_normalize_associated_types_in(\n-                    ObligationCause::dummy(),\n-                    param_env,\n-                    cleaned_pred,\n-                );\n+                self.infcx.at(&ObligationCause::dummy(), param_env).normalize(cleaned_pred);\n \n             let obligation =\n                 Obligation::new(self.tcx, ObligationCause::dummy(), param_env, cleaned_pred);\n \n-            // We don't use `InferCtxt::predicate_may_hold` because that\n-            // will re-run predicates that overflow locally, which ends up\n-            // taking a really long time to compute.\n-            self.evaluate_obligation(&obligation).map_or(false, |eval| eval.may_apply())\n+            self.predicate_may_hold(&obligation)\n         })\n     }\n "}, {"sha": "1740128727a5a34bf1ff8847a1dcdfa0fcd56f75", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2,6 +2,7 @@ use super::{DefIdOrName, Obligation, ObligationCause, ObligationCauseCode, Predi\n \n use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n+use crate::traits::NormalizeExt;\n \n use hir::def::CtorOf;\n use hir::HirId;\n@@ -1336,8 +1337,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     obligation.param_env,\n                     trait_pred_and_suggested_ty,\n                 );\n-                let suggested_ty_would_satisfy_obligation =\n-                    self.predicate_must_hold_modulo_regions(&new_obligation);\n+                let suggested_ty_would_satisfy_obligation = self\n+                    .evaluate_obligation_no_overflow(&new_obligation)\n+                    .must_apply_modulo_regions();\n                 if suggested_ty_would_satisfy_obligation {\n                     let sp = self\n                         .tcx\n@@ -1679,9 +1681,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         ) -> Ty<'tcx> {\n             let inputs = trait_ref.skip_binder().substs.type_at(1);\n             let sig = match inputs.kind() {\n-                ty::Tuple(inputs)\n-                    if infcx.tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some() =>\n-                {\n+                ty::Tuple(inputs) if infcx.tcx.is_fn_trait(trait_ref.def_id()) => {\n                     infcx.tcx.mk_fn_sig(\n                         inputs.iter(),\n                         infcx.next_ty_var(TypeVariableOrigin {\n@@ -1752,7 +1752,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n             && let Some(pred) = predicates.predicates.get(*idx)\n             && let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder()\n-            && ty::ClosureKind::from_def_id(self.tcx, trait_pred.def_id()).is_some()\n+            && self.tcx.is_fn_trait(trait_pred.def_id())\n         {\n             let expected_self =\n                 self.tcx.anonymize_late_bound_regions(pred.kind().rebind(trait_pred.self_ty()));\n@@ -1766,8 +1766,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 .enumerate()\n                 .find(|(other_idx, (pred, _))| match pred.kind().skip_binder() {\n                     ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n-                        if ty::ClosureKind::from_def_id(self.tcx, trait_pred.def_id())\n-                            .is_some()\n+                        if self.tcx.is_fn_trait(trait_pred.def_id())\n                             && other_idx != idx\n                             // Make sure that the self type matches\n                             // (i.e. constraining this closure)\n@@ -1991,11 +1990,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             .as_local()\n             .and_then(|def_id| hir.maybe_body_owned_by(def_id))\n             .map(|body_id| hir.body(body_id));\n-        let is_async = self\n-            .tcx\n-            .generator_kind(generator_did)\n-            .map(|generator_kind| matches!(generator_kind, hir::GeneratorKind::Async(..)))\n-            .unwrap_or(false);\n         let mut visitor = AwaitsVisitor::default();\n         if let Some(body) = generator_body {\n             visitor.visit_body(body);\n@@ -2072,6 +2066,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         debug!(?interior_or_upvar_span);\n         if let Some(interior_or_upvar_span) = interior_or_upvar_span {\n+            let is_async = self.tcx.generator_is_async(generator_did);\n             let typeck_results = match generator_data {\n                 GeneratorData::Local(typeck_results) => Some(typeck_results),\n                 GeneratorData::Foreign(_) => None,\n@@ -2644,10 +2639,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 if is_future\n                                     && obligated_types.last().map_or(false, |ty| match ty.kind() {\n                                         ty::Generator(last_def_id, ..) => {\n-                                            matches!(\n-                                                tcx.generator_kind(last_def_id),\n-                                                Some(GeneratorKind::Async(..))\n-                                            )\n+                                            tcx.generator_is_async(*last_def_id)\n                                         }\n                                         _ => false,\n                                     })\n@@ -2673,7 +2665,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 let sp = self.tcx.def_span(def_id);\n \n                                 // Special-case this to say \"async block\" instead of `[static generator]`.\n-                                let kind = tcx.generator_kind(def_id).unwrap();\n+                                let kind = tcx.generator_kind(def_id).unwrap().descr();\n                                 err.span_note(\n                                     sp,\n                                     &format!(\"required because it's used within this {}\", kind),\n@@ -2975,12 +2967,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         self.tcx.mk_substs_trait(trait_pred.self_ty(), []),\n                     )\n                 });\n-                let InferOk { value: projection_ty, .. } = self\n-                    .partially_normalize_associated_types_in(\n-                        obligation.cause.clone(),\n-                        obligation.param_env,\n-                        projection_ty,\n-                    );\n+                let InferOk { value: projection_ty, .. } =\n+                    self.at(&obligation.cause, obligation.param_env).normalize(projection_ty);\n \n                 debug!(\n                     normalized_projection_type = ?self.resolve_vars_if_possible(projection_ty)"}, {"sha": "76a755ed9e09d4a1da7070064fba845301c5d12a", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -199,7 +199,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n             // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n             1 => {\n                 let infer_var = pending_obligation.stalled_on[0];\n-                self.selcx.infcx().ty_or_const_infer_var_changed(infer_var)\n+                self.selcx.infcx.ty_or_const_infer_var_changed(infer_var)\n             }\n             0 => {\n                 // In this case we haven't changed, but wish to make a change.\n@@ -210,7 +210,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 // form was a perf win. See #64545 for details.\n                 (|| {\n                     for &infer_var in &pending_obligation.stalled_on {\n-                        if self.selcx.infcx().ty_or_const_infer_var_changed(infer_var) {\n+                        if self.selcx.infcx.ty_or_const_infer_var_changed(infer_var) {\n                             return true;\n                         }\n                     }\n@@ -240,13 +240,12 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n         debug!(?obligation, \"pre-resolve\");\n \n         if obligation.predicate.has_non_region_infer() {\n-            obligation.predicate =\n-                self.selcx.infcx().resolve_vars_if_possible(obligation.predicate);\n+            obligation.predicate = self.selcx.infcx.resolve_vars_if_possible(obligation.predicate);\n         }\n \n         let obligation = &pending_obligation.obligation;\n \n-        let infcx = self.selcx.infcx();\n+        let infcx = self.selcx.infcx;\n \n         if obligation.predicate.has_projections() {\n             let mut obligations = Vec::new();\n@@ -353,7 +352,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n \n                 ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n-                    match self.selcx.infcx().closure_kind(closure_substs) {\n+                    match self.selcx.infcx.closure_kind(closure_substs) {\n                         Some(closure_kind) => {\n                             if closure_kind.extends(kind) {\n                                 ProcessResult::Changed(vec![])\n@@ -367,7 +366,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                 ty::PredicateKind::WellFormed(arg) => {\n                     match wf::obligations(\n-                        self.selcx.infcx(),\n+                        self.selcx.infcx,\n                         obligation.param_env,\n                         obligation.cause.body_id,\n                         obligation.recursion_depth + 1,\n@@ -384,7 +383,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n \n                 ty::PredicateKind::Subtype(subtype) => {\n-                    match self.selcx.infcx().subtype_predicate(\n+                    match self.selcx.infcx.subtype_predicate(\n                         &obligation.cause,\n                         obligation.param_env,\n                         Binder::dummy(subtype),\n@@ -408,7 +407,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n \n                 ty::PredicateKind::Coerce(coerce) => {\n-                    match self.selcx.infcx().coerce_predicate(\n+                    match self.selcx.infcx.coerce_predicate(\n                         &obligation.cause,\n                         obligation.param_env,\n                         Binder::dummy(coerce),\n@@ -432,7 +431,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                 ty::PredicateKind::ConstEvaluatable(uv) => {\n                     match const_evaluatable::is_const_evaluatable(\n-                        self.selcx.infcx(),\n+                        self.selcx.infcx,\n                         uv,\n                         obligation.param_env,\n                         obligation.cause.span,\n@@ -503,7 +502,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                     let mut evaluate = |c: Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(unevaluated) = c.kind() {\n-                            match self.selcx.infcx().try_const_eval_resolve(\n+                            match self.selcx.infcx.try_const_eval_resolve(\n                                 obligation.param_env,\n                                 unevaluated,\n                                 c.ty(),\n@@ -531,7 +530,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                         (Ok(c1), Ok(c2)) => {\n                             match self\n                                 .selcx\n-                                .infcx()\n+                                .infcx\n                                 .at(&obligation.cause, obligation.param_env)\n                                 .eq(c1, c2)\n                             {\n@@ -601,7 +600,7 @@ impl<'a, 'tcx> FulfillProcessor<'a, 'tcx> {\n         trait_obligation: TraitObligation<'tcx>,\n         stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,\n     ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n-        let infcx = self.selcx.infcx();\n+        let infcx = self.selcx.infcx;\n         if obligation.predicate.is_global() {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n@@ -659,7 +658,7 @@ impl<'a, 'tcx> FulfillProcessor<'a, 'tcx> {\n         if obligation.predicate.is_global() {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n-            if self.selcx.infcx().predicate_must_hold_considering_regions(obligation) {\n+            if self.selcx.infcx.predicate_must_hold_considering_regions(obligation) {\n                 if let Some(key) = ProjectionCacheKey::from_poly_projection_predicate(\n                     &mut self.selcx,\n                     project_obligation.predicate,\n@@ -668,7 +667,7 @@ impl<'a, 'tcx> FulfillProcessor<'a, 'tcx> {\n                     // evaluated all sub-obligations. We can therefore mark the 'root'\n                     // obligation as complete, and skip evaluating sub-obligations.\n                     self.selcx\n-                        .infcx()\n+                        .infcx\n                         .inner\n                         .borrow_mut()\n                         .projection_cache()\n@@ -707,7 +706,7 @@ fn substs_infer_vars<'a, 'tcx>(\n     substs: ty::Binder<'tcx, SubstsRef<'tcx>>,\n ) -> impl Iterator<Item = TyOrConstInferVar<'tcx>> {\n     selcx\n-        .infcx()\n+        .infcx\n         .resolve_vars_if_possible(substs)\n         .skip_binder() // ok because this check doesn't care about regions\n         .iter()"}, {"sha": "371367f0deb3e671f956c7dd41d898f4e5eaf83b", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -56,7 +56,8 @@ pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n-pub use self::project::{normalize, normalize_projection_type, normalize_to};\n+pub(crate) use self::project::{normalize, normalize_to};\n+pub use self::project::{normalize_projection_type, NormalizeExt};\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n@@ -386,7 +387,7 @@ where\n {\n     let ocx = ObligationCtxt::new(infcx);\n     debug!(?value);\n-    let normalized_value = ocx.normalize(cause, param_env, value);\n+    let normalized_value = ocx.normalize(&cause, param_env, value);\n     debug!(?normalized_value);\n     debug!(\"select_all_or_error start\");\n     let errors = ocx.select_all_or_error();\n@@ -453,7 +454,7 @@ pub fn impossible_predicates<'tcx>(\n     let infcx = tcx.infer_ctxt().build();\n     let param_env = ty::ParamEnv::reveal_all();\n     let ocx = ObligationCtxt::new(&infcx);\n-    let predicates = ocx.normalize(ObligationCause::dummy(), param_env, predicates);\n+    let predicates = ocx.normalize(&ObligationCause::dummy(), param_env, predicates);\n     for predicate in predicates {\n         let obligation = Obligation::new(tcx, ObligationCause::dummy(), param_env, predicate);\n         ocx.register_obligation(obligation);"}, {"sha": "113803cd1790ac362a3794731b2d6186ca108991", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -27,6 +27,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n+use rustc_infer::infer::at::At;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n use rustc_infer::traits::ImplSourceBuiltinData;\n use rustc_middle::traits::select::OverflowError;\n@@ -48,6 +49,19 @@ pub type ProjectionTyObligation<'tcx> = Obligation<'tcx, ty::ProjectionTy<'tcx>>\n \n pub(super) struct InProgress;\n \n+pub trait NormalizeExt<'tcx> {\n+    fn normalize<T: TypeFoldable<'tcx>>(&self, t: T) -> InferOk<'tcx, T>;\n+}\n+\n+impl<'tcx> NormalizeExt<'tcx> for At<'_, 'tcx> {\n+    fn normalize<T: TypeFoldable<'tcx>>(&self, value: T) -> InferOk<'tcx, T> {\n+        let mut selcx = SelectionContext::new(self.infcx);\n+        let Normalized { value, obligations } =\n+            normalize(&mut selcx, self.param_env, self.cause.clone(), value);\n+        InferOk { value, obligations }\n+    }\n+}\n+\n /// When attempting to resolve `<T as TraitRef>::Name` ...\n #[derive(Debug)]\n pub enum ProjectionError<'tcx> {\n@@ -194,7 +208,7 @@ pub(super) fn poly_project_and_unify_type<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>,\n ) -> ProjectAndUnifyResult<'tcx> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let r = infcx.commit_if_ok(|_snapshot| {\n         let old_universe = infcx.universe();\n         let placeholder_predicate =\n@@ -250,7 +264,7 @@ fn project_and_unify_type<'cx, 'tcx>(\n ) -> ProjectAndUnifyResult<'tcx> {\n     let mut obligations = vec![];\n \n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let normalized = match opt_normalize_projection_type(\n         selcx,\n         obligation.param_env,\n@@ -269,7 +283,7 @@ fn project_and_unify_type<'cx, 'tcx>(\n     // This allows users to omit re-mentioning all bounds on an associated type and just use an\n     // `impl Trait` for the assoc type to add more bounds.\n     let InferOk { value: actual, obligations: new } =\n-        selcx.infcx().replace_opaque_types_with_inference_vars(\n+        selcx.infcx.replace_opaque_types_with_inference_vars(\n             actual,\n             obligation.cause.body_id,\n             obligation.cause.span,\n@@ -293,7 +307,7 @@ fn project_and_unify_type<'cx, 'tcx>(\n /// them with a fully resolved type where possible. The return value\n /// combines the normalized result and any additional obligations that\n /// were incurred as result.\n-pub fn normalize<'a, 'b, 'tcx, T>(\n+pub(crate) fn normalize<'a, 'b, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n@@ -307,7 +321,7 @@ where\n     Normalized { value, obligations }\n }\n \n-pub fn normalize_to<'a, 'b, 'tcx, T>(\n+pub(crate) fn normalize_to<'a, 'b, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n@@ -321,7 +335,7 @@ where\n }\n \n /// As `normalize`, but with a custom depth.\n-pub fn normalize_with_depth<'a, 'b, 'tcx, T>(\n+pub(crate) fn normalize_with_depth<'a, 'b, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n@@ -337,7 +351,7 @@ where\n }\n \n #[instrument(level = \"info\", skip(selcx, param_env, cause, obligations))]\n-pub fn normalize_with_depth_to<'a, 'b, 'tcx, T>(\n+pub(crate) fn normalize_with_depth_to<'a, 'b, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n@@ -357,7 +371,7 @@ where\n }\n \n #[instrument(level = \"info\", skip(selcx, param_env, cause, obligations))]\n-pub fn try_normalize_with_depth_to<'a, 'b, 'tcx, T>(\n+pub(crate) fn try_normalize_with_depth_to<'a, 'b, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n@@ -445,7 +459,7 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n \n     fn fold<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n-        let value = self.selcx.infcx().resolve_vars_if_possible(value);\n+        let value = self.selcx.infcx.resolve_vars_if_possible(value);\n         debug!(?value);\n \n         assert!(\n@@ -524,7 +538,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                                 self.param_env,\n                                 ty,\n                             );\n-                            self.selcx.infcx().err_ctxt().report_overflow_error(&obligation, true);\n+                            self.selcx.infcx.err_ctxt().report_overflow_error(&obligation, true);\n                         }\n \n                         let substs = substs.fold_with(self);\n@@ -590,7 +604,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 // want to figure out how to register obligations with escaping vars\n                 // or handle this some other way.\n \n-                let infcx = self.selcx.infcx();\n+                let infcx = self.selcx.infcx;\n                 let (data, mapped_regions, mapped_types, mapped_consts) =\n                     BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n                 let data = data.fold_with(self);\n@@ -640,7 +654,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n             let constant = constant.super_fold_with(self);\n             debug!(?constant, ?self.param_env);\n             with_replaced_escaping_bound_vars(\n-                self.selcx.infcx(),\n+                self.selcx.infcx,\n                 &mut self.universes,\n                 constant,\n                 |constant| constant.eval(tcx, self.param_env),\n@@ -818,7 +832,7 @@ impl<'tcx> TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                 let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderConst { universe, name: bound_const };\n                 self.mapped_consts.insert(p, bound_const);\n-                self.infcx.tcx.mk_const(ty::ConstKind::Placeholder(p), ct.ty())\n+                self.infcx.tcx.mk_const(p, ct.ty())\n             }\n             _ => ct.super_fold_with(self),\n         }\n@@ -829,7 +843,7 @@ impl<'tcx> TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n     }\n }\n \n-// The inverse of `BoundVarReplacer`: replaces placeholders with the bound vars from which they came.\n+/// The inverse of [`BoundVarReplacer`]: replaces placeholders with the bound vars from which they came.\n pub struct PlaceholderReplacer<'me, 'tcx> {\n     infcx: &'me InferCtxt<'tcx>,\n     mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n@@ -992,10 +1006,7 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n         // and a deferred predicate to resolve this when more type\n         // information is available.\n \n-        selcx\n-            .infcx()\n-            .infer_projection(param_env, projection_ty, cause, depth + 1, obligations)\n-            .into()\n+        selcx.infcx.infer_projection(param_env, projection_ty, cause, depth + 1, obligations).into()\n     })\n }\n \n@@ -1018,7 +1029,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     depth: usize,\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n ) -> Result<Option<Term<'tcx>>, InProgress> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     // Don't use the projection cache in intercrate mode -\n     // the `infcx` may be re-used between intercrate in non-intercrate\n     // mode, which could lead to using incorrect cache results.\n@@ -1110,7 +1121,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n-            let projected_term = selcx.infcx().resolve_vars_if_possible(projected_term);\n+            let projected_term = selcx.infcx.resolve_vars_if_possible(projected_term);\n \n             let mut result = if projected_term.has_projections() {\n                 let mut normalizer = AssocTypeNormalizer::new(\n@@ -1206,9 +1217,9 @@ fn normalize_to_error<'a, 'tcx>(\n         param_env,\n         predicate: trait_ref.without_const().to_predicate(selcx.tcx()),\n     };\n-    let tcx = selcx.infcx().tcx;\n+    let tcx = selcx.infcx.tcx;\n     let def_id = projection_ty.item_def_id;\n-    let new_value = selcx.infcx().next_ty_var(TypeVariableOrigin {\n+    let new_value = selcx.infcx.next_ty_var(TypeVariableOrigin {\n         kind: TypeVariableOriginKind::NormalizeProjectionType,\n         span: tcx.def_span(def_id),\n     });\n@@ -1330,7 +1341,7 @@ fn assemble_candidate_for_impl_trait_in_trait<'cx, 'tcx>(\n         let trait_predicate =\n             ty::Binder::dummy(ty::TraitRef { def_id: trait_def_id, substs: trait_substs });\n \n-        let _ = selcx.infcx().commit_if_ok(|_| {\n+        let _ = selcx.infcx.commit_if_ok(|_| {\n             match selcx.select(&obligation.with(tcx, trait_predicate)) {\n                 Ok(Some(super::ImplSource::UserDefined(data))) => {\n                     candidate_set.push_candidate(ProjectionCandidate::ImplTraitInTrait(\n@@ -1435,7 +1446,7 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     let tcx = selcx.tcx();\n \n     let self_ty = obligation.predicate.self_ty();\n-    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n+    let object_ty = selcx.infcx.shallow_resolve(self_ty);\n     let data = match object_ty.kind() {\n         ty::Dynamic(data, ..) => data,\n         ty::Infer(ty::TyVar(_)) => {\n@@ -1473,7 +1484,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     potentially_unnormalized_candidates: bool,\n ) {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     for predicate in env_predicates {\n         let bound_predicate = predicate.kind();\n         if let ty::PredicateKind::Clause(ty::Clause::Projection(data)) =\n@@ -1529,7 +1540,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n     // start out by selecting the predicate `T as TraitRef<...>`:\n     let poly_trait_ref = ty::Binder::dummy(obligation.predicate.trait_ref(selcx.tcx()));\n     let trait_obligation = obligation.with(selcx.tcx(), poly_trait_ref);\n-    let _ = selcx.infcx().commit_if_ok(|_| {\n+    let _ = selcx.infcx.commit_if_ok(|_| {\n         let impl_source = match selcx.select(&trait_obligation) {\n             Ok(Some(impl_source)) => impl_source,\n             Ok(None) => {\n@@ -1587,7 +1598,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     if obligation.param_env.reveal() == Reveal::All {\n                         // NOTE(eddyb) inference variables can resolve to parameters, so\n                         // assume `poly_trait_ref` isn't monomorphic, if it contains any.\n-                        let poly_trait_ref = selcx.infcx().resolve_vars_if_possible(poly_trait_ref);\n+                        let poly_trait_ref = selcx.infcx.resolve_vars_if_possible(poly_trait_ref);\n                         !poly_trait_ref.still_further_specializable()\n                     } else {\n                         debug!(\n@@ -1603,7 +1614,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // While a builtin impl may be known to exist, the associated type may not yet\n                 // be known. Any type with multiple potential associated types is therefore\n                 // not eligible.\n-                let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n+                let self_ty = selcx.infcx.shallow_resolve(obligation.predicate.self_ty());\n \n                 let lang_items = selcx.tcx().lang_items();\n                 if lang_items.discriminant_kind_trait() == Some(poly_trait_ref.def_id()) {\n@@ -1690,7 +1701,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                         // type parameters, opaques, and unnormalized projections have pointer\n                         // metadata if they're known (e.g. by the param_env) to be sized\n                         ty::Param(_) | ty::Projection(..) | ty::Opaque(..)\n-                            if selcx.infcx().predicate_must_hold_modulo_regions(\n+                            if selcx.infcx.predicate_must_hold_modulo_regions(\n                                 &obligation.with(\n                                     selcx.tcx(),\n                                     ty::Binder::dummy(\n@@ -1818,8 +1829,7 @@ fn confirm_candidate<'cx, 'tcx>(\n     // when possible for this to work. See `auto-trait-projection-recursion.rs`\n     // for a case where this matters.\n     if progress.term.has_infer_regions() {\n-        progress.term =\n-            progress.term.fold_with(&mut OpportunisticRegionResolver::new(selcx.infcx()));\n+        progress.term = progress.term.fold_with(&mut OpportunisticRegionResolver::new(selcx.infcx));\n     }\n     progress\n }\n@@ -2000,7 +2010,7 @@ fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_pointer_impl_source: ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let fn_type = selcx.infcx().shallow_resolve(fn_pointer_impl_source.fn_ty);\n+    let fn_type = selcx.infcx.shallow_resolve(fn_pointer_impl_source.fn_ty);\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized { value: sig, obligations } = normalize_with_depth(\n         selcx,\n@@ -2073,7 +2083,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n     poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n     potentially_unnormalized_candidate: bool,\n ) -> Progress<'tcx> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let cause = &obligation.cause;\n     let param_env = obligation.param_env;\n \n@@ -2168,7 +2178,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     // * `substs` ends up as `[u32, S]`\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n     let substs =\n-        translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n+        translate_substs(selcx.infcx, param_env, impl_def_id, substs, assoc_ty.defining_node);\n     let ty = tcx.bound_type_of(assoc_ty.item.def_id);\n     let is_const = matches!(tcx.def_kind(assoc_ty.item.def_id), DefKind::AssocConst);\n     let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n@@ -2264,7 +2274,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n     let impl_fn_substs =\n         obligation.predicate.substs.rebase_onto(tcx, tcx.parent(trait_fn_def_id), data.substs);\n     let impl_fn_substs = translate_substs(\n-        selcx.infcx(),\n+        selcx.infcx,\n         obligation.param_env,\n         data.impl_def_id,\n         impl_fn_substs,\n@@ -2424,7 +2434,7 @@ impl<'cx, 'tcx> ProjectionCacheKeyExt<'cx, 'tcx> for ProjectionCacheKey<'tcx> {\n         selcx: &mut SelectionContext<'cx, 'tcx>,\n         predicate: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<Self> {\n-        let infcx = selcx.infcx();\n+        let infcx = selcx.infcx;\n         // We don't do cross-snapshot caching of obligations with escaping regions,\n         // so there's no cache key to use\n         predicate.no_bound_vars().map(|predicate| {"}, {"sha": "1aed66308709e33a8e43df92298e951c4d549b9d", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -22,13 +22,13 @@ use super::NoSolution;\n \n pub use rustc_middle::traits::query::NormalizationResult;\n \n-pub trait AtExt<'tcx> {\n-    fn normalize<T>(&self, value: T) -> Result<Normalized<'tcx, T>, NoSolution>\n+pub trait QueryNormalizeExt<'tcx> {\n+    fn query_normalize<T>(&self, value: T) -> Result<Normalized<'tcx, T>, NoSolution>\n     where\n         T: TypeFoldable<'tcx>;\n }\n \n-impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n+impl<'cx, 'tcx> QueryNormalizeExt<'tcx> for At<'cx, 'tcx> {\n     /// Normalize `value` in the context of the inference context,\n     /// yielding a resulting type, or an error if `value` cannot be\n     /// normalized. If you don't care about regions, you should prefer\n@@ -42,7 +42,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n     /// normalizing, but for now should be used only when we actually\n     /// know that normalization will succeed, since error reporting\n     /// and other details are still \"under development\".\n-    fn normalize<T>(&self, value: T) -> Result<Normalized<'tcx, T>, NoSolution>\n+    fn query_normalize<T>(&self, value: T) -> Result<Normalized<'tcx, T>, NoSolution>\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "fe5135661b5f8f3996649ee9519849d747ad08e3", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 11, "deletions": 220, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -9,225 +9,18 @@ use hir::LangItem;\n use rustc_hir as hir;\n use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Ty, TypeVisitable};\n use rustc_target::spec::abi::Abi;\n \n use crate::traits;\n-use crate::traits::coherence::Conflict;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n-use crate::traits::{util, SelectionResult};\n-use crate::traits::{ErrorReporting, Overflow, Unimplemented};\n+use crate::traits::util;\n \n use super::BuiltinImplConditions;\n-use super::IntercrateAmbiguityCause;\n-use super::OverflowError;\n-use super::SelectionCandidate::{self, *};\n-use super::{EvaluatedCandidate, SelectionCandidateSet, SelectionContext, TraitObligationStack};\n+use super::SelectionCandidate::*;\n+use super::{SelectionCandidateSet, SelectionContext, TraitObligationStack};\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    pub(super) fn candidate_from_obligation<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n-        // Watch out for overflow. This intentionally bypasses (and does\n-        // not update) the cache.\n-        self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n-\n-        // Check the cache. Note that we freshen the trait-ref\n-        // separately rather than using `stack.fresh_trait_ref` --\n-        // this is because we want the unbound variables to be\n-        // replaced with fresh types starting from index 0.\n-        let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);\n-        debug!(?cache_fresh_trait_pred);\n-        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n-\n-        if let Some(c) =\n-            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n-        {\n-            debug!(\"CACHE HIT\");\n-            return c;\n-        }\n-\n-        // If no match, compute result and insert into cache.\n-        //\n-        // FIXME(nikomatsakis) -- this cache is not taking into\n-        // account cycles that may have occurred in forming the\n-        // candidate. I don't know of any specific problems that\n-        // result but it seems awfully suspicious.\n-        let (candidate, dep_node) =\n-            self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n-\n-        debug!(\"CACHE MISS\");\n-        self.insert_candidate_cache(\n-            stack.obligation.param_env,\n-            cache_fresh_trait_pred,\n-            dep_node,\n-            candidate.clone(),\n-        );\n-        candidate\n-    }\n-\n-    fn candidate_from_obligation_no_cache<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n-        if let Err(conflict) = self.is_knowable(stack) {\n-            debug!(\"coherence stage: not knowable\");\n-            if self.intercrate_ambiguity_causes.is_some() {\n-                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n-                // Heuristics: show the diagnostics when there are no candidates in crate.\n-                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n-                    let mut no_candidates_apply = true;\n-\n-                    for c in candidate_set.vec.iter() {\n-                        if self.evaluate_candidate(stack, &c)?.may_apply() {\n-                            no_candidates_apply = false;\n-                            break;\n-                        }\n-                    }\n-\n-                    if !candidate_set.ambiguous && no_candidates_apply {\n-                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                        let self_ty = trait_ref.self_ty();\n-                        let (trait_desc, self_desc) = with_no_trimmed_paths!({\n-                            let trait_desc = trait_ref.print_only_trait_path().to_string();\n-                            let self_desc = if self_ty.has_concrete_skeleton() {\n-                                Some(self_ty.to_string())\n-                            } else {\n-                                None\n-                            };\n-                            (trait_desc, self_desc)\n-                        });\n-                        let cause = if let Conflict::Upstream = conflict {\n-                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n-                        } else {\n-                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n-                        };\n-                        debug!(?cause, \"evaluate_stack: pushing cause\");\n-                        self.intercrate_ambiguity_causes.as_mut().unwrap().insert(cause);\n-                    }\n-                }\n-            }\n-            return Ok(None);\n-        }\n-\n-        let candidate_set = self.assemble_candidates(stack)?;\n-\n-        if candidate_set.ambiguous {\n-            debug!(\"candidate set contains ambig\");\n-            return Ok(None);\n-        }\n-\n-        let candidates = candidate_set.vec;\n-\n-        debug!(?stack, ?candidates, \"assembled {} candidates\", candidates.len());\n-\n-        // At this point, we know that each of the entries in the\n-        // candidate set is *individually* applicable. Now we have to\n-        // figure out if they contain mutual incompatibilities. This\n-        // frequently arises if we have an unconstrained input type --\n-        // for example, we are looking for `$0: Eq` where `$0` is some\n-        // unconstrained type variable. In that case, we'll get a\n-        // candidate which assumes $0 == int, one that assumes `$0 ==\n-        // usize`, etc. This spells an ambiguity.\n-\n-        let mut candidates = self.filter_impls(candidates, stack.obligation);\n-\n-        // If there is more than one candidate, first winnow them down\n-        // by considering extra conditions (nested obligations and so\n-        // forth). We don't winnow if there is exactly one\n-        // candidate. This is a relatively minor distinction but it\n-        // can lead to better inference and error-reporting. An\n-        // example would be if there was an impl:\n-        //\n-        //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n-        //\n-        // and we were to see some code `foo.push_clone()` where `boo`\n-        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n-        // we were to winnow, we'd wind up with zero candidates.\n-        // Instead, we select the right impl now but report \"`Bar` does\n-        // not implement `Clone`\".\n-        if candidates.len() == 1 {\n-            return self.filter_reservation_impls(candidates.pop().unwrap(), stack.obligation);\n-        }\n-\n-        // Winnow, but record the exact outcome of evaluation, which\n-        // is needed for specialization. Propagate overflow if it occurs.\n-        let mut candidates = candidates\n-            .into_iter()\n-            .map(|c| match self.evaluate_candidate(stack, &c) {\n-                Ok(eval) if eval.may_apply() => {\n-                    Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))\n-                }\n-                Ok(_) => Ok(None),\n-                Err(OverflowError::Canonical) => Err(Overflow(OverflowError::Canonical)),\n-                Err(OverflowError::ErrorReporting) => Err(ErrorReporting),\n-                Err(OverflowError::Error(e)) => Err(Overflow(OverflowError::Error(e))),\n-            })\n-            .flat_map(Result::transpose)\n-            .collect::<Result<Vec<_>, _>>()?;\n-\n-        debug!(?stack, ?candidates, \"winnowed to {} candidates\", candidates.len());\n-\n-        let needs_infer = stack.obligation.predicate.has_non_region_infer();\n-\n-        // If there are STILL multiple candidates, we can further\n-        // reduce the list by dropping duplicates -- including\n-        // resolving specializations.\n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            while i < candidates.len() {\n-                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n-                    self.candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                        needs_infer,\n-                    )\n-                });\n-                if is_dup {\n-                    debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                    candidates.swap_remove(i);\n-                } else {\n-                    debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                    i += 1;\n-\n-                    // If there are *STILL* multiple candidates, give up\n-                    // and report ambiguity.\n-                    if i > 1 {\n-                        debug!(\"multiple matches, ambig\");\n-                        return Ok(None);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // If there are *NO* candidates, then there are no impls --\n-        // that we know of, anyway. Note that in the case where there\n-        // are unbound type variables within the obligation, it might\n-        // be the case that you could still satisfy the obligation\n-        // from another crate by instantiating the type variables with\n-        // a type from another crate that does have an impl. This case\n-        // is checked for in `evaluate_stack` (and hence users\n-        // who might care about this case, like coherence, should use\n-        // that function).\n-        if candidates.is_empty() {\n-            // If there's an error type, 'downgrade' our result from\n-            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n-            // emitting additional spurious errors, since we're guaranteed\n-            // to have emitted at least one.\n-            if stack.obligation.predicate.references_error() {\n-                debug!(?stack.obligation.predicate, \"found error type in predicate, treating as ambiguous\");\n-                return Ok(None);\n-            }\n-            return Err(Unimplemented);\n-        }\n-\n-        // Just one candidate left.\n-        self.filter_reservation_impls(candidates.pop().unwrap().candidate, stack.obligation)\n-    }\n-\n     #[instrument(skip(self, stack), level = \"debug\")]\n     pub(super) fn assemble_candidates<'o>(\n         &mut self,\n@@ -238,7 +31,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             param_env: obligation.param_env,\n             cause: obligation.cause.clone(),\n             recursion_depth: obligation.recursion_depth,\n-            predicate: self.infcx().resolve_vars_if_possible(obligation.predicate),\n+            predicate: self.infcx.resolve_vars_if_possible(obligation.predicate),\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n@@ -430,9 +223,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) {\n         let self_ty = obligation.self_ty().skip_binder();\n         if let ty::Generator(did, ..) = self_ty.kind() {\n-            if let Some(rustc_hir::GeneratorKind::Async(_generator_kind)) =\n-                self.tcx().generator_kind(did)\n-            {\n+            if self.tcx().generator_is_async(*did) {\n                 debug!(?self_ty, ?obligation, \"assemble_future_candidates\",);\n \n                 candidates.vec.push(FutureCandidate);\n@@ -451,7 +242,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n-        let Some(kind) = self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) else {\n+        let Some(kind) = self.tcx().fn_trait_kind_from_def_id(obligation.predicate.def_id()) else {\n             return;\n         };\n \n@@ -489,7 +280,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n         // We provide impl of all fn traits for fn pointers.\n-        if self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()).is_none() {\n+        if !self.tcx().is_fn_trait(obligation.predicate.def_id()) {\n             return;\n         }\n \n@@ -689,9 +480,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             debug!(?poly_trait_ref, \"assemble_candidates_from_object_ty\");\n \n-            let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n+            let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n             let placeholder_trait_predicate =\n-                self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n+                self.infcx.replace_bound_vars_with_placeholders(poly_trait_predicate);\n \n             // Count only those upcast versions that match the trait-ref\n             // we are looking for. Specifically, do not only check for the\n@@ -940,7 +731,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        let self_ty = self.infcx().shallow_resolve(obligation.self_ty());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         match self_ty.skip_binder().kind() {\n             ty::Opaque(..)\n             | ty::Dynamic(..)\n@@ -1007,7 +798,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n-        let self_ty = self.infcx().shallow_resolve(obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         match self_ty.kind() {\n             ty::Tuple(_) => {\n                 candidates.vec.push(BuiltinCandidate { has_nested: false });"}, {"sha": "22cd700dcb5f4747705c2c31185cace511e59529", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -147,7 +147,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);\n         let placeholder_trait_predicate =\n-            self.infcx().replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n+            self.infcx.replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n         let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n         let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n         let (def_id, substs) = match *placeholder_self_ty.kind() {\n@@ -639,7 +639,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?obligation, \"confirm_trait_alias_candidate\");\n \n         let alias_def_id = obligation.predicate.def_id();\n-        let predicate = self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n+        let predicate = self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n         let trait_ref = predicate.trait_ref;\n         let trait_def_id = trait_ref.def_id;\n         let substs = trait_ref.substs;\n@@ -735,7 +735,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let kind = self\n             .tcx()\n-            .fn_trait_kind_from_lang_item(obligation.predicate.def_id())\n+            .fn_trait_kind_from_def_id(obligation.predicate.def_id())\n             .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n \n         // Okay to skip binder because the substs on closure types never"}, {"sha": "515f3a34988869a77b50f5ccfa36619197032a47", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 217, "deletions": 13, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -30,6 +30,7 @@ use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::project::ProjectAndUnifyResult;\n use crate::traits::project::ProjectionCacheKeyExt;\n use crate::traits::ProjectionCacheKey;\n+use crate::traits::Unimplemented;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -55,6 +56,7 @@ use std::fmt::{self, Display};\n use std::iter;\n \n pub use rustc_middle::traits::select::*;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n \n mod candidate_assembly;\n mod confirmation;\n@@ -101,7 +103,7 @@ impl IntercrateAmbiguityCause {\n }\n \n pub struct SelectionContext<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n+    pub infcx: &'cx InferCtxt<'tcx>,\n \n     /// Freshener used specifically for entries on the obligation\n     /// stack. This ensures that all entries on the stack at one time\n@@ -237,10 +239,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.intercrate_ambiguity_causes.take().unwrap_or_default()\n     }\n \n-    pub fn infcx(&self) -> &'cx InferCtxt<'tcx> {\n-        self.infcx\n-    }\n-\n     pub fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -309,6 +307,208 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.candidate_from_obligation(&stack)\n     }\n \n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn candidate_from_obligation<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        // Watch out for overflow. This intentionally bypasses (and does\n+        // not update) the cache.\n+        self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n+\n+        // Check the cache. Note that we freshen the trait-ref\n+        // separately rather than using `stack.fresh_trait_ref` --\n+        // this is because we want the unbound variables to be\n+        // replaced with fresh types starting from index 0.\n+        let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);\n+        debug!(?cache_fresh_trait_pred);\n+        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n+\n+        if let Some(c) =\n+            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n+        {\n+            debug!(\"CACHE HIT\");\n+            return c;\n+        }\n+\n+        // If no match, compute result and insert into cache.\n+        //\n+        // FIXME(nikomatsakis) -- this cache is not taking into\n+        // account cycles that may have occurred in forming the\n+        // candidate. I don't know of any specific problems that\n+        // result but it seems awfully suspicious.\n+        let (candidate, dep_node) =\n+            self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n+\n+        debug!(\"CACHE MISS\");\n+        self.insert_candidate_cache(\n+            stack.obligation.param_env,\n+            cache_fresh_trait_pred,\n+            dep_node,\n+            candidate.clone(),\n+        );\n+        candidate\n+    }\n+\n+    fn candidate_from_obligation_no_cache<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        if let Err(conflict) = self.is_knowable(stack) {\n+            debug!(\"coherence stage: not knowable\");\n+            if self.intercrate_ambiguity_causes.is_some() {\n+                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n+                // Heuristics: show the diagnostics when there are no candidates in crate.\n+                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n+                    let mut no_candidates_apply = true;\n+\n+                    for c in candidate_set.vec.iter() {\n+                        if self.evaluate_candidate(stack, &c)?.may_apply() {\n+                            no_candidates_apply = false;\n+                            break;\n+                        }\n+                    }\n+\n+                    if !candidate_set.ambiguous && no_candidates_apply {\n+                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                        let self_ty = trait_ref.self_ty();\n+                        let (trait_desc, self_desc) = with_no_trimmed_paths!({\n+                            let trait_desc = trait_ref.print_only_trait_path().to_string();\n+                            let self_desc = if self_ty.has_concrete_skeleton() {\n+                                Some(self_ty.to_string())\n+                            } else {\n+                                None\n+                            };\n+                            (trait_desc, self_desc)\n+                        });\n+                        let cause = if let Conflict::Upstream = conflict {\n+                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n+                        } else {\n+                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n+                        };\n+                        debug!(?cause, \"evaluate_stack: pushing cause\");\n+                        self.intercrate_ambiguity_causes.as_mut().unwrap().insert(cause);\n+                    }\n+                }\n+            }\n+            return Ok(None);\n+        }\n+\n+        let candidate_set = self.assemble_candidates(stack)?;\n+\n+        if candidate_set.ambiguous {\n+            debug!(\"candidate set contains ambig\");\n+            return Ok(None);\n+        }\n+\n+        let candidates = candidate_set.vec;\n+\n+        debug!(?stack, ?candidates, \"assembled {} candidates\", candidates.len());\n+\n+        // At this point, we know that each of the entries in the\n+        // candidate set is *individually* applicable. Now we have to\n+        // figure out if they contain mutual incompatibilities. This\n+        // frequently arises if we have an unconstrained input type --\n+        // for example, we are looking for `$0: Eq` where `$0` is some\n+        // unconstrained type variable. In that case, we'll get a\n+        // candidate which assumes $0 == int, one that assumes `$0 ==\n+        // usize`, etc. This spells an ambiguity.\n+\n+        let mut candidates = self.filter_impls(candidates, stack.obligation);\n+\n+        // If there is more than one candidate, first winnow them down\n+        // by considering extra conditions (nested obligations and so\n+        // forth). We don't winnow if there is exactly one\n+        // candidate. This is a relatively minor distinction but it\n+        // can lead to better inference and error-reporting. An\n+        // example would be if there was an impl:\n+        //\n+        //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n+        //\n+        // and we were to see some code `foo.push_clone()` where `boo`\n+        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n+        // we were to winnow, we'd wind up with zero candidates.\n+        // Instead, we select the right impl now but report \"`Bar` does\n+        // not implement `Clone`\".\n+        if candidates.len() == 1 {\n+            return self.filter_reservation_impls(candidates.pop().unwrap(), stack.obligation);\n+        }\n+\n+        // Winnow, but record the exact outcome of evaluation, which\n+        // is needed for specialization. Propagate overflow if it occurs.\n+        let mut candidates = candidates\n+            .into_iter()\n+            .map(|c| match self.evaluate_candidate(stack, &c) {\n+                Ok(eval) if eval.may_apply() => {\n+                    Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))\n+                }\n+                Ok(_) => Ok(None),\n+                Err(OverflowError::Canonical) => Err(Overflow(OverflowError::Canonical)),\n+                Err(OverflowError::ErrorReporting) => Err(ErrorReporting),\n+                Err(OverflowError::Error(e)) => Err(Overflow(OverflowError::Error(e))),\n+            })\n+            .flat_map(Result::transpose)\n+            .collect::<Result<Vec<_>, _>>()?;\n+\n+        debug!(?stack, ?candidates, \"winnowed to {} candidates\", candidates.len());\n+\n+        let needs_infer = stack.obligation.predicate.has_non_region_infer();\n+\n+        // If there are STILL multiple candidates, we can further\n+        // reduce the list by dropping duplicates -- including\n+        // resolving specializations.\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            while i < candidates.len() {\n+                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n+                    self.candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                        needs_infer,\n+                    )\n+                });\n+                if is_dup {\n+                    debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                    candidates.swap_remove(i);\n+                } else {\n+                    debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                    i += 1;\n+\n+                    // If there are *STILL* multiple candidates, give up\n+                    // and report ambiguity.\n+                    if i > 1 {\n+                        debug!(\"multiple matches, ambig\");\n+                        return Ok(None);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // If there are *NO* candidates, then there are no impls --\n+        // that we know of, anyway. Note that in the case where there\n+        // are unbound type variables within the obligation, it might\n+        // be the case that you could still satisfy the obligation\n+        // from another crate by instantiating the type variables with\n+        // a type from another crate that does have an impl. This case\n+        // is checked for in `evaluate_stack` (and hence users\n+        // who might care about this case, like coherence, should use\n+        // that function).\n+        if candidates.is_empty() {\n+            // If there's an error type, 'downgrade' our result from\n+            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n+            // emitting additional spurious errors, since we're guaranteed\n+            // to have emitted at least one.\n+            if stack.obligation.predicate.references_error() {\n+                debug!(?stack.obligation.predicate, \"found error type in predicate, treating as ambiguous\");\n+                return Ok(None);\n+            }\n+            return Err(Unimplemented);\n+        }\n+\n+        // Just one candidate left.\n+        self.filter_reservation_impls(candidates.pop().unwrap().candidate, stack.obligation)\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // EVALUATION\n     //\n@@ -734,10 +934,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match self\n-                                .infcx()\n-                                .at(&obligation.cause, obligation.param_env)\n-                                .eq(c1, c2)\n+                            match self.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n                             {\n                                 Ok(inf_ok) => self.evaluate_predicates_recursively(\n                                     previous_stack,\n@@ -1256,7 +1453,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         let obligation = &stack.obligation;\n-        let predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n+        let predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n \n         // Okay to skip binder because of the nature of the\n         // trait-ref-is-knowable check, which does not care about\n@@ -1393,9 +1590,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> smallvec::SmallVec<[(usize, ty::BoundConstness); 2]> {\n-        let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n+        let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n         let placeholder_trait_predicate =\n-            self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n+            self.infcx.replace_bound_vars_with_placeholders(poly_trait_predicate);\n         debug!(?placeholder_trait_predicate);\n \n         let tcx = self.infcx.tcx;\n@@ -2147,6 +2344,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.match_impl(impl_def_id, impl_trait_ref, obligation) {\n             Ok(substs) => substs,\n             Err(()) => {\n+                // FIXME: A rematch may fail when a candidate cache hit occurs\n+                // on thefreshened form of the trait predicate, but the match\n+                // fails for some reason that is not captured in the freshened\n+                // cache key. For example, equating an impl trait ref against\n+                // the placeholder trait ref may fail due the Generalizer relation\n+                // raising a CyclicalTy error due to a sub_root_var relation\n+                // for a variable being generalized...\n                 self.infcx.tcx.sess.delay_span_bug(\n                     obligation.cause.span,\n                     &format!(\n@@ -2175,7 +2379,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<Normalized<'tcx, SubstsRef<'tcx>>, ()> {\n         let placeholder_obligation =\n-            self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n+            self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n         let placeholder_obligation_trait_ref = placeholder_obligation.trait_ref;\n \n         let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);"}, {"sha": "a251a508b48cf1777f4d86e62583066eb8caa0b7", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -230,7 +230,7 @@ fn fulfill_implication<'tcx>(\n     Ok(infcx.resolve_vars_if_possible(target_substs))\n }\n \n-// Query provider for `specialization_graph_of`.\n+/// Query provider for `specialization_graph_of`.\n pub(super) fn specialization_graph_provider(\n     tcx: TyCtxt<'_>,\n     trait_id: DefId,"}, {"sha": "51968c2d7a191fccc2bd21e17ff26b6a0ec343f1", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -8,8 +8,8 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, ImplSubject, ToPredicate, Ty, TyCtxt, TypeVisitable};\n use rustc_middle::ty::{GenericArg, SubstsRef};\n \n+use super::NormalizeExt;\n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext};\n-use crate::infer::InferCtxtExt;\n use rustc_infer::infer::InferOk;\n pub use rustc_infer::traits::{self, util::*};\n \n@@ -202,15 +202,13 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n ) -> (ImplSubject<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n     let subject = selcx.tcx().bound_impl_subject(impl_def_id);\n     let subject = subject.subst(selcx.tcx(), impl_substs);\n-    let InferOk { value: subject, obligations: normalization_obligations1 } = selcx\n-        .infcx()\n-        .partially_normalize_associated_types_in(ObligationCause::dummy(), param_env, subject);\n+    let InferOk { value: subject, obligations: normalization_obligations1 } =\n+        selcx.infcx.at(&ObligationCause::dummy(), param_env).normalize(subject);\n \n     let predicates = selcx.tcx().predicates_of(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n-    let InferOk { value: predicates, obligations: normalization_obligations2 } = selcx\n-        .infcx()\n-        .partially_normalize_associated_types_in(ObligationCause::dummy(), param_env, predicates);\n+    let InferOk { value: predicates, obligations: normalization_obligations2 } =\n+        selcx.infcx.at(&ObligationCause::dummy(), param_env).normalize(predicates);\n     let impl_obligations =\n         super::predicates_for_generics(|_, _| ObligationCause::dummy(), param_env, predicates);\n "}, {"sha": "66ab742f15782ae6689314daebb663653635eb41", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -11,7 +11,7 @@ use rustc_trait_selection::traits::query::dropck_outlives::trivial_dropck_outliv\n use rustc_trait_selection::traits::query::dropck_outlives::{\n     DropckConstraint, DropckOutlivesResult,\n };\n-use rustc_trait_selection::traits::query::normalize::AtExt;\n+use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n use rustc_trait_selection::traits::{Normalized, ObligationCause};\n \n@@ -100,7 +100,7 @@ fn dropck_outlives<'tcx>(\n             // to push them onto the stack to be expanded.\n             for ty in constraints.dtorck_types.drain(..) {\n                 let Normalized { value: ty, obligations } =\n-                    ocx.infcx.at(&cause, param_env).normalize(ty)?;\n+                    ocx.infcx.at(&cause, param_env).query_normalize(ty)?;\n                 ocx.register_obligations(obligations);\n \n                 debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);"}, {"sha": "44fd8bfb31f231ab058a1b3a0a5ff120bf2e8564", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -2,7 +2,7 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, ParamEnvAnd, TyCtxt, TypeFoldable};\n-use rustc_trait_selection::traits::query::normalize::AtExt;\n+use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n use rustc_trait_selection::traits::{Normalized, ObligationCause};\n use std::sync::atomic::Ordering;\n \n@@ -29,7 +29,7 @@ fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq +\n     let ParamEnvAnd { param_env, value } = goal;\n     let infcx = tcx.infer_ctxt().build();\n     let cause = ObligationCause::dummy();\n-    match infcx.at(&cause, param_env).normalize(value) {\n+    match infcx.at(&cause, param_env).query_normalize(value) {\n         Ok(Normalized { value: normalized_value, obligations: normalized_obligations }) => {\n             // We don't care about the `obligations`; they are\n             // always only region relations, and we are about to"}, {"sha": "7f964afde80fd1d4b90f925796562b86b0c2ff94", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty::{ParamEnvAnd, Predicate, ToPredicate};\n use rustc_middle::ty::{UserSelfTy, UserSubsts};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n-use rustc_trait_selection::traits::query::normalize::AtExt;\n+use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n use rustc_trait_selection::traits::query::type_op::ascribe_user_type::AscribeUserType;\n use rustc_trait_selection::traits::query::type_op::eq::Eq;\n use rustc_trait_selection::traits::query::type_op::normalize::Normalize;\n@@ -62,7 +62,7 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n     let cause = ObligationCause::dummy_with_span(span);\n \n     let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n-    let ty = ocx.normalize(cause.clone(), param_env, ty);\n+    let ty = ocx.normalize(&cause, param_env, ty);\n     debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n \n     ocx.eq(&cause, param_env, mir_ty, ty)?;\n@@ -85,14 +85,14 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n             ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n         );\n         let instantiated_predicate =\n-            ocx.normalize(cause.clone(), param_env, instantiated_predicate);\n+            ocx.normalize(&cause.clone(), param_env, instantiated_predicate);\n \n         ocx.register_obligation(Obligation::new(tcx, cause, param_env, instantiated_predicate));\n     }\n \n     if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n         let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n-        let impl_self_ty = ocx.normalize(cause.clone(), param_env, impl_self_ty);\n+        let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n \n         ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n \n@@ -137,7 +137,7 @@ where\n {\n     let (param_env, Normalize { value }) = key.into_parts();\n     let Normalized { value, obligations } =\n-        ocx.infcx.at(&ObligationCause::dummy(), param_env).normalize(value)?;\n+        ocx.infcx.at(&ObligationCause::dummy(), param_env).query_normalize(value)?;\n     ocx.register_obligations(obligations);\n     Ok(value)\n }"}, {"sha": "f8ff31f971be66756353fd39b2f8805ff4c028f6", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -5,7 +5,7 @@ use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc_middle::thir::visit;\n use rustc_middle::thir::visit::Visitor;\n use rustc_middle::ty::abstract_const::CastKind;\n-use rustc_middle::ty::{self, ConstKind, Expr, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, Expr, TyCtxt, TypeVisitable};\n use rustc_middle::{mir, thir};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n@@ -32,10 +32,8 @@ pub(crate) fn destructure_const<'tcx>(\n     let (fields, variant) = match const_.ty().kind() {\n         ty::Array(inner_ty, _) | ty::Slice(inner_ty) => {\n             // construct the consts for the elements of the array/slice\n-            let field_consts = branches\n-                .iter()\n-                .map(|b| tcx.mk_const(ty::ConstKind::Value(*b), *inner_ty))\n-                .collect::<Vec<_>>();\n+            let field_consts =\n+                branches.iter().map(|b| tcx.mk_const(*b, *inner_ty)).collect::<Vec<_>>();\n             debug!(?field_consts);\n \n             (field_consts, None)\n@@ -53,7 +51,7 @@ pub(crate) fn destructure_const<'tcx>(\n \n             for (field, field_valtree) in iter::zip(fields, branches) {\n                 let field_ty = field.ty(tcx, substs);\n-                let field_const = tcx.mk_const(ty::ConstKind::Value(*field_valtree), field_ty);\n+                let field_const = tcx.mk_const(*field_valtree, field_ty);\n                 field_consts.push(field_const);\n             }\n             debug!(?field_consts);\n@@ -62,9 +60,7 @@ pub(crate) fn destructure_const<'tcx>(\n         }\n         ty::Tuple(elem_tys) => {\n             let fields = iter::zip(*elem_tys, branches)\n-                .map(|(elem_ty, elem_valtree)| {\n-                    tcx.mk_const(ty::ConstKind::Value(*elem_valtree), elem_ty)\n-                })\n+                .map(|(elem_ty, elem_valtree)| tcx.mk_const(*elem_valtree, elem_ty))\n                 .collect::<Vec<_>>();\n \n             (fields, None)\n@@ -129,17 +125,17 @@ fn recurse_build<'tcx>(\n         }\n         &ExprKind::NonHirLiteral { lit, user_ty: _ } => {\n             let val = ty::ValTree::from_scalar_int(lit);\n-            ty::Const::from_value(tcx, val, node.ty)\n+            tcx.mk_const(val, node.ty)\n         }\n         &ExprKind::ZstLiteral { user_ty: _ } => {\n             let val = ty::ValTree::zst();\n-            ty::Const::from_value(tcx, val, node.ty)\n+            tcx.mk_const(val, node.ty)\n         }\n         &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n             let uneval = ty::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n-            tcx.mk_const(ty::ConstKind::Unevaluated(uneval), node.ty)\n+            tcx.mk_const(uneval, node.ty)\n         }\n-        ExprKind::ConstParam { param, .. } => tcx.mk_const(ty::ConstKind::Param(*param), node.ty),\n+        ExprKind::ConstParam { param, .. } => tcx.mk_const(*param, node.ty),\n \n         ExprKind::Call { fun, args, .. } => {\n             let fun = recurse_build(tcx, body, *fun, root_span)?;\n@@ -149,16 +145,16 @@ fn recurse_build<'tcx>(\n                 new_args.push(recurse_build(tcx, body, id, root_span)?);\n             }\n             let new_args = tcx.mk_const_list(new_args.iter());\n-            tcx.mk_const(ConstKind::Expr(Expr::FunctionCall(fun, new_args)), node.ty)\n+            tcx.mk_const(Expr::FunctionCall(fun, new_args), node.ty)\n         }\n         &ExprKind::Binary { op, lhs, rhs } if check_binop(op) => {\n             let lhs = recurse_build(tcx, body, lhs, root_span)?;\n             let rhs = recurse_build(tcx, body, rhs, root_span)?;\n-            tcx.mk_const(ConstKind::Expr(Expr::Binop(op, lhs, rhs)), node.ty)\n+            tcx.mk_const(Expr::Binop(op, lhs, rhs), node.ty)\n         }\n         &ExprKind::Unary { op, arg } if check_unop(op) => {\n             let arg = recurse_build(tcx, body, arg, root_span)?;\n-            tcx.mk_const(ConstKind::Expr(Expr::UnOp(op, arg)), node.ty)\n+            tcx.mk_const(Expr::UnOp(op, arg), node.ty)\n         }\n         // This is necessary so that the following compiles:\n         //\n@@ -179,11 +175,11 @@ fn recurse_build<'tcx>(\n         // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n         &ExprKind::Use { source } => {\n             let arg = recurse_build(tcx, body, source, root_span)?;\n-            tcx.mk_const(ConstKind::Expr(Expr::Cast(CastKind::Use, arg, node.ty)), node.ty)\n+            tcx.mk_const(Expr::Cast(CastKind::Use, arg, node.ty), node.ty)\n         }\n         &ExprKind::Cast { source } => {\n             let arg = recurse_build(tcx, body, source, root_span)?;\n-            tcx.mk_const(ConstKind::Expr(Expr::Cast(CastKind::As, arg, node.ty)), node.ty)\n+            tcx.mk_const(Expr::Cast(CastKind::As, arg, node.ty), node.ty)\n         }\n         ExprKind::Borrow { arg, .. } => {\n             let arg_node = &body.exprs[*arg];"}, {"sha": "c6f2b16ca210226db5b9482d7233e87676418292", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -209,7 +209,7 @@ fn resolve_associated_item<'tcx>(\n             substs: future_data.substs,\n         }),\n         traits::ImplSource::Closure(closure_data) => {\n-            let trait_closure_kind = tcx.fn_trait_kind_from_lang_item(trait_id).unwrap();\n+            let trait_closure_kind = tcx.fn_trait_kind_from_def_id(trait_id).unwrap();\n             Instance::resolve_closure(\n                 tcx,\n                 closure_data.closure_def_id,"}, {"sha": "a5311dbd1b77025b32d282d9cf689d70c5e53fcd", "filename": "compiler/rustc_ty_utils/src/layout_sanity_check.rs", "status": "modified", "additions": 272, "deletions": 262, "changes": 534, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -20,283 +20,293 @@ pub(super) fn sanity_check_layout<'tcx>(\n         bug!(\"size is not a multiple of align, in the following layout:\\n{layout:#?}\");\n     }\n \n-    if cfg!(debug_assertions) {\n-        /// Yields non-ZST fields of the type\n-        fn non_zst_fields<'tcx, 'a>(\n-            cx: &'a LayoutCx<'tcx, TyCtxt<'tcx>>,\n-            layout: &'a TyAndLayout<'tcx>,\n-        ) -> impl Iterator<Item = (Size, TyAndLayout<'tcx>)> + 'a {\n-            (0..layout.layout.fields().count()).filter_map(|i| {\n-                let field = layout.field(cx, i);\n-                // Also checking `align == 1` here leads to test failures in\n-                // `layout/zero-sized-array-union.rs`, where a type has a zero-size field with\n-                // alignment 4 that still gets ignored during layout computation (which is okay\n-                // since other fields already force alignment 4).\n-                let zst = field.is_zst();\n-                (!zst).then(|| (layout.fields.offset(i), field))\n-            })\n-        }\n+    if !cfg!(debug_assertions) {\n+        // Stop here, the rest is kind of expensive.\n+        return;\n+    }\n \n-        fn skip_newtypes<'tcx>(\n-            cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n-            layout: &TyAndLayout<'tcx>,\n-        ) -> TyAndLayout<'tcx> {\n-            if matches!(layout.layout.variants(), Variants::Multiple { .. }) {\n-                // Definitely not a newtype of anything.\n-                return *layout;\n-            }\n-            let mut fields = non_zst_fields(cx, layout);\n-            let Some(first) = fields.next() else {\n-                // No fields here, so this could be a primitive or enum -- either way it's not a newtype around a thing\n-                return *layout\n-            };\n-            if fields.next().is_none() {\n-                let (offset, first) = first;\n-                if offset == Size::ZERO && first.layout.size() == layout.size {\n-                    // This is a newtype, so keep recursing.\n-                    // FIXME(RalfJung): I don't think it would be correct to do any checks for\n-                    // alignment here, so we don't. Is that correct?\n-                    return skip_newtypes(cx, &first);\n-                }\n+    /// Yields non-ZST fields of the type\n+    fn non_zst_fields<'tcx, 'a>(\n+        cx: &'a LayoutCx<'tcx, TyCtxt<'tcx>>,\n+        layout: &'a TyAndLayout<'tcx>,\n+    ) -> impl Iterator<Item = (Size, TyAndLayout<'tcx>)> + 'a {\n+        (0..layout.layout.fields().count()).filter_map(|i| {\n+            let field = layout.field(cx, i);\n+            // Also checking `align == 1` here leads to test failures in\n+            // `layout/zero-sized-array-union.rs`, where a type has a zero-size field with\n+            // alignment 4 that still gets ignored during layout computation (which is okay\n+            // since other fields already force alignment 4).\n+            let zst = field.is_zst();\n+            (!zst).then(|| (layout.fields.offset(i), field))\n+        })\n+    }\n+\n+    fn skip_newtypes<'tcx>(\n+        cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+        layout: &TyAndLayout<'tcx>,\n+    ) -> TyAndLayout<'tcx> {\n+        if matches!(layout.layout.variants(), Variants::Multiple { .. }) {\n+            // Definitely not a newtype of anything.\n+            return *layout;\n+        }\n+        let mut fields = non_zst_fields(cx, layout);\n+        let Some(first) = fields.next() else {\n+            // No fields here, so this could be a primitive or enum -- either way it's not a newtype around a thing\n+            return *layout\n+        };\n+        if fields.next().is_none() {\n+            let (offset, first) = first;\n+            if offset == Size::ZERO && first.layout.size() == layout.size {\n+                // This is a newtype, so keep recursing.\n+                // FIXME(RalfJung): I don't think it would be correct to do any checks for\n+                // alignment here, so we don't. Is that correct?\n+                return skip_newtypes(cx, &first);\n             }\n-            // No more newtypes here.\n-            *layout\n         }\n+        // No more newtypes here.\n+        *layout\n+    }\n \n-        fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n-            match layout.layout.abi() {\n-                Abi::Scalar(scalar) => {\n-                    // No padding in scalars.\n-                    let size = scalar.size(cx);\n-                    let align = scalar.align(cx).abi;\n-                    assert_eq!(\n-                        layout.layout.size(),\n-                        size,\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    assert_eq!(\n-                        layout.layout.align().abi,\n-                        align,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    // Check that this matches the underlying field.\n-                    let inner = skip_newtypes(cx, layout);\n-                    assert!(\n-                        matches!(inner.layout.abi(), Abi::Scalar(_)),\n-                        \"`Scalar` type {} is newtype around non-`Scalar` type {}\",\n-                        layout.ty,\n-                        inner.ty\n-                    );\n-                    match inner.layout.fields() {\n-                        FieldsShape::Primitive => {\n-                            // Fine.\n-                        }\n-                        FieldsShape::Union(..) => {\n-                            // FIXME: I guess we could also check something here? Like, look at all fields?\n-                            return;\n-                        }\n-                        FieldsShape::Arbitrary { .. } => {\n-                            // Should be an enum, the only field is the discriminant.\n-                            assert!(\n-                                inner.ty.is_enum(),\n-                                \"`Scalar` layout for non-primitive non-enum type {}\",\n-                                inner.ty\n-                            );\n-                            assert_eq!(\n-                                inner.layout.fields().count(),\n-                                1,\n-                                \"`Scalar` layout for multiple-field type in {inner:#?}\",\n-                            );\n-                            let offset = inner.layout.fields().offset(0);\n-                            let field = inner.field(cx, 0);\n-                            // The field should be at the right offset, and match the `scalar` layout.\n-                            assert_eq!(\n-                                offset,\n-                                Size::ZERO,\n-                                \"`Scalar` field at non-0 offset in {inner:#?}\",\n-                            );\n-                            assert_eq!(\n-                                field.size, size,\n-                                \"`Scalar` field with bad size in {inner:#?}\",\n-                            );\n-                            assert_eq!(\n-                                field.align.abi, align,\n-                                \"`Scalar` field with bad align in {inner:#?}\",\n-                            );\n-                            assert!(\n-                                matches!(field.abi, Abi::Scalar(_)),\n-                                \"`Scalar` field with bad ABI in {inner:#?}\",\n-                            );\n-                        }\n-                        _ => {\n-                            panic!(\"`Scalar` layout for non-primitive non-enum type {}\", inner.ty);\n-                        }\n+    fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n+        match layout.layout.abi() {\n+            Abi::Scalar(scalar) => {\n+                // No padding in scalars.\n+                let size = scalar.size(cx);\n+                let align = scalar.align(cx).abi;\n+                assert_eq!(\n+                    layout.layout.size(),\n+                    size,\n+                    \"size mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                assert_eq!(\n+                    layout.layout.align().abi,\n+                    align,\n+                    \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                // Check that this matches the underlying field.\n+                let inner = skip_newtypes(cx, layout);\n+                assert!(\n+                    matches!(inner.layout.abi(), Abi::Scalar(_)),\n+                    \"`Scalar` type {} is newtype around non-`Scalar` type {}\",\n+                    layout.ty,\n+                    inner.ty\n+                );\n+                match inner.layout.fields() {\n+                    FieldsShape::Primitive => {\n+                        // Fine.\n                     }\n-                }\n-                Abi::ScalarPair(scalar1, scalar2) => {\n-                    // Sanity-check scalar pairs. These are a bit more flexible and support\n-                    // padding, but we can at least ensure both fields actually fit into the layout\n-                    // and the alignment requirement has not been weakened.\n-                    let size1 = scalar1.size(cx);\n-                    let align1 = scalar1.align(cx).abi;\n-                    let size2 = scalar2.size(cx);\n-                    let align2 = scalar2.align(cx).abi;\n-                    assert!(\n-                        layout.layout.align().abi >= cmp::max(align1, align2),\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\",\n-                    );\n-                    let field2_offset = size1.align_to(align2);\n-                    assert!(\n-                        layout.layout.size() >= field2_offset + size2,\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    // Check that the underlying pair of fields matches.\n-                    let inner = skip_newtypes(cx, layout);\n-                    assert!(\n-                        matches!(inner.layout.abi(), Abi::ScalarPair(..)),\n-                        \"`ScalarPair` type {} is newtype around non-`ScalarPair` type {}\",\n-                        layout.ty,\n-                        inner.ty\n-                    );\n-                    if matches!(inner.layout.variants(), Variants::Multiple { .. }) {\n-                        // FIXME: ScalarPair for enums is enormously complicated and it is very hard\n-                        // to check anything about them.\n+                    FieldsShape::Union(..) => {\n+                        // FIXME: I guess we could also check something here? Like, look at all fields?\n                         return;\n                     }\n-                    match inner.layout.fields() {\n-                        FieldsShape::Arbitrary { .. } => {\n-                            // Checked below.\n-                        }\n-                        FieldsShape::Union(..) => {\n-                            // FIXME: I guess we could also check something here? Like, look at all fields?\n-                            return;\n-                        }\n-                        _ => {\n-                            panic!(\"`ScalarPair` layout with unexpected field shape in {inner:#?}\");\n-                        }\n+                    FieldsShape::Arbitrary { .. } => {\n+                        // Should be an enum, the only field is the discriminant.\n+                        assert!(\n+                            inner.ty.is_enum(),\n+                            \"`Scalar` layout for non-primitive non-enum type {}\",\n+                            inner.ty\n+                        );\n+                        assert_eq!(\n+                            inner.layout.fields().count(),\n+                            1,\n+                            \"`Scalar` layout for multiple-field type in {inner:#?}\",\n+                        );\n+                        let offset = inner.layout.fields().offset(0);\n+                        let field = inner.field(cx, 0);\n+                        // The field should be at the right offset, and match the `scalar` layout.\n+                        assert_eq!(\n+                            offset,\n+                            Size::ZERO,\n+                            \"`Scalar` field at non-0 offset in {inner:#?}\",\n+                        );\n+                        assert_eq!(field.size, size, \"`Scalar` field with bad size in {inner:#?}\",);\n+                        assert_eq!(\n+                            field.align.abi, align,\n+                            \"`Scalar` field with bad align in {inner:#?}\",\n+                        );\n+                        assert!(\n+                            matches!(field.abi, Abi::Scalar(_)),\n+                            \"`Scalar` field with bad ABI in {inner:#?}\",\n+                        );\n+                    }\n+                    _ => {\n+                        panic!(\"`Scalar` layout for non-primitive non-enum type {}\", inner.ty);\n                     }\n-                    let mut fields = non_zst_fields(cx, &inner);\n-                    let (offset1, field1) = fields.next().unwrap_or_else(|| {\n-                        panic!(\"`ScalarPair` layout for type with not even one non-ZST field: {inner:#?}\")\n-                    });\n-                    let (offset2, field2) = fields.next().unwrap_or_else(|| {\n-                        panic!(\"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\")\n-                    });\n-                    assert!(\n-                        fields.next().is_none(),\n-                        \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n-                    );\n-                    // The fields might be in opposite order.\n-                    let (offset1, field1, offset2, field2) = if offset1 <= offset2 {\n-                        (offset1, field1, offset2, field2)\n-                    } else {\n-                        (offset2, field2, offset1, field1)\n-                    };\n-                    // The fields should be at the right offset, and match the `scalar` layout.\n-                    assert_eq!(\n-                        offset1,\n-                        Size::ZERO,\n-                        \"`ScalarPair` first field at non-0 offset in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field1.size, size1,\n-                        \"`ScalarPair` first field with bad size in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field1.align.abi, align1,\n-                        \"`ScalarPair` first field with bad align in {inner:#?}\",\n-                    );\n-                    assert!(\n-                        matches!(field1.abi, Abi::Scalar(_)),\n-                        \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        offset2, field2_offset,\n-                        \"`ScalarPair` second field at bad offset in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field2.size, size2,\n-                        \"`ScalarPair` second field with bad size in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field2.align.abi, align2,\n-                        \"`ScalarPair` second field with bad align in {inner:#?}\",\n-                    );\n-                    assert!(\n-                        matches!(field2.abi, Abi::Scalar(_)),\n-                        \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n-                    );\n                 }\n-                Abi::Vector { count, element } => {\n-                    // No padding in vectors. Alignment can be strengthened, though.\n-                    assert!(\n-                        layout.layout.align().abi >= element.align(cx).abi,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    let size = element.size(cx) * count;\n-                    assert_eq!(\n-                        layout.layout.size(),\n-                        size.align_to(cx.data_layout().vector_align(size).abi),\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n+            }\n+            Abi::ScalarPair(scalar1, scalar2) => {\n+                // Sanity-check scalar pairs. Computing the expected size and alignment is a bit of work.\n+                let size1 = scalar1.size(cx);\n+                let align1 = scalar1.align(cx).abi;\n+                let size2 = scalar2.size(cx);\n+                let align2 = scalar2.align(cx).abi;\n+                let align = cmp::max(align1, align2);\n+                let field2_offset = size1.align_to(align2);\n+                let size = (field2_offset + size2).align_to(align);\n+                assert_eq!(\n+                    layout.layout.size(),\n+                    size,\n+                    \"size mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                assert_eq!(\n+                    layout.layout.align().abi,\n+                    align,\n+                    \"alignment mismatch between ABI and layout in {layout:#?}\",\n+                );\n+                // Check that the underlying pair of fields matches.\n+                let inner = skip_newtypes(cx, layout);\n+                assert!(\n+                    matches!(inner.layout.abi(), Abi::ScalarPair(..)),\n+                    \"`ScalarPair` type {} is newtype around non-`ScalarPair` type {}\",\n+                    layout.ty,\n+                    inner.ty\n+                );\n+                if matches!(inner.layout.variants(), Variants::Multiple { .. }) {\n+                    // FIXME: ScalarPair for enums is enormously complicated and it is very hard\n+                    // to check anything about them.\n+                    return;\n+                }\n+                match inner.layout.fields() {\n+                    FieldsShape::Arbitrary { .. } => {\n+                        // Checked below.\n+                    }\n+                    FieldsShape::Union(..) => {\n+                        // FIXME: I guess we could also check something here? Like, look at all fields?\n+                        return;\n+                    }\n+                    _ => {\n+                        panic!(\"`ScalarPair` layout with unexpected field shape in {inner:#?}\");\n+                    }\n                 }\n-                Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n+                let mut fields = non_zst_fields(cx, &inner);\n+                let (offset1, field1) = fields.next().unwrap_or_else(|| {\n+                    panic!(\n+                        \"`ScalarPair` layout for type with not even one non-ZST field: {inner:#?}\"\n+                    )\n+                });\n+                let (offset2, field2) = fields.next().unwrap_or_else(|| {\n+                    panic!(\n+                        \"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\"\n+                    )\n+                });\n+                assert!(\n+                    fields.next().is_none(),\n+                    \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n+                );\n+                // The fields might be in opposite order.\n+                let (offset1, field1, offset2, field2) = if offset1 <= offset2 {\n+                    (offset1, field1, offset2, field2)\n+                } else {\n+                    (offset2, field2, offset1, field1)\n+                };\n+                // The fields should be at the right offset, and match the `scalar` layout.\n+                assert_eq!(\n+                    offset1,\n+                    Size::ZERO,\n+                    \"`ScalarPair` first field at non-0 offset in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field1.size, size1,\n+                    \"`ScalarPair` first field with bad size in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field1.align.abi, align1,\n+                    \"`ScalarPair` first field with bad align in {inner:#?}\",\n+                );\n+                assert!(\n+                    matches!(field1.abi, Abi::Scalar(_)),\n+                    \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    offset2, field2_offset,\n+                    \"`ScalarPair` second field at bad offset in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field2.size, size2,\n+                    \"`ScalarPair` second field with bad size in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field2.align.abi, align2,\n+                    \"`ScalarPair` second field with bad align in {inner:#?}\",\n+                );\n+                assert!(\n+                    matches!(field2.abi, Abi::Scalar(_)),\n+                    \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n+                );\n             }\n+            Abi::Vector { count, element } => {\n+                // No padding in vectors, except possibly for trailing padding to make the size a multiple of align.\n+                let size = element.size(cx) * count;\n+                let align = cx.data_layout().vector_align(size).abi;\n+                let size = size.align_to(align); // needed e.g. for vectors of size 3\n+                assert!(align >= element.align(cx).abi); // just sanity-checking `vector_align`.\n+                assert_eq!(\n+                    layout.layout.size(),\n+                    size,\n+                    \"size mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                assert_eq!(\n+                    layout.layout.align().abi,\n+                    align,\n+                    \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                // FIXME: Do some kind of check of the inner type, like for Scalar and ScalarPair.\n+            }\n+            Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n         }\n+    }\n \n-        check_layout_abi(cx, layout);\n+    check_layout_abi(cx, layout);\n \n-        if let Variants::Multiple { variants, .. } = &layout.variants {\n-            for variant in variants.iter() {\n-                // No nested \"multiple\".\n-                assert!(matches!(variant.variants, Variants::Single { .. }));\n-                // Variants should have the same or a smaller size as the full thing,\n-                // and same for alignment.\n-                if variant.size > layout.size {\n-                    bug!(\n-                        \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n-                        layout.size.bytes(),\n-                        variant.size.bytes(),\n-                    )\n-                }\n-                if variant.align.abi > layout.align.abi {\n-                    bug!(\n-                        \"Type with alignment {} bytes has variant with alignment {} bytes: {layout:#?}\",\n-                        layout.align.abi.bytes(),\n-                        variant.align.abi.bytes(),\n-                    )\n-                }\n-                // Skip empty variants.\n-                if variant.size == Size::ZERO\n-                    || variant.fields.count() == 0\n-                    || variant.abi.is_uninhabited()\n-                {\n-                    // These are never actually accessed anyway, so we can skip the coherence check\n-                    // for them. They also fail that check, since they have\n-                    // `Aggregate`/`Uninhbaited` ABI even when the main type is\n-                    // `Scalar`/`ScalarPair`. (Note that sometimes, variants with fields have size\n-                    // 0, and sometimes, variants without fields have non-0 size.)\n-                    continue;\n-                }\n-                // The top-level ABI and the ABI of the variants should be coherent.\n-                let scalar_coherent = |s1: Scalar, s2: Scalar| {\n-                    s1.size(cx) == s2.size(cx) && s1.align(cx) == s2.align(cx)\n-                };\n-                let abi_coherent = match (layout.abi, variant.abi) {\n-                    (Abi::Scalar(s1), Abi::Scalar(s2)) => scalar_coherent(s1, s2),\n-                    (Abi::ScalarPair(a1, b1), Abi::ScalarPair(a2, b2)) => {\n-                        scalar_coherent(a1, a2) && scalar_coherent(b1, b2)\n-                    }\n-                    (Abi::Uninhabited, _) => true,\n-                    (Abi::Aggregate { .. }, _) => true,\n-                    _ => false,\n-                };\n-                if !abi_coherent {\n-                    bug!(\n-                        \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n-                        variant\n-                    );\n+    if let Variants::Multiple { variants, .. } = &layout.variants {\n+        for variant in variants.iter() {\n+            // No nested \"multiple\".\n+            assert!(matches!(variant.variants, Variants::Single { .. }));\n+            // Variants should have the same or a smaller size as the full thing,\n+            // and same for alignment.\n+            if variant.size > layout.size {\n+                bug!(\n+                    \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n+                    layout.size.bytes(),\n+                    variant.size.bytes(),\n+                )\n+            }\n+            if variant.align.abi > layout.align.abi {\n+                bug!(\n+                    \"Type with alignment {} bytes has variant with alignment {} bytes: {layout:#?}\",\n+                    layout.align.abi.bytes(),\n+                    variant.align.abi.bytes(),\n+                )\n+            }\n+            // Skip empty variants.\n+            if variant.size == Size::ZERO\n+                || variant.fields.count() == 0\n+                || variant.abi.is_uninhabited()\n+            {\n+                // These are never actually accessed anyway, so we can skip the coherence check\n+                // for them. They also fail that check, since they have\n+                // `Aggregate`/`Uninhbaited` ABI even when the main type is\n+                // `Scalar`/`ScalarPair`. (Note that sometimes, variants with fields have size\n+                // 0, and sometimes, variants without fields have non-0 size.)\n+                continue;\n+            }\n+            // The top-level ABI and the ABI of the variants should be coherent.\n+            let scalar_coherent =\n+                |s1: Scalar, s2: Scalar| s1.size(cx) == s2.size(cx) && s1.align(cx) == s2.align(cx);\n+            let abi_coherent = match (layout.abi, variant.abi) {\n+                (Abi::Scalar(s1), Abi::Scalar(s2)) => scalar_coherent(s1, s2),\n+                (Abi::ScalarPair(a1, b1), Abi::ScalarPair(a2, b2)) => {\n+                    scalar_coherent(a1, a2) && scalar_coherent(b1, b2)\n                 }\n+                (Abi::Uninhabited, _) => true,\n+                (Abi::Aggregate { .. }, _) => true,\n+                _ => false,\n+            };\n+            if !abi_coherent {\n+                bug!(\n+                    \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n+                    variant\n+                );\n             }\n         }\n     }"}, {"sha": "89feb361ddc116d2885e7c948ced45a27af6a211", "filename": "library/alloc/src/collections/vec_deque/drain.rs", "status": "modified", "additions": 128, "deletions": 65, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,12 +1,12 @@\n-use core::fmt;\n use core::iter::FusedIterator;\n use core::marker::PhantomData;\n-use core::mem::{self, MaybeUninit};\n-use core::ptr::{self, NonNull};\n+use core::mem::{self, SizedTypeProperties};\n+use core::ptr::NonNull;\n+use core::{fmt, ptr};\n \n use crate::alloc::{Allocator, Global};\n \n-use super::{count, wrap_index, VecDeque};\n+use super::VecDeque;\n \n /// A draining iterator over the elements of a `VecDeque`.\n ///\n@@ -20,38 +20,81 @@ pub struct Drain<\n     T: 'a,\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n > {\n-    after_tail: usize,\n-    after_head: usize,\n-    ring: NonNull<[T]>,\n-    tail: usize,\n-    head: usize,\n+    // We can't just use a &mut VecDeque<T, A>, as that would make Drain invariant over T\n+    // and we want it to be covariant instead\n     deque: NonNull<VecDeque<T, A>>,\n-    _phantom: PhantomData<&'a T>,\n+    // drain_start is stored in deque.len\n+    drain_len: usize,\n+    // index into the logical array, not the physical one (always lies in [0..deque.len))\n+    idx: usize,\n+    // number of elements after the drain range\n+    tail_len: usize,\n+    remaining: usize,\n+    // Needed to make Drain covariant over T\n+    _marker: PhantomData<&'a T>,\n }\n \n impl<'a, T, A: Allocator> Drain<'a, T, A> {\n     pub(super) unsafe fn new(\n-        after_tail: usize,\n-        after_head: usize,\n-        ring: &'a [MaybeUninit<T>],\n-        tail: usize,\n-        head: usize,\n-        deque: NonNull<VecDeque<T, A>>,\n+        deque: &'a mut VecDeque<T, A>,\n+        drain_start: usize,\n+        drain_len: usize,\n     ) -> Self {\n-        let ring = unsafe { NonNull::new_unchecked(ring as *const [MaybeUninit<T>] as *mut _) };\n-        Drain { after_tail, after_head, ring, tail, head, deque, _phantom: PhantomData }\n+        let orig_len = mem::replace(&mut deque.len, drain_start);\n+        let tail_len = orig_len - drain_start - drain_len;\n+        Drain {\n+            deque: NonNull::from(deque),\n+            drain_len,\n+            idx: drain_start,\n+            tail_len,\n+            remaining: drain_len,\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    // Only returns pointers to the slices, as that's\n+    // all we need to drop them. May only be called if `self.remaining != 0`.\n+    unsafe fn as_slices(&self) -> (*mut [T], *mut [T]) {\n+        unsafe {\n+            let deque = self.deque.as_ref();\n+            // FIXME: This is doing almost exactly the same thing as the else branch in `VecDeque::slice_ranges`.\n+            // Unfortunately, we can't just call `slice_ranges` here, as the deque's `len` is currently\n+            // just `drain_start`, so the range check would (almost) always panic. Between temporarily\n+            // adjusting the deques `len` to call `slice_ranges`, and just copy pasting the `slice_ranges`\n+            // implementation, this seemed like the less hacky solution, though it might be good to\n+            // find a better one in the future.\n+\n+            // because `self.remaining != 0`, we know that `self.idx < deque.original_len`, so it's a valid\n+            // logical index.\n+            let wrapped_start = deque.to_physical_idx(self.idx);\n+\n+            let head_len = deque.capacity() - wrapped_start;\n+\n+            let (a_range, b_range) = if head_len >= self.remaining {\n+                (wrapped_start..wrapped_start + self.remaining, 0..0)\n+            } else {\n+                let tail_len = self.remaining - head_len;\n+                (wrapped_start..deque.capacity(), 0..tail_len)\n+            };\n+\n+            // SAFETY: the range `self.idx..self.idx+self.remaining` lies strictly inside\n+            // the range `0..deque.original_len`. because of this, and because of the fact\n+            // that we acquire `a_range` and `b_range` exactly like `slice_ranges` would,\n+            // it's guaranteed that `a_range` and `b_range` represent valid ranges into\n+            // the deques buffer.\n+            (deque.buffer_range(a_range), deque.buffer_range(b_range))\n+        }\n     }\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Drain\")\n-            .field(&self.after_tail)\n-            .field(&self.after_head)\n-            .field(&self.ring)\n-            .field(&self.tail)\n-            .field(&self.head)\n+            .field(&self.drain_len)\n+            .field(&self.idx)\n+            .field(&self.tail_len)\n+            .field(&self.remaining)\n             .finish()\n     }\n }\n@@ -68,57 +111,81 @@ impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n \n         impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n             fn drop(&mut self) {\n-                self.0.for_each(drop);\n+                if self.0.remaining != 0 {\n+                    unsafe {\n+                        // SAFETY: We just checked that `self.remaining != 0`.\n+                        let (front, back) = self.0.as_slices();\n+                        ptr::drop_in_place(front);\n+                        ptr::drop_in_place(back);\n+                    }\n+                }\n \n                 let source_deque = unsafe { self.0.deque.as_mut() };\n \n-                // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n-                //\n-                //        T   t   h   H\n-                // [. . . o o x x o o . . .]\n-                //\n-                let orig_tail = source_deque.tail;\n-                let drain_tail = source_deque.head;\n-                let drain_head = self.0.after_tail;\n-                let orig_head = self.0.after_head;\n+                let drain_start = source_deque.len();\n+                let drain_len = self.0.drain_len;\n+                let drain_end = drain_start + drain_len;\n+\n+                let orig_len = self.0.tail_len + drain_end;\n \n-                let tail_len = count(orig_tail, drain_tail, source_deque.cap());\n-                let head_len = count(drain_head, orig_head, source_deque.cap());\n+                if T::IS_ZST {\n+                    // no need to copy around any memory if T is a ZST\n+                    source_deque.len = orig_len - drain_len;\n+                    return;\n+                }\n \n-                // Restore the original head value\n-                source_deque.head = orig_head;\n+                let head_len = drain_start;\n+                let tail_len = self.0.tail_len;\n \n-                match (tail_len, head_len) {\n+                match (head_len, tail_len) {\n                     (0, 0) => {\n                         source_deque.head = 0;\n-                        source_deque.tail = 0;\n+                        source_deque.len = 0;\n                     }\n                     (0, _) => {\n-                        source_deque.tail = drain_head;\n+                        source_deque.head = source_deque.to_physical_idx(drain_len);\n+                        source_deque.len = orig_len - drain_len;\n                     }\n                     (_, 0) => {\n-                        source_deque.head = drain_tail;\n+                        source_deque.len = orig_len - drain_len;\n                     }\n                     _ => unsafe {\n-                        if tail_len <= head_len {\n-                            source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n-                            source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n+                        if head_len <= tail_len {\n+                            source_deque.wrap_copy(\n+                                source_deque.head,\n+                                source_deque.to_physical_idx(drain_len),\n+                                head_len,\n+                            );\n+                            source_deque.head = source_deque.to_physical_idx(drain_len);\n+                            source_deque.len = orig_len - drain_len;\n                         } else {\n-                            source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n-                            source_deque.wrap_copy(drain_tail, drain_head, head_len);\n+                            source_deque.wrap_copy(\n+                                source_deque.to_physical_idx(head_len + drain_len),\n+                                source_deque.to_physical_idx(head_len),\n+                                tail_len,\n+                            );\n+                            source_deque.len = orig_len - drain_len;\n                         }\n                     },\n                 }\n             }\n         }\n \n-        while let Some(item) = self.next() {\n-            let guard = DropGuard(self);\n-            drop(item);\n-            mem::forget(guard);\n+        let guard = DropGuard(self);\n+        if guard.0.remaining != 0 {\n+            unsafe {\n+                // SAFETY: We just checked that `self.remaining != 0`.\n+                let (front, back) = guard.0.as_slices();\n+                // since idx is a logical index, we don't need to worry about wrapping.\n+                guard.0.idx += front.len();\n+                guard.0.remaining -= front.len();\n+                ptr::drop_in_place(front);\n+                guard.0.remaining = 0;\n+                ptr::drop_in_place(back);\n+            }\n         }\n \n-        DropGuard(self);\n+        // Dropping `guard` handles moving the remaining elements into place.\n     }\n }\n \n@@ -128,20 +195,18 @@ impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        if self.tail == self.head {\n+        if self.remaining == 0 {\n             return None;\n         }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n-        // Safety:\n-        // - `self.tail` in a ring buffer is always a valid index.\n-        // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(ptr::read(self.ring.as_ptr().get_unchecked_mut(tail))) }\n+        let wrapped_idx = unsafe { self.deque.as_ref().to_physical_idx(self.idx) };\n+        self.idx += 1;\n+        self.remaining -= 1;\n+        Some(unsafe { self.deque.as_mut().buffer_read(wrapped_idx) })\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = count(self.tail, self.head, self.ring.len());\n+        let len = self.remaining;\n         (len, Some(len))\n     }\n }\n@@ -150,14 +215,12 @@ impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n-        if self.tail == self.head {\n+        if self.remaining == 0 {\n             return None;\n         }\n-        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n-        // Safety:\n-        // - `self.head` in a ring buffer is always a valid index.\n-        // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(ptr::read(self.ring.as_ptr().get_unchecked_mut(self.head))) }\n+        self.remaining -= 1;\n+        let wrapped_idx = unsafe { self.deque.as_ref().to_physical_idx(self.idx + self.remaining) };\n+        Some(unsafe { self.deque.as_mut().buffer_read(wrapped_idx) })\n     }\n }\n "}, {"sha": "d9f3937144d04c0c9d51ba7c3e9f2b1729679f86", "filename": "library/alloc/src/collections/vec_deque/iter.rs", "status": "modified", "additions": 70, "deletions": 108, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,9 +1,6 @@\n-use core::fmt;\n use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n-use core::mem::MaybeUninit;\n use core::ops::Try;\n-\n-use super::{count, wrap_index, RingSlices};\n+use core::{fmt, mem, slice};\n \n /// An iterator over the elements of a `VecDeque`.\n ///\n@@ -13,38 +10,28 @@ use super::{count, wrap_index, RingSlices};\n /// [`iter`]: super::VecDeque::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    ring: &'a [MaybeUninit<T>],\n-    tail: usize,\n-    head: usize,\n+    i1: slice::Iter<'a, T>,\n+    i2: slice::Iter<'a, T>,\n }\n \n impl<'a, T> Iter<'a, T> {\n-    pub(super) fn new(ring: &'a [MaybeUninit<T>], tail: usize, head: usize) -> Self {\n-        Iter { ring, tail, head }\n+    pub(super) fn new(i1: slice::Iter<'a, T>, i2: slice::Iter<'a, T>) -> Self {\n+        Self { i1, i2 }\n     }\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            f.debug_tuple(\"Iter\")\n-                .field(&MaybeUninit::slice_assume_init_ref(front))\n-                .field(&MaybeUninit::slice_assume_init_ref(back))\n-                .finish()\n-        }\n+        f.debug_tuple(\"Iter\").field(&self.i1.as_slice()).field(&self.i2.as_slice()).finish()\n     }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Iter<'_, T> {\n     fn clone(&self) -> Self {\n-        Iter { ring: self.ring, tail: self.tail, head: self.head }\n+        Iter { i1: self.i1.clone(), i2: self.i2.clone() }\n     }\n }\n \n@@ -54,72 +41,50 @@ impl<'a, T> Iterator for Iter<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n-        if self.tail == self.head {\n-            return None;\n+        match self.i1.next() {\n+            Some(val) => Some(val),\n+            None => {\n+                // most of the time, the iterator will either always\n+                // call next(), or always call next_back(). By swapping\n+                // the iterators once the first one is empty, we ensure\n+                // that the first branch is taken as often as possible,\n+                // without sacrificing correctness, as i1 is empty anyways\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i1.next()\n+            }\n         }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n-        // Safety:\n-        // - `self.tail` in a ring buffer is always a valid index.\n-        // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(self.ring.get_unchecked(tail).assume_init_ref()) }\n+    }\n+\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let m = match self.i1.advance_by(n) {\n+            Ok(_) => return Ok(()),\n+            Err(m) => m,\n+        };\n+        mem::swap(&mut self.i1, &mut self.i2);\n+        self.i1.advance_by(n - m).map_err(|o| o + m)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = count(self.tail, self.head, self.ring.len());\n+        let len = self.len();\n         (len, Some(len))\n     }\n \n-    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, accum: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            accum = MaybeUninit::slice_assume_init_ref(front).iter().fold(accum, &mut f);\n-            MaybeUninit::slice_assume_init_ref(back).iter().fold(accum, &mut f)\n-        }\n+        let accum = self.i1.fold(accum, &mut f);\n+        self.i2.fold(accum, &mut f)\n     }\n \n     fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n     where\n-        Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n-        let (mut iter, final_res);\n-        if self.tail <= self.head {\n-            // Safety: single slice self.ring[self.tail..self.head] is initialized.\n-            iter = unsafe { MaybeUninit::slice_assume_init_ref(&self.ring[self.tail..self.head]) }\n-                .iter();\n-            final_res = iter.try_fold(init, &mut f);\n-        } else {\n-            // Safety: two slices: self.ring[self.tail..], self.ring[..self.head] both are initialized.\n-            let (front, back) = self.ring.split_at(self.tail);\n-\n-            let mut back_iter = unsafe { MaybeUninit::slice_assume_init_ref(back).iter() };\n-            let res = back_iter.try_fold(init, &mut f);\n-            let len = self.ring.len();\n-            self.tail = (self.ring.len() - back_iter.len()) & (len - 1);\n-            iter = unsafe { MaybeUninit::slice_assume_init_ref(&front[..self.head]).iter() };\n-            final_res = iter.try_fold(res?, &mut f);\n-        }\n-        self.tail = self.head - iter.len();\n-        final_res\n-    }\n-\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        if n >= count(self.tail, self.head, self.ring.len()) {\n-            self.tail = self.head;\n-            None\n-        } else {\n-            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n-            self.next()\n-        }\n+        let acc = self.i1.try_fold(init, &mut f)?;\n+        self.i2.try_fold(acc, &mut f)\n     }\n \n     #[inline]\n@@ -132,8 +97,12 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         // Safety: The TrustedRandomAccess contract requires that callers only pass an index\n         // that is in bounds.\n         unsafe {\n-            let idx = wrap_index(self.tail.wrapping_add(idx), self.ring.len());\n-            self.ring.get_unchecked(idx).assume_init_ref()\n+            let i1_len = self.i1.len();\n+            if idx < i1_len {\n+                self.i1.__iterator_get_unchecked(idx)\n+            } else {\n+                self.i2.__iterator_get_unchecked(idx - i1_len)\n+            }\n         }\n     }\n }\n@@ -142,63 +111,56 @@ impl<'a, T> Iterator for Iter<'a, T> {\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n-        if self.tail == self.head {\n-            return None;\n+        match self.i2.next_back() {\n+            Some(val) => Some(val),\n+            None => {\n+                // most of the time, the iterator will either always\n+                // call next(), or always call next_back(). By swapping\n+                // the iterators once the second one is empty, we ensure\n+                // that the first branch is taken as often as possible,\n+                // without sacrificing correctness, as i2 is empty anyways\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i2.next_back()\n+            }\n         }\n-        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n-        // Safety:\n-        // - `self.head` in a ring buffer is always a valid index.\n-        // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(self.ring.get_unchecked(self.head).assume_init_ref()) }\n     }\n \n-    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let m = match self.i2.advance_back_by(n) {\n+            Ok(_) => return Ok(()),\n+            Err(m) => m,\n+        };\n+\n+        mem::swap(&mut self.i1, &mut self.i2);\n+        self.i2.advance_back_by(n - m).map_err(|o| m + o)\n+    }\n+\n+    fn rfold<Acc, F>(self, accum: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            accum = MaybeUninit::slice_assume_init_ref(back).iter().rfold(accum, &mut f);\n-            MaybeUninit::slice_assume_init_ref(front).iter().rfold(accum, &mut f)\n-        }\n+        let accum = self.i2.rfold(accum, &mut f);\n+        self.i1.rfold(accum, &mut f)\n     }\n \n     fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n     where\n-        Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n-        let (mut iter, final_res);\n-        if self.tail <= self.head {\n-            // Safety: single slice self.ring[self.tail..self.head] is initialized.\n-            iter = unsafe {\n-                MaybeUninit::slice_assume_init_ref(&self.ring[self.tail..self.head]).iter()\n-            };\n-            final_res = iter.try_rfold(init, &mut f);\n-        } else {\n-            // Safety: two slices: self.ring[self.tail..], self.ring[..self.head] both are initialized.\n-            let (front, back) = self.ring.split_at(self.tail);\n-\n-            let mut front_iter =\n-                unsafe { MaybeUninit::slice_assume_init_ref(&front[..self.head]).iter() };\n-            let res = front_iter.try_rfold(init, &mut f);\n-            self.head = front_iter.len();\n-            iter = unsafe { MaybeUninit::slice_assume_init_ref(back).iter() };\n-            final_res = iter.try_rfold(res?, &mut f);\n-        }\n-        self.head = self.tail + iter.len();\n-        final_res\n+        let acc = self.i2.try_rfold(init, &mut f)?;\n+        self.i1.try_rfold(acc, &mut f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for Iter<'_, T> {\n+    fn len(&self) -> usize {\n+        self.i1.len() + self.i2.len()\n+    }\n+\n     fn is_empty(&self) -> bool {\n-        self.head == self.tail\n+        self.i1.is_empty() && self.i2.is_empty()\n     }\n }\n "}, {"sha": "2c59d95cd53e9360101d312f477ea452dcd24e75", "filename": "library/alloc/src/collections/vec_deque/iter_mut.rs", "status": "modified", "additions": 80, "deletions": 69, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,8 +1,6 @@\n-use core::fmt;\n use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n-use core::marker::PhantomData;\n-\n-use super::{count, wrap_index, RingSlices};\n+use core::ops::Try;\n+use core::{fmt, mem, slice};\n \n /// A mutable iterator over the elements of a `VecDeque`.\n ///\n@@ -12,39 +10,20 @@ use super::{count, wrap_index, RingSlices};\n /// [`iter_mut`]: super::VecDeque::iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n-    // Internal safety invariant: the entire slice is dereferenceable.\n-    ring: *mut [T],\n-    tail: usize,\n-    head: usize,\n-    phantom: PhantomData<&'a mut [T]>,\n+    i1: slice::IterMut<'a, T>,\n+    i2: slice::IterMut<'a, T>,\n }\n \n impl<'a, T> IterMut<'a, T> {\n-    pub(super) unsafe fn new(\n-        ring: *mut [T],\n-        tail: usize,\n-        head: usize,\n-        phantom: PhantomData<&'a mut [T]>,\n-    ) -> Self {\n-        IterMut { ring, tail, head, phantom }\n+    pub(super) fn new(i1: slice::IterMut<'a, T>, i2: slice::IterMut<'a, T>) -> Self {\n+        Self { i1, i2 }\n     }\n }\n \n-// SAFETY: we do nothing thread-local and there is no interior mutability,\n-// so the usual structural `Send`/`Sync` apply.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for IterMut<'_, T> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n-\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferenceable.\n-        let (front, back) = unsafe { (&*front, &*back) };\n-        f.debug_tuple(\"IterMut\").field(&front).field(&back).finish()\n+        f.debug_tuple(\"IterMut\").field(&self.i1.as_slice()).field(&self.i2.as_slice()).finish()\n     }\n }\n \n@@ -54,44 +33,50 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> {\n-        if self.tail == self.head {\n-            return None;\n+        match self.i1.next() {\n+            Some(val) => Some(val),\n+            None => {\n+                // most of the time, the iterator will either always\n+                // call next(), or always call next_back(). By swapping\n+                // the iterators once the first one is empty, we ensure\n+                // that the first branch is taken as often as possible,\n+                // without sacrificing correctness, as i1 is empty anyways\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i1.next()\n+            }\n         }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n+    }\n \n-        unsafe {\n-            let elem = self.ring.get_unchecked_mut(tail);\n-            Some(&mut *elem)\n-        }\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let m = match self.i1.advance_by(n) {\n+            Ok(_) => return Ok(()),\n+            Err(m) => m,\n+        };\n+        mem::swap(&mut self.i1, &mut self.i2);\n+        self.i1.advance_by(n - m).map_err(|o| o + m)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = count(self.tail, self.head, self.ring.len());\n+        let len = self.len();\n         (len, Some(len))\n     }\n \n-    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, accum: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferenceable.\n-        let (front, back) = unsafe { (&mut *front, &mut *back) };\n-        accum = front.iter_mut().fold(accum, &mut f);\n-        back.iter_mut().fold(accum, &mut f)\n+        let accum = self.i1.fold(accum, &mut f);\n+        self.i2.fold(accum, &mut f)\n     }\n \n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        if n >= count(self.tail, self.head, self.ring.len()) {\n-            self.tail = self.head;\n-            None\n-        } else {\n-            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n-            self.next()\n-        }\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        let acc = self.i1.try_fold(init, &mut f)?;\n+        self.i2.try_fold(acc, &mut f)\n     }\n \n     #[inline]\n@@ -104,8 +89,12 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         // Safety: The TrustedRandomAccess contract requires that callers only pass an index\n         // that is in bounds.\n         unsafe {\n-            let idx = wrap_index(self.tail.wrapping_add(idx), self.ring.len());\n-            &mut *self.ring.get_unchecked_mut(idx)\n+            let i1_len = self.i1.len();\n+            if idx < i1_len {\n+                self.i1.__iterator_get_unchecked(idx)\n+            } else {\n+                self.i2.__iterator_get_unchecked(idx - i1_len)\n+            }\n         }\n     }\n }\n@@ -114,34 +103,56 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n-        if self.tail == self.head {\n-            return None;\n+        match self.i2.next_back() {\n+            Some(val) => Some(val),\n+            None => {\n+                // most of the time, the iterator will either always\n+                // call next(), or always call next_back(). By swapping\n+                // the iterators once the first one is empty, we ensure\n+                // that the first branch is taken as often as possible,\n+                // without sacrificing correctness, as i2 is empty anyways\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i2.next_back()\n+            }\n         }\n-        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n+    }\n \n-        unsafe {\n-            let elem = self.ring.get_unchecked_mut(self.head);\n-            Some(&mut *elem)\n-        }\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let m = match self.i2.advance_back_by(n) {\n+            Ok(_) => return Ok(()),\n+            Err(m) => m,\n+        };\n+\n+        mem::swap(&mut self.i1, &mut self.i2);\n+        self.i2.advance_back_by(n - m).map_err(|o| m + o)\n     }\n \n-    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    fn rfold<Acc, F>(self, accum: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferenceable.\n-        let (front, back) = unsafe { (&mut *front, &mut *back) };\n-        accum = back.iter_mut().rfold(accum, &mut f);\n-        front.iter_mut().rfold(accum, &mut f)\n+        let accum = self.i2.rfold(accum, &mut f);\n+        self.i1.rfold(accum, &mut f)\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        let acc = self.i2.try_rfold(init, &mut f)?;\n+        self.i1.try_rfold(acc, &mut f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IterMut<'_, T> {\n+    fn len(&self) -> usize {\n+        self.i1.len() + self.i2.len()\n+    }\n+\n     fn is_empty(&self) -> bool {\n-        self.head == self.tail\n+        self.i1.is_empty() && self.i2.is_empty()\n     }\n }\n "}, {"sha": "ee8032ad6f0f7fe770c5a83c3d171b75ab85f217", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 492, "deletions": 767, "changes": 1259, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -10,11 +10,10 @@\n use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::iter::{repeat_n, repeat_with, FromIterator};\n-use core::marker::PhantomData;\n-use core::mem::{ManuallyDrop, MaybeUninit, SizedTypeProperties};\n+use core::iter::{repeat_n, repeat_with, ByRefSized, FromIterator};\n+use core::mem::{ManuallyDrop, SizedTypeProperties};\n use core::ops::{Index, IndexMut, Range, RangeBounds};\n-use core::ptr::{self, NonNull};\n+use core::ptr;\n use core::slice;\n \n // This is used in a bunch of intra-doc links.\n@@ -52,26 +51,13 @@ pub use self::iter::Iter;\n \n mod iter;\n \n-use self::pair_slices::PairSlices;\n-\n-mod pair_slices;\n-\n-use self::ring_slices::RingSlices;\n-\n-mod ring_slices;\n-\n use self::spec_extend::SpecExtend;\n \n mod spec_extend;\n \n #[cfg(test)]\n mod tests;\n \n-const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n-const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n-\n-const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible power of two\n-\n /// A double-ended queue implemented with a growable ring buffer.\n ///\n /// The \"default\" usage of this type as a queue is to use [`push_back`] to add to\n@@ -105,13 +91,13 @@ pub struct VecDeque<\n     T,\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n > {\n-    // tail and head are pointers into the buffer. Tail always points\n-    // to the first element that could be read, Head always points\n-    // to where data should be written.\n-    // If tail == head the buffer is empty. The length of the ringbuffer\n-    // is defined as the distance between the two.\n-    tail: usize,\n+    // `self[0]`, if it exists, is `buf[head]`.\n+    // `head < buf.capacity()`, unless `buf.capacity() == 0` when `head == 0`.\n     head: usize,\n+    // the number of initialized elements, starting from the one at `head` and potentially wrapping around.\n+    // if `len == 0`, the exact value of `head` is unimportant.\n+    // if `T` is zero-Sized, then `self.len <= usize::MAX`, otherwise `self.len <= isize::MAX as usize`.\n+    len: usize,\n     buf: RawVec<T, A>,\n }\n \n@@ -124,18 +110,8 @@ impl<T: Clone, A: Allocator + Clone> Clone for VecDeque<T, A> {\n     }\n \n     fn clone_from(&mut self, other: &Self) {\n-        self.truncate(other.len());\n-\n-        let mut iter = PairSlices::from(self, other);\n-        while let Some((dst, src)) = iter.next() {\n-            dst.clone_from_slice(&src);\n-        }\n-\n-        if iter.has_remainder() {\n-            for remainder in iter.remainder() {\n-                self.extend(remainder.iter().cloned());\n-            }\n-        }\n+        self.clear();\n+        self.extend(other.iter().cloned());\n     }\n }\n \n@@ -180,41 +156,6 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.buf.ptr()\n     }\n \n-    /// Marginally more convenient\n-    #[inline]\n-    fn cap(&self) -> usize {\n-        if T::IS_ZST {\n-            // For zero sized types, we are always at maximum capacity\n-            MAXIMUM_ZST_CAPACITY\n-        } else {\n-            self.buf.capacity()\n-        }\n-    }\n-\n-    /// Turn ptr into a slice, since the elements of the backing buffer may be uninitialized,\n-    /// we will return a slice of [`MaybeUninit<T>`].\n-    ///\n-    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n-    /// incorrect usage of this method.\n-    ///\n-    /// [zeroed]: mem::MaybeUninit::zeroed\n-    #[inline]\n-    unsafe fn buffer_as_slice(&self) -> &[MaybeUninit<T>] {\n-        unsafe { slice::from_raw_parts(self.ptr() as *mut MaybeUninit<T>, self.cap()) }\n-    }\n-\n-    /// Turn ptr into a mut slice, since the elements of the backing buffer may be uninitialized,\n-    /// we will return a slice of [`MaybeUninit<T>`].\n-    ///\n-    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n-    /// incorrect usage of this method.\n-    ///\n-    /// [zeroed]: mem::MaybeUninit::zeroed\n-    #[inline]\n-    unsafe fn buffer_as_mut_slice(&mut self) -> &mut [MaybeUninit<T>] {\n-        unsafe { slice::from_raw_parts_mut(self.ptr() as *mut MaybeUninit<T>, self.cap()) }\n-    }\n-\n     /// Moves an element out of the buffer\n     #[inline]\n     unsafe fn buffer_read(&mut self, off: usize) -> T {\n@@ -229,51 +170,58 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Returns `true` if the buffer is at full capacity.\n+    /// Returns a slice pointer into the buffer.\n+    /// `range` must lie inside `0..self.capacity()`.\n     #[inline]\n-    fn is_full(&self) -> bool {\n-        self.cap() - self.len() == 1\n+    unsafe fn buffer_range(&self, range: Range<usize>) -> *mut [T] {\n+        unsafe {\n+            ptr::slice_from_raw_parts_mut(self.ptr().add(range.start), range.end - range.start)\n+        }\n     }\n \n-    /// Returns the index in the underlying buffer for a given logical element\n-    /// index.\n+    /// Returns `true` if the buffer is at full capacity.\n     #[inline]\n-    fn wrap_index(&self, idx: usize) -> usize {\n-        wrap_index(idx, self.cap())\n+    fn is_full(&self) -> bool {\n+        self.len == self.capacity()\n     }\n \n     /// Returns the index in the underlying buffer for a given logical element\n     /// index + addend.\n     #[inline]\n     fn wrap_add(&self, idx: usize, addend: usize) -> usize {\n-        wrap_index(idx.wrapping_add(addend), self.cap())\n+        wrap_index(idx.wrapping_add(addend), self.capacity())\n+    }\n+\n+    #[inline]\n+    fn to_physical_idx(&self, idx: usize) -> usize {\n+        self.wrap_add(self.head, idx)\n     }\n \n     /// Returns the index in the underlying buffer for a given logical element\n     /// index - subtrahend.\n     #[inline]\n     fn wrap_sub(&self, idx: usize, subtrahend: usize) -> usize {\n-        wrap_index(idx.wrapping_sub(subtrahend), self.cap())\n+        wrap_index(idx.wrapping_sub(subtrahend).wrapping_add(self.capacity()), self.capacity())\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n-    unsafe fn copy(&self, dst: usize, src: usize, len: usize) {\n+    unsafe fn copy(&mut self, src: usize, dst: usize, len: usize) {\n         debug_assert!(\n-            dst + len <= self.cap(),\n+            dst + len <= self.capacity(),\n             \"cpy dst={} src={} len={} cap={}\",\n             dst,\n             src,\n             len,\n-            self.cap()\n+            self.capacity()\n         );\n         debug_assert!(\n-            src + len <= self.cap(),\n+            src + len <= self.capacity(),\n             \"cpy dst={} src={} len={} cap={}\",\n             dst,\n             src,\n             len,\n-            self.cap()\n+            self.capacity()\n         );\n         unsafe {\n             ptr::copy(self.ptr().add(src), self.ptr().add(dst), len);\n@@ -282,53 +230,51 @@ impl<T, A: Allocator> VecDeque<T, A> {\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n-    unsafe fn copy_nonoverlapping(&self, dst: usize, src: usize, len: usize) {\n+    unsafe fn copy_nonoverlapping(&mut self, src: usize, dst: usize, len: usize) {\n         debug_assert!(\n-            dst + len <= self.cap(),\n+            dst + len <= self.capacity(),\n             \"cno dst={} src={} len={} cap={}\",\n             dst,\n             src,\n             len,\n-            self.cap()\n+            self.capacity()\n         );\n         debug_assert!(\n-            src + len <= self.cap(),\n+            src + len <= self.capacity(),\n             \"cno dst={} src={} len={} cap={}\",\n             dst,\n             src,\n             len,\n-            self.cap()\n+            self.capacity()\n         );\n         unsafe {\n             ptr::copy_nonoverlapping(self.ptr().add(src), self.ptr().add(dst), len);\n         }\n     }\n \n     /// Copies a potentially wrapping block of memory len long from src to dest.\n-    /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n+    /// (abs(dst - src) + len) must be no larger than capacity() (There must be at\n     /// most one continuous overlapping region between src and dest).\n-    unsafe fn wrap_copy(&self, dst: usize, src: usize, len: usize) {\n-        #[allow(dead_code)]\n-        fn diff(a: usize, b: usize) -> usize {\n-            if a <= b { b - a } else { a - b }\n-        }\n+    unsafe fn wrap_copy(&mut self, src: usize, dst: usize, len: usize) {\n         debug_assert!(\n-            cmp::min(diff(dst, src), self.cap() - diff(dst, src)) + len <= self.cap(),\n+            cmp::min(src.abs_diff(dst), self.capacity() - src.abs_diff(dst)) + len\n+                <= self.capacity(),\n             \"wrc dst={} src={} len={} cap={}\",\n             dst,\n             src,\n             len,\n-            self.cap()\n+            self.capacity()\n         );\n \n-        if src == dst || len == 0 {\n+        // If T is a ZST, don't do any copying.\n+        if T::IS_ZST || src == dst || len == 0 {\n             return;\n         }\n \n         let dst_after_src = self.wrap_sub(dst, src) < len;\n \n-        let src_pre_wrap_len = self.cap() - src;\n-        let dst_pre_wrap_len = self.cap() - dst;\n+        let src_pre_wrap_len = self.capacity() - src;\n+        let dst_pre_wrap_len = self.capacity() - dst;\n         let src_wraps = src_pre_wrap_len < len;\n         let dst_wraps = dst_pre_wrap_len < len;\n \n@@ -342,7 +288,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 //            D . . .\n                 //\n                 unsafe {\n-                    self.copy(dst, src, len);\n+                    self.copy(src, dst, len);\n                 }\n             }\n             (false, false, true) => {\n@@ -355,8 +301,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 //    . .           D .\n                 //\n                 unsafe {\n-                    self.copy(dst, src, dst_pre_wrap_len);\n-                    self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                    self.copy(src, dst, dst_pre_wrap_len);\n+                    self.copy(src + dst_pre_wrap_len, 0, len - dst_pre_wrap_len);\n                 }\n             }\n             (true, false, true) => {\n@@ -369,8 +315,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 //    . .           D .\n                 //\n                 unsafe {\n-                    self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n-                    self.copy(dst, src, dst_pre_wrap_len);\n+                    self.copy(src + dst_pre_wrap_len, 0, len - dst_pre_wrap_len);\n+                    self.copy(src, dst, dst_pre_wrap_len);\n                 }\n             }\n             (false, true, false) => {\n@@ -383,8 +329,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 //              D . . .\n                 //\n                 unsafe {\n-                    self.copy(dst, src, src_pre_wrap_len);\n-                    self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                    self.copy(src, dst, src_pre_wrap_len);\n+                    self.copy(0, dst + src_pre_wrap_len, len - src_pre_wrap_len);\n                 }\n             }\n             (true, true, false) => {\n@@ -397,8 +343,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 //    D . . .\n                 //\n                 unsafe {\n-                    self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n-                    self.copy(dst, src, src_pre_wrap_len);\n+                    self.copy(0, dst + src_pre_wrap_len, len - src_pre_wrap_len);\n+                    self.copy(src, dst, src_pre_wrap_len);\n                 }\n             }\n             (false, true, true) => {\n@@ -414,9 +360,9 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 debug_assert!(dst_pre_wrap_len > src_pre_wrap_len);\n                 let delta = dst_pre_wrap_len - src_pre_wrap_len;\n                 unsafe {\n-                    self.copy(dst, src, src_pre_wrap_len);\n-                    self.copy(dst + src_pre_wrap_len, 0, delta);\n-                    self.copy(0, delta, len - dst_pre_wrap_len);\n+                    self.copy(src, dst, src_pre_wrap_len);\n+                    self.copy(0, dst + src_pre_wrap_len, delta);\n+                    self.copy(delta, 0, len - dst_pre_wrap_len);\n                 }\n             }\n             (true, true, true) => {\n@@ -432,9 +378,9 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 debug_assert!(src_pre_wrap_len > dst_pre_wrap_len);\n                 let delta = src_pre_wrap_len - dst_pre_wrap_len;\n                 unsafe {\n-                    self.copy(delta, 0, len - src_pre_wrap_len);\n-                    self.copy(0, self.cap() - delta, delta);\n-                    self.copy(dst, src, dst_pre_wrap_len);\n+                    self.copy(0, delta, len - src_pre_wrap_len);\n+                    self.copy(self.capacity() - delta, 0, delta);\n+                    self.copy(src, dst, dst_pre_wrap_len);\n                 }\n             }\n         }\n@@ -444,8 +390,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// Assumes capacity is sufficient.\n     #[inline]\n     unsafe fn copy_slice(&mut self, dst: usize, src: &[T]) {\n-        debug_assert!(src.len() <= self.cap());\n-        let head_room = self.cap() - dst;\n+        debug_assert!(src.len() <= self.capacity());\n+        let head_room = self.capacity() - dst;\n         if src.len() <= head_room {\n             unsafe {\n                 ptr::copy_nonoverlapping(src.as_ptr(), self.ptr().add(dst), src.len());\n@@ -478,48 +424,100 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         });\n     }\n \n+    /// Writes all values from `iter` to `dst`, wrapping\n+    /// at the end of the buffer and returns the number\n+    /// of written values.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Assumes that `iter` yields at most `len` items.\n+    /// Assumes capacity is sufficient.\n+    unsafe fn write_iter_wrapping(\n+        &mut self,\n+        dst: usize,\n+        mut iter: impl Iterator<Item = T>,\n+        len: usize,\n+    ) -> usize {\n+        struct Guard<'a, T, A: Allocator> {\n+            deque: &'a mut VecDeque<T, A>,\n+            written: usize,\n+        }\n+\n+        impl<'a, T, A: Allocator> Drop for Guard<'a, T, A> {\n+            fn drop(&mut self) {\n+                self.deque.len += self.written;\n+            }\n+        }\n+\n+        let head_room = self.capacity() - dst;\n+\n+        let mut guard = Guard { deque: self, written: 0 };\n+\n+        if head_room >= len {\n+            unsafe { guard.deque.write_iter(dst, iter, &mut guard.written) };\n+        } else {\n+            unsafe {\n+                guard.deque.write_iter(\n+                    dst,\n+                    ByRefSized(&mut iter).take(head_room),\n+                    &mut guard.written,\n+                );\n+                guard.deque.write_iter(0, iter, &mut guard.written)\n+            };\n+        }\n+\n+        guard.written\n+    }\n+\n     /// Frobs the head and tail sections around to handle the fact that we\n     /// just reallocated. Unsafe because it trusts old_capacity.\n     #[inline]\n     unsafe fn handle_capacity_increase(&mut self, old_capacity: usize) {\n-        let new_capacity = self.cap();\n+        let new_capacity = self.capacity();\n+        debug_assert!(new_capacity >= old_capacity);\n \n         // Move the shortest contiguous section of the ring buffer\n-        //    T             H\n+        //\n+        // H := head\n+        // L := last element (`self.to_physical_idx(self.len - 1)`)\n+        //\n+        //    H           L\n         //   [o o o o o o o . ]\n-        //    T             H\n+        //    H           L\n         // A [o o o o o o o . . . . . . . . . ]\n-        //        H T\n-        //   [o o . o o o o o ]\n-        //          T             H\n+        //        L H\n+        //   [o o o o o o o o ]\n+        //          H           L\n         // B [. . . o o o o o o o . . . . . . ]\n-        //              H T\n-        //   [o o o o o . o o ]\n-        //              H                 T\n+        //              L H\n+        //   [o o o o o o o o ]\n+        //            L                   H\n         // C [o o o o o . . . . . . . . . o o ]\n \n-        if self.tail <= self.head {\n+        // can't use is_contiguous() because the capacity is already updated.\n+        if self.head <= old_capacity - self.len {\n             // A\n             // Nop\n-        } else if self.head < old_capacity - self.tail {\n-            // B\n-            unsafe {\n-                self.copy_nonoverlapping(old_capacity, 0, self.head);\n-            }\n-            self.head += old_capacity;\n-            debug_assert!(self.head > self.tail);\n         } else {\n-            // C\n-            let new_tail = new_capacity - (old_capacity - self.tail);\n-            unsafe {\n-                self.copy_nonoverlapping(new_tail, self.tail, old_capacity - self.tail);\n+            let head_len = old_capacity - self.head;\n+            let tail_len = self.len - head_len;\n+            if head_len > tail_len && new_capacity - old_capacity >= tail_len {\n+                // B\n+                unsafe {\n+                    self.copy_nonoverlapping(0, old_capacity, tail_len);\n+                }\n+            } else {\n+                // C\n+                let new_head = new_capacity - head_len;\n+                unsafe {\n+                    // can't use copy_nonoverlapping here, because if e.g. head_len = 2\n+                    // and new_capacity = old_capacity + 1, then the heads overlap.\n+                    self.copy(self.head, new_head, head_len);\n+                }\n+                self.head = new_head;\n             }\n-            self.tail = new_tail;\n-            debug_assert!(self.head < self.tail);\n         }\n-        debug_assert!(self.head < self.cap());\n-        debug_assert!(self.tail < self.cap());\n-        debug_assert!(self.cap().count_ones() == 1);\n+        debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n     }\n }\n \n@@ -533,6 +531,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// let deque: VecDeque<u32> = VecDeque::new();\n     /// ```\n+    // FIXME: This should probably be const\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n@@ -569,8 +568,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub fn new_in(alloc: A) -> VecDeque<T, A> {\n-        VecDeque::with_capacity_in(INITIAL_CAPACITY, alloc)\n+    pub const fn new_in(alloc: A) -> VecDeque<T, A> {\n+        VecDeque { head: 0, len: 0, buf: RawVec::new_in(alloc) }\n     }\n \n     /// Creates an empty deque with space for at least `capacity` elements.\n@@ -584,11 +583,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub fn with_capacity_in(capacity: usize, alloc: A) -> VecDeque<T, A> {\n-        assert!(capacity < 1_usize << usize::BITS - 1, \"capacity overflow\");\n-        // +1 since the ringbuffer always leaves one space empty\n-        let cap = cmp::max(capacity + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n-\n-        VecDeque { tail: 0, head: 0, buf: RawVec::with_capacity_in(cap, alloc) }\n+        VecDeque { head: 0, len: 0, buf: RawVec::with_capacity_in(capacity, alloc) }\n     }\n \n     /// Provides a reference to the element at the given index.\n@@ -608,8 +603,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, index: usize) -> Option<&T> {\n-        if index < self.len() {\n-            let idx = self.wrap_add(self.tail, index);\n+        if index < self.len {\n+            let idx = self.to_physical_idx(index);\n             unsafe { Some(&*self.ptr().add(idx)) }\n         } else {\n             None\n@@ -637,8 +632,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n-        if index < self.len() {\n-            let idx = self.wrap_add(self.tail, index);\n+        if index < self.len {\n+            let idx = self.to_physical_idx(index);\n             unsafe { Some(&mut *self.ptr().add(idx)) }\n         } else {\n             None\n@@ -672,8 +667,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     pub fn swap(&mut self, i: usize, j: usize) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n-        let ri = self.wrap_add(self.tail, i);\n-        let rj = self.wrap_add(self.tail, j);\n+        let ri = self.to_physical_idx(i);\n+        let rj = self.to_physical_idx(j);\n         unsafe { ptr::swap(self.ptr().add(ri), self.ptr().add(rj)) }\n     }\n \n@@ -691,7 +686,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.cap() - 1\n+        if T::IS_ZST { usize::MAX } else { self.buf.capacity() }\n     }\n \n     /// Reserves the minimum capacity for at least `additional` more elements to be inserted in the\n@@ -718,7 +713,15 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// [`reserve`]: VecDeque::reserve\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n-        self.reserve(additional);\n+        let new_cap = self.len.checked_add(additional).expect(\"capacity overflow\");\n+        let old_cap = self.capacity();\n+\n+        if new_cap > old_cap {\n+            self.buf.reserve_exact(self.len, additional);\n+            unsafe {\n+                self.handle_capacity_increase(old_cap);\n+            }\n+        }\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted in the given\n@@ -739,15 +742,13 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n-        let old_cap = self.cap();\n-        let used_cap = self.len() + 1;\n-        let new_cap = used_cap\n-            .checked_add(additional)\n-            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .expect(\"capacity overflow\");\n+        let new_cap = self.len.checked_add(additional).expect(\"capacity overflow\");\n+        let old_cap = self.capacity();\n \n         if new_cap > old_cap {\n-            self.buf.reserve_exact(used_cap, new_cap - used_cap);\n+            // we don't need to reserve_exact(), as the size doesn't have\n+            // to be a power of 2.\n+            self.buf.reserve(self.len, additional);\n             unsafe {\n                 self.handle_capacity_increase(old_cap);\n             }\n@@ -793,7 +794,17 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"try_reserve\", since = \"1.57.0\")]\n     pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n-        self.try_reserve(additional)\n+        let new_cap =\n+            self.len.checked_add(additional).ok_or(TryReserveErrorKind::CapacityOverflow)?;\n+        let old_cap = self.capacity();\n+\n+        if new_cap > old_cap {\n+            self.buf.try_reserve_exact(self.len, additional)?;\n+            unsafe {\n+                self.handle_capacity_increase(old_cap);\n+            }\n+        }\n+        Ok(())\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n@@ -831,15 +842,12 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"try_reserve\", since = \"1.57.0\")]\n     pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n-        let old_cap = self.cap();\n-        let used_cap = self.len() + 1;\n-        let new_cap = used_cap\n-            .checked_add(additional)\n-            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .ok_or(TryReserveErrorKind::CapacityOverflow)?;\n+        let new_cap =\n+            self.len.checked_add(additional).ok_or(TryReserveErrorKind::CapacityOverflow)?;\n+        let old_cap = self.capacity();\n \n         if new_cap > old_cap {\n-            self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;\n+            self.buf.try_reserve(self.len, additional)?;\n             unsafe {\n                 self.handle_capacity_increase(old_cap);\n             }\n@@ -890,13 +898,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"shrink_to\", since = \"1.56.0\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n-        let min_capacity = cmp::min(min_capacity, self.capacity());\n-        // We don't have to worry about an overflow as neither `self.len()` nor `self.capacity()`\n-        // can ever be `usize::MAX`. +1 as the ringbuffer always leaves one space empty.\n-        let target_cap = cmp::max(cmp::max(min_capacity, self.len()) + 1, MINIMUM_CAPACITY + 1)\n-            .next_power_of_two();\n+        let target_cap = min_capacity.max(self.len);\n \n-        if target_cap < self.cap() {\n+        // never shrink ZSTs\n+        if T::IS_ZST || self.capacity() <= target_cap {\n+            return;\n+        }\n+\n+        if target_cap < self.capacity() {\n             // There are three cases of interest:\n             //   All elements are out of desired bounds\n             //   Elements are contiguous, and head is out of desired bounds\n@@ -905,49 +914,55 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             // At all other times, element positions are unaffected.\n             //\n             // Indicates that elements at the head should be moved.\n-            let head_outside = self.head == 0 || self.head >= target_cap;\n+\n+            let tail_outside = (target_cap + 1..=self.capacity()).contains(&(self.head + self.len));\n             // Move elements from out of desired bounds (positions after target_cap)\n-            if self.tail >= target_cap && head_outside {\n-                //                    T             H\n+            if self.len == 0 {\n+                self.head = 0;\n+            } else if self.head >= target_cap && tail_outside {\n+                //  H := head\n+                //  L := last element\n+                //                    H           L\n                 //   [. . . . . . . . o o o o o o o . ]\n-                //    T             H\n+                //    H           L\n                 //   [o o o o o o o . ]\n                 unsafe {\n-                    self.copy_nonoverlapping(0, self.tail, self.len());\n+                    // nonoverlapping because self.head >= target_cap >= self.len\n+                    self.copy_nonoverlapping(self.head, 0, self.len);\n                 }\n-                self.head = self.len();\n-                self.tail = 0;\n-            } else if self.tail != 0 && self.tail < target_cap && head_outside {\n-                //          T             H\n+                self.head = 0;\n+            } else if self.head < target_cap && tail_outside {\n+                //  H := head\n+                //  L := last element\n+                //          H           L\n                 //   [. . . o o o o o o o . . . . . . ]\n-                //        H T\n+                //      L   H\n                 //   [o o . o o o o o ]\n-                let len = self.wrap_sub(self.head, target_cap);\n+                let len = self.head + self.len - target_cap;\n                 unsafe {\n-                    self.copy_nonoverlapping(0, target_cap, len);\n+                    self.copy_nonoverlapping(target_cap, 0, len);\n                 }\n-                self.head = len;\n-                debug_assert!(self.head < self.tail);\n-            } else if self.tail >= target_cap {\n-                //              H                 T\n+            } else if self.head >= target_cap {\n+                //  H := head\n+                //  L := last element\n+                //            L                   H\n                 //   [o o o o o . . . . . . . . . o o ]\n-                //              H T\n+                //            L   H\n                 //   [o o o o o . o o ]\n-                debug_assert!(self.wrap_sub(self.head, 1) < target_cap);\n-                let len = self.cap() - self.tail;\n-                let new_tail = target_cap - len;\n+                let len = self.capacity() - self.head;\n+                let new_head = target_cap - len;\n                 unsafe {\n-                    self.copy_nonoverlapping(new_tail, self.tail, len);\n+                    // can't use copy_nonoverlapping here for the same reason\n+                    // as in `handle_capacity_increase()`\n+                    self.copy(self.head, new_head, len);\n                 }\n-                self.tail = new_tail;\n-                debug_assert!(self.head < self.tail);\n+                self.head = new_head;\n             }\n \n             self.buf.shrink_to_fit(target_cap);\n \n-            debug_assert!(self.head < self.cap());\n-            debug_assert!(self.tail < self.cap());\n-            debug_assert!(self.cap().count_ones() == 1);\n+            debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n+            debug_assert!(self.len <= self.capacity());\n         }\n     }\n \n@@ -992,20 +1007,20 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         // * The head of the VecDeque is moved before calling `drop_in_place`,\n         //   so no value is dropped twice if `drop_in_place` panics\n         unsafe {\n-            if len > self.len() {\n+            if len >= self.len {\n                 return;\n             }\n-            let num_dropped = self.len() - len;\n+\n             let (front, back) = self.as_mut_slices();\n             if len > front.len() {\n                 let begin = len - front.len();\n                 let drop_back = back.get_unchecked_mut(begin..) as *mut _;\n-                self.head = self.wrap_sub(self.head, num_dropped);\n+                self.len = len;\n                 ptr::drop_in_place(drop_back);\n             } else {\n                 let drop_back = back as *mut _;\n                 let drop_front = front.get_unchecked_mut(len..) as *mut _;\n-                self.head = self.wrap_sub(self.head, num_dropped);\n+                self.len = len;\n \n                 // Make sure the second half is dropped even when a destructor\n                 // in the first one panics.\n@@ -1039,7 +1054,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, T> {\n-        Iter::new(unsafe { self.buffer_as_slice() }, self.tail, self.head)\n+        let (a, b) = self.as_slices();\n+        Iter::new(a.iter(), b.iter())\n     }\n \n     /// Returns a front-to-back iterator that returns mutable references.\n@@ -1061,11 +1077,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n-        // SAFETY: The internal `IterMut` safety invariant is established because the\n-        // `ring` we create is a dereferenceable slice for lifetime '_.\n-        let ring = ptr::slice_from_raw_parts_mut(self.ptr(), self.cap());\n-\n-        unsafe { IterMut::new(ring, self.tail, self.head, PhantomData) }\n+        let (a, b) = self.as_mut_slices();\n+        IterMut::new(a.iter_mut(), b.iter_mut())\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n@@ -1097,14 +1110,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            let buf = self.buffer_as_slice();\n-            let (front, back) = RingSlices::ring_slices(buf, self.head, self.tail);\n-            (MaybeUninit::slice_assume_init_ref(front), MaybeUninit::slice_assume_init_ref(back))\n-        }\n+        let (a_range, b_range) = self.slice_ranges(..);\n+        // SAFETY: `slice_ranges` always returns valid ranges into\n+        // the physical buffer.\n+        unsafe { (&*self.buffer_range(a_range), &*self.buffer_range(b_range)) }\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n@@ -1135,16 +1144,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            let head = self.head;\n-            let tail = self.tail;\n-            let buf = self.buffer_as_mut_slice();\n-            let (front, back) = RingSlices::ring_slices(buf, head, tail);\n-            (MaybeUninit::slice_assume_init_mut(front), MaybeUninit::slice_assume_init_mut(back))\n-        }\n+        let (a_range, b_range) = self.slice_ranges(..);\n+        // SAFETY: `slice_ranges` always returns valid ranges into\n+        // the physical buffer.\n+        unsafe { (&mut *self.buffer_range(a_range), &mut *self.buffer_range(b_range)) }\n     }\n \n     /// Returns the number of elements in the deque.\n@@ -1161,7 +1164,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n-        count(self.tail, self.head, self.cap())\n+        self.len\n     }\n \n     /// Returns `true` if the deque is empty.\n@@ -1178,17 +1181,41 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.tail == self.head\n+        self.len == 0\n     }\n \n-    fn range_tail_head<R>(&self, range: R) -> (usize, usize)\n+    /// Given a range into the logical buffer of the deque, this function\n+    /// return two ranges into the physical buffer that correspond to\n+    /// the given range.\n+    fn slice_ranges<R>(&self, range: R) -> (Range<usize>, Range<usize>)\n     where\n         R: RangeBounds<usize>,\n     {\n-        let Range { start, end } = slice::range(range, ..self.len());\n-        let tail = self.wrap_add(self.tail, start);\n-        let head = self.wrap_add(self.tail, end);\n-        (tail, head)\n+        let Range { start, end } = slice::range(range, ..self.len);\n+        let len = end - start;\n+\n+        if len == 0 {\n+            (0..0, 0..0)\n+        } else {\n+            // `slice::range` guarantees that `start <= end <= self.len`.\n+            // because `len != 0`, we know that `start < end`, so `start < self.len`\n+            // and the indexing is valid.\n+            let wrapped_start = self.to_physical_idx(start);\n+\n+            // this subtraction can never overflow because `wrapped_start` is\n+            // at most `self.capacity()` (and if `self.capacity != 0`, then `wrapped_start` is strictly less\n+            // than `self.capacity`).\n+            let head_len = self.capacity() - wrapped_start;\n+\n+            if head_len >= len {\n+                // we know that `len + wrapped_start <= self.capacity <= usize::MAX`, so this addition can't overflow\n+                (wrapped_start..wrapped_start + len, 0..0)\n+            } else {\n+                // can't overflow because of the if condition\n+                let tail_len = len - head_len;\n+                (wrapped_start..self.capacity(), 0..tail_len)\n+            }\n+        }\n     }\n \n     /// Creates an iterator that covers the specified range in the deque.\n@@ -1217,9 +1244,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (tail, head) = self.range_tail_head(range);\n-        // The shared reference we have in &self is maintained in the '_ of Iter.\n-        Iter::new(unsafe { self.buffer_as_slice() }, tail, head)\n+        let (a_range, b_range) = self.slice_ranges(range);\n+        // SAFETY: The ranges returned by `slice_ranges`\n+        // are valid ranges into the physical buffer, so\n+        // it's ok to pass them to `buffer_range` and\n+        // dereference the result.\n+        let a = unsafe { &*self.buffer_range(a_range) };\n+        let b = unsafe { &*self.buffer_range(b_range) };\n+        Iter::new(a.iter(), b.iter())\n     }\n \n     /// Creates an iterator that covers the specified mutable range in the deque.\n@@ -1252,13 +1284,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (tail, head) = self.range_tail_head(range);\n-\n-        // SAFETY: The internal `IterMut` safety invariant is established because the\n-        // `ring` we create is a dereferenceable slice for lifetime '_.\n-        let ring = ptr::slice_from_raw_parts_mut(self.ptr(), self.cap());\n-\n-        unsafe { IterMut::new(ring, tail, head, PhantomData) }\n+        let (a_range, b_range) = self.slice_ranges(range);\n+        // SAFETY: The ranges returned by `slice_ranges`\n+        // are valid ranges into the physical buffer, so\n+        // it's ok to pass them to `buffer_range` and\n+        // dereference the result.\n+        let a = unsafe { &mut *self.buffer_range(a_range) };\n+        let b = unsafe { &mut *self.buffer_range(b_range) };\n+        IterMut::new(a.iter_mut(), b.iter_mut())\n     }\n \n     /// Removes the specified range from the deque in bulk, returning all\n@@ -1310,39 +1343,30 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         // When finished, the remaining data will be copied back to cover the hole,\n         // and the head/tail values will be restored correctly.\n         //\n-        let (drain_tail, drain_head) = self.range_tail_head(range);\n+        let Range { start, end } = slice::range(range, ..self.len);\n+        let drain_start = start;\n+        let drain_len = end - start;\n \n         // The deque's elements are parted into three segments:\n-        // * self.tail  -> drain_tail\n-        // * drain_tail -> drain_head\n-        // * drain_head -> self.head\n+        // * 0  -> drain_start\n+        // * drain_start -> drain_start+drain_len\n+        // * drain_start+drain_len -> self.len\n         //\n-        // T = self.tail; H = self.head; t = drain_tail; h = drain_head\n+        // H = self.head; T = self.head+self.len; t = drain_start+drain_len; h = drain_head\n         //\n-        // We store drain_tail as self.head, and drain_head and self.head as\n-        // after_tail and after_head respectively on the Drain. This also\n+        // We store drain_start as self.len, and drain_len and self.len as\n+        // drain_len and orig_len respectively on the Drain. This also\n         // truncates the effective array such that if the Drain is leaked, we\n         // have forgotten about the potentially moved values after the start of\n         // the drain.\n         //\n-        //        T   t   h   H\n+        //        H   h   t   T\n         // [. . . o o x x o o . . .]\n         //\n-        let head = self.head;\n-\n         // \"forget\" about the values after the start of the drain until after\n         // the drain is complete and the Drain destructor is run.\n-        self.head = drain_tail;\n \n-        let deque = NonNull::from(&mut *self);\n-        unsafe {\n-            // Crucially, we only create shared references from `self` here and read from\n-            // it.  We do not write to `self` nor reborrow to a mutable reference.\n-            // Hence the raw pointer we created above, for `deque`, remains valid.\n-            let ring = self.buffer_as_slice();\n-\n-            Drain::new(drain_head, head, ring, drain_tail, drain_head, deque)\n-        }\n+        unsafe { Drain::new(self, drain_start, drain_len) }\n     }\n \n     /// Clears the deque, removing all values.\n@@ -1361,6 +1385,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     pub fn clear(&mut self) {\n         self.truncate(0);\n+        // Not strictly necessary, but leaves things in a more consistent/predictable state.\n+        self.head = 0;\n     }\n \n     /// Returns `true` if the deque contains an element equal to the\n@@ -1455,7 +1481,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        self.get(self.len().wrapping_sub(1))\n+        self.get(self.len.wrapping_sub(1))\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the\n@@ -1479,7 +1505,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        self.get_mut(self.len().wrapping_sub(1))\n+        self.get_mut(self.len.wrapping_sub(1))\n     }\n \n     /// Removes the first element and returns it, or `None` if the deque is\n@@ -1503,9 +1529,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         if self.is_empty() {\n             None\n         } else {\n-            let tail = self.tail;\n-            self.tail = self.wrap_add(self.tail, 1);\n-            unsafe { Some(self.buffer_read(tail)) }\n+            let old_head = self.head;\n+            self.head = self.to_physical_idx(1);\n+            self.len -= 1;\n+            Some(unsafe { self.buffer_read(old_head) })\n         }\n     }\n \n@@ -1528,9 +1555,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         if self.is_empty() {\n             None\n         } else {\n-            self.head = self.wrap_sub(self.head, 1);\n-            let head = self.head;\n-            unsafe { Some(self.buffer_read(head)) }\n+            self.len -= 1;\n+            Some(unsafe { self.buffer_read(self.to_physical_idx(self.len)) })\n         }\n     }\n \n@@ -1552,10 +1578,11 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             self.grow();\n         }\n \n-        self.tail = self.wrap_sub(self.tail, 1);\n-        let tail = self.tail;\n+        self.head = self.wrap_sub(self.head, 1);\n+        self.len += 1;\n+\n         unsafe {\n-            self.buffer_write(tail, value);\n+            self.buffer_write(self.head, value);\n         }\n     }\n \n@@ -1577,16 +1604,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             self.grow();\n         }\n \n-        let head = self.head;\n-        self.head = self.wrap_add(self.head, 1);\n-        unsafe { self.buffer_write(head, value) }\n+        unsafe { self.buffer_write(self.to_physical_idx(self.len), value) }\n+        self.len += 1;\n     }\n \n     #[inline]\n     fn is_contiguous(&self) -> bool {\n-        // FIXME: Should we consider `head == 0` to mean\n-        // that `self` is contiguous?\n-        self.tail <= self.head\n+        // Do the calculation like this to avoid overflowing if len + head > usize::MAX\n+        self.head <= self.capacity() - self.len\n     }\n \n     /// Removes an element from anywhere in the deque and returns it,\n@@ -1615,8 +1640,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n-        let length = self.len();\n-        if length > 0 && index < length && index != 0 {\n+        let length = self.len;\n+        if index < length && index != 0 {\n             self.swap(index, 0);\n         } else if index >= length {\n             return None;\n@@ -1650,7 +1675,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n-        let length = self.len();\n+        let length = self.len;\n         if length > 0 && index < length - 1 {\n             self.swap(index, length - 1);\n         } else if index >= length {\n@@ -1689,198 +1714,26 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             self.grow();\n         }\n \n-        // Move the least number of elements in the ring buffer and insert\n-        // the given object\n-        //\n-        // At most len/2 - 1 elements will be moved. O(min(n, n-i))\n-        //\n-        // There are three main cases:\n-        //  Elements are contiguous\n-        //      - special case when tail is 0\n-        //  Elements are discontiguous and the insert is in the tail section\n-        //  Elements are discontiguous and the insert is in the head section\n-        //\n-        // For each of those there are two more cases:\n-        //  Insert is closer to tail\n-        //  Insert is closer to head\n-        //\n-        // Key: H - self.head\n-        //      T - self.tail\n-        //      o - Valid element\n-        //      I - Insertion element\n-        //      A - The element that should be after the insertion point\n-        //      M - Indicates element was moved\n-\n-        let idx = self.wrap_add(self.tail, index);\n-\n-        let distance_to_tail = index;\n-        let distance_to_head = self.len() - index;\n-\n-        let contiguous = self.is_contiguous();\n-\n-        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n-            (true, true, _) if index == 0 => {\n-                // push_front\n-                //\n-                //       T\n-                //       I             H\n-                //      [A o o o o o o . . . . . . . . .]\n-                //\n-                //                       H         T\n-                //      [A o o o o o o o . . . . . I]\n-                //\n-\n-                self.tail = self.wrap_sub(self.tail, 1);\n-            }\n-            (true, true, _) => {\n-                unsafe {\n-                    // contiguous, insert closer to tail:\n-                    //\n-                    //             T   I         H\n-                    //      [. . . o o A o o o o . . . . . .]\n-                    //\n-                    //           T               H\n-                    //      [. . o o I A o o o o . . . . . .]\n-                    //           M M\n-                    //\n-                    // contiguous, insert closer to tail and tail is 0:\n-                    //\n-                    //\n-                    //       T   I         H\n-                    //      [o o A o o o o . . . . . . . . .]\n-                    //\n-                    //                       H             T\n-                    //      [o I A o o o o o . . . . . . . o]\n-                    //       M                             M\n-\n-                    let new_tail = self.wrap_sub(self.tail, 1);\n-\n-                    self.copy(new_tail, self.tail, 1);\n-                    // Already moved the tail, so we only copy `index - 1` elements.\n-                    self.copy(self.tail, self.tail + 1, index - 1);\n-\n-                    self.tail = new_tail;\n-                }\n-            }\n-            (true, false, _) => {\n-                unsafe {\n-                    //  contiguous, insert closer to head:\n-                    //\n-                    //             T       I     H\n-                    //      [. . . o o o o A o o . . . . . .]\n-                    //\n-                    //             T               H\n-                    //      [. . . o o o o I A o o . . . . .]\n-                    //                       M M M\n-\n-                    self.copy(idx + 1, idx, self.head - idx);\n-                    self.head = self.wrap_add(self.head, 1);\n-                }\n-            }\n-            (false, true, true) => {\n-                unsafe {\n-                    // discontiguous, insert closer to tail, tail section:\n-                    //\n-                    //                   H         T   I\n-                    //      [o o o o o o . . . . . o o A o o]\n-                    //\n-                    //                   H       T\n-                    //      [o o o o o o . . . . o o I A o o]\n-                    //                           M M\n-\n-                    self.copy(self.tail - 1, self.tail, index);\n-                    self.tail -= 1;\n-                }\n-            }\n-            (false, false, true) => {\n-                unsafe {\n-                    // discontiguous, insert closer to head, tail section:\n-                    //\n-                    //           H             T         I\n-                    //      [o o . . . . . . . o o o o o A o]\n-                    //\n-                    //             H           T\n-                    //      [o o o . . . . . . o o o o o I A]\n-                    //       M M M                         M\n-\n-                    // copy elements up to new head\n-                    self.copy(1, 0, self.head);\n-\n-                    // copy last element into empty spot at bottom of buffer\n-                    self.copy(0, self.cap() - 1, 1);\n-\n-                    // move elements from idx to end forward not including ^ element\n-                    self.copy(idx + 1, idx, self.cap() - 1 - idx);\n-\n-                    self.head += 1;\n-                }\n-            }\n-            (false, true, false) if idx == 0 => {\n-                unsafe {\n-                    // discontiguous, insert is closer to tail, head section,\n-                    // and is at index zero in the internal buffer:\n-                    //\n-                    //       I                   H     T\n-                    //      [A o o o o o o o o o . . . o o o]\n-                    //\n-                    //                           H   T\n-                    //      [A o o o o o o o o o . . o o o I]\n-                    //                               M M M\n-\n-                    // copy elements up to new tail\n-                    self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n-\n-                    // copy last element into empty spot at bottom of buffer\n-                    self.copy(self.cap() - 1, 0, 1);\n-\n-                    self.tail -= 1;\n-                }\n-            }\n-            (false, true, false) => {\n-                unsafe {\n-                    // discontiguous, insert closer to tail, head section:\n-                    //\n-                    //             I             H     T\n-                    //      [o o o A o o o o o o . . . o o o]\n-                    //\n-                    //                           H   T\n-                    //      [o o I A o o o o o o . . o o o o]\n-                    //       M M                     M M M M\n-\n-                    // copy elements up to new tail\n-                    self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n-\n-                    // copy last element into empty spot at bottom of buffer\n-                    self.copy(self.cap() - 1, 0, 1);\n-\n-                    // move elements from idx-1 to end forward not including ^ element\n-                    self.copy(0, 1, idx - 1);\n-\n-                    self.tail -= 1;\n-                }\n+        let k = self.len - index;\n+        if k < index {\n+            // `index + 1` can't overflow, because if index was usize::MAX, then either the\n+            // assert would've failed, or the deque would've tried to grow past usize::MAX\n+            // and panicked.\n+            unsafe {\n+                // see `remove()` for explanation why this wrap_copy() call is safe.\n+                self.wrap_copy(self.to_physical_idx(index), self.to_physical_idx(index + 1), k);\n+                self.buffer_write(self.to_physical_idx(index), value);\n+                self.len += 1;\n             }\n-            (false, false, false) => {\n-                unsafe {\n-                    // discontiguous, insert closer to head, head section:\n-                    //\n-                    //               I     H           T\n-                    //      [o o o o A o o . . . . . . o o o]\n-                    //\n-                    //                     H           T\n-                    //      [o o o o I A o o . . . . . o o o]\n-                    //                 M M M\n-\n-                    self.copy(idx + 1, idx, self.head - idx);\n-                    self.head += 1;\n-                }\n+        } else {\n+            let old_head = self.head;\n+            self.head = self.wrap_sub(self.head, 1);\n+            unsafe {\n+                self.wrap_copy(old_head, self.head, index);\n+                self.buffer_write(self.to_physical_idx(index), value);\n+                self.len += 1;\n             }\n         }\n-\n-        // tail might've been changed so we need to recalculate\n-        let new_idx = self.wrap_add(self.tail, index);\n-        unsafe {\n-            self.buffer_write(new_idx, value);\n-        }\n     }\n \n     /// Removes and returns the element at `index` from the deque.\n@@ -1906,156 +1759,26 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, index: usize) -> Option<T> {\n-        if self.is_empty() || self.len() <= index {\n+        if self.len <= index {\n             return None;\n         }\n \n-        // There are three main cases:\n-        //  Elements are contiguous\n-        //  Elements are discontiguous and the removal is in the tail section\n-        //  Elements are discontiguous and the removal is in the head section\n-        //      - special case when elements are technically contiguous,\n-        //        but self.head = 0\n-        //\n-        // For each of those there are two more cases:\n-        //  Insert is closer to tail\n-        //  Insert is closer to head\n-        //\n-        // Key: H - self.head\n-        //      T - self.tail\n-        //      o - Valid element\n-        //      x - Element marked for removal\n-        //      R - Indicates element that is being removed\n-        //      M - Indicates element was moved\n-\n-        let idx = self.wrap_add(self.tail, index);\n-\n-        let elem = unsafe { Some(self.buffer_read(idx)) };\n-\n-        let distance_to_tail = index;\n-        let distance_to_head = self.len() - index;\n+        let wrapped_idx = self.to_physical_idx(index);\n \n-        let contiguous = self.is_contiguous();\n+        let elem = unsafe { Some(self.buffer_read(wrapped_idx)) };\n \n-        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n-            (true, true, _) => {\n-                unsafe {\n-                    // contiguous, remove closer to tail:\n-                    //\n-                    //             T   R         H\n-                    //      [. . . o o x o o o o . . . . . .]\n-                    //\n-                    //               T           H\n-                    //      [. . . . o o o o o o . . . . . .]\n-                    //               M M\n-\n-                    self.copy(self.tail + 1, self.tail, index);\n-                    self.tail += 1;\n-                }\n-            }\n-            (true, false, _) => {\n-                unsafe {\n-                    // contiguous, remove closer to head:\n-                    //\n-                    //             T       R     H\n-                    //      [. . . o o o o x o o . . . . . .]\n-                    //\n-                    //             T           H\n-                    //      [. . . o o o o o o . . . . . . .]\n-                    //                     M M\n-\n-                    self.copy(idx, idx + 1, self.head - idx - 1);\n-                    self.head -= 1;\n-                }\n-            }\n-            (false, true, true) => {\n-                unsafe {\n-                    // discontiguous, remove closer to tail, tail section:\n-                    //\n-                    //                   H         T   R\n-                    //      [o o o o o o . . . . . o o x o o]\n-                    //\n-                    //                   H           T\n-                    //      [o o o o o o . . . . . . o o o o]\n-                    //                               M M\n-\n-                    self.copy(self.tail + 1, self.tail, index);\n-                    self.tail = self.wrap_add(self.tail, 1);\n-                }\n-            }\n-            (false, false, false) => {\n-                unsafe {\n-                    // discontiguous, remove closer to head, head section:\n-                    //\n-                    //               R     H           T\n-                    //      [o o o o x o o . . . . . . o o o]\n-                    //\n-                    //                   H             T\n-                    //      [o o o o o o . . . . . . . o o o]\n-                    //               M M\n-\n-                    self.copy(idx, idx + 1, self.head - idx - 1);\n-                    self.head -= 1;\n-                }\n-            }\n-            (false, false, true) => {\n-                unsafe {\n-                    // discontiguous, remove closer to head, tail section:\n-                    //\n-                    //             H           T         R\n-                    //      [o o o . . . . . . o o o o o x o]\n-                    //\n-                    //           H             T\n-                    //      [o o . . . . . . . o o o o o o o]\n-                    //       M M                         M M\n-                    //\n-                    // or quasi-discontiguous, remove next to head, tail section:\n-                    //\n-                    //       H                 T         R\n-                    //      [. . . . . . . . . o o o o o x o]\n-                    //\n-                    //                         T           H\n-                    //      [. . . . . . . . . o o o o o o .]\n-                    //                                   M\n-\n-                    // draw in elements in the tail section\n-                    self.copy(idx, idx + 1, self.cap() - idx - 1);\n-\n-                    // Prevents underflow.\n-                    if self.head != 0 {\n-                        // copy first element into empty spot\n-                        self.copy(self.cap() - 1, 0, 1);\n-\n-                        // move elements in the head section backwards\n-                        self.copy(0, 1, self.head - 1);\n-                    }\n-\n-                    self.head = self.wrap_sub(self.head, 1);\n-                }\n-            }\n-            (false, true, false) => {\n-                unsafe {\n-                    // discontiguous, remove closer to tail, head section:\n-                    //\n-                    //           R               H     T\n-                    //      [o o x o o o o o o o . . . o o o]\n-                    //\n-                    //                           H       T\n-                    //      [o o o o o o o o o o . . . . o o]\n-                    //       M M M                       M M\n-\n-                    // draw in elements up to idx\n-                    self.copy(1, 0, idx);\n-\n-                    // copy last element into empty spot\n-                    self.copy(0, self.cap() - 1, 1);\n-\n-                    // move elements from tail to end forward, excluding the last one\n-                    self.copy(self.tail + 1, self.tail, self.cap() - self.tail - 1);\n-\n-                    self.tail = self.wrap_add(self.tail, 1);\n-                }\n-            }\n+        let k = self.len - index - 1;\n+        // safety: due to the nature of the if-condition, whichever wrap_copy gets called,\n+        // its length argument will be at most `self.len / 2`, so there can't be more than\n+        // one overlapping area.\n+        if k < index {\n+            unsafe { self.wrap_copy(self.wrap_add(wrapped_idx, 1), wrapped_idx, k) };\n+            self.len -= 1;\n+        } else {\n+            let old_head = self.head;\n+            self.head = self.to_physical_idx(1);\n+            unsafe { self.wrap_copy(old_head, self.head, index) };\n+            self.len -= 1;\n         }\n \n         elem\n@@ -2091,7 +1814,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         A: Clone,\n     {\n-        let len = self.len();\n+        let len = self.len;\n         assert!(at <= len, \"`at` out of bounds\");\n \n         let other_len = len - at;\n@@ -2128,8 +1851,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n \n         // Cleanup where the ends of the buffers are\n-        self.head = self.wrap_sub(self.head, other_len);\n-        other.head = other.wrap_index(other_len);\n+        self.len = at;\n+        other.len = other_len;\n \n         other\n     }\n@@ -2154,17 +1877,26 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n-        self.reserve(other.len());\n+        if T::IS_ZST {\n+            self.len += other.len;\n+            other.len = 0;\n+            other.head = 0;\n+            return;\n+        }\n+\n+        self.reserve(other.len);\n         unsafe {\n             let (left, right) = other.as_slices();\n-            self.copy_slice(self.head, left);\n-            self.copy_slice(self.wrap_add(self.head, left.len()), right);\n+            self.copy_slice(self.to_physical_idx(self.len), left);\n+            // no overflow, because self.capacity() >= old_cap + left.len() >= self.len + left.len()\n+            self.copy_slice(self.to_physical_idx(self.len + left.len()), right);\n         }\n         // SAFETY: Update pointers after copying to avoid leaving doppelganger\n         // in case of panics.\n-        self.head = self.wrap_add(self.head, other.len());\n-        // Silently drop values in `other`.\n-        other.tail = other.head;\n+        self.len += other.len;\n+        // Now that we own its values, forget everything in `other`.\n+        other.len = 0;\n+        other.head = 0;\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -2232,7 +1964,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         F: FnMut(&mut T) -> bool,\n     {\n-        let len = self.len();\n+        let len = self.len;\n         let mut idx = 0;\n         let mut cur = 0;\n \n@@ -2270,9 +2002,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         // Extend or possibly remove this assertion when valid use-cases for growing the\n         // buffer without it being full emerge\n         debug_assert!(self.is_full());\n-        let old_cap = self.cap();\n-        self.buf.reserve_exact(old_cap, old_cap);\n-        assert!(self.cap() == old_cap * 2);\n+        let old_cap = self.capacity();\n+        self.buf.reserve_for_push(old_cap);\n         unsafe {\n             self.handle_capacity_increase(old_cap);\n         }\n@@ -2306,7 +2037,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"vec_resize_with\", since = \"1.33.0\")]\n     pub fn resize_with(&mut self, new_len: usize, generator: impl FnMut() -> T) {\n-        let len = self.len();\n+        let len = self.len;\n \n         if new_len > len {\n             self.extend(repeat_with(generator).take(new_len - len))\n@@ -2372,110 +2103,129 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"deque_make_contiguous\", since = \"1.48.0\")]\n     pub fn make_contiguous(&mut self) -> &mut [T] {\n+        if T::IS_ZST {\n+            self.head = 0;\n+        }\n+\n         if self.is_contiguous() {\n-            let tail = self.tail;\n-            let head = self.head;\n-            // Safety:\n-            // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-            // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-            return unsafe {\n-                MaybeUninit::slice_assume_init_mut(\n-                    RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0,\n-                )\n-            };\n+            unsafe { return slice::from_raw_parts_mut(self.ptr().add(self.head), self.len) }\n         }\n \n-        let buf = self.buf.ptr();\n-        let cap = self.cap();\n-        let len = self.len();\n+        let &mut Self { head, len, .. } = self;\n+        let ptr = self.ptr();\n+        let cap = self.capacity();\n \n-        let free = self.tail - self.head;\n-        let tail_len = cap - self.tail;\n+        let free = cap - len;\n+        let head_len = cap - head;\n+        let tail = len - head_len;\n+        let tail_len = tail;\n \n-        if free >= tail_len {\n-            // there is enough free space to copy the tail in one go,\n-            // this means that we first shift the head backwards, and then\n-            // copy the tail to the correct position.\n+        if free >= head_len {\n+            // there is enough free space to copy the head in one go,\n+            // this means that we first shift the tail backwards, and then\n+            // copy the head to the correct position.\n             //\n             // from: DEFGH....ABC\n             // to:   ABCDEFGH....\n             unsafe {\n-                ptr::copy(buf, buf.add(tail_len), self.head);\n+                self.copy(0, head_len, tail_len);\n                 // ...DEFGH.ABC\n-                ptr::copy_nonoverlapping(buf.add(self.tail), buf, tail_len);\n+                self.copy_nonoverlapping(head, 0, head_len);\n                 // ABCDEFGH....\n-\n-                self.tail = 0;\n-                self.head = len;\n             }\n-        } else if free > self.head {\n-            // FIXME: We currently do not consider ....ABCDEFGH\n-            // to be contiguous because `head` would be `0` in this\n-            // case. While we probably want to change this it\n-            // isn't trivial as a few places expect `is_contiguous`\n-            // to mean that we can just slice using `buf[tail..head]`.\n \n-            // there is enough free space to copy the head in one go,\n-            // this means that we first shift the tail forwards, and then\n-            // copy the head to the correct position.\n+            self.head = 0;\n+        } else if free >= tail_len {\n+            // there is enough free space to copy the tail in one go,\n+            // this means that we first shift the head forwards, and then\n+            // copy the tail to the correct position.\n             //\n             // from: FGH....ABCDE\n             // to:   ...ABCDEFGH.\n             unsafe {\n-                ptr::copy(buf.add(self.tail), buf.add(self.head), tail_len);\n+                self.copy(head, tail, head_len);\n                 // FGHABCDE....\n-                ptr::copy_nonoverlapping(buf, buf.add(self.head + tail_len), self.head);\n+                self.copy_nonoverlapping(0, tail + head_len, tail_len);\n                 // ...ABCDEFGH.\n-\n-                self.tail = self.head;\n-                self.head = self.wrap_add(self.tail, len);\n             }\n+\n+            self.head = tail;\n         } else {\n-            // free is smaller than both head and tail,\n-            // this means we have to slowly \"swap\" the tail and the head.\n+            // `free` is smaller than both `head_len` and `tail_len`.\n+            // the general algorithm for this first moves the slices\n+            // right next to each other and then uses `slice::rotate`\n+            // to rotate them into place:\n             //\n-            // from: EFGHI...ABCD or HIJK.ABCDEFG\n-            // to:   ABCDEFGHI... or ABCDEFGHIJK.\n-            let mut left_edge: usize = 0;\n-            let mut right_edge: usize = self.tail;\n-            unsafe {\n-                // The general problem looks like this\n-                // GHIJKLM...ABCDEF - before any swaps\n-                // ABCDEFM...GHIJKL - after 1 pass of swaps\n-                // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n-                //                  - then restart the algorithm with a new (smaller) store\n-                // Sometimes the temp store is reached when the right edge is at the end\n-                // of the buffer - this means we've hit the right order with fewer swaps!\n-                // E.g\n-                // EF..ABCD\n-                // ABCDEF.. - after four only swaps we've finished\n-                while left_edge < len && right_edge != cap {\n-                    let mut right_offset = 0;\n-                    for i in left_edge..right_edge {\n-                        right_offset = (i - left_edge) % (cap - right_edge);\n-                        let src = right_edge + right_offset;\n-                        ptr::swap(buf.add(i), buf.add(src));\n+            // initially:   HIJK..ABCDEFG\n+            // step 1:      ..HIJKABCDEFG\n+            // step 2:      ..ABCDEFGHIJK\n+            //\n+            // or:\n+            //\n+            // initially:   FGHIJK..ABCDE\n+            // step 1:      FGHIJKABCDE..\n+            // step 2:      ABCDEFGHIJK..\n+\n+            // pick the shorter of the 2 slices to reduce the amount\n+            // of memory that needs to be moved around.\n+            if head_len > tail_len {\n+                // tail is shorter, so:\n+                //  1. copy tail forwards\n+                //  2. rotate used part of the buffer\n+                //  3. update head to point to the new beginning (which is just `free`)\n+\n+                unsafe {\n+                    // if there is no free space in the buffer, then the slices are already\n+                    // right next to each other and we don't need to move any memory.\n+                    if free != 0 {\n+                        // because we only move the tail forward as much as there's free space\n+                        // behind it, we don't overwrite any elements of the head slice, and\n+                        // the slices end up right next to each other.\n+                        self.copy(0, free, tail_len);\n                     }\n-                    let n_ops = right_edge - left_edge;\n-                    left_edge += n_ops;\n-                    right_edge += right_offset + 1;\n+\n+                    // We just copied the tail right next to the head slice,\n+                    // so all of the elements in the range are initialized\n+                    let slice = &mut *self.buffer_range(free..self.capacity());\n+\n+                    // because the deque wasn't contiguous, we know that `tail_len < self.len == slice.len()`,\n+                    // so this will never panic.\n+                    slice.rotate_left(tail_len);\n+\n+                    // the used part of the buffer now is `free..self.capacity()`, so set\n+                    // `head` to the beginning of that range.\n+                    self.head = free;\n                 }\n+            } else {\n+                // head is shorter so:\n+                //  1. copy head backwards\n+                //  2. rotate used part of the buffer\n+                //  3. update head to point to the new beginning (which is the beginning of the buffer)\n+\n+                unsafe {\n+                    // if there is no free space in the buffer, then the slices are already\n+                    // right next to each other and we don't need to move any memory.\n+                    if free != 0 {\n+                        // copy the head slice to lie right behind the tail slice.\n+                        self.copy(self.head, tail_len, head_len);\n+                    }\n+\n+                    // because we copied the head slice so that both slices lie right\n+                    // next to each other, all the elements in the range are initialized.\n+                    let slice = &mut *self.buffer_range(0..self.len);\n \n-                self.tail = 0;\n-                self.head = len;\n+                    // because the deque wasn't contiguous, we know that `head_len < self.len == slice.len()`\n+                    // so this will never panic.\n+                    slice.rotate_right(head_len);\n+\n+                    // the used part of the buffer now is `0..self.len`, so set\n+                    // `head` to the beginning of that range.\n+                    self.head = 0;\n+                }\n             }\n         }\n \n-        let tail = self.tail;\n-        let head = self.head;\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            MaybeUninit::slice_assume_init_mut(\n-                RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0,\n-            )\n-        }\n+        unsafe { slice::from_raw_parts_mut(ptr.add(self.head), self.len) }\n     }\n \n     /// Rotates the double-ended queue `mid` places to the left.\n@@ -2513,7 +2263,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n     pub fn rotate_left(&mut self, mid: usize) {\n         assert!(mid <= self.len());\n-        let k = self.len() - mid;\n+        let k = self.len - mid;\n         if mid <= k {\n             unsafe { self.rotate_left_inner(mid) }\n         } else {\n@@ -2556,7 +2306,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n     pub fn rotate_right(&mut self, k: usize) {\n         assert!(k <= self.len());\n-        let mid = self.len() - k;\n+        let mid = self.len - k;\n         if k <= mid {\n             unsafe { self.rotate_right_inner(k) }\n         } else {\n@@ -2567,26 +2317,24 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     // SAFETY: the following two methods require that the rotation amount\n     // be less than half the length of the deque.\n     //\n-    // `wrap_copy` requires that `min(x, cap() - x) + copy_len <= cap()`,\n-    // but than `min` is never more than half the capacity, regardless of x,\n+    // `wrap_copy` requires that `min(x, capacity() - x) + copy_len <= capacity()`,\n+    // but then `min` is never more than half the capacity, regardless of x,\n     // so it's sound to call here because we're calling with something\n     // less than half the length, which is never above half the capacity.\n \n     unsafe fn rotate_left_inner(&mut self, mid: usize) {\n         debug_assert!(mid * 2 <= self.len());\n         unsafe {\n-            self.wrap_copy(self.head, self.tail, mid);\n+            self.wrap_copy(self.head, self.to_physical_idx(self.len), mid);\n         }\n-        self.head = self.wrap_add(self.head, mid);\n-        self.tail = self.wrap_add(self.tail, mid);\n+        self.head = self.to_physical_idx(mid);\n     }\n \n     unsafe fn rotate_right_inner(&mut self, k: usize) {\n         debug_assert!(k * 2 <= self.len());\n         self.head = self.wrap_sub(self.head, k);\n-        self.tail = self.wrap_sub(self.tail, k);\n         unsafe {\n-            self.wrap_copy(self.tail, self.head, k);\n+            self.wrap_copy(self.to_physical_idx(self.len), self.head, k);\n         }\n     }\n \n@@ -2844,23 +2592,19 @@ impl<T: Clone, A: Allocator> VecDeque<T, A> {\n \n /// Returns the index in the underlying buffer for a given logical element index.\n #[inline]\n-fn wrap_index(index: usize, size: usize) -> usize {\n-    // size is always a power of 2\n-    debug_assert!(size.is_power_of_two());\n-    index & (size - 1)\n-}\n-\n-/// Calculate the number of elements left to be read in the buffer\n-#[inline]\n-fn count(tail: usize, head: usize, size: usize) -> usize {\n-    // size is always a power of 2\n-    (head.wrapping_sub(tail)) & (size - 1)\n+fn wrap_index(logical_index: usize, capacity: usize) -> usize {\n+    debug_assert!(\n+        (logical_index == 0 && capacity == 0)\n+            || logical_index < capacity\n+            || (logical_index - capacity) < capacity\n+    );\n+    if logical_index >= capacity { logical_index - capacity } else { logical_index }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq, A: Allocator> PartialEq for VecDeque<T, A> {\n     fn eq(&self, other: &Self) -> bool {\n-        if self.len() != other.len() {\n+        if self.len != other.len() {\n             return false;\n         }\n         let (sa, sb) = self.as_slices();\n@@ -2924,7 +2668,7 @@ impl<T: Ord, A: Allocator> Ord for VecDeque<T, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash, A: Allocator> Hash for VecDeque<T, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        state.write_length_prefix(self.len());\n+        state.write_length_prefix(self.len);\n         // It's not possible to use Hash::hash_slice on slices\n         // returned by as_slices method as their length can vary\n         // in otherwise identical deques.\n@@ -3033,7 +2777,7 @@ impl<'a, T: 'a + Copy, A: Allocator> Extend<&'a T> for VecDeque<T, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug, A: Allocator> fmt::Debug for VecDeque<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_list().entries(self).finish()\n+        f.debug_list().entries(self.iter()).finish()\n     }\n }\n \n@@ -3044,31 +2788,12 @@ impl<T, A: Allocator> From<Vec<T, A>> for VecDeque<T, A> {\n     /// [`Vec<T>`]: crate::vec::Vec\n     /// [`VecDeque<T>`]: crate::collections::VecDeque\n     ///\n-    /// This avoids reallocating where possible, but the conditions for that are\n-    /// strict, and subject to change, and so shouldn't be relied upon unless the\n-    /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n-    fn from(mut other: Vec<T, A>) -> Self {\n-        let len = other.len();\n-        if T::IS_ZST {\n-            // There's no actual allocation for ZSTs to worry about capacity,\n-            // but `VecDeque` can't handle as much length as `Vec`.\n-            assert!(len < MAXIMUM_ZST_CAPACITY, \"capacity overflow\");\n-        } else {\n-            // We need to resize if the capacity is not a power of two, too small or\n-            // doesn't have at least one free space. We do this while it's still in\n-            // the `Vec` so the items will drop on panic.\n-            let min_cap = cmp::max(MINIMUM_CAPACITY, len) + 1;\n-            let cap = cmp::max(min_cap, other.capacity()).next_power_of_two();\n-            if other.capacity() != cap {\n-                other.reserve_exact(cap - len);\n-            }\n-        }\n-\n-        unsafe {\n-            let (other_buf, len, capacity, alloc) = other.into_raw_parts_with_alloc();\n-            let buf = RawVec::from_raw_parts_in(other_buf, capacity, alloc);\n-            VecDeque { tail: 0, head: len, buf }\n-        }\n+    /// In its current implementation, this is a very cheap\n+    /// conversion. This isn't yet a guarantee though, and\n+    /// shouldn't be relied on.\n+    fn from(other: Vec<T, A>) -> Self {\n+        let (ptr, len, cap, alloc) = other.into_raw_parts_with_alloc();\n+        Self { head: 0, len, buf: unsafe { RawVec::from_raw_parts_in(ptr, cap, alloc) } }\n     }\n }\n \n@@ -3110,11 +2835,11 @@ impl<T, A: Allocator> From<VecDeque<T, A>> for Vec<T, A> {\n             let other = ManuallyDrop::new(other);\n             let buf = other.buf.ptr();\n             let len = other.len();\n-            let cap = other.cap();\n+            let cap = other.capacity();\n             let alloc = ptr::read(other.allocator());\n \n-            if other.tail != 0 {\n-                ptr::copy(buf.add(other.tail), buf, len);\n+            if other.head != 0 {\n+                ptr::copy(buf.add(other.head), buf, len);\n             }\n             Vec::from_raw_parts_in(buf, len, cap, alloc)\n         }\n@@ -3141,8 +2866,8 @@ impl<T, const N: usize> From<[T; N]> for VecDeque<T> {\n                 ptr::copy_nonoverlapping(arr.as_ptr(), deq.ptr(), N);\n             }\n         }\n-        deq.tail = 0;\n-        deq.head = N;\n+        deq.head = 0;\n+        deq.len = N;\n         deq\n     }\n }"}, {"sha": "6735424a3ef33c1c04dd1094f0dcbe5e620fc06a", "filename": "library/alloc/src/collections/vec_deque/pair_slices.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/80ab672b8611d34bf811d4498b9b9d116a085e7c/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ab672b8611d34bf811d4498b9b9d116a085e7c/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs?ref=80ab672b8611d34bf811d4498b9b9d116a085e7c", "patch": "@@ -1,67 +0,0 @@\n-use core::cmp::{self};\n-use core::mem::replace;\n-\n-use crate::alloc::Allocator;\n-\n-use super::VecDeque;\n-\n-/// PairSlices pairs up equal length slice parts of two deques\n-///\n-/// For example, given deques \"A\" and \"B\" with the following division into slices:\n-///\n-/// A: [0 1 2] [3 4 5]\n-/// B: [a b] [c d e]\n-///\n-/// It produces the following sequence of matching slices:\n-///\n-/// ([0 1], [a b])\n-/// (\\[2\\], \\[c\\])\n-/// ([3 4], [d e])\n-///\n-/// and the uneven remainder of either A or B is skipped.\n-pub struct PairSlices<'a, 'b, T> {\n-    a0: &'a mut [T],\n-    a1: &'a mut [T],\n-    b0: &'b [T],\n-    b1: &'b [T],\n-}\n-\n-impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n-    pub fn from<A: Allocator>(to: &'a mut VecDeque<T, A>, from: &'b VecDeque<T, A>) -> Self {\n-        let (a0, a1) = to.as_mut_slices();\n-        let (b0, b1) = from.as_slices();\n-        PairSlices { a0, a1, b0, b1 }\n-    }\n-\n-    pub fn has_remainder(&self) -> bool {\n-        !self.b0.is_empty()\n-    }\n-\n-    pub fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n-        IntoIterator::into_iter([self.b0, self.b1])\n-    }\n-}\n-\n-impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T> {\n-    type Item = (&'a mut [T], &'b [T]);\n-    fn next(&mut self) -> Option<Self::Item> {\n-        // Get next part length\n-        let part = cmp::min(self.a0.len(), self.b0.len());\n-        if part == 0 {\n-            return None;\n-        }\n-        let (p0, p1) = replace(&mut self.a0, &mut []).split_at_mut(part);\n-        let (q0, q1) = self.b0.split_at(part);\n-\n-        // Move a1 into a0, if it's empty (and b1, b0 the same way).\n-        self.a0 = p1;\n-        self.b0 = q1;\n-        if self.a0.is_empty() {\n-            self.a0 = replace(&mut self.a1, &mut []);\n-        }\n-        if self.b0.is_empty() {\n-            self.b0 = replace(&mut self.b1, &[]);\n-        }\n-        Some((p0, q0))\n-    }\n-}"}, {"sha": "dd0fa7d6074c00cbfed25293c649745930f564e9", "filename": "library/alloc/src/collections/vec_deque/ring_slices.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/80ab672b8611d34bf811d4498b9b9d116a085e7c/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ab672b8611d34bf811d4498b9b9d116a085e7c/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs?ref=80ab672b8611d34bf811d4498b9b9d116a085e7c", "patch": "@@ -1,56 +0,0 @@\n-use core::ptr::{self};\n-\n-/// Returns the two slices that cover the `VecDeque`'s valid range\n-pub trait RingSlices: Sized {\n-    fn slice(self, from: usize, to: usize) -> Self;\n-    fn split_at(self, i: usize) -> (Self, Self);\n-\n-    fn ring_slices(buf: Self, head: usize, tail: usize) -> (Self, Self) {\n-        let contiguous = tail <= head;\n-        if contiguous {\n-            let (empty, buf) = buf.split_at(0);\n-            (buf.slice(tail, head), empty)\n-        } else {\n-            let (mid, right) = buf.split_at(tail);\n-            let (left, _) = mid.split_at(head);\n-            (right, left)\n-        }\n-    }\n-}\n-\n-impl<T> RingSlices for &[T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        &self[from..to]\n-    }\n-    fn split_at(self, i: usize) -> (Self, Self) {\n-        (*self).split_at(i)\n-    }\n-}\n-\n-impl<T> RingSlices for &mut [T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        &mut self[from..to]\n-    }\n-    fn split_at(self, i: usize) -> (Self, Self) {\n-        (*self).split_at_mut(i)\n-    }\n-}\n-\n-impl<T> RingSlices for *mut [T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        assert!(from <= to && to < self.len());\n-        // Not using `get_unchecked_mut` to keep this a safe operation.\n-        let len = to - from;\n-        ptr::slice_from_raw_parts_mut(self.as_mut_ptr().wrapping_add(from), len)\n-    }\n-\n-    fn split_at(self, mid: usize) -> (Self, Self) {\n-        let len = self.len();\n-        let ptr = self.as_mut_ptr();\n-        assert!(mid <= len);\n-        (\n-            ptr::slice_from_raw_parts_mut(ptr, mid),\n-            ptr::slice_from_raw_parts_mut(ptr.wrapping_add(mid), len - mid),\n-        )\n-    }\n-}"}, {"sha": "dccf40ccb38aab69f0b3985120d8e9f8a168d1ca", "filename": "library/alloc/src/collections/vec_deque/spec_extend.rs", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,6 +1,6 @@\n use crate::alloc::Allocator;\n use crate::vec;\n-use core::iter::{ByRefSized, TrustedLen};\n+use core::iter::TrustedLen;\n use core::slice;\n \n use super::VecDeque;\n@@ -17,19 +17,33 @@ where\n     default fn spec_extend(&mut self, mut iter: I) {\n         // This function should be the moral equivalent of:\n         //\n-        //      for item in iter {\n-        //          self.push_back(item);\n-        //      }\n-        while let Some(element) = iter.next() {\n-            if self.len() == self.capacity() {\n-                let (lower, _) = iter.size_hint();\n-                self.reserve(lower.saturating_add(1));\n-            }\n+        // for item in iter {\n+        //     self.push_back(item);\n+        // }\n+\n+        // May only be called if `deque.len() < deque.capacity()`\n+        unsafe fn push_unchecked<T, A: Allocator>(deque: &mut VecDeque<T, A>, element: T) {\n+            // SAFETY: Because of the precondition, it's guaranteed that there is space\n+            // in the logical array after the last element.\n+            unsafe { deque.buffer_write(deque.to_physical_idx(deque.len), element) };\n+            // This can't overflow because `deque.len() < deque.capacity() <= usize::MAX`.\n+            deque.len += 1;\n+        }\n \n-            let head = self.head;\n-            self.head = self.wrap_add(self.head, 1);\n-            unsafe {\n-                self.buffer_write(head, element);\n+        while let Some(element) = iter.next() {\n+            let (lower, _) = iter.size_hint();\n+            self.reserve(lower.saturating_add(1));\n+\n+            // SAFETY: We just reserved space for at least one element.\n+            unsafe { push_unchecked(self, element) };\n+\n+            // Inner loop to avoid repeatedly calling `reserve`.\n+            while self.len < self.capacity() {\n+                let Some(element) = iter.next() else {\n+                    return;\n+                };\n+                // SAFETY: The loop condition guarantees that `self.len() < self.capacity()`.\n+                unsafe { push_unchecked(self, element) };\n             }\n         }\n     }\n@@ -39,7 +53,7 @@ impl<T, I, A: Allocator> SpecExtend<T, I> for VecDeque<T, A>\n where\n     I: TrustedLen<Item = T>,\n {\n-    default fn spec_extend(&mut self, mut iter: I) {\n+    default fn spec_extend(&mut self, iter: I) {\n         // This is the case for a TrustedLen iterator.\n         let (low, high) = iter.size_hint();\n         if let Some(additional) = high {\n@@ -51,35 +65,12 @@ where\n             );\n             self.reserve(additional);\n \n-            struct WrapAddOnDrop<'a, T, A: Allocator> {\n-                vec_deque: &'a mut VecDeque<T, A>,\n-                written: usize,\n-            }\n-\n-            impl<'a, T, A: Allocator> Drop for WrapAddOnDrop<'a, T, A> {\n-                fn drop(&mut self) {\n-                    self.vec_deque.head =\n-                        self.vec_deque.wrap_add(self.vec_deque.head, self.written);\n-                }\n-            }\n-\n-            let mut wrapper = WrapAddOnDrop { vec_deque: self, written: 0 };\n-\n-            let head_room = wrapper.vec_deque.cap() - wrapper.vec_deque.head;\n-            unsafe {\n-                wrapper.vec_deque.write_iter(\n-                    wrapper.vec_deque.head,\n-                    ByRefSized(&mut iter).take(head_room),\n-                    &mut wrapper.written,\n-                );\n-\n-                if additional > head_room {\n-                    wrapper.vec_deque.write_iter(0, iter, &mut wrapper.written);\n-                }\n-            }\n+            let written = unsafe {\n+                self.write_iter_wrapping(self.to_physical_idx(self.len), iter, additional)\n+            };\n \n             debug_assert_eq!(\n-                additional, wrapper.written,\n+                additional, written,\n                 \"The number of items written to VecDeque doesn't match the TrustedLen size hint\"\n             );\n         } else {\n@@ -99,8 +90,8 @@ impl<T, A: Allocator> SpecExtend<T, vec::IntoIter<T>> for VecDeque<T, A> {\n         self.reserve(slice.len());\n \n         unsafe {\n-            self.copy_slice(self.head, slice);\n-            self.head = self.wrap_add(self.head, slice.len());\n+            self.copy_slice(self.to_physical_idx(self.len), slice);\n+            self.len += slice.len();\n         }\n         iterator.forget_remaining_elements();\n     }\n@@ -125,8 +116,8 @@ where\n         self.reserve(slice.len());\n \n         unsafe {\n-            self.copy_slice(self.head, slice);\n-            self.head = self.wrap_add(self.head, slice.len());\n+            self.copy_slice(self.to_physical_idx(self.len), slice);\n+            self.len += slice.len();\n         }\n     }\n }"}, {"sha": "220ad71beabd43081f01769b53551fd16e3139ce", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 119, "deletions": 101, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -10,7 +10,7 @@ fn bench_push_back_100(b: &mut test::Bencher) {\n             deq.push_back(i);\n         }\n         deq.head = 0;\n-        deq.tail = 0;\n+        deq.len = 0;\n     })\n }\n \n@@ -22,7 +22,7 @@ fn bench_push_front_100(b: &mut test::Bencher) {\n             deq.push_front(i);\n         }\n         deq.head = 0;\n-        deq.tail = 0;\n+        deq.len = 0;\n     })\n }\n \n@@ -35,8 +35,8 @@ fn bench_pop_back_100(b: &mut test::Bencher) {\n     unsafe { deq.ptr().write_bytes(0u8, size + 1) };\n \n     b.iter(|| {\n-        deq.head = size;\n-        deq.tail = 0;\n+        deq.head = 0;\n+        deq.len = 100;\n         while !deq.is_empty() {\n             test::black_box(deq.pop_back());\n         }\n@@ -85,8 +85,8 @@ fn bench_pop_front_100(b: &mut test::Bencher) {\n     unsafe { deq.ptr().write_bytes(0u8, size + 1) };\n \n     b.iter(|| {\n-        deq.head = size;\n-        deq.tail = 0;\n+        deq.head = 0;\n+        deq.len = 100;\n         while !deq.is_empty() {\n             test::black_box(deq.pop_front());\n         }\n@@ -105,9 +105,9 @@ fn test_swap_front_back_remove() {\n         for len in 0..final_len {\n             let expected: VecDeque<_> =\n                 if back { (0..len).collect() } else { (0..len).rev().collect() };\n-            for tail_pos in 0..usable_cap {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n+            for head_pos in 0..usable_cap {\n+                tester.head = head_pos;\n+                tester.len = 0;\n                 if back {\n                     for i in 0..len * 2 {\n                         tester.push_front(i);\n@@ -124,8 +124,8 @@ fn test_swap_front_back_remove() {\n                         assert_eq!(tester.swap_remove_front(idx), Some(len * 2 - 1 - i));\n                     }\n                 }\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n+                assert!(tester.head <= tester.capacity());\n+                assert!(tester.len <= tester.capacity());\n                 assert_eq!(tester, expected);\n             }\n         }\n@@ -150,18 +150,18 @@ fn test_insert() {\n     for len in minlen..cap {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n-        for tail_pos in 0..cap {\n+        for head_pos in 0..cap {\n             for to_insert in 0..len {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n+                tester.head = head_pos;\n+                tester.len = 0;\n                 for i in 0..len {\n                     if i != to_insert {\n                         tester.push_back(i);\n                     }\n                 }\n                 tester.insert(to_insert, to_insert);\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n+                assert!(tester.head <= tester.capacity());\n+                assert!(tester.len <= tester.capacity());\n                 assert_eq!(tester, expected);\n             }\n         }\n@@ -257,13 +257,14 @@ fn test_swap_panic() {\n #[test]\n fn test_reserve_exact() {\n     let mut tester: VecDeque<i32> = VecDeque::with_capacity(1);\n-    assert!(tester.capacity() == 1);\n+    assert_eq!(tester.capacity(), 1);\n     tester.reserve_exact(50);\n-    assert!(tester.capacity() >= 51);\n+    assert_eq!(tester.capacity(), 50);\n     tester.reserve_exact(40);\n-    assert!(tester.capacity() >= 51);\n+    // reserving won't shrink the buffer\n+    assert_eq!(tester.capacity(), 50);\n     tester.reserve_exact(200);\n-    assert!(tester.capacity() >= 200);\n+    assert_eq!(tester.capacity(), 200);\n }\n \n #[test]\n@@ -323,6 +324,7 @@ fn test_contains() {\n #[test]\n fn test_rotate_left_right() {\n     let mut tester: VecDeque<_> = (1..=10).collect();\n+    tester.reserve(1);\n \n     assert_eq!(tester.len(), 10);\n \n@@ -463,7 +465,7 @@ fn test_binary_search_key() {\n }\n \n #[test]\n-fn make_contiguous_big_tail() {\n+fn make_contiguous_big_head() {\n     let mut tester = VecDeque::with_capacity(15);\n \n     for i in 0..3 {\n@@ -478,14 +480,14 @@ fn make_contiguous_big_tail() {\n     assert_eq!(tester.capacity(), 15);\n     assert_eq!((&[9, 8, 7, 6, 5, 4, 3] as &[_], &[0, 1, 2] as &[_]), tester.as_slices());\n \n-    let expected_start = tester.head;\n+    let expected_start = tester.as_slices().1.len();\n     tester.make_contiguous();\n-    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(tester.head, expected_start);\n     assert_eq!((&[9, 8, 7, 6, 5, 4, 3, 0, 1, 2] as &[_], &[] as &[_]), tester.as_slices());\n }\n \n #[test]\n-fn make_contiguous_big_head() {\n+fn make_contiguous_big_tail() {\n     let mut tester = VecDeque::with_capacity(15);\n \n     for i in 0..8 {\n@@ -499,44 +501,46 @@ fn make_contiguous_big_head() {\n     // 01234567......98\n     let expected_start = 0;\n     tester.make_contiguous();\n-    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(tester.head, expected_start);\n     assert_eq!((&[9, 8, 0, 1, 2, 3, 4, 5, 6, 7] as &[_], &[] as &[_]), tester.as_slices());\n }\n \n #[test]\n fn make_contiguous_small_free() {\n-    let mut tester = VecDeque::with_capacity(15);\n+    let mut tester = VecDeque::with_capacity(16);\n \n-    for i in 'A' as u8..'I' as u8 {\n+    for i in b'A'..b'I' {\n         tester.push_back(i as char);\n     }\n \n-    for i in 'I' as u8..'N' as u8 {\n+    for i in b'I'..b'N' {\n         tester.push_front(i as char);\n     }\n \n+    assert_eq!(tester, ['M', 'L', 'K', 'J', 'I', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']);\n+\n     // ABCDEFGH...MLKJI\n     let expected_start = 0;\n     tester.make_contiguous();\n-    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(tester.head, expected_start);\n     assert_eq!(\n         (&['M', 'L', 'K', 'J', 'I', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] as &[_], &[] as &[_]),\n         tester.as_slices()\n     );\n \n     tester.clear();\n-    for i in 'I' as u8..'N' as u8 {\n+    for i in b'I'..b'N' {\n         tester.push_back(i as char);\n     }\n \n-    for i in 'A' as u8..'I' as u8 {\n+    for i in b'A'..b'I' {\n         tester.push_front(i as char);\n     }\n \n     // IJKLM...HGFEDCBA\n-    let expected_start = 0;\n+    let expected_start = 3;\n     tester.make_contiguous();\n-    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(tester.head, expected_start);\n     assert_eq!(\n         (&['H', 'G', 'F', 'E', 'D', 'C', 'B', 'A', 'I', 'J', 'K', 'L', 'M'] as &[_], &[] as &[_]),\n         tester.as_slices()\n@@ -545,16 +549,55 @@ fn make_contiguous_small_free() {\n \n #[test]\n fn make_contiguous_head_to_end() {\n-    let mut dq = VecDeque::with_capacity(3);\n-    dq.push_front('B');\n-    dq.push_front('A');\n-    dq.push_back('C');\n-    dq.make_contiguous();\n-    let expected_tail = 0;\n-    let expected_head = 3;\n-    assert_eq!(expected_tail, dq.tail);\n-    assert_eq!(expected_head, dq.head);\n-    assert_eq!((&['A', 'B', 'C'] as &[_], &[] as &[_]), dq.as_slices());\n+    let mut tester = VecDeque::with_capacity(16);\n+\n+    for i in b'A'..b'L' {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in b'L'..b'Q' {\n+        tester.push_front(i as char);\n+    }\n+\n+    assert_eq!(\n+        tester,\n+        ['P', 'O', 'N', 'M', 'L', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']\n+    );\n+\n+    // ABCDEFGHIJKPONML\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.head, expected_start);\n+    assert_eq!(\n+        (\n+            &['P', 'O', 'N', 'M', 'L', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']\n+                as &[_],\n+            &[] as &[_]\n+        ),\n+        tester.as_slices()\n+    );\n+\n+    tester.clear();\n+    for i in b'L'..b'Q' {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in b'A'..b'L' {\n+        tester.push_front(i as char);\n+    }\n+\n+    // LMNOPKJIHGFEDCBA\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.head, expected_start);\n+    assert_eq!(\n+        (\n+            &['K', 'J', 'I', 'H', 'G', 'F', 'E', 'D', 'C', 'B', 'A', 'L', 'M', 'N', 'O', 'P']\n+                as &[_],\n+            &[] as &[_]\n+        ),\n+        tester.as_slices()\n+    );\n }\n \n #[test]\n@@ -588,10 +631,10 @@ fn test_remove() {\n     for len in minlen..cap - 1 {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n-        for tail_pos in 0..cap {\n+        for head_pos in 0..cap {\n             for to_remove in 0..=len {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n+                tester.head = head_pos;\n+                tester.len = 0;\n                 for i in 0..len {\n                     if i == to_remove {\n                         tester.push_back(1234);\n@@ -602,8 +645,8 @@ fn test_remove() {\n                     tester.push_back(1234);\n                 }\n                 tester.remove(to_remove);\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n+                assert!(tester.head <= tester.capacity());\n+                assert!(tester.len <= tester.capacity());\n                 assert_eq!(tester, expected);\n             }\n         }\n@@ -617,11 +660,11 @@ fn test_range() {\n     let cap = tester.capacity();\n     let minlen = if cfg!(miri) { cap - 1 } else { 0 }; // Miri is too slow\n     for len in minlen..=cap {\n-        for tail in 0..=cap {\n+        for head in 0..=cap {\n             for start in 0..=len {\n                 for end in start..=len {\n-                    tester.tail = tail;\n-                    tester.head = tail;\n+                    tester.head = head;\n+                    tester.len = 0;\n                     for i in 0..len {\n                         tester.push_back(i);\n                     }\n@@ -642,17 +685,17 @@ fn test_range_mut() {\n \n     let cap = tester.capacity();\n     for len in 0..=cap {\n-        for tail in 0..=cap {\n+        for head in 0..=cap {\n             for start in 0..=len {\n                 for end in start..=len {\n-                    tester.tail = tail;\n-                    tester.head = tail;\n+                    tester.head = head;\n+                    tester.len = 0;\n                     for i in 0..len {\n                         tester.push_back(i);\n                     }\n \n                     let head_was = tester.head;\n-                    let tail_was = tester.tail;\n+                    let len_was = tester.len;\n \n                     // Check that we iterate over the correct values\n                     let range: VecDeque<_> = tester.range_mut(start..end).map(|v| *v).collect();\n@@ -662,8 +705,8 @@ fn test_range_mut() {\n                     // We shouldn't have changed the capacity or made the\n                     // head or tail out of bounds\n                     assert_eq!(tester.capacity(), cap);\n-                    assert_eq!(tester.tail, tail_was);\n                     assert_eq!(tester.head, head_was);\n+                    assert_eq!(tester.len, len_was);\n                 }\n             }\n         }\n@@ -676,11 +719,11 @@ fn test_drain() {\n \n     let cap = tester.capacity();\n     for len in 0..=cap {\n-        for tail in 0..=cap {\n+        for head in 0..cap {\n             for drain_start in 0..=len {\n                 for drain_end in drain_start..=len {\n-                    tester.tail = tail;\n-                    tester.head = tail;\n+                    tester.head = head;\n+                    tester.len = 0;\n                     for i in 0..len {\n                         tester.push_back(i);\n                     }\n@@ -693,8 +736,8 @@ fn test_drain() {\n                     // We shouldn't have changed the capacity or made the\n                     // head or tail out of bounds\n                     assert_eq!(tester.capacity(), cap);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n+                    assert!(tester.head <= tester.capacity());\n+                    assert!(tester.len <= tester.capacity());\n \n                     // We should see the correct values in the VecDeque\n                     let expected: VecDeque<_> = (0..drain_start).chain(drain_end..len).collect();\n@@ -721,17 +764,18 @@ fn test_shrink_to_fit() {\n     for len in 0..=cap {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n-        for tail_pos in 0..=max_cap {\n-            tester.tail = tail_pos;\n-            tester.head = tail_pos;\n+        for head_pos in 0..=max_cap {\n+            tester.reserve(head_pos);\n+            tester.head = head_pos;\n+            tester.len = 0;\n             tester.reserve(63);\n             for i in 0..len {\n                 tester.push_back(i);\n             }\n             tester.shrink_to_fit();\n             assert!(tester.capacity() <= cap);\n-            assert!(tester.tail < tester.cap());\n-            assert!(tester.head < tester.cap());\n+            assert!(tester.head <= tester.capacity());\n+            assert!(tester.len <= tester.capacity());\n             assert_eq!(tester, expected);\n         }\n     }\n@@ -758,17 +802,17 @@ fn test_split_off() {\n             // at, at + 1, .., len - 1 (may be empty)\n             let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n \n-            for tail_pos in 0..cap {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n+            for head_pos in 0..cap {\n+                tester.head = head_pos;\n+                tester.len = 0;\n                 for i in 0..len {\n                     tester.push_back(i);\n                 }\n                 let result = tester.split_off(at);\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n-                assert!(result.tail < result.cap());\n-                assert!(result.head < result.cap());\n+                assert!(tester.head <= tester.capacity());\n+                assert!(tester.len <= tester.capacity());\n+                assert!(result.head <= result.capacity());\n+                assert!(result.len <= result.capacity());\n                 assert_eq!(tester, expected_self);\n                 assert_eq!(result, expected_other);\n             }\n@@ -785,16 +829,10 @@ fn test_from_vec() {\n             vec.extend(0..len);\n \n             let vd = VecDeque::from(vec.clone());\n-            assert!(vd.cap().is_power_of_two());\n             assert_eq!(vd.len(), vec.len());\n             assert!(vd.into_iter().eq(vec));\n         }\n     }\n-\n-    let vec = Vec::from([(); MAXIMUM_ZST_CAPACITY - 1]);\n-    let vd = VecDeque::from(vec.clone());\n-    assert!(vd.cap().is_power_of_two());\n-    assert_eq!(vd.len(), vec.len());\n }\n \n #[test]\n@@ -846,10 +884,6 @@ fn test_extend_impl(trusted_len: bool) {\n             }\n \n             assert_eq!(self.test, self.expected);\n-            let (a1, b1) = self.test.as_slices();\n-            let (a2, b2) = self.expected.as_slices();\n-            assert_eq!(a1, a2);\n-            assert_eq!(b1, b2);\n         }\n \n         fn drain<R: RangeBounds<usize> + Clone>(&mut self, range: R) {\n@@ -872,15 +906,15 @@ fn test_extend_impl(trusted_len: bool) {\n     let mut tester = VecDequeTester::new(trusted_len);\n \n     // Initial capacity\n-    tester.test_extend(0..tester.remaining_capacity() - 1);\n+    tester.test_extend(0..tester.remaining_capacity());\n \n     // Grow\n     tester.test_extend(1024..2048);\n \n     // Wrap around\n     tester.drain(..128);\n \n-    tester.test_extend(0..tester.remaining_capacity() - 1);\n+    tester.test_extend(0..tester.remaining_capacity());\n \n     // Continue\n     tester.drain(256..);\n@@ -892,16 +926,6 @@ fn test_extend_impl(trusted_len: bool) {\n     tester.test_extend(0..32);\n }\n \n-#[test]\n-#[should_panic = \"capacity overflow\"]\n-fn test_from_vec_zst_overflow() {\n-    use crate::vec::Vec;\n-    let vec = Vec::from([(); MAXIMUM_ZST_CAPACITY]);\n-    let vd = VecDeque::from(vec.clone()); // no room for +1\n-    assert!(vd.cap().is_power_of_two());\n-    assert_eq!(vd.len(), vec.len());\n-}\n-\n #[test]\n fn test_from_array() {\n     fn test<const N: usize>() {\n@@ -917,19 +941,13 @@ fn test_from_array() {\n             assert_eq!(deq[i], i);\n         }\n \n-        assert!(deq.cap().is_power_of_two());\n         assert_eq!(deq.len(), N);\n     }\n     test::<0>();\n     test::<1>();\n     test::<2>();\n     test::<32>();\n     test::<35>();\n-\n-    let array = [(); MAXIMUM_ZST_CAPACITY - 1];\n-    let deq = VecDeque::from(array);\n-    assert!(deq.cap().is_power_of_two());\n-    assert_eq!(deq.len(), MAXIMUM_ZST_CAPACITY - 1);\n }\n \n #[test]"}, {"sha": "d04de5a074b7fafa3d186d6762a336141c133b2b", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -465,7 +465,6 @@ fn test_drain() {\n         for i in 6..9 {\n             d.push_front(i);\n         }\n-\n         assert_eq!(d.drain(..).collect::<Vec<_>>(), [8, 7, 6, 0, 1, 2, 3, 4]);\n         assert!(d.is_empty());\n     }\n@@ -1142,7 +1141,7 @@ fn test_reserve_exact_2() {\n     v.push_back(16);\n \n     v.reserve_exact(16);\n-    assert!(v.capacity() >= 48)\n+    assert!(v.capacity() >= 33)\n }\n \n #[test]\n@@ -1157,7 +1156,7 @@ fn test_try_reserve() {\n     // * overflow may trigger when adding `len` to `cap` (in number of elements)\n     // * overflow may trigger when multiplying `new_cap` by size_of::<T> (to get bytes)\n \n-    const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n+    const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n     {\n@@ -1248,7 +1247,7 @@ fn test_try_reserve_exact() {\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments.\n \n-    const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n+    const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n     {\n@@ -1391,7 +1390,8 @@ fn test_rotate_nop() {\n \n #[test]\n fn test_rotate_left_parts() {\n-    let mut v: VecDeque<_> = (1..=7).collect();\n+    let mut v: VecDeque<_> = VecDeque::with_capacity(8);\n+    v.extend(1..=7);\n     v.rotate_left(2);\n     assert_eq!(v.as_slices(), (&[3, 4, 5, 6, 7, 1][..], &[2][..]));\n     v.rotate_left(2);\n@@ -1410,7 +1410,8 @@ fn test_rotate_left_parts() {\n \n #[test]\n fn test_rotate_right_parts() {\n-    let mut v: VecDeque<_> = (1..=7).collect();\n+    let mut v: VecDeque<_> = VecDeque::with_capacity(8);\n+    v.extend(1..=7);\n     v.rotate_right(2);\n     assert_eq!(v.as_slices(), (&[6, 7][..], &[1, 2, 3, 4, 5][..]));\n     v.rotate_right(2);"}, {"sha": "8ba1c122884ca431173cc28a77d33b6282e7169d", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 170, "deletions": 4, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -80,6 +80,8 @@ define!(\"mir_goto\", fn Goto(destination: BasicBlock) -> BasicBlock);\n define!(\"mir_retag\", fn Retag<T>(place: T));\n define!(\"mir_retag_raw\", fn RetagRaw<T>(place: T));\n define!(\"mir_move\", fn Move<T>(place: T) -> T);\n+define!(\"mir_static\", fn Static<T>(s: T) -> &'static T);\n+define!(\"mir_static_mut\", fn StaticMut<T>(s: T) -> *mut T);\n \n /// Convenience macro for generating custom MIR.\n ///\n@@ -90,10 +92,14 @@ pub macro mir {\n     (\n         $(let $local_decl:ident $(: $local_decl_ty:ty)? ;)*\n \n-        $entry_block:block\n+        {\n+            $($entry:tt)*\n+        }\n \n         $(\n-            $block_name:ident = $block:block\n+            $block_name:ident = {\n+                $($block:tt)*\n+            }\n         )*\n     ) => {{\n         // First, we declare all basic blocks.\n@@ -109,15 +115,175 @@ pub macro mir {\n                 let $local_decl $(: $local_decl_ty)? ;\n             )*\n \n+            ::core::intrinsics::mir::__internal_extract_let!($($entry)*);\n+            $(\n+                ::core::intrinsics::mir::__internal_extract_let!($($block)*);\n+            )*\n+\n             {\n                 // Finally, the contents of the basic blocks\n-                $entry_block;\n+                ::core::intrinsics::mir::__internal_remove_let!({\n+                    {}\n+                    { $($entry)* }\n+                });\n                 $(\n-                    $block;\n+                    ::core::intrinsics::mir::__internal_remove_let!({\n+                        {}\n+                        { $($block)* }\n+                    });\n                 )*\n \n                 RET\n             }\n         }\n     }}\n }\n+\n+/// Helper macro that extracts the `let` declarations out of a bunch of statements.\n+///\n+/// This macro is written using the \"statement muncher\" strategy. Each invocation parses the first\n+/// statement out of the input, does the appropriate thing with it, and then recursively calls the\n+/// same macro on the remainder of the input.\n+#[doc(hidden)]\n+pub macro __internal_extract_let {\n+    // If it's a `let` like statement, keep the `let`\n+    (\n+        let $var:ident $(: $ty:ty)? = $expr:expr; $($rest:tt)*\n+    ) => {\n+        let $var $(: $ty)?;\n+        ::core::intrinsics::mir::__internal_extract_let!($($rest)*);\n+    },\n+    // Due to #86730, we have to handle const blocks separately\n+    (\n+        let $var:ident $(: $ty:ty)? = const $block:block; $($rest:tt)*\n+    ) => {\n+        let $var $(: $ty)?;\n+        ::core::intrinsics::mir::__internal_extract_let!($($rest)*);\n+    },\n+    // Otherwise, output nothing\n+    (\n+        $stmt:stmt; $($rest:tt)*\n+    ) => {\n+        ::core::intrinsics::mir::__internal_extract_let!($($rest)*);\n+    },\n+    (\n+        $expr:expr\n+    ) => {}\n+}\n+\n+/// Helper macro that removes the `let` declarations from a bunch of statements.\n+///\n+/// Because expression position macros cannot expand to statements + expressions, we need to be\n+/// slightly creative here. The general strategy is also statement munching as above, but the output\n+/// of the macro is \"stored\" in the subsequent macro invocation. Easiest understood via example:\n+/// ```text\n+/// invoke!(\n+///     {\n+///         {\n+///             x = 5;\n+///         }\n+///         {\n+///             let d = e;\n+///             Call()\n+///         }\n+///     }\n+/// )\n+/// ```\n+/// becomes\n+/// ```text\n+/// invoke!(\n+///     {\n+///         {\n+///             x = 5;\n+///             d = e;\n+///         }\n+///         {\n+///             Call()\n+///         }\n+///     }\n+/// )\n+/// ```\n+#[doc(hidden)]\n+pub macro __internal_remove_let {\n+    // If it's a `let` like statement, remove the `let`\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                let $var:ident $(: $ty:ty)? = $expr:expr;\n+                $($rest:tt)*\n+            }\n+        }\n+    ) => { ::core::intrinsics::mir::__internal_remove_let!(\n+        {\n+            {\n+                $($already_parsed)*\n+                $var = $expr;\n+            }\n+            {\n+                $($rest)*\n+            }\n+        }\n+    )},\n+    // Due to #86730 , we have to handle const blocks separately\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                let $var:ident $(: $ty:ty)? = const $block:block;\n+                $($rest:tt)*\n+            }\n+        }\n+    ) => { ::core::intrinsics::mir::__internal_remove_let!(\n+        {\n+            {\n+                $($already_parsed)*\n+                $var = const $block;\n+            }\n+            {\n+                $($rest)*\n+            }\n+        }\n+    )},\n+    // Otherwise, keep going\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                $stmt:stmt;\n+                $($rest:tt)*\n+            }\n+        }\n+    ) => { ::core::intrinsics::mir::__internal_remove_let!(\n+        {\n+            {\n+                $($already_parsed)*\n+                $stmt;\n+            }\n+            {\n+                $($rest)*\n+            }\n+        }\n+    )},\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                $expr:expr\n+            }\n+        }\n+    ) => {\n+        {\n+            $($already_parsed)*\n+            $expr\n+        }\n+    },\n+}"}, {"sha": "f29cd357d6bfd5218ab7489a3d40148b184d8231", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1546,6 +1546,18 @@ pub(crate) mod builtin {\n         /* compiler built-in */\n     }\n \n+    /// Unstable placeholder for type ascription.\n+    #[rustc_builtin_macro]\n+    #[unstable(\n+        feature = \"type_ascription\",\n+        issue = \"23416\",\n+        reason = \"placeholder syntax for type ascription\"\n+    )]\n+    #[cfg(not(bootstrap))]\n+    pub macro type_ascribe($expr:expr, $ty:ty) {\n+        /* compiler built-in */\n+    }\n+\n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "383bdc7b6e2e9f945d008186a4574744b186a92d", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1113,7 +1113,10 @@ impl<T> fmt::Debug for Discriminant<T> {\n /// # Stability\n ///\n /// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n-/// of some variant will not change between compilations with the same compiler.\n+/// of some variant will not change between compilations with the same compiler. See the [Reference]\n+/// for more information.\n+///\n+/// [Reference]: ../../reference/items/enumerations.html#custom-discriminant-values-for-fieldless-enumerations\n ///\n /// # Examples\n ///\n@@ -1129,6 +1132,62 @@ impl<T> fmt::Debug for Discriminant<T> {\n /// assert_eq!(mem::discriminant(&Foo::B(1)), mem::discriminant(&Foo::B(2)));\n /// assert_ne!(mem::discriminant(&Foo::B(3)), mem::discriminant(&Foo::C(3)));\n /// ```\n+///\n+/// ## Accessing the numeric value of the discriminant\n+///\n+/// Note that it is *undefined behavior* to [`transmute`] from [`Discriminant`] to a primitive!\n+///\n+/// If an enum has only unit variants, then the numeric value of the discriminant can be accessed\n+/// with an [`as`] cast:\n+///\n+/// ```\n+/// enum Enum {\n+///     Foo,\n+///     Bar,\n+///     Baz,\n+/// }\n+///\n+/// assert_eq!(0, Enum::Foo as isize);\n+/// assert_eq!(1, Enum::Bar as isize);\n+/// assert_eq!(2, Enum::Baz as isize);\n+/// ```\n+///\n+/// If an enum has opted-in to having a [primitive representation] for its discriminant,\n+/// then it's possible to use pointers to read the memory location storing the discriminant.\n+/// That **cannot** be done for enums using the [default representation], however, as it's\n+/// undefined what layout the discriminant has and where it's stored \u2014 it might not even be\n+/// stored at all!\n+///\n+/// [`as`]: ../../std/keyword.as.html\n+/// [primitive representation]: ../../reference/type-layout.html#primitive-representations\n+/// [default representation]: ../../reference/type-layout.html#the-default-representation\n+/// ```\n+/// #[repr(u8)]\n+/// enum Enum {\n+///     Unit,\n+///     Tuple(bool),\n+///     Struct { a: bool },\n+/// }\n+///\n+/// impl Enum {\n+///     fn discriminant(&self) -> u8 {\n+///         // SAFETY: Because `Self` is marked `repr(u8)`, its layout is a `repr(C)` `union`\n+///         // between `repr(C)` structs, each of which has the `u8` discriminant as its first\n+///         // field, so we can read the discriminant without offsetting the pointer.\n+///         unsafe { *<*const _>::from(self).cast::<u8>() }\n+///     }\n+/// }\n+///\n+/// let unit_like = Enum::Unit;\n+/// let tuple_like = Enum::Tuple(true);\n+/// let struct_like = Enum::Struct { a: false };\n+/// assert_eq!(0, unit_like.discriminant());\n+/// assert_eq!(1, tuple_like.discriminant());\n+/// assert_eq!(2, struct_like.discriminant());\n+///\n+/// // \u26a0\ufe0f This is undefined behavior. Don't do this. \u26a0\ufe0f\n+/// // assert_eq!(0, unsafe { std::mem::transmute::<_, u8>(std::mem::discriminant(&unit_like)) });\n+/// ```\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"mem_discriminant\")]"}, {"sha": "2d67d742c689b21e0ca422bd52ca79e1ca7581a4", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -98,3 +98,11 @@ pub use crate::macros::builtin::cfg_accessible;\n     reason = \"`cfg_eval` is a recently implemented feature\"\n )]\n pub use crate::macros::builtin::cfg_eval;\n+\n+#[unstable(\n+    feature = \"type_ascription\",\n+    issue = \"23416\",\n+    reason = \"placeholder syntax for type ascription\"\n+)]\n+#[cfg(not(bootstrap))]\n+pub use crate::macros::builtin::type_ascribe;"}, {"sha": "5f8748206d7645508b254bd01dd69e10e9dab1c5", "filename": "library/core/src/str/converts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -77,7 +77,7 @@ use super::Utf8Error;\n /// let sparkle_heart = [240, 159, 146, 150];\n ///\n /// // We know these bytes are valid, so just use `unwrap()`.\n-/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n+/// let sparkle_heart: &str = str::from_utf8(&sparkle_heart).unwrap();\n ///\n /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n /// ```"}, {"sha": "0660e03c1a8213cb91c9eae70d6995afd26df65f", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -401,7 +401,7 @@ impl File {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[unstable(feature = \"file_create_new\", issue = \"none\")]\n+    #[unstable(feature = \"file_create_new\", issue = \"105135\")]\n     pub fn create_new<P: AsRef<Path>>(path: P) -> io::Result<File> {\n         OpenOptions::new().read(true).write(true).create_new(true).open(path.as_ref())\n     }"}, {"sha": "6c957c2fa90eb517088f085687474dbc3b6d702a", "filename": "library/std/src/path.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1463,6 +1463,30 @@ impl PathBuf {\n         true\n     }\n \n+    /// Yields a mutable reference to the underlying [`OsString`] instance.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(path_as_mut_os_str)]\n+    /// use std::path::{Path, PathBuf};\n+    ///\n+    /// let mut path = PathBuf::from(\"/foo\");\n+    ///\n+    /// path.push(\"bar\");\n+    /// assert_eq!(path, Path::new(\"/foo/bar\"));\n+    ///\n+    /// // OsString's `push` does not add a separator.\n+    /// path.as_mut_os_string().push(\"baz\");\n+    /// assert_eq!(path, Path::new(\"/foo/barbaz\"));\n+    /// ```\n+    #[unstable(feature = \"path_as_mut_os_str\", issue = \"105021\")]\n+    #[must_use]\n+    #[inline]\n+    pub fn as_mut_os_string(&mut self) -> &mut OsString {\n+        &mut self.inner\n+    }\n+\n     /// Consumes the `PathBuf`, yielding its internal [`OsString`] storage.\n     ///\n     /// # Examples\n@@ -1993,6 +2017,28 @@ impl Path {\n         &self.inner\n     }\n \n+    /// Yields a mutable reference to the underlying [`OsStr`] slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(path_as_mut_os_str)]\n+    /// use std::path::{Path, PathBuf};\n+    ///\n+    /// let mut path = PathBuf::from(\"/Foo.TXT\").into_boxed_path();\n+    ///\n+    /// assert_ne!(&*path, Path::new(\"/foo.txt\"));\n+    ///\n+    /// path.as_mut_os_str().make_ascii_lowercase();\n+    /// assert_eq!(&*path, Path::new(\"/foo.txt\"));\n+    /// ```\n+    #[unstable(feature = \"path_as_mut_os_str\", issue = \"105021\")]\n+    #[must_use]\n+    #[inline]\n+    pub fn as_mut_os_str(&mut self) -> &mut OsStr {\n+        &mut self.inner\n+    }\n+\n     /// Yields a [`&str`] slice if the `Path` is valid unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity."}, {"sha": "a5a798078eb984ea4772c5e4f6a72ba7ecbd1f0d", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -85,6 +85,15 @@ pub use core::prelude::v1::cfg_accessible;\n )]\n pub use core::prelude::v1::cfg_eval;\n \n+// Do not `doc(no_inline)` either.\n+#[unstable(\n+    feature = \"type_ascription\",\n+    issue = \"23416\",\n+    reason = \"placeholder syntax for type ascription\"\n+)]\n+#[cfg(not(bootstrap))]\n+pub use core::prelude::v1::type_ascribe;\n+\n // The file so far is equivalent to src/libcore/prelude/v1.rs,\n // and below to src/liballoc/prelude.rs.\n // Those files are duplicated rather than using glob imports"}, {"sha": "3edbe7280774d44d75ff56e5bb4100ff6b10d272", "filename": "library/std/src/sys/common/alloc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -4,7 +4,7 @@ use crate::ptr;\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values.\n-#[cfg(all(any(\n+#[cfg(any(\n     target_arch = \"x86\",\n     target_arch = \"arm\",\n     target_arch = \"mips\",\n@@ -16,23 +16,23 @@ use crate::ptr;\n     target_arch = \"hexagon\",\n     all(target_arch = \"riscv32\", not(target_os = \"espidf\")),\n     all(target_arch = \"xtensa\", not(target_os = \"espidf\")),\n-)))]\n+))]\n pub const MIN_ALIGN: usize = 8;\n-#[cfg(all(any(\n+#[cfg(any(\n     target_arch = \"x86_64\",\n     target_arch = \"aarch64\",\n     target_arch = \"mips64\",\n     target_arch = \"s390x\",\n     target_arch = \"sparc64\",\n     target_arch = \"riscv64\",\n     target_arch = \"wasm64\",\n-)))]\n+))]\n pub const MIN_ALIGN: usize = 16;\n // The allocator on the esp-idf platform guarantees 4 byte alignment.\n-#[cfg(all(any(\n+#[cfg(any(\n     all(target_arch = \"riscv32\", target_os = \"espidf\"),\n     all(target_arch = \"xtensa\", target_os = \"espidf\"),\n-)))]\n+))]\n pub const MIN_ALIGN: usize = 4;\n \n pub unsafe fn realloc_fallback("}, {"sha": "6fb92c037ee4f4f3338411479bd699de8a38f68a", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -1,10 +1,8 @@\n-use crate::convert::TryFrom;\n-use crate::ffi::{CStr, CString, OsString};\n+use crate::ffi::{CStr, OsString};\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n use crate::io::{self, Error, ErrorKind};\n use crate::io::{BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n-use crate::os::unix::ffi::OsStrExt;\n use crate::path::{Path, PathBuf};\n use crate::sys::common::small_c_string::run_path_with_cstr;\n use crate::sys::cvt;"}, {"sha": "8f65544a9e894de0a21f897911fea2d688cead06", "filename": "library/std/src/sys/hermit/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -5,6 +5,7 @@ use crate::ffi::CStr;\n use crate::io;\n use crate::mem;\n use crate::num::NonZeroUsize;\n+use crate::ptr;\n use crate::sys::hermit::abi;\n use crate::sys::hermit::thread_local_dtor::run_dtors;\n use crate::time::Duration;\n@@ -47,7 +48,7 @@ impl Thread {\n         extern \"C\" fn thread_start(main: usize) {\n             unsafe {\n                 // Finally, let's run some code.\n-                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n+                Box::from_raw(ptr::from_exposed_addr::<Box<dyn FnOnce()>>(main).cast_mut())();\n \n                 // run all destructors\n                 run_dtors();"}, {"sha": "cf4ebba1a39a613482c81e87d73dc1daae84a14b", "filename": "library/std/src/sys/wasi/net.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -119,8 +119,14 @@ impl TcpStream {\n         unsupported()\n     }\n \n-    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n-        unsupported()\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        let wasi_how = match how {\n+            Shutdown::Read => wasi::SDFLAGS_RD,\n+            Shutdown::Write => wasi::SDFLAGS_WR,\n+            Shutdown::Both => wasi::SDFLAGS_RD | wasi::SDFLAGS_WR,\n+        };\n+\n+        unsafe { wasi::sock_shutdown(self.socket().as_raw_fd() as _, wasi_how).map_err(err2io) }\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpStream> {"}, {"sha": "6741ae46d32ddfa79c265e46053ce71680e652b6", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 2, "deletions": 52, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -9,17 +9,16 @@ mod tests;\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::io;\n-use crate::marker::PhantomData;\n use crate::num::NonZeroU16;\n use crate::os::windows::prelude::*;\n use crate::path::PathBuf;\n-use crate::ptr::NonNull;\n use crate::sys::c;\n use crate::sys::process::ensure_no_nuls;\n use crate::sys::windows::os::current_exe;\n+use crate::sys_common::wstr::WStrUnits;\n use crate::vec;\n \n-use core::iter;\n+use crate::iter;\n \n /// This is the const equivalent to `NonZeroU16::new(n).unwrap()`\n ///\n@@ -199,55 +198,6 @@ impl ExactSizeIterator for Args {\n     }\n }\n \n-/// A safe iterator over a LPWSTR\n-/// (aka a pointer to a series of UTF-16 code units terminated by a NULL).\n-struct WStrUnits<'a> {\n-    // The pointer must never be null...\n-    lpwstr: NonNull<u16>,\n-    // ...and the memory it points to must be valid for this lifetime.\n-    lifetime: PhantomData<&'a [u16]>,\n-}\n-impl WStrUnits<'_> {\n-    /// Create the iterator. Returns `None` if `lpwstr` is null.\n-    ///\n-    /// SAFETY: `lpwstr` must point to a null-terminated wide string that lives\n-    /// at least as long as the lifetime of this struct.\n-    unsafe fn new(lpwstr: *const u16) -> Option<Self> {\n-        Some(Self { lpwstr: NonNull::new(lpwstr as _)?, lifetime: PhantomData })\n-    }\n-    fn peek(&self) -> Option<NonZeroU16> {\n-        // SAFETY: It's always safe to read the current item because we don't\n-        // ever move out of the array's bounds.\n-        unsafe { NonZeroU16::new(*self.lpwstr.as_ptr()) }\n-    }\n-    /// Advance the iterator while `predicate` returns true.\n-    /// Returns the number of items it advanced by.\n-    fn advance_while<P: FnMut(NonZeroU16) -> bool>(&mut self, mut predicate: P) -> usize {\n-        let mut counter = 0;\n-        while let Some(w) = self.peek() {\n-            if !predicate(w) {\n-                break;\n-            }\n-            counter += 1;\n-            self.next();\n-        }\n-        counter\n-    }\n-}\n-impl Iterator for WStrUnits<'_> {\n-    // This can never return zero as that marks the end of the string.\n-    type Item = NonZeroU16;\n-    fn next(&mut self) -> Option<NonZeroU16> {\n-        // SAFETY: If NULL is reached we immediately return.\n-        // Therefore it's safe to advance the pointer after that.\n-        unsafe {\n-            let next = self.peek()?;\n-            self.lpwstr = NonNull::new_unchecked(self.lpwstr.as_ptr().add(1));\n-            Some(next)\n-        }\n-    }\n-}\n-\n #[derive(Debug)]\n pub(crate) enum Arg {\n     /// Add quotes (if needed)"}, {"sha": "b1987aa0f6286b2333e36a45aadf576e1f7a395f", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -32,6 +32,7 @@ pub mod thread;\n pub mod thread_info;\n pub mod thread_local_dtor;\n pub mod thread_parker;\n+pub mod wstr;\n pub mod wtf8;\n \n cfg_if::cfg_if! {"}, {"sha": "b230fd1a829f72864139c173e310b6dbcde70b58", "filename": "library/std/src/sys_common/wstr.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys_common%2Fwstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/library%2Fstd%2Fsrc%2Fsys_common%2Fwstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fwstr.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -0,0 +1,59 @@\n+//! This module contains constructs to work with 16-bit characters (UCS-2 or UTF-16)\n+#![allow(dead_code)]\n+\n+use crate::marker::PhantomData;\n+use crate::num::NonZeroU16;\n+use crate::ptr::NonNull;\n+\n+/// A safe iterator over a LPWSTR\n+/// (aka a pointer to a series of UTF-16 code units terminated by a NULL).\n+pub struct WStrUnits<'a> {\n+    // The pointer must never be null...\n+    lpwstr: NonNull<u16>,\n+    // ...and the memory it points to must be valid for this lifetime.\n+    lifetime: PhantomData<&'a [u16]>,\n+}\n+\n+impl WStrUnits<'_> {\n+    /// Create the iterator. Returns `None` if `lpwstr` is null.\n+    ///\n+    /// SAFETY: `lpwstr` must point to a null-terminated wide string that lives\n+    /// at least as long as the lifetime of this struct.\n+    pub unsafe fn new(lpwstr: *const u16) -> Option<Self> {\n+        Some(Self { lpwstr: NonNull::new(lpwstr as _)?, lifetime: PhantomData })\n+    }\n+\n+    pub fn peek(&self) -> Option<NonZeroU16> {\n+        // SAFETY: It's always safe to read the current item because we don't\n+        // ever move out of the array's bounds.\n+        unsafe { NonZeroU16::new(*self.lpwstr.as_ptr()) }\n+    }\n+\n+    /// Advance the iterator while `predicate` returns true.\n+    /// Returns the number of items it advanced by.\n+    pub fn advance_while<P: FnMut(NonZeroU16) -> bool>(&mut self, mut predicate: P) -> usize {\n+        let mut counter = 0;\n+        while let Some(w) = self.peek() {\n+            if !predicate(w) {\n+                break;\n+            }\n+            counter += 1;\n+            self.next();\n+        }\n+        counter\n+    }\n+}\n+\n+impl Iterator for WStrUnits<'_> {\n+    // This can never return zero as that marks the end of the string.\n+    type Item = NonZeroU16;\n+    fn next(&mut self) -> Option<NonZeroU16> {\n+        // SAFETY: If NULL is reached we immediately return.\n+        // Therefore it's safe to advance the pointer after that.\n+        unsafe {\n+            let next = self.peek()?;\n+            self.lpwstr = NonNull::new_unchecked(self.lpwstr.as_ptr().add(1));\n+            Some(next)\n+        }\n+    }\n+}"}, {"sha": "2d5018d934e2e27023b8ea25122517ce0c3a16f4", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -441,6 +441,7 @@ def download_toolchain(self):\n \n             self.fix_bin_or_dylib(\"{}/bin/rustc\".format(bin_root))\n             self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(bin_root))\n+            self.fix_bin_or_dylib(\"{}/libexec/rust-analyzer-proc-macro-srv\".format(bin_root))\n             lib_dir = \"{}/lib\".format(bin_root)\n             for lib in os.listdir(lib_dir):\n                 if lib.endswith(\".so\"):"}, {"sha": "cff5fd8c5b02cb46ea3656dfa548b87ae7b12dff", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -644,6 +644,7 @@ impl<'a> Builder<'a> {\n                 test::CrateLibrustc,\n                 test::CrateRustdoc,\n                 test::CrateRustdocJsonTypes,\n+                test::CrateJsonDocLint,\n                 test::Linkcheck,\n                 test::TierCheck,\n                 test::ReplacePlaceholderTest,"}, {"sha": "6ae283f32a5f3a9080edd104a4cf46bc01b3376d", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -360,6 +360,7 @@ impl Config {\n \n             self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));\n             self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustdoc\"));\n+            self.fix_bin_or_dylib(&bin_root.join(\"libexec\").join(\"rust-analyzer-proc-macro-srv\"));\n             let lib_dir = bin_root.join(\"lib\");\n             for lib in t!(fs::read_dir(&lib_dir), lib_dir.display().to_string()) {\n                 let lib = t!(lib);"}, {"sha": "a3d1893afbb65d171eb8052773a757978e5f75c1", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -647,9 +647,10 @@ impl Build {\n         if !update(true).status().map_or(false, |status| status.success()) {\n             self.run(&mut update(false));\n         }\n-\n+        self.run(Command::new(\"git\").args(&[\"stash\", \"push\"]).current_dir(&absolute_path));\n         self.run(Command::new(\"git\").args(&[\"reset\", \"-q\", \"--hard\"]).current_dir(&absolute_path));\n-        self.run(Command::new(\"git\").args(&[\"clean\", \"-qdfx\"]).current_dir(absolute_path));\n+        self.run(Command::new(\"git\").args(&[\"clean\", \"-qdfx\"]).current_dir(&absolute_path));\n+        self.run(Command::new(\"git\").args(&[\"stash\", \"pop\"]).current_dir(absolute_path));\n     }\n \n     /// If any submodule has been initialized already, sync it unconditionally."}, {"sha": "39cedfdac5f775d7630f90195d81d226c7f671ec", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -90,6 +90,42 @@ fn try_run_quiet(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n     true\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateJsonDocLint {\n+    host: TargetSelection,\n+}\n+\n+impl Step for CrateJsonDocLint {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/jsondoclint\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(CrateJsonDocLint { host: run.target });\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        let bootstrap_host = builder.config.build;\n+        let compiler = builder.compiler(0, bootstrap_host);\n+\n+        let cargo = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolBootstrap,\n+            bootstrap_host,\n+            \"test\",\n+            \"src/tools/jsondoclint\",\n+            SourceType::InTree,\n+            &[],\n+        );\n+        try_run(builder, &mut cargo.into());\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Linkcheck {\n     host: TargetSelection,"}, {"sha": "7c09e3a582fd6042c3a90f47c959b718772684ba", "filename": "src/ci/docker/host-x86_64/test-various/Dockerfile", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -19,11 +19,18 @@ RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-ins\n   wget \\\n   patch \\\n   ovmf \\\n+  qemu-efi-aarch64 \\\n+  qemu-system-arm \\\n   qemu-system-x86\n \n RUN curl -sL https://nodejs.org/dist/v15.14.0/node-v15.14.0-linux-x64.tar.xz | \\\n   tar -xJ\n \n+# Install 32-bit OVMF files for the i686-unknown-uefi test. This package\n+# is not available in ubuntu 20.04, so download a 22.04 package.\n+RUN curl -sL --output ovmf-ia32.deb http://mirrors.kernel.org/ubuntu/pool/universe/e/edk2/ovmf-ia32_2022.02-3_all.deb\n+RUN dpkg -i ovmf-ia32.deb && rm ovmf-ia32.deb\n+\n WORKDIR /build/\n COPY scripts/musl-patch-configure.diff /build/\n COPY scripts/musl-toolchain.sh /build/\n@@ -68,7 +75,11 @@ ENV MUSL_TARGETS=x86_64-unknown-linux-musl \\\n ENV MUSL_SCRIPT python3 /checkout/x.py --stage 2 test --host='' --target $MUSL_TARGETS\n \n COPY host-x86_64/test-various/uefi_qemu_test /uefi_qemu_test\n-ENV UEFI_TARGETS=x86_64-unknown-uefi \\\n+ENV UEFI_TARGETS=aarch64-unknown-uefi,i686-unknown-uefi,x86_64-unknown-uefi \\\n+    CC_aarch64_unknown_uefi=clang-11 \\\n+    CXX_aarch64_unknown_uefi=clang++-11 \\\n+    CC_i686_unknown_uefi=clang-11 \\\n+    CXX_i686_unknown_uefi=clang++-11 \\\n     CC_x86_64_unknown_uefi=clang-11 \\\n     CXX_x86_64_unknown_uefi=clang++-11\n ENV UEFI_SCRIPT python3 /checkout/x.py --stage 2 build --host='' --target $UEFI_TARGETS && \\"}, {"sha": "ffae7b0d4ac271676fba6cf16c993010d56f037b", "filename": "src/ci/docker/host-x86_64/test-various/uefi_qemu_test/run.py", "status": "modified", "additions": 62, "deletions": 16, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2Frun.py", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2Frun.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2Fuefi_qemu_test%2Frun.py?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -8,19 +8,51 @@\n \n from pathlib import Path\n \n+TARGET_AARCH64 = 'aarch64-unknown-uefi'\n+TARGET_I686 = 'i686-unknown-uefi'\n+TARGET_X86_64 = 'x86_64-unknown-uefi'\n \n-def run(*cmd, capture=False, check=True, env=None):\n+def run(*cmd, capture=False, check=True, env=None, timeout=None):\n     \"\"\"Print and run a command, optionally capturing the output.\"\"\"\n     cmd = [str(p) for p in cmd]\n     print(' '.join(cmd))\n     return subprocess.run(cmd,\n                           capture_output=capture,\n                           check=check,\n                           env=env,\n-                          text=True)\n-\n+                          text=True,\n+                          timeout=timeout)\n+\n+def build_and_run(tmp_dir, target):\n+    if target == TARGET_AARCH64:\n+        boot_file_name = 'bootaa64.efi'\n+        ovmf_dir = Path('/usr/share/AAVMF')\n+        ovmf_code = 'AAVMF_CODE.fd'\n+        ovmf_vars = 'AAVMF_VARS.fd'\n+        qemu = 'qemu-system-aarch64'\n+        machine = 'virt'\n+        cpu = 'cortex-a72'\n+    elif target == TARGET_I686:\n+        boot_file_name = 'bootia32.efi'\n+        ovmf_dir = Path('/usr/share/OVMF')\n+        ovmf_code = 'OVMF32_CODE_4M.secboot.fd'\n+        ovmf_vars = 'OVMF32_VARS_4M.fd'\n+        # The i686 target intentionally uses 64-bit qemu; the important\n+        # difference is that the OVMF code provides a 32-bit environment.\n+        qemu = 'qemu-system-x86_64'\n+        machine = 'q35'\n+        cpu = 'qemu64'\n+    elif target == TARGET_X86_64:\n+        boot_file_name = 'bootx64.efi'\n+        ovmf_dir = Path('/usr/share/OVMF')\n+        ovmf_code = 'OVMF_CODE.fd'\n+        ovmf_vars = 'OVMF_VARS.fd'\n+        qemu = 'qemu-system-x86_64'\n+        machine = 'q35'\n+        cpu = 'qemu64'\n+    else:\n+        raise KeyError('invalid target')\n \n-def build_and_run(tmp_dir):\n     host_artifacts = Path('/checkout/obj/build/x86_64-unknown-linux-gnu')\n     stage0 = host_artifacts / 'stage0/bin'\n     stage2 = host_artifacts / 'stage2/bin'\n@@ -33,7 +65,6 @@ def build_and_run(tmp_dir):\n     shutil.copytree('/uefi_qemu_test', test_crate)\n \n     # Build the UEFI executable.\n-    target = 'x86_64-unknown-uefi'\n     run('cargo',\n         'build',\n         '--manifest-path',\n@@ -49,22 +80,32 @@ def build_and_run(tmp_dir):\n \n     # Copy the executable into the ESP.\n     src_exe_path = test_crate / 'target' / target / 'debug/uefi_qemu_test.efi'\n-    shutil.copy(src_exe_path, boot / 'bootx64.efi')\n+    shutil.copy(src_exe_path, boot / boot_file_name)\n+    print(src_exe_path, boot / boot_file_name)\n+\n+    # Select the appropriate EDK2 build.\n+    ovmf_code = ovmf_dir / ovmf_code\n+    ovmf_vars = ovmf_dir / ovmf_vars\n+\n+    # Make a writable copy of the vars file. aarch64 doesn't boot\n+    # correctly with read-only vars.\n+    ovmf_rw_vars = Path(tmp_dir) / 'vars.fd'\n+    shutil.copy(ovmf_vars, ovmf_rw_vars)\n \n     # Run the executable in QEMU and capture the output.\n-    qemu = 'qemu-system-x86_64'\n-    ovmf_dir = Path('/usr/share/OVMF')\n-    ovmf_code = ovmf_dir / 'OVMF_CODE.fd'\n-    ovmf_vars = ovmf_dir / 'OVMF_VARS.fd'\n     output = run(qemu,\n+                 '-machine',\n+                 machine,\n+                 '-cpu',\n+                 cpu,\n                  '-display',\n                  'none',\n                  '-serial',\n                  'stdio',\n                  '-drive',\n                  f'if=pflash,format=raw,readonly=on,file={ovmf_code}',\n                  '-drive',\n-                 f'if=pflash,format=raw,readonly=on,file={ovmf_vars}',\n+                 f'if=pflash,format=raw,readonly=off,file={ovmf_rw_vars}',\n                  '-drive',\n                  f'format=raw,file=fat:rw:{esp}',\n                  capture=True,\n@@ -73,7 +114,9 @@ def build_and_run(tmp_dir):\n                  # shutdown under some circumstances. That has been\n                  # fixed in newer versions of QEMU, but for now just\n                  # don't check the exit status.\n-                 check=False).stdout\n+                 check=False,\n+                 # Set a timeout to kill the VM in case something goes wrong.\n+                 timeout=60).stdout\n \n     if 'Hello World!' in output:\n         print('VM produced expected output')\n@@ -86,10 +129,13 @@ def build_and_run(tmp_dir):\n \n \n def main():\n-    # Create a temporary directory so that we have a writeable\n-    # workspace.\n-    with tempfile.TemporaryDirectory() as tmp_dir:\n-        build_and_run(tmp_dir)\n+    targets = [TARGET_AARCH64, TARGET_I686, TARGET_X86_64]\n+\n+    for target in targets:\n+        # Create a temporary directory so that we have a writeable\n+        # workspace.\n+        with tempfile.TemporaryDirectory() as tmp_dir:\n+            build_and_run(tmp_dir, target)\n \n \n if __name__ == \"__main__\":"}, {"sha": null, "filename": "src/ci/docker/scripts/fuchsia-test-runner.py", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800"}, {"sha": "ef6eee75f1ce6c2cdc4d0ed83e43144e60bb68de", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -104,6 +104,33 @@ This modifier has no effect when building other targets like executables or dyna\n \n The default for this modifier is `+bundle`.\n \n+### Linking modifiers: `verbatim`\n+\n+This modifier is compatible with all linking kinds.\n+\n+`+verbatim` means that rustc itself won't add any target-specified library prefixes or suffixes\n+(like `lib` or `.a`) to the library name, and will try its best to ask for the same thing from the\n+linker.\n+\n+For `ld`-like linkers supporting GNU extensions rustc will use the `-l:filename` syntax (note the\n+colon) when passing the library, so the linker won't add any prefixes or suffixes to it.\n+See [`-l namespec`](https://sourceware.org/binutils/docs/ld/Options.html) in ld documentation for\n+more details. \\\n+For linkers not supporting any verbatim modifiers (e.g. `link.exe` or `ld64`) the library name will\n+be passed as is. So the most reliable cross-platform use scenarios for this option are when no\n+linker is involved, for example bundling native libraries into rlibs.\n+\n+`-verbatim` means that rustc will either add a target-specific prefix and suffix to the library\n+name before passing it to linker, or won't prevent linker from implicitly adding it. \\\n+In case of `raw-dylib` kind in particular `.dll` will be added to the library name on Windows.\n+\n+The default for this modifier is `-verbatim`.\n+\n+NOTE: Even with `+verbatim` and `-l:filename` syntax `ld`-like linkers do not typically support\n+passing absolute paths to libraries. Usually such paths need to be passed as input files without\n+using any options like `-l`, e.g. `ld /my/absolute/path`. \\\n+`-Clink-arg=/my/absolute/path` can be used for doing this from stable `rustc`.\n+\n <a id=\"option-crate-type\"></a>\n ## `--crate-type`: a list of types of crates for the compiler to emit\n "}, {"sha": "d0c3ddf2606245fb5acdc000e1e7de126dc881f8", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -214,7 +214,7 @@ target | std | host | notes\n [`aarch64-kmc-solid_asp3`](platform-support/kmc-solid.md) | \u2713 |  | ARM64 SOLID with TOPPERS/ASP3\n [`aarch64-nintendo-switch-freestanding`](platform-support/aarch64-nintendo-switch-freestanding.md) | * |  | ARM64 Nintendo Switch, Horizon\n [`aarch64-pc-windows-gnullvm`](platform-support/pc-windows-gnullvm.md) | \u2713 | \u2713 |\n-[`aarch64-unknown-nto-qnx7.1.0`](platform-support/nto-qnx.md) | ? |  | ARM64 QNX Neutrino 7.1 RTOS |\n+[`aarch64-unknown-nto-qnx710`](platform-support/nto-qnx.md) | ? |  | ARM64 QNX Neutrino 7.1 RTOS |\n `aarch64-unknown-freebsd` | \u2713 | \u2713 | ARM64 FreeBSD\n `aarch64-unknown-hermit` | \u2713 |  | ARM64 HermitCore\n `aarch64-unknown-linux-gnu_ilp32` | \u2713 | \u2713 | ARM64 Linux (ILP32 ABI)\n@@ -305,7 +305,7 @@ target | std | host | notes\n `x86_64-apple-ios-macabi` | \u2713 |  | Apple Catalyst on x86_64\n `x86_64-apple-tvos` | * | | x86 64-bit tvOS\n [`x86_64-apple-watchos-sim`](platform-support/apple-watchos.md) | \u2713 | | x86 64-bit Apple WatchOS simulator\n-[`x86_64-pc-nto-qnx7.1.0`](platform-support/nto-qnx.md) | ? |  | x86 64-bit QNX Neutrino 7.1 RTOS |\n+[`x86_64-pc-nto-qnx710`](platform-support/nto-qnx.md) | ? |  | x86 64-bit QNX Neutrino 7.1 RTOS |\n [`x86_64-pc-windows-gnullvm`](platform-support/pc-windows-gnullvm.md) | \u2713 | \u2713 |\n `x86_64-pc-windows-msvc` | * |  | 64-bit Windows XP support\n `x86_64-sun-solaris` | ? |  | Deprecated target for 64-bit Solaris 10/11, illumos"}, {"sha": "fbf999f97151b3e8169a90a5ed476159c6fd601d", "filename": "src/doc/rustc/src/platform-support/fuchsia.md", "status": "modified", "additions": 60, "deletions": 23, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -189,17 +189,45 @@ Fuchsia as well. A recent version (14+) of clang should be sufficient to compile\n Rust for Fuchsia.\n \n x86-64 and AArch64 Fuchsia targets can be enabled using the following\n-configuration.\n-\n-In `config.toml`, add:\n+configuration in `config.toml`:\n \n ```toml\n [build]\n target = [\"<host_platform>\", \"aarch64-fuchsia\", \"x86_64-fuchsia\"]\n+\n+[rust]\n+lld = true\n+\n+[target.x86_64-fuchsia]\n+cc = \"clang\"\n+cxx = \"clang++\"\n+\n+[target.aarch64-fuchsia]\n+cc = \"clang\"\n+cxx = \"clang++\"\n+```\n+\n+Though not strictly required, you may also want to use `clang` for your host\n+target as well:\n+\n+```toml\n+[target.<host_platform>]\n+cc = \"clang\"\n+cxx = \"clang++\"\n+```\n+\n+By default, the Rust compiler installs itself to `/usr/local` on most UNIX\n+systems. You may want to install it to another location (e.g. a local `install`\n+directory) by setting a custom prefix in `config.toml`:\n+\n+```toml\n+[install]\n+# Make sure to use the absolute path to your install directory\n+prefix = \"<RUST_SRC_PATH>/install\"\n ```\n \n-Additionally, the following environment variables must be configured (for\n-example, using a script like `config-env.sh`):\n+Next, the following environment variables must be configured. For example, using\n+a script we name `config-env.sh`:\n \n ```sh\n # Configure this environment variable to be the path to the downloaded SDK\n@@ -215,8 +243,11 @@ export LDFLAGS_x86_64_fuchsia=\"--target=x86_64-fuchsia --sysroot=${SDK_PATH}/arc\n export CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS=\"-C link-arg=--sysroot=${SDK_PATH}/arch/x64/sysroot -Lnative=${SDK_PATH}/arch/x64/sysroot/lib -Lnative=${SDK_PATH}/arch/x64/lib\"\n ```\n \n-These can be run together in a shell environment by executing\n-`(source config-env.sh && ./x.py install)`.\n+Finally, the Rust compiler can be built and installed:\n+\n+```sh\n+(source config-env.sh && ./x.py install)\n+```\n \n Once `rustc` is installed, we can create a new working directory to work from,\n `hello_fuchsia` along with `hello_fuchsia/src`:\n@@ -641,31 +672,38 @@ available on the [Fuchsia devsite].\n \n ### Running the compiler test suite\n \n-Pre-requisites for running the Rust test suite on Fuchsia are:\n-1. Checkout of Rust source.\n-1. Setup of `config-env.sh` and `config.toml` from \"[Targeting Fuchsia with a compiler built from source](#targeting-fuchsia-with-a-compiler-built-from-source)\".\n-1. Download of the Fuchsia SDK. Minimum supported SDK version is [9.20220726.1.1](https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core/linux-amd64/+/version:9.20220726.1.1)\n+The commands in this section assume that they are being run from inside your\n+local Rust source checkout:\n+\n+```sh\n+cd ${RUST_SRC_PATH}\n+```\n+\n+To run the Rust test suite on an emulated Fuchsia device, you must install the\n+Rust compiler locally. See \"[Targeting Fuchsia with a compiler built from source](#targeting-fuchsia-with-a-compiler-built-from-source)\"\n+for the steps to build locally.\n \n-Interfacing with the Fuchsia emulator is handled by our test runner script located\n-at `${RUST_SRC_PATH}/src/ci/docker/scripts/fuchsia-test-runner.py`.\n+You'll also need to download a copy of the Fuchsia SDK. The current minimum\n+supported SDK version is [9.20220726.1.1](https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core/linux-amd64/+/version:9.20220726.1.1).\n \n-We start by activating our Fuchsia test environment. From a terminal:\n+Fuchsia's test runner interacts with the Fuchsia emulator and is located at\n+`src/ci/docker/scripts/fuchsia-test-runner.py`. We can use it to start our\n+test environment with:\n \n-**Issue command from ${RUST_SRC_PATH}**\n ```sh\n src/ci/docker/scripts/fuchsia-test-runner.py start\n-    --rust .\n+    --rust ${RUST_SRC_PATH}/install\n     --sdk ${SDK_PATH}\n     --target-arch {x64,arm64}\n ```\n \n-Next, for ease of commands, we copy `config-env.sh` and `config.toml` into our Rust source\n-code path, `${RUST_SRC_PATH}`.\n+Where `${RUST_SRC_PATH}/install` is the `prefix` set in `config.toml` and\n+`${SDK_PATH}` is the path to the downloaded and unzipped SDK.\n \n-From there, we utilize `x.py` to run our tests, using the test runner script to\n-run the tests on our emulator. To run the full `src/test/ui` test suite:\n+Once our environment is started, we can run our tests using `x.py` as usual. The\n+test runner script will run the compiled tests on an emulated Fuchsia device. To\n+run the full `src/test/ui` test suite:\n \n-**Run from ${RUST_SRC_PATH}**\n ```sh\n ( \\\n     source config-env.sh &&                                                   \\\n@@ -695,9 +733,8 @@ run the tests on our emulator. To run the full `src/test/ui` test suite:\n *Note: The test suite cannot be run in parallel at the moment, so `x.py`\n must be run with `--jobs 1` to ensure only one test runs at a time.*\n \n-When finished, stop the test environment:\n+When finished, the test runner can be used to stop the test environment:\n \n-**Issue command from ${RUST_SRC_PATH}**\n ```sh\n src/ci/docker/scripts/fuchsia-test-runner.py stop\n ```"}, {"sha": "37d0c31976c774a940ece3a5c119be2f31d74de3", "filename": "src/doc/rustc/src/platform-support/nto-qnx.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fnto-qnx.md", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fnto-qnx.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fnto-qnx.md?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -93,15 +93,15 @@ Run the following:\n \n ```bash\n env \\\n-    CC_aarch64-unknown-nto-qnx7.1.0=\"qcc\" \\\n-    CFLAGS_aarch64-unknown-nto-qnx7.1.0=\"-Vgcc_ntoaarch64le_cxx\" \\\n-    CXX_aarch64-unknown-nto-qnx7.1.0=\"qcc\" \\\n-    AR_aarch64_unknown_nto_qnx7.1.0=\"ntoaarch64-ar\" \\\n-    CC_x86_64-pc-nto-qnx7.1.0=\"qcc\" \\\n-    CFLAGS_x86_64-pc-nto-qnx7.1.0=\"-Vgcc_ntox86_64_cxx\" \\\n-    CXX_x86_64-pc-nto-qnx7.1.0=\"qcc\" \\\n-    AR_x86_64_pc_nto_qnx7.1.0=\"ntox86_64-ar\" \\\n-        ./x.py build --target aarch64-unknown-nto-qnx7.1.0 --target x86_64-pc-nto-qnx7.1.0 --target x86_64-unknown-linux-gnu rustc library/core library/alloc/\n+    CC_aarch64-unknown-nto-qnx710=\"qcc\" \\\n+    CFLAGS_aarch64-unknown-nto-qnx710=\"-Vgcc_ntoaarch64le_cxx\" \\\n+    CXX_aarch64-unknown-nto-qnx710=\"qcc\" \\\n+    AR_aarch64_unknown_nto_qnx710=\"ntoaarch64-ar\" \\\n+    CC_x86_64-pc-nto-qnx710=\"qcc\" \\\n+    CFLAGS_x86_64-pc-nto-qnx710=\"-Vgcc_ntox86_64_cxx\" \\\n+    CXX_x86_64-pc-nto-qnx710=\"qcc\" \\\n+    AR_x86_64_pc_nto_qnx710=\"ntox86_64-ar\" \\\n+        ./x.py build --target aarch64-unknown-nto-qnx710 --target x86_64-pc-nto-qnx710 --target x86_64-unknown-linux-gnu rustc library/core library/alloc/\n ```\n \n ## Building Rust programs"}, {"sha": "95932db14e1f659ca86fd8dcbe5f02ad04940d24", "filename": "src/doc/rustc/src/target-tier-policy.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -158,6 +158,8 @@ approved by the appropriate team for that shared code before acceptance.\n     the name of the target makes people extremely likely to form incorrect\n     beliefs about what it targets, the name should be changed or augmented to\n     disambiguate it.\n+  - If possible, use only letters, numbers, dashes and underscores for the name.\n+    Periods (`.`) are known to cause issues in Cargo.\n - Tier 3 targets may have unusual requirements to build or use, but must not\n   create legal issues or impose onerous legal terms for the Rust project or for\n   Rust developers or users."}, {"sha": "21668973194ed2a30d4997ee330857e8c116907a", "filename": "src/doc/style-guide/src/principles.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fprinciples.md", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fprinciples.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fprinciples.md?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -8,7 +8,9 @@ following principles (in rough priority order):\n     - avoiding misleading formatting\n     - accessibility - readable and editable by users using the the widest\n       variety of hardware, including non-visual accessibility interfaces\n-    - readability of code when quoted in rustc error messages\n+    - readability of code in contexts without syntax highlighting or IDE\n+      assistance, such as rustc error messages, diffs, grep, and other\n+      plain-text contexts\n \n * aesthetics\n     - sense of 'beauty'"}, {"sha": "02bd87e50956d4ee83acec6e389a63e83513e4a2", "filename": "src/doc/unstable-book/src/language-features/native-link-modifiers-verbatim.md", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/80ab672b8611d34bf811d4498b9b9d116a085e7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnative-link-modifiers-verbatim.md", "raw_url": "https://github.com/rust-lang/rust/raw/80ab672b8611d34bf811d4498b9b9d116a085e7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnative-link-modifiers-verbatim.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnative-link-modifiers-verbatim.md?ref=80ab672b8611d34bf811d4498b9b9d116a085e7c", "patch": "@@ -1,20 +0,0 @@\n-# `native_link_modifiers_verbatim`\n-\n-The tracking issue for this feature is: [#81490]\n-\n-[#81490]: https://github.com/rust-lang/rust/issues/81490\n-\n-------------------------\n-\n-The `native_link_modifiers_verbatim` feature allows you to use the `verbatim` modifier.\n-\n-`+verbatim` means that rustc itself won't add any target-specified library prefixes or suffixes (like `lib` or `.a`) to the library name, and will try its best to ask for the same thing from the linker.\n-\n-For `ld`-like linkers rustc will use the `-l:filename` syntax (note the colon) when passing the library, so the linker won't add any prefixes or suffixes as well.\n-See [`-l namespec`](https://sourceware.org/binutils/docs/ld/Options.html) in ld documentation for more details.\n-For linkers not supporting any verbatim modifiers (e.g. `link.exe` or `ld64`) the library name will be passed as is.\n-\n-The default for this modifier is `-verbatim`.\n-\n-This RFC changes the behavior of `raw-dylib` linking kind specified by [RFC 2627](https://github.com/rust-lang/rfcs/pull/2627). The `.dll` suffix (or other target-specified suffixes for other targets) is now added automatically.\n-If your DLL doesn't have the `.dll` suffix, it can be specified with `+verbatim`."}, {"sha": "32b8d8e24c65245efb100e6997948e1942aa3706", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -144,20 +144,16 @@ class StdVecDequeProvider:\n     def __init__(self, valobj):\n         self.valobj = valobj\n         self.head = int(valobj[\"head\"])\n-        self.tail = int(valobj[\"tail\"])\n+        self.size = int(valobj[\"len\"])\n         self.cap = int(valobj[\"buf\"][\"cap\"])\n         self.data_ptr = unwrap_unique_or_non_null(valobj[\"buf\"][\"ptr\"])\n-        if self.head >= self.tail:\n-            self.size = self.head - self.tail\n-        else:\n-            self.size = self.cap + self.head - self.tail\n \n     def to_string(self):\n         return \"VecDeque(size={})\".format(self.size)\n \n     def children(self):\n         return _enumerate_array_elements(\n-            (self.data_ptr + ((self.tail + index) % self.cap)) for index in xrange(self.size)\n+            (self.data_ptr + ((self.head + index) % self.cap)) for index in xrange(self.size)\n         )\n \n     @staticmethod"}, {"sha": "697ad4293c3f0bd1fc5a7ca3146cee1659e5a47e", "filename": "src/etc/lldb_providers.py", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -356,7 +356,7 @@ def has_children(self):\n class StdVecDequeSyntheticProvider:\n     \"\"\"Pretty-printer for alloc::collections::vec_deque::VecDeque<T>\n \n-    struct VecDeque<T> { tail: usize, head: usize, buf: RawVec<T> }\n+    struct VecDeque<T> { head: usize, len: usize, buf: RawVec<T> }\n     \"\"\"\n \n     def __init__(self, valobj, dict):\n@@ -373,28 +373,24 @@ def num_children(self):\n     def get_child_index(self, name):\n         # type: (str) -> int\n         index = name.lstrip('[').rstrip(']')\n-        if index.isdigit() and self.tail <= index and (self.tail + index) % self.cap < self.head:\n+        if index.isdigit() and int(index) < self.size:\n             return int(index)\n         else:\n             return -1\n \n     def get_child_at_index(self, index):\n         # type: (int) -> SBValue\n         start = self.data_ptr.GetValueAsUnsigned()\n-        address = start + ((index + self.tail) % self.cap) * self.element_type_size\n+        address = start + ((index + self.head) % self.cap) * self.element_type_size\n         element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.element_type)\n         return element\n \n     def update(self):\n         # type: () -> None\n         self.head = self.valobj.GetChildMemberWithName(\"head\").GetValueAsUnsigned()\n-        self.tail = self.valobj.GetChildMemberWithName(\"tail\").GetValueAsUnsigned()\n+        self.size = self.valobj.GetChildMemberWithName(\"len\").GetValueAsUnsigned()\n         self.buf = self.valobj.GetChildMemberWithName(\"buf\")\n         self.cap = self.buf.GetChildMemberWithName(\"cap\").GetValueAsUnsigned()\n-        if self.head >= self.tail:\n-            self.size = self.head - self.tail\n-        else:\n-            self.size = self.cap + self.head - self.tail\n \n         self.data_ptr = unwrap_unique_or_non_null(self.buf.GetChildMemberWithName(\"ptr\"))\n "}, {"sha": "c4ad98ec1d3a99cf9b3ba9ebc36e0ea1715a17c8", "filename": "src/etc/natvis/liballoc.natvis", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fliballoc.natvis?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -12,20 +12,19 @@\n     </Expand>\n   </Type>\n   <Type Name=\"alloc::collections::vec_deque::VecDeque&lt;*&gt;\">\n-    <DisplayString>{{ len={tail &lt;= head ? head - tail : buf.cap - tail + head} }}</DisplayString>\n+    <DisplayString>{{ len={len} }}</DisplayString>\n     <Expand>\n-      <Item Name=\"[len]\" ExcludeView=\"simple\">tail &lt;= head ? head - tail : buf.cap - tail + head</Item>\n+      <Item Name=\"[len]\" ExcludeView=\"simple\">len</Item>\n       <Item Name=\"[capacity]\" ExcludeView=\"simple\">buf.cap</Item>\n       <CustomListItems>\n-        <Variable Name=\"i\" InitialValue=\"tail\" />\n-\n-        <Size>tail &lt;= head ? head - tail : buf.cap - tail + head</Size>\n+        <Variable Name=\"i\" InitialValue=\"0\" />\n+        <Size>len</Size>\n         <Loop>\n-          <If Condition=\"i == head\">\n+          <If Condition=\"i == len\">\n             <Break/>\n           </If>\n-          <Item>buf.ptr.pointer.pointer[i]</Item>\n-          <Exec>i = (i + 1 == buf.cap ? 0 : i + 1)</Exec>\n+          <Item>buf.ptr.pointer.pointer[(i + head) % buf.cap]</Item>\n+          <Exec>i = i + 1</Exec>\n         </Loop>\n       </CustomListItems>\n     </Expand>"}, {"sha": "1843a21205cfa65ef3de0f27c2b2391ac0b191b1", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -50,7 +50,7 @@ impl Cfg {\n     ) -> Result<Option<Cfg>, InvalidCfgError> {\n         match nested_cfg {\n             NestedMetaItem::MetaItem(ref cfg) => Cfg::parse_without(cfg, exclude),\n-            NestedMetaItem::Literal(ref lit) => {\n+            NestedMetaItem::Lit(ref lit) => {\n                 Err(InvalidCfgError { msg: \"unexpected literal\", span: lit.span })\n             }\n         }"}, {"sha": "80909919ba2b69e64a21c3e6c502ac4ec23363c1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -893,7 +893,7 @@ fn clean_fn_decl_legacy_const_generics(func: &mut Function, attrs: &[ast::Attrib\n         .filter(|a| a.has_name(sym::rustc_legacy_const_generics))\n         .filter_map(|a| a.meta_item_list())\n     {\n-        for (pos, literal) in meta_item_list.iter().filter_map(|meta| meta.literal()).enumerate() {\n+        for (pos, literal) in meta_item_list.iter().filter_map(|meta| meta.lit()).enumerate() {\n             match literal.kind {\n                 ast::LitKind::Int(a, _) => {\n                     let gen = func.generics.params.remove(0);\n@@ -1581,14 +1581,14 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>>\n     }\n \n     use crate::rustc_trait_selection::infer::TyCtxtInferExt;\n-    use crate::rustc_trait_selection::traits::query::normalize::AtExt;\n+    use crate::rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n     use rustc_middle::traits::ObligationCause;\n \n     // Try to normalize `<X as Y>::T` to a type\n     let infcx = cx.tcx.infer_ctxt().build();\n     let normalized = infcx\n         .at(&ObligationCause::dummy(), cx.param_env)\n-        .normalize(ty)\n+        .query_normalize(ty)\n         .map(|resolved| infcx.resolve_vars_if_possible(resolved.value));\n     match normalized {\n         Ok(normalized_value) => {\n@@ -2231,6 +2231,26 @@ fn clean_extern_crate<'tcx>(\n }\n \n fn clean_use_statement<'tcx>(\n+    import: &hir::Item<'tcx>,\n+    name: Symbol,\n+    path: &hir::UsePath<'tcx>,\n+    kind: hir::UseKind,\n+    cx: &mut DocContext<'tcx>,\n+    inlined_names: &mut FxHashSet<(ItemType, Symbol)>,\n+) -> Vec<Item> {\n+    let mut items = Vec::new();\n+    let hir::UsePath { segments, ref res, span } = *path;\n+    for &res in res {\n+        if let Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) = res {\n+            continue;\n+        }\n+        let path = hir::Path { segments, res, span };\n+        items.append(&mut clean_use_statement_inner(import, name, &path, kind, cx, inlined_names));\n+    }\n+    items\n+}\n+\n+fn clean_use_statement_inner<'tcx>(\n     import: &hir::Item<'tcx>,\n     name: Symbol,\n     path: &hir::Path<'tcx>,"}, {"sha": "2590bb0df3f0e62ef74c84ce9eab4b3922e2862b", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -115,7 +115,6 @@ impl From<DefId> for ItemId {\n #[derive(Clone, Debug)]\n pub(crate) struct Crate {\n     pub(crate) module: Item,\n-    pub(crate) primitives: ThinVec<(DefId, PrimitiveType)>,\n     /// Only here so that they can be filtered through the rustdoc passes.\n     pub(crate) external_traits: Rc<RefCell<FxHashMap<DefId, Trait>>>,\n }\n@@ -243,7 +242,9 @@ impl ExternalCrate {\n                         hir::ItemKind::Use(path, hir::UseKind::Single)\n                             if tcx.visibility(id.owner_id).is_public() =>\n                         {\n-                            as_keyword(path.res.expect_non_local())\n+                            path.res\n+                                .iter()\n+                                .find_map(|res| as_keyword(res.expect_non_local()))\n                                 .map(|(_, prim)| (id.owner_id.to_def_id(), prim))\n                         }\n                         _ => None,\n@@ -311,10 +312,11 @@ impl ExternalCrate {\n                         hir::ItemKind::Use(path, hir::UseKind::Single)\n                             if tcx.visibility(id.owner_id).is_public() =>\n                         {\n-                            as_primitive(path.res.expect_non_local()).map(|(_, prim)| {\n+                            path.res\n+                                .iter()\n+                                .find_map(|res| as_primitive(res.expect_non_local()))\n                                 // Pretend the primitive is local.\n-                                (id.owner_id.to_def_id(), prim)\n-                            })\n+                                .map(|(_, prim)| (id.owner_id.to_def_id(), prim))\n                         }\n                         _ => None,\n                     }\n@@ -1306,7 +1308,7 @@ impl Attributes {\n         for attr in self.other_attrs.lists(sym::doc).filter(|a| a.has_name(sym::alias)) {\n             if let Some(values) = attr.meta_item_list() {\n                 for l in values {\n-                    match l.literal().unwrap().kind {\n+                    match l.lit().unwrap().kind {\n                         ast::LitKind::Str(s, _) => {\n                             aliases.insert(s);\n                         }\n@@ -2572,7 +2574,7 @@ mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // tidy-alphabetical-start\n-    static_assert_size!(Crate, 72); // frequently moved by-value\n+    static_assert_size!(Crate, 64); // frequently moved by-value\n     static_assert_size!(DocFragment, 32);\n     static_assert_size!(GenericArg, 32);\n     static_assert_size!(GenericArgs, 32);"}, {"sha": "246560bad291ffcc173fd72610030f1138951f75", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64d8670e4c512c29e6a58c73c0aba65f00bb800/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=b64d8670e4c512c29e6a58c73c0aba65f00bb800", "patch": "@@ -73,7 +73,7 @@ pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n         }));\n     }\n \n-    Crate { module, primitives, external_traits: cx.external_traits.clone() }\n+    Crate { module, external_traits: cx.external_traits.clone() }\n }\n \n pub(crate) fn substs_to_args<'tcx>(\n@@ -106,7 +106,7 @@ fn external_generic_args<'tcx>(\n ) -> GenericArgs {\n     let args = substs_to_args(cx, substs, has_self);\n \n-    if cx.tcx.fn_trait_kind_from_lang_item(did).is_some() {\n+    if cx.tcx.fn_trait_kind_from_def_id(did).is_some() {\n         let inputs =\n             // The trait's first substitution is the one after self, if there is one.\n             match substs.iter().nth(if has_self { 1 } else { 0 }).unwrap().expect_ty().kind() {"}]}