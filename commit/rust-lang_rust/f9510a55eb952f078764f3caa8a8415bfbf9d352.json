{"sha": "f9510a55eb952f078764f3caa8a8415bfbf9d352", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NTEwYTU1ZWI5NTJmMDc4NzY0ZjNjYWE4YTg0MTViZmJmOWQzNTI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-11T22:44:06Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:46:39Z"}, "message": "chains: fix visual indent chain layout", "tree": {"sha": "dddab72f2024b0736d9c3cd24203bfba965c6ab7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dddab72f2024b0736d9c3cd24203bfba965c6ab7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9510a55eb952f078764f3caa8a8415bfbf9d352", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9510a55eb952f078764f3caa8a8415bfbf9d352", "html_url": "https://github.com/rust-lang/rust/commit/f9510a55eb952f078764f3caa8a8415bfbf9d352", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9510a55eb952f078764f3caa8a8415bfbf9d352/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8618a558342e98b57f5b2e4697c615b1d0f9b735", "url": "https://api.github.com/repos/rust-lang/rust/commits/8618a558342e98b57f5b2e4697c615b1d0f9b735", "html_url": "https://github.com/rust-lang/rust/commit/8618a558342e98b57f5b2e4697c615b1d0f9b735"}], "stats": {"total": 146, "additions": 85, "deletions": 61}, "files": [{"sha": "45b45b16732a14489308138be4e978d05062974f", "filename": "src/chains.rs", "status": "modified", "additions": 79, "deletions": 61, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/f9510a55eb952f078764f3caa8a8415bfbf9d352/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9510a55eb952f078764f3caa8a8415bfbf9d352/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=f9510a55eb952f078764f3caa8a8415bfbf9d352", "patch": "@@ -275,12 +275,12 @@ impl Rewrite for Chain {\n         };\n \n         formatter.format_root(&self.parent, context, shape)?;\n-        if let result @ Some(_) = formatter.pure_root() {\n-            return result;\n+        if let Some(result) = formatter.pure_root() {\n+            return wrap_str(result, context.config.max_width(), shape);\n         }\n \n         // Decide how to layout the rest of the chain.\n-        let child_shape = formatter.child_shape(context, shape);\n+        let child_shape = formatter.child_shape(context, shape)?;\n \n         formatter.format_children(context, child_shape)?;\n         formatter.format_last_child(context, shape, child_shape)?;\n@@ -309,7 +309,7 @@ trait ChainFormatter {\n         context: &RewriteContext,\n         shape: Shape,\n     ) -> Option<()>;\n-    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Shape;\n+    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Option<Shape>;\n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()>;\n     fn format_last_child(\n         &mut self,\n@@ -414,8 +414,10 @@ impl<'a> ChainFormatterShared<'a> {\n \n         let all_in_one_line =\n             self.rewrites.iter().all(|s| !s.contains('\\n')) && one_line_budget > 0;\n-        let last_shape = if all_in_one_line || extendable {\n+        let last_shape = if all_in_one_line {\n             shape.sub_width(last.tries)?\n+        } else if extendable {\n+            child_shape.sub_width(last.tries)?\n         } else {\n             child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?\n         };\n@@ -481,7 +483,7 @@ impl<'a> ChainFormatterShared<'a> {\n             if *context.force_one_line_chain.borrow() {\n                 return None;\n             }\n-            child_shape.indent.to_string_with_newline(context.config)\n+            child_shape.to_string_with_newline(context.config)\n         };\n \n         let mut rewrite_iter = self.rewrites.iter();\n@@ -512,37 +514,6 @@ impl<'a> ChainFormatterBlock<'a> {\n             is_block_like: Vec::with_capacity(chain.children.len() + 1),\n         }\n     }\n-\n-    // States whether an expression's last line exclusively consists of closing\n-    // parens, braces, and brackets in its idiomatic formatting.\n-    fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool {\n-        match expr.node {\n-            ast::ExprKind::Mac(..)\n-            | ast::ExprKind::Call(..)\n-            | ast::ExprKind::MethodCall(..)\n-            | ast::ExprKind::Struct(..)\n-            | ast::ExprKind::While(..)\n-            | ast::ExprKind::WhileLet(..)\n-            | ast::ExprKind::If(..)\n-            | ast::ExprKind::IfLet(..)\n-            | ast::ExprKind::Block(..)\n-            | ast::ExprKind::Loop(..)\n-            | ast::ExprKind::ForLoop(..)\n-            | ast::ExprKind::Match(..) => repr.contains('\\n'),\n-            ast::ExprKind::Paren(ref expr)\n-            | ast::ExprKind::Binary(_, _, ref expr)\n-            | ast::ExprKind::Index(_, ref expr)\n-            | ast::ExprKind::Unary(_, ref expr)\n-            | ast::ExprKind::Closure(_, _, _, _, ref expr, _)\n-            | ast::ExprKind::Try(ref expr)\n-            | ast::ExprKind::Yield(Some(ref expr)) => Self::is_block_expr(context, expr, repr),\n-            // This can only be a string lit\n-            ast::ExprKind::Lit(_) => {\n-                repr.contains('\\n') && trimmed_last_line_width(repr) <= context.config.tab_spaces()\n-            }\n-            _ => false,\n-        }\n-    }\n }\n \n impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n@@ -554,7 +525,7 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n     ) -> Option<()> {\n         let mut root_rewrite: String = parent.rewrite(context, shape)?;\n \n-        let mut root_ends_with_block = Self::is_block_expr(context, &parent.expr, &root_rewrite);\n+        let mut root_ends_with_block = is_block_expr(context, &parent.expr, &root_rewrite);\n         let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n \n         while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n@@ -565,7 +536,7 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n                 None => break,\n             }\n \n-            root_ends_with_block = Self::is_block_expr(context, &item.expr, &root_rewrite);\n+            root_ends_with_block = is_block_expr(context, &item.expr, &root_rewrite);\n \n             self.shared.children = &self.shared.children[..self.shared.children.len() - 1];\n             if self.shared.children.is_empty() {\n@@ -577,19 +548,21 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n         Some(())\n     }\n \n-    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Shape {\n-        if self.is_block_like[0] {\n-            shape\n-        } else {\n-            shape.block_indent(context.config.tab_spaces())\n-        }.with_max_width(context.config)\n+    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Option<Shape> {\n+        Some(\n+            if self.is_block_like[0] {\n+                shape.block_indent(0)\n+            } else {\n+                shape.block_indent(context.config.tab_spaces())\n+            }.with_max_width(context.config),\n+        )\n     }\n \n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n         for item in self.shared.children[1..].iter().rev() {\n             let rewrite = item.rewrite_postfix(context, child_shape)?;\n             self.is_block_like\n-                .push(Self::is_block_expr(context, &item.expr, &rewrite));\n+                .push(is_block_expr(context, &item.expr, &rewrite));\n             self.shared.rewrites.push(rewrite);\n         }\n         Some(())\n@@ -618,12 +591,15 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n // Format a chain using visual indent.\n struct ChainFormatterVisual<'a> {\n     shared: ChainFormatterShared<'a>,\n+    // The extra offset from the chain's shape to the position of the `.`\n+    offset: usize,\n }\n \n impl<'a> ChainFormatterVisual<'a> {\n     fn new(chain: &'a Chain) -> ChainFormatterVisual<'a> {\n         ChainFormatterVisual {\n             shared: ChainFormatterShared::new(chain),\n+            offset: 0,\n         }\n     }\n }\n@@ -635,23 +611,31 @@ impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n         context: &RewriteContext,\n         shape: Shape,\n     ) -> Option<()> {\n-        // Determines if we can continue formatting a given expression on the same line.\n-        fn is_continuable(expr: &ast::Expr) -> bool {\n-            match expr.node {\n-                ast::ExprKind::Path(..) => true,\n-                _ => false,\n-            }\n-        }\n-\n         let parent_shape = shape.visual_indent(0);\n         let mut root_rewrite = parent.rewrite(context, parent_shape)?;\n+        let multiline = root_rewrite.contains('\\n');\n+        self.offset = if multiline {\n+            last_line_width(&root_rewrite).saturating_sub(shape.used_width())\n+        } else {\n+            trimmed_last_line_width(&root_rewrite)\n+        };\n \n-        if !root_rewrite.contains('\\n') && is_continuable(&parent.expr) {\n+        if !multiline || is_block_expr(context, &parent.expr, &root_rewrite) {\n             let item = &self.shared.children[self.shared.children.len() - 1];\n-            let overhead = last_line_width(&root_rewrite);\n-            let shape = parent_shape.offset_left(overhead)?;\n-            let rewrite = item.rewrite_postfix(context, shape)?;\n-            root_rewrite.push_str(&rewrite);\n+            let child_shape = parent_shape\n+                .visual_indent(self.offset)\n+                .sub_width(self.offset)?;\n+            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+            match wrap_str(rewrite, context.config.max_width(), shape) {\n+                Some(rewrite) => root_rewrite.push_str(&rewrite),\n+                None => {\n+                    // We couldn't fit in at the visual indent, try the last\n+                    // indent.\n+                    let rewrite = item.rewrite_postfix(context, parent_shape)?;\n+                    root_rewrite.push_str(&rewrite);\n+                    self.offset = 0;\n+                }\n+            }\n \n             self.shared.children = &self.shared.children[..self.shared.children.len() - 1];\n         }\n@@ -660,8 +644,11 @@ impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n         Some(())\n     }\n \n-    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Shape {\n-        shape.visual_indent(0).with_max_width(context.config)\n+    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Option<Shape> {\n+        shape\n+            .with_max_width(context.config)\n+            .offset_left(self.offset)\n+            .map(|s| s.visual_indent(0))\n     }\n \n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n@@ -691,3 +678,34 @@ impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n         self.shared.pure_root()\n     }\n }\n+\n+// States whether an expression's last line exclusively consists of closing\n+// parens, braces, and brackets in its idiomatic formatting.\n+fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool {\n+    match expr.node {\n+        ast::ExprKind::Mac(..)\n+        | ast::ExprKind::Call(..)\n+        | ast::ExprKind::MethodCall(..)\n+        | ast::ExprKind::Struct(..)\n+        | ast::ExprKind::While(..)\n+        | ast::ExprKind::WhileLet(..)\n+        | ast::ExprKind::If(..)\n+        | ast::ExprKind::IfLet(..)\n+        | ast::ExprKind::Block(..)\n+        | ast::ExprKind::Loop(..)\n+        | ast::ExprKind::ForLoop(..)\n+        | ast::ExprKind::Match(..) => repr.contains('\\n'),\n+        ast::ExprKind::Paren(ref expr)\n+        | ast::ExprKind::Binary(_, _, ref expr)\n+        | ast::ExprKind::Index(_, ref expr)\n+        | ast::ExprKind::Unary(_, ref expr)\n+        | ast::ExprKind::Closure(_, _, _, _, ref expr, _)\n+        | ast::ExprKind::Try(ref expr)\n+        | ast::ExprKind::Yield(Some(ref expr)) => is_block_expr(context, expr, repr),\n+        // This can only be a string lit\n+        ast::ExprKind::Lit(_) => {\n+            repr.contains('\\n') && trimmed_last_line_width(repr) <= context.config.tab_spaces()\n+        }\n+        _ => false,\n+    }\n+}"}, {"sha": "12a911a19315a583d9a62e733758567725cf7ad9", "filename": "src/shape.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9510a55eb952f078764f3caa8a8415bfbf9d352/src%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9510a55eb952f078764f3caa8a8415bfbf9d352/src%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshape.rs?ref=f9510a55eb952f078764f3caa8a8415bfbf9d352", "patch": "@@ -274,6 +274,12 @@ impl Shape {\n         );\n         Shape { width, ..*self }\n     }\n+\n+    pub fn to_string_with_newline(&self, config: &Config) -> Cow<'static, str> {\n+        let mut offset_indent = self.indent;\n+        offset_indent.alignment = self.offset;\n+        offset_indent.to_string_inner(config, 0)\n+    }\n }\n \n #[cfg(test)]"}]}