{"sha": "4772dc8087b1d0f2bab6d064fd930e596c82d439", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NzJkYzgwODdiMWQwZjJiYWI2ZDA2NGZkOTMwZTU5NmM4MmQ0Mzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-13T22:23:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-13T22:23:09Z"}, "message": "Auto merge of #58432 - Centril:rollup, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #58110 (libpanic_unwind => 2018)\n - #58167 (HirId-ify hir::BodyId)\n - #58202 (Ignore future deprecations in #[deprecated])\n - #58272 (Cut down on number formating code size)\n - #58276 (Improve the error messages for missing stability attributes)\n - #58354 (Fix ICE and invalid filenames in MIR printing code)\n - #58381 (Only suggest imports if not imported.)\n - #58386 (Fix #54242)\n - #58400 (Fix rustc_driver swallowing errors when compilation is stopped)\n - #58420 (target/uefi: clarify documentation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "7c8656ec979db015bf10de0754069c549ecb8840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c8656ec979db015bf10de0754069c549ecb8840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4772dc8087b1d0f2bab6d064fd930e596c82d439", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4772dc8087b1d0f2bab6d064fd930e596c82d439", "html_url": "https://github.com/rust-lang/rust/commit/4772dc8087b1d0f2bab6d064fd930e596c82d439", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4772dc8087b1d0f2bab6d064fd930e596c82d439/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e54494727855cd14229f5d456591ed2a2f027c46", "url": "https://api.github.com/repos/rust-lang/rust/commits/e54494727855cd14229f5d456591ed2a2f027c46", "html_url": "https://github.com/rust-lang/rust/commit/e54494727855cd14229f5d456591ed2a2f027c46"}, {"sha": "05cfcb5eb2ad816712d5b047747f14e92b2575a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/05cfcb5eb2ad816712d5b047747f14e92b2575a0", "html_url": "https://github.com/rust-lang/rust/commit/05cfcb5eb2ad816712d5b047747f14e92b2575a0"}], "stats": {"total": 1198, "additions": 753, "deletions": 445}, "files": [{"sha": "7efb7f31298bf194fea3657d7555519e26a04a46", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1036,6 +1036,27 @@ pub fn write(output: &mut dyn Write, args: Arguments) -> Result {\n     Ok(())\n }\n \n+/// Padding after the end of something. Returned by `Formatter::padding`.\n+#[must_use = \"don't forget to write the post padding\"]\n+struct PostPadding {\n+    fill: char,\n+    padding: usize,\n+}\n+\n+impl PostPadding {\n+    fn new(fill: char, padding: usize) -> PostPadding {\n+        PostPadding { fill, padding }\n+    }\n+\n+    /// Write this post padding.\n+    fn write(self, buf: &mut dyn Write) -> Result {\n+        for _ in 0..self.padding {\n+            buf.write_char(self.fill)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'a> Formatter<'a> {\n     fn wrap_buf<'b, 'c, F>(&'b mut self, wrap: F) -> Formatter<'c>\n         where 'b: 'c, F: FnOnce(&'b mut (dyn Write+'b)) -> &'c mut (dyn Write+'c)\n@@ -1153,47 +1174,56 @@ impl<'a> Formatter<'a> {\n             sign = Some('+'); width += 1;\n         }\n \n-        let prefixed = self.alternate();\n-        if prefixed {\n+        let prefix = if self.alternate() {\n             width += prefix.chars().count();\n-        }\n+            Some(prefix)\n+        } else {\n+            None\n+        };\n \n         // Writes the sign if it exists, and then the prefix if it was requested\n-        let write_prefix = |f: &mut Formatter| {\n+        #[inline(never)]\n+        fn write_prefix(f: &mut Formatter, sign: Option<char>, prefix: Option<&str>) -> Result {\n             if let Some(c) = sign {\n                 f.buf.write_char(c)?;\n             }\n-            if prefixed { f.buf.write_str(prefix) }\n-            else { Ok(()) }\n-        };\n+            if let Some(prefix) = prefix {\n+                f.buf.write_str(prefix)\n+            } else {\n+                Ok(())\n+            }\n+        }\n \n         // The `width` field is more of a `min-width` parameter at this point.\n         match self.width {\n             // If there's no minimum length requirements then we can just\n             // write the bytes.\n             None => {\n-                write_prefix(self)?; self.buf.write_str(buf)\n+                write_prefix(self, sign, prefix)?;\n+                self.buf.write_str(buf)\n             }\n             // Check if we're over the minimum width, if so then we can also\n             // just write the bytes.\n             Some(min) if width >= min => {\n-                write_prefix(self)?; self.buf.write_str(buf)\n+                write_prefix(self, sign, prefix)?;\n+                self.buf.write_str(buf)\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n             Some(min) if self.sign_aware_zero_pad() => {\n                 self.fill = '0';\n                 self.align = rt::v1::Alignment::Right;\n-                write_prefix(self)?;\n-                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n-                    f.buf.write_str(buf)\n-                })\n+                write_prefix(self, sign, prefix)?;\n+                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n+                self.buf.write_str(buf)?;\n+                post_padding.write(self.buf)\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n-                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n-                    write_prefix(f)?; f.buf.write_str(buf)\n-                })\n+                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n+                write_prefix(self, sign, prefix)?;\n+                self.buf.write_str(buf)?;\n+                post_padding.write(self.buf)\n             }\n         }\n     }\n@@ -1264,19 +1294,21 @@ impl<'a> Formatter<'a> {\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n                 let align = rt::v1::Alignment::Left;\n-                self.with_padding(width - s.chars().count(), align, |me| {\n-                    me.buf.write_str(s)\n-                })\n+                let post_padding = self.padding(width - s.chars().count(), align)?;\n+                self.buf.write_str(s)?;\n+                post_padding.write(self.buf)\n             }\n         }\n     }\n \n-    /// Runs a callback, emitting the correct padding either before or\n-    /// afterwards depending on whether right or left alignment is requested.\n-    fn with_padding<F>(&mut self, padding: usize, default: rt::v1::Alignment,\n-                       f: F) -> Result\n-        where F: FnOnce(&mut Formatter) -> Result,\n-    {\n+    /// Write the pre-padding and return the unwritten post-padding. Callers are\n+    /// responsible for ensuring post-padding is written after the thing that is\n+    /// being padded.\n+    fn padding(\n+        &mut self,\n+        padding: usize,\n+        default: rt::v1::Alignment\n+    ) -> result::Result<PostPadding, Error> {\n         let align = match self.align {\n             rt::v1::Alignment::Unknown => default,\n             _ => self.align\n@@ -1289,20 +1321,11 @@ impl<'a> Formatter<'a> {\n             rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n-        let mut fill = [0; 4];\n-        let fill = self.fill.encode_utf8(&mut fill);\n-\n         for _ in 0..pre_pad {\n-            self.buf.write_str(fill)?;\n-        }\n-\n-        f(self)?;\n-\n-        for _ in 0..post_pad {\n-            self.buf.write_str(fill)?;\n+            self.buf.write_char(self.fill)?;\n         }\n \n-        Ok(())\n+        Ok(PostPadding::new(self.fill, post_pad))\n     }\n \n     /// Takes the formatted parts and applies the padding.\n@@ -1334,9 +1357,9 @@ impl<'a> Formatter<'a> {\n             let ret = if width <= len { // no padding\n                 self.write_formatted_parts(&formatted)\n             } else {\n-                self.with_padding(width - len, align, |f| {\n-                    f.write_formatted_parts(&formatted)\n-                })\n+                let post_padding = self.padding(width - len, align)?;\n+                self.write_formatted_parts(&formatted)?;\n+                post_padding.write(self.buf)\n             };\n             self.fill = old_fill;\n             self.align = old_align;"}, {"sha": "b9fa3640371082148624f625ad1e0eabbea9faa7", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 52, "deletions": 35, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -178,45 +178,36 @@ integer! { i32, u32 }\n integer! { i64, u64 }\n integer! { i128, u128 }\n \n-const DEC_DIGITS_LUT: &'static[u8] =\n+\n+static DEC_DIGITS_LUT: &[u8; 200] =\n     b\"0001020304050607080910111213141516171819\\\n       2021222324252627282930313233343536373839\\\n       4041424344454647484950515253545556575859\\\n       6061626364656667686970717273747576777879\\\n       8081828384858687888990919293949596979899\";\n \n macro_rules! impl_Display {\n-    ($($t:ident),*: $conv_fn:ident) => ($(\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl fmt::Display for $t {\n-        #[allow(unused_comparisons)]\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            let is_nonnegative = *self >= 0;\n-            let mut n = if is_nonnegative {\n-                self.$conv_fn()\n-            } else {\n-                // convert the negative num to positive by summing 1 to it's 2 complement\n-                (!self.$conv_fn()).wrapping_add(1)\n-            };\n+    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n+        fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter) -> fmt::Result {\n             let mut buf = uninitialized_array![u8; 39];\n             let mut curr = buf.len() as isize;\n             let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             unsafe {\n                 // need at least 16 bits for the 4-characters-at-a-time to work.\n-                if ::mem::size_of::<$t>() >= 2 {\n-                    // eagerly decode 4 characters at a time\n-                    while n >= 10000 {\n-                        let rem = (n % 10000) as isize;\n-                        n /= 10000;\n-\n-                        let d1 = (rem / 100) << 1;\n-                        let d2 = (rem % 100) << 1;\n-                        curr -= 4;\n-                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n-                        ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n-                    }\n+                assert!(::mem::size_of::<$u>() >= 2);\n+\n+                // eagerly decode 4 characters at a time\n+                while n >= 10000 {\n+                    let rem = (n % 10000) as isize;\n+                    n /= 10000;\n+\n+                    let d1 = (rem / 100) << 1;\n+                    let d2 = (rem % 100) << 1;\n+                    curr -= 4;\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                 }\n \n                 // if we reach here numbers are <= 9999, so at most 4 chars long\n@@ -247,15 +238,41 @@ macro_rules! impl_Display {\n             };\n             f.pad_integral(is_nonnegative, \"\", buf_slice)\n         }\n-    })*);\n+\n+        $(\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl fmt::Display for $t {\n+                #[allow(unused_comparisons)]\n+                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                    let is_nonnegative = *self >= 0;\n+                    let n = if is_nonnegative {\n+                        self.$conv_fn()\n+                    } else {\n+                        // convert the negative num to positive by summing 1 to it's 2 complement\n+                        (!self.$conv_fn()).wrapping_add(1)\n+                    };\n+                    $name(n, is_nonnegative, f)\n+                }\n+            })*\n+    };\n+}\n+\n+// Include wasm32 in here since it doesn't reflect the native pointer size, and\n+// often cares strongly about getting a smaller code size.\n+#[cfg(any(target_pointer_width = \"64\", target_arch = \"wasm32\"))]\n+mod imp {\n+    use super::*;\n+    impl_Display!(\n+        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n+            as u64 via to_u64 named fmt_u64\n+    );\n+}\n+\n+#[cfg(not(any(target_pointer_width = \"64\", target_arch = \"wasm32\")))]\n+mod imp {\n+    use super::*;\n+    impl_Display!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named fmt_u32);\n+    impl_Display!(i64, u64 as u64 via to_u64 named fmt_u64);\n }\n \n-impl_Display!(i8, u8, i16, u16, i32, u32: to_u32);\n-impl_Display!(i64, u64: to_u64);\n-impl_Display!(i128, u128: to_u128);\n-#[cfg(target_pointer_width = \"16\")]\n-impl_Display!(isize, usize: to_u16);\n-#[cfg(target_pointer_width = \"32\")]\n-impl_Display!(isize, usize: to_u32);\n-#[cfg(target_pointer_width = \"64\")]\n-impl_Display!(isize, usize: to_u64);\n+impl_Display!(i128, u128 as u128 via to_u128 named fmt_u128);"}, {"sha": "1b3901ac11a96c580c605497a3a074c2fe58c50d", "filename": "src/libpanic_unwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2FCargo.toml?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"panic_unwind\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n path = \"lib.rs\""}, {"sha": "07fa2971847f65d5d49df89a547e3b6c8ca86d75", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n #![allow(unused)]\n \n-use dwarf::DwarfReader;\n+use crate::dwarf::DwarfReader;\n use core::mem;\n \n pub const DW_EH_PE_omit: u8 = 0xFF;\n@@ -51,7 +51,7 @@ pub enum EHAction {\n \n pub const USING_SJLJ_EXCEPTIONS: bool = cfg!(all(target_os = \"ios\", target_arch = \"arm\"));\n \n-pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext)\n+pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>)\n     -> Result<EHAction, ()>\n {\n     if lsda.is_null() {\n@@ -145,7 +145,7 @@ fn round_up(unrounded: usize, align: usize) -> Result<usize, ()> {\n }\n \n unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n-                               context: &EHContext,\n+                               context: &EHContext<'_>,\n                                encoding: u8)\n                                -> Result<usize, ()> {\n     if encoding == DW_EH_PE_omit {"}, {"sha": "18e9006468ef3500c6b7f4de3d79d2a440673013", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -10,10 +10,10 @@\n \n use core::any::Any;\n use core::ptr;\n+use core::mem;\n use alloc::boxed::Box;\n use libc::{self, c_int};\n use unwind as uw;\n-use core::mem;\n \n pub fn payload() -> *mut u8 {\n     ptr::null_mut()"}, {"sha": "e2b743b379704b5faf18c1d96c14b6aae9a00f72", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -52,7 +52,7 @@ use alloc::boxed::Box;\n \n use unwind as uw;\n use libc::{c_int, uintptr_t};\n-use dwarf::eh::{self, EHContext, EHAction};\n+use crate::dwarf::eh::{self, EHContext, EHAction};\n \n #[repr(C)]\n struct Exception {"}, {"sha": "9d3d8f6185bb3e955b226ad29f2d70305b5d0561", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -17,6 +17,8 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(allocator_api)]\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n@@ -32,11 +34,6 @@\n #![panic_runtime]\n #![feature(panic_runtime)]\n \n-extern crate alloc;\n-extern crate libc;\n-#[cfg(not(any(target_env = \"msvc\", all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))))]\n-extern crate unwind;\n-\n use alloc::boxed::Box;\n use core::intrinsics;\n use core::mem;\n@@ -87,7 +84,7 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n                                                   vtable_ptr: *mut usize)\n                                                   -> u32 {\n     let mut payload = imp::payload();\n-    if intrinsics::try(f, data, &mut payload as *mut _ as *mut _) == 0 {\n+    if intrinsics::r#try(f, data, &mut payload as *mut _ as *mut _) == 0 {\n         0\n     } else {\n         let obj = mem::transmute::<_, raw::TraitObject>(imp::cleanup(payload));"}, {"sha": "996fdb931eff2d49000f7d56212adea96c5d0172", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -52,7 +52,7 @@ use core::any::Any;\n use core::mem;\n use core::raw;\n \n-use windows as c;\n+use crate::windows as c;\n use libc::{c_int, c_uint};\n \n // First up, a whole bunch of type definitions. There's a few platform-specific\n@@ -301,5 +301,5 @@ pub unsafe fn cleanup(payload: [u64; 2]) -> Box<dyn Any + Send> {\n #[lang = \"eh_personality\"]\n #[cfg(not(test))]\n fn rust_eh_personality() {\n-    unsafe { ::core::intrinsics::abort() }\n+    unsafe { core::intrinsics::abort() }\n }"}, {"sha": "457ffcd34f9c7ad423cbeeed910b342e85655534", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -9,8 +9,8 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::intrinsics;\n use core::ptr;\n-use dwarf::eh::{EHContext, EHAction, find_eh_action};\n-use windows as c;\n+use crate::dwarf::eh::{EHContext, EHAction, find_eh_action};\n+use crate::windows as c;\n \n // Define our exception codes:\n // according to http://msdn.microsoft.com/en-us/library/het71c37(v=VS.80).aspx,"}, {"sha": "b6cf4c1b84d0c6454b91bfb8374518c31eef8756", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -127,9 +127,9 @@ impl<'hir> Entry<'hir> {\n         }\n     }\n \n-    fn is_body_owner(self, node_id: NodeId) -> bool {\n+    fn is_body_owner(self, hir_id: HirId) -> bool {\n         match self.associated_body() {\n-            Some(b) => b.node_id == node_id,\n+            Some(b) => b.hir_id == hir_id,\n             None => false,\n         }\n     }\n@@ -438,7 +438,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body {\n-        self.read(id.node_id);\n+        self.read_by_hir_id(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n@@ -462,9 +462,10 @@ impl<'hir> Map<'hir> {\n     /// Returns the `NodeId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n-    pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n+    pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> NodeId {\n+        let node_id = self.hir_to_node_id(hir_id);\n         let parent = self.get_parent_node(node_id);\n-        assert!(self.map[parent.as_usize()].map_or(false, |e| e.is_body_owner(node_id)));\n+        assert!(self.map[parent.as_usize()].map_or(false, |e| e.is_body_owner(hir_id)));\n         parent\n     }\n \n@@ -488,6 +489,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn maybe_body_owned_by_by_hir_id(&self, id: HirId) -> Option<BodyId> {\n+        let node_id = self.hir_to_node_id(id);\n+        self.maybe_body_owned_by(node_id)\n+    }\n+\n     /// Given a body owner's id, returns the `BodyId` associated with it.\n     pub fn body_owned_by(&self, id: NodeId) -> BodyId {\n         self.maybe_body_owned_by(id).unwrap_or_else(|| {\n@@ -521,6 +528,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn body_owner_kind_by_hir_id(&self, id: HirId) -> BodyOwnerKind {\n+        let node_id = self.hir_to_node_id(id);\n+        self.body_owner_kind(node_id)\n+    }\n+\n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n@@ -837,6 +850,12 @@ impl<'hir> Map<'hir> {\n         self.local_def_id(self.get_module_parent_node(id))\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_module_parent_by_hir_id(&self, id: HirId) -> DefId {\n+        let node_id = self.hir_to_node_id(id);\n+        self.get_module_parent(node_id)\n+    }\n+\n     /// Returns the `NodeId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, id: NodeId) -> NodeId {"}, {"sha": "0bf9857b4977762be53f30f69c8d581bb47d6b2d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -72,7 +72,7 @@ pub mod print;\n /// the `local_id` part of the `HirId` changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n pub struct HirId {\n     pub owner: DefIndex,\n     pub local_id: ItemLocalId,\n@@ -1234,7 +1234,7 @@ pub enum UnsafeSource {\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct BodyId {\n-    pub node_id: NodeId,\n+    pub hir_id: HirId,\n }\n \n /// The body of a function, closure, or constant value. In the case of\n@@ -1268,7 +1268,7 @@ pub struct Body {\n impl Body {\n     pub fn id(&self) -> BodyId {\n         BodyId {\n-            node_id: self.value.id\n+            hir_id: self.value.hir_id,\n         }\n     }\n }\n@@ -2290,7 +2290,7 @@ impl ItemKind {\n             ItemKind::Union(..) => \"union\",\n             ItemKind::Trait(..) => \"trait\",\n             ItemKind::TraitAlias(..) => \"trait alias\",\n-            ItemKind::Impl(..) => \"item\",\n+            ItemKind::Impl(..) => \"impl\",\n         }\n     }\n "}, {"sha": "b10e89373259798624d97801c4f5939b5967094b", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -989,8 +989,8 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::BodyId {\n     fn to_stable_hash_key(&self,\n                           hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n-        let hir::BodyId { node_id } = *self;\n-        node_id.to_stable_hash_key(hcx)\n+        let hir::BodyId { hir_id } = *self;\n+        hir_id.to_stable_hash_key(hcx)\n     }\n }\n "}, {"sha": "9e0e48e474118fd14730ee363d1f804427b4b026", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if let Some(body_id) = body_id {\n-            let expr = self.tcx.hir().expect_expr(body_id.node_id);\n+            let expr = self.tcx.hir().expect_expr_by_hir_id(body_id.hir_id);\n             local_visitor.visit_expr(expr);\n         }\n "}, {"sha": "a61771b2a4eeab2884b672a2c33391e0ec67b96d", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -7,6 +7,7 @@ pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n pub use crate::ty::IntVarValue;\n \n+use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::canonical::{Canonical, CanonicalVarValues};\n use crate::middle::free_region::RegionRelations;\n@@ -203,7 +204,7 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     // for each body-id in this map, which will process the\n     // obligations within. This is expected to be done 'late enough'\n     // that all type inference variables have been bound and so forth.\n-    pub region_obligations: RefCell<Vec<(ast::NodeId, RegionObligation<'tcx>)>>,\n+    pub region_obligations: RefCell<Vec<(hir::HirId, RegionObligation<'tcx>)>>,\n \n     /// What is the innermost universe we have created? Starts out as\n     /// `UniverseIndex::root()` but grows from there as we enter\n@@ -1433,7 +1434,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn partially_normalize_associated_types_in<T>(\n         &self,\n         span: Span,\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n     ) -> InferOk<'tcx, T>"}, {"sha": "1f81321d22d6ed1099dd7082ef905130050c1b3c", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n         parent_def_id: DefId,\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n@@ -632,7 +632,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     parent_def_id: DefId,\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     opaque_types: OpaqueTypeMap<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,"}, {"sha": "39aa51a95f793cb9bebe71b05f16bafc9f493df5", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::outlives::free_region_map::FreeRegionMap;\n use crate::infer::{GenericKind, InferCtxt};\n+use crate::hir;\n use rustc_data_structures::fx::FxHashMap;\n-use syntax::ast;\n use syntax_pos::Span;\n use crate::traits::query::outlives_bounds::{self, OutlivesBound};\n use crate::ty::{self, Ty};\n@@ -55,7 +55,7 @@ pub struct OutlivesEnvironment<'tcx> {\n     // results when proving outlives obligations like `T: 'x` later\n     // (e.g., if `T: 'x` must be proven within the body B1, then we\n     // know it is true if either `'a: 'x` or `'b: 'x`).\n-    region_bound_pairs_map: FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>>,\n+    region_bound_pairs_map: FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n \n     // Used to compute `region_bound_pairs_map`: contains the set of\n     // in-scope region-bound pairs thus far.\n@@ -87,7 +87,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     }\n \n     /// Borrows current value of the `region_bound_pairs`.\n-    pub fn region_bound_pairs_map(&self) -> &FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>> {\n+    pub fn region_bound_pairs_map(&self) -> &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>> {\n         &self.region_bound_pairs_map\n     }\n \n@@ -162,7 +162,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n         fn_sig_tys: &[Ty<'tcx>],\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         span: Span,\n     ) {\n         debug!(\"add_implied_bounds()\");\n@@ -176,7 +176,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     }\n \n     /// Save the current set of region-bound pairs under the given `body_id`.\n-    pub fn save_implied_bounds(&mut self, body_id: ast::NodeId) {\n+    pub fn save_implied_bounds(&mut self, body_id: hir::HirId) {\n         let old = self.region_bound_pairs_map.insert(\n             body_id,\n             self.region_bound_pairs_accum.clone(),"}, {"sha": "bbda3d2fdbf84d9ac15ebb7d186ac0e7cd65fd52", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -63,7 +63,7 @@ use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::outlives::verify::VerifyBoundCx;\n use crate::infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n use rustc_data_structures::fx::FxHashMap;\n-use syntax::ast;\n+use crate::hir;\n use crate::traits::ObligationCause;\n use crate::ty::outlives::Component;\n use crate::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n@@ -76,7 +76,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// information).\n     pub fn register_region_obligation(\n         &self,\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         obligation: RegionObligation<'tcx>,\n     ) {\n         debug!(\n@@ -110,7 +110,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Trait queries just want to pass back type obligations \"as is\"\n-    pub fn take_registered_region_obligations(&self) -> Vec<(ast::NodeId, RegionObligation<'tcx>)> {\n+    pub fn take_registered_region_obligations(&self) -> Vec<(hir::HirId, RegionObligation<'tcx>)> {\n         ::std::mem::replace(&mut *self.region_obligations.borrow_mut(), vec![])\n     }\n \n@@ -149,7 +149,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// processed.\n     pub fn process_registered_region_obligations(\n         &self,\n-        region_bound_pairs_map: &FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>>,\n+        region_bound_pairs_map: &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) {"}, {"sha": "30a43c7a92595c57c2b5a2ac25e14949a7d37ef5", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -322,14 +322,17 @@ struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n-    fn check_missing_stability(&self, id: NodeId, span: Span) {\n+    fn check_missing_stability(&self, id: NodeId, span: Span, name: &str) {\n         let hir_id = self.tcx.hir().node_to_hir_id(id);\n         let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&\n                         stab.is_none() &&\n                         self.access_levels.is_reachable(id);\n         if is_error {\n-            self.tcx.sess.span_err(span, \"This node does not have a stability attribute\");\n+            self.tcx.sess.span_err(\n+                span,\n+                &format!(\"{} has missing stability attribute\", name),\n+            );\n         }\n     }\n }\n@@ -347,42 +350,42 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n             // optional. They inherit stability from their parents when unannotated.\n             hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n \n-            _ => self.check_missing_stability(i.id, i.span)\n+            _ => self.check_missing_stability(i.id, i.span, i.node.descriptive_variant())\n         }\n \n         intravisit::walk_item(self, i)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        self.check_missing_stability(ti.id, ti.span);\n+        self.check_missing_stability(ti.id, ti.span, \"item\");\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent(ii.id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n-            self.check_missing_stability(ii.id, ii.span);\n+            self.check_missing_stability(ii.id, ii.span, \"item\");\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n-        self.check_missing_stability(var.node.data.id(), var.span);\n+        self.check_missing_stability(var.node.data.id(), var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField) {\n-        self.check_missing_stability(s.id, s.span);\n+        self.check_missing_stability(s.id, s.span, \"field\");\n         intravisit::walk_struct_field(self, s);\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n-        self.check_missing_stability(i.id, i.span);\n+        self.check_missing_stability(i.id, i.span, i.node.descriptive_variant());\n         intravisit::walk_foreign_item(self, i);\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        self.check_missing_stability(md.id, md.span);\n+        self.check_missing_stability(md.id, md.span, \"macro\");\n     }\n }\n \n@@ -593,37 +596,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Deprecated attributes apply in-crate and cross-crate.\n         if let Some(id) = id {\n             if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n-                // If the deprecation is scheduled for a future Rust\n-                // version, then we should display no warning message.\n-                let deprecated_in_future_version = if let Some(sym) = depr_entry.attr.since {\n-                    let since = sym.as_str();\n-                    if !deprecation_in_effect(&since) {\n-                        Some(since)\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                };\n-\n                 let parent_def_id = self.hir().local_def_id(self.hir().get_parent(id));\n                 let skip = self.lookup_deprecation_entry(parent_def_id)\n                                .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n-                if let Some(since) = deprecated_in_future_version {\n-                    let path = self.item_path_str(def_id);\n-                    let message = format!(\"use of item '{}' \\\n-                                           that will be deprecated in future version {}\",\n-                                          path,\n-                                          since);\n-\n-                    lint_deprecated(def_id,\n-                                    id,\n-                                    depr_entry.attr.note,\n-                                    None,\n-                                    &message,\n-                                    lint::builtin::DEPRECATED_IN_FUTURE);\n-                } else if !skip {\n+                if !skip {\n                     let path = self.item_path_str(def_id);\n                     let message = format!(\"use of deprecated item '{}'\", path);\n                     lint_deprecated(def_id,\n@@ -866,7 +843,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             tcx,\n             access_levels,\n         };\n-        missing.check_missing_stability(ast::CRATE_NODE_ID, krate.span);\n+        missing.check_missing_stability(ast::CRATE_NODE_ID, krate.span, \"crate\");\n         intravisit::walk_crate(&mut missing, krate);\n         krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }"}, {"sha": "8957bbaa4ad7d9eb3df9793e8398b28e2e6e56fd", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 full_env,\n                 ty,\n                 trait_did,\n-                ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+                ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID),\n             );\n             fulfill.select_all_or_error(&infcx).unwrap_or_else(|e| {\n                 panic!(\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             user_env.caller_bounds.iter().cloned().collect();\n \n         let mut new_env = param_env.clone();\n-        let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+        let dummy_cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n \n         while let Some(pred) = predicates.pop_front() {\n             infcx.clear_caches();\n@@ -669,7 +669,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         select: &mut SelectionContext<'c, 'd, 'cx>,\n         only_projections: bool,\n     ) -> bool {\n-        let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+        let dummy_cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n \n         for (obligation, mut predicate) in nested\n             .map(|o| (o.clone(), o.predicate.clone()))"}, {"sha": "459ff4db9e957d6157cc034bb1cd5556eafeb82b", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -132,7 +132,7 @@ pub struct ObligationCause<'tcx> {\n     /// (in particular, closures can add new assumptions). See the\n     /// field `region_obligations` of the `FulfillmentContext` for more\n     /// information.\n-    pub body_id: ast::NodeId,\n+    pub body_id: hir::HirId,\n \n     pub code: ObligationCauseCode<'tcx>\n }\n@@ -654,7 +654,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n     };\n     let obligation = Obligation {\n         param_env,\n-        cause: ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n+        cause: ObligationCause::misc(span, hir::DUMMY_HIR_ID),\n         recursion_depth: 0,\n         predicate: trait_ref.to_predicate(),\n     };\n@@ -677,7 +677,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n         // anyhow).\n-        let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n+        let cause = ObligationCause::misc(span, hir::DUMMY_HIR_ID);\n \n         fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n \n@@ -1057,7 +1057,7 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     }\n \n     pub fn misc(span: Span,\n-                body_id: ast::NodeId,\n+                body_id: hir::HirId,\n                 param_env: ty::ParamEnv<'tcx>,\n                 trait_ref: O)\n                 -> Obligation<'tcx, O> {\n@@ -1075,18 +1075,18 @@ impl<'tcx,O> Obligation<'tcx,O> {\n impl<'tcx> ObligationCause<'tcx> {\n     #[inline]\n     pub fn new(span: Span,\n-               body_id: ast::NodeId,\n+               body_id: hir::HirId,\n                code: ObligationCauseCode<'tcx>)\n                -> ObligationCause<'tcx> {\n-        ObligationCause { span: span, body_id: body_id, code: code }\n+        ObligationCause { span, body_id, code }\n     }\n \n-    pub fn misc(span: Span, body_id: ast::NodeId) -> ObligationCause<'tcx> {\n-        ObligationCause { span: span, body_id: body_id, code: MiscObligation }\n+    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id, code: MiscObligation }\n     }\n \n     pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, body_id: ast::CRATE_NODE_ID, code: MiscObligation }\n+        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation }\n     }\n }\n "}, {"sha": "954de15905fb7092875e64a2178671e232f5e8bc", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::InferCtxt;\n use crate::infer::canonical::OriginalQueryValues;\n-use syntax::ast;\n+use crate::hir;\n use syntax::source_map::Span;\n use crate::traits::{FulfillmentContext, ObligationCause, TraitEngine, TraitEngineExt};\n use crate::traits::query::NoSolution;\n@@ -89,7 +89,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     pub fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         ty: Ty<'tcx>,\n         span: Span,\n     ) -> Vec<OutlivesBound<'tcx>> {"}, {"sha": "1bb67b3ffaae84cc6e09431d62c19971f5637757", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -39,7 +39,7 @@ use std::ops::Deref;\n use rustc_data_structures::sync::{self, Lrc, ParallelIterator, par_iter};\n use std::slice;\n use std::{mem, ptr};\n-use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n+use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::{keywords, Symbol, LocalInternedString, InternedString};\n@@ -2795,7 +2795,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n         variant.fields.iter().position(|field| {\n-            self.adjust_ident(ident, variant.did, DUMMY_NODE_ID).0 == field.ident.modern()\n+            self.adjust_ident(ident, variant.did, hir::DUMMY_HIR_ID).0 == field.ident.modern()\n         })\n     }\n \n@@ -3003,10 +3003,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// its supposed definition name (`def_name`). The method also needs `DefId` of the supposed\n     /// definition's parent/scope to perform comparison.\n     pub fn hygienic_eq(self, use_name: Ident, def_name: Ident, def_parent_def_id: DefId) -> bool {\n-        self.adjust_ident(use_name, def_parent_def_id, DUMMY_NODE_ID).0 == def_name.modern()\n+        self.adjust_ident(use_name, def_parent_def_id, hir::DUMMY_HIR_ID).0 == def_name.modern()\n     }\n \n-    pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {\n+    pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: hir::HirId) -> (Ident, DefId) {\n         ident = ident.modern();\n         let target_expansion = match scope.krate {\n             LOCAL_CRATE => self.hir().definitions().expansion_that_defined(scope.index),\n@@ -3015,8 +3015,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let scope = match ident.span.adjust(target_expansion) {\n             Some(actual_expansion) =>\n                 self.hir().definitions().parent_module_of_macro_def(actual_expansion),\n-            None if block == DUMMY_NODE_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n-            None => self.hir().get_module_parent(block),\n+            None if block == hir::DUMMY_HIR_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n+            None => self.hir().get_module_parent_by_hir_id(block),\n         };\n         (ident, scope)\n     }\n@@ -3193,8 +3193,8 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if tcx.sess.opts.debugging_opts.chalk { Some(def_id) } else { None }\n     );\n \n-    let body_id = tcx.hir().as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n-        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.node_id)\n+    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {\n+        tcx.hir().maybe_body_owned_by_by_hir_id(id).map_or(id, |body| body.hir_id)\n     });\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)"}, {"sha": "233aff9de243fda3e600d2f30dd52d8a7d1049a4", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -188,40 +188,6 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n \n         job.signal_complete();\n     }\n-\n-    /// Executes a job by changing the ImplicitCtxt to point to the\n-    /// new query job while it executes. It returns the diagnostics\n-    /// captured during execution and the actual result.\n-    #[inline(always)]\n-    pub(super) fn start<'lcx, F, R>(\n-        &self,\n-        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n-        diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n-        compute: F)\n-    -> R\n-    where\n-        F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'lcx>) -> R\n-    {\n-        // The TyCtxt stored in TLS has the same global interner lifetime\n-        // as `tcx`, so we use `with_related_context` to relate the 'gcx lifetimes\n-        // when accessing the ImplicitCtxt\n-        tls::with_related_context(tcx, move |current_icx| {\n-            // Update the ImplicitCtxt to point to our new query job\n-            let new_icx = tls::ImplicitCtxt {\n-                tcx: tcx.global_tcx(),\n-                query: Some(self.job.clone()),\n-                diagnostics,\n-                layout_depth: current_icx.layout_depth,\n-                task_deps: current_icx.task_deps,\n-            };\n-\n-            // Use the ImplicitCtxt while we execute the query\n-            tls::enter_context(&new_icx, |_| {\n-                compute(tcx)\n-            })\n-        })\n-    }\n-\n }\n \n #[inline(always)]\n@@ -265,6 +231,39 @@ pub(super) enum TryGetJob<'a, 'tcx: 'a, D: QueryDescription<'tcx> + 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    /// Executes a job by changing the ImplicitCtxt to point to the\n+    /// new query job while it executes. It returns the diagnostics\n+    /// captured during execution and the actual result.\n+    #[inline(always)]\n+    pub(super) fn start_query<F, R>(\n+        self,\n+        job: Lrc<QueryJob<'gcx>>,\n+        diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n+        compute: F)\n+    -> R\n+    where\n+        F: for<'b, 'lcx> FnOnce(TyCtxt<'b, 'gcx, 'lcx>) -> R\n+    {\n+        // The TyCtxt stored in TLS has the same global interner lifetime\n+        // as `self`, so we use `with_related_context` to relate the 'gcx lifetimes\n+        // when accessing the ImplicitCtxt\n+        tls::with_related_context(self, move |current_icx| {\n+            // Update the ImplicitCtxt to point to our new query job\n+            let new_icx = tls::ImplicitCtxt {\n+                tcx: self.global_tcx(),\n+                query: Some(job),\n+                diagnostics,\n+                layout_depth: current_icx.layout_depth,\n+                task_deps: current_icx.task_deps,\n+            };\n+\n+            // Use the ImplicitCtxt while we execute the query\n+            tls::enter_context(&new_icx, |_| {\n+                compute(self.global_tcx())\n+            })\n+        })\n+    }\n+\n     #[inline(never)]\n     #[cold]\n     pub(super) fn report_cycle(\n@@ -378,7 +377,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.sess.profiler(|p| p.start_query(Q::NAME, Q::CATEGORY));\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-                job.start(self, diagnostics, |tcx| {\n+                self.start_query(job.job.clone(), diagnostics, |tcx| {\n                     tcx.dep_graph.with_anon_task(dep_node.kind, || {\n                         Q::compute(tcx.global_tcx(), key)\n                     })\n@@ -401,16 +400,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if !dep_node.kind.is_input() {\n-            if let Some((prev_dep_node_index,\n-                         dep_node_index)) = self.dep_graph.try_mark_green_and_read(self,\n-                                                                                   &dep_node) {\n-                return Ok(self.load_from_disk_and_cache_in_memory::<Q>(\n-                    key,\n-                    job,\n-                    prev_dep_node_index,\n-                    dep_node_index,\n-                    &dep_node\n-                ))\n+            // The diagnostics for this query will be\n+            // promoted to the current session during\n+            // try_mark_green(), so we can ignore them here.\n+            let loaded = self.start_query(job.job.clone(), None, |tcx| {\n+                let marked = tcx.dep_graph.try_mark_green_and_read(tcx, &dep_node);\n+                marked.map(|(prev_dep_node_index, dep_node_index)| {\n+                    (tcx.load_from_disk_and_cache_in_memory::<Q>(\n+                        key.clone(),\n+                        prev_dep_node_index,\n+                        dep_node_index,\n+                        &dep_node\n+                    ), dep_node_index)\n+                })\n+            });\n+            if let Some((result, dep_node_index)) = loaded {\n+                job.complete(&result, dep_node_index);\n+                return Ok(result);\n             }\n         }\n \n@@ -422,7 +428,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     fn load_from_disk_and_cache_in_memory<Q: QueryDescription<'gcx>>(\n         self,\n         key: Q::Key,\n-        job: JobOwner<'a, 'gcx, Q>,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node_index: DepNodeIndex,\n         dep_node: &DepNode\n@@ -461,15 +466,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             self.sess.profiler(|p| p.start_query(Q::NAME, Q::CATEGORY));\n \n-            // The diagnostics for this query have already been\n-            // promoted to the current session during\n-            // try_mark_green(), so we can ignore them here.\n-            let result = job.start(self, None, |tcx| {\n-                // The dep-graph for this computation is already in\n-                // place\n-                tcx.dep_graph.with_ignore(|| {\n-                    Q::compute(tcx, key)\n-                })\n+            // The dep-graph for this computation is already in\n+            // place\n+            let result = self.dep_graph.with_ignore(|| {\n+                Q::compute(self, key)\n             });\n \n             self.sess.profiler(|p| p.end_query(Q::NAME, Q::CATEGORY));\n@@ -486,8 +486,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n         }\n \n-        job.complete(&result, dep_node_index);\n-\n         result\n     }\n \n@@ -540,7 +538,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.sess.profiler(|p| p.start_query(Q::NAME, Q::CATEGORY));\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-            job.start(self, diagnostics, |tcx| {\n+            self.start_query(job.job.clone(), diagnostics, |tcx| {\n                 if dep_node.kind.is_eval_always() {\n                     tcx.dep_graph.with_eval_always_task(dep_node,\n                                                         tcx,"}, {"sha": "282bf1219fa5c174deca13a16c972947c71129e5", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,10 +1,10 @@\n+use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::InferCtxt;\n use crate::ty::subst::Substs;\n use crate::traits;\n use crate::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use std::iter::once;\n-use syntax::ast;\n use syntax_pos::Span;\n use crate::middle::lang_items;\n \n@@ -16,7 +16,7 @@ use crate::middle::lang_items;\n /// say \"$0 is WF if $0 is WF\".\n pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                    param_env: ty::ParamEnv<'tcx>,\n-                                   body_id: ast::NodeId,\n+                                   body_id: hir::HirId,\n                                    ty: Ty<'tcx>,\n                                    span: Span)\n                                    -> Option<Vec<traits::PredicateObligation<'tcx>>>\n@@ -42,7 +42,7 @@ pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// if `Bar: Eq`.\n pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                          param_env: ty::ParamEnv<'tcx>,\n-                                         body_id: ast::NodeId,\n+                                         body_id: hir::HirId,\n                                          trait_ref: &ty::TraitRef<'tcx>,\n                                          span: Span)\n                                          -> Vec<traits::PredicateObligation<'tcx>>\n@@ -54,7 +54,7 @@ pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n \n pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                              param_env: ty::ParamEnv<'tcx>,\n-                                             body_id: ast::NodeId,\n+                                             body_id: hir::HirId,\n                                              predicate: &ty::Predicate<'tcx>,\n                                              span: Span)\n                                              -> Vec<traits::PredicateObligation<'tcx>>\n@@ -103,7 +103,7 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n }"}, {"sha": "307df163866392dcdabd7314bc633cb99e31b421", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -404,7 +404,7 @@ fn closure_to_block(closure_id: LocalDefId,\n     match tcx.hir().get(closure_id) {\n         Node::Expr(expr) => match expr.node {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n-                body_id.node_id\n+                tcx.hir().hir_to_node_id(body_id.hir_id)\n             }\n             _ => {\n                 bug!(\"encountered non-closure id: {}\", closure_id)"}, {"sha": "e5b290b55c22e5ad915562d44361a26c9eceb84b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -296,6 +296,11 @@ pub fn compile_input(\n                         (control.after_analysis.callback)(&mut state);\n                     });\n \n+                    // Plugins like clippy and rust-semverver stop the analysis early,\n+                    // but want to still return an error if errors during the analysis\n+                    // happened:\n+                    tcx.sess.compile_status()?;\n+\n                     if control.after_analysis.stop == Compilation::Stop {\n                         return result.and_then(|_| Err(CompileIncomplete::Stopped));\n                     }"}, {"sha": "c593be4e67f4577d0ce57c6ec09a8d624d3f61f4", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1174,9 +1174,9 @@ impl MirPass for QualifyAndPromoteConstants {\n         }\n \n         let def_id = src.def_id();\n-        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let mut const_promoted_temps = None;\n-        let mode = match tcx.hir().body_owner_kind(id) {\n+        let mode = match tcx.hir().body_owner_kind_by_hir_id(id) {\n             hir::BodyOwnerKind::Closure => Mode::Fn,\n             hir::BodyOwnerKind::Fn => {\n                 if tcx.is_const_fn(def_id) {"}, {"sha": "8177de50776d64758e164dbf622de5d9f85fe882", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -197,7 +197,7 @@ fn dump_path(\n                 .chars()\n                 .filter_map(|c| match c {\n                     ' ' => None,\n-                    ':' => Some('_'),\n+                    ':' | '<' | '>' => Some('_'),\n                     c => Some(c)\n                 }));\n             s\n@@ -603,7 +603,8 @@ fn write_mir_sig(\n     match (descr, src.promoted) {\n         (_, Some(i)) => write!(w, \"{:?} in \", i)?,\n         (Some(Def::StructCtor(..)), _) => write!(w, \"struct \")?,\n-        (Some(Def::Const(_)), _) => write!(w, \"const \")?,\n+        (Some(Def::Const(_)), _)\n+        | (Some(Def::AssociatedConst(_)), _) => write!(w, \"const \")?,\n         (Some(Def::Static(_, /*is_mutbl*/false)), _) => write!(w, \"static \")?,\n         (Some(Def::Static(_, /*is_mutbl*/true)), _) => write!(w, \"static mut \")?,\n         (_, _) if is_function => write!(w, \"fn \")?,"}, {"sha": "20f31b3ebc1736e4c4a4244639dac1fbf62713da", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -56,8 +56,7 @@ fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let node_id = tcx.hir().as_local_node_id(def_id)\n         .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n     let body_id = tcx.hir().body_owned_by(node_id);\n-    let body_hir_id = tcx.hir().node_to_hir_id(body_id.node_id);\n-    tcx.rvalue_promotable_map(def_id).contains(&body_hir_id.local_id)\n+    tcx.rvalue_promotable_map(def_id).contains(&body_id.hir_id.local_id)\n }\n \n fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "91651ad29dfa48e023beb1f65eb7cf2e9555c018", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -805,7 +805,8 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n                    def: &'tcx ty::AdtDef, // definition of the struct or enum\n                    field: &'tcx ty::FieldDef) { // definition of the field\n         let ident = Ident::new(keywords::Invalid.name(), use_ctxt);\n-        let def_id = self.tcx.adjust_ident(ident, def.did, self.current_item).1;\n+        let current_hir = self.tcx.hir().node_to_hir_id(self.current_item);\n+        let def_id = self.tcx.adjust_ident(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n                              field.ident, def.variant_descr(), self.tcx.item_path_str(def.did))"}, {"sha": "c8b3e2f4e4cf4684ff3bc1efb42efa525db5e5b1", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -106,7 +106,15 @@ impl<'a> Resolver<'a> {\n \n         // Try to lookup name in more relaxed fashion for better error reporting.\n         let ident = path.last().unwrap().ident;\n-        let candidates = self.lookup_import_candidates(ident, ns, is_expected);\n+        let candidates = self.lookup_import_candidates(ident, ns, is_expected)\n+            .drain(..)\n+            .filter(|ImportSuggestion { did, .. }| {\n+                match (did, def.and_then(|def| def.opt_def_id())) {\n+                    (Some(suggestion_did), Some(actual_did)) => *suggestion_did != actual_did,\n+                    _ => true,\n+                }\n+            })\n+            .collect::<Vec<_>>();\n         if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n             let enum_candidates =\n                 self.lookup_import_candidates(ident, ns, is_enum_variant);"}, {"sha": "fbed1145cd156089da8e95330e8a3023297cb9cc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -24,7 +24,7 @@ use rustc::hir::def::*;\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n-use rustc::ty;\n+use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::{bug, span_bug};\n \n@@ -92,6 +92,7 @@ enum ScopeSet {\n \n /// A free importable items suggested in case of resolution failure.\n struct ImportSuggestion {\n+    did: Option<DefId>,\n     path: Path,\n }\n \n@@ -4391,7 +4392,8 @@ impl<'a> Resolver<'a> {\n \n                 // collect results based on the filter function\n                 if ident.name == lookup_ident.name && ns == namespace {\n-                    if filter_fn(name_binding.def()) {\n+                    let def = name_binding.def();\n+                    if filter_fn(def) {\n                         // create the path\n                         let mut segms = path_segments.clone();\n                         if lookup_ident.span.rust_2018() {\n@@ -4415,7 +4417,12 @@ impl<'a> Resolver<'a> {\n                         // declared as public (due to pruning, we don't explore\n                         // outside crate private modules => no need to check this)\n                         if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n-                            candidates.push(ImportSuggestion { path });\n+                            let did = match def {\n+                                Def::StructCtor(did, _) | Def::VariantCtor(did, _) =>\n+                                    self.parent(did),\n+                                _ => def.opt_def_id(),\n+                            };\n+                            candidates.push(ImportSuggestion { did, path });\n                         }\n                     }\n                 }\n@@ -4512,7 +4519,8 @@ impl<'a> Resolver<'a> {\n                             span: name_binding.span,\n                             segments: path_segments,\n                         };\n-                        result = Some((module, ImportSuggestion { path }));\n+                        let did = module.def().and_then(|def| def.opt_def_id());\n+                        result = Some((module, ImportSuggestion { did, path }));\n                     } else {\n                         // add the module to the lookup\n                         if seen_modules.insert(module.def_id().unwrap()) {"}, {"sha": "631966c09a498b23684277add55609c33830dd27", "filename": "src/librustc_target/spec/uefi_base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -5,7 +5,7 @@\n // UEFI uses COFF/PE32+ format for binaries. All binaries must be statically linked. No dynamic\n // linker is supported. As native to COFF, binaries are position-dependent, but will be relocated\n // by the loader if the pre-chosen memory location is already in use.\n-// UEFI forbids running code on anything but the boot-CPU. Not interrupts are allowed other than\n+// UEFI forbids running code on anything but the boot-CPU. No interrupts are allowed other than\n // the timer-interrupt. Device-drivers are required to use polling-based models. Furthermore, all\n // code runs in the same environment, no process separation is supported.\n \n@@ -21,7 +21,10 @@ pub fn opts() -> TargetOptions {\n             \"/NOLOGO\".to_string(),\n \n             // UEFI is fully compatible to non-executable data pages. Tell the compiler that\n-            // non-code sections can be marked as non-executable, including stack pages.\n+            // non-code sections can be marked as non-executable, including stack pages. In fact,\n+            // firmware might enforce this, so we better let the linker know about this, so it\n+            // will fail if the compiler ever tries placing code on the stack (e.g., trampoline\n+            // constructs and alike).\n             \"/NXCOMPAT\".to_string(),\n \n             // There is no runtime for UEFI targets, prevent them from being linked. UEFI targets"}, {"sha": "443479f55f04a2361bbca5520e1ea820842587b2", "filename": "src/librustc_target/spec/x86_64_unknown_uefi.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_uefi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_uefi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_uefi.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -12,23 +12,25 @@ pub fn target() -> TargetResult {\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = Some(64);\n \n-    // We disable MMX and SSE for now. UEFI does not prevent these from being used, but there have\n-    // been reports to GRUB that some firmware does not initialize the FP exception handlers\n-    // properly. Therefore, using FP coprocessors will end you up at random memory locations when\n-    // you throw FP exceptions.\n-    // To be safe, we disable them for now and force soft-float. This can be revisited when we\n-    // have more test coverage. Disabling FP served GRUB well so far, so it should be good for us\n-    // as well.\n+    // We disable MMX and SSE for now, even though UEFI allows using them. Problem is, you have to\n+    // enable these CPU features explicitly before their first use, otherwise their instructions\n+    // will trigger an exception. Rust does not inject any code that enables AVX/MMX/SSE\n+    // instruction sets, so this must be done by the firmware. However, existing firmware is known\n+    // to leave these uninitialized, thus triggering exceptions if we make use of them. Which is\n+    // why we avoid them and instead use soft-floats. This is also what GRUB and friends did so\n+    // far.\n+    // If you initialize FP units yourself, you can override these flags with custom linker\n+    // arguments, thus giving you access to full MMX/SSE acceleration.\n     base.features = \"-mmx,-sse,+soft-float\".to_string();\n \n     // UEFI systems run without a host OS, hence we cannot assume any code locality. We must tell\n     // LLVM to expect code to reference any address in the address-space. The \"large\" code-model\n     // places no locality-restrictions, so it fits well here.\n     base.code_model = Some(\"large\".to_string());\n \n-    // UEFI mostly mirrors the calling-conventions used on windows. In case of x86-64 this means\n-    // small structs will be returned as int. This shouldn't matter much, since the restrictions\n-    // placed by the UEFI specifications forbid any ABI to return structures.\n+    // UEFI mirrors the calling-conventions used on windows. In case of x86-64 this means small\n+    // structs will be returned as int. This shouldn't matter much, since the restrictions placed\n+    // by the UEFI specifications forbid any ABI to return structures.\n     base.abi_return_struct_as_int = true;\n \n     Ok(Target {"}, {"sha": "dad45130062a45a1c3d8726f55eb0b37992947cc", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,6 +1,7 @@\n //! Provider for the `implied_outlives_bounds` query.\n //! Do not call this query directory. See [`rustc::traits::query::implied_outlives_bounds`].\n \n+use rustc::hir;\n use rustc::infer::InferCtxt;\n use rustc::infer::canonical::{self, Canonical};\n use rustc::traits::{TraitEngine, TraitEngineExt};\n@@ -11,7 +12,6 @@ use rustc::ty::outlives::Component;\n use rustc::ty::query::Providers;\n use rustc::ty::wf;\n use smallvec::{SmallVec, smallvec};\n-use syntax::ast::DUMMY_NODE_ID;\n use syntax::source_map::DUMMY_SP;\n use rustc::traits::FulfillmentContext;\n \n@@ -65,7 +65,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n         let obligations =\n-            wf::obligations(infcx, param_env, DUMMY_NODE_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n+            wf::obligations(infcx, param_env, hir::DUMMY_HIR_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n \n         // N.B., all of these predicates *ought* to be easily proven\n         // true. In fact, their correctness is (mostly) implied by"}, {"sha": "38f7a21e66c55fc8a5de858c3fd53968486d0f17", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,11 +1,11 @@\n+use rustc::hir;\n use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::traits::query::{normalize::NormalizationResult, CanonicalProjectionGoal, NoSolution};\n use rustc::traits::{self, ObligationCause, SelectionContext, TraitEngineExt};\n use rustc::ty::query::Providers;\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n use std::sync::atomic::Ordering;\n-use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::DUMMY_SP;\n \n crate fn provide(p: &mut Providers<'_>) {\n@@ -34,7 +34,7 @@ fn normalize_projection_ty<'tcx>(\n              value: goal,\n          }| {\n             let selcx = &mut SelectionContext::new(infcx);\n-            let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n+            let cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n             let mut obligations = vec![];\n             let answer = traits::normalize_projection_type(\n                 selcx,"}, {"sha": "30fbdbdeb443363c1fcb1654e98f9ef344aaae16", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,6 +1,7 @@\n use rustc::infer::at::ToTrace;\n use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::infer::InferCtxt;\n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::traits::query::type_op::ascribe_user_type::AscribeUserType;\n use rustc::traits::query::type_op::eq::Eq;\n@@ -18,7 +19,6 @@ use rustc::ty::{\n };\n use rustc_data_structures::sync::Lrc;\n use std::fmt;\n-use syntax::ast;\n use syntax_pos::DUMMY_SP;\n \n crate fn provide(p: &mut Providers<'_>) {\n@@ -71,7 +71,7 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         self.infcx\n             .partially_normalize_associated_types_in(\n                 DUMMY_SP,\n-                ast::CRATE_NODE_ID,\n+                hir::CRATE_HIR_ID,\n                 self.param_env,\n                 &value,\n             )"}, {"sha": "23e9cd55cdce7f552fff4cfbb1cb05c07c18e61e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -878,8 +878,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                                           binding.item_name, binding.span)\n         }?;\n \n+        let hir_ref_id = self.tcx().hir().node_to_hir_id(ref_id);\n         let (assoc_ident, def_scope) =\n-            tcx.adjust_ident(binding.item_name, candidate.def_id(), ref_id);\n+            tcx.adjust_ident(binding.item_name, candidate.def_id(), hir_ref_id);\n         let assoc_ty = tcx.associated_items(candidate.def_id()).find(|i| {\n             i.kind == ty::AssociatedKind::Type && i.ident.modern() == assoc_ident\n         }).expect(\"missing associated type\");\n@@ -1373,7 +1374,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         };\n \n         let trait_did = bound.def_id();\n-        let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_ident, trait_did, ref_id);\n+        let hir_ref_id = self.tcx().hir().node_to_hir_id(ref_id);\n+        let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_ident, trait_did, hir_ref_id);\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n                 i.ident.modern() == assoc_ident"}, {"sha": "f863cfe1887db6f9c726b2652a1668a4ddae7b9e", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,6 +1,7 @@\n use super::{FnCtxt, PlaceOp, Needs};\n use super::method::MethodCallee;\n \n+use rustc::hir;\n use rustc::infer::{InferCtxt, InferOk};\n use rustc::session::DiagnosticMessageId;\n use rustc::traits::{self, TraitEngine};\n@@ -9,7 +10,7 @@ use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n \n use syntax_pos::Span;\n-use syntax::ast::{self, Ident};\n+use syntax::ast::Ident;\n \n use std::iter;\n \n@@ -21,7 +22,7 @@ enum AutoderefKind {\n \n pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n     cur_ty: Ty<'tcx>,\n@@ -87,7 +88,7 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                param_env: ty::ParamEnv<'tcx>,\n-               body_id: ast::NodeId,\n+               body_id: hir::HirId,\n                span: Span,\n                base_ty: Ty<'tcx>)\n                -> Autoderef<'a, 'gcx, 'tcx>"}, {"sha": "722af8f0e778d16bbd85a3491977f8eabec5f42a", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -641,7 +641,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .liberate_late_bound_regions(expr_def_id, &bound_sig);\n         let liberated_sig = self.inh.normalize_associated_types_in(\n             body.value.span,\n-            body.value.id,\n+            body.value.hir_id,\n             self.param_env,\n             &liberated_sig,\n         );"}, {"sha": "05ca54df2984b8eab95210201ecceb274fa33d59", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -84,10 +84,11 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n     let impl_m_node_id = tcx.hir().as_local_node_id(impl_m.def_id).unwrap();\n+    let impl_m_hir_id = tcx.hir().node_to_hir_id(impl_m_node_id);\n \n     let cause = ObligationCause {\n         span: impl_m_span,\n-        body_id: impl_m_node_id,\n+        body_id: impl_m_hir_id,\n         code: ObligationCauseCode::CompareImplMethodObligation {\n             item_name: impl_m.ident.name,\n             impl_item_def_id: impl_m.def_id,\n@@ -205,7 +206,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Construct trait parameter environment and then shift it into the placeholder viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n-    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n+    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_hir_id);\n     let param_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&hybrid_preds.predicates),\n         Reveal::UserFacing,\n@@ -262,7 +263,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         );\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n-                                              impl_m_node_id,\n+                                              impl_m_hir_id,\n                                               param_env,\n                                               &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder::bind(impl_sig));\n@@ -275,7 +276,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n-                                              impl_m_node_id,\n+                                              impl_m_hir_id,\n                                               param_env,\n                                               &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder::bind(trait_sig));\n@@ -347,8 +348,8 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        let fcx = FnCtxt::new(&inh, param_env, impl_m_node_id);\n-        fcx.regionck_item(impl_m_node_id, impl_m_span, &[]);\n+        let fcx = FnCtxt::new(&inh, param_env, impl_m_hir_id);\n+        fcx.regionck_item(impl_m_hir_id, impl_m_span, &[]);\n \n         Ok(())\n     })\n@@ -903,22 +904,23 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Create a parameter environment that represents the implementation's\n         // method.\n         let impl_c_node_id = tcx.hir().as_local_node_id(impl_c.def_id).unwrap();\n+        let impl_c_hir_id = tcx.hir().node_to_hir_id(impl_c_node_id);\n \n         // Compute placeholder form of impl and trait const tys.\n         let impl_ty = tcx.type_of(impl_c.def_id);\n         let trait_ty = tcx.type_of(trait_c.def_id).subst(tcx, trait_to_impl_substs);\n-        let mut cause = ObligationCause::misc(impl_c_span, impl_c_node_id);\n+        let mut cause = ObligationCause::misc(impl_c_span, impl_c_hir_id);\n \n         // There is no \"body\" here, so just pass dummy id.\n         let impl_ty = inh.normalize_associated_types_in(impl_c_span,\n-                                                        impl_c_node_id,\n+                                                        impl_c_hir_id,\n                                                         param_env,\n                                                         &impl_ty);\n \n         debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n         let trait_ty = inh.normalize_associated_types_in(impl_c_span,\n-                                                         impl_c_node_id,\n+                                                         impl_c_hir_id,\n                                                          param_env,\n                                                          &trait_ty);\n \n@@ -973,7 +975,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             return;\n         }\n \n-        let fcx = FnCtxt::new(&inh, param_env, impl_c_node_id);\n-        fcx.regionck_item(impl_c_node_id, impl_c_span, &[]);\n+        let fcx = FnCtxt::new(&inh, param_env, impl_c_hir_id);\n+        fcx.regionck_item(impl_c_hir_id, impl_c_span, &[]);\n     });\n }"}, {"sha": "ad74e78fecdcdb1270e7b743975cc57b6be0bd79", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,5 +1,6 @@\n use crate::check::regionck::RegionCtxt;\n \n+use crate::hir;\n use crate::hir::def_id::DefId;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::{self, InferOk, SuppressRegionErrors};\n@@ -9,7 +10,6 @@ use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use crate::util::common::ErrorReported;\n \n-use syntax::ast;\n use syntax_pos::Span;\n \n /// This function confirms that the `Drop` implementation identified by\n@@ -70,7 +70,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId,\n ) -> Result<(), ErrorReported> {\n-    let drop_impl_node_id = tcx.hir().as_local_node_id(drop_impl_did).unwrap();\n+    let drop_impl_hir_id = tcx.hir().as_local_hir_id(drop_impl_did).unwrap();\n \n     // check that the impl type can be made to match the trait type.\n \n@@ -85,7 +85,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let fresh_impl_substs = infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n-        let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);\n+        let cause = &ObligationCause::misc(drop_impl_span, drop_impl_hir_id);\n         match infcx\n             .at(cause, impl_param_env)\n             .eq(named_type, fresh_impl_self_ty)\n@@ -291,7 +291,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n     scope: region::Scope,\n ) -> Result<(), ErrorReported> {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\","}, {"sha": "fca9fa0829f7263e6e9f255ff00761b10c4e753a", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -58,7 +58,7 @@ fn equate_intrinsic_type<'a, 'tcx>(\n         safety,\n         abi\n     )));\n-    let cause = ObligationCause::new(it.span, it.id, ObligationCauseCode::IntrinsicType);\n+    let cause = ObligationCause::new(it.span, it.hir_id, ObligationCauseCode::IntrinsicType);\n     require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(def_id)), fty);\n }\n "}, {"sha": "709177212ada7409e2824b367f9684cf9790d400", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -401,7 +401,7 @@ fn method_autoderef_steps<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {\n         let ParamEnvAnd { param_env, value: self_ty } = goal;\n \n-        let mut autoderef = Autoderef::new(infcx, param_env, ast::DUMMY_NODE_ID, DUMMY_SP, self_ty)\n+        let mut autoderef = Autoderef::new(infcx, param_env, hir::DUMMY_HIR_ID, DUMMY_SP, self_ty)\n             .include_raw_pointers()\n             .silence_errors();\n         let mut reached_raw_pointer = false;\n@@ -1183,7 +1183,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         stable_pick: &Pick,\n         unstable_candidates: &[(&Candidate<'tcx>, Symbol)],\n     ) {\n-        let mut diag = self.tcx.struct_span_lint_node(\n+        let mut diag = self.tcx.struct_span_lint_hir(\n             lint::builtin::UNSTABLE_NAME_COLLISIONS,\n             self.fcx.body_id,\n             self.span,"}, {"sha": "768842ef39214f0e5dc817212e925e8ac356c000", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -346,7 +346,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     };\n \n                                     let field_ty = field.ty(tcx, substs);\n-                                    let scope = self.tcx.hir().get_module_parent(self.body_id);\n+                                    let scope = self.tcx.hir().get_module_parent_by_hir_id(\n+                                        self.body_id);\n                                     if field.vis.is_accessible_from(scope, self.tcx) {\n                                         if self.is_fn_ty(&field_ty, span) {\n                                             err.help(&format!(\"use `({0}.{1})(...)` if you \\\n@@ -499,7 +500,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               err: &mut DiagnosticBuilder,\n                               mut msg: String,\n                               candidates: Vec<DefId>) {\n-        let module_did = self.tcx.hir().get_module_parent(self.body_id);\n+        let module_did = self.tcx.hir().get_module_parent_by_hir_id(self.body_id);\n         let module_id = self.tcx.hir().as_local_node_id(module_did).unwrap();\n         let krate = self.tcx.hir().krate();\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);\n@@ -752,12 +753,11 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n                            traits: &mut Vec<DefId>,\n                            external_mods: &mut FxHashSet<DefId>,\n                            def: Def) {\n-        let def_id = def.def_id();\n         match def {\n-            Def::Trait(..) => {\n+            Def::Trait(def_id) => {\n                 traits.push(def_id);\n             }\n-            Def::Mod(..) => {\n+            Def::Mod(def_id) => {\n                 if !external_mods.insert(def_id) {\n                     return;\n                 }"}, {"sha": "91e44a15882684f3e463b5e1feef378f8110ee60", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -510,7 +510,7 @@ impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n }\n \n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n \n     /// The parameter environment used for proving trait obligations\n     /// in this function. This can change when we descend into\n@@ -672,7 +672,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n \n     fn normalize_associated_types_in<T>(&self,\n                                         span: Span,\n-                                        body_id: ast::NodeId,\n+                                        body_id: hir::HirId,\n                                         param_env: ty::ParamEnv<'tcx>,\n                                         value: &T) -> T\n         where T : TypeFoldable<'tcx>\n@@ -861,14 +861,14 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tcx.liberate_late_bound_regions(def_id, &fn_sig);\n             let fn_sig =\n                 inh.normalize_associated_types_in(body.value.span,\n-                                                  body_id.node_id,\n+                                                  body_id.hir_id,\n                                                   param_env,\n                                                   &fn_sig);\n \n             let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, None).0;\n             fcx\n         } else {\n-            let fcx = FnCtxt::new(&inh, param_env, body.value.id);\n+            let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n             let expected_type = tcx.type_of(def_id);\n             let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n@@ -1062,7 +1062,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, param_env, body.value.id);\n+    let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n \n     let declared_ret_ty = fn_sig.output();\n@@ -1169,8 +1169,9 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 let substs = fcx.tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);\n                 let return_ty_span = decl.output.span();\n+                let fn_hir_id = fcx.tcx.hir().node_to_hir_id(fn_id);\n                 let cause = traits::ObligationCause::new(\n-                    return_ty_span, fn_id, ObligationCauseCode::MainFunctionType);\n+                    return_ty_span, fn_hir_id, ObligationCauseCode::MainFunctionType);\n \n                 inherited.register_predicate(\n                     traits::Obligation::new(\n@@ -2022,7 +2023,7 @@ enum TupleArgumentsFlag {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(inh: &'a Inherited<'a, 'gcx, 'tcx>,\n                param_env: ty::ParamEnv<'tcx>,\n-               body_id: ast::NodeId)\n+               body_id: hir::HirId)\n                -> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n             body_id,"}, {"sha": "792f8eaacd29031d9d1a1eb8cf8d94529a697727", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -112,7 +112,7 @@ macro_rules! ignore_err {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n-        let id = body.value.id;\n+        let id = body.value.hir_id;\n         let mut rcx = RegionCtxt::new(\n             self,\n             RepeatingScope(id),\n@@ -138,9 +138,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Region checking during the WF phase for items. `wf_tys` are the\n     /// types from which we should derive implied bounds, if any.\n-    pub fn regionck_item(&self, item_id: ast::NodeId, span: Span, wf_tys: &[Ty<'tcx>]) {\n+    pub fn regionck_item(&self, item_id: hir::HirId, span: Span, wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?})\", item_id, wf_tys);\n-        let subject = self.tcx.hir().local_def_id(item_id);\n+        let subject = self.tcx.hir().local_def_id_from_hir_id(item_id);\n         let mut rcx = RegionCtxt::new(\n             self,\n             RepeatingScope(item_id),\n@@ -166,18 +166,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_fn(&self, fn_id: ast::NodeId, body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n-        let node_id = body.value.id;\n+        let hir_id = body.value.hir_id;\n         let mut rcx = RegionCtxt::new(\n             self,\n-            RepeatingScope(node_id),\n-            node_id,\n+            RepeatingScope(hir_id),\n+            hir_id,\n             Subject(subject),\n             self.param_env,\n         );\n \n         if self.err_count_since_creation() == 0 {\n+            let fn_hir_id = self.tcx.hir().node_to_hir_id(fn_id);\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, body, self.tcx.hir().span(fn_id));\n+            rcx.visit_fn_body(fn_hir_id, body, self.tcx.hir().span_by_hir_id(fn_hir_id));\n         }\n \n         rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n@@ -201,13 +202,13 @@ pub struct RegionCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     outlives_environment: OutlivesEnvironment<'tcx>,\n \n     // id of innermost fn body id\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n \n     // call_site scope of innermost fn\n     call_site_scope: Option<region::Scope>,\n \n     // id of innermost fn or loop\n-    repeating_scope: ast::NodeId,\n+    repeating_scope: hir::HirId,\n \n     // id of AST node being analyzed (the subject of the analysis).\n     subject_def_id: DefId,\n@@ -220,14 +221,14 @@ impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct RepeatingScope(ast::NodeId);\n+pub struct RepeatingScope(hir::HirId);\n pub struct Subject(DefId);\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(\n         fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n         RepeatingScope(initial_repeating_scope): RepeatingScope,\n-        initial_body_id: ast::NodeId,\n+        initial_body_id: hir::HirId,\n         Subject(subject): Subject,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> RegionCtxt<'a, 'gcx, 'tcx> {\n@@ -244,7 +245,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn set_repeating_scope(&mut self, scope: ast::NodeId) -> ast::NodeId {\n+    fn set_repeating_scope(&mut self, scope: hir::HirId) -> hir::HirId {\n         mem::replace(&mut self.repeating_scope, scope)\n     }\n \n@@ -301,15 +302,15 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// `intravisit::Visitor` impl below.)\n     fn visit_fn_body(\n         &mut self,\n-        id: ast::NodeId, // the id of the fn itself\n+        id: hir::HirId, // the id of the fn itself\n         body: &'gcx hir::Body,\n         span: Span,\n     ) {\n         // When we enter a function, we can derive\n-        debug!(\"visit_fn_body(id={})\", id);\n+        debug!(\"visit_fn_body(id={:?})\", id);\n \n         let body_id = body.id();\n-        self.body_id = body_id.node_id;\n+        self.body_id = body_id.hir_id;\n \n         let call_site = region::Scope {\n             id: body.value.hir_id.local_id,\n@@ -318,11 +319,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.call_site_scope = Some(call_site);\n \n         let fn_sig = {\n-            let fn_hir_id = self.tcx.hir().node_to_hir_id(id);\n-            match self.tables.borrow().liberated_fn_sigs().get(fn_hir_id) {\n+            match self.tables.borrow().liberated_fn_sigs().get(id) {\n                 Some(f) => f.clone(),\n                 None => {\n-                    bug!(\"No fn-sig entry for id={}\", id);\n+                    bug!(\"No fn-sig entry for id={:?}\", id);\n                 }\n             }\n         };\n@@ -342,11 +342,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.outlives_environment.add_implied_bounds(\n             self.fcx,\n             &fn_sig_tys[..],\n-            body_id.node_id,\n+            body_id.hir_id,\n             span,\n         );\n         self.outlives_environment\n-            .save_implied_bounds(body_id.node_id);\n+            .save_implied_bounds(body_id.hir_id);\n         self.link_fn_args(\n             region::Scope {\n                 id: body.value.hir_id.local_id,\n@@ -355,7 +355,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             &body.arguments,\n         );\n         self.visit_body(body);\n-        self.visit_region_obligations(body_id.node_id);\n+        self.visit_region_obligations(body_id.hir_id);\n \n         let call_site_scope = self.call_site_scope.unwrap();\n         debug!(\n@@ -365,17 +365,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         );\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n \n-        let body_hir_id = self.tcx.hir().node_to_hir_id(body_id.node_id);\n-        self.type_of_node_must_outlive(infer::CallReturn(span), body_hir_id, call_site_region);\n+        self.type_of_node_must_outlive(infer::CallReturn(span), body_id.hir_id, call_site_region);\n \n         self.constrain_opaque_types(\n             &self.fcx.opaque_types.borrow(),\n             self.outlives_environment.free_region_map(),\n         );\n     }\n \n-    fn visit_region_obligations(&mut self, node_id: ast::NodeId) {\n-        debug!(\"visit_region_obligations: node_id={}\", node_id);\n+    fn visit_region_obligations(&mut self, hir_id: hir::HirId) {\n+        debug!(\"visit_region_obligations: hir_id={:?}\", hir_id);\n \n         // region checking can introduce new pending obligations\n         // which, when processed, might generate new region\n@@ -474,7 +473,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         let env_snapshot = self.outlives_environment.push_snapshot_pre_closure();\n \n         let body = self.tcx.hir().body(body_id);\n-        self.visit_fn_body(id, body, span);\n+        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        self.visit_fn_body(hir_id, body, span);\n \n         // Restore state from previous function.\n         self.outlives_environment\n@@ -502,7 +502,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         debug!(\n-            \"regionck::visit_expr(e={:?}, repeating_scope={})\",\n+            \"regionck::visit_expr(e={:?}, repeating_scope={:?})\",\n             expr, self.repeating_scope\n         );\n \n@@ -555,7 +555,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         debug!(\n-            \"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n+            \"regionck::visit_expr(e={:?}, repeating_scope={:?}) - visiting subexprs\",\n             expr, self.repeating_scope\n         );\n         match expr.node {\n@@ -679,16 +679,16 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprKind::Loop(ref body, _, _) => {\n-                let repeating_scope = self.set_repeating_scope(body.id);\n+                let repeating_scope = self.set_repeating_scope(body.hir_id);\n                 intravisit::walk_expr(self, expr);\n                 self.set_repeating_scope(repeating_scope);\n             }\n \n             hir::ExprKind::While(ref cond, ref body, _) => {\n-                let repeating_scope = self.set_repeating_scope(cond.id);\n+                let repeating_scope = self.set_repeating_scope(cond.hir_id);\n                 self.visit_expr(&cond);\n \n-                self.set_repeating_scope(body.id);\n+                self.set_repeating_scope(body.hir_id);\n                 self.visit_block(&body);\n \n                 self.set_repeating_scope(repeating_scope);\n@@ -758,7 +758,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn check_expr_fn_block(&mut self, expr: &'gcx hir::Expr, body_id: hir::BodyId) {\n-        let repeating_scope = self.set_repeating_scope(body_id.node_id);\n+        let repeating_scope = self.set_repeating_scope(body_id.hir_id);\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);\n     }"}, {"sha": "86b2e0bfe8aef6d9a96b51f61aec50baa5239b05", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -22,7 +22,7 @@ use rustc::hir;\n /// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>)`.\n struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n-    id: ast::NodeId,\n+    id: hir::HirId,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n }\n@@ -226,9 +226,10 @@ fn for_item<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, item: &hir::Item)\n fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId, span: Span)\n                           -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n     let def_id = tcx.hir().local_def_id(id);\n+    let hir_id = tcx.hir().node_to_hir_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n-        id,\n+        id: hir_id,\n         span,\n         param_env: tcx.param_env(def_id),\n     }\n@@ -968,13 +969,13 @@ fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n fn check_false_global_bounds<'a, 'gcx, 'tcx>(\n     fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n-    id: ast::NodeId)\n+    id: hir::HirId)\n {\n     use rustc::ty::TypeFoldable;\n \n     let empty_env = ty::ParamEnv::empty();\n \n-    let def_id = fcx.tcx.hir().local_def_id(id);\n+    let def_id = fcx.tcx.hir().local_def_id_from_hir_id(id);\n     let predicates = fcx.tcx.predicates_of(def_id).predicates\n         .iter()\n         .map(|(p, _)| *p)"}, {"sha": "e68c50d752bd5d78c07f71605f6f1191d050587f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -100,7 +100,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         body: &'gcx hir::Body,\n         rustc_dump_user_substs: bool,\n     ) -> WritebackCx<'cx, 'gcx, 'tcx> {\n-        let owner = fcx.tcx.hir().definitions().node_to_hir_id(body.id().node_id);\n+        let owner = body.id().hir_id;\n \n         WritebackCx {\n             fcx,"}, {"sha": "0996d1ff3b9989f2377b2f5396415ea208061682", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -162,8 +162,8 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n     if impl_did.is_local() {\n         let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n-        let impl_node_id = tcx.hir().as_local_node_id(impl_did).unwrap();\n-        let span = tcx.hir().span(impl_node_id);\n+        let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap();\n+        let span = tcx.hir().span_by_hir_id(impl_hir_id);\n \n         let source = tcx.type_of(impl_did);\n         assert!(!source.has_escaping_bound_vars());\n@@ -185,7 +185,7 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n         };\n \n         tcx.infer_ctxt().enter(|infcx| {\n-            let cause = ObligationCause::misc(span, impl_node_id);\n+            let cause = ObligationCause::misc(span, impl_hir_id);\n \n             use ty::TyKind::*;\n             match (&source.sty, &target.sty) {\n@@ -332,7 +332,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n     });\n \n     // this provider should only get invoked for local def-ids\n-    let impl_node_id = gcx.hir().as_local_node_id(impl_did).unwrap_or_else(|| {\n+    let impl_hir_id = gcx.hir().as_local_hir_id(impl_did).unwrap_or_else(|| {\n         bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n     });\n \n@@ -344,7 +344,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n            source,\n            target);\n \n-    let span = gcx.hir().span(impl_node_id);\n+    let span = gcx.hir().span_by_hir_id(impl_hir_id);\n     let param_env = gcx.param_env(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n \n@@ -355,7 +355,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n            target);\n \n     gcx.infer_ctxt().enter(|infcx| {\n-        let cause = ObligationCause::misc(span, impl_node_id);\n+        let cause = ObligationCause::misc(span, impl_hir_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n                            mt_b: ty::TypeAndMut<'gcx>,\n                            mk_ptr: &dyn Fn(Ty<'gcx>) -> Ty<'gcx>| {\n@@ -481,11 +481,11 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                being coerced, none found\");\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n-                    let item = gcx.hir().expect_item(impl_node_id);\n+                    let item = gcx.hir().expect_item_by_hir_id(impl_hir_id);\n                     let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.node {\n                         t.path.span\n                     } else {\n-                        gcx.hir().span(impl_node_id)\n+                        gcx.hir().span_by_hir_id(impl_hir_id)\n                     };\n \n                     let mut err = struct_span_err!(gcx.sess,\n@@ -527,7 +527,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n         let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n \n         // Register an obligation for `A: Trait<B>`.\n-        let cause = traits::ObligationCause::misc(span, impl_node_id);\n+        let cause = traits::ObligationCause::misc(span, impl_hir_id);\n         let predicate = gcx.predicate_for_trait_def(param_env,\n                                                     cause,\n                                                     trait_def_id,"}, {"sha": "7055218577c5c8accb30895dbbff87adb7d455c0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -179,12 +179,12 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, main_def_id: DefId) {\n-    let main_id = tcx.hir().as_local_node_id(main_def_id).unwrap();\n+    let main_id = tcx.hir().as_local_hir_id(main_def_id).unwrap();\n     let main_span = tcx.def_span(main_def_id);\n     let main_t = tcx.type_of(main_def_id);\n     match main_t.sty {\n         ty::FnDef(..) => {\n-            if let Some(Node::Item(it)) = tcx.hir().find(main_id) {\n+            if let Some(Node::Item(it)) = tcx.hir().find_by_hir_id(main_id) {\n                 if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n@@ -244,12 +244,12 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, main_def_id: DefId) {\n }\n \n fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, start_def_id: DefId) {\n-    let start_id = tcx.hir().as_local_node_id(start_def_id).unwrap();\n+    let start_id = tcx.hir().as_local_hir_id(start_def_id).unwrap();\n     let start_span = tcx.def_span(start_def_id);\n     let start_t = tcx.type_of(start_def_id);\n     match start_t.sty {\n         ty::FnDef(..) => {\n-            if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n+            if let Some(Node::Item(it)) = tcx.hir().find_by_hir_id(start_id) {\n                 if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n                     let mut error = false;\n                     if !generics.params.is_empty() {"}, {"sha": "d12b5021ca9fae5902c5fe3fbdfd0d7bc8939c6e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -3830,7 +3830,7 @@ fn print_const(cx: &DocContext, n: ty::LazyConst) -> String {\n }\n \n fn print_const_expr(cx: &DocContext, body: hir::BodyId) -> String {\n-    cx.tcx.hir().node_to_pretty_string(body.node_id)\n+    cx.tcx.hir().hir_to_pretty_string(body.hir_id)\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt"}, {"sha": "e660d27d74b4cf416cb7ababd012da123d5fa8c8", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -2823,7 +2823,17 @@ fn stability_tags(item: &clean::Item) -> String {\n \n     // The trailing space after each tag is to space it properly against the rest of the docs.\n     if item.deprecation().is_some() {\n-        tags += &tag_html(\"deprecated\", \"Deprecated\");\n+        let mut message = \"Deprecated\";\n+        if let Some(ref stab) = item.stability {\n+            if let Some(ref depr) = stab.deprecation {\n+                if let Some(ref since) = depr.since {\n+                    if !stability::deprecation_in_effect(&since) {\n+                        message = \"Deprecation planned\";\n+                    }\n+                }\n+            }\n+        }\n+        tags += &tag_html(\"deprecated\", message);\n     }\n \n     if let Some(stab) = item\n@@ -2851,16 +2861,23 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n     let mut stability = vec![];\n     let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n \n-    if let Some(Deprecation { since, note }) = &item.deprecation() {\n+    if let Some(Deprecation { note, since }) = &item.deprecation() {\n+        // We display deprecation messages for #[deprecated] and #[rustc_deprecated]\n+        // but only display the future-deprecation messages for #[rustc_deprecated].\n         let mut message = if let Some(since) = since {\n-            if stability::deprecation_in_effect(since) {\n-                format!(\"Deprecated since {}\", Escape(since))\n-            } else {\n-                format!(\"Deprecating in {}\", Escape(since))\n-            }\n+            format!(\"Deprecated since {}\", Escape(since))\n         } else {\n             String::from(\"Deprecated\")\n         };\n+        if let Some(ref stab) = item.stability {\n+            if let Some(ref depr) = stab.deprecation {\n+                if let Some(ref since) = depr.since {\n+                    if !stability::deprecation_in_effect(&since) {\n+                        message = format!(\"Deprecating in {}\", Escape(&since));\n+                    }\n+                }\n+            }\n+        }\n \n         if let Some(note) = note {\n             let mut ids = cx.id_map.borrow_mut();"}, {"sha": "bd5cae861e93b4228e954d3f5955754fa25d66b8", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -60,9 +60,11 @@ impl<'a, 'tcx, 'rcx> LibEmbargoVisitor<'a, 'tcx, 'rcx> {\n         }\n \n         for item in self.cx.tcx.item_children(def_id).iter() {\n-            if self.cx.tcx.def_key(item.def.def_id()).parent.map_or(false, |d| d == def_id.index) ||\n-                item.vis == Visibility::Public {\n-                self.visit_item(item.def);\n+            if let Some(def_id) = item.def.opt_def_id() {\n+                if self.cx.tcx.def_key(def_id).parent.map_or(false, |d| d == def_id.index) ||\n+                    item.vis == Visibility::Public {\n+                    self.visit_item(item.def);\n+                }\n             }\n         }\n     }"}, {"sha": "1c700d44dd80b7be19a54f8032a2e6c8677becfa", "filename": "src/test/incremental/issue-54242.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fincremental%2Fissue-54242.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fincremental%2Fissue-54242.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-54242.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -0,0 +1,17 @@\n+// revisions: rpass cfail\n+\n+trait Tr {\n+    type Arr;\n+\n+    const C: usize = 0;\n+}\n+\n+impl Tr for str {\n+    #[cfg(rpass)]\n+    type Arr = [u8; 8];\n+    #[cfg(cfail)]\n+    type Arr = [u8; Self::C];\n+    //[cfail]~^ ERROR cycle detected when const-evaluating\n+}\n+\n+fn main() {}"}, {"sha": "fe85baa048e3903046c895c8012d444895b210ec", "filename": "src/test/mir-opt/unusual-item-types.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -0,0 +1,66 @@\n+// Test that we don't ICE when trying to dump MIR for unusual item types and\n+// that we don't create filenames containing `<` and `>`\n+\n+struct A;\n+\n+impl A {\n+    const ASSOCIATED_CONSTANT: i32 = 2;\n+}\n+\n+enum E {\n+    V = 5,\n+}\n+\n+fn main() {\n+    let v = Vec::<i32>::new();\n+}\n+\n+// END RUST SOURCE\n+\n+// START rustc.{{impl}}-ASSOCIATED_CONSTANT.mir_map.0.mir\n+// bb0: {\n+//     _0 = const 2i32;\n+//     return;\n+// }\n+// bb1: {\n+//     resume;\n+// }\n+// END rustc.{{impl}}-ASSOCIATED_CONSTANT.mir_map.0.mir\n+\n+// START rustc.E-V-{{constant}}.mir_map.0.mir\n+// bb0: {\n+//     _0 = const 5isize;\n+//     return;\n+// }\n+// bb1: {\n+//     resume;\n+// }\n+// END rustc.E-V-{{constant}}.mir_map.0.mir\n+\n+// START rustc.ptr-real_drop_in_place.std__vec__Vec_i32_.AddMovesForPackedDrops.before.mir\n+//     bb0: {\n+//     goto -> bb7;\n+// }\n+// bb1: {\n+//     return;\n+// }\n+// bb2: {\n+//     resume;\n+// }\n+// bb3: {\n+//     goto -> bb1;\n+// }\n+// bb4: {\n+//     goto -> bb2;\n+// }\n+// bb5: {\n+//     drop(((*_1).0: alloc::raw_vec::RawVec<i32>)) -> bb4;\n+// }\n+// bb6: {\n+//     drop(((*_1).0: alloc::raw_vec::RawVec<i32>)) -> [return: bb3, unwind: bb4];\n+// }\n+// bb7: {\n+//     _2 = &mut (*_1);\n+//     _3 = const std::ops::Drop::drop(move _2) -> [return: bb6, unwind: bb5];\n+// }\n+// END rustc.ptr-real_drop_in_place.std__vec__Vec_i32_.AddMovesForPackedDrops.before.mir"}, {"sha": "26de6a0c6899054c98f7890befd0639573a70e13", "filename": "src/test/run-make/wasm-stringify-ints-small/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2FMakefile?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -0,0 +1,10 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+ifeq ($(TARGET),wasm32-unknown-unknown)\n+all:\n+\t$(RUSTC) foo.rs -C lto -O --target wasm32-unknown-unknown\n+\twc -c < $(TMPDIR)/foo.wasm\n+\t[ \"`wc -c < $(TMPDIR)/foo.wasm`\" -lt \"20500\" ]\n+else\n+all:\n+endif"}, {"sha": "7a947f013ad486f1adc58f027e2a88253f501e9b", "filename": "src/test/run-make/wasm-stringify-ints-small/foo.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2Ffoo.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -0,0 +1,33 @@\n+#![crate_type = \"cdylib\"]\n+\n+extern \"C\" {\n+    fn observe(ptr: *const u8, len: usize);\n+}\n+\n+macro_rules! s {\n+    ( $( $f:ident -> $t:ty );* $(;)* ) => {\n+        $(\n+            extern \"C\" {\n+                fn $f() -> $t;\n+            }\n+            let s = $f().to_string();\n+            observe(s.as_ptr(), s.len());\n+        )*\n+    };\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn foo() {\n+    s! {\n+        get_u8 -> u8;\n+        get_i8 -> i8;\n+        get_u16 -> u16;\n+        get_i16 -> i16;\n+        get_u32 -> u32;\n+        get_i32 -> i32;\n+        get_u64 -> u64;\n+        get_i64 -> i64;\n+        get_usize -> usize;\n+        get_isize -> isize;\n+    }\n+}"}, {"sha": "c5248c52fb973313eefda0ff4143312fef01cbcd", "filename": "src/test/rustdoc/deprecated-future.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Frustdoc%2Fdeprecated-future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Frustdoc%2Fdeprecated-future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdeprecated-future.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,6 +1,8 @@\n #![feature(deprecated)]\n \n+// @has deprecated_future/index.html '//*[@class=\"stab deprecated\"]' \\\n+//      'Deprecated'\n // @has deprecated_future/struct.S.html '//*[@class=\"stab deprecated\"]' \\\n-//      'Deprecating in 99.99.99: effectively never'\n+//      'Deprecated since 99.99.99: effectively never'\n #[deprecated(since = \"99.99.99\", note = \"effectively never\")]\n pub struct S;"}, {"sha": "3133775706b8de24386f15282a1adf4ddb5086f9", "filename": "src/test/rustdoc/rustc_deprecated-future.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Frustdoc%2Frustc_deprecated-future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Frustdoc%2Frustc_deprecated-future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Frustc_deprecated-future.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -0,0 +1,11 @@\n+#![feature(staged_api)]\n+\n+#![stable(feature = \"rustc_deprecated-future-test\", since = \"1.0.0\")]\n+\n+// @has rustc_deprecated_future/index.html '//*[@class=\"stab deprecated\"]' \\\n+//      'Deprecation planned'\n+// @has rustc_deprecated_future/struct.S.html '//*[@class=\"stab deprecated\"]' \\\n+//      'Deprecating in 99.99.99: effectively never'\n+#[rustc_deprecated(since = \"99.99.99\", reason = \"effectively never\")]\n+#[stable(feature = \"rustc_deprecated-future-test\", since = \"1.0.0\")]\n+pub struct S;"}, {"sha": "138d902621cbcb2e3309181255b9030b66cbb204", "filename": "src/test/ui/deprecation/deprecation-in-future.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,12 +1,14 @@\n // ignore-tidy-linelength\n \n+// run-pass\n+\n #![deny(deprecated_in_future)]\n \n #[deprecated(since = \"99.99.99\", note = \"text\")]\n pub fn deprecated_future() {}\n \n fn test() {\n-    deprecated_future(); //~ ERROR use of item 'deprecated_future' that will be deprecated in future version 99.99.99: text\n+    deprecated_future(); // ok; deprecated_in_future only applies to rustc_deprecated\n }\n \n fn main() {}"}, {"sha": "81d2461c1bd83754232e1d426b3f29349d6ea451", "filename": "src/test/ui/deprecation/deprecation-in-future.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-in-future.stderr?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,14 +1,8 @@\n-error: use of item 'deprecated_future' that will be deprecated in future version 99.99.99: text\n-  --> $DIR/deprecation-in-future.rs:9:5\n+warning: use of deprecated item 'deprecated_future': text\n+  --> $DIR/deprecation-in-future.rs:11:5\n    |\n-LL |     deprecated_future(); //~ ERROR use of item 'deprecated_future' that will be deprecated in future version 99.99.99: text\n+LL |     deprecated_future(); // ok; deprecated_in_future only applies to rustc_deprecated\n    |     ^^^^^^^^^^^^^^^^^\n    |\n-note: lint level defined here\n-  --> $DIR/deprecation-in-future.rs:3:9\n-   |\n-LL | #![deny(deprecated_in_future)]\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n+   = note: #[warn(deprecated)] on by default\n "}, {"sha": "033d6eebbb21957542e11e245b2713001179d2a6", "filename": "src/test/ui/deprecation/deprecation-lint.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -261,8 +261,9 @@ mod this_crate {\n         <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n         <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n \n-        deprecated_future(); // Fine; no error.\n-        deprecated_future_text(); // Fine; no error.\n+        // Future deprecations are only permitted for rustc_deprecated.\n+        deprecated_future(); //~ ERROR use of deprecated item\n+        deprecated_future_text(); //~ ERROR use of deprecated item\n \n         let _ = DeprecatedStruct {\n             //~^ ERROR use of deprecated item 'this_crate::DeprecatedStruct': text"}, {"sha": "c48d06e86154d84b27b89d71927d4bc92a4b18d4", "filename": "src/test/ui/deprecation/deprecation-lint.stderr", "status": "modified", "additions": 56, "deletions": 44, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.stderr?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -214,128 +214,140 @@ error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n LL |         <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: use of deprecated item 'this_crate::deprecated_future': text\n+  --> $DIR/deprecation-lint.rs:265:9\n+   |\n+LL |         deprecated_future(); //~ ERROR use of deprecated item\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: use of deprecated item 'this_crate::deprecated_future_text': text\n+  --> $DIR/deprecation-lint.rs:266:9\n+   |\n+LL |         deprecated_future_text(); //~ ERROR use of deprecated item\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+\n error: use of deprecated item 'this_crate::DeprecatedStruct': text\n-  --> $DIR/deprecation-lint.rs:267:17\n+  --> $DIR/deprecation-lint.rs:268:17\n    |\n LL |         let _ = DeprecatedStruct {\n    |                 ^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::DeprecatedUnitStruct': text\n-  --> $DIR/deprecation-lint.rs:272:17\n+  --> $DIR/deprecation-lint.rs:273:17\n    |\n LL |         let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item 'this_crate::DeprecatedUnitStruct': text\n    |                 ^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::Enum::DeprecatedVariant': text\n-  --> $DIR/deprecation-lint.rs:274:17\n+  --> $DIR/deprecation-lint.rs:275:17\n    |\n LL |         let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item 'this_crate::Enum::DeprecatedVariant': text\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::DeprecatedTupleStruct': text\n-  --> $DIR/deprecation-lint.rs:276:17\n+  --> $DIR/deprecation-lint.rs:277:17\n    |\n LL |         let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item 'this_crate::DeprecatedTupleStruct': text\n    |                 ^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::nested::DeprecatedStruct': text\n-  --> $DIR/deprecation-lint.rs:278:17\n+  --> $DIR/deprecation-lint.rs:279:17\n    |\n LL |         let _ = nested::DeprecatedStruct {\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::nested::DeprecatedUnitStruct': text\n-  --> $DIR/deprecation-lint.rs:283:17\n+  --> $DIR/deprecation-lint.rs:284:17\n    |\n LL |         let _ = nested::DeprecatedUnitStruct; //~ ERROR use of deprecated item 'this_crate::nested::DeprecatedUnitStruct': text\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::nested::Enum::DeprecatedVariant': text\n-  --> $DIR/deprecation-lint.rs:285:17\n+  --> $DIR/deprecation-lint.rs:286:17\n    |\n LL |         let _ = nested::Enum::DeprecatedVariant; //~ ERROR use of deprecated item 'this_crate::nested::Enum::DeprecatedVariant': text\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::nested::DeprecatedTupleStruct': text\n-  --> $DIR/deprecation-lint.rs:287:17\n+  --> $DIR/deprecation-lint.rs:288:17\n    |\n LL |         let _ = nested::DeprecatedTupleStruct (1); //~ ERROR use of deprecated item 'this_crate::nested::DeprecatedTupleStruct': text\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n-  --> $DIR/deprecation-lint.rs:292:9\n+  --> $DIR/deprecation-lint.rs:293:9\n    |\n LL |         Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n-  --> $DIR/deprecation-lint.rs:294:9\n+  --> $DIR/deprecation-lint.rs:295:9\n    |\n LL |         <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-  --> $DIR/deprecation-lint.rs:296:9\n+  --> $DIR/deprecation-lint.rs:297:9\n    |\n LL |         Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-  --> $DIR/deprecation-lint.rs:298:9\n+  --> $DIR/deprecation-lint.rs:299:9\n    |\n LL |         <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::test_fn_closure_body::{{closure}}::bar'\n-  --> $DIR/deprecation-lint.rs:316:13\n+  --> $DIR/deprecation-lint.rs:317:13\n    |\n LL |             bar(); //~ ERROR use of deprecated item 'this_crate::test_fn_closure_body::{{closure}}::bar'\n    |             ^^^\n \n error: use of deprecated item 'this_crate::DeprecatedTrait': text\n-  --> $DIR/deprecation-lint.rs:335:10\n+  --> $DIR/deprecation-lint.rs:336:10\n    |\n LL |     impl DeprecatedTrait for S { } //~ ERROR use of deprecated item 'this_crate::DeprecatedTrait': text\n    |          ^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::DeprecatedTrait': text\n-  --> $DIR/deprecation-lint.rs:337:24\n+  --> $DIR/deprecation-lint.rs:338:24\n    |\n LL |     trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated item 'this_crate::DeprecatedTrait': text\n    |                        ^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Deprecated': text\n-  --> $DIR/deprecation-lint.rs:389:17\n+  --> $DIR/deprecation-lint.rs:390:17\n    |\n LL |         let x = Deprecated {\n    |                 ^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Deprecated': text\n-  --> $DIR/deprecation-lint.rs:398:13\n+  --> $DIR/deprecation-lint.rs:399:13\n    |\n LL |         let Deprecated {\n    |             ^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Deprecated': text\n-  --> $DIR/deprecation-lint.rs:404:13\n+  --> $DIR/deprecation-lint.rs:405:13\n    |\n LL |         let Deprecated\n    |             ^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Deprecated2': text\n-  --> $DIR/deprecation-lint.rs:409:17\n+  --> $DIR/deprecation-lint.rs:410:17\n    |\n LL |         let x = Deprecated2(1, 2, 3);\n    |                 ^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Deprecated2': text\n-  --> $DIR/deprecation-lint.rs:419:13\n+  --> $DIR/deprecation-lint.rs:420:13\n    |\n LL |         let Deprecated2\n    |             ^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Deprecated2': text\n-  --> $DIR/deprecation-lint.rs:428:13\n+  --> $DIR/deprecation-lint.rs:429:13\n    |\n LL |         let Deprecated2\n    |             ^^^^^^^^^^^\n@@ -593,136 +605,136 @@ LL |         <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated ite\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::DeprecatedStruct::i': text\n-  --> $DIR/deprecation-lint.rs:269:13\n+  --> $DIR/deprecation-lint.rs:270:13\n    |\n LL |             i: 0 //~ ERROR use of deprecated item 'this_crate::DeprecatedStruct::i': text\n    |             ^^^^\n \n error: use of deprecated item 'this_crate::nested::DeprecatedStruct::i': text\n-  --> $DIR/deprecation-lint.rs:280:13\n+  --> $DIR/deprecation-lint.rs:281:13\n    |\n LL |             i: 0 //~ ERROR use of deprecated item 'this_crate::nested::DeprecatedStruct::i': text\n    |             ^^^^\n \n error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n-  --> $DIR/deprecation-lint.rs:291:13\n+  --> $DIR/deprecation-lint.rs:292:13\n    |\n LL |         foo.trait_deprecated(); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n    |             ^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n-  --> $DIR/deprecation-lint.rs:293:9\n+  --> $DIR/deprecation-lint.rs:294:9\n    |\n LL |         <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-  --> $DIR/deprecation-lint.rs:295:13\n+  --> $DIR/deprecation-lint.rs:296:13\n    |\n LL |         foo.trait_deprecated_text(); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-  --> $DIR/deprecation-lint.rs:297:9\n+  --> $DIR/deprecation-lint.rs:298:9\n    |\n LL |         <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::Trait::trait_deprecated': text\n-  --> $DIR/deprecation-lint.rs:302:13\n+  --> $DIR/deprecation-lint.rs:303:13\n    |\n LL |         foo.trait_deprecated(); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated'\n    |             ^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n-  --> $DIR/deprecation-lint.rs:303:13\n+  --> $DIR/deprecation-lint.rs:304:13\n    |\n LL |         foo.trait_deprecated_text(); //~ ERROR use of deprecated item 'this_crate::Trait::trait_deprecated_text': text\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Stable::override2': text\n-  --> $DIR/deprecation-lint.rs:362:13\n+  --> $DIR/deprecation-lint.rs:363:13\n    |\n LL |             override2: 3,\n    |             ^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Stable::override2': text\n-  --> $DIR/deprecation-lint.rs:366:17\n+  --> $DIR/deprecation-lint.rs:367:17\n    |\n LL |         let _ = x.override2;\n    |                 ^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Stable::override2': text\n-  --> $DIR/deprecation-lint.rs:370:13\n+  --> $DIR/deprecation-lint.rs:371:13\n    |\n LL |             override2: _\n    |             ^^^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Stable2::2': text\n-  --> $DIR/deprecation-lint.rs:378:17\n+  --> $DIR/deprecation-lint.rs:379:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n error: use of deprecated item 'this_crate2::Stable2::2': text\n-  --> $DIR/deprecation-lint.rs:383:20\n+  --> $DIR/deprecation-lint.rs:384:20\n    |\n LL |                    _)\n    |                    ^\n \n error: use of deprecated item 'this_crate2::Deprecated::inherit': text\n-  --> $DIR/deprecation-lint.rs:391:13\n+  --> $DIR/deprecation-lint.rs:392:13\n    |\n LL |             inherit: 1,\n    |             ^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Deprecated::inherit': text\n-  --> $DIR/deprecation-lint.rs:395:17\n+  --> $DIR/deprecation-lint.rs:396:17\n    |\n LL |         let _ = x.inherit;\n    |                 ^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Deprecated::inherit': text\n-  --> $DIR/deprecation-lint.rs:400:13\n+  --> $DIR/deprecation-lint.rs:401:13\n    |\n LL |             inherit: _,\n    |             ^^^^^^^^^^\n \n error: use of deprecated item 'this_crate2::Deprecated2::0': text\n-  --> $DIR/deprecation-lint.rs:412:17\n+  --> $DIR/deprecation-lint.rs:413:17\n    |\n LL |         let _ = x.0;\n    |                 ^^^\n \n error: use of deprecated item 'this_crate2::Deprecated2::1': text\n-  --> $DIR/deprecation-lint.rs:414:17\n+  --> $DIR/deprecation-lint.rs:415:17\n    |\n LL |         let _ = x.1;\n    |                 ^^^\n \n error: use of deprecated item 'this_crate2::Deprecated2::2': text\n-  --> $DIR/deprecation-lint.rs:416:17\n+  --> $DIR/deprecation-lint.rs:417:17\n    |\n LL |         let _ = x.2;\n    |                 ^^^\n \n error: use of deprecated item 'this_crate2::Deprecated2::0': text\n-  --> $DIR/deprecation-lint.rs:421:14\n+  --> $DIR/deprecation-lint.rs:422:14\n    |\n LL |             (_,\n    |              ^\n \n error: use of deprecated item 'this_crate2::Deprecated2::1': text\n-  --> $DIR/deprecation-lint.rs:423:14\n+  --> $DIR/deprecation-lint.rs:424:14\n    |\n LL |              _,\n    |              ^\n \n error: use of deprecated item 'this_crate2::Deprecated2::2': text\n-  --> $DIR/deprecation-lint.rs:425:14\n+  --> $DIR/deprecation-lint.rs:426:14\n    |\n LL |              _)\n    |              ^\n \n-error: aborting due to 120 previous errors\n+error: aborting due to 122 previous errors\n "}, {"sha": "a19363c512950c06f1b304b96d41d03ace087ac4", "filename": "src/test/ui/deprecation/rustc_deprecation-in-future.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -0,0 +1,15 @@\n+// ignore-tidy-linelength\n+\n+#![deny(deprecated_in_future)]\n+\n+#![feature(staged_api)]\n+\n+#![stable(feature = \"rustc_deprecation-in-future-test\", since = \"1.0.0\")]\n+\n+#[rustc_deprecated(since = \"99.99.99\", reason = \"effectively never\")]\n+#[stable(feature = \"rustc_deprecation-in-future-test\", since = \"1.0.0\")]\n+pub struct S;\n+\n+fn main() {\n+    let _ = S; //~ ERROR use of item 'S' that will be deprecated in future version 99.99.99: effectively never\n+}"}, {"sha": "bd8ade16ec0e85577223123be5c99f80e1c75845", "filename": "src/test/ui/deprecation/rustc_deprecation-in-future.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Frustc_deprecation-in-future.stderr?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -0,0 +1,14 @@\n+error: use of item 'S' that will be deprecated in future version 99.99.99: effectively never\n+  --> $DIR/rustc_deprecation-in-future.rs:14:13\n+   |\n+LL |     let _ = S; //~ ERROR use of item 'S' that will be deprecated in future version 99.99.99: effectively never\n+   |             ^\n+   |\n+note: lint level defined here\n+  --> $DIR/rustc_deprecation-in-future.rs:3:9\n+   |\n+LL | #![deny(deprecated_in_future)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "9d746673f4dae41791c7bae84c1b23e386ed2817", "filename": "src/test/ui/issue-42944.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fissue-42944.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fissue-42944.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-42944.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -0,0 +1,19 @@\n+mod foo {\n+    pub struct B(());\n+}\n+\n+mod bar {\n+    use foo::B;\n+\n+    fn foo() {\n+        B(()); //~ ERROR expected function, found struct `B` [E0423]\n+    }\n+}\n+\n+mod baz {\n+    fn foo() {\n+        B(()); //~ ERROR cannot find function `B` in this scope [E0425]\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "43fd0ffb72439d3c17426ff114cb4631de02be0f", "filename": "src/test/ui/issue-42944.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fissue-42944.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fissue-42944.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-42944.stderr?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -0,0 +1,20 @@\n+error[E0423]: expected function, found struct `B`\n+  --> $DIR/issue-42944.rs:9:9\n+   |\n+LL |         B(()); //~ ERROR expected function, found struct `B` [E0423]\n+   |         ^ constructor is not visible here due to private fields\n+\n+error[E0425]: cannot find function `B` in this scope\n+  --> $DIR/issue-42944.rs:15:9\n+   |\n+LL |         B(()); //~ ERROR cannot find function `B` in this scope [E0425]\n+   |         ^ not found in this scope\n+help: possible candidate is found in another module, you can import it into scope\n+   |\n+LL |     use foo::B;\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0423, E0425.\n+For more information about an error, try `rustc --explain E0423`."}, {"sha": "469c22fdb17d7b6aedbf12e8cfa4500d57b41674", "filename": "src/test/ui/missing/missing-stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fmissing%2Fmissing-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fmissing%2Fmissing-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-stability.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -6,7 +6,7 @@\n #![stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n \n pub fn unmarked() {\n-    //~^ ERROR This node does not have a stability attribute\n+    //~^ ERROR function has missing stability attribute\n     ()\n }\n \n@@ -20,5 +20,5 @@ pub mod foo {\n pub mod bar {\n     // #[stable] is not inherited\n     pub fn unmarked() {}\n-    //~^ ERROR This node does not have a stability attribute\n+    //~^ ERROR function has missing stability attribute\n }"}, {"sha": "6c81f2bac57889753083ab52d233ae573380ca80", "filename": "src/test/ui/missing/missing-stability.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fmissing%2Fmissing-stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fmissing%2Fmissing-stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-stability.stderr?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,13 +1,13 @@\n-error: This node does not have a stability attribute\n+error: function has missing stability attribute\n   --> $DIR/missing-stability.rs:8:1\n    |\n LL | / pub fn unmarked() {\n-LL | |     //~^ ERROR This node does not have a stability attribute\n+LL | |     //~^ ERROR function has missing stability attribute\n LL | |     ()\n LL | | }\n    | |_^\n \n-error: This node does not have a stability attribute\n+error: function has missing stability attribute\n   --> $DIR/missing-stability.rs:22:5\n    |\n LL |     pub fn unmarked() {}"}, {"sha": "519e74d9f631583dd55586e43a830183ac254168", "filename": "src/test/ui/resolve/privacy-struct-ctor.stderr", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -2,25 +2,16 @@ error[E0423]: expected value, found struct `Z`\n   --> $DIR/privacy-struct-ctor.rs:20:9\n    |\n LL |         Z;\n-   |         ^ constructor is not visible here due to private fields\n-help: a tuple struct with a similar name exists\n-   |\n-LL |         S;\n    |         ^\n-help: possible better candidate is found in another module, you can import it into scope\n-   |\n-LL |     use m::n::Z;\n-   |\n+   |         |\n+   |         constructor is not visible here due to private fields\n+   |         help: a tuple struct with a similar name exists: `S`\n \n error[E0423]: expected value, found struct `S`\n   --> $DIR/privacy-struct-ctor.rs:33:5\n    |\n LL |     S;\n    |     ^ constructor is not visible here due to private fields\n-help: possible better candidate is found in another module, you can import it into scope\n-   |\n-LL | use m::S;\n-   |\n \n error[E0423]: expected value, found struct `S2`\n   --> $DIR/privacy-struct-ctor.rs:38:5"}, {"sha": "8f750ae62f5e4c2f57e725e0f3b620410535479d", "filename": "src/test/ui/stability-attribute/missing-stability-attr-at-top-level.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -0,0 +1,4 @@\n+#![feature(staged_api)]\n+//~^ ERROR crate has missing stability attribute\n+\n+fn main() {}"}, {"sha": "f6747976945572429892e77838fc31dd4ab74305", "filename": "src/test/ui/stability-attribute/missing-stability-attr-at-top-level.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fmissing-stability-attr-at-top-level.stderr?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -0,0 +1,11 @@\n+error: crate has missing stability attribute\n+  --> $DIR/missing-stability-attr-at-top-level.rs:1:1\n+   |\n+LL | / #![feature(staged_api)]\n+LL | | //~^ ERROR crate has missing stability attribute\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n+\n+error: aborting due to previous error\n+"}, {"sha": "0b243bb52119bae080f3163343f3b4e6ff61340e", "filename": "src/test/ui/stability-attribute/stability-attribute-issue-43027.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-issue-43027.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-issue-43027.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-issue-43027.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -2,7 +2,7 @@\n #![stable(feature = \"test\", since = \"0\")]\n \n #[stable(feature = \"test\", since = \"0\")]\n-pub struct Reverse<T>(pub T); //~ ERROR This node does not have a stability attribute\n+pub struct Reverse<T>(pub T); //~ ERROR field has missing stability attribute\n \n fn main() {\n     // Make sure the field is used to fill the stability cache"}, {"sha": "7ffb4bb487a7b514b3cc04a50156efe38ee05739", "filename": "src/test/ui/stability-attribute/stability-attribute-issue-43027.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-issue-43027.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-issue-43027.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-issue-43027.stderr?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,7 +1,7 @@\n-error: This node does not have a stability attribute\n+error: field has missing stability attribute\n   --> $DIR/stability-attribute-issue-43027.rs:5:23\n    |\n-LL | pub struct Reverse<T>(pub T); //~ ERROR This node does not have a stability attribute\n+LL | pub struct Reverse<T>(pub T); //~ ERROR field has missing stability attribute\n    |                       ^^^^^\n \n error: aborting due to previous error"}, {"sha": "13ef3d3f53d2b0dc2629249eda300d8c6f90ed38", "filename": "src/test/ui/stability-attribute/stability-attribute-sanity-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity-3.rs?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -5,7 +5,7 @@\n #![stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n \n #[macro_export]\n-macro_rules! mac { //~ ERROR This node does not have a stability attribute\n+macro_rules! mac { //~ ERROR macro has missing stability attribute\n     () => ()\n }\n "}, {"sha": "1c759d49b9947483a4c22529d566f7466782de29", "filename": "src/test/ui/stability-attribute/stability-attribute-sanity-3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4772dc8087b1d0f2bab6d064fd930e596c82d439/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity-3.stderr?ref=4772dc8087b1d0f2bab6d064fd930e596c82d439", "patch": "@@ -1,7 +1,7 @@\n-error: This node does not have a stability attribute\n+error: macro has missing stability attribute\n   --> $DIR/stability-attribute-sanity-3.rs:8:1\n    |\n-LL | / macro_rules! mac { //~ ERROR This node does not have a stability attribute\n+LL | / macro_rules! mac { //~ ERROR macro has missing stability attribute\n LL | |     () => ()\n LL | | }\n    | |_^"}]}