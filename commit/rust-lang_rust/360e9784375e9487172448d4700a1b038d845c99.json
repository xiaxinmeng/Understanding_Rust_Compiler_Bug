{"sha": "360e9784375e9487172448d4700a1b038d845c99", "node_id": "C_kwDOAAsO6NoAKDM2MGU5Nzg0Mzc1ZTk0ODcxNzI0NDhkNDcwMGExYjAzOGQ4NDVjOTk", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-09T15:15:26Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-17T07:48:19Z"}, "message": "Don't call closures immediately, use `try{}` blocks", "tree": {"sha": "98292d79e3230200cdaaeaf24d491a44af4ea3f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98292d79e3230200cdaaeaf24d491a44af4ea3f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/360e9784375e9487172448d4700a1b038d845c99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/360e9784375e9487172448d4700a1b038d845c99", "html_url": "https://github.com/rust-lang/rust/commit/360e9784375e9487172448d4700a1b038d845c99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/360e9784375e9487172448d4700a1b038d845c99/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bddbf38af29dcfe5ebe12efebf465233fbb52398", "url": "https://api.github.com/repos/rust-lang/rust/commits/bddbf38af29dcfe5ebe12efebf465233fbb52398", "html_url": "https://github.com/rust-lang/rust/commit/bddbf38af29dcfe5ebe12efebf465233fbb52398"}], "stats": {"total": 203, "additions": 88, "deletions": 115}, "files": [{"sha": "2133b5ac50b029fc11a1f1ae815cf9f56aaea68d", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=360e9784375e9487172448d4700a1b038d845c99", "patch": "@@ -47,42 +47,22 @@ pub(super) fn compare_impl_method<'tcx>(\n \n     let impl_m_span = tcx.def_span(impl_m.def_id);\n \n-    if let Err(_) = compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_generic_param_kinds(tcx, impl_m, trait_m, false) {\n-        return;\n-    }\n-\n-    if let Err(_) =\n-        compare_number_of_method_arguments(tcx, impl_m, impl_m_span, trait_m, trait_item_span)\n-    {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_synthetic_generics(tcx, impl_m, trait_m) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_asyncness(tcx, impl_m, impl_m_span, trait_m, trait_item_span) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_method_predicate_entailment(\n-        tcx,\n-        impl_m,\n-        impl_m_span,\n-        trait_m,\n-        impl_trait_ref,\n-        CheckImpliedWfMode::Check,\n-    ) {\n-        return;\n-    }\n+    let _: Result<_, ErrorGuaranteed> = try {\n+        compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)?;\n+        compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false)?;\n+        compare_generic_param_kinds(tcx, impl_m, trait_m, false)?;\n+        compare_number_of_method_arguments(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_synthetic_generics(tcx, impl_m, trait_m)?;\n+        compare_asyncness(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_method_predicate_entailment(\n+            tcx,\n+            impl_m,\n+            impl_m_span,\n+            trait_m,\n+            impl_trait_ref,\n+            CheckImpliedWfMode::Check,\n+        )?;\n+    };\n }\n \n /// This function is best explained by example. Consider a trait:\n@@ -1493,7 +1473,7 @@ fn compare_synthetic_generics<'tcx>(\n                 // explicit generics\n                 (true, false) => {\n                     err.span_label(impl_span, \"expected generic parameter, found `impl Trait`\");\n-                    (|| {\n+                    let _: Option<_> = try {\n                         // try taking the name from the trait impl\n                         // FIXME: this is obviously suboptimal since the name can already be used\n                         // as another generic argument\n@@ -1526,14 +1506,13 @@ fn compare_synthetic_generics<'tcx>(\n                             ],\n                             Applicability::MaybeIncorrect,\n                         );\n-                        Some(())\n-                    })();\n+                    };\n                 }\n                 // The case where the trait method uses `impl Trait`, but the impl method uses\n                 // explicit generics.\n                 (false, true) => {\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n-                    (|| {\n+                    let _: Option<_> = try {\n                         let impl_m = impl_m.def_id.as_local()?;\n                         let impl_m = tcx.hir().expect_impl_item(impl_m);\n                         let input_tys = match impl_m.kind {\n@@ -1573,8 +1552,7 @@ fn compare_synthetic_generics<'tcx>(\n                             ],\n                             Applicability::MaybeIncorrect,\n                         );\n-                        Some(())\n-                    })();\n+                    };\n                 }\n                 _ => unreachable!(),\n             }\n@@ -1799,16 +1777,16 @@ pub(super) fn compare_impl_ty<'tcx>(\n ) {\n     debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    let _: Result<(), ErrorGuaranteed> = (|| {\n+    let _: Result<(), ErrorGuaranteed> = try {\n         compare_number_of_generics(tcx, impl_ty, trait_ty, trait_item_span, false)?;\n \n         compare_generic_param_kinds(tcx, impl_ty, trait_ty, false)?;\n \n         let sp = tcx.def_span(impl_ty.def_id);\n         compare_type_predicate_entailment(tcx, impl_ty, sp, trait_ty, impl_trait_ref)?;\n \n-        check_type_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)\n-    })();\n+        check_type_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)?;\n+    };\n }\n \n /// The equivalent of [compare_method_predicate_entailment], but for associated types"}, {"sha": "3c5a3b16ec18afee95dbe1432c635db9412da5a7", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=360e9784375e9487172448d4700a1b038d845c99", "patch": "@@ -251,7 +251,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     VarValue::Empty(a_universe) => {\n                         let b_data = var_values.value_mut(b_vid);\n \n-                        let changed = (|| match *b_data {\n+                        let changed = match *b_data {\n                             VarValue::Empty(b_universe) => {\n                                 // Empty regions are ordered according to the universe\n                                 // they are associated with.\n@@ -280,20 +280,20 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                                 };\n \n                                 if lub == cur_region {\n-                                    return false;\n+                                    false\n+                                } else {\n+                                    debug!(\n+                                        \"Expanding value of {:?} from {:?} to {:?}\",\n+                                        b_vid, cur_region, lub\n+                                    );\n+\n+                                    *b_data = VarValue::Value(lub);\n+                                    true\n                                 }\n-\n-                                debug!(\n-                                    \"Expanding value of {:?} from {:?} to {:?}\",\n-                                    b_vid, cur_region, lub\n-                                );\n-\n-                                *b_data = VarValue::Value(lub);\n-                                true\n                             }\n \n                             VarValue::ErrorValue => false,\n-                        })();\n+                        };\n \n                         if changed {\n                             changes.push(b_vid);"}, {"sha": "82bc4770b6b471dcd60caa00fea9ed733d7e9d03", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=360e9784375e9487172448d4700a1b038d845c99", "patch": "@@ -3,6 +3,7 @@\n #![feature(internal_output_capture)]\n #![feature(thread_spawn_unchecked)]\n #![feature(once_cell)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "9bee49f4ba8b220fd8a46a9096198e618ef96cbc", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=360e9784375e9487172448d4700a1b038d845c99", "patch": "@@ -559,7 +559,7 @@ fn write_out_deps(\n     }\n     let deps_filename = outputs.path(OutputType::DepInfo);\n \n-    let result = (|| -> io::Result<()> {\n+    let result: io::Result<()> = try {\n         // Build a list of files used to compile the output and\n         // write Makefile-compatible dependency rules\n         let mut files: Vec<String> = sess\n@@ -646,9 +646,7 @@ fn write_out_deps(\n                 writeln!(file)?;\n             }\n         }\n-\n-        Ok(())\n-    })();\n+    };\n \n     match result {\n         Ok(_) => {"}, {"sha": "fcc8f457a8b7887296526a2d1093a5b3f86027a6", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=360e9784375e9487172448d4700a1b038d845c99", "patch": "@@ -159,18 +159,20 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n             }\n             chalk_ir::TyKind::Array(ty, len) => Some(write!(fmt, \"[{:?}; {:?}]\", ty, len)),\n             chalk_ir::TyKind::Slice(ty) => Some(write!(fmt, \"[{:?}]\", ty)),\n-            chalk_ir::TyKind::Tuple(len, substs) => Some((|| {\n-                write!(fmt, \"(\")?;\n-                for (idx, substitution) in substs.interned().iter().enumerate() {\n-                    if idx == *len && *len != 1 {\n-                        // Don't add a trailing comma if the tuple has more than one element\n-                        write!(fmt, \"{:?}\", substitution)?;\n-                    } else {\n-                        write!(fmt, \"{:?},\", substitution)?;\n+            chalk_ir::TyKind::Tuple(len, substs) => Some(\n+                try {\n+                    write!(fmt, \"(\")?;\n+                    for (idx, substitution) in substs.interned().iter().enumerate() {\n+                        if idx == *len && *len != 1 {\n+                            // Don't add a trailing comma if the tuple has more than one element\n+                            write!(fmt, \"{:?}\", substitution)?;\n+                        } else {\n+                            write!(fmt, \"{:?},\", substitution)?;\n+                        }\n                     }\n-                }\n-                write!(fmt, \")\")\n-            })()),\n+                    write!(fmt, \")\")?;\n+                },\n+            ),\n             _ => None,\n         }\n     }"}, {"sha": "33fdc1901cd781b2832dbcdf832271ed706d5f8b", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=360e9784375e9487172448d4700a1b038d845c99", "patch": "@@ -86,10 +86,10 @@ pub(super) fn build_custom_mir<'tcx>(\n         block_map: FxHashMap::default(),\n     };\n \n-    let res = (|| {\n+    let res: PResult<_> = try {\n         pctxt.parse_args(&params)?;\n-        pctxt.parse_body(expr)\n-    })();\n+        pctxt.parse_body(expr)?;\n+    };\n     if let Err(err) = res {\n         tcx.sess.diagnostic().span_fatal(\n             err.span,"}, {"sha": "ef502b4fa81e165c32d997cfa64ec32d05b478d4", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=360e9784375e9487172448d4700a1b038d845c99", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 //\n                 // it is usually better to focus on `the_value` rather\n                 // than the entirety of block(s) surrounding it.\n-                let adjusted_span = (|| {\n+                let adjusted_span = \n                     if let ExprKind::Block { block } = expr.kind\n                         && let Some(tail_ex) = this.thir[block].expr\n                     {\n@@ -135,10 +135,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             tail_result_is_ignored: true,\n                             span: expr.span,\n                         });\n-                        return Some(expr.span);\n-                    }\n-                    None\n-                })();\n+                        Some(expr.span)\n+                    } else {\n+                        None\n+                    };\n \n                 let temp =\n                     unpack!(block = this.as_temp(block, statement_scope, expr, Mutability::Not));"}, {"sha": "e754e2465346fde741c36e91c172f02762572e7b", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=360e9784375e9487172448d4700a1b038d845c99", "patch": "@@ -141,27 +141,23 @@ impl IntRange {\n     ) -> Option<IntRange> {\n         let ty = value.ty();\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, ty) {\n-            let val = (|| {\n-                match value {\n-                    mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) => {\n-                        // For this specific pattern we can skip a lot of effort and go\n-                        // straight to the result, after doing a bit of checking. (We\n-                        // could remove this branch and just fall through, which\n-                        // is more general but much slower.)\n-                        return scalar.to_bits_or_ptr_internal(target_size).unwrap().left();\n+            let val =\n+                if let mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) = value {\n+                    // For this specific pattern we can skip a lot of effort and go\n+                    // straight to the result, after doing a bit of checking. (We\n+                    // could remove this branch and just fall through, which\n+                    // is more general but much slower.)\n+                    scalar.to_bits_or_ptr_internal(target_size).unwrap().left()?\n+                } else {\n+                    if let mir::ConstantKind::Ty(c) = value\n+                        && let ty::ConstKind::Value(_) = c.kind() \n+                    {\n+                        bug!(\"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\");\n                     }\n-                    mir::ConstantKind::Ty(c) => match c.kind() {\n-                        ty::ConstKind::Value(_) => bug!(\n-                            \"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\"\n-                        ),\n-                        _ => {}\n-                    },\n-                    _ => {}\n-                }\n \n-                // This is a more general form of the previous case.\n-                value.try_eval_bits(tcx, param_env, ty)\n-            })()?;\n+                    // This is a more general form of the previous case.\n+                    value.try_eval_bits(tcx, param_env, ty)?\n+                };\n             let val = val ^ bias;\n             Some(IntRange { range: val..=val, bias })\n         } else {"}, {"sha": "ea27db7b81f8790ed5cec181b89655d0e700edb7", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=360e9784375e9487172448d4700a1b038d845c99", "patch": "@@ -208,14 +208,12 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n             _ => {\n                 // This `for` loop was once a call to `all()`, but this lower-level\n                 // form was a perf win. See #64545 for details.\n-                (|| {\n-                    for &infer_var in &pending_obligation.stalled_on {\n-                        if self.selcx.infcx.ty_or_const_infer_var_changed(infer_var) {\n-                            return true;\n-                        }\n+                for &infer_var in &pending_obligation.stalled_on {\n+                    if self.selcx.infcx.ty_or_const_infer_var_changed(infer_var) {\n+                        return true;\n                     }\n-                    false\n-                })()\n+                }\n+                false\n             }\n         }\n     }"}, {"sha": "751aec48bd8c31e6da7827a5714cdb8fa96840e9", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360e9784375e9487172448d4700a1b038d845c99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=360e9784375e9487172448d4700a1b038d845c99", "patch": "@@ -201,7 +201,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n         // wait to fold the substs.\n \n         // Wrap this in a closure so we don't accidentally return from the outer function\n-        let res = (|| match *ty.kind() {\n+        let res = match *ty.kind() {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n@@ -210,7 +210,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n             {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n-                    Reveal::UserFacing => ty.try_super_fold_with(self),\n+                    Reveal::UserFacing => ty.try_super_fold_with(self)?,\n \n                     Reveal::All => {\n                         let substs = substs.try_fold_with(self)?;\n@@ -230,7 +230,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         if concrete_ty == ty {\n                             bug!(\n                                 \"infinite recursion generic_ty: {:#?}, substs: {:#?}, \\\n-                                 concrete_ty: {:#?}, ty: {:#?}\",\n+                             concrete_ty: {:#?}, ty: {:#?}\",\n                                 generic_ty,\n                                 substs,\n                                 concrete_ty,\n@@ -239,7 +239,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         }\n                         let folded_ty = ensure_sufficient_stack(|| self.try_fold_ty(concrete_ty));\n                         self.anon_depth -= 1;\n-                        folded_ty\n+                        folded_ty?\n                     }\n                 }\n             }\n@@ -287,9 +287,9 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // `tcx.normalize_projection_ty` may normalize to a type that still has\n                 // unevaluated consts, so keep normalizing here if that's the case.\n                 if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n-                    Ok(res.try_super_fold_with(self)?)\n+                    res.try_super_fold_with(self)?\n                 } else {\n-                    Ok(res)\n+                    res\n                 }\n             }\n \n@@ -344,14 +344,14 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // `tcx.normalize_projection_ty` may normalize to a type that still has\n                 // unevaluated consts, so keep normalizing here if that's the case.\n                 if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n-                    Ok(res.try_super_fold_with(self)?)\n+                    res.try_super_fold_with(self)?\n                 } else {\n-                    Ok(res)\n+                    res\n                 }\n             }\n \n-            _ => ty.try_super_fold_with(self),\n-        })()?;\n+            _ => ty.try_super_fold_with(self)?,\n+        };\n \n         self.cache.insert(ty, res);\n         Ok(res)"}]}