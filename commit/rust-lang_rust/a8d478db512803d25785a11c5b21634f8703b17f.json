{"sha": "a8d478db512803d25785a11c5b21634f8703b17f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZDQ3OGRiNTEyODAzZDI1Nzg1YTExYzViMjE2MzRmODcwM2IxN2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-15T16:56:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-15T16:56:03Z"}, "message": "auto merge of #17208 : kmcallister/rust/llvm-diagnostics, r=thestinger\n\nI would like to map this information back to AST nodes, so that we can print remarks with spans, and so that remarks can be enabled on a per-function basis.  Unfortunately, doing this would require a lot more code restructuring \u2014 for example, we currently throw away the AST map and lots of other information before LLVM optimizations run.  So for the time being, we print the remarks with debug location strings from LLVM.  There's a warning if you use `-C remark` without `--debuginfo`.\r\n\r\nFixes #17116.", "tree": {"sha": "3b26870796579c4563a938cadf93b98569b6d7f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b26870796579c4563a938cadf93b98569b6d7f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8d478db512803d25785a11c5b21634f8703b17f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d478db512803d25785a11c5b21634f8703b17f", "html_url": "https://github.com/rust-lang/rust/commit/a8d478db512803d25785a11c5b21634f8703b17f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8d478db512803d25785a11c5b21634f8703b17f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e2860407b6b9e618e9f466610ae66e51f0d16da", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e2860407b6b9e618e9f466610ae66e51f0d16da", "html_url": "https://github.com/rust-lang/rust/commit/8e2860407b6b9e618e9f466610ae66e51f0d16da"}, {"sha": "ad9a1daa819bbeb8e643a01167b3b69055b88d57", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad9a1daa819bbeb8e643a01167b3b69055b88d57", "html_url": "https://github.com/rust-lang/rust/commit/ad9a1daa819bbeb8e643a01167b3b69055b88d57"}], "stats": {"total": 405, "additions": 366, "deletions": 39}, "files": [{"sha": "53bdf500a217b0d407d44cc000a65f8fbabcfc96", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 56, "deletions": 11, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a8d478db512803d25785a11c5b21634f8703b17f/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d478db512803d25785a11c5b21634f8703b17f/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=a8d478db512803d25785a11c5b21634f8703b17f", "patch": "@@ -11,11 +11,11 @@\n use back::lto;\n use back::link::{get_cc_prog, remove};\n use driver::driver::{CrateTranslation, ModuleTranslation, OutputFilenames};\n-use driver::config::NoDebugInfo;\n+use driver::config::{NoDebugInfo, Passes, AllPasses};\n use driver::session::Session;\n use driver::config;\n use llvm;\n-use llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n+use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef, ContextRef};\n use util::common::time;\n use syntax::abi;\n use syntax::codemap;\n@@ -28,9 +28,10 @@ use std::io::fs;\n use std::iter::Unfold;\n use std::ptr;\n use std::str;\n+use std::mem;\n use std::sync::{Arc, Mutex};\n use std::task::TaskBuilder;\n-use libc::{c_uint, c_int};\n+use libc::{c_uint, c_int, c_void};\n \n \n #[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n@@ -311,21 +312,49 @@ struct CodegenContext<'a> {\n     lto_ctxt: Option<(&'a Session, &'a [String])>,\n     // Handler to use for diagnostics produced during codegen.\n     handler: &'a Handler,\n+    // LLVM optimizations for which we want to print remarks.\n+    remark: Passes,\n }\n \n impl<'a> CodegenContext<'a> {\n-    fn new(handler: &'a Handler) -> CodegenContext<'a> {\n-        CodegenContext {\n-            lto_ctxt: None,\n-            handler: handler,\n-        }\n-    }\n-\n     fn new_with_session(sess: &'a Session, reachable: &'a [String]) -> CodegenContext<'a> {\n         CodegenContext {\n             lto_ctxt: Some((sess, reachable)),\n             handler: sess.diagnostic().handler(),\n+            remark: sess.opts.cg.remark.clone(),\n+        }\n+    }\n+}\n+\n+struct DiagHandlerFreeVars<'a> {\n+    llcx: ContextRef,\n+    cgcx: &'a CodegenContext<'a>,\n+}\n+\n+unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_void) {\n+    let DiagHandlerFreeVars { llcx, cgcx }\n+        = *mem::transmute::<_, *const DiagHandlerFreeVars>(user);\n+\n+    match llvm::diagnostic::Diagnostic::unpack(info) {\n+        llvm::diagnostic::Optimization(opt) => {\n+            let pass_name = CString::new(opt.pass_name, false);\n+            let pass_name = pass_name.as_str().expect(\"got a non-UTF8 pass name from LLVM\");\n+            let enabled = match cgcx.remark {\n+                AllPasses => true,\n+                Passes(ref v) => v.iter().any(|s| s.as_slice() == pass_name),\n+            };\n+\n+            if enabled {\n+                let loc = llvm::debug_loc_to_string(llcx, opt.debug_loc);\n+                cgcx.handler.note(format!(\"optimization {:s} for {:s} at {:s}: {:s}\",\n+                                          opt.kind.describe(),\n+                                          pass_name,\n+                                          if loc.is_empty() { \"[unknown]\" } else { loc.as_slice() },\n+                                          llvm::twine_to_string(opt.message)).as_slice());\n+            }\n         }\n+\n+        _ => (),\n     }\n }\n \n@@ -338,6 +367,17 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     let ModuleTranslation { llmod, llcx } = mtrans;\n     let tm = config.tm;\n \n+    // llcx doesn't outlive this function, so we can put this on the stack.\n+    let fv = DiagHandlerFreeVars {\n+        llcx: llcx,\n+        cgcx: cgcx,\n+    };\n+    if !cgcx.remark.is_empty() {\n+        llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler,\n+                                              &fv as *const DiagHandlerFreeVars\n+                                                  as *mut c_void);\n+    }\n+\n     if config.emit_no_opt_bc {\n         let ext = format!(\"{}.no-opt.bc\", name_extra);\n         output_names.with_extension(ext.as_slice()).with_c_str(|buf| {\n@@ -785,13 +825,18 @@ fn run_work_multithreaded(sess: &Session,\n     for i in range(0, num_workers) {\n         let work_items_arc = work_items_arc.clone();\n         let diag_emitter = diag_emitter.clone();\n+        let remark = sess.opts.cg.remark.clone();\n \n         let future = TaskBuilder::new().named(format!(\"codegen-{}\", i)).try_future(proc() {\n             let diag_handler = mk_handler(box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n             // fields.\n-            let cgcx = CodegenContext::new(&diag_handler);\n+            let cgcx = CodegenContext {\n+                lto_ctxt: None,\n+                handler: &diag_handler,\n+                remark: remark,\n+            };\n \n             loop {\n                 // Avoid holding the lock for the entire duration of the match."}, {"sha": "f7b0a178734e1bd80494d864db2cbfed8a308d22", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a8d478db512803d25785a11c5b21634f8703b17f/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d478db512803d25785a11c5b21634f8703b17f/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=a8d478db512803d25785a11c5b21634f8703b17f", "patch": "@@ -235,6 +235,21 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n                        --pretty flowgraph output\", FLOWGRAPH_PRINT_ALL))\n }\n \n+#[deriving(Clone)]\n+pub enum Passes {\n+    Passes(Vec<String>),\n+    AllPasses,\n+}\n+\n+impl Passes {\n+    pub fn is_empty(&self) -> bool {\n+        match *self {\n+            Passes(ref v) => v.is_empty(),\n+            AllPasses => false,\n+        }\n+    }\n+}\n+\n /// Declare a macro that will define all CodegenOptions fields and parsers all\n /// at once. The goal of this macro is to define an interface that can be\n /// programmatically used by the option parser in order to initialize the struct\n@@ -261,7 +276,7 @@ macro_rules! cgoptions(\n         &[ $( (stringify!($opt), cgsetters::$opt, $desc) ),* ];\n \n     mod cgsetters {\n-        use super::CodegenOptions;\n+        use super::{CodegenOptions, Passes, AllPasses};\n \n         $(\n             pub fn $opt(cg: &mut CodegenOptions, v: Option<&str>) -> bool {\n@@ -310,6 +325,24 @@ macro_rules! cgoptions(\n                 None => false\n             }\n         }\n+\n+        fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n+            match v {\n+                Some(\"all\") => {\n+                    *slot = AllPasses;\n+                    true\n+                }\n+                v => {\n+                    let mut passes = vec!();\n+                    if parse_list(&mut passes, v) {\n+                        *slot = Passes(passes);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+            }\n+        }\n     }\n ) )\n \n@@ -356,6 +389,8 @@ cgoptions!(\n          \"extra data to put in each output filename\"),\n     codegen_units: uint = (1, parse_uint,\n         \"divide crate into N units to optimize in parallel\"),\n+    remark: Passes = (Passes(Vec::new()), parse_passes,\n+        \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n )\n \n pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n@@ -716,8 +751,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             None      |\n             Some(\"2\") => FullDebugInfo,\n             Some(arg) => {\n-                early_error(format!(\"optimization level needs to be between \\\n-                                     0-3 (instead was `{}`)\",\n+                early_error(format!(\"debug info level needs to be between \\\n+                                     0-2 (instead was `{}`)\",\n                                     arg).as_slice());\n             }\n         }\n@@ -744,6 +779,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     }\n     let cg = build_codegen_options(matches);\n \n+    if !cg.remark.is_empty() && debuginfo == NoDebugInfo {\n+        early_warn(\"-C remark will not show source locations without --debuginfo\");\n+    }\n+\n     let color = match matches.opt_str(\"color\").as_ref().map(|s| s.as_slice()) {\n         Some(\"auto\")   => Auto,\n         Some(\"always\") => Always,"}, {"sha": "a6a30d6ba85ecb6d68dfe63c47b1814b6e59a472", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a8d478db512803d25785a11c5b21634f8703b17f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d478db512803d25785a11c5b21634f8703b17f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=a8d478db512803d25785a11c5b21634f8703b17f", "patch": "@@ -21,11 +21,10 @@ use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel};\n \n use std::c_str::ToCStr;\n use std::mem;\n-use std::string;\n use std::cell::RefCell;\n use std::collections::HashMap;\n \n-use libc::{c_uint, c_void, free};\n+use libc::c_uint;\n \n #[deriving(Clone, PartialEq, Show)]\n pub struct Type {\n@@ -339,12 +338,9 @@ impl TypeNames {\n     }\n \n     pub fn type_to_string(&self, ty: Type) -> String {\n-        unsafe {\n-            let s = llvm::LLVMTypeToString(ty.to_ref());\n-            let ret = string::raw::from_buf(s as *const u8);\n-            free(s as *mut c_void);\n-            ret\n-        }\n+        llvm::build_string(|s| unsafe {\n+                llvm::LLVMWriteTypeToString(ty.to_ref(), s);\n+            }).expect(\"non-UTF8 type description from LLVM\")\n     }\n \n     pub fn types_to_str(&self, tys: &[Type]) -> String {\n@@ -353,11 +349,8 @@ impl TypeNames {\n     }\n \n     pub fn val_to_string(&self, val: ValueRef) -> String {\n-        unsafe {\n-            let s = llvm::LLVMValueToString(val);\n-            let ret = string::raw::from_buf(s as *const u8);\n-            free(s as *mut c_void);\n-            ret\n-        }\n+        llvm::build_string(|s| unsafe {\n+                llvm::LLVMWriteValueToString(val, s);\n+            }).expect(\"nun-UTF8 value description from LLVM\")\n     }\n }"}, {"sha": "6e1368ec3f90cee3ca5730890deacaf2241ec214", "filename": "src/librustc_llvm/diagnostic.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a8d478db512803d25785a11c5b21634f8703b17f/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d478db512803d25785a11c5b21634f8703b17f/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=a8d478db512803d25785a11c5b21634f8703b17f", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! LLVM diagnostic reports.\n+\n+use libc::c_char;\n+\n+use {ValueRef, TwineRef, DebugLocRef, DiagnosticInfoRef};\n+\n+pub enum OptimizationDiagnosticKind {\n+    OptimizationRemark,\n+    OptimizationMissed,\n+    OptimizationAnalysis,\n+    OptimizationFailure,\n+}\n+\n+impl OptimizationDiagnosticKind {\n+    pub fn describe(self) -> &'static str {\n+        match self {\n+            OptimizationRemark => \"remark\",\n+            OptimizationMissed => \"missed\",\n+            OptimizationAnalysis => \"analysis\",\n+            OptimizationFailure => \"failure\",\n+        }\n+    }\n+}\n+\n+pub struct OptimizationDiagnostic {\n+    pub kind: OptimizationDiagnosticKind,\n+    pub pass_name: *const c_char,\n+    pub function: ValueRef,\n+    pub debug_loc: DebugLocRef,\n+    pub message: TwineRef,\n+}\n+\n+impl OptimizationDiagnostic {\n+    unsafe fn unpack(kind: OptimizationDiagnosticKind, di: DiagnosticInfoRef)\n+            -> OptimizationDiagnostic {\n+\n+        let mut opt = OptimizationDiagnostic {\n+            kind: kind,\n+            pass_name: 0 as *const c_char,\n+            function: 0 as ValueRef,\n+            debug_loc: 0 as DebugLocRef,\n+            message: 0 as TwineRef,\n+        };\n+\n+        super::LLVMUnpackOptimizationDiagnostic(di,\n+            &mut opt.pass_name,\n+            &mut opt.function,\n+            &mut opt.debug_loc,\n+            &mut opt.message);\n+\n+        opt\n+    }\n+}\n+\n+pub enum Diagnostic {\n+    Optimization(OptimizationDiagnostic),\n+\n+    /// LLVM has other types that we do not wrap here.\n+    UnknownDiagnostic(DiagnosticInfoRef),\n+}\n+\n+impl Diagnostic {\n+    pub unsafe fn unpack(di: DiagnosticInfoRef) -> Diagnostic {\n+        let kind = super::LLVMGetDiagInfoKind(di);\n+\n+        match kind {\n+            super::DK_OptimizationRemark\n+                => Optimization(OptimizationDiagnostic::unpack(OptimizationRemark, di)),\n+\n+            super::DK_OptimizationRemarkMissed\n+                => Optimization(OptimizationDiagnostic::unpack(OptimizationMissed, di)),\n+\n+            super::DK_OptimizationRemarkAnalysis\n+                => Optimization(OptimizationDiagnostic::unpack(OptimizationAnalysis, di)),\n+\n+            super::DK_OptimizationFailure\n+                => Optimization(OptimizationDiagnostic::unpack(OptimizationFailure, di)),\n+\n+            _ => UnknownDiagnostic(di)\n+        }\n+    }\n+}"}, {"sha": "690b288043d6af856c489ee039373c6967a560b7", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 87, "deletions": 3, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a8d478db512803d25785a11c5b21634f8703b17f/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d478db512803d25785a11c5b21634f8703b17f/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=a8d478db512803d25785a11c5b21634f8703b17f", "patch": "@@ -28,14 +28,17 @@\n extern crate libc;\n \n use std::c_str::ToCStr;\n+use std::cell::RefCell;\n+use std::{raw, mem};\n use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n-use libc::{c_longlong, c_ulonglong};\n+use libc::{c_longlong, c_ulonglong, c_void};\n use debuginfo::{DIBuilderRef, DIDescriptor,\n                 DIFile, DILexicalBlock, DISubprogram, DIType,\n                 DIBasicType, DIDerivedType, DICompositeType,\n                 DIVariable, DIGlobalVariable, DIArray, DISubrange};\n \n pub mod archive_ro;\n+pub mod diagnostic;\n \n pub type Opcode = u32;\n pub type Bool = c_uint;\n@@ -79,6 +82,15 @@ pub enum Linkage {\n     CommonLinkage = 14,\n }\n \n+#[repr(C)]\n+#[deriving(Show)]\n+pub enum DiagnosticSeverity {\n+    Error,\n+    Warning,\n+    Remark,\n+    Note,\n+}\n+\n #[deriving(Clone)]\n pub enum Attribute {\n     ZExtAttribute = 1 << 0,\n@@ -358,6 +370,18 @@ pub enum CodeGenModel {\n     CodeModelLarge = 5,\n }\n \n+#[repr(C)]\n+pub enum DiagnosticKind {\n+    DK_InlineAsm = 0,\n+    DK_StackSize,\n+    DK_DebugMetadataVersion,\n+    DK_SampleProfile,\n+    DK_OptimizationRemark,\n+    DK_OptimizationRemarkMissed,\n+    DK_OptimizationRemarkAnalysis,\n+    DK_OptimizationFailure,\n+}\n+\n // Opaque pointer types\n pub enum Module_opaque {}\n pub type ModuleRef = *mut Module_opaque;\n@@ -393,6 +417,14 @@ pub enum TargetMachine_opaque {}\n pub type TargetMachineRef = *mut TargetMachine_opaque;\n pub enum Archive_opaque {}\n pub type ArchiveRef = *mut Archive_opaque;\n+pub enum Twine_opaque {}\n+pub type TwineRef = *mut Twine_opaque;\n+pub enum DiagnosticInfo_opaque {}\n+pub type DiagnosticInfoRef = *mut DiagnosticInfo_opaque;\n+pub enum DebugLoc_opaque {}\n+pub type DebugLocRef = *mut DebugLoc_opaque;\n+\n+pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n \n pub mod debuginfo {\n     use super::{ValueRef};\n@@ -1839,8 +1871,8 @@ extern {\n                                         -> ValueRef;\n \n     pub fn LLVMDICompositeTypeSetTypeArray(CompositeType: ValueRef, TypeArray: ValueRef);\n-    pub fn LLVMTypeToString(Type: TypeRef) -> *const c_char;\n-    pub fn LLVMValueToString(value_ref: ValueRef) -> *const c_char;\n+    pub fn LLVMWriteTypeToString(Type: TypeRef, s: RustStringRef);\n+    pub fn LLVMWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n \n     pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n \n@@ -1916,6 +1948,24 @@ extern {\n \n     pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n                                   data: *mut *const c_char) -> c_int;\n+\n+    pub fn LLVMWriteTwineToString(T: TwineRef, s: RustStringRef);\n+\n+    pub fn LLVMContextSetDiagnosticHandler(C: ContextRef,\n+                                           Handler: DiagnosticHandler,\n+                                           DiagnosticContext: *mut c_void);\n+\n+    pub fn LLVMUnpackOptimizationDiagnostic(DI: DiagnosticInfoRef,\n+                                            pass_name_out: *mut *const c_char,\n+                                            function_out: *mut ValueRef,\n+                                            debugloc_out: *mut DebugLocRef,\n+                                            message_out: *mut TwineRef);\n+\n+    pub fn LLVMWriteDiagnosticInfoToString(DI: DiagnosticInfoRef, s: RustStringRef);\n+    pub fn LLVMGetDiagInfoSeverity(DI: DiagnosticInfoRef) -> DiagnosticSeverity;\n+    pub fn LLVMGetDiagInfoKind(DI: DiagnosticInfoRef) -> DiagnosticKind;\n+\n+    pub fn LLVMWriteDebugLocToString(C: ContextRef, DL: DebugLocRef, s: RustStringRef);\n }\n \n pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n@@ -2046,6 +2096,40 @@ pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n     }\n }\n \n+pub enum RustString_opaque {}\n+pub type RustStringRef = *mut RustString_opaque;\n+type RustStringRepr = *mut RefCell<Vec<u8>>;\n+\n+/// Appending to a Rust string -- used by raw_rust_string_ostream.\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rust_llvm_string_write_impl(sr: RustStringRef,\n+                                                     ptr: *const c_char,\n+                                                     size: size_t) {\n+    let slice: &[u8] = mem::transmute(raw::Slice {\n+        data: ptr as *const u8,\n+        len: size as uint,\n+    });\n+\n+    let sr: RustStringRepr = mem::transmute(sr);\n+    (*sr).borrow_mut().push_all(slice);\n+}\n+\n+pub fn build_string(f: |RustStringRef|) -> Option<String> {\n+    let mut buf = RefCell::new(Vec::new());\n+    f(&mut buf as RustStringRepr as RustStringRef);\n+    String::from_utf8(buf.unwrap()).ok()\n+}\n+\n+pub unsafe fn twine_to_string(tr: TwineRef) -> String {\n+    build_string(|s| LLVMWriteTwineToString(tr, s))\n+        .expect(\"got a non-UTF8 Twine from LLVM\")\n+}\n+\n+pub unsafe fn debug_loc_to_string(c: ContextRef, tr: DebugLocRef) -> String {\n+    build_string(|s| LLVMWriteDebugLocToString(c, tr, s))\n+        .expect(\"got a non-UTF8 DebugLoc from LLVM\")\n+}\n+\n // FIXME #15460 - create a public function that actually calls our\n // static LLVM symbols. Otherwise the linker will just throw llvm\n // away.  We're just calling lots of stuff until we transitively get"}, {"sha": "7896ce2ba761a965e8c6c56d638166efa9e58083", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a8d478db512803d25785a11c5b21634f8703b17f/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a8d478db512803d25785a11c5b21634f8703b17f/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=a8d478db512803d25785a11c5b21634f8703b17f", "patch": "@@ -11,6 +11,8 @@\n #include \"rustllvm.h\"\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/ObjectFile.h\"\n+#include \"llvm/IR/DiagnosticInfo.h\"\n+#include \"llvm/IR/DiagnosticPrinter.h\"\n \n #if LLVM_VERSION_MINOR >= 5\n #include \"llvm/IR/CallSite.h\"\n@@ -645,22 +647,18 @@ extern \"C\" void LLVMDICompositeTypeSetTypeArray(\n #endif\n }\n \n-extern \"C\" char *LLVMTypeToString(LLVMTypeRef Type) {\n-    std::string s;\n-    llvm::raw_string_ostream os(s);\n+extern \"C\" void LLVMWriteTypeToString(LLVMTypeRef Type, RustStringRef str) {\n+    raw_rust_string_ostream os(str);\n     unwrap<llvm::Type>(Type)->print(os);\n-    return strdup(os.str().data());\n }\n \n-extern \"C\" char *LLVMValueToString(LLVMValueRef Value) {\n-    std::string s;\n-    llvm::raw_string_ostream os(s);\n+extern \"C\" void LLVMWriteValueToString(LLVMValueRef Value, RustStringRef str) {\n+    raw_rust_string_ostream os(str);\n     os << \"(\";\n     unwrap<llvm::Value>(Value)->getType()->print(os);\n     os << \":\";\n     unwrap<llvm::Value>(Value)->print(os);\n     os << \")\";\n-    return strdup(os.str().data());\n }\n \n #if LLVM_VERSION_MINOR >= 5\n@@ -827,3 +825,49 @@ extern \"C\" LLVMTypeRef\n LLVMRustArrayType(LLVMTypeRef ElementType, uint64_t ElementCount) {\n     return wrap(ArrayType::get(unwrap(ElementType), ElementCount));\n }\n+\n+DEFINE_SIMPLE_CONVERSION_FUNCTIONS(Twine, LLVMTwineRef)\n+DEFINE_SIMPLE_CONVERSION_FUNCTIONS(DebugLoc, LLVMDebugLocRef)\n+\n+extern \"C\" void\n+LLVMWriteTwineToString(LLVMTwineRef T, RustStringRef str) {\n+    raw_rust_string_ostream os(str);\n+    unwrap(T)->print(os);\n+}\n+\n+extern \"C\" void\n+LLVMUnpackOptimizationDiagnostic(\n+    LLVMDiagnosticInfoRef di,\n+    const char **pass_name_out,\n+    LLVMValueRef *function_out,\n+    LLVMDebugLocRef *debugloc_out,\n+    LLVMTwineRef *message_out)\n+{\n+    // Undefined to call this not on an optimization diagnostic!\n+    llvm::DiagnosticInfoOptimizationBase *opt\n+        = static_cast<llvm::DiagnosticInfoOptimizationBase*>(unwrap(di));\n+\n+    *pass_name_out = opt->getPassName();\n+    *function_out = wrap(&opt->getFunction());\n+    *debugloc_out = wrap(&opt->getDebugLoc());\n+    *message_out = wrap(&opt->getMsg());\n+}\n+\n+extern \"C\" void LLVMWriteDiagnosticInfoToString(LLVMDiagnosticInfoRef di, RustStringRef str) {\n+    raw_rust_string_ostream os(str);\n+    DiagnosticPrinterRawOStream dp(os);\n+    unwrap(di)->print(dp);\n+}\n+\n+extern \"C\" int LLVMGetDiagInfoKind(LLVMDiagnosticInfoRef di) {\n+    return unwrap(di)->getKind();\n+}\n+\n+extern \"C\" void LLVMWriteDebugLocToString(\n+    LLVMContextRef C,\n+    LLVMDebugLocRef dl,\n+    RustStringRef str)\n+{\n+    raw_rust_string_ostream os(str);\n+    unwrap(dl)->print(*unwrap(C), os);\n+}"}, {"sha": "54b0c2506c76b4bfb7953b1e392e67619b283f26", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a8d478db512803d25785a11c5b21634f8703b17f/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/a8d478db512803d25785a11c5b21634f8703b17f/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=a8d478db512803d25785a11c5b21634f8703b17f", "patch": "@@ -69,3 +69,33 @@\n #endif\n \n void LLVMRustSetLastError(const char*);\n+\n+typedef struct OpaqueRustString *RustStringRef;\n+typedef struct LLVMOpaqueTwine *LLVMTwineRef;\n+typedef struct LLVMOpaqueDebugLoc *LLVMDebugLocRef;\n+\n+extern \"C\" void\n+rust_llvm_string_write_impl(RustStringRef str, const char *ptr, size_t size);\n+\n+class raw_rust_string_ostream : public llvm::raw_ostream  {\n+    RustStringRef str;\n+    uint64_t pos;\n+\n+    void write_impl(const char *ptr, size_t size) override {\n+        rust_llvm_string_write_impl(str, ptr, size);\n+        pos += size;\n+    }\n+\n+    uint64_t current_pos() const override {\n+        return pos;\n+    }\n+\n+public:\n+    explicit raw_rust_string_ostream(RustStringRef str)\n+        : str(str), pos(0) { }\n+\n+    ~raw_rust_string_ostream() {\n+        // LLVM requires this.\n+        flush();\n+    }\n+};"}]}