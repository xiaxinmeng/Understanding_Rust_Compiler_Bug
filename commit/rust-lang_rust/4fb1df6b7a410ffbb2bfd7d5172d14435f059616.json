{"sha": "4fb1df6b7a410ffbb2bfd7d5172d14435f059616", "node_id": "C_kwDOAAsO6NoAKDRmYjFkZjZiN2E0MTBmZmJiMmJmZDdkNTE3MmQxNDQzNWYwNTk2MTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-03T21:40:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-03T21:40:09Z"}, "message": "Auto merge of #14961 - HKalbasi:mir-fix, r=HKalbasi\n\nFix drop scopes problems in mir\n\nFix false positives of `need-mut` emerged from #14955\n\nThere are still 5 `need-mut` false positives on self, all related to `izip!` macro hygenic issue. I will try to do something about that before monday release.", "tree": {"sha": "686b76b14676c81922a2cfe503c05fed22670ab8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/686b76b14676c81922a2cfe503c05fed22670ab8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fb1df6b7a410ffbb2bfd7d5172d14435f059616", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fb1df6b7a410ffbb2bfd7d5172d14435f059616", "html_url": "https://github.com/rust-lang/rust/commit/4fb1df6b7a410ffbb2bfd7d5172d14435f059616", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fb1df6b7a410ffbb2bfd7d5172d14435f059616/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5c56cd9a03c8cb032a9aa139cf8084b08d73dde", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5c56cd9a03c8cb032a9aa139cf8084b08d73dde", "html_url": "https://github.com/rust-lang/rust/commit/e5c56cd9a03c8cb032a9aa139cf8084b08d73dde"}, {"sha": "08f89193b53b3c6fe03d0ccd321d18bd518ccf24", "url": "https://api.github.com/repos/rust-lang/rust/commits/08f89193b53b3c6fe03d0ccd321d18bd518ccf24", "html_url": "https://github.com/rust-lang/rust/commit/08f89193b53b3c6fe03d0ccd321d18bd518ccf24"}], "stats": {"total": 261, "additions": 237, "deletions": 24}, "files": [{"sha": "ce14f6dbad536909f6997e639566906ef28449bc", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4fb1df6b7a410ffbb2bfd7d5172d14435f059616/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fb1df6b7a410ffbb2bfd7d5172d14435f059616/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=4fb1df6b7a410ffbb2bfd7d5172d14435f059616", "patch": "@@ -1896,7 +1896,14 @@ impl Evaluator<'_> {\n         let mir_body = self\n             .db\n             .monomorphized_mir_body(def, generic_args, self.trait_env.clone())\n-            .map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n+            .map_err(|e| {\n+                MirEvalError::InFunction(\n+                    Either::Left(imp),\n+                    Box::new(MirEvalError::MirLowerError(imp, e)),\n+                    span,\n+                    locals.body.owner,\n+                )\n+            })?;\n         let result = self.interpret_mir(&mir_body, arg_bytes.iter().cloned()).map_err(|e| {\n             MirEvalError::InFunction(Either::Left(imp), Box::new(e), span, locals.body.owner)\n         })?;"}, {"sha": "dabc76ba15bf4701f8ac60147088f8df5246790a", "filename": "crates/hir-ty/src/mir/eval/tests.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4fb1df6b7a410ffbb2bfd7d5172d14435f059616/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fb1df6b7a410ffbb2bfd7d5172d14435f059616/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs?ref=4fb1df6b7a410ffbb2bfd7d5172d14435f059616", "patch": "@@ -1,5 +1,6 @@\n use base_db::{fixture::WithFixture, FileId};\n use hir_def::db::DefDatabase;\n+use syntax::{TextRange, TextSize};\n \n use crate::{db::HirDatabase, test_db::TestDB, Interner, Substitution};\n \n@@ -45,7 +46,21 @@ fn check_pass_and_stdio(ra_fixture: &str, expected_stdout: &str, expected_stderr\n     match x {\n         Err(e) => {\n             let mut err = String::new();\n-            let span_formatter = |file, range| format!(\"{:?} {:?}\", file, range);\n+            let line_index = |size: TextSize| {\n+                let mut size = u32::from(size) as usize;\n+                let mut lines = ra_fixture.lines().enumerate();\n+                while let Some((i, l)) = lines.next() {\n+                    if let Some(x) = size.checked_sub(l.len()) {\n+                        size = x;\n+                    } else {\n+                        return (i, size);\n+                    }\n+                }\n+                (usize::MAX, size)\n+            };\n+            let span_formatter = |file, range: TextRange| {\n+                format!(\"{:?} {:?}..{:?}\", file, line_index(range.start()), line_index(range.end()))\n+            };\n             e.pretty_print(&mut err, &db, span_formatter).unwrap();\n             panic!(\"Error in interpreting: {err}\");\n         }\n@@ -115,6 +130,58 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn drop_if_let() {\n+    check_pass(\n+        r#\"\n+//- minicore: drop, add, option, cell, builtin_impls\n+\n+use core::cell::Cell;\n+\n+struct X<'a>(&'a Cell<i32>);\n+impl<'a> Drop for X<'a> {\n+    fn drop(&mut self) {\n+        self.0.set(self.0.get() + 1)\n+    }\n+}\n+\n+fn should_not_reach() {\n+    _ // FIXME: replace this function with panic when that works\n+}\n+\n+#[test]\n+fn main() {\n+    let s = Cell::new(0);\n+    let x = Some(X(&s));\n+    if let Some(y) = x {\n+        if s.get() != 0 {\n+            should_not_reach();\n+        }\n+        if s.get() != 0 {\n+            should_not_reach();\n+        }\n+    } else {\n+        should_not_reach();\n+    }\n+    if s.get() != 1 {\n+        should_not_reach();\n+    }\n+    let x = Some(X(&s));\n+    if let None = x {\n+        should_not_reach();\n+    } else {\n+        if s.get() != 1 {\n+            should_not_reach();\n+        }\n+    }\n+    if s.get() != 1 {\n+        should_not_reach();\n+    }\n+}\n+    \"#,\n+    );\n+}\n+\n #[test]\n fn drop_in_place() {\n     check_pass("}, {"sha": "aad1a82f2981cbf5081488e3de5ccc36ab863135", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 93, "deletions": 21, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4fb1df6b7a410ffbb2bfd7d5172d14435f059616/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fb1df6b7a410ffbb2bfd7d5172d14435f059616/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=4fb1df6b7a410ffbb2bfd7d5172d14435f059616", "patch": "@@ -48,6 +48,7 @@ struct LoopBlocks {\n     /// `None` for loops that are not terminating\n     end: Option<BasicBlockId>,\n     place: Place,\n+    drop_scope_index: usize,\n }\n \n #[derive(Debug, Clone, Default)]\n@@ -101,6 +102,35 @@ pub enum MirLowerError {\n     GenericArgNotProvided(TypeOrConstParamId, Substitution),\n }\n \n+/// A token to ensuring that each drop scope is popped at most once, thanks to the compiler that checks moves.\n+struct DropScopeToken;\n+impl DropScopeToken {\n+    fn pop_and_drop(self, ctx: &mut MirLowerCtx<'_>, current: BasicBlockId) -> BasicBlockId {\n+        std::mem::forget(self);\n+        ctx.pop_drop_scope_internal(current)\n+    }\n+\n+    /// It is useful when we want a drop scope is syntaxically closed, but we don't want to execute any drop\n+    /// code. Either when the control flow is diverging (so drop code doesn't reached) or when drop is handled\n+    /// for us (for example a block that ended with a return statement. Return will drop everything, so the block shouldn't\n+    /// do anything)\n+    fn pop_assume_dropped(self, ctx: &mut MirLowerCtx<'_>) {\n+        std::mem::forget(self);\n+        ctx.pop_drop_scope_assume_dropped_internal();\n+    }\n+}\n+\n+// Uncomment this to make `DropScopeToken` a drop bomb. Unfortunately we can't do this in release, since\n+// in cases that mir lowering fails, we don't handle (and don't need to handle) drop scopes so it will be\n+// actually reached. `pop_drop_scope_assert_finished` will also detect this case, but doesn't show useful\n+// stack trace.\n+//\n+// impl Drop for DropScopeToken {\n+//     fn drop(&mut self) {\n+//         never!(\"Drop scope doesn't popped\");\n+//     }\n+// }\n+\n impl MirLowerError {\n     pub fn pretty_print(\n         &self,\n@@ -506,7 +536,6 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     self.lower_loop(current, place.clone(), Some(*label), expr_id.into(), |this, begin| {\n                         if let Some(current) = this.lower_block_to_place(statements, begin, *tail, place, expr_id.into())? {\n                             let end = this.current_loop_end()?;\n-                            let current = this.pop_drop_scope(current);\n                             this.set_goto(current, end, expr_id.into());\n                         }\n                         Ok(())\n@@ -516,30 +545,39 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 }\n             }\n             Expr::Loop { body, label } => self.lower_loop(current, place, *label, expr_id.into(), |this, begin| {\n-                if let Some((_, current)) = this.lower_expr_as_place(begin, *body, true)? {\n-                    let current = this.pop_drop_scope(current);\n+                let scope = this.push_drop_scope();\n+                if let Some((_, mut current)) = this.lower_expr_as_place(begin, *body, true)? {\n+                    current = scope.pop_and_drop(this, current);\n                     this.set_goto(current, begin, expr_id.into());\n+                } else {\n+                    scope.pop_assume_dropped(this);\n                 }\n                 Ok(())\n             }),\n             Expr::While { condition, body, label } => {\n                 self.lower_loop(current, place, *label, expr_id.into(),|this, begin| {\n+                    let scope = this.push_drop_scope();\n                     let Some((discr, to_switch)) = this.lower_expr_to_some_operand(*condition, begin)? else {\n                         return Ok(());\n                     };\n-                    let end = this.current_loop_end()?;\n+                    let fail_cond = this.new_basic_block();\n                     let after_cond = this.new_basic_block();\n                     this.set_terminator(\n                         to_switch,\n                         TerminatorKind::SwitchInt {\n                             discr,\n-                            targets: SwitchTargets::static_if(1, after_cond, end),\n+                            targets: SwitchTargets::static_if(1, after_cond, fail_cond),\n                         },\n                         expr_id.into(),\n                     );\n+                    let fail_cond = this.drop_until_scope(this.drop_scopes.len() - 1, fail_cond);\n+                    let end = this.current_loop_end()?;\n+                    this.set_goto(fail_cond, end, expr_id.into());\n                     if let Some((_, block)) = this.lower_expr_as_place(after_cond, *body, true)? {\n-                        let block = this.pop_drop_scope(block);\n+                        let block = scope.pop_and_drop(this, block);\n                         this.set_goto(block, begin, expr_id.into());\n+                    } else {\n+                        scope.pop_assume_dropped(this);\n                     }\n                     Ok(())\n                 })\n@@ -637,7 +675,9 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     Some(l) => self.labeled_loop_blocks.get(l).ok_or(MirLowerError::UnresolvedLabel)?,\n                     None => self.current_loop_blocks.as_ref().ok_or(MirLowerError::ContinueWithoutLoop)?,\n                 };\n-                self.set_goto(current, loop_data.begin, expr_id.into());\n+                let begin = loop_data.begin;\n+                current = self.drop_until_scope(loop_data.drop_scope_index, current);\n+                self.set_goto(current, begin, expr_id.into());\n                 Ok(None)\n             },\n             &Expr::Break { expr, label } => {\n@@ -651,10 +691,16 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     };\n                     current = c;\n                 }\n-                let end = match label {\n-                    Some(l) => self.labeled_loop_blocks.get(&l).ok_or(MirLowerError::UnresolvedLabel)?.end.expect(\"We always generate end for labeled loops\"),\n-                    None => self.current_loop_end()?,\n+                let (end, drop_scope) = match label {\n+                    Some(l) => {\n+                        let loop_blocks = self.labeled_loop_blocks.get(&l).ok_or(MirLowerError::UnresolvedLabel)?;\n+                        (loop_blocks.end.expect(\"We always generate end for labeled loops\"), loop_blocks.drop_scope_index)\n+                    },\n+                    None => {\n+                        (self.current_loop_end()?, self.current_loop_blocks.as_ref().unwrap().drop_scope_index)\n+                    },\n                 };\n+                current = self.drop_until_scope(drop_scope, current);\n                 self.set_goto(current, end, expr_id.into());\n                 Ok(None)\n             }\n@@ -1378,7 +1424,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         let begin = self.new_basic_block();\n         let prev = mem::replace(\n             &mut self.current_loop_blocks,\n-            Some(LoopBlocks { begin, end: None, place }),\n+            Some(LoopBlocks { begin, end: None, place, drop_scope_index: self.drop_scopes.len() }),\n         );\n         let prev_label = if let Some(label) = label {\n             // We should generate the end now, to make sure that it wouldn't change later. It is\n@@ -1391,7 +1437,6 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             None\n         };\n         self.set_goto(prev_block, begin, span);\n-        self.push_drop_scope();\n         f(self, begin)?;\n         let my = mem::replace(&mut self.current_loop_blocks, prev).ok_or(\n             MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\".to_string()),\n@@ -1489,6 +1534,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         place: Place,\n         span: MirSpan,\n     ) -> Result<Option<Idx<BasicBlock>>> {\n+        let scope = self.push_drop_scope();\n         for statement in statements.iter() {\n             match statement {\n                 hir_def::hir::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n@@ -1497,6 +1543,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         let Some((init_place, c)) =\n                             self.lower_expr_as_place(current, *expr_id, true)?\n                         else {\n+                            scope.pop_assume_dropped(self);\n                             return Ok(None);\n                         };\n                         current = c;\n@@ -1528,18 +1575,25 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     }\n                 }\n                 hir_def::hir::Statement::Expr { expr, has_semi: _ } => {\n-                    self.push_drop_scope();\n+                    let scope2 = self.push_drop_scope();\n                     let Some((_, c)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                        scope2.pop_assume_dropped(self);\n+                        scope.pop_assume_dropped(self);\n                         return Ok(None);\n                     };\n-                    current = self.pop_drop_scope(c);\n+                    current = scope2.pop_and_drop(self, c);\n                 }\n             }\n         }\n-        match tail {\n-            Some(tail) => self.lower_expr_to_place(tail, place, current),\n-            None => Ok(Some(current)),\n+        if let Some(tail) = tail {\n+            let Some(c) = self.lower_expr_to_place(tail, place, current)? else {\n+                scope.pop_assume_dropped(self);\n+                return Ok(None);\n+            };\n+            current = c;\n         }\n+        current = scope.pop_and_drop(self, current);\n+        Ok(Some(current))\n     }\n \n     fn lower_params_and_bindings(\n@@ -1625,16 +1679,34 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         current\n     }\n \n-    fn push_drop_scope(&mut self) {\n+    fn push_drop_scope(&mut self) -> DropScopeToken {\n         self.drop_scopes.push(DropScope::default());\n+        DropScopeToken\n+    }\n+\n+    /// Don't call directly\n+    fn pop_drop_scope_assume_dropped_internal(&mut self) {\n+        self.drop_scopes.pop();\n     }\n \n-    fn pop_drop_scope(&mut self, mut current: BasicBlockId) -> BasicBlockId {\n+    /// Don't call directly\n+    fn pop_drop_scope_internal(&mut self, mut current: BasicBlockId) -> BasicBlockId {\n         let scope = self.drop_scopes.pop().unwrap();\n         self.emit_drop_and_storage_dead_for_scope(&scope, &mut current);\n         current\n     }\n \n+    fn pop_drop_scope_assert_finished(\n+        &mut self,\n+        mut current: BasicBlockId,\n+    ) -> Result<BasicBlockId> {\n+        current = self.pop_drop_scope_internal(current);\n+        if !self.drop_scopes.is_empty() {\n+            implementation_error!(\"Mismatched count between drop scope push and pops\");\n+        }\n+        Ok(current)\n+    }\n+\n     fn emit_drop_and_storage_dead_for_scope(\n         &mut self,\n         scope: &DropScope,\n@@ -1728,7 +1800,7 @@ pub fn mir_body_for_closure_query(\n         |_| true,\n     )?;\n     if let Some(current) = ctx.lower_expr_to_place(*root, return_slot().into(), current)? {\n-        let current = ctx.pop_drop_scope(current);\n+        let current = ctx.pop_drop_scope_assert_finished(current)?;\n         ctx.set_terminator(current, TerminatorKind::Return, (*root).into());\n     }\n     let mut upvar_map: FxHashMap<LocalId, Vec<(&CapturedItem, usize)>> = FxHashMap::default();\n@@ -1863,7 +1935,7 @@ pub fn lower_to_mir(\n         ctx.lower_params_and_bindings([].into_iter(), binding_picker)?\n     };\n     if let Some(current) = ctx.lower_expr_to_place(root_expr, return_slot().into(), current)? {\n-        let current = ctx.pop_drop_scope(current);\n+        let current = ctx.pop_drop_scope_assert_finished(current)?;\n         ctx.set_terminator(current, TerminatorKind::Return, root_expr.into());\n     }\n     Ok(ctx.result)"}, {"sha": "743ef0c6f5290aeb072b3f7bd66cc290898d99b6", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4fb1df6b7a410ffbb2bfd7d5172d14435f059616/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fb1df6b7a410ffbb2bfd7d5172d14435f059616/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=4fb1df6b7a410ffbb2bfd7d5172d14435f059616", "patch": "@@ -512,6 +512,38 @@ fn main() {\n         f(x);\n     }\n }\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn check(_: i32) -> bool {\n+    false\n+}\n+fn main() {\n+    loop {\n+        let x = 1;\n+        if check(x) {\n+            break;\n+        }\n+        let y = (1, 2);\n+        if check(y.1) {\n+            return;\n+        }\n+        let z = (1, 2);\n+        match z {\n+            (k @ 5, ref mut t) if { continue; } => {\n+                  //^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `z`\n+                *t = 5;\n+            }\n+            _ => {\n+                let y = (1, 2);\n+                if check(y.1) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n \"#,\n         );\n         check_diagnostics(\n@@ -592,7 +624,7 @@ fn f((x, y): (i32, i32)) {\n     fn for_loop() {\n         check_diagnostics(\n             r#\"\n-//- minicore: iterators\n+//- minicore: iterators, copy\n fn f(x: [(i32, u8); 10]) {\n     for (a, mut b) in x {\n           //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n@@ -604,6 +636,28 @@ fn f(x: [(i32, u8); 10]) {\n         );\n     }\n \n+    #[test]\n+    fn while_let() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: iterators, copy\n+fn f(x: [(i32, u8); 10]) {\n+    let mut it = x.into_iter();\n+    while let Some((a, mut b)) = it.next() {\n+                     //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        while let Some((c, mut d)) = it.next() {\n+                         //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            a = 2;\n+          //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `a`\n+            c = 2;\n+          //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `c`\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn index() {\n         check_diagnostics("}, {"sha": "3ca31cce5649e803a94703592cdf945e37849b4d", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4fb1df6b7a410ffbb2bfd7d5172d14435f059616/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fb1df6b7a410ffbb2bfd7d5172d14435f059616/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=4fb1df6b7a410ffbb2bfd7d5172d14435f059616", "patch": "@@ -726,6 +726,19 @@ pub mod ops {\n     pub trait AddAssign<Rhs = Self> {\n         fn add_assign(&mut self, rhs: Rhs);\n     }\n+\n+    // region:builtin_impls\n+    macro_rules! add_impl {\n+        ($($t:ty)*) => ($(\n+            impl const Add for $t {\n+                type Output = $t;\n+                fn add(self, other: $t) -> $t { self + other }\n+            }\n+        )*)\n+    }\n+\n+    add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+    // endregion:builtin_impls\n     // endregion:add\n \n     // region:generator"}]}