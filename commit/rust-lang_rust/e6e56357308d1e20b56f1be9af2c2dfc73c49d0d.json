{"sha": "e6e56357308d1e20b56f1be9af2c2dfc73c49d0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZTU2MzU3MzA4ZDFlMjBiNTZmMWJlOWFmMmMyZGZjNzNjNDlkMGQ=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-11-14T14:00:57Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-11-15T08:22:00Z"}, "message": "ty: return impl Iterator from Predicate::walk_tys", "tree": {"sha": "254906948296ce847e1e1d5e6116d7dc69065310", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/254906948296ce847e1e1d5e6116d7dc69065310"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6e56357308d1e20b56f1be9af2c2dfc73c49d0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e56357308d1e20b56f1be9af2c2dfc73c49d0d", "html_url": "https://github.com/rust-lang/rust/commit/e6e56357308d1e20b56f1be9af2c2dfc73c49d0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6e56357308d1e20b56f1be9af2c2dfc73c49d0d/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "126a0e2aadcd2c4cbe0b67f9c192047d6f6ec9e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/126a0e2aadcd2c4cbe0b67f9c192047d6f6ec9e6", "html_url": "https://github.com/rust-lang/rust/commit/126a0e2aadcd2c4cbe0b67f9c192047d6f6ec9e6"}], "stats": {"total": 78, "additions": 58, "deletions": 20}, "files": [{"sha": "c801cb99a1e2c944dd5fa51eb7732f5efa312d65", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 58, "deletions": 20, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e6e56357308d1e20b56f1be9af2c2dfc73c49d0d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e56357308d1e20b56f1be9af2c2dfc73c49d0d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e6e56357308d1e20b56f1be9af2c2dfc73c49d0d", "patch": "@@ -49,7 +49,6 @@ use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n use rustc_data_structures::sync::{self, Lrc, ParallelIterator, par_iter};\n use std::slice;\n-use std::vec::IntoIter;\n use std::{mem, ptr};\n use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n use syntax::attr;\n@@ -1343,49 +1342,88 @@ impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     }\n }\n \n+// A custom iterator used by Predicate::walk_tys.\n+enum WalkTysIter<'tcx, I, J, K>\n+    where I: Iterator<Item = Ty<'tcx>>,\n+          J: Iterator<Item = Ty<'tcx>>,\n+          K: Iterator<Item = Ty<'tcx>>\n+{\n+    None,\n+    One(Ty<'tcx>),\n+    Two(Ty<'tcx>, Ty<'tcx>),\n+    Types(I),\n+    InputTypes(J),\n+    ProjectionTypes(K)\n+}\n+\n+impl<'tcx, I, J, K> Iterator for WalkTysIter<'tcx, I, J, K>\n+    where I: Iterator<Item = Ty<'tcx>>,\n+          J: Iterator<Item = Ty<'tcx>>,\n+          K: Iterator<Item = Ty<'tcx>>\n+{\n+    type Item = Ty<'tcx>;\n+\n+    fn next(&mut self) -> Option<Ty<'tcx>> {\n+        match *self {\n+            WalkTysIter::None => None,\n+            WalkTysIter::One(item) => {\n+                *self = WalkTysIter::None;\n+                Some(item)\n+            },\n+            WalkTysIter::Two(item1, item2) => {\n+                *self = WalkTysIter::One(item2);\n+                Some(item1)\n+            },\n+            WalkTysIter::Types(ref mut iter) => {\n+                iter.next()\n+            },\n+            WalkTysIter::InputTypes(ref mut iter) => {\n+                iter.next()\n+            },\n+            WalkTysIter::ProjectionTypes(ref mut iter) => {\n+                iter.next()\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> Predicate<'tcx> {\n     /// Iterates over the types in this predicate. Note that in all\n     /// cases this is skipping over a binder, so late-bound regions\n     /// with depth 0 are bound by the predicate.\n-    pub fn walk_tys(&self) -> IntoIter<Ty<'tcx>> {\n-        let vec: Vec<_> = match *self {\n+    pub fn walk_tys(&'a self) -> impl Iterator<Item = Ty<'tcx>> + 'a {\n+        match *self {\n             ty::Predicate::Trait(ref data) => {\n-                data.skip_binder().input_types().collect()\n+                WalkTysIter::InputTypes(data.skip_binder().input_types())\n             }\n             ty::Predicate::Subtype(binder) => {\n                 let SubtypePredicate { a, b, a_is_expected: _ } = binder.skip_binder();\n-                vec![a, b]\n+                WalkTysIter::Two(a, b)\n             }\n             ty::Predicate::TypeOutlives(binder) => {\n-                vec![binder.skip_binder().0]\n+                WalkTysIter::One(binder.skip_binder().0)\n             }\n             ty::Predicate::RegionOutlives(..) => {\n-                vec![]\n+                WalkTysIter::None\n             }\n             ty::Predicate::Projection(ref data) => {\n                 let inner = data.skip_binder();\n-                inner.projection_ty.substs.types().chain(Some(inner.ty)).collect()\n+                WalkTysIter::ProjectionTypes(\n+                    inner.projection_ty.substs.types().chain(Some(inner.ty)))\n             }\n             ty::Predicate::WellFormed(data) => {\n-                vec![data]\n+                WalkTysIter::One(data)\n             }\n             ty::Predicate::ObjectSafe(_trait_def_id) => {\n-                vec![]\n+                WalkTysIter::None\n             }\n             ty::Predicate::ClosureKind(_closure_def_id, closure_substs, _kind) => {\n-                closure_substs.substs.types().collect()\n+                WalkTysIter::Types(closure_substs.substs.types())\n             }\n             ty::Predicate::ConstEvaluatable(_, substs) => {\n-                substs.types().collect()\n+                WalkTysIter::Types(substs.types())\n             }\n-        };\n-\n-        // FIXME: The only reason to collect into a vector here is that I was\n-        // too lazy to make the full (somewhat complicated) iterator\n-        // type that would be needed here. But I wanted this fn to\n-        // return an iterator conceptually, rather than a `Vec`, so as\n-        // to be closer to `Ty::walk`.\n-        vec.into_iter()\n+        }\n     }\n \n     pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {"}]}