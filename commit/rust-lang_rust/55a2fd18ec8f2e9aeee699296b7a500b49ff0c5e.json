{"sha": "55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1YTJmZDE4ZWM4ZjJlOWFlZWU2OTkyOTZiN2E1MDBiNDlmZjBjNWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-19T20:50:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-19T22:07:46Z"}, "message": "implement capture clauses (move, in particular) and integrate\nthem into type state and so forth", "tree": {"sha": "bbbe674e6f78eff5581363045d87f8ec856a534a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbbe674e6f78eff5581363045d87f8ec856a534a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "html_url": "https://github.com/rust-lang/rust/commit/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41ae146057431d99d5ab5c87d385dbf787a10ea2", "url": "https://api.github.com/repos/rust-lang/rust/commits/41ae146057431d99d5ab5c87d385dbf787a10ea2", "html_url": "https://github.com/rust-lang/rust/commit/41ae146057431d99d5ab5c87d385dbf787a10ea2"}], "stats": {"total": 358, "additions": 305, "deletions": 53}, "files": [{"sha": "0dd1956ff418e386bc72834f60fbb33d35e94ba9", "filename": "src/comp/middle/capture.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcapture.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -0,0 +1,132 @@\n+import syntax::{ast, ast_util};\n+import std::map;\n+\n+export capture_mode;\n+export capture_var;\n+export capture_map;\n+export check_capture_clause;\n+export compute_capture_vars;\n+export cap_copy;\n+export cap_move;\n+export cap_drop;\n+export cap_ref;\n+\n+tag capture_mode {\n+    cap_copy; //< Copy the value into the closure.\n+    cap_move; //< Move the value into the closure.\n+    cap_drop; //< Drop value after creating closure.\n+    cap_ref;  //< Reference directly from parent stack frame (block fn).\n+}\n+\n+type capture_var = {\n+    def: ast::def,     //< The variable being accessed free.\n+    mode: capture_mode //< How is the variable being accessed.\n+};\n+\n+type capture_map = map::hashmap<ast::def_id, capture_var>;\n+\n+// checks the capture clause for a fn_expr() and issues warnings or\n+// errors for any irregularities which we identify.\n+fn check_capture_clause(tcx: ty::ctxt,\n+                        fn_expr_id: ast::node_id,\n+                        fn_proto: ast::proto,\n+                        cap_clause: ast::capture_clause) {\n+    let freevars = freevars::get_freevars(tcx, fn_expr_id);\n+    let seen_defs = map::new_int_hash();\n+\n+    let check_capture_item = lambda(&&cap_item: @ast::capture_item) {\n+        let cap_def = tcx.def_map.get(cap_item.id);\n+        if !vec::any(*freevars, {|fv| fv.def == cap_def}) {\n+            tcx.sess.span_warn(\n+                cap_item.span,\n+                #fmt(\"Captured variable '%s' not used in closure\",\n+                     cap_item.name));\n+        }\n+\n+        let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n+        if !seen_defs.insert(cap_def_id, ()) {\n+            tcx.sess.span_err(\n+                cap_item.span,\n+                #fmt(\"Variable '%s' captured more than once\",\n+                     cap_item.name));\n+        }\n+    };\n+\n+    let check_not_upvar = lambda(&&cap_item: @ast::capture_item) {\n+        alt tcx.def_map.get(cap_item.id) {\n+          ast::def_upvar(_, _, _) {\n+            tcx.sess.span_err(\n+                cap_item.span,\n+                #fmt(\"Upvars (like '%s') cannot be moved into a closure\",\n+                     cap_item.name));\n+          }\n+          _ {}\n+        }\n+    };\n+\n+    let check_block_captures = lambda(v: [@ast::capture_item]) {\n+        if check vec::is_not_empty(v) {\n+            let cap_item0 = vec::head(v);\n+            tcx.sess.span_err(\n+                cap_item0.span,\n+                \"Cannot capture values explicitly with a block closure\");\n+        }\n+    };\n+\n+    alt fn_proto {\n+      ast::proto_block. {\n+        check_block_captures(cap_clause.copies);\n+        check_block_captures(cap_clause.moves);\n+      }\n+      ast::proto_bare. | ast::proto_shared(_) | ast::proto_send. {\n+        vec::iter(cap_clause.copies, check_capture_item);\n+        vec::iter(cap_clause.moves, check_capture_item);\n+        vec::iter(cap_clause.moves, check_not_upvar);\n+      }\n+    }\n+}\n+\n+fn compute_capture_vars(tcx: ty::ctxt,\n+                        fn_expr_id: ast::node_id,\n+                        fn_proto: ast::proto,\n+                        cap_clause: ast::capture_clause) -> [capture_var] {\n+    let freevars = freevars::get_freevars(tcx, fn_expr_id);\n+    let cap_map = map::new_int_hash();\n+\n+    vec::iter(cap_clause.copies) { |cap_item|\n+        let cap_def = tcx.def_map.get(cap_item.id);\n+        let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n+        if vec::any(*freevars, {|fv| fv.def == cap_def}) {\n+            cap_map.insert(cap_def_id, { def:cap_def, mode:cap_copy });\n+        }\n+    }\n+\n+    vec::iter(cap_clause.moves) { |cap_item|\n+        let cap_def = tcx.def_map.get(cap_item.id);\n+        let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n+        if vec::any(*freevars, {|fv| fv.def == cap_def}) {\n+            cap_map.insert(cap_def_id, { def:cap_def, mode:cap_move });\n+        } else {\n+            cap_map.insert(cap_def_id, { def:cap_def, mode:cap_drop });\n+        }\n+    }\n+\n+    let implicit_mode = alt fn_proto {\n+      ast::proto_block. { cap_ref }\n+      ast::proto_bare. | ast::proto_shared(_) | ast::proto_send. { cap_copy }\n+    };\n+\n+    vec::iter(*freevars) { |fvar|\n+        let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n+        alt cap_map.find(fvar_def_id) {\n+          option::some(_) { /* was explicitly named, do nothing */ }\n+          option::none. {\n+            cap_map.insert(fvar_def_id, {def:fvar.def, mode:implicit_mode});\n+          }\n+        }\n+    }\n+\n+    let result = [];\n+    cap_map.values { |cap_var| result += [cap_var]; }\n+    ret result;\n+}"}, {"sha": "aa72cb98ad3e6cb43961ab00152622c95347bc8d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -2566,7 +2566,11 @@ type generic_info =\n      static_tis: [option::t<@tydesc_info>],\n      tydescs: [ValueRef]};\n \n-tag lval_kind { temporary; owned; owned_imm; }\n+tag lval_kind {\n+    temporary; //< Temporary value passed by value if of immediate type\n+    owned;     //< Non-temporary value passed by pointer\n+    owned_imm; //< Non-temporary value passed by value\n+}\n type local_var_result = {val: ValueRef, kind: lval_kind};\n type lval_result = {bcx: @block_ctxt, val: ValueRef, kind: lval_kind};\n tag callee_env { obj_env(ValueRef); null_env; is_closure; }\n@@ -3550,12 +3554,13 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         assert op != ast::deref; // lvals are handled above\n         ret trans_unary(bcx, op, x, e.id, dest);\n       }\n-      // NDM captures\n       ast::expr_fn(f, cap_clause) {\n-        ret trans_closure::trans_expr_fn(bcx, f, e.span, e.id, dest);\n+        ret trans_closure::trans_expr_fn(\n+            bcx, f, e.span, e.id, *cap_clause, dest);\n       }\n       ast::expr_bind(f, args) {\n-        ret trans_closure::trans_bind(bcx, f, args, e.id, dest);\n+        ret trans_closure::trans_bind(\n+            bcx, f, args, e.id, dest);\n       }\n       ast::expr_copy(a) {\n         if !expr_is_lval(bcx, a) {"}, {"sha": "c61c7a4ff930e57ea97a93676a080245137d9ea7", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 96, "deletions": 46, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -43,8 +43,10 @@ import trans::{\n //   };\n // };\n //\n-// NB: this is defined in the code in T_closure_ptr and\n-// closure_ty_to_tuple_ty (below).\n+// NB: this struct is defined in the code in trans_common::T_closure()\n+// and mk_closure_ty() below.  The former defines the LLVM version and\n+// the latter the Rust equivalent.  It occurs to me that these could\n+// perhaps be unified, but currently they are not.\n //\n // Note that the closure carries a type descriptor that describes\n // itself.  Trippy.  This is needed because the precise types of the\n@@ -64,8 +66,17 @@ import trans::{\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n tag environment_value {\n+    // Evaluate expr and store result in env (used for bind).\n     env_expr(@ast::expr);\n-    env_direct(ValueRef, ty::t, bool);\n+\n+    // Copy the value from this llvm ValueRef into the environment.\n+    env_copy(ValueRef, ty::t, lval_kind);\n+\n+    // Move the value from this llvm ValueRef into the environment.\n+    env_move(ValueRef, ty::t, lval_kind);\n+\n+    // Access by reference (used for blocks).\n+    env_ref(ValueRef, ty::t, lval_kind);\n }\n \n // Given a closure ty, emits a corresponding tuple ty\n@@ -143,8 +154,10 @@ fn store_environment(\n     let bound_tys = [];\n     for bv in bound_values {\n         bound_tys += [alt bv {\n-          env_direct(_, t, _) { t }\n-          env_expr(e) { ty::expr_ty(tcx, e) }\n+            env_copy(_, t, _) { t }\n+            env_move(_, t, _) { t }\n+            env_ref(_, t, _) { t }\n+            env_expr(e) { ty::expr_ty(tcx, e) }\n         }];\n     }\n     let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n@@ -239,17 +252,29 @@ fn store_environment(\n             add_clean_temp_mem(bcx, bound.val, bound_tys[i]);\n             temp_cleanups += [bound.val];\n           }\n-          env_direct(val, ty, is_mem) {\n-            alt ck {\n-              ty::closure_shared. | ty::closure_send. {\n-                let val1 = is_mem ? load_if_immediate(bcx, val, ty) : val;\n-                bcx = trans::copy_val(bcx, INIT, bound.val, val1, ty);\n-              }\n-              ty::closure_block. {\n-                let addr = is_mem ? val : do_spill_noroot(bcx, val);\n-                Store(bcx, addr, bound.val);\n-              }\n-            }\n+          env_copy(val, ty, owned.) {\n+            let val1 = load_if_immediate(bcx, val, ty);\n+            bcx = trans::copy_val(bcx, INIT, bound.val, val1, ty);\n+          }\n+          env_copy(val, ty, owned_imm.) {\n+            bcx = trans::copy_val(bcx, INIT, bound.val, val, ty);\n+          }\n+          env_copy(_, _, temporary.) {\n+            fail \"Cannot capture temporary upvar\";\n+          }\n+          env_move(val, ty, kind) {\n+            let src = {bcx:bcx, val:val, kind:kind};\n+            bcx = move_val(bcx, INIT, bound.val, src, ty);\n+          }\n+          env_ref(val, ty, owned.) {\n+            Store(bcx, val, bound.val);\n+          }\n+          env_ref(val, ty, owned_imm.) {\n+            let addr = do_spill_noroot(bcx, val);\n+            Store(bcx, addr, bound.val);\n+          }\n+          env_ref(_, _, temporary.) {\n+            fail \"Cannot capture temporary upvar\";\n           }\n         }\n     }\n@@ -260,25 +285,38 @@ fn store_environment(\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n-fn build_closure(cx: @block_ctxt,\n-                 upvars: freevar_info,\n+fn build_closure(bcx0: @block_ctxt,\n+                 cap_vars: [capture::capture_var],\n                  ck: ty::closure_kind)\n     -> closure_result {\n     // If we need to, package up the iterator body to call\n     let env_vals = [];\n-    let tcx = bcx_tcx(cx);\n-    // Package up the upvars\n-    vec::iter(*upvars) { |upvar|\n-        let lv = trans_local_var(cx, upvar.def);\n-        let nid = ast_util::def_id_of_def(upvar.def).node;\n+    let bcx = bcx0;\n+    let tcx = bcx_tcx(bcx);\n+\n+    // Package up the captured upvars\n+    vec::iter(cap_vars) { |cap_var|\n+        let lv = trans_local_var(bcx, cap_var.def);\n+        let nid = ast_util::def_id_of_def(cap_var.def).node;\n         let ty = ty::node_id_to_monotype(tcx, nid);\n-        alt ck {\n-          ty::closure_block. { ty = ty::mk_mut_ptr(tcx, ty); }\n-          ty::closure_send. | ty::closure_shared. {}\n+        alt cap_var.mode {\n+          capture::cap_ref. {\n+            assert ck == ty::closure_block;\n+            ty = ty::mk_mut_ptr(tcx, ty);\n+            env_vals += [env_ref(lv.val, ty, lv.kind)];\n+          }\n+          capture::cap_copy. {\n+            env_vals += [env_copy(lv.val, ty, lv.kind)];\n+          }\n+          capture::cap_move. {\n+            env_vals += [env_move(lv.val, ty, lv.kind)];\n+          }\n+          capture::cap_drop. {\n+            bcx = drop_ty(bcx, lv.val, ty);\n+          }\n         }\n-        env_vals += [env_direct(lv.val, ty, lv.kind == owned)];\n     }\n-    ret store_environment(cx, copy cx.fcx.lltydescs, env_vals, ck);\n+    ret store_environment(bcx, copy bcx.fcx.lltydescs, env_vals, ck);\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n@@ -287,7 +325,7 @@ fn build_closure(cx: @block_ctxt,\n fn load_environment(enclosing_cx: @block_ctxt,\n                     fcx: @fn_ctxt,\n                     boxed_closure_ty: ty::t,\n-                    upvars: freevar_info,\n+                    cap_vars: [capture::capture_var],\n                     ck: ty::closure_kind) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n \n@@ -311,23 +349,34 @@ fn load_environment(enclosing_cx: @block_ctxt,\n \n     // Populate the upvars from the environment.\n     let path = [0, abi::box_rc_field_body, abi::closure_elt_bindings];\n-    vec::iteri(*upvars) { |i, upvar|\n-        check type_is_tup_like(bcx, boxed_closure_ty);\n-        let upvarptr =\n-            GEP_tup_like(bcx, boxed_closure_ty, llclosure, path + [i as int]);\n-        bcx = upvarptr.bcx;\n-        let llupvarptr = upvarptr.val;\n-        alt ck {\n-          ty::closure_block. { llupvarptr = Load(bcx, llupvarptr); }\n-          ty::closure_send. | ty::closure_shared. { }\n+    let i = 0u;\n+    vec::iter(cap_vars) { |cap_var|\n+        alt cap_var.mode {\n+          capture::cap_drop. { /* ignore */ }\n+          _ {\n+            check type_is_tup_like(bcx, boxed_closure_ty);\n+            let upvarptr = GEP_tup_like(\n+                bcx, boxed_closure_ty, llclosure, path + [i as int]);\n+            bcx = upvarptr.bcx;\n+            let llupvarptr = upvarptr.val;\n+            alt ck {\n+              ty::closure_block. { llupvarptr = Load(bcx, llupvarptr); }\n+              ty::closure_send. | ty::closure_shared. { }\n+            }\n+            let def_id = ast_util::def_id_of_def(cap_var.def);\n+            fcx.llupvars.insert(def_id.node, llupvarptr);\n+            i += 1u;\n+          }\n         }\n-        let def_id = ast_util::def_id_of_def(upvar.def);\n-        fcx.llupvars.insert(def_id.node, llupvarptr);\n     }\n }\n \n-fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n-                 id: ast::node_id, dest: dest) -> @block_ctxt {\n+fn trans_expr_fn(bcx: @block_ctxt,\n+                 f: ast::_fn,\n+                 sp: span,\n+                 id: ast::node_id,\n+                 cap_clause: ast::capture_clause,\n+                 dest: dest) -> @block_ctxt {\n     if dest == ignore { ret bcx; }\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n     let fty = node_id_type(ccx, id);\n@@ -339,10 +388,11 @@ fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n     register_fn(ccx, sp, sub_cx.path, \"anon fn\", [], id);\n \n     let trans_closure_env = lambda(ck: ty::closure_kind) -> ValueRef {\n-        let upvars = get_freevars(ccx.tcx, id);\n-        let {llbox, box_ty, bcx} = build_closure(bcx, upvars, ck);\n+        let cap_vars = capture::compute_capture_vars(\n+            ccx.tcx, id, f.proto, cap_clause);\n+        let {llbox, box_ty, bcx} = build_closure(bcx, cap_vars, ck);\n         trans_closure(sub_cx, sp, f, llfn, no_self, [], id, {|fcx|\n-            load_environment(bcx, fcx, box_ty, upvars, ck);\n+            load_environment(bcx, fcx, box_ty, cap_vars, ck);\n         });\n         llbox\n     };\n@@ -420,7 +470,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n         let sp = cx.sp;\n         let llclosurety = T_ptr(type_of(ccx, sp, outgoing_fty));\n         let src_loc = PointerCast(bcx, cl, llclosurety);\n-        ([env_direct(src_loc, pair_ty, true)], none)\n+        ([env_copy(src_loc, pair_ty, owned)], none)\n       }\n       none. { ([], some(f_res.val)) }\n     };"}, {"sha": "862c7867feb20719c27aa0843b6bc09acfebde7c", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -347,6 +347,13 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n             handle_var_def(fcx, rslt, def.def, \"upvar\");\n         }\n \n+        let use_cap_item = lambda(&&cap_item: @capture_item) {\n+            let d = local_node_id_to_local_def_id(fcx, cap_item.id);\n+            option::may(d, { |id| use_var(fcx, id) });\n+        };\n+        vec::iter(cap_clause.copies, use_cap_item);\n+        vec::iter(cap_clause.moves, use_cap_item);\n+\n         vec::iter(cap_clause.moves) { |cap_item|\n             log (\"forget_in_postcond: \", cap_item);\n             forget_in_postcond(fcx, e.id, cap_item.id);"}, {"sha": "dc3cee75c23b00721ba0c13b4c0ee6ec59aa3896", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -1939,9 +1939,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n         write::ty_only_fixup(fcx, id, result_ty);\n       }\n-      ast::expr_fn(f, captures) { // NDM captures\n-        let cx = @{tcx: tcx};\n-        let fty = ty_of_fn_decl(cx.tcx, m_check_tyvar(fcx), f.decl,\n+      ast::expr_fn(f, captures) {\n+        let fty = ty_of_fn_decl(tcx, m_check_tyvar(fcx), f.decl,\n                                  f.proto, [], none).ty;\n \n         write::ty_only_fixup(fcx, id, fty);\n@@ -1956,6 +1955,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         if f.proto == ast::proto_block {\n             write::ty_only_fixup(fcx, id, expected);\n         }\n+\n+        capture::check_capture_clause(tcx, expr.id, f.proto, *captures);\n       }\n       ast::expr_block(b) {\n         // If this is an unchecked block, turn off purity-checking"}, {"sha": "0ddfb970ed175c7b0d7a4337e07f85d3a48c46d5", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -38,6 +38,7 @@ mod middle {\n     mod shape;\n     mod gc;\n     mod debuginfo;\n+    mod capture;\n \n     mod tstate {\n         mod ck;"}, {"sha": "4f6b5cf3744f904d8d88c0f5399bb634d5923b89", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -261,6 +261,10 @@ tag expr_ {\n     expr_mac(mac);\n }\n \n+// AST nodes that represent a capture clause, which is used to declare\n+// variables that are copied or moved explicitly into the closure.  In some\n+// cases, local variables can also be copied implicitly into the closure if\n+// they are used in the closure body.\n type capture_item = {\n     id: int,\n     name: ident, // Currently, can only capture a local var."}, {"sha": "0758ad67bd56bc5a48d40765d0c62a9c3a185460", "filename": "src/test/compile-fail/cap-clause-both-copy-and-move.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Fcompile-fail%2Fcap-clause-both-copy-and-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Fcompile-fail%2Fcap-clause-both-copy-and-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-both-copy-and-move.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern:error: Variable 'x' captured more than once\n+fn main() {\n+    let x = 5;\n+    let y = sendfn[move x; copy x]() -> int { x };\n+}\n\\ No newline at end of file"}, {"sha": "2e1008bad1c6b824c170b5d5f1616e4225cda5a5", "filename": "src/test/compile-fail/cap-clause-double-copy.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-copy.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern:error: Variable 'x' captured more than once\n+fn main() {\n+    let x = 5;\n+    let y = sendfn[copy x, x]() -> int { x };\n+}"}, {"sha": "89e1a4a5a51e758710a265a20f8fda8aad16dc6c", "filename": "src/test/compile-fail/cap-clause-double-move.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-move.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern: error: Variable 'x' captured more than once\n+fn main() {\n+    let x = 5;\n+    let y = sendfn[move x, x]() -> int { x };\n+}"}, {"sha": "33b0a67a7e4dd54a52d1b779dd697fc111d18efe", "filename": "src/test/compile-fail/cap-clause-move-upvar.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Fcompile-fail%2Fcap-clause-move-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Fcompile-fail%2Fcap-clause-move-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-move-upvar.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -0,0 +1,8 @@\n+// error-pattern: error: Upvars (like 'x') cannot be moved into a closure\n+fn main() {\n+    let x = 5;\n+    let _y = sendfn[move x]() -> int {\n+        let _z = sendfn[move x]() -> int { x };\n+        22\n+    };\n+}"}, {"sha": "029b05ad2e10298291ca15d02fc30ec76e526ad5", "filename": "src/test/compile-fail/cap-clause-use-after-move.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Fcompile-fail%2Fcap-clause-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Fcompile-fail%2Fcap-clause-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-use-after-move.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -0,0 +1,7 @@\n+// error-pattern:Unsatisfied precondition constraint\n+\n+fn main() {\n+    let x = 5;\n+    let _y = sendfn[move x]() { };\n+    let _z = x; //< error: Unsatisfied precondition constraint\n+}"}, {"sha": "96b4b4d3aaa6365f2db76dba1f45d6c4f7f64ef4", "filename": "src/test/run-pass/cap-clause-move.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -0,0 +1,17 @@\n+// error-pattern: warning: Captured variable 'y' not used in closure\n+fn main() {\n+    let x = ~1;\n+    let y = ptr::addr_of(*x) as uint;\n+\n+    let lam_copy = lambda[copy x]() -> uint { ptr::addr_of(*x) as uint };\n+    let lam_move = lambda[move x]() -> uint { ptr::addr_of(*x) as uint };\n+    assert lam_copy() != y;\n+    assert lam_move() == y;\n+\n+    let x = ~2;\n+    let y = ptr::addr_of(*x) as uint;\n+    let snd_copy = sendfn[copy x]() -> uint { ptr::addr_of(*x) as uint };\n+    let snd_move = sendfn[move x]() -> uint { ptr::addr_of(*x) as uint };\n+    assert snd_copy() != y;\n+    assert snd_move() == y;\n+}"}, {"sha": "0bb43b9c6f53e983237b8ac7c54dbcd280dd2659", "filename": "src/test/run-pass/cap-clause-not-used.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Frun-pass%2Fcap-clause-not-used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e/src%2Ftest%2Frun-pass%2Fcap-clause-not-used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-not-used.rs?ref=55a2fd18ec8f2e9aeee699296b7a500b49ff0c5e", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern: warning: Captured variable 'y' not used in closure\n+fn main() {\n+    let x = 5;\n+    let _y = sendfn[copy x]() { };\n+}"}]}