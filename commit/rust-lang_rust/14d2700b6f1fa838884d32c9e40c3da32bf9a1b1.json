{"sha": "14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZDI3MDBiNmYxZmE4Mzg4ODRkMzJjOWU0MGMzZGEzMmJmOWExYjE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-28T17:13:34Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-28T17:13:34Z"}, "message": "Merge #3217 #3366\n\n3217: Fix string_lit_as_bytes lint for macros r=phansch a=yaahallo\n\nPrior to this change, string_lit_as_bytes would trigger for constructs\r\nlike `include_str!(\"filename\").as_bytes()` and would recommend fixing it\r\nby rewriting as `binclude_str!(\"filename\")`.\r\n\r\nThis change updates the lint to act as an EarlyLintPass lint. It then\r\ndifferentiates between string literals and macros that have bytes\r\nyielding alternatives.\r\n\r\nCloses #3205\n\n3366: Don't expand macros in some suggestions r=oli-obk a=phansch\n\nFixes #1148 \r\nFixes #1628\r\nFixes #2455\r\nFixes #3023\r\nFixes #3333\r\nFixes #3360\n\nCo-authored-by: Jane Lusby <jlusby42@gmail.com>\nCo-authored-by: Philipp Hansch <dev@phansch.net>", "tree": {"sha": "bb62a869b991b49fa5a8433edda510035ee06a81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb62a869b991b49fa5a8433edda510035ee06a81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "html_url": "https://github.com/rust-lang/rust/commit/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "6ce5edcdd5f520f647e19a8376d797566dec686a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce5edcdd5f520f647e19a8376d797566dec686a", "html_url": "https://github.com/rust-lang/rust/commit/6ce5edcdd5f520f647e19a8376d797566dec686a"}, {"sha": "19ac2e94c6cb12ae4f9fb410f165e2aa5309e124", "url": "https://api.github.com/repos/rust-lang/rust/commits/19ac2e94c6cb12ae4f9fb410f165e2aa5309e124", "html_url": "https://github.com/rust-lang/rust/commit/19ac2e94c6cb12ae4f9fb410f165e2aa5309e124"}, {"sha": "840e50e97f023c2d0bfeb0222d094fa407f12f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/840e50e97f023c2d0bfeb0222d094fa407f12f2f", "html_url": "https://github.com/rust-lang/rust/commit/840e50e97f023c2d0bfeb0222d094fa407f12f2f"}], "stats": {"total": 175, "additions": 123, "deletions": 52}, "files": [{"sha": "00ce58f00b0d1907cc43aa4751f0e37ba097ceff", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -12,7 +12,7 @@ use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::hir::*;\n use crate::syntax::ast::NodeId;\n-use crate::utils::{in_macro, match_def_path, match_trait_method, same_tys, snippet, span_lint_and_then};\n+use crate::utils::{in_macro, match_def_path, match_trait_method, same_tys, snippet, snippet_with_macro_callsite, span_lint_and_then};\n use crate::utils::{opt_def_id, paths, resolve_node};\n use crate::rustc_errors::Applicability;\n \n@@ -72,7 +72,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n                     let a = cx.tables.expr_ty(e);\n                     let b = cx.tables.expr_ty(&args[0]);\n                     if same_tys(cx, a, b) {\n-                        let sugg = snippet(cx, args[0].span, \"<expr>\").into_owned();\n+                        let sugg = snippet_with_macro_callsite(cx, args[0].span, \"<expr>\").to_string();\n+\n                         span_lint_and_then(cx, IDENTITY_CONVERSION, e.span, \"identical conversion\", |db| {\n                             db.span_suggestion_with_applicability(\n                                 e.span,"}, {"sha": "4a704c3d52ece894c0e4a8991cd28d7f02d5f841", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -19,7 +19,8 @@ use crate::syntax::ast::LitKind;\n use crate::syntax::source_map::Span;\n use crate::utils::paths;\n use crate::utils::{expr_block, is_allowed, is_expn_of, match_qpath, match_type, multispan_sugg,\n-            remove_blocks, snippet, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty};\n+            remove_blocks, snippet, span_lint_and_sugg, span_lint_and_then,\n+            span_note_and_lint, walk_ptrs_ty};\n use crate::utils::sugg::Sugg;\n use crate::consts::{constant, Constant};\n use crate::rustc_errors::Applicability;"}, {"sha": "8d0cd32e23bf46c2cf3ebdadccf2e8859e7c28ef", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -21,7 +21,7 @@ use crate::utils::sugg;\n use crate::utils::{\n     get_arg_name, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of, is_self, is_self_ty,\n     iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method, match_type,\n-    match_var, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path, snippet, span_lint,\n+    match_var, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path, snippet, snippet_with_macro_callsite, span_lint,\n     span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n use if_chain::if_chain;\n@@ -1062,9 +1062,9 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n         }\n \n         let sugg: Cow<'_, _> = match (fn_has_arguments, !or_has_args) {\n-            (true, _) => format!(\"|_| {}\", snippet(cx, arg.span, \"..\")).into(),\n-            (false, false) => format!(\"|| {}\", snippet(cx, arg.span, \"..\")).into(),\n-            (false, true) => snippet(cx, fun_span, \"..\"),\n+            (true, _) => format!(\"|_| {}\", snippet_with_macro_callsite(cx, arg.span, \"..\")).into(),\n+            (false, false) => format!(\"|| {}\", snippet_with_macro_callsite(cx, arg.span, \"..\")).into(),\n+            (false, true) => snippet_with_macro_callsite(cx, fun_span, \"..\"),\n         };\n         let span_replace_word = method_span.with_hi(span.hi());\n         span_lint_and_sugg("}, {"sha": "e07b1649a4662897ffa8d08de6d0c3280a6b3e94", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n@@ -92,7 +91,14 @@ impl LintPass for StringAdd {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprKind::Binary(Spanned { node: BinOpKind::Add, .. }, ref left, _) = e.node {\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Add, ..\n+            },\n+            ref left,\n+            _,\n+        ) = e.node\n+        {\n             if is_string(cx, left) {\n                 if !is_allowed(cx, STRING_ADD_ASSIGN, e.id) {\n                     let parent = get_parent_expr(cx, e);\n@@ -132,13 +138,15 @@ fn is_string(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n \n fn is_add(cx: &LateContext<'_, '_>, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n-        ExprKind::Binary(Spanned { node: BinOpKind::Add, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n+        ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Add, ..\n+            },\n+            ref left,\n+            _,\n+        ) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprKind::Block(ref block, _) => {\n-            block.stmts.is_empty()\n-                && block\n-                    .expr\n-                    .as_ref()\n-                    .map_or(false, |expr| is_add(cx, expr, target))\n+            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n         },\n         _ => false,\n     }\n@@ -155,14 +163,33 @@ impl LintPass for StringLitAsBytes {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        use crate::syntax::ast::LitKind;\n+        use crate::syntax::ast::{LitKind, StrStyle};\n         use crate::utils::{in_macro, snippet};\n \n         if let ExprKind::MethodCall(ref path, _, ref args) = e.node {\n             if path.ident.name == \"as_bytes\" {\n                 if let ExprKind::Lit(ref lit) = args[0].node {\n-                    if let LitKind::Str(ref lit_content, _) = lit.node {\n-                        if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(args[0].span) {\n+                    if let LitKind::Str(ref lit_content, style) = lit.node {\n+                        let callsite = snippet(cx, args[0].span.source_callsite(), r#\"\"foo\"\"#);\n+                        let expanded = if let StrStyle::Raw(n) = style {\n+                            let term = (0..n).map(|_| '#').collect::<String>();\n+                            format!(\"r{0}\\\"{1}\\\"{0}\", term, lit_content.as_str())\n+                        } else {\n+                            format!(\"\\\"{}\\\"\", lit_content.as_str())\n+                        };\n+                        if callsite.starts_with(\"include_str!\") {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                STRING_LIT_AS_BYTES,\n+                                e.span,\n+                                \"calling `as_bytes()` on `include_str!(..)`\",\n+                                \"consider using `include_bytes!(..)` instead\",\n+                                snippet(cx, args[0].span, r#\"\"foo\"\"#).replacen(\"include_str\", \"include_bytes\", 1),\n+                            );\n+                        } else if callsite == expanded\n+                            && lit_content.as_str().chars().all(|c| c.is_ascii())\n+                            && !in_macro(args[0].span)\n+                        {\n                             span_lint_and_sugg(\n                                 cx,\n                                 STRING_LIT_AS_BYTES,"}, {"sha": "72a6bda26c36b41676dadab8d4a12cdafaf18bb8", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -362,6 +362,12 @@ pub fn snippet<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str)\n     snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)\n }\n \n+/// Same as `snippet`, but should only be used when it's clear that the input span is\n+/// not a macro argument.\n+pub fn snippet_with_macro_callsite<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+    snippet(cx, span.source_callsite(), default)\n+}\n+\n /// Convert a span to a code snippet. Returns `None` if not available.\n pub fn snippet_opt<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     cx.sess().source_map().span_to_snippet(span).ok()\n@@ -400,7 +406,10 @@ pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n ) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     let string = option.unwrap_or_default();\n-    if let ExprKind::Block(_, _) = expr.node {\n+    if in_macro(expr.span) {\n+        Cow::Owned(format!(\"{{ {} }}\", snippet_with_macro_callsite(cx, expr.span, default)))\n+    }\n+    else if let ExprKind::Block(_, _) = expr.node {\n         Cow::Owned(format!(\"{}{}\", code, string))\n     } else if string.is_empty() {\n         Cow::Owned(format!(\"{{ {} }}\", code))"}, {"sha": "b5cb92c6d5a108c9ec143ed23f8c2b9e440e026f", "filename": "tests/ui/identity_conversion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_conversion.rs?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -53,4 +53,5 @@ fn main() {\n     let _ = String::from(format!(\"A: {:04}\", 123));\n     let _ = \"\".lines().into_iter();\n     let _ = vec![1, 2, 3].into_iter().into_iter();\n+    let _: String = format!(\"Hello {}\", \"world\").into();\n }"}, {"sha": "15bef8b125ebb31f275493e0408927651adc855f", "filename": "tests/ui/identity_conversion.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fidentity_conversion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fidentity_conversion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_conversion.stderr?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -58,5 +58,11 @@ error: identical conversion\n 55 |     let _ = vec![1, 2, 3].into_iter().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into_iter()`: `vec![1, 2, 3].into_iter()`\n \n-error: aborting due to 9 previous errors\n+error: identical conversion\n+  --> $DIR/identity_conversion.rs:56:21\n+   |\n+56 |     let _: String = format!(\"Hello {}\", \"world\").into();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into()`: `format!(\"Hello {}\", \"world\")`\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "b5f1f2ab0e731dcbf82f48c836847f5d9dadb06c", "filename": "tests/ui/matches.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fmatches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fmatches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.stderr?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -33,7 +33,7 @@ error: you seem to be trying to use match for destructuring a single pattern. Co\n 51 | |         &(v, 1) => println!(\"{}\", v),\n 52 | |         _ => println!(\"none\"),\n 53 | |     }\n-   | |_____^ help: try this: `if let &(v, 1) = tup { $ crate :: io :: _print ( format_args_nl ! ( $ ( $ arg ) * ) ) ; } else { $ crate :: io :: _print ( format_args_nl ! ( $ ( $ arg ) * ) ) ; }`\n+   | |_____^ help: try this: `if let &(v, 1) = tup { println!(\"{}\", v) } else { println!(\"none\") }`\n \n error: you don't need to add `&` to all patterns\n   --> $DIR/matches.rs:50:5"}, {"sha": "896b15481bb49bf3102377ab9a731ee4dc552e6e", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -297,7 +297,7 @@ error: use of `unwrap_or` followed by a function call\n    --> $DIR/methods.rs:339:14\n     |\n 339 |     with_vec.unwrap_or(vec![]);\n-    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| < [ _ ] > :: into_vec ( box [ $ ( $ x ) , * ] ))`\n+    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| vec![])`\n \n error: use of `unwrap_or` followed by a function call\n    --> $DIR/methods.rs:344:21"}, {"sha": "dca68e179e7425ac06a0baa0e30733e74d78b4dc", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -23,6 +23,15 @@ fn single_match(){\n         _ => ()\n     };\n \n+    let x = Some(1u8);\n+    match x {\n+        // Note the missing block braces.\n+        // We suggest `if let Some(y) = x { .. }` because the macro\n+        // is expanded before we can do anything.\n+        Some(y) => println!(\"{:?}\", y),\n+        _ => ()\n+    }\n+\n     let z = (1u8,1u8);\n     match z {\n         (2...3, 7...9) => dummy(),"}, {"sha": "df614ad201d1d3642163c18eec00ea398ff6a97d", "filename": "tests/ui/single_match.stderr", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.stderr?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -12,38 +12,50 @@ error: you seem to be trying to use match for destructuring a single pattern. Co\n error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:27:5\n    |\n-27 | /     match z {\n-28 | |         (2...3, 7...9) => dummy(),\n-29 | |         _ => {}\n-30 | |     };\n+27 | /     match x {\n+28 | |         // Note the missing block braces.\n+29 | |         // We suggest `if let Some(y) = x { .. }` because the macro\n+30 | |         // is expanded before we can do anything.\n+31 | |         Some(y) => println!(\"{:?}\", y),\n+32 | |         _ => ()\n+33 | |     }\n+   | |_____^ help: try this: `if let Some(y) = x { println!(\"{:?}\", y) }`\n+\n+error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:36:5\n+   |\n+36 | /     match z {\n+37 | |         (2...3, 7...9) => dummy(),\n+38 | |         _ => {}\n+39 | |     };\n    | |_____^ help: try this: `if let (2...3, 7...9) = z { dummy() }`\n \n error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match.rs:53:5\n+  --> $DIR/single_match.rs:62:5\n    |\n-53 | /     match x {\n-54 | |         Some(y) => dummy(),\n-55 | |         None => ()\n-56 | |     };\n+62 | /     match x {\n+63 | |         Some(y) => dummy(),\n+64 | |         None => ()\n+65 | |     };\n    | |_____^ help: try this: `if let Some(y) = x { dummy() }`\n \n error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match.rs:58:5\n+  --> $DIR/single_match.rs:67:5\n    |\n-58 | /     match y {\n-59 | |         Ok(y) => dummy(),\n-60 | |         Err(..) => ()\n-61 | |     };\n+67 | /     match y {\n+68 | |         Ok(y) => dummy(),\n+69 | |         Err(..) => ()\n+70 | |     };\n    | |_____^ help: try this: `if let Ok(y) = y { dummy() }`\n \n error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match.rs:65:5\n+  --> $DIR/single_match.rs:74:5\n    |\n-65 | /     match c {\n-66 | |         Cow::Borrowed(..) => dummy(),\n-67 | |         Cow::Owned(..) => (),\n-68 | |     };\n+74 | /     match c {\n+75 | |         Cow::Borrowed(..) => dummy(),\n+76 | |         Cow::Owned(..) => (),\n+77 | |     };\n    | |_____^ help: try this: `if let Cow::Borrowed(..) = c { dummy() }`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "d2062b356dc0d0d29eb3db9793bc0629a1acb1e5", "filename": "tests/ui/strings.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstrings.rs?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -10,10 +10,10 @@\n \n \n \n-\n #[warn(clippy::string_add)]\n #[allow(clippy::string_add_assign)]\n-fn add_only() { // ignores assignment distinction\n+fn add_only() {\n+    // ignores assignment distinction\n     let mut x = \"\".to_owned();\n \n     for _ in 1..3 {\n@@ -59,19 +59,24 @@ fn both() {\n fn str_lit_as_bytes() {\n     let bs = \"hello there\".as_bytes();\n \n+    let bs = r###\"raw string with three ### in it and some \" \"\"###.as_bytes();\n+\n     // no warning, because this cannot be written as a byte string literal:\n     let ubs = \"\u2603\".as_bytes();\n \n     let strify = stringify!(foobar).as_bytes();\n+\n+    let includestr = include_str!(\"entry.rs\").as_bytes();\n }\n \n+#[allow(clippy::assign_op_pattern)]\n fn main() {\n     add_only();\n     add_assign_only();\n     both();\n \n     // the add is only caught for `String`\n     let mut x = 1;\n-    ; x = x + 1;\n+    x = x + 1;\n     assert_eq!(2, x);\n }"}, {"sha": "21115d8e97ecd20eb449916684ff6de2e7b6b960", "filename": "tests/ui/strings.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fstrings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14d2700b6f1fa838884d32c9e40c3da32bf9a1b1/tests%2Fui%2Fstrings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstrings.stderr?ref=14d2700b6f1fa838884d32c9e40c3da32bf9a1b1", "patch": "@@ -61,16 +61,16 @@ error: calling `as_bytes()` on a string literal\n    = note: `-D clippy::string-lit-as-bytes` implied by `-D warnings`\n \n error: calling `as_bytes()` on a string literal\n-  --> $DIR/strings.rs:65:18\n+  --> $DIR/strings.rs:62:14\n    |\n-65 |     let strify = stringify!(foobar).as_bytes();\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using a byte string literal instead: `bstringify!(foobar)`\n+62 |     let bs = r###\"raw string with three ### in it and some \" \"\"###.as_bytes();\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using a byte string literal instead: `br###\"raw string with three ### in it and some \" \"\"###`\n \n-error: manual implementation of an assign operation\n-  --> $DIR/strings.rs:75:7\n+error: calling `as_bytes()` on `include_str!(..)`\n+  --> $DIR/strings.rs:69:22\n    |\n-75 |     ; x = x + 1;\n-   |       ^^^^^^^^^ help: replace it with: `x += 1`\n+69 |     let includestr = include_str!(\"entry.rs\").as_bytes();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `include_bytes!(..)` instead: `include_bytes!(\"entry.rs\")`\n \n error: aborting due to 11 previous errors\n "}]}