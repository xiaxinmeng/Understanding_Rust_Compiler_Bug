{"sha": "4971d03ccfe9452753deb84fd958fd0b0e63f156", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NzFkMDNjY2ZlOTQ1Mjc1M2RlYjg0ZmQ5NThmZDBiMGU2M2YxNTY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-05T22:31:39Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-08T21:04:54Z"}, "message": "fix some cases of unexpected exceptions leaving validation", "tree": {"sha": "f1909d6549a58263da93d1fc600e6b78577e30d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1909d6549a58263da93d1fc600e6b78577e30d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4971d03ccfe9452753deb84fd958fd0b0e63f156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4971d03ccfe9452753deb84fd958fd0b0e63f156", "html_url": "https://github.com/rust-lang/rust/commit/4971d03ccfe9452753deb84fd958fd0b0e63f156", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4971d03ccfe9452753deb84fd958fd0b0e63f156/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "938f8522ecf6c463bc06503251a23c3ded35ca25", "url": "https://api.github.com/repos/rust-lang/rust/commits/938f8522ecf6c463bc06503251a23c3ded35ca25", "html_url": "https://github.com/rust-lang/rust/commit/938f8522ecf6c463bc06503251a23c3ded35ca25"}], "stats": {"total": 185, "additions": 122, "deletions": 63}, "files": [{"sha": "731c3ee0d6a0eeec5360c3b84d2ad013e9c81f28", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -245,7 +245,7 @@ fn print_backtrace(backtrace: &mut Backtrace) {\n     eprintln!(\"\\n\\nAn error occurred in miri:\\n{:?}\", backtrace);\n }\n \n-impl From<ErrorHandled> for InterpErrorInfo<'tcx> {\n+impl From<ErrorHandled> for InterpErrorInfo<'_> {\n     fn from(err: ErrorHandled) -> Self {\n         match err {\n             ErrorHandled::Reported => err_inval!(ReferencedConstant),\n@@ -291,7 +291,7 @@ pub enum InvalidProgramInfo<'tcx> {\n     Layout(layout::LayoutError<'tcx>),\n }\n \n-impl fmt::Debug for InvalidProgramInfo<'tcx> {\n+impl fmt::Debug for InvalidProgramInfo<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use InvalidProgramInfo::*;\n         match self {\n@@ -304,7 +304,7 @@ impl fmt::Debug for InvalidProgramInfo<'tcx> {\n }\n \n /// Error information for when the program caused Undefined Behavior.\n-pub enum UndefinedBehaviorInfo {\n+pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Ub(String),\n     /// Free-form case for experimental UB. Only for errors that are never caught!\n@@ -321,9 +321,11 @@ pub enum UndefinedBehaviorInfo {\n     RemainderByZero,\n     /// Overflowing inbounds pointer arithmetic.\n     PointerArithOverflow,\n+    /// Invalid metadata in a wide pointer (using `str` to avoid allocations).\n+    InvalidMeta(&'tcx str),\n }\n \n-impl fmt::Debug for UndefinedBehaviorInfo {\n+impl fmt::Debug for UndefinedBehaviorInfo<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use UndefinedBehaviorInfo::*;\n         match self {\n@@ -338,6 +340,7 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n             DivisionByZero => write!(f, \"dividing by zero\"),\n             RemainderByZero => write!(f, \"calculating the remainder with a divisor of zero\"),\n             PointerArithOverflow => write!(f, \"overflowing in-bounds pointer arithmetic\"),\n+            InvalidMeta(msg) => write!(f, \"invalid metadata in wide pointer: {}\", msg),\n         }\n     }\n }\n@@ -577,7 +580,7 @@ impl fmt::Debug for ResourceExhaustionInfo {\n \n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior.\n-    UndefinedBehavior(UndefinedBehaviorInfo),\n+    UndefinedBehavior(UndefinedBehaviorInfo<'tcx>),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n     /// but the interpreter is not sure).\n     Unsupported(UnsupportedOpInfo<'tcx>),"}, {"sha": "ffbff00cf376005a6b983d0ddc9c247b1ad67383", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -186,7 +186,12 @@ fn validate_and_turn_into_const<'tcx>(\n         if cid.promoted.is_none() {\n             let mut ref_tracking = RefTracking::new(mplace);\n             while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-                ecx.validate_operand(mplace.into(), path, Some(&mut ref_tracking))?;\n+                ecx.const_validate_operand(\n+                    mplace.into(),\n+                    path,\n+                    &mut ref_tracking,\n+                    /*may_ref_to_static*/ is_static,\n+                )?;\n             }\n         }\n         // Now that we validated, turn this into a proper constant."}, {"sha": "9b28b7a20c044ef3779e561566cb22b6e52ff866", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -457,10 +457,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Check if this brought us over the size limit.\n                 if size.bytes() >= self.tcx.data_layout().obj_size_bound() {\n-                    throw_ub_format!(\n-                        \"wide pointer metadata contains invalid information: \\\n-                        total size is bigger than largest supported object\"\n-                    );\n+                    throw_ub!(InvalidMeta(\"total size is bigger than largest supported object\"));\n                 }\n                 Ok(Some((size, align)))\n             }\n@@ -476,10 +473,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Make sure the slice is not too big.\n                 let size = elem.size.checked_mul(len, &*self.tcx).ok_or_else(|| {\n-                    err_ub_format!(\n-                        \"invalid slice: \\\n-                        total size is bigger than largest supported object\"\n-                    )\n+                    err_ub!(InvalidMeta(\"slice is bigger than largest supported object\"))\n                 })?;\n                 Ok(Some((size, elem.align.abi)))\n             }\n@@ -685,7 +679,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // invariant -- that is, unless a function somehow has a ptr to\n                     // its return place... but the way MIR is currently generated, the\n                     // return place is always a local and then this cannot happen.\n-                    self.validate_operand(self.place_to_op(return_place)?, vec![], None)?;\n+                    self.validate_operand(self.place_to_op(return_place)?)?;\n                 }\n             } else {\n                 // Uh, that shouldn't happen... the function did not intend to return"}, {"sha": "a4815b9696ebb5d0d0d2a4c57e3e4d8adb1afe1d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -689,7 +689,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n+            self.validate_operand(self.place_to_op(dest)?)?;\n         }\n \n         Ok(())\n@@ -706,7 +706,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), vec![], None)?;\n+            self.validate_operand(dest.into())?;\n         }\n \n         Ok(())\n@@ -843,7 +843,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n+            self.validate_operand(self.place_to_op(dest)?)?;\n         }\n \n         Ok(())\n@@ -951,7 +951,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), vec![], None)?;\n+            self.validate_operand(dest.into())?;\n         }\n \n         Ok(())"}, {"sha": "05bb010959b32093e07245b623fa14c4baf8fb0d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 50, "deletions": 14, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -171,6 +171,7 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     path: Vec<PathElem>,\n     ref_tracking_for_consts:\n         Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n+    may_ref_to_static: bool,\n     ecx: &'rt InterpCx<'mir, 'tcx, M>,\n }\n \n@@ -324,9 +325,17 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n             self.check_wide_ptr_meta(place.meta, place.layout)?;\n         }\n         // Make sure this is dereferenceable and all.\n-        let (size, align) = self\n-            .ecx\n-            .size_and_align_of(place.meta, place.layout)?\n+        let size_and_align = match self.ecx.size_and_align_of(place.meta, place.layout) {\n+            Ok(res) => res,\n+            Err(err) => match err.kind {\n+                err_ub!(InvalidMeta(msg)) => throw_validation_failure!(\n+                    format_args!(\"invalid {} metadata: {}\", kind, msg),\n+                    self.path\n+                ),\n+                _ => bug!(\"Unexpected error during ptr size_and_align_of: {}\", err),\n+            },\n+        };\n+        let (size, align) = size_and_align\n             // for the purpose of validity, consider foreign types to have\n             // alignment and size determined by the layout (size will be 0,\n             // alignment should take attributes into account).\n@@ -387,6 +396,12 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                     if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n                         return Ok(());\n                     }\n+                    if !self.may_ref_to_static && self.ecx.tcx.is_static(did) {\n+                        throw_validation_failure!(\n+                            format_args!(\"a {} pointing to a static variable\", kind),\n+                            self.path\n+                        );\n+                    }\n                 }\n             }\n             // Proceed recursively even for ZST, no reason to skip them!\n@@ -781,26 +796,20 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    /// This function checks the data at `op`. `op` is assumed to cover valid memory if it\n-    /// is an indirect operand.\n-    /// It will error if the bits at the destination do not match the ones described by the layout.\n-    ///\n-    /// `ref_tracking_for_consts` can be `None` to avoid recursive checking below references.\n-    /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n-    /// validation (e.g., pointer values are fine in integers at runtime) and various other const\n-    /// specific validation checks.\n-    pub fn validate_operand(\n+    fn validate_operand_internal(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n         ref_tracking_for_consts: Option<\n             &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n         >,\n+        may_ref_to_static: bool,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"validate_operand: {:?}, {:?}\", *op, op.layout.ty);\n+        trace!(\"validate_operand_internal: {:?}, {:?}\", *op, op.layout.ty);\n \n         // Construct a visitor\n-        let mut visitor = ValidityVisitor { path, ref_tracking_for_consts, ecx: self };\n+        let mut visitor =\n+            ValidityVisitor { path, ref_tracking_for_consts, may_ref_to_static, ecx: self };\n \n         // Try to cast to ptr *once* instead of all the time.\n         let op = self.force_op_ptr(op).unwrap_or(op);\n@@ -815,4 +824,31 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Err(err) => Err(err),\n         }\n     }\n+\n+    /// This function checks the data at `op` to be const-valid.\n+    /// `op` is assumed to cover valid memory if it is an indirect operand.\n+    /// It will error if the bits at the destination do not match the ones described by the layout.\n+    ///\n+    /// `ref_tracking` is used to record references that we encounter so that they\n+    /// can be checked recursively by an outside driving loop.\n+    ///\n+    /// `may_ref_to_static` controls whether references are allowed to point to statics.\n+    #[inline(always)]\n+    pub fn const_validate_operand(\n+        &self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+        path: Vec<PathElem>,\n+        ref_tracking: &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n+        may_ref_to_static: bool,\n+    ) -> InterpResult<'tcx> {\n+        self.validate_operand_internal(op, path, Some(ref_tracking), may_ref_to_static)\n+    }\n+\n+    /// This function checks the data at `op` to be runtime-valid.\n+    /// `op` is assumed to cover valid memory if it is an indirect operand.\n+    /// It will error if the bits at the destination do not match the ones described by the layout.\n+    #[inline(always)]\n+    pub fn validate_operand(&self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+        self.validate_operand_internal(op, vec![], None, false)\n+    }\n }"}, {"sha": "a07c8575b300c9048d9266c8352a3dc67cd61109", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -637,11 +637,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         trace!(\"attepting to replace {:?} with {:?}\", rval, value);\n-        if let Err(e) = self.ecx.validate_operand(\n+        if let Err(e) = self.ecx.const_validate_operand(\n             value,\n             vec![],\n             // FIXME: is ref tracking too expensive?\n-            Some(&mut interpret::RefTracking::empty()),\n+            &mut interpret::RefTracking::empty(),\n+            /*may_ref_to_static*/ true,\n         ) {\n             trace!(\"validation error, attempt failed: {:?}\", e);\n             return;"}, {"sha": "c6b8e8eb611819a10c9af6cb0da142ca8a246158", "filename": "src/test/ui/consts/const-eval/dangling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.rs?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -6,7 +6,7 @@ use std::{mem, usize};\n const TEST: () = { unsafe { //~ NOTE\n     let slice: *const [u8] = mem::transmute((1usize, usize::MAX));\n     let _val = &*slice; //~ ERROR: any use of this value will cause an error\n-    //~^ NOTE: total size is bigger than largest supported object\n+    //~^ NOTE: slice is bigger than largest supported object\n     //~^^ on by default\n } };\n "}, {"sha": "b9ddc93b03b84e942dfc318b09c2d48b275743fd", "filename": "src/test/ui/consts/const-eval/dangling.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.stderr?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -4,7 +4,7 @@ error: any use of this value will cause an error\n LL | / const TEST: () = { unsafe {\n LL | |     let slice: *const [u8] = mem::transmute((1usize, usize::MAX));\n LL | |     let _val = &*slice;\n-   | |                ^^^^^^^ invalid slice: total size is bigger than largest supported object\n+   | |                ^^^^^^^ invalid metadata in wide pointer: slice is bigger than largest supported object\n LL | |\n LL | |\n LL | | } };"}, {"sha": "2d48309b727229354512ca82cad09ce87a9ff9ed", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -31,12 +31,16 @@ const STR_VALID: &str = unsafe { mem::transmute((&42u8, 1usize)) };\n // bad str\n const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n //~^ ERROR it is undefined behavior to use this value\n+const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+//~^ ERROR it is undefined behavior to use this value\n // bad str\n const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n //~^ ERROR it is undefined behavior to use this value\n // bad str in user-defined unsized type\n const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n //~^ ERROR it is undefined behavior to use this value\n+const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+//~^ ERROR it is undefined behavior to use this value\n \n // invalid UTF-8\n const STR_NO_UTF8: &str = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n@@ -83,7 +87,7 @@ const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute\n // # raw slice\n const RAW_SLICE_VALID: *const [u8] = unsafe { mem::transmute((&42u8, 1usize)) }; // ok\n const RAW_SLICE_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, 999usize)) }; // ok because raw\n-const RAW_SLICE_MUCH_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, usize::max_value())) }; // ok because raw\n+const RAW_SLICE_MUCH_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, usize::MAX)) }; // ok because raw\n const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n //~^ ERROR it is undefined behavior to use this value\n     let uninit_len = MaybeUninit::<usize> { uninit: () };"}, {"sha": "a562c64b124f99e36c73b838f24976bdd54f2013", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -7,15 +7,23 @@ LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:35:1\n+  --> $DIR/ub-wide-ptr.rs:34:1\n+   |\n+LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object at .0\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:37:1\n    |\n LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:38:1\n+  --> $DIR/ub-wide-ptr.rs:40:1\n    |\n LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n@@ -25,21 +33,29 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:42:1\n    |\n+LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:46:1\n+   |\n LL | const STR_NO_UTF8: &str = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:45:1\n+  --> $DIR/ub-wide-ptr.rs:49:1\n    |\n LL | const MYSTR_NO_UTF8: &MyStr = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>.0\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:52:1\n+  --> $DIR/ub-wide-ptr.rs:56:1\n    |\n LL | / const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n LL | |\n@@ -51,63 +67,63 @@ LL | | };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:58:1\n+  --> $DIR/ub-wide-ptr.rs:62:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:61:1\n+  --> $DIR/ub-wide-ptr.rs:65:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:64:1\n+  --> $DIR/ub-wide-ptr.rs:68:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:67:1\n+  --> $DIR/ub-wide-ptr.rs:71:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:71:1\n+  --> $DIR/ub-wide-ptr.rs:75:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:77:1\n+  --> $DIR/ub-wide-ptr.rs:81:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:80:1\n+  --> $DIR/ub-wide-ptr.rs:84:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:87:1\n+  --> $DIR/ub-wide-ptr.rs:91:1\n    |\n LL | / const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n LL | |\n@@ -119,65 +135,65 @@ LL | | };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:95:1\n+  --> $DIR/ub-wide-ptr.rs:99:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: &dyn Trait = unsafe { mem::transmute((&92u8, &3u8)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:98:1\n+  --> $DIR/ub-wide-ptr.rs:102:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:101:1\n+  --> $DIR/ub-wide-ptr.rs:105:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, 4usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:105:1\n+  --> $DIR/ub-wide-ptr.rs:109:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:109:1\n+  --> $DIR/ub-wide-ptr.rs:113:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:115:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:117:5\n+  --> $DIR/ub-wide-ptr.rs:121:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid use of NULL pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:121:5\n+  --> $DIR/ub-wide-ptr.rs:125:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocation N which has size N\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 24 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "f2ca7ff782591d0b45d8e9598f708a2c2a1ddf5e", "filename": "src/test/ui/consts/const-points-to-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -8,7 +8,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-points-to-static.rs:5:1\n    |\n LL | const TEST: &u8 = &MY_STATIC;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a reference pointing to a static variable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "5e85be45b164711a54c96d36519996e76263d345", "filename": "src/test/ui/consts/issue-63952.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -8,7 +8,7 @@ LL | |             ptr: &42,\n ...  |\n LL | |     .slice\n LL | | };\n-   | |__^ invalid slice: total size is bigger than largest supported object\n+   | |__^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "ad777cfe8ea4bcb2d52a6a4b393e620a825bd4c0", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4971d03ccfe9452753deb84fd958fd0b0e63f156/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr?ref=4971d03ccfe9452753deb84fd958fd0b0e63f156", "patch": "@@ -48,7 +48,7 @@ LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n LL | |     unsafe { &*(&FOO as *const _ as *const usize) }\n LL | |\n LL | | };\n-   | |__^ constant accesses static\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -97,7 +97,7 @@ LL | |     static FOO: usize = 0;\n LL | |     &FOO\n LL | |\n LL | | };\n-   | |__^ constant accesses static\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}]}