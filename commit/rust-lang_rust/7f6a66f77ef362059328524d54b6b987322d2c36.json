{"sha": "7f6a66f77ef362059328524d54b6b987322d2c36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNmE2NmY3N2VmMzYyMDU5MzI4NTI0ZDU0YjZiOTg3MzIyZDJjMzY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-07T03:46:00Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-14T19:27:07Z"}, "message": "rustc: Invert some archive deps", "tree": {"sha": "f3655753a1c62a216e34e29f2c4ff028dc8a24d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3655753a1c62a216e34e29f2c4ff028dc8a24d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f6a66f77ef362059328524d54b6b987322d2c36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f6a66f77ef362059328524d54b6b987322d2c36", "html_url": "https://github.com/rust-lang/rust/commit/7f6a66f77ef362059328524d54b6b987322d2c36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f6a66f77ef362059328524d54b6b987322d2c36/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "930abc156789db6ee897a68f02fac6af682cca5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/930abc156789db6ee897a68f02fac6af682cca5b", "html_url": "https://github.com/rust-lang/rust/commit/930abc156789db6ee897a68f02fac6af682cca5b"}], "stats": {"total": 119, "additions": 85, "deletions": 34}, "files": [{"sha": "ac457f208dd05b4720a37d42f4b40bdb1e057180", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 54, "deletions": 31, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7f6a66f77ef362059328524d54b6b987322d2c36/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6a66f77ef362059328524d54b6b987322d2c36/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=7f6a66f77ef362059328524d54b6b987322d2c36", "patch": "@@ -10,9 +10,6 @@\n \n //! A helper class for dealing with static archives\n \n-use super::link::{get_ar_prog};\n-use driver::session::Session;\n-use metadata::filesearch;\n use llvm::{ArchiveRef, llvm};\n \n use libc;\n@@ -24,22 +21,38 @@ use std::os;\n use std::raw;\n use std::str;\n use syntax::abi;\n+use ErrorHandler = syntax::diagnostic::Handler;\n \n pub static METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n+pub struct ArchiveConfig<'a> {\n+    pub handler: &'a ErrorHandler,\n+    pub dst: Path,\n+    pub lib_search_paths: Vec<Path>,\n+    pub os: abi::Os,\n+    pub maybe_ar_prog: Option<String>\n+}\n+\n pub struct Archive<'a> {\n-    sess: &'a Session,\n+    handler: &'a ErrorHandler,\n     dst: Path,\n+    lib_search_paths: Vec<Path>,\n+    os: abi::Os,\n+    maybe_ar_prog: Option<String>\n }\n \n pub struct ArchiveRO {\n     ptr: ArchiveRef,\n }\n \n-fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n+fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n+          args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n-    let ar = get_ar_prog(sess);\n-    let mut cmd = Command::new(ar.as_slice());\n+    let ar = match *maybe_ar_prog {\n+        Some(ref ar) => ar.as_slice(),\n+        None => \"ar\"\n+    };\n+    let mut cmd = Command::new(ar);\n \n     cmd.arg(args).args(paths);\n     debug!(\"{}\", cmd);\n@@ -56,42 +69,55 @@ fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n         Ok(prog) => {\n             let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n-                sess.err(format!(\"{} failed with: {}\",\n+                handler.err(format!(\"{} failed with: {}\",\n                                  cmd,\n                                  o.status).as_slice());\n-                sess.note(format!(\"stdout ---\\n{}\",\n+                handler.note(format!(\"stdout ---\\n{}\",\n                                   str::from_utf8(o.output\n                                                   .as_slice()).unwrap())\n                           .as_slice());\n-                sess.note(format!(\"stderr ---\\n{}\",\n+                handler.note(format!(\"stderr ---\\n{}\",\n                                   str::from_utf8(o.error\n                                                   .as_slice()).unwrap())\n                           .as_slice());\n-                sess.abort_if_errors();\n+                handler.abort_if_errors();\n             }\n             o\n         },\n         Err(e) => {\n-            sess.err(format!(\"could not exec `{}`: {}\", ar.as_slice(),\n+            handler.err(format!(\"could not exec `{}`: {}\", ar.as_slice(),\n                              e).as_slice());\n-            sess.abort_if_errors();\n+            handler.abort_if_errors();\n             fail!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n     }\n }\n \n impl<'a> Archive<'a> {\n     /// Initializes a new static archive with the given object file\n-    pub fn create<'b>(sess: &'a Session, dst: &'b Path,\n-                      initial_object: &'b Path) -> Archive<'a> {\n-        run_ar(sess, \"crus\", None, [dst, initial_object]);\n-        Archive { sess: sess, dst: dst.clone() }\n+    pub fn create<'b>(config: ArchiveConfig<'a>, initial_object: &'b Path) -> Archive<'a> {\n+        let ArchiveConfig { handler, dst, lib_search_paths, os, maybe_ar_prog } = config;\n+        run_ar(handler, &maybe_ar_prog, \"crus\", None, [&dst, initial_object]);\n+        Archive {\n+            handler: handler,\n+            dst: dst,\n+            lib_search_paths: lib_search_paths,\n+            os: os,\n+            maybe_ar_prog: maybe_ar_prog\n+        }\n     }\n \n     /// Opens an existing static archive\n-    pub fn open(sess: &'a Session, dst: Path) -> Archive<'a> {\n+    pub fn open(config: ArchiveConfig<'a>) -> Archive<'a> {\n+        let ArchiveConfig { handler, dst, lib_search_paths, os, maybe_ar_prog } = config;\n         assert!(dst.exists());\n-        Archive { sess: sess, dst: dst }\n+        Archive {\n+            handler: handler,\n+            dst: dst,\n+            lib_search_paths: lib_search_paths,\n+            os: os,\n+            maybe_ar_prog: maybe_ar_prog\n+        }\n     }\n \n     /// Adds all of the contents of a native library to this archive. This will\n@@ -120,22 +146,22 @@ impl<'a> Archive<'a> {\n     /// Adds an arbitrary file to this archive\n     pub fn add_file(&mut self, file: &Path, has_symbols: bool) {\n         let cmd = if has_symbols {\"r\"} else {\"rS\"};\n-        run_ar(self.sess, cmd, None, [&self.dst, file]);\n+        run_ar(self.handler, &self.maybe_ar_prog, cmd, None, [&self.dst, file]);\n     }\n \n     /// Removes a file from this archive\n     pub fn remove_file(&mut self, file: &str) {\n-        run_ar(self.sess, \"d\", None, [&self.dst, &Path::new(file)]);\n+        run_ar(self.handler, &self.maybe_ar_prog, \"d\", None, [&self.dst, &Path::new(file)]);\n     }\n \n     /// Updates all symbols in the archive (runs 'ar s' over it)\n     pub fn update_symbols(&mut self) {\n-        run_ar(self.sess, \"s\", None, [&self.dst]);\n+        run_ar(self.handler, &self.maybe_ar_prog, \"s\", None, [&self.dst]);\n     }\n \n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n-        let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n+        let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, [&self.dst]);\n         let output = str::from_utf8(output.output.as_slice()).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n@@ -148,7 +174,7 @@ impl<'a> Archive<'a> {\n \n         // First, extract the contents of the archive to a temporary directory\n         let archive = os::make_absolute(archive);\n-        run_ar(self.sess, \"x\", Some(loc.path()), [&archive]);\n+        run_ar(self.handler, &self.maybe_ar_prog, \"x\", Some(loc.path()), [&archive]);\n \n         // Next, we must rename all of the inputs to \"guaranteed unique names\".\n         // The reason for this is that archives are keyed off the name of the\n@@ -184,23 +210,20 @@ impl<'a> Archive<'a> {\n         // Finally, add all the renamed files to this archive\n         let mut args = vec!(&self.dst);\n         args.extend(inputs.iter());\n-        run_ar(self.sess, \"r\", None, args.as_slice());\n+        run_ar(self.handler, &self.maybe_ar_prog, \"r\", None, args.as_slice());\n         Ok(())\n     }\n \n     fn find_library(&self, name: &str) -> Path {\n-        let (osprefix, osext) = match self.sess.targ_cfg.os {\n+        let (osprefix, osext) = match self.os {\n             abi::OsWin32 => (\"\", \"lib\"), _ => (\"lib\", \"a\"),\n         };\n         // On Windows, static libraries sometimes show up as libfoo.a and other\n         // times show up as foo.lib\n         let oslibname = format!(\"{}{}.{}\", osprefix, name, osext);\n         let unixlibname = format!(\"lib{}.a\", name);\n \n-        let mut rustpath = filesearch::rust_path();\n-        rustpath.push(self.sess.target_filesearch().get_lib_path());\n-        let search = self.sess.opts.addl_lib_search_paths.borrow();\n-        for path in search.iter().chain(rustpath.iter()) {\n+        for path in self.lib_search_paths.iter() {\n             debug!(\"looking for {} inside {}\", name, path.display());\n             let test = path.join(oslibname.as_slice());\n             if test.exists() { return test }\n@@ -209,7 +232,7 @@ impl<'a> Archive<'a> {\n                 if test.exists() { return test }\n             }\n         }\n-        self.sess.fatal(format!(\"could not find native static library `{}`, \\\n+        self.handler.fatal(format!(\"could not find native static library `{}`, \\\n                                  perhaps an -L flag is missing?\",\n                                 name).as_slice());\n     }"}, {"sha": "a552f5421505523f47ae5bc6f7ad46d03252e7ec", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7f6a66f77ef362059328524d54b6b987322d2c36/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6a66f77ef362059328524d54b6b987322d2c36/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=7f6a66f77ef362059328524d54b6b987322d2c36", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::archive::{Archive, METADATA_FILENAME};\n+use super::archive::{Archive, ArchiveConfig, METADATA_FILENAME};\n use super::rpath;\n use super::rpath::RPathConfig;\n use super::svh::Svh;\n@@ -29,6 +29,7 @@ use util::sha2::{Digest, Sha256};\n \n use std::c_str::{ToCStr, CString};\n use std::char;\n+use std::collections::HashSet;\n use std::io::{fs, TempDir, Command};\n use std::io;\n use std::ptr;\n@@ -962,6 +963,17 @@ fn link_binary_output(sess: &Session,\n     out_filename\n }\n \n+fn archive_search_paths(sess: &Session) -> Vec<Path> {\n+    let mut rustpath = filesearch::rust_path();\n+    rustpath.push(sess.target_filesearch().get_lib_path());\n+    // FIXME: Addl lib search paths are an unordered HashSet?\n+    // Shouldn't this search be done in some order?\n+    let addl_lib_paths: HashSet<Path> = sess.opts.addl_lib_search_paths.borrow().clone();\n+    let mut search: Vec<Path> = addl_lib_paths.move_iter().collect();\n+    search.push_all(rustpath.as_slice());\n+    return search;\n+}\n+\n // Create an 'rlib'\n //\n // An rlib in its current incarnation is essentially a renamed .a file. The\n@@ -972,7 +984,15 @@ fn link_rlib<'a>(sess: &'a Session,\n                  trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n                  obj_filename: &Path,\n                  out_filename: &Path) -> Archive<'a> {\n-    let mut a = Archive::create(sess, out_filename, obj_filename);\n+    let handler = &sess.diagnostic().handler;\n+    let config = ArchiveConfig {\n+        handler: handler,\n+        dst: out_filename.clone(),\n+        lib_search_paths: archive_search_paths(sess),\n+        os: sess.targ_cfg.os,\n+        maybe_ar_prog: sess.opts.cg.ar.clone()\n+    };\n+    let mut a = Archive::create(config, obj_filename);\n \n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n@@ -1561,7 +1581,15 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                         sess.abort_if_errors();\n                     }\n                 }\n-                let mut archive = Archive::open(sess, dst.clone());\n+                let handler = &sess.diagnostic().handler;\n+                let config = ArchiveConfig {\n+                    handler: handler,\n+                    dst: dst.clone(),\n+                    lib_search_paths: archive_search_paths(sess),\n+                    os: sess.targ_cfg.os,\n+                    maybe_ar_prog: sess.opts.cg.ar.clone()\n+                };\n+                let mut archive = Archive::open(config);\n                 archive.remove_file(format!(\"{}.o\", name).as_slice());\n                 let files = archive.files();\n                 if files.iter().any(|s| s.as_slice().ends_with(\".o\")) {"}]}