{"sha": "23704740c2e5ddf4e7c184a25d3eed216dd47b82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNzA0NzQwYzJlNWRkZjRlN2MxODRhMjVkM2VlZDIxNmRkNDdiODI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-16T20:33:36Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-16T20:34:28Z"}, "message": "Fix build breakage and include all types in \"types\" section in docs\n\nThe section on types was missing trait types, class types, param\ntypes, and self types. Fixed it.", "tree": {"sha": "7cd7addbfe084ffaaaf2bb0c0d44eda71206f902", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cd7addbfe084ffaaaf2bb0c0d44eda71206f902"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23704740c2e5ddf4e7c184a25d3eed216dd47b82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23704740c2e5ddf4e7c184a25d3eed216dd47b82", "html_url": "https://github.com/rust-lang/rust/commit/23704740c2e5ddf4e7c184a25d3eed216dd47b82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23704740c2e5ddf4e7c184a25d3eed216dd47b82/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "748f2e09096a324d7f2764bd1d54f094a42ef248", "url": "https://api.github.com/repos/rust-lang/rust/commits/748f2e09096a324d7f2764bd1d54f094a42ef248", "html_url": "https://github.com/rust-lang/rust/commit/748f2e09096a324d7f2764bd1d54f094a42ef248"}], "stats": {"total": 127, "additions": 102, "deletions": 25}, "files": [{"sha": "913249af8bb83d1eb03bd4e36a8c914d1a6ba99b", "filename": "doc/rust.md", "status": "modified", "additions": 102, "deletions": 25, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/23704740c2e5ddf4e7c184a25d3eed216dd47b82/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/23704740c2e5ddf4e7c184a25d3eed216dd47b82/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=23704740c2e5ddf4e7c184a25d3eed216dd47b82", "patch": "@@ -593,7 +593,7 @@ There are several kinds of item:\n   * [type definitions](#type-definitions)\n   * [enumerations](#enumerations)\n   * [resources](#resources)\n-  * [interfaces](#interfaces)\n+  * [traits](#traits)\n   * [implementations](#implementations)\n \n Some items form an implicit scope for the declaration of sub-items. In other\n@@ -1012,8 +1012,8 @@ parameter is given a [`copy` bound](#type-kinds).\n fn id<T: copy>(x: T) -> T { x }\n ~~~~\n \n-Similarly, [interface](#interfaces) bounds can be specified for type\n-parameters to allow methods of that interface to be called on values\n+Similarly, [trait](#traits) bounds can be specified for type\n+parameters to allow methods with that trait to be called on values\n of that type.\n \n #### Extern functions\n@@ -1153,11 +1153,11 @@ class file_descriptor {\n       self.fd = fd; self.name = none;\n     }\n     priv {\n-      let mut name: option<str>;\n+      let mut name: option<~str>;\n     }\n-    fn get_name() -> str {\n+    fn get_name() -> ~str {\n       alt self.name {\n-         none    { fail \"File has no name!\"; }\n+         none    { fail ~\"File has no name!\"; }\n          some(n) { n }\n       }\n     }\n@@ -1215,17 +1215,17 @@ class file<A: copy> {\n Classes do not support inheritance, except through traits. As a\n result, all class method dispatch is static (non-virtual).\n \n-A class may implement a trait (see [interfaces](#interfaces)):\n+A class may implement a trait (see [traits](#traits)):\n \n ~~~~\n trait to_str {\n-  fn to_str() -> str;\n+  fn to_str() -> ~str;\n }\n \n class file : to_str {\n   let fd: *libc::FILE;\n   new(fd: *libc::FILE) { self.fd = fd; }\n-  fn to_str() -> str { \"a file\" }\n+  fn to_str() -> ~str { ~\"a file\" }\n }\n ~~~~\n \n@@ -1249,9 +1249,9 @@ The order of fields in a class instance is significant; its runtime\n representation is the same as that of a record with identical fields\n laid out in the same order.\n \n-### Interfaces\n+### Traits\n \n-An _interface item_ describes a set of method types. _[implementation\n+A _trait item_ describes a set of method types. _[implementation\n items](#implementations)_ can be used to provide implementations of\n those methods for a specific type.\n \n@@ -1265,12 +1265,12 @@ iface shape {\n }\n ~~~~\n \n-This defines an interface with two methods. All values which have\n-[implementations](#implementations) of this interface in scope can\n+This defines a trait with two methods. All values that have\n+[implementations](#implementations) of this trait in scope can\n have their `draw` and `bounding_box` methods called, using\n `value.bounding_box()` [syntax](#field-expressions).\n \n-Type parameters can be specified for an interface to make it generic.\n+Type parameters can be specified for a trait to make it generic.\n These appear after the name, using the same syntax used in [generic\n functions](#generic-functions).\n \n@@ -1282,10 +1282,10 @@ iface seq<T> {\n }\n ~~~~\n \n-Generic functions may use interfaces as bounds on their type\n-parameters. This will have two effects: only types that implement the\n-interface can be used to instantiate the parameter, and within the\n-generic function, the methods of the interface can be called on values\n+Generic functions may use traits as bounds on their type\n+parameters. This will have two effects: only types that have the trait\n+may instantiate the parameter, and within the\n+generic function, the methods of the trait can be called on values\n that have the parameter's type. For example:\n \n ~~~~\n@@ -1298,8 +1298,8 @@ fn draw_twice<T: shape>(surface: surface, sh: T) {\n }\n ~~~~\n \n-Interface items also define a type with the same name as the\n-interface. Values of this type are created by\n+Trait items also define a type with the same name as the\n+trait. Values of this type are created by\n [casting](#type-cast-expressions) values (of a type for which an\n implementation of the given interface is in scope) to the interface\n type.\n@@ -1321,7 +1321,7 @@ instantiate type parameters that are bounded on their interface.\n ### Implementations\n \n An _implementation item_ provides an implementation of an\n-[interface](#interfaces) for a type.\n+[interface](#traits) for a type.\n \n ~~~~\n # type point = {x: float, y: float};\n@@ -1682,7 +1682,7 @@ When the type of the expression to the left of the dot is a boxed\n record, it is automatically derferenced to make the field access\n possible.\n \n-Field access syntax is overloaded for [interface method](#interfaces)\n+Field access syntax is overloaded for [trait method](#traits)\n access. When no matching field is found, or the expression to the left\n of the dot is not a (boxed) record, an\n [implementation](#implementations) that matches this type and the\n@@ -2067,11 +2067,10 @@ conditional expression evaluates to `false`, the `while` expression completes.\n An example:\n \n ~~~~\n-# let mut i = 0;\n-# let println = io::println;\n+let mut i = 0;\n \n while i < 10 {\n-    println(~\"hello\\n\");\n+    io::println(~\"hello\\n\");\n     i = i + 1;\n }\n ~~~~\n@@ -2758,6 +2757,84 @@ let bo: binop = add;\n x = bo(5,7);\n ~~~~~~~~\n \n+### Trait types\n+\n+Every trait item (see [traits](#traits)) defines a type with the same name\n+as the trait. For a trait `T`, cast expressions introduce values of type `T`:\n+\n+~~~~~~~~\n+// doc extractor doesn't recognize trait -- fix it\n+iface printable {\n+  fn to_str() -> ~str;\n+}\n+\n+impl of printable for ~str {\n+  fn to_str() -> ~str { self }\n+}\n+\n+fn print(a: printable) {\n+   io::println(a.to_str());\n+}\n+\n+fn main() {\n+   print(~\"meow\" as printable);\n+}\n+~~~~~~~~\n+\n+In this example, the trait `printable` occurs as a type in both the type signature of\n+`print`, and the cast expression in `main`.\n+\n+### Class types\n+\n+Every class item defines a type. See [classes](#classes).\n+\n+### Type parameters\n+\n+Within the body of an item that has type parameter declarations, the names of its type parameters are types:\n+\n+~~~~~~~\n+fn map<A: copy, B: copy>(f: fn(A) -> B, xs: ~[A]) -> ~[B] {\n+   if xs.len() == 0 { ret ~[]; }\n+   let first: B = f(xs[0]);\n+   let rest: ~[B] = map(f, xs.slice(1, xs.len()));\n+   ret ~[first] + rest;\n+}\n+~~~~~~~\n+\n+Here, `first` has type `B`, referring to `map`'s `B` type parameter; and `rest` has\n+type `~[B]`, a vector type with element type `B`.\n+\n+### Self type\n+\n+The special type `self` has a meaning within methods inside a class or\n+impl item. It refers to the type of the implicit `self` argument. For\n+example, in:\n+\n+~~~~~~\n+iface printable {\n+  fn to_str() -> ~str;\n+}\n+\n+impl of printable for ~str {\n+  fn to_str() -> ~str { self }\n+}\n+~~~~~~\n+\n+`self` refers to the value of type `str` that is the receiver for a\n+call to the method `to_str`. Similarly, in a class declaration:\n+\n+~~~~~~\n+class cat {\n+  let mut meows: uint;\n+  new() { self.meows = 0; }\n+  fn meow() { self.meows = self.meows + 1; }\n+}\n+~~~~~~\n+\n+`self` refers to the class instance that is the receiver of the method\n+(except in the constructor `new`, where `self` is the class instance\n+that the constructor implicitly returns).\n+\n ## Type kinds\n \n Types in Rust are categorized into three kinds, based on whether they"}]}