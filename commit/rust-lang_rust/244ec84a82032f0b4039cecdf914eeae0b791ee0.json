{"sha": "244ec84a82032f0b4039cecdf914eeae0b791ee0", "node_id": "C_kwDOAAsO6NoAKDI0NGVjODRhODIwMzJmMGI0MDM5Y2VjZGY5MTRlZWFlMGI3OTFlZTA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-11T14:43:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-11T14:43:13Z"}, "message": "Rollup merge of #108071 - compiler-errors:new-solver-caching, r=lcnr\n\nImplement goal caching with the new solver\n\nMaybe it's wrong, idk. Opening mostly for first impressions before I go to sleep.\n\nr? ``@lcnr,`` cc ``@cjgillot``", "tree": {"sha": "8f55d40745f751ded9d6319c1693f3723a39ce8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f55d40745f751ded9d6319c1693f3723a39ce8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/244ec84a82032f0b4039cecdf914eeae0b791ee0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkDJOBCRBK7hj4Ov3rIwAAP+gIAFrBxLdnXsocQwCb0NGtZOMG\njcm55/Icp7rrj4/x2/Zh/5X2q/0ax0GXCe5jPBtKWFKZoq4qLwAGxTIlVHZebAOZ\nF3St2NNbx+XwBfX3wm1kw1a0cpHhQbMJWLyivsuyv8d1zZi3BoCsD3NL5EARZwU3\nhrR/GJ+fcAjWIaaw/+/IloyGrSjCUI/LJ9aA4bq6ypqa9RLfVGXjgmMpwO0+b7eP\ngJAsh04RNuMAmoe7YtyAxVsR0RSH26N5lc8cAV88T58lS9R6u6FeLreT5wRCUGrq\n+PzYVT2YdTf2QCoDoqVBngGipueNk5V6V6l8frBRd/VORu69dcrli3hTsVqE+uM=\n=lHDw\n-----END PGP SIGNATURE-----\n", "payload": "tree 8f55d40745f751ded9d6319c1693f3723a39ce8e\nparent d47d4ad4b223710341d97e46ceb306883f0da829\nparent d21e4d8411aef3baa776685b7b51e20cc75c7329\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678545793 +0100\ncommitter GitHub <noreply@github.com> 1678545793 +0100\n\nRollup merge of #108071 - compiler-errors:new-solver-caching, r=lcnr\n\nImplement goal caching with the new solver\n\nMaybe it's wrong, idk. Opening mostly for first impressions before I go to sleep.\n\nr? ``@lcnr,`` cc ``@cjgillot``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/244ec84a82032f0b4039cecdf914eeae0b791ee0", "html_url": "https://github.com/rust-lang/rust/commit/244ec84a82032f0b4039cecdf914eeae0b791ee0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/244ec84a82032f0b4039cecdf914eeae0b791ee0/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d47d4ad4b223710341d97e46ceb306883f0da829", "url": "https://api.github.com/repos/rust-lang/rust/commits/d47d4ad4b223710341d97e46ceb306883f0da829", "html_url": "https://github.com/rust-lang/rust/commit/d47d4ad4b223710341d97e46ceb306883f0da829"}, {"sha": "d21e4d8411aef3baa776685b7b51e20cc75c7329", "url": "https://api.github.com/repos/rust-lang/rust/commits/d21e4d8411aef3baa776685b7b51e20cc75c7329", "html_url": "https://github.com/rust-lang/rust/commit/d21e4d8411aef3baa776685b7b51e20cc75c7329"}], "stats": {"total": 356, "additions": 183, "deletions": 173}, "files": [{"sha": "77c67c14ecc55a88685987b502f98e1eca4aa77d", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=244ec84a82032f0b4039cecdf914eeae0b791ee0", "patch": "@@ -53,6 +53,12 @@ pub struct Obligation<'tcx, T> {\n     pub recursion_depth: usize,\n }\n \n+impl<'tcx, P> From<Obligation<'tcx, P>> for solve::Goal<'tcx, P> {\n+    fn from(value: Obligation<'tcx, P>) -> Self {\n+        solve::Goal { param_env: value.param_env, predicate: value.predicate }\n+    }\n+}\n+\n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n "}, {"sha": "92d3e73e683cd832ec640ab1f3a6ed332795aca0", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=244ec84a82032f0b4039cecdf914eeae0b791ee0", "patch": "@@ -1,12 +1,104 @@\n use std::ops::ControlFlow;\n \n use rustc_data_structures::intern::Interned;\n+use rustc_query_system::cache::Cache;\n \n-use crate::infer::canonical::QueryRegionConstraints;\n+use crate::infer::canonical::{CanonicalVarValues, QueryRegionConstraints};\n+use crate::traits::query::NoSolution;\n+use crate::traits::Canonical;\n use crate::ty::{\n-    FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable, TypeVisitor,\n+    self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable,\n+    TypeVisitor,\n };\n \n+pub type EvaluationCache<'tcx> = Cache<CanonicalGoal<'tcx>, QueryResult<'tcx>>;\n+\n+/// A goal is a statement, i.e. `predicate`, we want to prove\n+/// given some assumptions, i.e. `param_env`.\n+///\n+/// Most of the time the `param_env` contains the `where`-bounds of the function\n+/// we're currently typechecking while the `predicate` is some trait bound.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Goal<'tcx, P> {\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub predicate: P,\n+}\n+\n+impl<'tcx, P> Goal<'tcx, P> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: impl ToPredicate<'tcx, P>,\n+    ) -> Goal<'tcx, P> {\n+        Goal { param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+\n+    /// Updates the goal to one with a different `predicate` but the same `param_env`.\n+    pub fn with<Q>(self, tcx: TyCtxt<'tcx>, predicate: impl ToPredicate<'tcx, Q>) -> Goal<'tcx, Q> {\n+        Goal { param_env: self.param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Response<'tcx> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    /// Additional constraints returned by this query.\n+    pub external_constraints: ExternalConstraints<'tcx>,\n+    pub certainty: Certainty,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum Certainty {\n+    Yes,\n+    Maybe(MaybeCause),\n+}\n+\n+impl Certainty {\n+    pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n+\n+    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n+    /// use this function to unify the certainty of these goals\n+    pub fn unify_and(self, other: Certainty) -> Certainty {\n+        match (self, other) {\n+            (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n+            (Certainty::Yes, Certainty::Maybe(_)) => other,\n+            (Certainty::Maybe(_), Certainty::Yes) => self,\n+            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n+                Certainty::Maybe(MaybeCause::Overflow)\n+            }\n+            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n+            // may still result in failure.\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n+            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n+                Certainty::Maybe(MaybeCause::Ambiguity)\n+            }\n+        }\n+    }\n+}\n+\n+/// Why we failed to evaluate a goal.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum MaybeCause {\n+    /// We failed due to ambiguity. This ambiguity can either\n+    /// be a true ambiguity, i.e. there are multiple different answers,\n+    /// or we hit a case where we just don't bother, e.g. `?x: Trait` goals.\n+    Ambiguity,\n+    /// We gave up due to an overflow, most often by hitting the recursion limit.\n+    Overflow,\n+}\n+\n+pub type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n+\n+pub type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n+\n+/// The result of evaluating a canonical query.\n+///\n+/// FIXME: We use a different type than the existing canonical queries. This is because\n+/// we need to add a `Certainty` for `overflow` and may want to restructure this code without\n+/// having to worry about changes to currently used code. Once we've made progress on this\n+/// solver, merge the two responses again.\n+pub type QueryResult<'tcx> = Result<CanonicalResponse<'tcx>, NoSolution>;\n+\n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n pub struct ExternalConstraints<'tcx>(pub(crate) Interned<'tcx, ExternalConstraintsData<'tcx>>);\n "}, {"sha": "e95f6f91357ef18a74ed44b6866ba8e7c412c5c2", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=244ec84a82032f0b4039cecdf914eeae0b791ee0", "patch": "@@ -17,6 +17,7 @@ use crate::mir::{\n };\n use crate::thir::Thir;\n use crate::traits;\n+use crate::traits::solve;\n use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n@@ -537,6 +538,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Merge this with `selection_cache`?\n     pub evaluation_cache: traits::EvaluationCache<'tcx>,\n \n+    /// Caches the results of goal evaluation in the new solver.\n+    pub new_solver_evaluation_cache: solve::EvaluationCache<'tcx>,\n+\n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n \n@@ -712,6 +716,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             pred_rcache: Default::default(),\n             selection_cache: Default::default(),\n             evaluation_cache: Default::default(),\n+            new_solver_evaluation_cache: Default::default(),\n             data_layout,\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n         }"}, {"sha": "b092503a007ecffc4783bf52d2c247a486d7ab8b", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=244ec84a82032f0b4039cecdf914eeae0b791ee0", "patch": "@@ -2,11 +2,12 @@\n \n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n+use super::EvalCtxt;\n use itertools::Itertools;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n+use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::fmt::Debug;"}, {"sha": "55d361b120441cc616fa73430fc998166e571db4", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 5, "deletions": 92, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=244ec84a82032f0b4039cecdf914eeae0b791ee0", "patch": "@@ -21,11 +21,13 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::Obligation;\n-use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n+use rustc_middle::traits::solve::{\n+    CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n+    Goal, MaybeCause, QueryResult, Response,\n+};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n-    CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, ToPredicate, TypeOutlivesPredicate,\n+    CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n use rustc_span::DUMMY_SP;\n \n@@ -43,45 +45,6 @@ mod trait_goals;\n pub use eval_ctxt::EvalCtxt;\n pub use fulfill::FulfillmentCtxt;\n \n-/// A goal is a statement, i.e. `predicate`, we want to prove\n-/// given some assumptions, i.e. `param_env`.\n-///\n-/// Most of the time the `param_env` contains the `where`-bounds of the function\n-/// we're currently typechecking while the `predicate` is some trait bound.\n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub struct Goal<'tcx, P> {\n-    param_env: ty::ParamEnv<'tcx>,\n-    predicate: P,\n-}\n-\n-impl<'tcx, P> Goal<'tcx, P> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        predicate: impl ToPredicate<'tcx, P>,\n-    ) -> Goal<'tcx, P> {\n-        Goal { param_env, predicate: predicate.to_predicate(tcx) }\n-    }\n-\n-    /// Updates the goal to one with a different `predicate` but the same `param_env`.\n-    fn with<Q>(self, tcx: TyCtxt<'tcx>, predicate: impl ToPredicate<'tcx, Q>) -> Goal<'tcx, Q> {\n-        Goal { param_env: self.param_env, predicate: predicate.to_predicate(tcx) }\n-    }\n-}\n-\n-impl<'tcx, P> From<Obligation<'tcx, P>> for Goal<'tcx, P> {\n-    fn from(obligation: Obligation<'tcx, P>) -> Goal<'tcx, P> {\n-        Goal { param_env: obligation.param_env, predicate: obligation.predicate }\n-    }\n-}\n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub struct Response<'tcx> {\n-    pub var_values: CanonicalVarValues<'tcx>,\n-    /// Additional constraints returned by this query.\n-    pub external_constraints: ExternalConstraints<'tcx>,\n-    pub certainty: Certainty,\n-}\n-\n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n }\n@@ -94,56 +57,6 @@ impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub enum Certainty {\n-    Yes,\n-    Maybe(MaybeCause),\n-}\n-\n-impl Certainty {\n-    pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n-\n-    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n-    /// use this function to unify the certainty of these goals\n-    pub fn unify_and(self, other: Certainty) -> Certainty {\n-        match (self, other) {\n-            (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n-            (Certainty::Yes, Certainty::Maybe(_)) => other,\n-            (Certainty::Maybe(_), Certainty::Yes) => self,\n-            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n-                Certainty::Maybe(MaybeCause::Overflow)\n-            }\n-            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n-            // may still result in failure.\n-            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n-            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n-                Certainty::Maybe(MaybeCause::Ambiguity)\n-            }\n-        }\n-    }\n-}\n-\n-/// Why we failed to evaluate a goal.\n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub enum MaybeCause {\n-    /// We failed due to ambiguity. This ambiguity can either\n-    /// be a true ambiguity, i.e. there are multiple different answers,\n-    /// or we hit a case where we just don't bother, e.g. `?x: Trait` goals.\n-    Ambiguity,\n-    /// We gave up due to an overflow, most often by hitting the recursion limit.\n-    Overflow,\n-}\n-\n-type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n-type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n-/// The result of evaluating a canonical query.\n-///\n-/// FIXME: We use a different type than the existing canonical queries. This is because\n-/// we need to add a `Certainty` for `overflow` and may want to restructure this code without\n-/// having to worry about changes to currently used code. Once we've made progress on this\n-/// solver, merge the two responses again.\n-pub type QueryResult<'tcx> = Result<CanonicalResponse<'tcx>, NoSolution>;\n-\n pub trait InferCtxtEvalExt<'tcx> {\n     /// Evaluates a goal from **outside** of the trait solver.\n     ///"}, {"sha": "e206658b4b90d2cc8374c524048c3c028d06574a", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=244ec84a82032f0b4039cecdf914eeae0b791ee0", "patch": "@@ -2,7 +2,7 @@ use crate::traits::{specialization_graph, translate_substs};\n \n use super::assembly;\n use super::trait_goals::structural_traits;\n-use super::{Certainty, EvalCtxt, Goal, QueryResult};\n+use super::EvalCtxt;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -11,6 +11,7 @@ use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n+use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, QueryResult};\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::ProjectionPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -512,7 +513,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     fn consider_builtin_dyn_upcast_candidates(\n         _ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-    ) -> Vec<super::CanonicalResponse<'tcx>> {\n+    ) -> Vec<CanonicalResponse<'tcx>> {\n         bug!(\"`Unsize` does not have an associated type: {:?}\", goal);\n     }\n "}, {"sha": "d1b4fa554c5f2f5e1e3a73009d9be82cdade3cc4", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=244ec84a82032f0b4039cecdf914eeae0b791ee0", "patch": "@@ -8,12 +8,10 @@\n //!\n //! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n //! before then or if I still haven't done that before January 2023.\n-use super::overflow::OverflowData;\n use super::StackDepth;\n-use crate::solve::{CanonicalGoal, QueryResult};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::traits::solve::{CanonicalGoal, QueryResult};\n \n rustc_index::newtype_index! {\n     pub struct EntryIndex {}\n@@ -98,26 +96,3 @@ impl<'tcx> ProvisionalCache<'tcx> {\n         self.entries[entry_index].response\n     }\n }\n-\n-pub(super) fn try_move_finished_goal_to_global_cache<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    overflow_data: &mut OverflowData,\n-    stack: &IndexVec<super::StackDepth, super::StackElem<'tcx>>,\n-    goal: CanonicalGoal<'tcx>,\n-    response: QueryResult<'tcx>,\n-) {\n-    // We move goals to the global cache if we either did not hit an overflow or if it's\n-    // the root goal as that will now always hit the same overflow limit.\n-    //\n-    // NOTE: We cannot move any non-root goals to the global cache even if their final result\n-    // isn't impacted by the overflow as that goal still has unstable query dependencies\n-    // because it didn't go its full depth.\n-    //\n-    // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n-    // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n-    let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n-    if should_cache_globally {\n-        // FIXME: move the provisional entry to the global cache.\n-        let _ = (tcx, goal, response);\n-    }\n-}"}, {"sha": "f1b840aac556abfaf4d2d45278a5f0eb02c4f57d", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 61, "deletions": 46, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=244ec84a82032f0b4039cecdf914eeae0b791ee0", "patch": "@@ -2,11 +2,12 @@ mod cache;\n mod overflow;\n \n use self::cache::ProvisionalEntry;\n-use super::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n pub(super) use crate::solve::search_graph::overflow::OverflowHandler;\n use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::dep_graph::DepKind;\n+use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::TyCtxt;\n use std::{collections::hash_map::Entry, mem};\n \n@@ -139,10 +140,9 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// updated the provisional cache and we have to recompute the current goal.\n     ///\n     /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n-    #[instrument(level = \"debug\", skip(self, tcx, actual_goal), ret)]\n+    #[instrument(level = \"debug\", skip(self, actual_goal), ret)]\n     fn try_finalize_goal(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n         actual_goal: CanonicalGoal<'tcx>,\n         response: QueryResult<'tcx>,\n     ) -> bool {\n@@ -176,72 +176,87 @@ impl<'tcx> SearchGraph<'tcx> {\n             self.stack.push(StackElem { goal, has_been_used: false });\n             false\n         } else {\n-            self.try_move_finished_goal_to_global_cache(tcx, stack_elem);\n             true\n         }\n     }\n \n-    fn try_move_finished_goal_to_global_cache(\n+    pub(super) fn with_new_goal(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        stack_elem: StackElem<'tcx>,\n-    ) {\n-        let StackElem { goal, .. } = stack_elem;\n+        canonical_goal: CanonicalGoal<'tcx>,\n+        mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(result) = tcx.new_solver_evaluation_cache.get(&canonical_goal, tcx) {\n+            return result;\n+        }\n+\n+        match self.try_push_stack(tcx, canonical_goal) {\n+            Ok(()) => {}\n+            // Our goal is already on the stack, eager return.\n+            Err(response) => return response,\n+        }\n+\n+        // This is for global caching, so we properly track query dependencies.\n+        // Everything that affects the `Result` should be performed within this\n+        // `with_anon_task` closure.\n+        let (result, dep_node) = tcx.dep_graph.with_anon_task(tcx, DepKind::TraitSelect, || {\n+            self.repeat_while_none(\n+                |this| {\n+                    let result = this.deal_with_overflow(tcx, canonical_goal);\n+                    let _ = this.stack.pop().unwrap();\n+                    result\n+                },\n+                |this| {\n+                    let result = loop_body(this);\n+                    this.try_finalize_goal(canonical_goal, result).then(|| result)\n+                },\n+            )\n+        });\n+\n         let cache = &mut self.provisional_cache;\n-        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n+        let provisional_entry_index = *cache.lookup_table.get(&canonical_goal).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n         let depth = provisional_entry.depth;\n \n         // If not, we're done with this goal.\n         //\n         // Check whether that this goal doesn't depend on a goal deeper on the stack\n-        // and if so, move it and all nested goals to the global cache.\n+        // and if so, move it to the global cache.\n         //\n         // Note that if any nested goal were to depend on something deeper on the stack,\n         // this would have also updated the depth of the current goal.\n         if depth == self.stack.next_index() {\n-            for (i, entry) in cache.entries.drain_enumerated(provisional_entry_index.index()..) {\n+            // If the current goal is the head of a cycle, we drop all other\n+            // cycle participants without moving them to the global cache.\n+            let other_cycle_participants = provisional_entry_index.index() + 1;\n+            for (i, entry) in cache.entries.drain_enumerated(other_cycle_participants..) {\n                 let actual_index = cache.lookup_table.remove(&entry.goal);\n                 debug_assert_eq!(Some(i), actual_index);\n                 debug_assert!(entry.depth == depth);\n-                cache::try_move_finished_goal_to_global_cache(\n-                    tcx,\n-                    &mut self.overflow_data,\n-                    &self.stack,\n-                    entry.goal,\n-                    entry.response,\n-                );\n             }\n-        }\n-    }\n \n-    pub(super) fn with_new_goal(\n-        &mut self,\n-        tcx: TyCtxt<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n-        mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        match self.try_push_stack(tcx, canonical_goal) {\n-            Ok(()) => {}\n-            // Our goal is already on the stack, eager return.\n-            Err(response) => return response,\n+            let current_goal = cache.entries.pop().unwrap();\n+            let actual_index = cache.lookup_table.remove(&current_goal.goal);\n+            debug_assert_eq!(Some(provisional_entry_index), actual_index);\n+            debug_assert!(current_goal.depth == depth);\n+\n+            // We move the root goal to the global cache if we either did not hit an overflow or if it's\n+            // the root goal as that will now always hit the same overflow limit.\n+            //\n+            // NOTE: We cannot move any non-root goals to the global cache. When replaying the root goal's\n+            // dependencies, our non-root goal may no longer appear as child of the root goal.\n+            //\n+            // See https://github.com/rust-lang/rust/pull/108071 for some additional context.\n+            let should_cache_globally = !self.overflow_data.did_overflow() || self.stack.is_empty();\n+            if should_cache_globally {\n+                tcx.new_solver_evaluation_cache.insert(\n+                    current_goal.goal,\n+                    dep_node,\n+                    current_goal.response,\n+                );\n+            }\n         }\n \n-        self.repeat_while_none(\n-            |this| {\n-                let result = this.deal_with_overflow(tcx, canonical_goal);\n-                let stack_elem = this.stack.pop().unwrap();\n-                this.try_move_finished_goal_to_global_cache(tcx, stack_elem);\n-                result\n-            },\n-            |this| {\n-                let result = loop_body(this);\n-                if this.try_finalize_goal(tcx, canonical_goal, result) {\n-                    Some(result)\n-                } else {\n-                    None\n-                }\n-            },\n-        )\n+        result\n     }\n }"}, {"sha": "7c9e63f529b5503a78a9d606fba3b1eb5fc8f329", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/overflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs?ref=244ec84a82032f0b4039cecdf914eeae0b791ee0", "patch": "@@ -1,10 +1,11 @@\n use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::traits::solve::{Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Limit;\n \n use super::SearchGraph;\n-use crate::solve::{response_no_constraints, Certainty, EvalCtxt, MaybeCause, QueryResult};\n+use crate::solve::{response_no_constraints, EvalCtxt};\n \n /// When detecting a solver overflow, we return ambiguity. Overflow can be\n /// *hidden* by either a fatal error in an **AND** or a trivial success in an **OR**."}, {"sha": "0669975d63819174d57d86c2472b2672d1775810", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=244ec84a82032f0b4039cecdf914eeae0b791ee0", "patch": "@@ -2,12 +2,12 @@\n \n use std::iter;\n \n-use super::assembly;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n+use super::{assembly, EvalCtxt};\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::supertraits;\n+use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, QueryResult};\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_middle::ty::{TraitPredicate, TypeVisitableExt};"}, {"sha": "1420c25c922801e70298c97766a64d61f2621131", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244ec84a82032f0b4039cecdf914eeae0b791ee0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=244ec84a82032f0b4039cecdf914eeae0b791ee0", "patch": "@@ -1,9 +1,10 @@\n+use rustc_middle::traits::solve::{Certainty, Goal, MaybeCause};\n use rustc_middle::ty;\n use rustc_session::config::TraitSolver;\n \n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferCtxt;\n-use crate::solve::{Certainty, Goal, InferCtxtEvalExt, MaybeCause};\n+use crate::solve::InferCtxtEvalExt;\n use crate::traits::{EvaluationResult, OverflowError, PredicateObligation, SelectionContext};\n \n pub trait InferCtxtExt<'tcx> {"}]}