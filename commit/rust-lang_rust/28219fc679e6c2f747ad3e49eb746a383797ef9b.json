{"sha": "28219fc679e6c2f747ad3e49eb746a383797ef9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MjE5ZmM2NzllNmMyZjc0N2FkM2U0OWViNzQ2YTM4Mzc5N2VmOWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-04T20:45:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:10Z"}, "message": "Remove usage of ~fn() from uv async/idle", "tree": {"sha": "264c95902202c54f0978a483b6b932cd13462d6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/264c95902202c54f0978a483b6b932cd13462d6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28219fc679e6c2f747ad3e49eb746a383797ef9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28219fc679e6c2f747ad3e49eb746a383797ef9b", "html_url": "https://github.com/rust-lang/rust/commit/28219fc679e6c2f747ad3e49eb746a383797ef9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28219fc679e6c2f747ad3e49eb746a383797ef9b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9286d5113d843e65fb13ff0cf142c1bfb10124f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9286d5113d843e65fb13ff0cf142c1bfb10124f7", "html_url": "https://github.com/rust-lang/rust/commit/9286d5113d843e65fb13ff0cf142c1bfb10124f7"}], "stats": {"total": 545, "additions": 279, "deletions": 266}, "files": [{"sha": "27f6439a12d4774274997cd713b18ddb0be3bb06", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 133, "deletions": 29, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=28219fc679e6c2f747ad3e49eb746a383797ef9b", "patch": "@@ -8,51 +8,155 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::cast;\n use std::libc::c_int;\n+use std::rt::rtio::{Callback, RemoteCallback};\n+use std::unstable::sync::Exclusive;\n \n use uvll;\n-use super::{Watcher, Loop, NativeHandle, AsyncCallback, WatcherInterop};\n-use super::status_to_maybe_uv_error;\n+use super::{Loop, UvHandle};\n \n-pub struct AsyncWatcher(*uvll::uv_async_t);\n-impl Watcher for AsyncWatcher { }\n+// The entire point of async is to call into a loop from other threads so it\n+// does not need to home.\n+pub struct AsyncWatcher {\n+    handle: *uvll::uv_async_t,\n+\n+    // A flag to tell the callback to exit, set from the dtor. This is\n+    // almost never contested - only in rare races with the dtor.\n+    exit_flag: Exclusive<bool>\n+}\n+\n+struct Payload {\n+    callback: ~Callback,\n+    exit_flag: Exclusive<bool>,\n+}\n \n impl AsyncWatcher {\n-    pub fn new(loop_: &mut Loop, cb: AsyncCallback) -> AsyncWatcher {\n+    pub fn new(loop_: &mut Loop, cb: ~Callback) -> AsyncWatcher {\n+        let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n+        assert_eq!(unsafe {\n+            uvll::async_init(loop_.native_handle(), handle, async_cb)\n+        }, 0);\n+        let flag = Exclusive::new(false);\n+        let payload = ~Payload { callback: cb, exit_flag: flag.clone() };\n         unsafe {\n-            let handle = uvll::malloc_handle(uvll::UV_ASYNC);\n-            assert!(handle.is_not_null());\n-            let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            let data = watcher.get_watcher_data();\n-            data.async_cb = Some(cb);\n-            assert_eq!(0, uvll::uv_async_init(loop_.native_handle(), handle, async_cb));\n-            return watcher;\n+            let payload: *u8 = cast::transmute(payload);\n+            uvll::set_data_for_uv_handle(handle, payload);\n         }\n+        return AsyncWatcher { handle: handle, exit_flag: flag, };\n+    }\n+}\n \n-        extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n-            let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n-            let status = status_to_maybe_uv_error(status);\n-            let data = watcher.get_watcher_data();\n-            let cb = data.async_cb.get_ref();\n-            (*cb)(watcher, status);\n-        }\n+impl UvHandle<uvll::uv_async_t> for AsyncWatcher {\n+    fn uv_handle(&self) -> *uvll::uv_async_t { self.handle }\n+    unsafe fn from_uv_handle<'a>(h: &'a *T) -> &'a mut AsyncWatcher {\n+        fail!(\"async watchers can't be built from their handles\");\n     }\n+}\n+\n+extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n+    assert!(status == 0);\n+    let payload: &mut Payload = unsafe {\n+        cast::transmute(uvll::get_data_for_uv_handle(handle))\n+    };\n+\n+    // The synchronization logic here is subtle. To review,\n+    // the uv async handle type promises that, after it is\n+    // triggered the remote callback is definitely called at\n+    // least once. UvRemoteCallback needs to maintain those\n+    // semantics while also shutting down cleanly from the\n+    // dtor. In our case that means that, when the\n+    // UvRemoteCallback dtor calls `async.send()`, here `f` is\n+    // always called later.\n+\n+    // In the dtor both the exit flag is set and the async\n+    // callback fired under a lock.  Here, before calling `f`,\n+    // we take the lock and check the flag. Because we are\n+    // checking the flag before calling `f`, and the flag is\n+    // set under the same lock as the send, then if the flag\n+    // is set then we're guaranteed to call `f` after the\n+    // final send.\n+\n+    // If the check was done after `f()` then there would be a\n+    // period between that call and the check where the dtor\n+    // could be called in the other thread, missing the final\n+    // callback while still destroying the handle.\n+\n+    let should_exit = unsafe {\n+        payload.exit_flag.with_imm(|&should_exit| should_exit)\n+    };\n+\n+    payload.callback.call();\n+\n+    if should_exit {\n+        unsafe { uvll::close(handle, close_cb) }\n+    }\n+}\n \n-    pub fn send(&mut self) {\n+extern fn close_cb(handle: *uvll::uv_handle_t) {\n+    // drop the payload\n+    let _payload: ~Payload = unsafe {\n+        cast::transmute(uvll::get_data_for_uv_handle(handle))\n+    };\n+    // and then free the handle\n+    unsafe { uvll::free_handle(handle) }\n+}\n+\n+impl RemoteCallback for AsyncWatcher {\n+    fn fire(&mut self) {\n+        unsafe { uvll::async_send(self.handle) }\n+    }\n+}\n+\n+impl Drop for AsyncWatcher {\n+    fn drop(&mut self) {\n         unsafe {\n-            let handle = self.native_handle();\n-            uvll::uv_async_send(handle);\n+            do self.exit_flag.with |should_exit| {\n+                // NB: These two things need to happen atomically. Otherwise\n+                // the event handler could wake up due to a *previous*\n+                // signal and see the exit flag, destroying the handle\n+                // before the final send.\n+                *should_exit = true;\n+                uvll::async_send(self.handle)\n+            }\n         }\n     }\n }\n \n-impl NativeHandle<*uvll::uv_async_t> for AsyncWatcher {\n-    fn from_native_handle(handle: *uvll::uv_async_t) -> AsyncWatcher {\n-        AsyncWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_async_t {\n-        match self { &AsyncWatcher(ptr) => ptr }\n+#[cfg(test)]\n+mod test_remote {\n+    use std::cell::Cell;\n+    use std::rt::test::*;\n+    use std::rt::thread::Thread;\n+    use std::rt::tube::Tube;\n+    use std::rt::rtio::EventLoop;\n+    use std::rt::local::Local;\n+    use std::rt::sched::Scheduler;\n+\n+    #[test]\n+    fn test_uv_remote() {\n+        do run_in_mt_newsched_task {\n+            let mut tube = Tube::new();\n+            let tube_clone = tube.clone();\n+            let remote_cell = Cell::new_empty();\n+            do Local::borrow |sched: &mut Scheduler| {\n+                let tube_clone = tube_clone.clone();\n+                let tube_clone_cell = Cell::new(tube_clone);\n+                let remote = do sched.event_loop.remote_callback {\n+                    // This could be called multiple times\n+                    if !tube_clone_cell.is_empty() {\n+                        tube_clone_cell.take().send(1);\n+                    }\n+                };\n+                remote_cell.put_back(remote);\n+            }\n+            let thread = do Thread::start {\n+                remote_cell.take().fire();\n+            };\n+\n+            assert!(tube.recv() == 1);\n+            thread.join();\n+        }\n     }\n }\n "}, {"sha": "da3ddacef6bbb44e7b735035b2fd7ced29cfec4a", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 71, "deletions": 43, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=28219fc679e6c2f747ad3e49eb746a383797ef9b", "patch": "@@ -8,70 +8,98 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::libc::c_int;\n+use std::cast;\n+use std::libc::{c_int, c_void};\n \n use uvll;\n-use super::{Watcher, Loop, NativeHandle, IdleCallback, status_to_maybe_uv_error};\n-\n-pub struct IdleWatcher(*uvll::uv_idle_t);\n-impl Watcher for IdleWatcher { }\n+use super::{Loop, UvHandle};\n+use std::rt::rtio::{Callback, PausibleIdleCallback};\n+\n+pub struct IdleWatcher {\n+    handle: *uvll::uv_idle_t,\n+    idle_flag: bool,\n+    closed: bool,\n+    callback: Option<~Callback>,\n+}\n \n impl IdleWatcher {\n-    pub fn new(loop_: &mut Loop) -> IdleWatcher {\n+    pub fn new(loop_: &mut Loop) -> ~IdleWatcher {\n+        let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n+        assert_eq!(unsafe {\n+            uvll::idle_init(loop_.native_handle(), handle)\n+        }, 0);\n+        let me = ~IdleWatcher {\n+            handle: handle,\n+            idle_flag: false,\n+            closed: false,\n+            callback: None,\n+        };\n+        return me.install();\n+    }\n+\n+    pub fn onetime(loop_: &mut Loop, f: proc()) {\n+        let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n         unsafe {\n-            let handle = uvll::malloc_handle(uvll::UV_IDLE);\n-            assert!(handle.is_not_null());\n-            assert_eq!(uvll::uv_idle_init(loop_.native_handle(), handle), 0);\n-            let mut watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            return watcher\n+            assert_eq!(uvll::idle_init(loop_.native_handle(), handle), 0);\n+            let data: *c_void = cast::transmute(~f);\n+            uvll::set_data_for_uv_handle(handle, data);\n+            assert_eq!(uvll::idle_start(handle, onetime_cb), 0)\n         }\n-    }\n \n-    pub fn start(&mut self, cb: IdleCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            data.idle_cb = Some(cb);\n+        extern fn onetime_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+            assert_eq!(status, 0);\n+            unsafe {\n+                let data = uvll::get_data_for_uv_handle(handle);\n+                let f: ~proc() = cast::transmute(data);\n+                (*f)();\n+                uvll::idle_stop(handle);\n+                uvll::close(handle, close_cb);\n+            }\n         }\n \n-        unsafe {\n-            assert_eq!(uvll::uv_idle_start(self.native_handle(), idle_cb), 0)\n+        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+            unsafe { uvll::free_handle(handle) }\n         }\n     }\n+}\n \n-    pub fn restart(&mut self) {\n-        unsafe {\n-            assert!(self.get_watcher_data().idle_cb.is_some());\n-            assert_eq!(uvll::uv_idle_start(self.native_handle(), idle_cb), 0)\n+impl PausibleIdleCallback for IdleWatcher {\n+    fn start(&mut self, cb: ~Callback) {\n+        assert!(self.callback.is_none());\n+        self.callback = Some(cb);\n+        assert_eq!(unsafe { uvll::idle_start(self.handle, idle_cb) }, 0)\n+        self.idle_flag = true;\n+    }\n+    fn pause(&mut self) {\n+        if self.idle_flag == true {\n+            assert_eq!(unsafe {uvll::idle_stop(self.handle) }, 0);\n+            self.idle_flag = false;\n         }\n     }\n-\n-    pub fn stop(&mut self) {\n-        // NB: Not resetting the Rust idle_cb to None here because `stop` is\n-        // likely called from *within* the idle callback, causing a use after\n-        // free\n-\n-        unsafe {\n-            assert_eq!(uvll::uv_idle_stop(self.native_handle()), 0);\n+    fn resume(&mut self) {\n+        if self.idle_flag == false {\n+            assert_eq!(unsafe { uvll::idle_start(self.handle, idle_cb) }, 0)\n+            self.idle_flag = true;\n+        }\n+    }\n+    fn close(&mut self) {\n+        self.pause();\n+        if !self.closed {\n+            self.closed = true;\n+            self.close_async_();\n         }\n     }\n }\n \n-impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n-    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n-        IdleWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_idle_t {\n-        match self { &IdleWatcher(ptr) => ptr }\n-    }\n+impl UvHandle<uvll::uv_idle_t> for IdleWatcher {\n+    fn uv_handle(&self) -> *uvll::uv_idle_t { self.handle }\n }\n \n extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-    let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-    let data = idle_watcher.get_watcher_data();\n-    let cb: &IdleCallback = data.idle_cb.get_ref();\n-    let status = status_to_maybe_uv_error(status);\n-    (*cb)(idle_watcher, status);\n+    assert_eq!(status, 0);\n+    let idle: &mut IdleWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n+    assert!(idle.callback.is_some());\n+    idle.callback.get_mut_ref().call();\n }\n \n #[cfg(test)]"}, {"sha": "f3d9bb5443bb8a29ed8e41d1d4318e2cc812f6e2", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=28219fc679e6c2f747ad3e49eb746a383797ef9b", "patch": "@@ -55,7 +55,6 @@ use std::cast::transmute;\n use std::ptr::null;\n use std::unstable::finally::Finally;\n use std::rt::io::net::ip::SocketAddr;\n-use std::rt::io::signal::Signum;\n \n use std::rt::io::IoError;\n \n@@ -152,7 +151,39 @@ pub trait UvHandle<T> {\n             unsafe { uvll::free_handle(handle) }\n         }\n \n-        unsafe { uvll::close(self.uv_handle(), close_cb) }\n+        unsafe {\n+            uvll::set_data_for_uv_handle(self.uv_handle(), null::<()>());\n+            uvll::close(self.uv_handle(), close_cb)\n+        }\n+    }\n+}\n+\n+pub trait UvRequest<T> {\n+    fn uv_request(&self) -> *T;\n+\n+    // FIXME(#8888) dummy self\n+    fn alloc(_: Option<Self>, ty: uvll::uv_req_type) -> *T {\n+        unsafe {\n+            let handle = uvll::malloc_req(ty);\n+            assert!(!handle.is_null());\n+            handle as *T\n+        }\n+    }\n+\n+    unsafe fn from_uv_request<'a>(h: &'a *T) -> &'a mut Self {\n+        cast::transmute(uvll::get_data_for_req(*h))\n+    }\n+\n+    fn install(~self) -> ~Self {\n+        unsafe {\n+            let myptr = cast::transmute::<&~Self, &*u8>(&self);\n+            uvll::set_data_for_req(self.uv_request(), *myptr);\n+        }\n+        self\n+    }\n+\n+    fn delete(&mut self) {\n+        unsafe { uvll::free_req(self.uv_request() as *c_void) }\n     }\n }\n \n@@ -185,7 +216,6 @@ impl NativeHandle<*uvll::uv_loop_t> for Loop {\n pub type AllocCallback = ~fn(uint) -> Buf;\n pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n pub type NullCallback = ~fn();\n-pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n@@ -201,7 +231,6 @@ struct WatcherData {\n     connect_cb: Option<ConnectionCallback>,\n     close_cb: Option<NullCallback>,\n     alloc_cb: Option<AllocCallback>,\n-    idle_cb: Option<IdleCallback>,\n     async_cb: Option<AsyncCallback>,\n     udp_recv_cb: Option<UdpReceiveCallback>,\n     udp_send_cb: Option<UdpSendCallback>,\n@@ -234,11 +263,9 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 connect_cb: None,\n                 close_cb: None,\n                 alloc_cb: None,\n-                idle_cb: None,\n                 async_cb: None,\n                 udp_recv_cb: None,\n                 udp_send_cb: None,\n-                signal_cb: None,\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);\n             uvll::set_data_for_uv_handle(self.native_handle(), data);"}, {"sha": "f584fa6a1485ff042757d5ceac4788e377071092", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 11, "deletions": 170, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=28219fc679e6c2f747ad3e49eb746a383797ef9b", "patch": "@@ -28,9 +28,12 @@ use std::rt::rtio::*;\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::tube::Tube;\n use std::rt::task::Task;\n-use std::unstable::sync::Exclusive;\n-use std::libc::{lseek, off_t};\n-use std::rt::io::{FileMode, FileAccess, FileStat};\n+use std::path::{GenericPath, Path};\n+use std::libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY,\n+                O_WRONLY, S_IRUSR, S_IWUSR, S_IRWXU};\n+use std::rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n+                  CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n+                  FileStat};\n use std::rt::io::signal::Signum;\n use std::task;\n use ai = std::rt::io::net::addrinfo;\n@@ -199,27 +202,16 @@ impl EventLoop for UvEventLoop {\n         self.uvio.uv_loop().run();\n     }\n \n-    fn callback(&mut self, f: ~fn()) {\n-        let mut idle_watcher =  IdleWatcher::new(self.uvio.uv_loop());\n-        do idle_watcher.start |mut idle_watcher, status| {\n-            assert!(status.is_none());\n-            idle_watcher.stop();\n-            idle_watcher.close(||());\n-            f();\n-        }\n+    fn callback(&mut self, f: proc()) {\n+        IdleWatcher::onetime(self.uvio.uv_loop(), f);\n     }\n \n     fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback {\n-        let idle_watcher = IdleWatcher::new(self.uvio.uv_loop());\n-        ~UvPausibleIdleCallback {\n-            watcher: idle_watcher,\n-            idle_flag: false,\n-            closed: false\n-        } as ~PausibleIdleCallback\n+        IdleWatcher::new(self.uvio.uv_loop()) as ~PausibleIdleCallback\n     }\n \n-    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallback {\n-        ~UvRemoteCallback::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n+    fn remote_callback(&mut self, f: ~Callback) -> ~RemoteCallback {\n+        ~AsyncWatcher::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n     }\n \n     fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory)) {\n@@ -233,44 +225,6 @@ pub extern \"C\" fn new_loop() -> ~EventLoop {\n     ~UvEventLoop::new() as ~EventLoop\n }\n \n-pub struct UvPausibleIdleCallback {\n-    priv watcher: IdleWatcher,\n-    priv idle_flag: bool,\n-    priv closed: bool\n-}\n-\n-impl PausibleIdleCallback for UvPausibleIdleCallback {\n-    #[inline]\n-    fn start(&mut self, f: ~fn()) {\n-        do self.watcher.start |_idle_watcher, _status| {\n-            f();\n-        };\n-        self.idle_flag = true;\n-    }\n-    #[inline]\n-    fn pause(&mut self) {\n-        if self.idle_flag == true {\n-            self.watcher.stop();\n-            self.idle_flag = false;\n-        }\n-    }\n-    #[inline]\n-    fn resume(&mut self) {\n-        if self.idle_flag == false {\n-            self.watcher.restart();\n-            self.idle_flag = true;\n-        }\n-    }\n-    #[inline]\n-    fn close(&mut self) {\n-        self.pause();\n-        if !self.closed {\n-            self.closed = true;\n-            self.watcher.close(||{});\n-        }\n-    }\n-}\n-\n #[test]\n fn test_callback_run_once() {\n     do run_in_bare_thread {\n@@ -285,119 +239,6 @@ fn test_callback_run_once() {\n     }\n }\n \n-// The entire point of async is to call into a loop from other threads so it does not need to home.\n-pub struct UvRemoteCallback {\n-    // The uv async handle for triggering the callback\n-    priv async: AsyncWatcher,\n-    // A flag to tell the callback to exit, set from the dtor. This is\n-    // almost never contested - only in rare races with the dtor.\n-    priv exit_flag: Exclusive<bool>\n-}\n-\n-impl UvRemoteCallback {\n-    pub fn new(loop_: &mut Loop, f: ~fn()) -> UvRemoteCallback {\n-        let exit_flag = Exclusive::new(false);\n-        let exit_flag_clone = exit_flag.clone();\n-        let async = do AsyncWatcher::new(loop_) |watcher, status| {\n-            assert!(status.is_none());\n-\n-            // The synchronization logic here is subtle. To review,\n-            // the uv async handle type promises that, after it is\n-            // triggered the remote callback is definitely called at\n-            // least once. UvRemoteCallback needs to maintain those\n-            // semantics while also shutting down cleanly from the\n-            // dtor. In our case that means that, when the\n-            // UvRemoteCallback dtor calls `async.send()`, here `f` is\n-            // always called later.\n-\n-            // In the dtor both the exit flag is set and the async\n-            // callback fired under a lock.  Here, before calling `f`,\n-            // we take the lock and check the flag. Because we are\n-            // checking the flag before calling `f`, and the flag is\n-            // set under the same lock as the send, then if the flag\n-            // is set then we're guaranteed to call `f` after the\n-            // final send.\n-\n-            // If the check was done after `f()` then there would be a\n-            // period between that call and the check where the dtor\n-            // could be called in the other thread, missing the final\n-            // callback while still destroying the handle.\n-\n-            let should_exit = unsafe {\n-                exit_flag_clone.with_imm(|&should_exit| should_exit)\n-            };\n-\n-            f();\n-\n-            if should_exit {\n-                watcher.close(||());\n-            }\n-\n-        };\n-        UvRemoteCallback {\n-            async: async,\n-            exit_flag: exit_flag\n-        }\n-    }\n-}\n-\n-impl RemoteCallback for UvRemoteCallback {\n-    fn fire(&mut self) { self.async.send() }\n-}\n-\n-impl Drop for UvRemoteCallback {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let this: &mut UvRemoteCallback = cast::transmute_mut(self);\n-            do this.exit_flag.with |should_exit| {\n-                // NB: These two things need to happen atomically. Otherwise\n-                // the event handler could wake up due to a *previous*\n-                // signal and see the exit flag, destroying the handle\n-                // before the final send.\n-                *should_exit = true;\n-                this.async.send();\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_remote {\n-    use std::cell::Cell;\n-    use std::rt::test::*;\n-    use std::rt::thread::Thread;\n-    use std::rt::tube::Tube;\n-    use std::rt::rtio::EventLoop;\n-    use std::rt::local::Local;\n-    use std::rt::sched::Scheduler;\n-\n-    #[test]\n-    fn test_uv_remote() {\n-        do run_in_mt_newsched_task {\n-            let mut tube = Tube::new();\n-            let tube_clone = tube.clone();\n-            let remote_cell = Cell::new_empty();\n-            do Local::borrow |sched: &mut Scheduler| {\n-                let tube_clone = tube_clone.clone();\n-                let tube_clone_cell = Cell::new(tube_clone);\n-                let remote = do sched.event_loop.remote_callback {\n-                    // This could be called multiple times\n-                    if !tube_clone_cell.is_empty() {\n-                        tube_clone_cell.take().send(1);\n-                    }\n-                };\n-                remote_cell.put_back(remote);\n-            }\n-            let thread = do Thread::start {\n-                remote_cell.take().fire();\n-            };\n-\n-            assert!(tube.recv() == 1);\n-            thread.join();\n-        }\n-    }\n-}\n-\n pub struct UvIoFactory(Loop);\n \n impl UvIoFactory {"}, {"sha": "0c8d192d89ac1373053f35b3bc67cd494f305697", "filename": "src/libstd/rt/basic.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbasic.rs?ref=28219fc679e6c2f747ad3e49eb746a383797ef9b", "patch": "@@ -15,7 +15,8 @@\n use prelude::*;\n \n use cast;\n-use rt::rtio::{EventLoop, IoFactory, RemoteCallback, PausibleIdleCallback};\n+use rt::rtio::{EventLoop, IoFactory, RemoteCallback, PausibleIdleCallback,\n+               Callback};\n use unstable::sync::Exclusive;\n use util;\n \n@@ -25,9 +26,9 @@ pub fn event_loop() -> ~EventLoop {\n }\n \n struct BasicLoop {\n-    work: ~[~fn()],               // pending work\n-    idle: Option<*BasicPausible>, // only one is allowed\n-    remotes: ~[(uint, ~fn())],\n+    work: ~[proc()],                  // pending work\n+    idle: Option<*mut BasicPausible>, // only one is allowed\n+    remotes: ~[(uint, ~Callback)],\n     next_remote: uint,\n     messages: Exclusive<~[Message]>\n }\n@@ -86,8 +87,8 @@ impl BasicLoop {\n     fn message(&mut self, message: Message) {\n         match message {\n             RunRemote(i) => {\n-                match self.remotes.iter().find(|& &(id, _)| id == i) {\n-                    Some(&(_, ref f)) => (*f)(),\n+                match self.remotes.mut_iter().find(|& &(id, _)| id == i) {\n+                    Some(&(_, ref mut f)) => f.call(),\n                     None => unreachable!()\n                 }\n             }\n@@ -106,7 +107,7 @@ impl BasicLoop {\n             match self.idle {\n                 Some(idle) => {\n                     if (*idle).active {\n-                        (*(*idle).work.get_ref())();\n+                        (*idle).work.get_mut_ref().call();\n                     }\n                 }\n                 None => {}\n@@ -144,7 +145,7 @@ impl EventLoop for BasicLoop {\n         }\n     }\n \n-    fn callback(&mut self, f: ~fn()) {\n+    fn callback(&mut self, f: proc()) {\n         self.work.push(f);\n     }\n \n@@ -153,13 +154,13 @@ impl EventLoop for BasicLoop {\n         let callback = ~BasicPausible::new(self);\n         rtassert!(self.idle.is_none());\n         unsafe {\n-            let cb_ptr: &*BasicPausible = cast::transmute(&callback);\n+            let cb_ptr: &*mut BasicPausible = cast::transmute(&callback);\n             self.idle = Some(*cb_ptr);\n         }\n         return callback as ~PausibleIdleCallback;\n     }\n \n-    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallback {\n+    fn remote_callback(&mut self, f: ~Callback) -> ~RemoteCallback {\n         let id = self.next_remote;\n         self.next_remote += 1;\n         self.remotes.push((id, f));\n@@ -203,7 +204,7 @@ impl Drop for BasicRemote {\n \n struct BasicPausible {\n     eloop: *mut BasicLoop,\n-    work: Option<~fn()>,\n+    work: Option<~Callback>,\n     active: bool,\n }\n \n@@ -218,7 +219,7 @@ impl BasicPausible {\n }\n \n impl PausibleIdleCallback for BasicPausible {\n-    fn start(&mut self, f: ~fn()) {\n+    fn start(&mut self, f: ~Callback) {\n         rtassert!(!self.active && self.work.is_none());\n         self.active = true;\n         self.work = Some(f);"}, {"sha": "8684537f4e4b5b376a90aaa787bb385447d786e1", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=28219fc679e6c2f747ad3e49eb746a383797ef9b", "patch": "@@ -24,11 +24,15 @@ use path::Path;\n use super::io::{SeekStyle};\n use super::io::{FileMode, FileAccess, FileStat, FilePermission};\n \n+pub trait Callback {\n+    fn call(&mut self);\n+}\n+\n pub trait EventLoop {\n     fn run(&mut self);\n-    fn callback(&mut self, ~fn());\n+    fn callback(&mut self, proc());\n     fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback;\n-    fn remote_callback(&mut self, ~fn()) -> ~RemoteCallback;\n+    fn remote_callback(&mut self, ~Callback) -> ~RemoteCallback;\n \n     /// The asynchronous I/O services. Not all event loops may provide one\n     // FIXME(#9382) this is an awful interface\n@@ -222,7 +226,7 @@ pub trait RtioTTY {\n }\n \n pub trait PausibleIdleCallback {\n-    fn start(&mut self, f: ~fn());\n+    fn start(&mut self, f: ~Callback);\n     fn pause(&mut self);\n     fn resume(&mut self);\n     fn close(&mut self);"}, {"sha": "fb4bd573a73e9df47a6c582e5f607fc9e0f9e05c", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28219fc679e6c2f747ad3e49eb746a383797ef9b/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=28219fc679e6c2f747ad3e49eb746a383797ef9b", "patch": "@@ -23,7 +23,7 @@ use super::message_queue::MessageQueue;\n use rt::kill::BlockedTask;\n use rt::local_ptr;\n use rt::local::Local;\n-use rt::rtio::{RemoteCallback, PausibleIdleCallback};\n+use rt::rtio::{RemoteCallback, PausibleIdleCallback, Callback};\n use borrow::{to_uint};\n use cell::Cell;\n use rand::{XorShiftRng, Rng, Rand};\n@@ -184,7 +184,7 @@ impl Scheduler {\n         // Before starting our first task, make sure the idle callback\n         // is active. As we do not start in the sleep state this is\n         // important.\n-        self.idle_callback.get_mut_ref().start(Scheduler::run_sched_once);\n+        self.idle_callback.get_mut_ref().start(~SchedRunner as ~Callback);\n \n         // Now, as far as all the scheduler state is concerned, we are\n         // inside the \"scheduler\" context. So we can act like the\n@@ -767,7 +767,7 @@ impl Scheduler {\n     }\n \n     pub fn make_handle(&mut self) -> SchedHandle {\n-        let remote = self.event_loop.remote_callback(Scheduler::run_sched_once);\n+        let remote = self.event_loop.remote_callback(~SchedRunner as ~Callback);\n \n         return SchedHandle {\n             remote: remote,\n@@ -802,6 +802,14 @@ impl SchedHandle {\n     }\n }\n \n+struct SchedRunner;\n+\n+impl Callback for SchedRunner {\n+    fn call(&mut self) {\n+        Scheduler::run_sched_once();\n+    }\n+}\n+\n struct CleanupJob {\n     task: ~Task,\n     f: UnsafeTaskReceiver"}]}