{"sha": "5c1c48532f1f5ce726d1704d33366f8fb371cca0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMWM0ODUzMmYxZjVjZTcyNmQxNzA0ZDMzMzY2ZjhmYjM3MWNjYTA=", "commit": {"author": {"name": "Theodore DeRego", "email": "tedsta@google.com", "date": "2016-11-23T21:58:13Z"}, "committer": {"name": "Theodore DeRego", "email": "tedsta@google.com", "date": "2016-11-23T21:58:13Z"}, "message": "Separated fuchsia-specific process stuff into 'process_fuchsia.rs' and refactored out some now-duplicated code into a 'process_common.rs'", "tree": {"sha": "d13306fdf763685c38f806e8050dc143bfe7b0da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d13306fdf763685c38f806e8050dc143bfe7b0da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c1c48532f1f5ce726d1704d33366f8fb371cca0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c1c48532f1f5ce726d1704d33366f8fb371cca0", "html_url": "https://github.com/rust-lang/rust/commit/5c1c48532f1f5ce726d1704d33366f8fb371cca0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c1c48532f1f5ce726d1704d33366f8fb371cca0/comments", "author": {"login": "tedsta", "id": 1218723, "node_id": "MDQ6VXNlcjEyMTg3MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1218723?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tedsta", "html_url": "https://github.com/tedsta", "followers_url": "https://api.github.com/users/tedsta/followers", "following_url": "https://api.github.com/users/tedsta/following{/other_user}", "gists_url": "https://api.github.com/users/tedsta/gists{/gist_id}", "starred_url": "https://api.github.com/users/tedsta/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tedsta/subscriptions", "organizations_url": "https://api.github.com/users/tedsta/orgs", "repos_url": "https://api.github.com/users/tedsta/repos", "events_url": "https://api.github.com/users/tedsta/events{/privacy}", "received_events_url": "https://api.github.com/users/tedsta/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tedsta", "id": 1218723, "node_id": "MDQ6VXNlcjEyMTg3MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1218723?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tedsta", "html_url": "https://github.com/tedsta", "followers_url": "https://api.github.com/users/tedsta/followers", "following_url": "https://api.github.com/users/tedsta/following{/other_user}", "gists_url": "https://api.github.com/users/tedsta/gists{/gist_id}", "starred_url": "https://api.github.com/users/tedsta/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tedsta/subscriptions", "organizations_url": "https://api.github.com/users/tedsta/orgs", "repos_url": "https://api.github.com/users/tedsta/repos", "events_url": "https://api.github.com/users/tedsta/events{/privacy}", "received_events_url": "https://api.github.com/users/tedsta/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae09957040927a16467c544d3ec8f427e9808d75", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae09957040927a16467c544d3ec8f427e9808d75", "html_url": "https://github.com/rust-lang/rust/commit/ae09957040927a16467c544d3ec8f427e9808d75"}], "stats": {"total": 1808, "additions": 940, "deletions": 868}, "files": [{"sha": "155259d2645da4d517abb6b7dec2bae098312bce", "filename": "src/libstd/sys/unix/magenta.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c1c48532f1f5ce726d1704d33366f8fb371cca0/src%2Flibstd%2Fsys%2Funix%2Fmagenta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1c48532f1f5ce726d1704d33366f8fb371cca0/src%2Flibstd%2Fsys%2Funix%2Fmagenta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmagenta.rs?ref=5c1c48532f1f5ce726d1704d33366f8fb371cca0", "patch": "@@ -67,7 +67,6 @@ pub struct mx_info_process_t {\n     pub rec: mx_record_process_t,\n }\n \n-#[link(name = \"magenta\")]\n extern {\n     pub fn mx_handle_close(handle: mx_handle_t) -> mx_status_t;\n \n@@ -89,7 +88,6 @@ pub fn mx_hnd_info(hnd_type: u32, arg: u32) -> u32 {\n     (hnd_type & 0xFFFF) | ((arg & 0xFFFF) << 16)\n }\n \n-#[link(name=\"mxio\")]\n extern {\n     pub fn mxio_get_startup_handle(id: u32) -> mx_handle_t;\n }\n@@ -123,7 +121,6 @@ pub struct launchpad_t {\n     loader_message: bool,\n }\n \n-#[link(name=\"launchpad\")]\n extern {\n     pub fn launchpad_create(job: mx_handle_t, name: *const c_char,\n                             lp: *mut *mut launchpad_t) -> mx_status_t;"}, {"sha": "d660514a9830e5e04484972f7ba7d507b476f7f8", "filename": "src/libstd/sys/unix/process.rs", "status": "removed", "additions": 0, "deletions": 865, "changes": 865, "blob_url": "https://github.com/rust-lang/rust/blob/ae09957040927a16467c544d3ec8f427e9808d75/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae09957040927a16467c544d3ec8f427e9808d75/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=ae09957040927a16467c544d3ec8f427e9808d75", "patch": "@@ -1,865 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use os::unix::prelude::*;\n-\n-use collections::hash_map::{HashMap, Entry};\n-use env;\n-use ffi::{OsString, OsStr, CString, CStr};\n-use fmt;\n-use io::{self, Error, ErrorKind};\n-use libc::{self, c_int, gid_t, uid_t, c_char};\n-use mem;\n-use ptr;\n-use sys::fd::FileDesc;\n-use sys::fs::{File, OpenOptions};\n-use sys::pipe::{self, AnonPipe};\n-\n-#[cfg(not(target_os = \"fuchsia\"))]\n-use sys::cvt;\n-#[cfg(target_os = \"fuchsia\")]\n-use sys::mx_cvt;\n-\n-#[cfg(target_os = \"fuchsia\")]\n-use sys::magenta::{launchpad_t, mx_handle_t};\n-\n-#[cfg(not(target_os = \"fuchsia\"))]\n-use libc::pid_t;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Command {\n-    // Currently we try hard to ensure that the call to `.exec()` doesn't\n-    // actually allocate any memory. While many platforms try to ensure that\n-    // memory allocation works after a fork in a multithreaded process, it's\n-    // been observed to be buggy and somewhat unreliable, so we do our best to\n-    // just not do it at all!\n-    //\n-    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n-    // what's gonna get passed to `execvp`. The `argv` array starts with the\n-    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n-    // also null-terminated.\n-    //\n-    // Right now we don't support removing arguments, so there's no much fancy\n-    // support there, but we support adding and removing environment variables,\n-    // so a side table is used to track where in the `envp` array each key is\n-    // located. Whenever we add a key we update it in place if it's already\n-    // present, and whenever we remove a key we update the locations of all\n-    // other keys.\n-    program: CString,\n-    args: Vec<CString>,\n-    env: Option<HashMap<OsString, (usize, CString)>>,\n-    argv: Vec<*const c_char>,\n-    envp: Option<Vec<*const c_char>>,\n-\n-    cwd: Option<CString>,\n-    uid: Option<uid_t>,\n-    gid: Option<gid_t>,\n-    saw_nul: bool,\n-    closures: Vec<Box<FnMut() -> io::Result<()> + Send + Sync>>,\n-    stdin: Option<Stdio>,\n-    stdout: Option<Stdio>,\n-    stderr: Option<Stdio>,\n-}\n-\n-// passed back to std::process with the pipes connected to the child, if any\n-// were requested\n-pub struct StdioPipes {\n-    pub stdin: Option<AnonPipe>,\n-    pub stdout: Option<AnonPipe>,\n-    pub stderr: Option<AnonPipe>,\n-}\n-\n-// passed to do_exec() with configuration of what the child stdio should look\n-// like\n-struct ChildPipes {\n-    stdin: ChildStdio,\n-    stdout: ChildStdio,\n-    stderr: ChildStdio,\n-}\n-\n-enum ChildStdio {\n-    Inherit,\n-    Explicit(c_int),\n-    Owned(FileDesc),\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    MakePipe,\n-    Fd(FileDesc),\n-}\n-\n-impl Command {\n-    pub fn new(program: &OsStr) -> Command {\n-        let mut saw_nul = false;\n-        let program = os2c(program, &mut saw_nul);\n-        Command {\n-            argv: vec![program.as_ptr(), ptr::null()],\n-            program: program,\n-            args: Vec::new(),\n-            env: None,\n-            envp: None,\n-            cwd: None,\n-            uid: None,\n-            gid: None,\n-            saw_nul: saw_nul,\n-            closures: Vec::new(),\n-            stdin: None,\n-            stdout: None,\n-            stderr: None,\n-        }\n-    }\n-\n-    pub fn arg(&mut self, arg: &OsStr) {\n-        // Overwrite the trailing NULL pointer in `argv` and then add a new null\n-        // pointer.\n-        let arg = os2c(arg, &mut self.saw_nul);\n-        self.argv[self.args.len() + 1] = arg.as_ptr();\n-        self.argv.push(ptr::null());\n-\n-        // Also make sure we keep track of the owned value to schedule a\n-        // destructor for this memory.\n-        self.args.push(arg);\n-    }\n-\n-    fn init_env_map(&mut self) -> (&mut HashMap<OsString, (usize, CString)>,\n-                                   &mut Vec<*const c_char>) {\n-        if self.env.is_none() {\n-            let mut map = HashMap::new();\n-            let mut envp = Vec::new();\n-            for (k, v) in env::vars_os() {\n-                let s = pair_to_key(&k, &v, &mut self.saw_nul);\n-                envp.push(s.as_ptr());\n-                map.insert(k, (envp.len() - 1, s));\n-            }\n-            envp.push(ptr::null());\n-            self.env = Some(map);\n-            self.envp = Some(envp);\n-        }\n-        (self.env.as_mut().unwrap(), self.envp.as_mut().unwrap())\n-    }\n-\n-    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n-        let new_key = pair_to_key(key, val, &mut self.saw_nul);\n-        let (map, envp) = self.init_env_map();\n-\n-        // If `key` is already present then we just update `envp` in place\n-        // (and store the owned value), but if it's not there we override the\n-        // trailing NULL pointer, add a new NULL pointer, and store where we\n-        // were located.\n-        match map.entry(key.to_owned()) {\n-            Entry::Occupied(mut e) => {\n-                let (i, ref mut s) = *e.get_mut();\n-                envp[i] = new_key.as_ptr();\n-                *s = new_key;\n-            }\n-            Entry::Vacant(e) => {\n-                let len = envp.len();\n-                envp[len - 1] = new_key.as_ptr();\n-                envp.push(ptr::null());\n-                e.insert((len - 1, new_key));\n-            }\n-        }\n-    }\n-\n-    pub fn env_remove(&mut self, key: &OsStr) {\n-        let (map, envp) = self.init_env_map();\n-\n-        // If we actually ended up removing a key, then we need to update the\n-        // position of all keys that come after us in `envp` because they're all\n-        // one element sooner now.\n-        if let Some((i, _)) = map.remove(key) {\n-            envp.remove(i);\n-\n-            for (_, &mut (ref mut j, _)) in map.iter_mut() {\n-                if *j >= i {\n-                    *j -= 1;\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn env_clear(&mut self) {\n-        self.env = Some(HashMap::new());\n-        self.envp = Some(vec![ptr::null()]);\n-    }\n-\n-    pub fn cwd(&mut self, dir: &OsStr) {\n-        self.cwd = Some(os2c(dir, &mut self.saw_nul));\n-    }\n-    pub fn uid(&mut self, id: uid_t) {\n-        self.uid = Some(id);\n-    }\n-    pub fn gid(&mut self, id: gid_t) {\n-        self.gid = Some(id);\n-    }\n-\n-    pub fn before_exec(&mut self,\n-                       f: Box<FnMut() -> io::Result<()> + Send + Sync>) {\n-        self.closures.push(f);\n-    }\n-\n-    pub fn stdin(&mut self, stdin: Stdio) {\n-        self.stdin = Some(stdin);\n-    }\n-    pub fn stdout(&mut self, stdout: Stdio) {\n-        self.stdout = Some(stdout);\n-    }\n-    pub fn stderr(&mut self, stderr: Stdio) {\n-        self.stderr = Some(stderr);\n-    }\n-\n-    #[cfg(not(target_os = \"fuchsia\"))]\n-    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n-                 -> io::Result<(Process, StdioPipes)> {\n-        use sys;\n-\n-        const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n-\n-        if self.saw_nul {\n-            return Err(io::Error::new(ErrorKind::InvalidInput,\n-                                      \"nul byte found in provided data\"));\n-        }\n-\n-        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n-        let (input, output) = sys::pipe::anon_pipe()?;\n-\n-        let pid = unsafe {\n-            match cvt(libc::fork())? {\n-                0 => {\n-                    drop(input);\n-                    let err = self.do_exec(theirs);\n-                    let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n-                    let bytes = [\n-                        (errno >> 24) as u8,\n-                        (errno >> 16) as u8,\n-                        (errno >>  8) as u8,\n-                        (errno >>  0) as u8,\n-                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n-                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n-                    ];\n-                    // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n-                    // we want to be sure we *don't* run at_exit destructors as\n-                    // we're being torn down regardless\n-                    assert!(output.write(&bytes).is_ok());\n-                    libc::_exit(1)\n-                }\n-                n => n,\n-            }\n-        };\n-\n-        let mut p = Process { pid: pid, status: None };\n-        drop(output);\n-        let mut bytes = [0; 8];\n-\n-        // loop to handle EINTR\n-        loop {\n-            match input.read(&mut bytes) {\n-                Ok(0) => return Ok((p, ours)),\n-                Ok(8) => {\n-                    assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n-                            \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n-                    let errno = combine(&bytes[0.. 4]);\n-                    assert!(p.wait().is_ok(),\n-                            \"wait() should either return Ok or panic\");\n-                    return Err(Error::from_raw_os_error(errno))\n-                }\n-                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-                Err(e) => {\n-                    assert!(p.wait().is_ok(),\n-                            \"wait() should either return Ok or panic\");\n-                    panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n-                },\n-                Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n-                    assert!(p.wait().is_ok(),\n-                            \"wait() should either return Ok or panic\");\n-                    panic!(\"short read on the CLOEXEC pipe\")\n-                }\n-            }\n-        }\n-\n-        fn combine(arr: &[u8]) -> i32 {\n-            let a = arr[0] as u32;\n-            let b = arr[1] as u32;\n-            let c = arr[2] as u32;\n-            let d = arr[3] as u32;\n-\n-            ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n-        }\n-    }\n-\n-    #[cfg(target_os = \"fuchsia\")]\n-    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n-                 -> io::Result<(Process, StdioPipes)> {\n-        if self.saw_nul {\n-            return Err(io::Error::new(ErrorKind::InvalidInput,\n-                                      \"nul byte found in provided data\"));\n-        }\n-\n-        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n-\n-        let (launchpad, process_handle) = unsafe { self.do_exec(theirs)? };\n-\n-        Ok((Process { launchpad: launchpad, handle: process_handle, status: None }, ours))\n-    }\n-\n-    #[cfg(not(target_os = \"fuchsia\"))]\n-    pub fn exec(&mut self, default: Stdio) -> io::Error {\n-        if self.saw_nul {\n-            return io::Error::new(ErrorKind::InvalidInput,\n-                                  \"nul byte found in provided data\")\n-        }\n-\n-        match self.setup_io(default, true) {\n-            Ok((_, theirs)) => unsafe { self.do_exec(theirs) },\n-            Err(e) => e,\n-        }\n-    }\n-\n-    #[cfg(target_os = \"fuchsia\")]\n-    pub fn exec(&mut self, default: Stdio) -> io::Error {\n-        if self.saw_nul {\n-            return io::Error::new(ErrorKind::InvalidInput,\n-                                  \"nul byte found in provided data\")\n-        }\n-\n-        match self.setup_io(default, true) {\n-            Ok((_, _)) => {\n-                // FIXME: This is tough because we don't support the exec syscalls\n-                unimplemented!();\n-            },\n-            Err(e) => e,\n-        }\n-    }\n-\n-    // And at this point we've reached a special time in the life of the\n-    // child. The child must now be considered hamstrung and unable to\n-    // do anything other than syscalls really. Consider the following\n-    // scenario:\n-    //\n-    //      1. Thread A of process 1 grabs the malloc() mutex\n-    //      2. Thread B of process 1 forks(), creating thread C\n-    //      3. Thread C of process 2 then attempts to malloc()\n-    //      4. The memory of process 2 is the same as the memory of\n-    //         process 1, so the mutex is locked.\n-    //\n-    // This situation looks a lot like deadlock, right? It turns out\n-    // that this is what pthread_atfork() takes care of, which is\n-    // presumably implemented across platforms. The first thing that\n-    // threads to *before* forking is to do things like grab the malloc\n-    // mutex, and then after the fork they unlock it.\n-    //\n-    // Despite this information, libnative's spawn has been witnessed to\n-    // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n-    // all collected backtraces point at malloc/free traffic in the\n-    // child spawned process.\n-    //\n-    // For this reason, the block of code below should contain 0\n-    // invocations of either malloc of free (or their related friends).\n-    //\n-    // As an example of not having malloc/free traffic, we don't close\n-    // this file descriptor by dropping the FileDesc (which contains an\n-    // allocation). Instead we just close it manually. This will never\n-    // have the drop glue anyway because this code never returns (the\n-    // child will either exec() or invoke libc::exit)\n-    #[cfg(not(target_os = \"fuchsia\"))]\n-    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n-        use sys::{self, cvt_r};\n-\n-        macro_rules! t {\n-            ($e:expr) => (match $e {\n-                Ok(e) => e,\n-                Err(e) => return e,\n-            })\n-        }\n-\n-        if let Some(fd) = stdio.stdin.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n-        }\n-        if let Some(fd) = stdio.stdout.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n-        }\n-        if let Some(fd) = stdio.stderr.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n-        }\n-\n-        if let Some(u) = self.gid {\n-            t!(cvt(libc::setgid(u as gid_t)));\n-        }\n-        if let Some(u) = self.uid {\n-            // When dropping privileges from root, the `setgroups` call\n-            // will remove any extraneous groups. If we don't call this,\n-            // then even though our uid has dropped, we may still have\n-            // groups that enable us to do super-user things. This will\n-            // fail if we aren't root, so don't bother checking the\n-            // return value, this is just done as an optimistic\n-            // privilege dropping function.\n-            let _ = libc::setgroups(0, ptr::null());\n-\n-            t!(cvt(libc::setuid(u as uid_t)));\n-        }\n-        if let Some(ref cwd) = self.cwd {\n-            t!(cvt(libc::chdir(cwd.as_ptr())));\n-        }\n-        if let Some(ref envp) = self.envp {\n-            *sys::os::environ() = envp.as_ptr();\n-        }\n-\n-        // NaCl has no signal support.\n-        if cfg!(not(any(target_os = \"nacl\", target_os = \"emscripten\"))) {\n-            // Reset signal handling so the child process starts in a\n-            // standardized state. libstd ignores SIGPIPE, and signal-handling\n-            // libraries often set a mask. Child processes inherit ignored\n-            // signals and the signal mask from their parent, but most\n-            // UNIX programs do not reset these things on their own, so we\n-            // need to clean things up now to avoid confusing the program\n-            // we're about to run.\n-            let mut set: libc::sigset_t = mem::uninitialized();\n-            t!(cvt(libc::sigemptyset(&mut set)));\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n-                                         ptr::null_mut())));\n-            let ret = super::signal(libc::SIGPIPE, libc::SIG_DFL);\n-            if ret == libc::SIG_ERR {\n-                return io::Error::last_os_error()\n-            }\n-        }\n-\n-        for callback in self.closures.iter_mut() {\n-            t!(callback());\n-        }\n-\n-        libc::execvp(self.argv[0], self.argv.as_ptr());\n-        io::Error::last_os_error()\n-    }\n-\n-    #[cfg(target_os = \"fuchsia\")]\n-    unsafe fn do_exec(&mut self, stdio: ChildPipes)\n-                      -> io::Result<(*mut launchpad_t, mx_handle_t)> {\n-        use sys::magenta::*;\n-\n-        macro_rules! tlp {\n-            ($lp:expr, $e:expr) => (match $e {\n-                Ok(e) => e,\n-                Err(e) => {\n-                    launchpad_destroy($lp);\n-                    return Err(e);\n-                },\n-            })\n-        }\n-\n-        let job_handle = mxio_get_startup_handle(mx_hnd_info(MX_HND_TYPE_JOB, 0));\n-        let envp = match self.envp {\n-            Some(ref envp) => envp.as_ptr(),\n-            None => ptr::null(),\n-        };\n-\n-        let mut launchpad: *mut launchpad_t = ptr::null_mut();\n-        let mut job_copy: mx_handle_t = MX_HANDLE_INVALID;\n-\n-        // Duplicate the job handle\n-        mx_cvt(mx_handle_duplicate(job_handle, MX_RIGHT_SAME_RIGHTS,\n-                                   &mut job_copy as *mut mx_handle_t))?;\n-        // Create a launchpad\n-        mx_cvt(launchpad_create(job_copy, self.argv[0],\n-                                &mut launchpad as *mut *mut launchpad_t))?;\n-        // Set the process argv\n-        tlp!(launchpad, mx_cvt(launchpad_arguments(launchpad, self.argv.len() as i32 - 1,\n-                                                   self.argv.as_ptr())));\n-        // Setup the environment vars\n-        tlp!(launchpad, mx_cvt(launchpad_environ(launchpad, envp)));\n-        tlp!(launchpad, mx_cvt(launchpad_add_vdso_vmo(launchpad)));\n-        tlp!(launchpad, mx_cvt(launchpad_clone_mxio_root(launchpad)));\n-        // Load the executable\n-        tlp!(launchpad,\n-             mx_cvt(launchpad_elf_load(launchpad, launchpad_vmo_from_file(self.argv[0]))));\n-        tlp!(launchpad, mx_cvt(launchpad_load_vdso(launchpad, MX_HANDLE_INVALID)));\n-        tlp!(launchpad, mx_cvt(launchpad_clone_mxio_cwd(launchpad)));\n-\n-        // Clone stdin, stdout, and stderr\n-        if let Some(fd) = stdio.stdin.fd() {\n-            launchpad_transfer_fd(launchpad, fd, 0);\n-        } else {\n-            launchpad_clone_fd(launchpad, 0, 0);\n-        }\n-        if let Some(fd) = stdio.stdout.fd() {\n-            launchpad_transfer_fd(launchpad, fd, 1);\n-        } else {\n-            launchpad_clone_fd(launchpad, 1, 1);\n-        }\n-        if let Some(fd) = stdio.stderr.fd() {\n-            launchpad_transfer_fd(launchpad, fd, 2);\n-        } else {\n-            launchpad_clone_fd(launchpad, 2, 2);\n-        }\n-\n-        // We don't want FileDesc::drop to be called on any stdio. It would close their fds. The\n-        // fds will be closed once the child process finishes.\n-        let ChildPipes { stdin: child_stdin, stdout: child_stdout, stderr: child_stderr } = stdio;\n-        if let ChildStdio::Owned(fd) = child_stdin { fd.into_raw(); }\n-        if let ChildStdio::Owned(fd) = child_stdout { fd.into_raw(); }\n-        if let ChildStdio::Owned(fd) = child_stderr { fd.into_raw(); }\n-\n-        for callback in self.closures.iter_mut() {\n-            callback()?;\n-        }\n-\n-        let process_handle = tlp!(launchpad, mx_cvt(launchpad_start(launchpad)));\n-\n-        Ok((launchpad, process_handle))\n-    }\n-\n-    fn setup_io(&self, default: Stdio, needs_stdin: bool)\n-                -> io::Result<(StdioPipes, ChildPipes)> {\n-        let null = Stdio::Null;\n-        let default_stdin = if needs_stdin {&default} else {&null};\n-        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n-        let stdout = self.stdout.as_ref().unwrap_or(&default);\n-        let stderr = self.stderr.as_ref().unwrap_or(&default);\n-        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n-        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n-        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n-        let ours = StdioPipes {\n-            stdin: our_stdin,\n-            stdout: our_stdout,\n-            stderr: our_stderr,\n-        };\n-        let theirs = ChildPipes {\n-            stdin: their_stdin,\n-            stdout: their_stdout,\n-            stderr: their_stderr,\n-        };\n-        Ok((ours, theirs))\n-    }\n-}\n-\n-fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n-    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n-        *saw_nul = true;\n-        CString::new(\"<string-with-nul>\").unwrap()\n-    })\n-}\n-\n-impl Stdio {\n-    fn to_child_stdio(&self, readable: bool)\n-                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n-        match *self {\n-            Stdio::Inherit => {\n-                Ok((ChildStdio::Inherit, None))\n-            },\n-\n-            // Make sure that the source descriptors are not an stdio\n-            // descriptor, otherwise the order which we set the child's\n-            // descriptors may blow away a descriptor which we are hoping to\n-            // save. For example, suppose we want the child's stderr to be the\n-            // parent's stdout, and the child's stdout to be the parent's\n-            // stderr. No matter which we dup first, the second will get\n-            // overwritten prematurely.\n-            Stdio::Fd(ref fd) => {\n-                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n-                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n-                } else {\n-                    Ok((ChildStdio::Explicit(fd.raw()), None))\n-                }\n-            }\n-\n-            Stdio::MakePipe => {\n-                let (reader, writer) = pipe::anon_pipe()?;\n-                let (ours, theirs) = if readable {\n-                    (writer, reader)\n-                } else {\n-                    (reader, writer)\n-                };\n-                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n-            }\n-\n-            Stdio::Null => {\n-                let mut opts = OpenOptions::new();\n-                opts.read(readable);\n-                opts.write(!readable);\n-                let path = unsafe {\n-                    CStr::from_ptr(\"/dev/null\\0\".as_ptr() as *const _)\n-                };\n-                let fd = File::open_c(&path, &opts)?;\n-                Ok((ChildStdio::Owned(fd.into_fd()), None))\n-            }\n-        }\n-    }\n-}\n-\n-impl ChildStdio {\n-    fn fd(&self) -> Option<c_int> {\n-        match *self {\n-            ChildStdio::Inherit => None,\n-            ChildStdio::Explicit(fd) => Some(fd),\n-            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n-        }\n-    }\n-}\n-\n-fn pair_to_key(key: &OsStr, value: &OsStr, saw_nul: &mut bool) -> CString {\n-    let (key, value) = (key.as_bytes(), value.as_bytes());\n-    let mut v = Vec::with_capacity(key.len() + value.len() + 1);\n-    v.extend(key);\n-    v.push(b'=');\n-    v.extend(value);\n-    CString::new(v).unwrap_or_else(|_e| {\n-        *saw_nul = true;\n-        CString::new(\"foo=bar\").unwrap()\n-    })\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?}\", self.program)?;\n-        for arg in &self.args {\n-            write!(f, \" {:?}\", arg)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Processes\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Unix exit statuses\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitStatus(c_int);\n-\n-impl ExitStatus {\n-    fn exited(&self) -> bool {\n-        unsafe { libc::WIFEXITED(self.0) }\n-    }\n-\n-    pub fn success(&self) -> bool {\n-        self.code() == Some(0)\n-    }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        if self.exited() {\n-            Some(unsafe { libc::WEXITSTATUS(self.0) })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn signal(&self) -> Option<i32> {\n-        if !self.exited() {\n-            Some(unsafe { libc::WTERMSIG(self.0) })\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl From<c_int> for ExitStatus {\n-    fn from(a: c_int) -> ExitStatus {\n-        ExitStatus(a)\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if let Some(code) = self.code() {\n-            write!(f, \"exit code: {}\", code)\n-        } else {\n-            let signal = self.signal().unwrap();\n-            write!(f, \"signal: {}\", signal)\n-        }\n-    }\n-}\n-\n-/// The unique id of the process (this should never be negative).\n-#[cfg(not(target_os = \"fuchsia\"))]\n-pub struct Process {\n-    pid: pid_t,\n-    status: Option<ExitStatus>,\n-}\n-\n-#[cfg(target_os = \"fuchsia\")]\n-pub struct Process {\n-    launchpad: *mut launchpad_t,\n-    handle: mx_handle_t,\n-    status: Option<ExitStatus>,\n-}\n-\n-impl Process {\n-    #[cfg(not(target_os = \"fuchsia\"))]\n-    pub fn id(&self) -> u32 {\n-        self.pid as u32\n-    }\n-\n-    #[cfg(target_os = \"fuchsia\")]\n-    pub fn id(&self) -> u32 {\n-        0\n-    }\n-\n-    #[cfg(not(target_os = \"fuchsia\"))]\n-    pub fn kill(&mut self) -> io::Result<()> {\n-        // If we've already waited on this process then the pid can be recycled\n-        // and used for another process, and we probably shouldn't be killing\n-        // random processes, so just return an error.\n-        if self.status.is_some() {\n-            Err(Error::new(ErrorKind::InvalidInput,\n-                           \"invalid argument: can't kill an exited process\"))\n-        } else {\n-            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(|_| ())\n-        }\n-    }\n-\n-    #[cfg(target_os = \"fuchsia\")]\n-    pub fn kill(&mut self) -> io::Result<()> {\n-        use sys::magenta::*;\n-\n-        // If we've already waited on this process then the pid can be recycled\n-        // and used for another process, and we probably shouldn't be killing\n-        // random processes, so just return an error.\n-        if self.status.is_some() {\n-            Err(Error::new(ErrorKind::InvalidInput,\n-                           \"invalid argument: can't kill an exited process\"))\n-        } else {\n-            unsafe {\n-                mx_cvt(mx_handle_close(self.handle))?;\n-                launchpad_destroy(self.launchpad);\n-            }\n-            Ok(())\n-        }\n-    }\n-\n-    #[cfg(not(target_os = \"fuchsia\"))]\n-    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        use sys::cvt_r;\n-        if let Some(status) = self.status {\n-            return Ok(status)\n-        }\n-        let mut status = 0 as c_int;\n-        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n-        self.status = Some(ExitStatus(status));\n-        Ok(ExitStatus(status))\n-    }\n-\n-    #[cfg(target_os = \"fuchsia\")]\n-    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        use default::Default;\n-        use sys::magenta::*;\n-\n-        if let Some(status) = self.status {\n-            return Ok(status)\n-        }\n-\n-        let mut proc_info: mx_info_process_t = Default::default();\n-        let mut actual: mx_size_t = 0;\n-        let mut avail: mx_size_t = 0;\n-\n-        unsafe {\n-            mx_cvt(mx_handle_wait_one(self.handle, MX_TASK_TERMINATED,\n-                                      MX_TIME_INFINITE, ptr::null_mut()))?;\n-            mx_cvt(mx_object_get_info(self.handle, MX_INFO_PROCESS,\n-                                      &mut proc_info as *mut _ as *mut libc::c_void,\n-                                      mem::size_of::<mx_info_process_t>(), &mut actual,\n-                                      &mut avail))?;\n-        }\n-        if actual != 1 {\n-            return Err(Error::new(ErrorKind::InvalidInput,\n-                                  \"Failed to get exit status of process\"));\n-        }\n-        self.status = Some(ExitStatus(proc_info.rec.return_code));\n-        unsafe {\n-            mx_cvt(mx_handle_close(self.handle))?;\n-            launchpad_destroy(self.launchpad);\n-        }\n-        Ok(ExitStatus(proc_info.rec.return_code))\n-    }\n-}\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests {\n-    use super::*;\n-\n-    use ffi::OsStr;\n-    use mem;\n-    use ptr;\n-    use libc;\n-    use sys::cvt;\n-\n-    macro_rules! t {\n-        ($e:expr) => {\n-            match $e {\n-                Ok(t) => t,\n-                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(target_os = \"android\"))]\n-    extern {\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n-        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n-    }\n-\n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n-        use slice;\n-\n-        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n-        let bit = (signum - 1) as usize;\n-        raw[bit / 8] |= 1 << (bit % 8);\n-        return 0;\n-    }\n-\n-    // See #14232 for more information, but it appears that signal delivery to a\n-    // newly spawned process may just be raced in the OSX, so to prevent this\n-    // test from being flaky we ignore it on OSX.\n-    #[test]\n-    #[cfg_attr(target_os = \"macos\", ignore)]\n-    #[cfg_attr(target_os = \"nacl\", ignore)] // no signals on NaCl.\n-    fn test_process_mask() {\n-        unsafe {\n-            // Test to make sure that a signal mask does not get inherited.\n-            let mut cmd = Command::new(OsStr::new(\"cat\"));\n-\n-            let mut set: libc::sigset_t = mem::uninitialized();\n-            let mut old_set: libc::sigset_t = mem::uninitialized();\n-            t!(cvt(libc::sigemptyset(&mut set)));\n-            t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n-\n-            cmd.stdin(Stdio::MakePipe);\n-            cmd.stdout(Stdio::MakePipe);\n-\n-            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n-            let stdin_write = pipes.stdin.take().unwrap();\n-            let stdout_read = pipes.stdout.take().unwrap();\n-\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n-                                         ptr::null_mut())));\n-\n-            t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n-            // We need to wait until SIGINT is definitely delivered. The\n-            // easiest way is to write something to cat, and try to read it\n-            // back: if SIGINT is unmasked, it'll get delivered when cat is\n-            // next scheduled.\n-            let _ = stdin_write.write(b\"Hello\");\n-            drop(stdin_write);\n-\n-            // Either EOF or failure (EPIPE) is okay.\n-            let mut buf = [0; 5];\n-            if let Ok(ret) = stdout_read.read(&mut buf) {\n-                assert!(ret == 0);\n-            }\n-\n-            t!(cat.wait());\n-        }\n-    }\n-}"}, {"sha": "82c3971ee40648bccf4e40413b9443882886b26c", "filename": "src/libstd/sys/unix/process/mod.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c1c48532f1f5ce726d1704d33366f8fb371cca0/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1c48532f1f5ce726d1704d33366f8fb371cca0/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs?ref=5c1c48532f1f5ce726d1704d33366f8fb371cca0", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::process_common::{Command, ExitStatus, Stdio, StdioPipes};\n+pub use self::process_inner::Process;\n+\n+mod process_common;\n+#[cfg(not(target_os = \"fuchsia\"))]\n+#[path = \"process_unix.rs\"]\n+mod process_inner;\n+#[cfg(target_os = \"fuchsia\")]\n+#[path = \"process_fuchsia.rs\"]\n+mod process_inner;"}, {"sha": "24b8b61edea27877425dd2ee12b563b7f46fea6c", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/5c1c48532f1f5ce726d1704d33366f8fb371cca0/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1c48532f1f5ce726d1704d33366f8fb371cca0/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=5c1c48532f1f5ce726d1704d33366f8fb371cca0", "patch": "@@ -0,0 +1,480 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use os::unix::prelude::*;\n+\n+use collections::hash_map::{HashMap, Entry};\n+use env;\n+use ffi::{OsString, OsStr, CString, CStr};\n+use fmt;\n+use io;\n+use libc::{self, c_int, gid_t, uid_t, c_char};\n+use ptr;\n+use sys::fd::FileDesc;\n+use sys::fs::{File, OpenOptions};\n+use sys::pipe::{self, AnonPipe};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Command {\n+    // Currently we try hard to ensure that the call to `.exec()` doesn't\n+    // actually allocate any memory. While many platforms try to ensure that\n+    // memory allocation works after a fork in a multithreaded process, it's\n+    // been observed to be buggy and somewhat unreliable, so we do our best to\n+    // just not do it at all!\n+    //\n+    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n+    // what's gonna get passed to `execvp`. The `argv` array starts with the\n+    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n+    // also null-terminated.\n+    //\n+    // Right now we don't support removing arguments, so there's no much fancy\n+    // support there, but we support adding and removing environment variables,\n+    // so a side table is used to track where in the `envp` array each key is\n+    // located. Whenever we add a key we update it in place if it's already\n+    // present, and whenever we remove a key we update the locations of all\n+    // other keys.\n+    program: CString,\n+    args: Vec<CString>,\n+    env: Option<HashMap<OsString, (usize, CString)>>,\n+    argv: Vec<*const c_char>,\n+    envp: Option<Vec<*const c_char>>,\n+\n+    cwd: Option<CString>,\n+    uid: Option<uid_t>,\n+    gid: Option<gid_t>,\n+    saw_nul: bool,\n+    closures: Vec<Box<FnMut() -> io::Result<()> + Send + Sync>>,\n+    stdin: Option<Stdio>,\n+    stdout: Option<Stdio>,\n+    stderr: Option<Stdio>,\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+// passed to do_exec() with configuration of what the child stdio should look\n+// like\n+pub struct ChildPipes {\n+    pub stdin: ChildStdio,\n+    pub stdout: ChildStdio,\n+    pub stderr: ChildStdio,\n+}\n+\n+pub enum ChildStdio {\n+    Inherit,\n+    Explicit(c_int),\n+    Owned(FileDesc),\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+    Fd(FileDesc),\n+}\n+\n+impl Command {\n+    pub fn new(program: &OsStr) -> Command {\n+        let mut saw_nul = false;\n+        let program = os2c(program, &mut saw_nul);\n+        Command {\n+            argv: vec![program.as_ptr(), ptr::null()],\n+            program: program,\n+            args: Vec::new(),\n+            env: None,\n+            envp: None,\n+            cwd: None,\n+            uid: None,\n+            gid: None,\n+            saw_nul: saw_nul,\n+            closures: Vec::new(),\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n+        }\n+    }\n+\n+    pub fn arg(&mut self, arg: &OsStr) {\n+        // Overwrite the trailing NULL pointer in `argv` and then add a new null\n+        // pointer.\n+        let arg = os2c(arg, &mut self.saw_nul);\n+        self.argv[self.args.len() + 1] = arg.as_ptr();\n+        self.argv.push(ptr::null());\n+\n+        // Also make sure we keep track of the owned value to schedule a\n+        // destructor for this memory.\n+        self.args.push(arg);\n+    }\n+\n+    fn init_env_map(&mut self) -> (&mut HashMap<OsString, (usize, CString)>,\n+                                   &mut Vec<*const c_char>) {\n+        if self.env.is_none() {\n+            let mut map = HashMap::new();\n+            let mut envp = Vec::new();\n+            for (k, v) in env::vars_os() {\n+                let s = pair_to_key(&k, &v, &mut self.saw_nul);\n+                envp.push(s.as_ptr());\n+                map.insert(k, (envp.len() - 1, s));\n+            }\n+            envp.push(ptr::null());\n+            self.env = Some(map);\n+            self.envp = Some(envp);\n+        }\n+        (self.env.as_mut().unwrap(), self.envp.as_mut().unwrap())\n+    }\n+\n+    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n+        let new_key = pair_to_key(key, val, &mut self.saw_nul);\n+        let (map, envp) = self.init_env_map();\n+\n+        // If `key` is already present then we just update `envp` in place\n+        // (and store the owned value), but if it's not there we override the\n+        // trailing NULL pointer, add a new NULL pointer, and store where we\n+        // were located.\n+        match map.entry(key.to_owned()) {\n+            Entry::Occupied(mut e) => {\n+                let (i, ref mut s) = *e.get_mut();\n+                envp[i] = new_key.as_ptr();\n+                *s = new_key;\n+            }\n+            Entry::Vacant(e) => {\n+                let len = envp.len();\n+                envp[len - 1] = new_key.as_ptr();\n+                envp.push(ptr::null());\n+                e.insert((len - 1, new_key));\n+            }\n+        }\n+    }\n+\n+    pub fn env_remove(&mut self, key: &OsStr) {\n+        let (map, envp) = self.init_env_map();\n+\n+        // If we actually ended up removing a key, then we need to update the\n+        // position of all keys that come after us in `envp` because they're all\n+        // one element sooner now.\n+        if let Some((i, _)) = map.remove(key) {\n+            envp.remove(i);\n+\n+            for (_, &mut (ref mut j, _)) in map.iter_mut() {\n+                if *j >= i {\n+                    *j -= 1;\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn env_clear(&mut self) {\n+        self.env = Some(HashMap::new());\n+        self.envp = Some(vec![ptr::null()]);\n+    }\n+\n+    pub fn cwd(&mut self, dir: &OsStr) {\n+        self.cwd = Some(os2c(dir, &mut self.saw_nul));\n+    }\n+    pub fn uid(&mut self, id: uid_t) {\n+        self.uid = Some(id);\n+    }\n+    pub fn gid(&mut self, id: gid_t) {\n+        self.gid = Some(id);\n+    }\n+\n+    pub fn saw_nul(&self) -> bool {\n+        self.saw_nul\n+    }\n+    pub fn get_envp(&self) -> &Option<Vec<*const c_char>> {\n+        &self.envp\n+    }\n+    pub fn get_argv(&self) -> &Vec<*const c_char> {\n+        &self.argv\n+    }\n+\n+    #[cfg(not(target_os=\"fuchsia\"))]\n+    pub fn get_cwd(&self) -> &Option<CString> {\n+        &self.cwd\n+    }\n+    #[cfg(not(target_os=\"fuchsia\"))]\n+    pub fn get_uid(&self) -> Option<uid_t> {\n+        self.uid\n+    }\n+    #[cfg(not(target_os=\"fuchsia\"))]\n+    pub fn get_gid(&self) -> Option<gid_t> {\n+        self.gid\n+    }\n+\n+    pub fn get_closures(&mut self) -> &mut Vec<Box<FnMut() -> io::Result<()> + Send + Sync>> {\n+        &mut self.closures\n+    }\n+\n+    pub fn before_exec(&mut self,\n+                       f: Box<FnMut() -> io::Result<()> + Send + Sync>) {\n+        self.closures.push(f);\n+    }\n+\n+    pub fn stdin(&mut self, stdin: Stdio) {\n+        self.stdin = Some(stdin);\n+    }\n+\n+    pub fn stdout(&mut self, stdout: Stdio) {\n+        self.stdout = Some(stdout);\n+    }\n+\n+    pub fn stderr(&mut self, stderr: Stdio) {\n+        self.stderr = Some(stderr);\n+    }\n+\n+    pub fn setup_io(&self, default: Stdio, needs_stdin: bool)\n+                -> io::Result<(StdioPipes, ChildPipes)> {\n+        let null = Stdio::Null;\n+        let default_stdin = if needs_stdin {&default} else {&null};\n+        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n+        let stdout = self.stdout.as_ref().unwrap_or(&default);\n+        let stderr = self.stderr.as_ref().unwrap_or(&default);\n+        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n+        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n+        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n+        let ours = StdioPipes {\n+            stdin: our_stdin,\n+            stdout: our_stdout,\n+            stderr: our_stderr,\n+        };\n+        let theirs = ChildPipes {\n+            stdin: their_stdin,\n+            stdout: their_stdout,\n+            stderr: their_stderr,\n+        };\n+        Ok((ours, theirs))\n+    }\n+}\n+\n+fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n+    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n+        *saw_nul = true;\n+        CString::new(\"<string-with-nul>\").unwrap()\n+    })\n+}\n+\n+impl Stdio {\n+    pub fn to_child_stdio(&self, readable: bool)\n+                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n+        match *self {\n+            Stdio::Inherit => {\n+                Ok((ChildStdio::Inherit, None))\n+            },\n+\n+            // Make sure that the source descriptors are not an stdio\n+            // descriptor, otherwise the order which we set the child's\n+            // descriptors may blow away a descriptor which we are hoping to\n+            // save. For example, suppose we want the child's stderr to be the\n+            // parent's stdout, and the child's stdout to be the parent's\n+            // stderr. No matter which we dup first, the second will get\n+            // overwritten prematurely.\n+            Stdio::Fd(ref fd) => {\n+                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n+                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n+                } else {\n+                    Ok((ChildStdio::Explicit(fd.raw()), None))\n+                }\n+            }\n+\n+            Stdio::MakePipe => {\n+                let (reader, writer) = pipe::anon_pipe()?;\n+                let (ours, theirs) = if readable {\n+                    (writer, reader)\n+                } else {\n+                    (reader, writer)\n+                };\n+                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n+            }\n+\n+            Stdio::Null => {\n+                let mut opts = OpenOptions::new();\n+                opts.read(readable);\n+                opts.write(!readable);\n+                let path = unsafe {\n+                    CStr::from_ptr(\"/dev/null\\0\".as_ptr() as *const _)\n+                };\n+                let fd = File::open_c(&path, &opts)?;\n+                Ok((ChildStdio::Owned(fd.into_fd()), None))\n+            }\n+        }\n+    }\n+}\n+\n+impl ChildStdio {\n+    pub fn fd(&self) -> Option<c_int> {\n+        match *self {\n+            ChildStdio::Inherit => None,\n+            ChildStdio::Explicit(fd) => Some(fd),\n+            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n+        }\n+    }\n+}\n+\n+fn pair_to_key(key: &OsStr, value: &OsStr, saw_nul: &mut bool) -> CString {\n+    let (key, value) = (key.as_bytes(), value.as_bytes());\n+    let mut v = Vec::with_capacity(key.len() + value.len() + 1);\n+    v.extend(key);\n+    v.push(b'=');\n+    v.extend(value);\n+    CString::new(v).unwrap_or_else(|_e| {\n+        *saw_nul = true;\n+        CString::new(\"foo=bar\").unwrap()\n+    })\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.program)?;\n+        for arg in &self.args {\n+            write!(f, \" {:?}\", arg)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// Unix exit statuses\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(c_int);\n+\n+impl ExitStatus {\n+    pub fn new(status: c_int) -> ExitStatus {\n+        ExitStatus(status)\n+    }\n+\n+    fn exited(&self) -> bool {\n+        unsafe { libc::WIFEXITED(self.0) }\n+    }\n+\n+    pub fn success(&self) -> bool {\n+        self.code() == Some(0)\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        if self.exited() {\n+            Some(unsafe { libc::WEXITSTATUS(self.0) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn signal(&self) -> Option<i32> {\n+        if !self.exited() {\n+            Some(unsafe { libc::WTERMSIG(self.0) })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl From<c_int> for ExitStatus {\n+    fn from(a: c_int) -> ExitStatus {\n+        ExitStatus(a)\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if let Some(code) = self.code() {\n+            write!(f, \"exit code: {}\", code)\n+        } else {\n+            let signal = self.signal().unwrap();\n+            write!(f, \"signal: {}\", signal)\n+        }\n+    }\n+}\n+\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n+mod tests {\n+    use super::*;\n+\n+    use ffi::OsStr;\n+    use mem;\n+    use ptr;\n+    use libc;\n+    use sys::cvt;\n+\n+    macro_rules! t {\n+        ($e:expr) => {\n+            match $e {\n+                Ok(t) => t,\n+                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(target_os = \"android\"))]\n+    extern {\n+        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n+        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n+    }\n+\n+    #[cfg(target_os = \"android\")]\n+    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n+        use slice;\n+\n+        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n+        let bit = (signum - 1) as usize;\n+        raw[bit / 8] |= 1 << (bit % 8);\n+        return 0;\n+    }\n+\n+    // See #14232 for more information, but it appears that signal delivery to a\n+    // newly spawned process may just be raced in the OSX, so to prevent this\n+    // test from being flaky we ignore it on OSX.\n+    #[test]\n+    #[cfg_attr(target_os = \"macos\", ignore)]\n+    #[cfg_attr(target_os = \"nacl\", ignore)] // no signals on NaCl.\n+    fn test_process_mask() {\n+        unsafe {\n+            // Test to make sure that a signal mask does not get inherited.\n+            let mut cmd = Command::new(OsStr::new(\"cat\"));\n+\n+            let mut set: libc::sigset_t = mem::uninitialized();\n+            let mut old_set: libc::sigset_t = mem::uninitialized();\n+            t!(cvt(libc::sigemptyset(&mut set)));\n+            t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n+\n+            cmd.stdin(Stdio::MakePipe);\n+            cmd.stdout(Stdio::MakePipe);\n+\n+            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n+            let stdin_write = pipes.stdin.take().unwrap();\n+            let stdout_read = pipes.stdout.take().unwrap();\n+\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n+                                         ptr::null_mut())));\n+\n+            t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n+            // We need to wait until SIGINT is definitely delivered. The\n+            // easiest way is to write something to cat, and try to read it\n+            // back: if SIGINT is unmasked, it'll get delivered when cat is\n+            // next scheduled.\n+            let _ = stdin_write.write(b\"Hello\");\n+            drop(stdin_write);\n+\n+            // Either EOF or failure (EPIPE) is okay.\n+            let mut buf = [0; 5];\n+            if let Ok(ret) = stdout_read.read(&mut buf) {\n+                assert!(ret == 0);\n+            }\n+\n+            t!(cat.wait());\n+        }\n+    }\n+}"}, {"sha": "30e5555df69de1036096bc38f58b2438e20542b6", "filename": "src/libstd/sys/unix/process/process_fuchsia.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/5c1c48532f1f5ce726d1704d33366f8fb371cca0/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1c48532f1f5ce726d1704d33366f8fb371cca0/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=5c1c48532f1f5ce726d1704d33366f8fb371cca0", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use libc;\n+use mem;\n+use ptr;\n+\n+use sys::mx_cvt;\n+use sys::magenta::{launchpad_t, mx_handle_t};\n+use sys::process::process_common::*;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl Command {\n+    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n+                 -> io::Result<(Process, StdioPipes)> {\n+        if self.saw_nul() {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                      \"nul byte found in provided data\"));\n+        }\n+\n+        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n+\n+        let (launchpad, process_handle) = unsafe { self.do_exec(theirs)? };\n+\n+        Ok((Process { launchpad: launchpad, handle: process_handle, status: None }, ours))\n+    }\n+\n+    pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        if self.saw_nul() {\n+            return io::Error::new(io::ErrorKind::InvalidInput,\n+                                  \"nul byte found in provided data\")\n+        }\n+\n+        match self.setup_io(default, true) {\n+            Ok((_, _)) => {\n+                // FIXME: This is tough because we don't support the exec syscalls\n+                unimplemented!();\n+            },\n+            Err(e) => e,\n+        }\n+    }\n+\n+    unsafe fn do_exec(&mut self, stdio: ChildPipes)\n+                      -> io::Result<(*mut launchpad_t, mx_handle_t)> {\n+        use sys::magenta::*;\n+\n+        let job_handle = mxio_get_startup_handle(mx_hnd_info(MX_HND_TYPE_JOB, 0));\n+        let envp = match *self.get_envp() {\n+            Some(ref envp) => envp.as_ptr(),\n+            None => ptr::null(),\n+        };\n+\n+        // To make sure launchpad_destroy gets called on the launchpad if this function fails\n+        struct LaunchpadDestructor(*mut launchpad_t);\n+        impl Drop for LaunchpadDestructor {\n+            fn drop(&mut self) { unsafe { launchpad_destroy(self.0); } }\n+        }\n+\n+        let mut launchpad: *mut launchpad_t = ptr::null_mut();\n+        let launchpad_destructor = LaunchpadDestructor(launchpad);\n+\n+        // Duplicate the job handle\n+        let mut job_copy: mx_handle_t = MX_HANDLE_INVALID;\n+        mx_cvt(mx_handle_duplicate(job_handle, MX_RIGHT_SAME_RIGHTS,\n+                                   &mut job_copy as *mut mx_handle_t))?;\n+        // Create a launchpad\n+        mx_cvt(launchpad_create(job_copy, self.get_argv()[0],\n+                                &mut launchpad as *mut *mut launchpad_t))?;\n+        // Set the process argv\n+        mx_cvt(launchpad_arguments(launchpad, self.get_argv().len() as i32 - 1,\n+                                   self.get_argv().as_ptr()))?;\n+        // Setup the environment vars\n+        mx_cvt(launchpad_environ(launchpad, envp))?;\n+        mx_cvt(launchpad_add_vdso_vmo(launchpad))?;\n+        mx_cvt(launchpad_clone_mxio_root(launchpad))?;\n+        // Load the executable\n+        mx_cvt(launchpad_elf_load(launchpad, launchpad_vmo_from_file(self.get_argv()[0])))?;\n+        mx_cvt(launchpad_load_vdso(launchpad, MX_HANDLE_INVALID))?;\n+        mx_cvt(launchpad_clone_mxio_cwd(launchpad))?;\n+\n+        // Clone stdin, stdout, and stderr\n+        if let Some(fd) = stdio.stdin.fd() {\n+            launchpad_transfer_fd(launchpad, fd, 0);\n+        } else {\n+            launchpad_clone_fd(launchpad, 0, 0);\n+        }\n+        if let Some(fd) = stdio.stdout.fd() {\n+            launchpad_transfer_fd(launchpad, fd, 1);\n+        } else {\n+            launchpad_clone_fd(launchpad, 1, 1);\n+        }\n+        if let Some(fd) = stdio.stderr.fd() {\n+            launchpad_transfer_fd(launchpad, fd, 2);\n+        } else {\n+            launchpad_clone_fd(launchpad, 2, 2);\n+        }\n+\n+        // We don't want FileDesc::drop to be called on any stdio. It would close their fds. The\n+        // fds will be closed once the child process finishes.\n+        mem::forget(stdio);\n+\n+        for callback in self.get_closures().iter_mut() {\n+            callback()?;\n+        }\n+\n+        let process_handle = mx_cvt(launchpad_start(launchpad))?;\n+\n+        // Successfully started the launchpad, so launchpad_destroy shouldn't get called\n+        mem::forget(launchpad_destructor);\n+\n+        Ok((launchpad, process_handle))\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Process {\n+    launchpad: *mut launchpad_t,\n+    handle: mx_handle_t,\n+    status: Option<ExitStatus>,\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        self.handle as u32\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        use sys::magenta::*;\n+\n+        // If we've already waited on this process then the pid can be recycled\n+        // and used for another process, and we probably shouldn't be killing\n+        // random processes, so just return an error.\n+        if self.status.is_some() {\n+            Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                           \"invalid argument: can't kill an exited process\"))\n+        } else {\n+            unsafe {\n+                mx_cvt(mx_handle_close(self.handle))?;\n+                launchpad_destroy(self.launchpad);\n+            }\n+            Ok(())\n+        }\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        use default::Default;\n+        use sys::magenta::*;\n+\n+        if let Some(status) = self.status {\n+            return Ok(status)\n+        }\n+\n+        let mut proc_info: mx_info_process_t = Default::default();\n+        let mut actual: mx_size_t = 0;\n+        let mut avail: mx_size_t = 0;\n+\n+        unsafe {\n+            mx_cvt(mx_handle_wait_one(self.handle, MX_TASK_TERMINATED,\n+                                      MX_TIME_INFINITE, ptr::null_mut()))?;\n+            mx_cvt(mx_object_get_info(self.handle, MX_INFO_PROCESS,\n+                                      &mut proc_info as *mut _ as *mut libc::c_void,\n+                                      mem::size_of::<mx_info_process_t>(), &mut actual,\n+                                      &mut avail))?;\n+        }\n+        if actual != 1 {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                  \"Failed to get exit status of process\"));\n+        }\n+        self.status = Some(ExitStatus::new(proc_info.rec.return_code));\n+        unsafe {\n+            mx_cvt(mx_handle_close(self.handle))?;\n+            launchpad_destroy(self.launchpad);\n+        }\n+        Ok(ExitStatus::new(proc_info.rec.return_code))\n+    }\n+}"}, {"sha": "aa42672202559f94d5283064627808c1692c2667", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/5c1c48532f1f5ce726d1704d33366f8fb371cca0/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1c48532f1f5ce726d1704d33366f8fb371cca0/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=5c1c48532f1f5ce726d1704d33366f8fb371cca0", "patch": "@@ -0,0 +1,250 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io::{self, Error, ErrorKind};\n+use libc::{self, c_int, gid_t, pid_t, uid_t};\n+use mem;\n+use ptr;\n+\n+use sys::cvt;\n+use sys::process::process_common::*;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl Command {\n+    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n+                 -> io::Result<(Process, StdioPipes)> {\n+        use sys;\n+\n+        const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n+\n+        if self.saw_nul() {\n+            return Err(io::Error::new(ErrorKind::InvalidInput,\n+                                      \"nul byte found in provided data\"));\n+        }\n+\n+        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n+        let (input, output) = sys::pipe::anon_pipe()?;\n+\n+        let pid = unsafe {\n+            match cvt(libc::fork())? {\n+                0 => {\n+                    drop(input);\n+                    let err = self.do_exec(theirs);\n+                    let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n+                    let bytes = [\n+                        (errno >> 24) as u8,\n+                        (errno >> 16) as u8,\n+                        (errno >>  8) as u8,\n+                        (errno >>  0) as u8,\n+                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n+                    ];\n+                    // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n+                    // we want to be sure we *don't* run at_exit destructors as\n+                    // we're being torn down regardless\n+                    assert!(output.write(&bytes).is_ok());\n+                    libc::_exit(1)\n+                }\n+                n => n,\n+            }\n+        };\n+\n+        let mut p = Process { pid: pid, status: None };\n+        drop(output);\n+        let mut bytes = [0; 8];\n+\n+        // loop to handle EINTR\n+        loop {\n+            match input.read(&mut bytes) {\n+                Ok(0) => return Ok((p, ours)),\n+                Ok(8) => {\n+                    assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n+                            \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n+                    let errno = combine(&bytes[0.. 4]);\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    return Err(Error::from_raw_os_error(errno))\n+                }\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                Err(e) => {\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n+                },\n+                Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    panic!(\"short read on the CLOEXEC pipe\")\n+                }\n+            }\n+        }\n+\n+        fn combine(arr: &[u8]) -> i32 {\n+            let a = arr[0] as u32;\n+            let b = arr[1] as u32;\n+            let c = arr[2] as u32;\n+            let d = arr[3] as u32;\n+\n+            ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n+        }\n+    }\n+\n+    pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        if self.saw_nul() {\n+            return io::Error::new(ErrorKind::InvalidInput,\n+                                  \"nul byte found in provided data\")\n+        }\n+\n+        match self.setup_io(default, true) {\n+            Ok((_, theirs)) => unsafe { self.do_exec(theirs) },\n+            Err(e) => e,\n+        }\n+    }\n+\n+    // And at this point we've reached a special time in the life of the\n+    // child. The child must now be considered hamstrung and unable to\n+    // do anything other than syscalls really. Consider the following\n+    // scenario:\n+    //\n+    //      1. Thread A of process 1 grabs the malloc() mutex\n+    //      2. Thread B of process 1 forks(), creating thread C\n+    //      3. Thread C of process 2 then attempts to malloc()\n+    //      4. The memory of process 2 is the same as the memory of\n+    //         process 1, so the mutex is locked.\n+    //\n+    // This situation looks a lot like deadlock, right? It turns out\n+    // that this is what pthread_atfork() takes care of, which is\n+    // presumably implemented across platforms. The first thing that\n+    // threads to *before* forking is to do things like grab the malloc\n+    // mutex, and then after the fork they unlock it.\n+    //\n+    // Despite this information, libnative's spawn has been witnessed to\n+    // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n+    // all collected backtraces point at malloc/free traffic in the\n+    // child spawned process.\n+    //\n+    // For this reason, the block of code below should contain 0\n+    // invocations of either malloc of free (or their related friends).\n+    //\n+    // As an example of not having malloc/free traffic, we don't close\n+    // this file descriptor by dropping the FileDesc (which contains an\n+    // allocation). Instead we just close it manually. This will never\n+    // have the drop glue anyway because this code never returns (the\n+    // child will either exec() or invoke libc::exit)\n+    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n+        use sys::{self, cvt_r};\n+\n+        macro_rules! t {\n+            ($e:expr) => (match $e {\n+                Ok(e) => e,\n+                Err(e) => return e,\n+            })\n+        }\n+\n+        if let Some(fd) = stdio.stdin.fd() {\n+            t!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n+        }\n+        if let Some(fd) = stdio.stdout.fd() {\n+            t!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n+        }\n+        if let Some(fd) = stdio.stderr.fd() {\n+            t!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n+        }\n+\n+        if let Some(u) = self.get_gid() {\n+            t!(cvt(libc::setgid(u as gid_t)));\n+        }\n+        if let Some(u) = self.get_uid() {\n+            // When dropping privileges from root, the `setgroups` call\n+            // will remove any extraneous groups. If we don't call this,\n+            // then even though our uid has dropped, we may still have\n+            // groups that enable us to do super-user things. This will\n+            // fail if we aren't root, so don't bother checking the\n+            // return value, this is just done as an optimistic\n+            // privilege dropping function.\n+            let _ = libc::setgroups(0, ptr::null());\n+\n+            t!(cvt(libc::setuid(u as uid_t)));\n+        }\n+        if let Some(ref cwd) = *self.get_cwd() {\n+            t!(cvt(libc::chdir(cwd.as_ptr())));\n+        }\n+        if let Some(ref envp) = *self.get_envp() {\n+            *sys::os::environ() = envp.as_ptr();\n+        }\n+\n+        // NaCl has no signal support.\n+        if cfg!(not(any(target_os = \"nacl\", target_os = \"emscripten\"))) {\n+            // Reset signal handling so the child process starts in a\n+            // standardized state. libstd ignores SIGPIPE, and signal-handling\n+            // libraries often set a mask. Child processes inherit ignored\n+            // signals and the signal mask from their parent, but most\n+            // UNIX programs do not reset these things on their own, so we\n+            // need to clean things up now to avoid confusing the program\n+            // we're about to run.\n+            let mut set: libc::sigset_t = mem::uninitialized();\n+            t!(cvt(libc::sigemptyset(&mut set)));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n+                                         ptr::null_mut())));\n+            let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n+            if ret == libc::SIG_ERR {\n+                return io::Error::last_os_error()\n+            }\n+        }\n+\n+        for callback in self.get_closures().iter_mut() {\n+            t!(callback());\n+        }\n+\n+        libc::execvp(self.get_argv()[0], self.get_argv().as_ptr());\n+        io::Error::last_os_error()\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// The unique id of the process (this should never be negative).\n+pub struct Process {\n+    pid: pid_t,\n+    status: Option<ExitStatus>,\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        self.pid as u32\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        // If we've already waited on this process then the pid can be recycled\n+        // and used for another process, and we probably shouldn't be killing\n+        // random processes, so just return an error.\n+        if self.status.is_some() {\n+            Err(Error::new(ErrorKind::InvalidInput,\n+                           \"invalid argument: can't kill an exited process\"))\n+        } else {\n+            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(|_| ())\n+        }\n+    }\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        use sys::cvt_r;\n+        if let Some(status) = self.status {\n+            return Ok(status)\n+        }\n+        let mut status = 0 as c_int;\n+        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n+        self.status = Some(ExitStatus::new(status));\n+        Ok(ExitStatus::new(status))\n+    }\n+}"}]}