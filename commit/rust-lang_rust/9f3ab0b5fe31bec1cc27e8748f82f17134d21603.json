{"sha": "9f3ab0b5fe31bec1cc27e8748f82f17134d21603", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmM2FiMGI1ZmUzMWJlYzFjYzI3ZTg3NDhmODJmMTcxMzRkMjE2MDM=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-06-23T23:11:29Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-06-23T23:11:29Z"}, "message": "Format comments in struct literals", "tree": {"sha": "99369f15db66dbe8b2f98272662dad7d8e9c8ccb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99369f15db66dbe8b2f98272662dad7d8e9c8ccb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f3ab0b5fe31bec1cc27e8748f82f17134d21603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3ab0b5fe31bec1cc27e8748f82f17134d21603", "html_url": "https://github.com/rust-lang/rust/commit/9f3ab0b5fe31bec1cc27e8748f82f17134d21603", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f3ab0b5fe31bec1cc27e8748f82f17134d21603/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ef5db9496fddfb5a26131a5a4dc8b2fcce40dde", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef5db9496fddfb5a26131a5a4dc8b2fcce40dde", "html_url": "https://github.com/rust-lang/rust/commit/0ef5db9496fddfb5a26131a5a4dc8b2fcce40dde"}], "stats": {"total": 155, "additions": 108, "deletions": 47}, "files": [{"sha": "56c8772dd9edad85c1c2bb0c9dead3c22f18e0d4", "filename": "src/expr.rs", "status": "modified", "additions": 67, "deletions": 28, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9f3ab0b5fe31bec1cc27e8748f82f17134d21603/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3ab0b5fe31bec1cc27e8748f82f17134d21603/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=9f3ab0b5fe31bec1cc27e8748f82f17134d21603", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n use rewrite::{Rewrite, RewriteContext};\n-use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n+use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n use string::{StringFormat, rewrite_string};\n+use utils::span_after;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{Pos, Span, BytePos};\n@@ -37,11 +38,13 @@ impl Rewrite for ast::Expr {\n                 return rewrite_paren(context, subexpr, width, offset);\n             }\n             ast::Expr_::ExprStruct(ref path, ref fields, ref base) => {\n-                return rewrite_struct_lit(context, path,\n-                                               fields,\n-                                               base.as_ref().map(|e| &**e),\n-                                               width,\n-                                               offset);\n+                return rewrite_struct_lit(context,\n+                                          path,\n+                                          fields,\n+                                          base.as_ref().map(|e| &**e),\n+                                          self.span,\n+                                          width,\n+                                          offset);\n             }\n             ast::Expr_::ExprTup(ref items) => {\n                 return rewrite_tuple_lit(context, items, self.span, width, offset);\n@@ -107,8 +110,10 @@ fn rewrite_call(context: &RewriteContext,\n                              \")\",\n                              |item| item.span.lo,\n                              |item| item.span.hi,\n+                             // Take old span when rewrite fails.\n                              |item| item.rewrite(context, remaining_width, offset)\n-                                        .unwrap(), // FIXME: don't unwrap, take span literal\n+                                        .unwrap_or(context.codemap.span_to_snippet(item.span)\n+                                                                  .unwrap()),\n                              callee.span.hi + BytePos(1),\n                              span.hi);\n \n@@ -134,35 +139,68 @@ fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, width: usize, of\n     subexpr_str.map(|s| format!(\"({})\", s))\n }\n \n-fn rewrite_struct_lit(context: &RewriteContext,\n-                      path: &ast::Path,\n-                      fields: &[ast::Field],\n-                      base: Option<&ast::Expr>,\n-                      width: usize,\n-                      offset: usize)\n+fn rewrite_struct_lit<'a>(context: &RewriteContext,\n+                          path: &ast::Path,\n+                          fields: &'a [ast::Field],\n+                          base: Option<&'a ast::Expr>,\n+                          span: Span,\n+                          width: usize,\n+                          offset: usize)\n         -> Option<String>\n {\n     debug!(\"rewrite_struct_lit: width {}, offset {}\", width, offset);\n     assert!(fields.len() > 0 || base.is_some());\n \n+    enum StructLitField<'a> {\n+        Regular(&'a ast::Field),\n+        Base(&'a ast::Expr)\n+    }\n+\n     let path_str = pprust::path_to_string(path);\n     // Foo { a: Foo } - indent is +3, width is -5.\n     let indent = offset + path_str.len() + 3;\n     let budget = width - (path_str.len() + 5);\n \n-    let field_strs: Vec<_> =\n-        try_opt!(fields.iter()\n-                       .map(|field| rewrite_field(context, field, budget, indent))\n-                       .chain(base.iter()\n-                                  .map(|expr| expr.rewrite(context,\n-                                                           // 2 = \"..\"\n-                                                           budget - 2,\n-                                                           indent + 2)\n-                                                  .map(|s| format!(\"..{}\", s))))\n-                       .collect());\n-\n-    // FIXME comments\n-    let field_strs: Vec<_> = field_strs.into_iter().map(ListItem::from_str).collect();\n+    let field_iter = fields.into_iter().map(StructLitField::Regular)\n+                           .chain(base.into_iter().map(StructLitField::Base));\n+\n+    let items = itemize_list(context.codemap,\n+                             Vec::new(),\n+                             field_iter,\n+                             \",\",\n+                             \"}\",\n+                             |item| {\n+                                 match *item {\n+                                     StructLitField::Regular(ref field) => field.span.lo,\n+                                     // 2 = ..\n+                                     StructLitField::Base(ref expr) => expr.span.lo - BytePos(2)\n+                                 }\n+                             },\n+                             |item| {\n+                                 match *item {\n+                                     StructLitField::Regular(ref field) => field.span.hi,\n+                                     StructLitField::Base(ref expr) => expr.span.hi\n+                                 }\n+                             },\n+                             |item| {\n+                                 match *item {\n+                                     StructLitField::Regular(ref field) => {\n+                                         rewrite_field(context, &field, budget, indent)\n+                                            .unwrap_or(context.codemap.span_to_snippet(field.span)\n+                                                                      .unwrap())\n+                                     },\n+                                     StructLitField::Base(ref expr) => {\n+                                         // 2 = ..\n+                                         expr.rewrite(context, budget - 2, indent + 2)\n+                                             .map(|s| format!(\"..{}\", s))\n+                                             .unwrap_or(context.codemap.span_to_snippet(expr.span)\n+                                                                       .unwrap())\n+                                     }\n+                                 }\n+                             },\n+                             span_after(span, \"{\", context.codemap),\n+                             span.hi);\n+\n     let fmt = ListFormatting {\n         tactic: ListTactic::HorizontalVertical,\n         separator: \",\",\n@@ -176,7 +214,7 @@ fn rewrite_struct_lit(context: &RewriteContext,\n         v_width: budget,\n         is_expression: true,\n     };\n-    let fields_str = write_list(&field_strs, &fmt);\n+    let fields_str = write_list(&items, &fmt);\n     Some(format!(\"{} {{ {} }}\", path_str, fields_str))\n \n     // FIXME if the usual multi-line layout is too wide, we should fall back to\n@@ -210,7 +248,8 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                              |item| item.rewrite(context,\n                                                  context.config.max_width - indent - 2,\n                                                  indent)\n-                                        .unwrap(), // FIXME: don't unwrap, take span literal\n+                                        .unwrap_or(context.codemap.span_to_snippet(item.span)\n+                                                                  .unwrap()),\n                              span.lo + BytePos(1), // Remove parens\n                              span.hi - BytePos(1));\n "}, {"sha": "10a93c23033ddb696508943ffee53f76a4c66621", "filename": "src/items.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f3ab0b5fe31bec1cc27e8748f82f17134d21603/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3ab0b5fe31bec1cc27e8748f82f17134d21603/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=9f3ab0b5fe31bec1cc27e8748f82f17134d21603", "patch": "@@ -11,7 +11,7 @@\n // Formatting top-level items - functions, structs, enums, traits, impls.\n \n use {ReturnIndent, BraceStyle};\n-use utils::{format_visibility, make_indent, contains_skip};\n+use utils::{format_visibility, make_indent, contains_skip, span_after};\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n use comment::FindUncommented;\n use visitor::FmtVisitor;\n@@ -165,7 +165,7 @@ impl<'a> FmtVisitor<'a> {\n                                            one_line_budget,\n                                            multi_line_budget,\n                                            arg_indent,\n-                                           codemap::mk_sp(self.span_after(span, \"(\"),\n+                                           codemap::mk_sp(span_after(span, \"(\", self.codemap),\n                                                           span_for_return(&fd.output).lo)));\n         result.push(')');\n \n@@ -278,7 +278,7 @@ impl<'a> FmtVisitor<'a> {\n         // You also don't get to put a comment on self, unless it is explicit.\n         if args.len() >= min_args {\n             let comment_span_start = if min_args == 2 {\n-                self.span_after(span, \",\")\n+                span_after(span, \",\", self.codemap)\n             } else {\n                 span.lo\n             };\n@@ -438,7 +438,7 @@ impl<'a> FmtVisitor<'a> {\n                                              |arg| arg.ty.span.lo,\n                                              |arg| arg.ty.span.hi,\n                                              |arg| pprust::ty_to_string(&arg.ty),\n-                                             self.span_after(field.span, \"(\"),\n+                                             span_after(field.span, \"(\", self.codemap),\n                                              next_span_start);\n \n                     result.push('(');\n@@ -549,7 +549,7 @@ impl<'a> FmtVisitor<'a> {\n                                  },\n                                  |field| field.node.ty.span.hi,\n                                  |field| self.format_field(field),\n-                                 self.span_after(span, opener.trim()),\n+                                 span_after(span, opener.trim(), self.codemap),\n                                  span.hi);\n \n         // 2 terminators and a semicolon\n@@ -714,7 +714,7 @@ impl<'a> FmtVisitor<'a> {\n                                      |sp| sp.lo,\n                                      |sp| sp.hi,\n                                      |_| String::new(),\n-                                     self.span_after(span, \"<\"),\n+                                     span_after(span, \"<\", self.codemap),\n                                      span.hi);\n \n         for (item, ty) in items.iter_mut().zip(lt_strs.chain(ty_strs)) {\n@@ -793,12 +793,6 @@ impl<'a> FmtVisitor<'a> {\n                 pprust::pat_to_string(&arg.pat),\n                 pprust::ty_to_string(&arg.ty))\n     }\n-\n-    fn span_after(&self, original: Span, needle: &str) -> BytePos {\n-        let snippet = self.snippet(original);\n-\n-        original.lo + BytePos(snippet.find_uncommented(needle).unwrap() as u32 + 1)\n-    }\n }\n \n fn span_for_return(ret: &ast::FunctionRetTy) -> Span {"}, {"sha": "aefc93d7c86ec259443149ce01b99e14ae0c26df", "filename": "src/lists.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f3ab0b5fe31bec1cc27e8748f82f17134d21603/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3ab0b5fe31bec1cc27e8748f82f17134d21603/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=9f3ab0b5fe31bec1cc27e8748f82f17134d21603", "patch": "@@ -203,10 +203,11 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> St\n         }\n \n         if tactic == ListTactic::Vertical && item.post_comment.is_some() {\n-            let width = formatting.v_width - item_width - 1; // Space between item and comment\n+            // 1 = space between item and comment.\n+            let width = formatting.v_width.checked_sub(item_width + 1).unwrap_or(1);\n             let offset = formatting.indent + item_width + 1;\n             let comment = item.post_comment.as_ref().unwrap();\n-            // Use block-style only for the last item or multiline comments\n+            // Use block-style only for the last item or multiline comments.\n             let block_style = formatting.is_expression && last ||\n                               comment.trim().contains('\\n') ||\n                               comment.trim().len() > width;\n@@ -241,7 +242,7 @@ pub fn itemize_list<T, I, F1, F2, F3>(codemap: &CodeMap,\n                                       terminator: &str,\n                                       get_lo: F1,\n                                       get_hi: F2,\n-                                      get_item: F3,\n+                                      get_item_string: F3,\n                                       mut prev_span_end: BytePos,\n                                       next_span_start: BytePos)\n     -> Vec<ListItem>\n@@ -306,7 +307,7 @@ pub fn itemize_list<T, I, F1, F2, F3>(codemap: &CodeMap,\n \n         result.push(ListItem {\n             pre_comment: pre_comment,\n-            item: get_item(&item),\n+            item: get_item_string(&item),\n             post_comment: if post_snippet.len() > 0 {\n                 Some(post_snippet.to_owned())\n             } else {"}, {"sha": "de17f989f7a9f6ce130fc6f6c7b6175f70afdd41", "filename": "src/utils.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f3ab0b5fe31bec1cc27e8748f82f17134d21603/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3ab0b5fe31bec1cc27e8748f82f17134d21603/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=9f3ab0b5fe31bec1cc27e8748f82f17134d21603", "patch": "@@ -9,9 +9,19 @@\n // except according to those terms.\n \n use syntax::ast::{Visibility, Attribute, MetaItem, MetaItem_};\n+use syntax::codemap::{CodeMap, Span, BytePos};\n+\n+use comment::FindUncommented;\n \n use SKIP_ANNOTATION;\n \n+#[inline]\n+pub fn span_after(original: Span, needle: &str, codemap: &CodeMap) -> BytePos {\n+    let snippet = codemap.span_to_snippet(original).unwrap();\n+\n+    original.lo + BytePos(snippet.find_uncommented(needle).unwrap() as u32 + 1)\n+}\n+\n #[inline]\n pub fn prev_char(s: &str, mut i: usize) -> usize {\n     if i == 0 { return 0; }"}, {"sha": "ad6e1c085b3857f4fc33cb79de14b6541421c8d3", "filename": "tests/target/multiple.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9f3ab0b5fe31bec1cc27e8748f82f17134d21603/tests%2Ftarget%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3ab0b5fe31bec1cc27e8748f82f17134d21603/tests%2Ftarget%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmultiple.rs?ref=9f3ab0b5fe31bec1cc27e8748f82f17134d21603", "patch": "@@ -145,11 +145,28 @@ fn struct_lits() {\n     let x = Bar;\n     // Comment\n     let y = Foo { a: x };\n-    Foo { a: foo(), b: bar(), ..something };\n+    Foo { a: foo(), // comment\n+          // comment\n+          b: bar(),\n+          ..something };\n     Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(),\n                                                                                b: bar(), };\n-    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(),\n-                                                                                         b: bar(), };\n+    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { // Comment\n+                                                                                         a: foo(), /* C\n+                                                                                                    * o\n+                                                                                                    * m\n+                                                                                                    * m\n+                                                                                                    * e\n+                                                                                                    * n\n+                                                                                                    * t */\n+                                                                                         // Comment\n+                                                                                         b: bar(), /* C\n+                                                                                                    * o\n+                                                                                                    * m\n+                                                                                                    * m\n+                                                                                                    * e\n+                                                                                                    * n\n+                                                                                                    * t */ };\n \n     Foo { a: Bar, b: foo() };\n }"}]}