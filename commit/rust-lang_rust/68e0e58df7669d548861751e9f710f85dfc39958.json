{"sha": "68e0e58df7669d548861751e9f710f85dfc39958", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZTBlNThkZjc2NjlkNTQ4ODYxNzUxZTlmNzEwZjg1ZGZjMzk5NTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-28T07:59:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-28T07:59:21Z"}, "message": "Auto merge of #50612 - Zoxc:thin-slice, r=michaelwoerister\n\nMake &Slice a thin pointer\n\nSplit out from https://github.com/rust-lang/rust/pull/50395\n\nr? @michaelwoerister", "tree": {"sha": "ee43357358b8a2db29dd0d4e18e13c6ad5bce4e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee43357358b8a2db29dd0d4e18e13c6ad5bce4e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68e0e58df7669d548861751e9f710f85dfc39958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68e0e58df7669d548861751e9f710f85dfc39958", "html_url": "https://github.com/rust-lang/rust/commit/68e0e58df7669d548861751e9f710f85dfc39958", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68e0e58df7669d548861751e9f710f85dfc39958/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0456c6f8fe8a88a080b6d4973c8e279de4afe0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0456c6f8fe8a88a080b6d4973c8e279de4afe0f", "html_url": "https://github.com/rust-lang/rust/commit/d0456c6f8fe8a88a080b6d4973c8e279de4afe0f"}, {"sha": "fb4e3b62e05555815b7e2b55383b853c472c3712", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb4e3b62e05555815b7e2b55383b853c472c3712", "html_url": "https://github.com/rust-lang/rust/commit/fb4e3b62e05555815b7e2b55383b853c472c3712"}], "stats": {"total": 182, "additions": 133, "deletions": 49}, "files": [{"sha": "b6a81596d06cc7ea1997757b83f669e023ab9236", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/68e0e58df7669d548861751e9f710f85dfc39958/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e0e58df7669d548861751e9f710f85dfc39958/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=68e0e58df7669d548861751e9f710f85dfc39958", "patch": "@@ -314,17 +314,15 @@ impl DroplessArena {\n         false\n     }\n \n-    fn align_for<T>(&self) {\n-        let align = mem::align_of::<T>();\n+    fn align(&self, align: usize) {\n         let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n         self.ptr.set(final_address as *mut u8);\n         assert!(self.ptr <= self.end);\n     }\n \n     #[inline(never)]\n     #[cold]\n-    fn grow<T>(&self, n: usize) {\n-        let needed_bytes = n * mem::size_of::<T>();\n+    fn grow(&self, needed_bytes: usize) {\n         unsafe {\n             let mut chunks = self.chunks.borrow_mut();\n             let (chunk, mut new_capacity);\n@@ -356,25 +354,38 @@ impl DroplessArena {\n     }\n \n     #[inline]\n-    pub fn alloc<T>(&self, object: T) -> &mut T {\n+    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n         unsafe {\n-            assert!(!mem::needs_drop::<T>());\n-            assert!(mem::size_of::<T>() != 0);\n+            assert!(bytes != 0);\n+\n+            self.align(align);\n \n-            self.align_for::<T>();\n-            let future_end = intrinsics::arith_offset(self.ptr.get(), mem::size_of::<T>() as isize);\n+            let future_end = intrinsics::arith_offset(self.ptr.get(), bytes as isize);\n             if (future_end as *mut u8) >= self.end.get() {\n-                self.grow::<T>(1)\n+                self.grow(bytes);\n             }\n \n             let ptr = self.ptr.get();\n             // Set the pointer past ourselves\n             self.ptr.set(\n-                intrinsics::arith_offset(self.ptr.get(), mem::size_of::<T>() as isize) as *mut u8,\n+                intrinsics::arith_offset(self.ptr.get(), bytes as isize) as *mut u8,\n             );\n+            slice::from_raw_parts_mut(ptr, bytes)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc<T>(&self, object: T) -> &mut T {\n+        assert!(!mem::needs_drop::<T>());\n+\n+        let mem = self.alloc_raw(\n+            mem::size_of::<T>(),\n+            mem::align_of::<T>()) as *mut _ as *mut T;\n+\n+        unsafe {\n             // Write into uninitialized memory.\n-            ptr::write(ptr as *mut T, object);\n-            &mut *(ptr as *mut T)\n+            ptr::write(mem, object);\n+            &mut *mem\n         }\n     }\n \n@@ -393,21 +404,13 @@ impl DroplessArena {\n         assert!(!mem::needs_drop::<T>());\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n-        self.align_for::<T>();\n \n-        let future_end = unsafe {\n-            intrinsics::arith_offset(self.ptr.get(), (slice.len() * mem::size_of::<T>()) as isize)\n-        };\n-        if (future_end as *mut u8) >= self.end.get() {\n-            self.grow::<T>(slice.len());\n-        }\n+        let mem = self.alloc_raw(\n+            slice.len() * mem::size_of::<T>(),\n+            mem::align_of::<T>()) as *mut _ as *mut T;\n \n         unsafe {\n-            let arena_slice = slice::from_raw_parts_mut(self.ptr.get() as *mut T, slice.len());\n-            self.ptr.set(intrinsics::arith_offset(\n-                self.ptr.get(),\n-                (slice.len() * mem::size_of::<T>()) as isize,\n-            ) as *mut u8);\n+            let arena_slice = slice::from_raw_parts_mut(mem, slice.len());\n             arena_slice.copy_from_slice(slice);\n             arena_slice\n         }\n@@ -464,6 +467,12 @@ impl SyncDroplessArena {\n         self.lock.lock().in_arena(ptr)\n     }\n \n+    #[inline(always)]\n+    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n+        // Extend the lifetime of the result since it's limited to the lock guard\n+        unsafe { &mut *(self.lock.lock().alloc_raw(bytes, align) as *mut [u8]) }\n+    }\n+\n     #[inline(always)]\n     pub fn alloc<T>(&self, object: T) -> &mut T {\n         // Extend the lifetime of the result since it's limited to the lock guard"}, {"sha": "783d4a472a50ae022ef89bbb8904dd75f0c1b5e2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68e0e58df7669d548861751e9f710f85dfc39958/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e0e58df7669d548861751e9f710f85dfc39958/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=68e0e58df7669d548861751e9f710f85dfc39958", "patch": "@@ -54,6 +54,7 @@\n #![feature(macro_vis_matcher)]\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]\n+#![feature(extern_types)]\n #![feature(non_exhaustive)]\n #![feature(proc_macro_internals)]\n #![feature(quote)]"}, {"sha": "2b2da6f842bb6245973e53162996c66c31f1c12c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/68e0e58df7669d548861751e9f710f85dfc39958/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e0e58df7669d548861751e9f710f85dfc39958/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=68e0e58df7669d548861751e9f710f85dfc39958", "patch": "@@ -794,6 +794,12 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n \n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n+        // Ensure our type representation does not grow\n+        #[cfg(target_pointer_width = \"64\")]\n+        assert!(mem::size_of::<ty::TypeVariants>() <= 24);\n+        #[cfg(target_pointer_width = \"64\")]\n+        assert!(mem::size_of::<ty::TyS>() <= 32);\n+\n         let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);\n         let mk_region = |r| {\n             if let Some(r) = interners.region.borrow().get(&r) {\n@@ -2056,9 +2062,8 @@ for Interned<'tcx, Slice<Goal<'tcx>>> {\n \n macro_rules! intern_method {\n     ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n-                                            $alloc_method:ident,\n+                                            $alloc_method:expr,\n                                             $alloc_to_key:expr,\n-                                            $alloc_to_ret:expr,\n                                             $keep_in_local_tcx:expr) -> $ty:ty) => {\n         impl<'a, 'gcx, $lt_tcx> TyCtxt<'a, 'gcx, $lt_tcx> {\n             pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n@@ -2081,7 +2086,7 @@ macro_rules! intern_method {\n                              v);\n                     }\n \n-                    let i = ($alloc_to_ret)(self.interners.arena.$alloc_method(v));\n+                    let i = $alloc_method(&self.interners.arena, v);\n                     interner.insert(Interned(i));\n                     i\n                 } else {\n@@ -2094,7 +2099,9 @@ macro_rules! intern_method {\n                     let v = unsafe {\n                         mem::transmute(v)\n                     };\n-                    let i = ($alloc_to_ret)(self.global_interners.arena.$alloc_method(v));\n+                    let i: &$lt_tcx $ty = $alloc_method(&self.global_interners.arena, v);\n+                    // Cast to 'gcx\n+                    let i = unsafe { mem::transmute(i) };\n                     interner.insert(Interned(i));\n                     i\n                 }\n@@ -2121,8 +2128,10 @@ macro_rules! direct_interners {\n \n         intern_method!(\n             $lt_tcx,\n-            $name: $method($ty, alloc, |x| x, |x| x, $keep_in_local_tcx) -> $ty\n-        );)+\n+            $name: $method($ty,\n+                           |a: &$lt_tcx SyncDroplessArena, v| -> &$lt_tcx $ty { a.alloc(v) },\n+                           |x| x,\n+                           $keep_in_local_tcx) -> $ty);)+\n     }\n }\n \n@@ -2137,10 +2146,11 @@ direct_interners!('tcx,\n \n macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ident)),+) => (\n-        $(intern_method!('tcx, $field: $method(&[$ty<'tcx>], alloc_slice, Deref::deref,\n-                                               |xs: &[$ty]| -> &Slice<$ty> {\n-            unsafe { mem::transmute(xs) }\n-        }, |xs: &[$ty]| xs.iter().any(keep_local)) -> Slice<$ty<'tcx>>);)+\n+        $(intern_method!( 'tcx, $field: $method(\n+            &[$ty<'tcx>],\n+            |a, v| Slice::from_arena(a, v),\n+            Deref::deref,\n+            |xs: &[$ty]| xs.iter().any(keep_local)) -> Slice<$ty<'tcx>>);)+\n     )\n }\n \n@@ -2162,9 +2172,8 @@ intern_method! {\n     'tcx,\n     canonical_var_infos: _intern_canonical_var_infos(\n         &[CanonicalVarInfo],\n-        alloc_slice,\n+        |a, v| Slice::from_arena(a, v),\n         Deref::deref,\n-        |xs: &[CanonicalVarInfo]| -> &Slice<CanonicalVarInfo> { unsafe { mem::transmute(xs) } },\n         |_xs: &[CanonicalVarInfo]| -> bool { false }\n     ) -> Slice<CanonicalVarInfo>\n }"}, {"sha": "775c7c234fda1bd87fe777df9da14b114fa167ef", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 76, "deletions": 11, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/68e0e58df7669d548861751e9f710f85dfc39958/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e0e58df7669d548861751e9f710f85dfc39958/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=68e0e58df7669d548861751e9f710f85dfc39958", "patch": "@@ -36,6 +36,7 @@ use ty::util::{IntTypeExt, Discr};\n use ty::walk::TypeWalker;\n use util::captures::Captures;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use arena::SyncDroplessArena;\n \n use serialize::{self, Encodable, Encoder};\n use std::cell::RefCell;\n@@ -582,54 +583,113 @@ impl <'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for Ty<'tcx> {\n     }\n }\n \n+extern {\n+    /// A dummy type used to force Slice to by unsized without requiring fat pointers\n+    type OpaqueSliceContents;\n+}\n+\n /// A wrapper for slices with the additional invariant\n /// that the slice is interned and no other slice with\n /// the same contents can exist in the same context.\n-/// This means we can use pointer + length for both\n+/// This means we can use pointer for both\n /// equality comparisons and hashing.\n-#[derive(Debug, RustcEncodable)]\n-pub struct Slice<T>([T]);\n+#[repr(C)]\n+pub struct Slice<T> {\n+    len: usize,\n+    data: [T; 0],\n+    opaque: OpaqueSliceContents,\n+}\n+\n+impl<T: Copy> Slice<T> {\n+    #[inline]\n+    fn from_arena<'tcx>(arena: &'tcx SyncDroplessArena, slice: &[T]) -> &'tcx Slice<T> {\n+        assert!(!mem::needs_drop::<T>());\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(slice.len() != 0);\n+\n+        // Align up the size of the len (usize) field\n+        let align = mem::align_of::<T>();\n+        let align_mask = align - 1;\n+        let offset = mem::size_of::<usize>();\n+        let offset = (offset + align_mask) & !align_mask;\n+\n+        let size = offset + slice.len() * mem::size_of::<T>();\n+\n+        let mem = arena.alloc_raw(\n+            size,\n+            cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n+        unsafe {\n+            let result = &mut *(mem.as_mut_ptr() as *mut Slice<T>);\n+            // Write the length\n+            result.len = slice.len();\n+\n+            // Write the elements\n+            let arena_slice = slice::from_raw_parts_mut(result.data.as_mut_ptr(), result.len);\n+            arena_slice.copy_from_slice(slice);\n+\n+            result\n+        }\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for Slice<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (**self).fmt(f)\n+    }\n+}\n+\n+impl<T: Encodable> Encodable for Slice<T> {\n+    #[inline]\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n \n impl<T> Ord for Slice<T> where T: Ord {\n     fn cmp(&self, other: &Slice<T>) -> Ordering {\n         if self == other { Ordering::Equal } else {\n-            <[T] as Ord>::cmp(&self.0, &other.0)\n+            <[T] as Ord>::cmp(&**self, &**other)\n         }\n     }\n }\n \n impl<T> PartialOrd for Slice<T> where T: PartialOrd {\n     fn partial_cmp(&self, other: &Slice<T>) -> Option<Ordering> {\n         if self == other { Some(Ordering::Equal) } else {\n-            <[T] as PartialOrd>::partial_cmp(&self.0, &other.0)\n+            <[T] as PartialOrd>::partial_cmp(&**self, &**other)\n         }\n     }\n }\n \n-impl<T> PartialEq for Slice<T> {\n+impl<T: PartialEq> PartialEq for Slice<T> {\n     #[inline]\n     fn eq(&self, other: &Slice<T>) -> bool {\n-        (&self.0 as *const [T]) == (&other.0 as *const [T])\n+        (self as *const _) == (other as *const _)\n     }\n }\n-impl<T> Eq for Slice<T> {}\n+impl<T: Eq> Eq for Slice<T> {}\n \n impl<T> Hash for Slice<T> {\n+    #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self.as_ptr(), self.len()).hash(s)\n+        (self as *const Slice<T>).hash(s)\n     }\n }\n \n impl<T> Deref for Slice<T> {\n     type Target = [T];\n+    #[inline(always)]\n     fn deref(&self) -> &[T] {\n-        &self.0\n+        unsafe {\n+            slice::from_raw_parts(self.data.as_ptr(), self.len)\n+        }\n     }\n }\n \n impl<'a, T> IntoIterator for &'a Slice<T> {\n     type Item = &'a T;\n     type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n+    #[inline(always)]\n     fn into_iter(self) -> Self::IntoIter {\n         self[..].iter()\n     }\n@@ -638,9 +698,14 @@ impl<'a, T> IntoIterator for &'a Slice<T> {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<Ty<'tcx>> {}\n \n impl<T> Slice<T> {\n+    #[inline(always)]\n     pub fn empty<'a>() -> &'a Slice<T> {\n+        #[repr(align(64), C)]\n+        struct EmptySlice([u8; 64]);\n+        static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n+        assert!(mem::align_of::<T>() <= 64);\n         unsafe {\n-            mem::transmute(slice::from_raw_parts(0x1 as *const T, 0))\n+            &*(&EMPTY_SLICE as *const _ as *const Slice<T>)\n         }\n     }\n }"}, {"sha": "54b7a3821caadb183f42e0657a5f722327354d47", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68e0e58df7669d548861751e9f710f85dfc39958/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e0e58df7669d548861751e9f710f85dfc39958/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=68e0e58df7669d548861751e9f710f85dfc39958", "patch": "@@ -48,7 +48,7 @@ fn main() {\n //         _2 = move _3;\n //         StorageDead(_3);\n //         StorageLive(_4);\n-//         UserAssertTy(Canonical { variables: Slice([]), value: std::option::Option<std::boxed::Box<u32>> }, _4);\n+//         UserAssertTy(Canonical { variables: [], value: std::option::Option<std::boxed::Box<u32>> }, _4);\n //         _4 = std::option::Option<std::boxed::Box<u32>>::None;\n //         StorageLive(_5);\n //         StorageLive(_6);"}]}