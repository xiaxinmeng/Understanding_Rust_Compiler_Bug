{"sha": "2c5cd9ce53d2d25041db0cb02b40ba460ffa8908", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNWNkOWNlNTNkMmQyNTA0MWRiMGNiMDJiNDBiYTQ2MGZmYTg5MDg=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-07-10T17:16:22Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-07-11T15:52:57Z"}, "message": "Clean up CodegenUnit name generation.", "tree": {"sha": "6a035b3951c42c1d37d1948bc497704a002b73e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a035b3951c42c1d37d1948bc497704a002b73e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908", "html_url": "https://github.com/rust-lang/rust/commit/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dc7ddb9763f28b83de7bf3b3025f8042ea9e830", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dc7ddb9763f28b83de7bf3b3025f8042ea9e830", "html_url": "https://github.com/rust-lang/rust/commit/8dc7ddb9763f28b83de7bf3b3025f8042ea9e830"}], "stats": {"total": 211, "additions": 154, "deletions": 57}, "files": [{"sha": "5ca0dda7545574abd3c15053503e8aba0c5db22f", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=2c5cd9ce53d2d25041db0cb02b40ba460ffa8908", "patch": "@@ -8,15 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, CrateNum};\n use syntax::ast::NodeId;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::{Symbol, InternedString};\n use ty::{Instance, TyCtxt};\n use util::nodemap::FxHashMap;\n use rustc_data_structures::base_n;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n                                            StableHasher};\n use ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n+use std::fmt;\n use std::hash::Hash;\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n@@ -173,6 +174,80 @@ impl<'tcx> CodegenUnit<'tcx> {\n             self.size_estimate = Some(size_estimate + delta);\n         }\n     }\n+\n+    /// CGU names should fulfill the following requirements:\n+    /// - They should be able to act as a file name on any kind of file system\n+    /// - They should not collide with other CGU names, even for different versions\n+    ///   of the same crate.\n+    ///\n+    /// Consequently, we don't use special characters except for '.' and '-' and we\n+    /// prefix each name with the crate-name and crate-disambiguator.\n+    ///\n+    /// This function will build CGU names of the form:\n+    ///\n+    /// ```\n+    /// <crate-name>.<crate-disambiguator>(-<component>)*[.<special-suffix>]\n+    /// ```\n+    ///\n+    /// The '.' before `<special-suffix>` makes sure that names with a special\n+    /// suffix can never collide with a name built out of regular Rust\n+    /// identifiers (e.g. module paths).\n+    pub fn build_cgu_name<I, C, S>(tcx: TyCtxt,\n+                                   cnum: CrateNum,\n+                                   components: I,\n+                                   special_suffix: Option<S>)\n+                                   -> InternedString\n+        where I: IntoIterator<Item=C>,\n+              C: fmt::Display,\n+              S: fmt::Display,\n+    {\n+        let cgu_name = CodegenUnit::build_cgu_name_no_mangle(tcx,\n+                                                             cnum,\n+                                                             components,\n+                                                             special_suffix);\n+\n+        if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n+            cgu_name\n+        } else {\n+            let cgu_name = &cgu_name.as_str()[..];\n+            Symbol::intern(&CodegenUnit::mangle_name(cgu_name)).as_interned_str()\n+        }\n+    }\n+\n+    /// Same as `CodegenUnit::build_cgu_name()` but will never mangle the\n+    /// resulting name.\n+    pub fn build_cgu_name_no_mangle<I, C, S>(tcx: TyCtxt,\n+                                             cnum: CrateNum,\n+                                             components: I,\n+                                             special_suffix: Option<S>)\n+                                             -> InternedString\n+        where I: IntoIterator<Item=C>,\n+              C: fmt::Display,\n+              S: fmt::Display,\n+    {\n+        use std::fmt::Write;\n+\n+        let mut cgu_name = String::with_capacity(64);\n+\n+        // Start out with the crate name and disambiguator\n+        write!(cgu_name,\n+               \"{}.{}\",\n+               tcx.crate_name(cnum),\n+               tcx.crate_disambiguator(cnum)).unwrap();\n+\n+        // Add the components\n+        for component in components {\n+            write!(cgu_name, \"-{}\", component).unwrap();\n+        }\n+\n+        if let Some(special_suffix) = special_suffix {\n+            // We add a dot in here so it cannot clash with anything in a regular\n+            // Rust identifier\n+            write!(cgu_name, \".{}\", special_suffix).unwrap();\n+        }\n+\n+        Symbol::intern(&cgu_name[..]).as_interned_str()\n+    }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {"}, {"sha": "c28b49756f096f0398cb424ab439477a502bcc34", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=2c5cd9ce53d2d25041db0cb02b40ba460ffa8908", "patch": "@@ -26,6 +26,7 @@ use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::{duration_to_secs_str, ErrorReported};\n use util::common::ProfileQueriesMsg;\n \n+use rustc_data_structures::base_n;\n use rustc_data_structures::sync::{self, Lrc, Lock, LockCell, OneThread, Once, RwLock};\n \n use syntax::ast::NodeId;\n@@ -1185,6 +1186,14 @@ impl CrateDisambiguator {\n     }\n }\n \n+impl fmt::Display for CrateDisambiguator {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        let (a, b) = self.0.as_value();\n+        let as_u128 = a as u128 | ((b as u128) << 64);\n+        f.write_str(&base_n::encode(as_u128, base_n::CASE_INSENSITIVE))\n+    }\n+}\n+\n impl From<Fingerprint> for CrateDisambiguator {\n     fn from(fingerprint: Fingerprint) -> CrateDisambiguator {\n         CrateDisambiguator(fingerprint)"}, {"sha": "f6e9ee7b22560ba0a96e837593517993b4a5f358", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=2c5cd9ce53d2d25041db0cb02b40ba460ffa8908", "patch": "@@ -27,11 +27,11 @@\n //! the HIR doesn't change as a result of the annotations, which might\n //! perturb the reuse results.\n \n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::dep_graph::{DepNode, DepConstructor};\n use rustc::mir::mono::CodegenUnit;\n use rustc::ty::TyCtxt;\n use syntax::ast;\n-use syntax_pos::symbol::Symbol;\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED};\n \n const MODULE: &'static str = \"module\";\n@@ -72,34 +72,71 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n             return;\n         }\n \n-        let mname = self.field(attr, MODULE);\n-        let mangled_cgu_name = CodegenUnit::mangle_name(&mname.as_str());\n-        let mangled_cgu_name = Symbol::intern(&mangled_cgu_name).as_interned_str();\n+        let user_path = self.field(attr, MODULE).as_str().to_string();\n+        let crate_name = self.tcx.crate_name(LOCAL_CRATE).as_str().to_string();\n+\n+        if !user_path.starts_with(&crate_name) {\n+            let msg = format!(\"Found malformed codegen unit name `{}`. \\\n+                Codegen units names must always start with the name of the \\\n+                crate (`{}` in this case).\", user_path, crate_name);\n+            self.tcx.sess.span_fatal(attr.span, &msg);\n+        }\n+\n+        // Split of the \"special suffix\" if there is one.\n+        let (user_path, cgu_special_suffix) = if let Some(index) = user_path.rfind(\".\") {\n+            (&user_path[..index], Some(&user_path[index + 1 ..]))\n+        } else {\n+            (&user_path[..], None)\n+        };\n+\n+        let mut cgu_path_components = user_path.split(\"-\").collect::<Vec<_>>();\n+\n+        // Remove the crate name\n+        assert_eq!(cgu_path_components.remove(0), crate_name);\n+\n+        let cgu_name = CodegenUnit::build_cgu_name(self.tcx,\n+                                                   LOCAL_CRATE,\n+                                                   cgu_path_components,\n+                                                   cgu_special_suffix);\n+\n+        debug!(\"mapping '{}' to cgu name '{}'\", self.field(attr, MODULE), cgu_name);\n \n         let dep_node = DepNode::new(self.tcx,\n-                                    DepConstructor::CompileCodegenUnit(mangled_cgu_name));\n+                                    DepConstructor::CompileCodegenUnit(cgu_name));\n \n         if let Some(loaded_from_cache) = self.tcx.dep_graph.was_loaded_from_cache(&dep_node) {\n             match (disposition, loaded_from_cache) {\n                 (Disposition::Reused, false) => {\n                     self.tcx.sess.span_err(\n                         attr.span,\n                         &format!(\"expected module named `{}` to be Reused but is Codegened\",\n-                                 mname));\n+                                 user_path));\n                 }\n                 (Disposition::Codegened, true) => {\n                     self.tcx.sess.span_err(\n                         attr.span,\n                         &format!(\"expected module named `{}` to be Codegened but is Reused\",\n-                                 mname));\n+                                 user_path));\n                 }\n                 (Disposition::Reused, true) |\n                 (Disposition::Codegened, false) => {\n                     // These are what we would expect.\n                 }\n             }\n         } else {\n-            self.tcx.sess.span_err(attr.span, &format!(\"no module named `{}`\", mname));\n+            let available_cgus = self.tcx\n+                .collect_and_partition_mono_items(LOCAL_CRATE)\n+                .1\n+                .iter()\n+                .map(|cgu| format!(\"{}\", cgu.name()))\n+                .collect::<Vec<String>>()\n+                .join(\", \");\n+\n+            self.tcx.sess.span_err(attr.span,\n+                &format!(\"no module named `{}` (mangled: {}).\\nAvailable modules: {}\",\n+                    user_path,\n+                    cgu_name,\n+                    available_cgus));\n         }\n     }\n "}, {"sha": "73b430bc0411253f4148bb031f917e295de4cb6f", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 22, "deletions": 46, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=2c5cd9ce53d2d25041db0cb02b40ba460ffa8908", "patch": "@@ -104,7 +104,7 @@\n \n use monomorphize::collector::InliningMap;\n use rustc::dep_graph::WorkProductId;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::DefPathData;\n use rustc::mir::mono::{Linkage, Visibility};\n use rustc::middle::exported_symbols::SymbolExportLevel;\n@@ -114,7 +114,7 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use std::collections::hash_map::Entry;\n use std::cmp;\n use syntax::ast::NodeId;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::InternedString;\n use rustc::mir::mono::MonoItem;\n use monomorphize::item::{MonoItemExt, InstantiationMode};\n \n@@ -204,16 +204,9 @@ impl<'tcx> CodegenUnitExt<'tcx> for CodegenUnit<'tcx> {\n \n // Anything we can't find a proper codegen unit for goes into this.\n fn fallback_cgu_name(tcx: TyCtxt) -> InternedString {\n-    const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n-\n-    if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n-        Symbol::intern(FALLBACK_CODEGEN_UNIT).as_interned_str()\n-    } else {\n-        Symbol::intern(&CodegenUnit::mangle_name(FALLBACK_CODEGEN_UNIT)).as_interned_str()\n-    }\n+    CodegenUnit::build_cgu_name(tcx, LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n }\n \n-\n pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               mono_items: I,\n                               strategy: PartitioningStrategy,\n@@ -224,8 +217,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n-    let mut initial_partitioning = place_root_mono_items(tcx,\n-                                                                mono_items);\n+    let mut initial_partitioning = place_root_mono_items(tcx, mono_items);\n \n     initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(&tcx));\n \n@@ -234,7 +226,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n-        merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name.as_str());\n+        merge_codegen_units(tcx, &mut initial_partitioning, count);\n \n         debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n@@ -328,7 +320,7 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n \n         let codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n-                                            .or_insert_with(make_codegen_unit);\n+                                        .or_insert_with(make_codegen_unit);\n \n         let mut can_be_internalized = true;\n         let default_visibility = |id: DefId, is_generic: bool| {\n@@ -491,9 +483,9 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-                             target_cgu_count: usize,\n-                             crate_name: &str) {\n+fn merge_codegen_units<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                             initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+                             target_cgu_count: usize) {\n     assert!(target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n@@ -522,7 +514,7 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n     }\n \n     for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-        cgu.set_name(numbered_codegen_unit_name(crate_name, index));\n+        cgu.set_name(numbered_codegen_unit_name(tcx, index));\n     }\n }\n \n@@ -727,42 +719,26 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        def_id: DefId,\n                                        volatile: bool)\n                                        -> InternedString {\n-    // Unfortunately we cannot just use the `ty::item_path` infrastructure here\n-    // because we need paths to modules and the DefIds of those are not\n-    // available anymore for external items.\n-    let mut cgu_name = String::with_capacity(64);\n-\n     let def_path = tcx.def_path(def_id);\n-    cgu_name.push_str(&tcx.crate_name(def_path.krate).as_str());\n-\n-    for part in tcx.def_path(def_id)\n-                   .data\n-                   .iter()\n-                   .take_while(|part| {\n-                        match part.data {\n-                            DefPathData::Module(..) => true,\n-                            _ => false,\n-                        }\n-                    }) {\n-        cgu_name.push_str(\"-\");\n-        cgu_name.push_str(&part.data.as_interned_str().as_str());\n-    }\n \n-    if volatile {\n-        cgu_name.push_str(\".volatile\");\n-    }\n+    let components = def_path.data.iter().take_while(|part| {\n+        match part.data {\n+            DefPathData::Module(..) => true,\n+            _ => false,\n+        }\n+    }).map(|part| part.data.as_interned_str());\n \n-    let cgu_name = if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n-        cgu_name\n+    let volatile_suffix = if volatile {\n+        Some(\"volatile\")\n     } else {\n-        CodegenUnit::mangle_name(&cgu_name)\n+        None\n     };\n \n-    Symbol::intern(&cgu_name[..]).as_interned_str()\n+    CodegenUnit::build_cgu_name(tcx, def_path.krate, components, volatile_suffix)\n }\n \n-fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n-    Symbol::intern(&format!(\"{}{}\", crate_name, index)).as_interned_str()\n+fn numbered_codegen_unit_name(tcx: TyCtxt, index: usize) -> InternedString {\n+    CodegenUnit::build_cgu_name_no_mangle(tcx, LOCAL_CRATE, &[\"cgu\"], Some(index))\n }\n \n fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "5491827af8a3511b42194805a0d7c2a6ee5b144e", "filename": "src/test/incremental/issue-39828/auxiliary/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908/src%2Ftest%2Fincremental%2Fissue-39828%2Fauxiliary%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c5cd9ce53d2d25041db0cb02b40ba460ffa8908/src%2Ftest%2Fincremental%2Fissue-39828%2Fauxiliary%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-39828%2Fauxiliary%2Fgeneric.rs?ref=2c5cd9ce53d2d25041db0cb02b40ba460ffa8908", "patch": "@@ -11,7 +11,7 @@\n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n \n-#![rustc_partition_reused(module=\"__rustc_fallback_codegen_unit\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"generic-fallback.cgu\", cfg=\"rpass2\")]\n #![feature(rustc_attrs)]\n \n #![crate_type=\"rlib\"]"}]}