{"sha": "bb9172d7b512c36f34d34b024640f030d1fde2eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiOTE3MmQ3YjUxMmMzNmYzNGQzNGIwMjQ2NDBmMDMwZDFmZGUyZWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-09T02:21:49Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-27T17:14:50Z"}, "message": "Fix fallout of removing default bounds\n\nThis is all purely fallout of getting the previous commit to compile.", "tree": {"sha": "0e4ea18ae30a12954db6b9fbe95f62222ade9301", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e4ea18ae30a12954db6b9fbe95f62222ade9301"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb9172d7b512c36f34d34b024640f030d1fde2eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb9172d7b512c36f34d34b024640f030d1fde2eb", "html_url": "https://github.com/rust-lang/rust/commit/bb9172d7b512c36f34d34b024640f030d1fde2eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb9172d7b512c36f34d34b024640f030d1fde2eb/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdd24b2a56e8bf6b952bd8880364fb0a57c2c540", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd24b2a56e8bf6b952bd8880364fb0a57c2c540", "html_url": "https://github.com/rust-lang/rust/commit/bdd24b2a56e8bf6b952bd8880364fb0a57c2c540"}], "stats": {"total": 740, "additions": 377, "deletions": 363}, "files": [{"sha": "d2599aab14c9fa01bcabff6dd92f9b3b0984f02a", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -22,14 +22,14 @@ use std::rt::rtio::{EventLoop, IoFactory, RemoteCallback, PausableIdleCallback,\n use std::unstable::sync::Exclusive;\n \n /// This is the only exported function from this module.\n-pub fn event_loop() -> ~EventLoop {\n-    ~BasicLoop::new() as ~EventLoop\n+pub fn event_loop() -> ~EventLoop:Send {\n+    ~BasicLoop::new() as ~EventLoop:Send\n }\n \n struct BasicLoop {\n-    work: ~[proc()],                  // pending work\n+    work: ~[proc:Send()],             // pending work\n     idle: Option<*mut BasicPausable>, // only one is allowed\n-    remotes: ~[(uint, ~Callback)],\n+    remotes: ~[(uint, ~Callback:Send)],\n     next_remote: uint,\n     messages: Exclusive<~[Message]>,\n }\n@@ -135,26 +135,28 @@ impl EventLoop for BasicLoop {\n         }\n     }\n \n-    fn callback(&mut self, f: proc()) {\n+    fn callback(&mut self, f: proc:Send()) {\n         self.work.push(f);\n     }\n \n     // FIXME: Seems like a really weird requirement to have an event loop provide.\n-    fn pausable_idle_callback(&mut self, cb: ~Callback) -> ~PausableIdleCallback {\n+    fn pausable_idle_callback(&mut self, cb: ~Callback:Send)\n+        -> ~PausableIdleCallback:Send\n+    {\n         let callback = ~BasicPausable::new(self, cb);\n         rtassert!(self.idle.is_none());\n         unsafe {\n             let cb_ptr: &*mut BasicPausable = cast::transmute(&callback);\n             self.idle = Some(*cb_ptr);\n         }\n-        return callback as ~PausableIdleCallback;\n+        callback as ~PausableIdleCallback:Send\n     }\n \n-    fn remote_callback(&mut self, f: ~Callback) -> ~RemoteCallback {\n+    fn remote_callback(&mut self, f: ~Callback:Send) -> ~RemoteCallback:Send {\n         let id = self.next_remote;\n         self.next_remote += 1;\n         self.remotes.push((id, f));\n-        ~BasicRemote::new(self.messages.clone(), id) as ~RemoteCallback\n+        ~BasicRemote::new(self.messages.clone(), id) as ~RemoteCallback:Send\n     }\n \n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> { None }\n@@ -195,12 +197,12 @@ impl Drop for BasicRemote {\n \n struct BasicPausable {\n     eloop: *mut BasicLoop,\n-    work: ~Callback,\n+    work: ~Callback:Send,\n     active: bool,\n }\n \n impl BasicPausable {\n-    fn new(eloop: &mut BasicLoop, cb: ~Callback) -> BasicPausable {\n+    fn new(eloop: &mut BasicLoop, cb: ~Callback:Send) -> BasicPausable {\n         BasicPausable {\n             active: false,\n             work: cb,"}, {"sha": "12f2839f321218b704d2e63c0df3857662d6587b", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -247,7 +247,7 @@ pub mod task;\n /// The return value is used as the process return code. 0 on success, 101 on\n /// error.\n pub fn start(argc: int, argv: **u8,\n-             event_loop_factory: fn() -> ~rtio::EventLoop,\n+             event_loop_factory: fn() -> ~rtio::EventLoop:Send,\n              main: proc()) -> int {\n     rt::init(argc, argv);\n     let mut main = Some(main);\n@@ -268,7 +268,8 @@ pub fn start(argc: int, argv: **u8,\n ///\n /// This function will not return until all schedulers in the associated pool\n /// have returned.\n-pub fn run(event_loop_factory: fn() -> ~rtio::EventLoop, main: proc()) -> int {\n+pub fn run(event_loop_factory: fn() -> ~rtio::EventLoop:Send,\n+           main: proc()) -> int {\n     // Create a scheduler pool and spawn the main task into this pool. We will\n     // get notified over a channel when the main task exits.\n     let mut cfg = PoolConfig::new();\n@@ -298,7 +299,7 @@ pub struct PoolConfig {\n     threads: uint,\n     /// A factory function used to create new event loops. If this is not\n     /// specified then the default event loop factory is used.\n-    event_loop_factory: fn() -> ~rtio::EventLoop,\n+    event_loop_factory: fn() -> ~rtio::EventLoop:Send,\n }\n \n impl PoolConfig {\n@@ -323,7 +324,7 @@ pub struct SchedPool {\n     priv stack_pool: StackPool,\n     priv deque_pool: deque::BufferPool<~task::GreenTask>,\n     priv sleepers: SleeperList,\n-    priv factory: fn() -> ~rtio::EventLoop,\n+    priv factory: fn() -> ~rtio::EventLoop:Send,\n     priv task_state: TaskState,\n     priv tasks_done: Receiver<()>,\n }"}, {"sha": "4308c05716c29d975e8bde53daac2356b0e56963", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -79,7 +79,7 @@ pub struct Scheduler {\n     /// A fast XorShift rng for scheduler use\n     rng: XorShiftRng,\n     /// A togglable idle callback\n-    idle_callback: Option<~PausableIdleCallback>,\n+    idle_callback: Option<~PausableIdleCallback:Send>,\n     /// A countdown that starts at a random value and is decremented\n     /// every time a yield check is performed. When it hits 0 a task\n     /// will yield.\n@@ -99,7 +99,7 @@ pub struct Scheduler {\n     //      destroyed before it's actually destroyed.\n \n     /// The event loop used to drive the scheduler and perform I/O\n-    event_loop: ~EventLoop,\n+    event_loop: ~EventLoop:Send,\n }\n \n /// An indication of how hard to work on a given operation, the difference\n@@ -122,7 +122,7 @@ impl Scheduler {\n     // * Initialization Functions\n \n     pub fn new(pool_id: uint,\n-               event_loop: ~EventLoop,\n+               event_loop: ~EventLoop:Send,\n                work_queue: deque::Worker<~GreenTask>,\n                work_queues: ~[deque::Stealer<~GreenTask>],\n                sleeper_list: SleeperList,\n@@ -135,7 +135,7 @@ impl Scheduler {\n     }\n \n     pub fn new_special(pool_id: uint,\n-                       event_loop: ~EventLoop,\n+                       event_loop: ~EventLoop:Send,\n                        work_queue: deque::Worker<~GreenTask>,\n                        work_queues: ~[deque::Stealer<~GreenTask>],\n                        sleeper_list: SleeperList,\n@@ -182,7 +182,7 @@ impl Scheduler {\n     pub fn bootstrap(mut ~self) {\n \n         // Build an Idle callback.\n-        let cb = ~SchedRunner as ~Callback;\n+        let cb = ~SchedRunner as ~Callback:Send;\n         self.idle_callback = Some(self.event_loop.pausable_idle_callback(cb));\n \n         // Create a task for the scheduler with an empty context.\n@@ -230,7 +230,7 @@ impl Scheduler {\n         // mutable reference to the event_loop to give it the \"run\"\n         // command.\n         unsafe {\n-            let event_loop: *mut ~EventLoop = &mut self.event_loop;\n+            let event_loop: *mut ~EventLoop:Send = &mut self.event_loop;\n             // Our scheduler must be in the task before the event loop\n             // is started.\n             stask.put_with_sched(self);\n@@ -868,7 +868,7 @@ impl Scheduler {\n     }\n \n     pub fn make_handle(&mut self) -> SchedHandle {\n-        let remote = self.event_loop.remote_callback(~SchedRunner as ~Callback);\n+        let remote = self.event_loop.remote_callback(~SchedRunner);\n \n         return SchedHandle {\n             remote: remote,\n@@ -893,7 +893,7 @@ pub enum SchedMessage {\n }\n \n pub struct SchedHandle {\n-    priv remote: ~RemoteCallback,\n+    priv remote: ~RemoteCallback:Send,\n     priv queue: msgq::Producer<SchedMessage>,\n     sched_id: uint\n }\n@@ -1007,7 +1007,6 @@ mod test {\n \n     use std::comm;\n     use std::task::TaskOpts;\n-    use std::rt::Runtime;\n     use std::rt::task::Task;\n     use std::rt::local::Local;\n \n@@ -1034,7 +1033,7 @@ mod test {\n         match task.get().maybe_take_runtime::<GreenTask>() {\n             Some(green) => {\n                 let ret = green.sched.get_ref().sched_id();\n-                task.get().put_runtime(green as ~Runtime);\n+                task.get().put_runtime(green);\n                 return ret;\n             }\n             None => fail!()"}, {"sha": "75a53b0bbd3ef741193145c776bf410d854f77d4", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -34,7 +34,7 @@ impl Runtime for SimpleTask {\n \n         let me = &mut *self as *mut SimpleTask;\n         let cur_dupe = &*cur_task as *Task;\n-        cur_task.put_runtime(self as ~Runtime);\n+        cur_task.put_runtime(self);\n         let task = BlockedTask::block(cur_task);\n \n         // See libnative/task.rs for what's going on here with the `awoken`\n@@ -57,7 +57,7 @@ impl Runtime for SimpleTask {\n     }\n     fn reawaken(mut ~self, mut to_wake: ~Task) {\n         let me = &mut *self as *mut SimpleTask;\n-        to_wake.put_runtime(self as ~Runtime);\n+        to_wake.put_runtime(self);\n         unsafe {\n             cast::forget(to_wake);\n             let guard = (*me).lock.lock();\n@@ -86,6 +86,6 @@ pub fn task() -> ~Task {\n     task.put_runtime(~SimpleTask {\n         lock: unsafe {NativeMutex::new()},\n         awoken: false,\n-    } as ~Runtime);\n+    });\n     return task;\n }"}, {"sha": "7be749791a2957d5e49cf803ab409fb92babdb5e", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -287,7 +287,7 @@ impl GreenTask {\n \n     pub fn swap(mut ~self) -> ~Task {\n         let mut task = self.task.take_unwrap();\n-        task.put_runtime(self as ~Runtime);\n+        task.put_runtime(self);\n         return task;\n     }\n \n@@ -482,7 +482,6 @@ impl Runtime for GreenTask {\n \n #[cfg(test)]\n mod tests {\n-    use std::rt::Runtime;\n     use std::rt::local::Local;\n     use std::rt::task::Task;\n     use std::task;\n@@ -576,7 +575,7 @@ mod tests {\n                 let mut task: ~Task = Local::take();\n                 match task.maybe_take_runtime::<GreenTask>() {\n                     Some(ops) => {\n-                        task.put_runtime(ops as ~Runtime);\n+                        task.put_runtime(ops);\n                     }\n                     None => fail!(),\n                 }"}, {"sha": "765b3dabd7b870c177f499c0e83c77f946278a23", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -156,7 +156,7 @@ pub static WARN: u32 = 2;\n /// Error log level\n pub static ERROR: u32 = 1;\n \n-local_data_key!(local_logger: ~Logger)\n+local_data_key!(local_logger: ~Logger:Send)\n \n /// A trait used to represent an interface to a task-local logger. Each task\n /// can have its own custom logger which can respond to logging messages\n@@ -203,7 +203,7 @@ pub fn log(level: u32, args: &fmt::Arguments) {\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n     let mut logger = local_data::pop(local_logger).unwrap_or_else(|| {\n-        ~DefaultLogger { handle: io::stderr() } as ~Logger\n+        ~DefaultLogger { handle: io::stderr() } as ~Logger:Send\n     });\n     logger.log(level, args);\n     local_data::set(local_logger, logger);\n@@ -217,7 +217,7 @@ pub fn log_level() -> u32 { unsafe { LOG_LEVEL } }\n \n /// Replaces the task-local logger with the specified logger, returning the old\n /// logger.\n-pub fn set_logger(logger: ~Logger) -> Option<~Logger> {\n+pub fn set_logger(logger: ~Logger:Send) -> Option<~Logger:Send> {\n     let prev = local_data::pop(local_logger);\n     local_data::set(local_logger, logger);\n     return prev;"}, {"sha": "2e33110b7003a08bedacbce09816a4a0214097e3", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -176,8 +176,8 @@ impl rtio::RtioPipe for FileDesc {\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         self.inner_write(buf)\n     }\n-    fn clone(&self) -> ~rtio::RtioPipe {\n-        ~FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe\n+    fn clone(&self) -> ~rtio::RtioPipe:Send {\n+        ~FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe:Send\n     }\n }\n "}, {"sha": "3536ec7dec6f2d3f6562b80bd58a9ad5d71fe09a", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -227,20 +227,20 @@ impl IoFactory {\n \n impl rtio::IoFactory for IoFactory {\n     // networking\n-    fn tcp_connect(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpStream> {\n-        net::TcpStream::connect(addr).map(|s| ~s as ~RtioTcpStream)\n+    fn tcp_connect(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpStream:Send> {\n+        net::TcpStream::connect(addr).map(|s| ~s as ~RtioTcpStream:Send)\n     }\n-    fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener> {\n-        net::TcpListener::bind(addr).map(|s| ~s as ~RtioTcpListener)\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener:Send> {\n+        net::TcpListener::bind(addr).map(|s| ~s as ~RtioTcpListener:Send)\n     }\n-    fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket> {\n-        net::UdpSocket::bind(addr).map(|u| ~u as ~RtioUdpSocket)\n+    fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket:Send> {\n+        net::UdpSocket::bind(addr).map(|u| ~u as ~RtioUdpSocket:Send)\n     }\n-    fn unix_bind(&mut self, path: &CString) -> IoResult<~RtioUnixListener> {\n-        pipe::UnixListener::bind(path).map(|s| ~s as ~RtioUnixListener)\n+    fn unix_bind(&mut self, path: &CString) -> IoResult<~RtioUnixListener:Send> {\n+        pipe::UnixListener::bind(path).map(|s| ~s as ~RtioUnixListener:Send)\n     }\n-    fn unix_connect(&mut self, path: &CString) -> IoResult<~RtioPipe> {\n-        pipe::UnixStream::connect(path).map(|s| ~s as ~RtioPipe)\n+    fn unix_connect(&mut self, path: &CString) -> IoResult<~RtioPipe:Send> {\n+        pipe::UnixStream::connect(path).map(|s| ~s as ~RtioPipe:Send)\n     }\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> IoResult<~[ai::Info]> {\n@@ -249,16 +249,16 @@ impl rtio::IoFactory for IoFactory {\n \n     // filesystem operations\n     fn fs_from_raw_fd(&mut self, fd: c_int,\n-                      close: CloseBehavior) -> ~RtioFileStream {\n+                      close: CloseBehavior) -> ~RtioFileStream:Send {\n         let close = match close {\n             rtio::CloseSynchronously | rtio::CloseAsynchronously => true,\n             rtio::DontClose => false\n         };\n-        ~file::FileDesc::new(fd, close) as ~RtioFileStream\n+        ~file::FileDesc::new(fd, close) as ~RtioFileStream:Send\n     }\n     fn fs_open(&mut self, path: &CString, fm: io::FileMode, fa: io::FileAccess)\n-        -> IoResult<~RtioFileStream> {\n-        file::open(path, fm, fa).map(|fd| ~fd as ~RtioFileStream)\n+        -> IoResult<~RtioFileStream:Send> {\n+        file::open(path, fm, fa).map(|fd| ~fd as ~RtioFileStream:Send)\n     }\n     fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n         file::unlink(path)\n@@ -304,25 +304,27 @@ impl rtio::IoFactory for IoFactory {\n     }\n \n     // misc\n-    fn timer_init(&mut self) -> IoResult<~RtioTimer> {\n-        timer::Timer::new().map(|t| ~t as ~RtioTimer)\n+    fn timer_init(&mut self) -> IoResult<~RtioTimer:Send> {\n+        timer::Timer::new().map(|t| ~t as ~RtioTimer:Send)\n     }\n     fn spawn(&mut self, config: ProcessConfig)\n-            -> IoResult<(~RtioProcess, ~[Option<~RtioPipe>])> {\n+            -> IoResult<(~RtioProcess:Send, ~[Option<~RtioPipe:Send>])> {\n         process::Process::spawn(config).map(|(p, io)| {\n-            (~p as ~RtioProcess,\n-             io.move_iter().map(|p| p.map(|p| ~p as ~RtioPipe)).collect())\n+            (~p as ~RtioProcess:Send,\n+             io.move_iter().map(|p| p.map(|p| ~p as ~RtioPipe:Send)).collect())\n         })\n     }\n     fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n         process::Process::kill(pid, signum)\n     }\n-    fn pipe_open(&mut self, fd: c_int) -> IoResult<~RtioPipe> {\n-        Ok(~file::FileDesc::new(fd, true) as ~RtioPipe)\n+    fn pipe_open(&mut self, fd: c_int) -> IoResult<~RtioPipe:Send> {\n+        Ok(~file::FileDesc::new(fd, true) as ~RtioPipe:Send)\n     }\n-    fn tty_open(&mut self, fd: c_int, _readable: bool) -> IoResult<~RtioTTY> {\n+    fn tty_open(&mut self, fd: c_int, _readable: bool)\n+        -> IoResult<~RtioTTY:Send>\n+    {\n         if unsafe { libc::isatty(fd) } != 0 {\n-            Ok(~file::FileDesc::new(fd, true) as ~RtioTTY)\n+            Ok(~file::FileDesc::new(fd, true) as ~RtioTTY:Send)\n         } else {\n             Err(IoError {\n                 kind: io::MismatchedFileTypeForOperation,\n@@ -332,7 +334,7 @@ impl rtio::IoFactory for IoFactory {\n         }\n     }\n     fn signal(&mut self, _signal: Signum, _channel: Sender<Signum>)\n-        -> IoResult<~RtioSignal> {\n+        -> IoResult<~RtioSignal:Send> {\n         Err(unimpl())\n     }\n }"}, {"sha": "6f6ddeec86bff427917a6ac035d31d453f388c35", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -348,8 +348,8 @@ impl rtio::RtioTcpStream for TcpStream {\n         self.set_keepalive(None)\n     }\n \n-    fn clone(&self) -> ~rtio::RtioTcpStream {\n-        ~TcpStream { inner: self.inner.clone() } as ~rtio::RtioTcpStream\n+    fn clone(&self) -> ~rtio::RtioTcpStream:Send {\n+        ~TcpStream { inner: self.inner.clone() } as ~rtio::RtioTcpStream:Send\n     }\n     fn close_write(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe {\n@@ -418,8 +418,8 @@ impl TcpListener {\n }\n \n impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(~self) -> IoResult<~rtio::RtioTcpAcceptor> {\n-        self.native_listen(128).map(|a| ~a as ~rtio::RtioTcpAcceptor)\n+    fn listen(~self) -> IoResult<~rtio::RtioTcpAcceptor:Send> {\n+        self.native_listen(128).map(|a| ~a as ~rtio::RtioTcpAcceptor:Send)\n     }\n }\n \n@@ -461,8 +461,8 @@ impl rtio::RtioSocket for TcpAcceptor {\n }\n \n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n-    fn accept(&mut self) -> IoResult<~rtio::RtioTcpStream> {\n-        self.native_accept().map(|s| ~s as ~rtio::RtioTcpStream)\n+    fn accept(&mut self) -> IoResult<~rtio::RtioTcpStream:Send> {\n+        self.native_accept().map(|s| ~s as ~rtio::RtioTcpStream:Send)\n     }\n \n     fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n@@ -630,7 +630,7 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         self.set_broadcast(false)\n     }\n \n-    fn clone(&self) -> ~rtio::RtioUdpSocket {\n-        ~UdpSocket { inner: self.inner.clone() } as ~rtio::RtioUdpSocket\n+    fn clone(&self) -> ~rtio::RtioUdpSocket:Send {\n+        ~UdpSocket { inner: self.inner.clone() } as ~rtio::RtioUdpSocket:Send\n     }\n }"}, {"sha": "e25571d02c92d3f253a8a49f8ce76672fc25b4ae", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -150,8 +150,8 @@ impl rtio::RtioPipe for UnixStream {\n         }\n     }\n \n-    fn clone(&self) -> ~rtio::RtioPipe {\n-        ~UnixStream { inner: self.inner.clone() } as ~rtio::RtioPipe\n+    fn clone(&self) -> ~rtio::RtioPipe:Send {\n+        ~UnixStream { inner: self.inner.clone() } as ~rtio::RtioPipe:Send\n     }\n }\n \n@@ -250,8 +250,8 @@ impl UnixListener {\n }\n \n impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor> {\n-        self.native_listen(128).map(|a| ~a as ~rtio::RtioUnixAcceptor)\n+    fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor:Send> {\n+        self.native_listen(128).map(|a| ~a as ~rtio::RtioUnixAcceptor:Send)\n     }\n }\n \n@@ -279,7 +279,7 @@ impl UnixAcceptor {\n }\n \n impl rtio::RtioUnixAcceptor for UnixAcceptor {\n-    fn accept(&mut self) -> IoResult<~rtio::RtioPipe> {\n-        self.native_accept().map(|s| ~s as ~rtio::RtioPipe)\n+    fn accept(&mut self) -> IoResult<~rtio::RtioPipe:Send> {\n+        self.native_accept().map(|s| ~s as ~rtio::RtioPipe:Send)\n     }\n }"}, {"sha": "662c6417ca82e6c99446f3bd0ab384b08716a567", "filename": "src/libnative/task.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -35,7 +35,7 @@ pub fn new(stack_bounds: (uint, uint)) -> ~Task {\n     let mut task = ~Task::new();\n     let mut ops = ops();\n     ops.stack_bounds = stack_bounds;\n-    task.put_runtime(ops as ~rt::Runtime);\n+    task.put_runtime(ops);\n     return task;\n }\n \n@@ -50,13 +50,13 @@ fn ops() -> ~Ops {\n }\n \n /// Spawns a function with the default configuration\n-pub fn spawn(f: proc()) {\n+pub fn spawn(f: proc:Send()) {\n     spawn_opts(TaskOpts::new(), f)\n }\n \n /// Spawns a new task given the configuration options and a procedure to run\n /// inside the task.\n-pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n+pub fn spawn_opts(opts: TaskOpts, f: proc:Send()) {\n     let TaskOpts {\n         notify_chan, name, stack_size,\n         stderr, stdout,\n@@ -98,7 +98,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n \n         let mut f = Some(f);\n         let mut task = task;\n-        task.put_runtime(ops as ~rt::Runtime);\n+        task.put_runtime(ops);\n         let t = task.run(|| { f.take_unwrap()() });\n         drop(t);\n         bookkeeping::decrement();\n@@ -121,15 +121,15 @@ struct Ops {\n impl rt::Runtime for Ops {\n     fn yield_now(~self, mut cur_task: ~Task) {\n         // put the task back in TLS and then invoke the OS thread yield\n-        cur_task.put_runtime(self as ~rt::Runtime);\n+        cur_task.put_runtime(self);\n         Local::put(cur_task);\n         Thread::yield_now();\n     }\n \n     fn maybe_yield(~self, mut cur_task: ~Task) {\n         // just put the task back in TLS, on OS threads we never need to\n         // opportunistically yield b/c the OS will do that for us (preemption)\n-        cur_task.put_runtime(self as ~rt::Runtime);\n+        cur_task.put_runtime(self);\n         Local::put(cur_task);\n     }\n \n@@ -183,7 +183,7 @@ impl rt::Runtime for Ops {\n     fn deschedule(mut ~self, times: uint, mut cur_task: ~Task,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         let me = &mut *self as *mut Ops;\n-        cur_task.put_runtime(self as ~rt::Runtime);\n+        cur_task.put_runtime(self);\n \n         unsafe {\n             let cur_task_dupe = &*cur_task as *Task;\n@@ -230,16 +230,16 @@ impl rt::Runtime for Ops {\n     fn reawaken(mut ~self, mut to_wake: ~Task) {\n         unsafe {\n             let me = &mut *self as *mut Ops;\n-            to_wake.put_runtime(self as ~rt::Runtime);\n+            to_wake.put_runtime(self);\n             cast::forget(to_wake);\n             let guard = (*me).lock.lock();\n             (*me).awoken = true;\n             guard.signal();\n         }\n     }\n \n-    fn spawn_sibling(~self, mut cur_task: ~Task, opts: TaskOpts, f: proc()) {\n-        cur_task.put_runtime(self as ~rt::Runtime);\n+    fn spawn_sibling(~self, mut cur_task: ~Task, opts: TaskOpts, f: proc:Send()) {\n+        cur_task.put_runtime(self);\n         Local::put(cur_task);\n \n         task::spawn_opts(opts, f);\n@@ -252,7 +252,6 @@ impl rt::Runtime for Ops {\n \n #[cfg(test)]\n mod tests {\n-    use std::rt::Runtime;\n     use std::rt::local::Local;\n     use std::rt::task::Task;\n     use std::task;\n@@ -335,7 +334,7 @@ mod tests {\n                 let mut task: ~Task = Local::take();\n                 match task.maybe_take_runtime::<Ops>() {\n                     Some(ops) => {\n-                        task.put_runtime(ops as ~Runtime);\n+                        task.put_runtime(ops);\n                     }\n                     None => fail!(),\n                 }"}, {"sha": "ea7db3db67f47eb26a55fa6d7f6553c14f403ea8", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -365,7 +365,7 @@ fn parse_crate_attrs(sess: &session::Session, input: &d::Input) ->\n ///\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n-pub fn monitor(f: proc()) {\n+pub fn monitor(f: proc:Send()) {\n     // FIXME: This is a hack for newsched since it doesn't support split stacks.\n     // rustc needs a lot of stack! When optimizations are disabled, it needs\n     // even *more* stack than usual as well.\n@@ -387,7 +387,7 @@ pub fn monitor(f: proc()) {\n     let mut r = io::ChanReader::new(rx);\n \n     match task_builder.try(proc() {\n-        io::stdio::set_stderr(~w as ~io::Writer);\n+        io::stdio::set_stderr(~w);\n         f()\n     }) {\n         Ok(()) => { /* fallthrough */ }\n@@ -425,7 +425,7 @@ pub fn monitor(f: proc()) {\n             // Fail so the process returns a failure code, but don't pollute the\n             // output with some unnecessary failure messages, we've already\n             // printed everything that we needed to.\n-            io::stdio::set_stderr(~io::util::NullWriter as ~io::Writer);\n+            io::stdio::set_stderr(~io::util::NullWriter);\n             fail!();\n         }\n     }"}, {"sha": "64203db83b72276670f2a00b1736f6de9f029cef", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -118,7 +118,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     let old = io::stdio::set_stderr(~w1);\n     spawn(proc() {\n         let mut p = io::ChanReader::new(rx);\n-        let mut err = old.unwrap_or(~io::stderr() as ~Writer);\n+        let mut err = old.unwrap_or(~io::stderr() as ~Writer:Send);\n         io::util::copy(&mut p, &mut err).unwrap();\n     });\n     let emitter = diagnostic::EmitterWriter::new(~w2);"}, {"sha": "5caccb348cc798fa4a9bb91cc802609c0f9ed2ae", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -27,12 +27,12 @@ pub struct AsyncWatcher {\n }\n \n struct Payload {\n-    callback: ~Callback,\n+    callback: ~Callback:Send,\n     exit_flag: Exclusive<bool>,\n }\n \n impl AsyncWatcher {\n-    pub fn new(loop_: &mut Loop, cb: ~Callback) -> AsyncWatcher {\n+    pub fn new(loop_: &mut Loop, cb: ~Callback:Send) -> AsyncWatcher {\n         let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n         assert_eq!(unsafe {\n             uvll::uv_async_init(loop_.handle, handle, async_cb)\n@@ -149,8 +149,7 @@ mod test_remote {\n \n         let (tx, rx) = channel();\n         let cb = ~MyCallback(Some(tx));\n-        let watcher = AsyncWatcher::new(&mut local_loop().loop_,\n-                                        cb as ~Callback);\n+        let watcher = AsyncWatcher::new(&mut local_loop().loop_, cb);\n \n         let thread = Thread::start(proc() {\n             let mut watcher = watcher;"}, {"sha": "bbfacf870964c61f4e14c02edb869927a7b34f96", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -19,11 +19,11 @@ pub struct IdleWatcher {\n     handle: *uvll::uv_idle_t,\n     idle_flag: bool,\n     closed: bool,\n-    callback: ~Callback,\n+    callback: ~Callback:Send,\n }\n \n impl IdleWatcher {\n-    pub fn new(loop_: &mut Loop, cb: ~Callback) -> ~IdleWatcher {\n+    pub fn new(loop_: &mut Loop, cb: ~Callback:Send) -> ~IdleWatcher {\n         let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n         assert_eq!(unsafe {\n             uvll::uv_idle_init(loop_.handle, handle)"}, {"sha": "41a6651cc1caba01f675990f4672d2dda9c427fb", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -126,8 +126,8 @@ pub mod stream;\n ///     // this code is running inside of a green task powered by libuv\n /// }\n /// ```\n-pub fn event_loop() -> ~rtio::EventLoop {\n-    ~uvio::UvEventLoop::new() as ~rtio::EventLoop\n+pub fn event_loop() -> ~rtio::EventLoop:Send {\n+    ~uvio::UvEventLoop::new() as ~rtio::EventLoop:Send\n }\n \n /// A type that wraps a uv handle"}, {"sha": "cfecdd929f38d25ccf6b3d84b2be25ad4de64c70", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -167,8 +167,8 @@ pub struct TcpListener {\n     home: HomeHandle,\n     handle: *uvll::uv_pipe_t,\n     priv closing_task: Option<BlockedTask>,\n-    priv outgoing: Sender<Result<~rtio::RtioTcpStream, IoError>>,\n-    priv incoming: Receiver<Result<~rtio::RtioTcpStream, IoError>>,\n+    priv outgoing: Sender<Result<~rtio::RtioTcpStream:Send, IoError>>,\n+    priv incoming: Receiver<Result<~rtio::RtioTcpStream:Send, IoError>>,\n }\n \n pub struct TcpAcceptor {\n@@ -295,15 +295,15 @@ impl rtio::RtioTcpStream for TcpWatcher {\n         })\n     }\n \n-    fn clone(&self) -> ~rtio::RtioTcpStream {\n+    fn clone(&self) -> ~rtio::RtioTcpStream:Send {\n         ~TcpWatcher {\n             handle: self.handle,\n             stream: StreamWatcher::new(self.handle),\n             home: self.home.clone(),\n             refcount: self.refcount.clone(),\n             write_access: self.write_access.clone(),\n             read_access: self.read_access.clone(),\n-        } as ~rtio::RtioTcpStream\n+        } as ~rtio::RtioTcpStream:Send\n     }\n \n     fn close_write(&mut self) -> Result<(), IoError> {\n@@ -397,14 +397,14 @@ impl rtio::RtioSocket for TcpListener {\n }\n \n impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(~self) -> Result<~rtio::RtioTcpAcceptor, IoError> {\n+    fn listen(~self) -> Result<~rtio::RtioTcpAcceptor:Send, IoError> {\n         // create the acceptor object from ourselves\n         let mut acceptor = ~TcpAcceptor { listener: self };\n \n         let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n         match unsafe { uvll::uv_listen(acceptor.listener.handle, 128, listen_cb) } {\n-            0 => Ok(acceptor as ~rtio::RtioTcpAcceptor),\n+            0 => Ok(acceptor as ~rtio::RtioTcpAcceptor:Send),\n             n => Err(uv_error_to_io_error(UvError(n))),\n         }\n     }\n@@ -420,7 +420,7 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n             });\n             let client = TcpWatcher::new_home(&loop_, tcp.home().clone());\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle) }, 0);\n-            Ok(~client as ~rtio::RtioTcpStream)\n+            Ok(~client as ~rtio::RtioTcpStream:Send)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n@@ -448,7 +448,7 @@ impl rtio::RtioSocket for TcpAcceptor {\n }\n \n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n-    fn accept(&mut self) -> Result<~rtio::RtioTcpStream, IoError> {\n+    fn accept(&mut self) -> Result<~rtio::RtioTcpStream:Send, IoError> {\n         self.listener.incoming.recv()\n     }\n \n@@ -709,14 +709,14 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         })\n     }\n \n-    fn clone(&self) -> ~rtio::RtioUdpSocket {\n+    fn clone(&self) -> ~rtio::RtioUdpSocket:Send {\n         ~UdpWatcher {\n             handle: self.handle,\n             home: self.home.clone(),\n             refcount: self.refcount.clone(),\n             write_access: self.write_access.clone(),\n             read_access: self.read_access.clone(),\n-        } as ~rtio::RtioUdpSocket\n+        } as ~rtio::RtioUdpSocket:Send\n     }\n }\n "}, {"sha": "e1226f0b3a98c413d61a1a8647f88737e3b3191a", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -37,8 +37,8 @@ pub struct PipeWatcher {\n pub struct PipeListener {\n     home: HomeHandle,\n     pipe: *uvll::uv_pipe_t,\n-    priv outgoing: Sender<Result<~RtioPipe, IoError>>,\n-    priv incoming: Receiver<Result<~RtioPipe, IoError>>,\n+    priv outgoing: Sender<Result<~RtioPipe:Send, IoError>>,\n+    priv incoming: Receiver<Result<~RtioPipe:Send, IoError>>,\n }\n \n pub struct PipeAcceptor {\n@@ -139,15 +139,15 @@ impl RtioPipe for PipeWatcher {\n         self.stream.write(buf).map_err(uv_error_to_io_error)\n     }\n \n-    fn clone(&self) -> ~RtioPipe {\n+    fn clone(&self) -> ~RtioPipe:Send {\n         ~PipeWatcher {\n             stream: StreamWatcher::new(self.stream.handle),\n             defused: false,\n             home: self.home.clone(),\n             refcount: self.refcount.clone(),\n             read_access: self.read_access.clone(),\n             write_access: self.write_access.clone(),\n-        } as ~RtioPipe\n+        } as ~RtioPipe:Send\n     }\n }\n \n@@ -197,14 +197,14 @@ impl PipeListener {\n }\n \n impl RtioUnixListener for PipeListener {\n-    fn listen(~self) -> Result<~RtioUnixAcceptor, IoError> {\n+    fn listen(~self) -> Result<~RtioUnixAcceptor:Send, IoError> {\n         // create the acceptor object from ourselves\n         let mut acceptor = ~PipeAcceptor { listener: self };\n \n         let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n         match unsafe { uvll::uv_listen(acceptor.listener.pipe, 128, listen_cb) } {\n-            0 => Ok(acceptor as ~RtioUnixAcceptor),\n+            0 => Ok(acceptor as ~RtioUnixAcceptor:Send),\n             n => Err(uv_error_to_io_error(UvError(n))),\n         }\n     }\n@@ -229,7 +229,7 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n             });\n             let client = PipeWatcher::new_home(&loop_, pipe.home().clone(), false);\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle()) }, 0);\n-            Ok(~client as ~RtioPipe)\n+            Ok(~client as ~RtioPipe:Send)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n@@ -246,7 +246,7 @@ impl Drop for PipeListener {\n // PipeAcceptor implementation and traits\n \n impl RtioUnixAcceptor for PipeAcceptor {\n-    fn accept(&mut self) -> Result<~RtioPipe, IoError> {\n+    fn accept(&mut self) -> Result<~RtioPipe:Send, IoError> {\n         self.listener.incoming.recv()\n     }\n }"}, {"sha": "1621ccfbf454cf64b4c63379b0d77444fdf5d968", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -85,14 +85,17 @@ impl rtio::EventLoop for UvEventLoop {\n         IdleWatcher::onetime(&mut self.uvio.loop_, f);\n     }\n \n-    fn pausable_idle_callback(&mut self, cb: ~rtio::Callback)\n-        -> ~rtio::PausableIdleCallback\n+    fn pausable_idle_callback(&mut self, cb: ~rtio::Callback:Send)\n+        -> ~rtio::PausableIdleCallback:Send\n     {\n-        IdleWatcher::new(&mut self.uvio.loop_, cb) as ~rtio::PausableIdleCallback\n+        IdleWatcher::new(&mut self.uvio.loop_,\n+                         cb) as ~rtio::PausableIdleCallback:Send\n     }\n \n-    fn remote_callback(&mut self, f: ~rtio::Callback) -> ~rtio::RemoteCallback {\n-        ~AsyncWatcher::new(&mut self.uvio.loop_, f) as ~rtio::RemoteCallback\n+    fn remote_callback(&mut self, f: ~rtio::Callback:Send)\n+        -> ~rtio::RemoteCallback:Send\n+    {\n+        ~AsyncWatcher::new(&mut self.uvio.loop_, f) as ~rtio::RemoteCallback:Send\n     }\n \n     fn io<'a>(&'a mut self) -> Option<&'a mut rtio::IoFactory> {\n@@ -141,30 +144,30 @@ impl IoFactory for UvIoFactory {\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n     fn tcp_connect(&mut self, addr: SocketAddr)\n-        -> Result<~rtio::RtioTcpStream, IoError>\n+        -> Result<~rtio::RtioTcpStream:Send, IoError>\n     {\n         match TcpWatcher::connect(self, addr) {\n-            Ok(t) => Ok(~t as ~rtio::RtioTcpStream),\n+            Ok(t) => Ok(~t as ~rtio::RtioTcpStream:Send),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioTcpListener, IoError> {\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioTcpListener:Send, IoError> {\n         match TcpListener::bind(self, addr) {\n-            Ok(t) => Ok(t as ~rtio::RtioTcpListener),\n+            Ok(t) => Ok(t as ~rtio::RtioTcpListener:Send),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioUdpSocket, IoError> {\n+    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioUdpSocket:Send, IoError> {\n         match UdpWatcher::bind(self, addr) {\n-            Ok(u) => Ok(~u as ~rtio::RtioUdpSocket),\n+            Ok(u) => Ok(~u as ~rtio::RtioUdpSocket:Send),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn timer_init(&mut self) -> Result<~rtio::RtioTimer, IoError> {\n-        Ok(TimerWatcher::new(self) as ~rtio::RtioTimer)\n+    fn timer_init(&mut self) -> Result<~rtio::RtioTimer:Send, IoError> {\n+        Ok(TimerWatcher::new(self) as ~rtio::RtioTimer:Send)\n     }\n \n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n@@ -174,12 +177,12 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn fs_from_raw_fd(&mut self, fd: c_int,\n-                      close: rtio::CloseBehavior) -> ~rtio::RtioFileStream {\n-        ~FileWatcher::new(self, fd, close) as ~rtio::RtioFileStream\n+                      close: rtio::CloseBehavior) -> ~rtio::RtioFileStream:Send {\n+        ~FileWatcher::new(self, fd, close) as ~rtio::RtioFileStream:Send\n     }\n \n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n-        -> Result<~rtio::RtioFileStream, IoError> {\n+        -> Result<~rtio::RtioFileStream:Send, IoError> {\n         let flags = match fm {\n             io::Open => 0,\n             io::Append => libc::O_APPEND,\n@@ -195,7 +198,7 @@ impl IoFactory for UvIoFactory {\n         };\n \n         match FsRequest::open(self, path, flags as int, mode as int) {\n-            Ok(fs) => Ok(~fs as ~rtio::RtioFileStream),\n+            Ok(fs) => Ok(~fs as ~rtio::RtioFileStream:Send),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n@@ -260,12 +263,12 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~rtio::RtioProcess, ~[Option<~rtio::RtioPipe>]), IoError>\n+            -> Result<(~rtio::RtioProcess:Send, ~[Option<~rtio::RtioPipe:Send>]), IoError>\n     {\n         match Process::spawn(self, config) {\n             Ok((p, io)) => {\n-                Ok((p as ~rtio::RtioProcess,\n-                    io.move_iter().map(|i| i.map(|p| ~p as ~rtio::RtioPipe)).collect()))\n+                Ok((p as ~rtio::RtioProcess:Send,\n+                    io.move_iter().map(|i| i.map(|p| ~p as ~rtio::RtioPipe:Send)).collect()))\n             }\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n@@ -275,40 +278,40 @@ impl IoFactory for UvIoFactory {\n         Process::kill(pid, signum).map_err(uv_error_to_io_error)\n     }\n \n-    fn unix_bind(&mut self, path: &CString) -> Result<~rtio::RtioUnixListener, IoError>\n+    fn unix_bind(&mut self, path: &CString) -> Result<~rtio::RtioUnixListener:Send, IoError>\n     {\n         match PipeListener::bind(self, path) {\n-            Ok(p) => Ok(p as ~rtio::RtioUnixListener),\n+            Ok(p) => Ok(p as ~rtio::RtioUnixListener:Send),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn unix_connect(&mut self, path: &CString) -> Result<~rtio::RtioPipe, IoError> {\n+    fn unix_connect(&mut self, path: &CString) -> Result<~rtio::RtioPipe:Send, IoError> {\n         match PipeWatcher::connect(self, path) {\n-            Ok(p) => Ok(~p as ~rtio::RtioPipe),\n+            Ok(p) => Ok(~p as ~rtio::RtioPipe:Send),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n     fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> Result<~rtio::RtioTTY, IoError> {\n+            -> Result<~rtio::RtioTTY:Send, IoError> {\n         match TtyWatcher::new(self, fd, readable) {\n-            Ok(tty) => Ok(~tty as ~rtio::RtioTTY),\n+            Ok(tty) => Ok(~tty as ~rtio::RtioTTY:Send),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n-    fn pipe_open(&mut self, fd: c_int) -> Result<~rtio::RtioPipe, IoError> {\n+    fn pipe_open(&mut self, fd: c_int) -> Result<~rtio::RtioPipe:Send, IoError> {\n         match PipeWatcher::open(self, fd) {\n-            Ok(s) => Ok(~s as ~rtio::RtioPipe),\n+            Ok(s) => Ok(~s as ~rtio::RtioPipe:Send),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n     fn signal(&mut self, signum: Signum, channel: Sender<Signum>)\n-        -> Result<~rtio::RtioSignal, IoError> {\n+        -> Result<~rtio::RtioSignal:Send, IoError> {\n         match SignalWatcher::new(self, signum, channel) {\n-            Ok(s) => Ok(s as ~rtio::RtioSignal),\n+            Ok(s) => Ok(s as ~rtio::RtioSignal:Send),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }"}, {"sha": "c52cfb1e35de036244b11a8c859d2c6438e96e73", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -2600,6 +2600,6 @@ mod tests {\n             Ok(o) => o\n         };\n         let mut decoder = Decoder::new(json_obj);\n-        let hm: HashMap<uint, bool> = Decodable::decode(&mut decoder);\n+        let _hm: HashMap<uint, bool> = Decodable::decode(&mut decoder);\n     }\n }"}, {"sha": "a6cc4c64d2084c94af1cca6c88ea3602fd11a387", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -35,17 +35,18 @@\n \n use cast;\n use container::Container;\n-use ptr;\n+use kinds::Send;\n+use ops::Drop;\n+use option::{Option, Some, None};\n use ptr::RawPtr;\n+use ptr;\n use raw;\n-use option::{Option, Some, None};\n-use ops::Drop;\n \n /// The type representing a foreign chunk of memory\n pub struct CVec<T> {\n     priv base: *mut T,\n     priv len: uint,\n-    priv dtor: Option<proc()>,\n+    priv dtor: Option<proc:Send()>,\n }\n \n #[unsafe_destructor]\n@@ -89,7 +90,7 @@ impl<T> CVec<T> {\n     /// * dtor - A proc to run when the value is destructed, useful\n     ///          for freeing the buffer, etc.\n     pub unsafe fn new_with_dtor(base: *mut T, len: uint,\n-                                dtor: proc()) -> CVec<T> {\n+                                dtor: proc:Send()) -> CVec<T> {\n         assert!(base != ptr::mut_null());\n         CVec {\n             base: base,"}, {"sha": "020f493e24b9f80c283bd83dd1d4378abdd8ac26", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -53,6 +53,7 @@ use c_str::ToCStr;\n use clone::Clone;\n use container::Container;\n use iter::Iterator;\n+use kinds::Send;\n use super::{Reader, Writer, Seek};\n use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n             FileMode, FileAccess, FileStat, IoResult, FilePermission};\n@@ -77,7 +78,7 @@ use vec::Vec;\n /// configured at creation time, via the `FileAccess` parameter to\n /// `File::open_mode()`.\n pub struct File {\n-    priv fd: ~RtioFileStream,\n+    priv fd: ~RtioFileStream:Send,\n     priv path: Path,\n     priv last_nread: int,\n }"}, {"sha": "e343fdcd325650d2a0ffec34e8db0fb5627d759f", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -20,9 +20,10 @@\n #[deny(missing_doc)];\n \n use clone::Clone;\n+use io::IoResult;\n use io::net::ip::SocketAddr;\n use io::{Reader, Writer, Listener, Acceptor};\n-use io::IoResult;\n+use kinds::Send;\n use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n \n@@ -45,11 +46,11 @@ use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n /// drop(stream); // close the connection\n /// ```\n pub struct TcpStream {\n-    priv obj: ~RtioTcpStream\n+    priv obj: ~RtioTcpStream:Send\n }\n \n impl TcpStream {\n-    fn new(s: ~RtioTcpStream) -> TcpStream {\n+    fn new(s: ~RtioTcpStream:Send) -> TcpStream {\n         TcpStream { obj: s }\n     }\n \n@@ -127,7 +128,7 @@ impl Writer for TcpStream {\n /// # }\n /// ```\n pub struct TcpListener {\n-    priv obj: ~RtioTcpListener\n+    priv obj: ~RtioTcpListener:Send\n }\n \n impl TcpListener {\n@@ -160,7 +161,7 @@ impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n /// a `TcpListener`'s `listen` method, and this object can be used to accept new\n /// `TcpStream` instances.\n pub struct TcpAcceptor {\n-    priv obj: ~RtioTcpAcceptor\n+    priv obj: ~RtioTcpAcceptor:Send\n }\n \n impl Acceptor<TcpStream> for TcpAcceptor {"}, {"sha": "8169fc1a917094320ea051ee9b3879093808041c", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -16,9 +16,10 @@\n //! datagram protocol.\n \n use clone::Clone;\n-use result::{Ok, Err};\n use io::net::ip::SocketAddr;\n use io::{Reader, Writer, IoResult};\n+use kinds::Send;\n+use result::{Ok, Err};\n use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n \n /// A User Datagram Protocol socket.\n@@ -53,7 +54,7 @@ use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n /// drop(socket); // close the socket\n /// ```\n pub struct UdpSocket {\n-    priv obj: ~RtioUdpSocket\n+    priv obj: ~RtioUdpSocket:Send\n }\n \n impl UdpSocket {"}, {"sha": "1a020f9a82052f015f6cd6437886846ba011072f", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -28,18 +28,19 @@ use prelude::*;\n \n use c_str::ToCStr;\n use clone::Clone;\n-use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n-use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n use io::pipe::PipeStream;\n use io::{Listener, Acceptor, Reader, Writer, IoResult};\n+use kinds::Send;\n+use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n+use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n \n /// A stream which communicates over a named pipe.\n pub struct UnixStream {\n     priv obj: PipeStream,\n }\n \n impl UnixStream {\n-    fn new(obj: ~RtioPipe) -> UnixStream {\n+    fn new(obj: ~RtioPipe:Send) -> UnixStream {\n         UnixStream { obj: PipeStream::new(obj) }\n     }\n \n@@ -82,7 +83,7 @@ impl Writer for UnixStream {\n /// A value that can listen for incoming named pipe connection requests.\n pub struct UnixListener {\n     /// The internal, opaque runtime Unix listener.\n-    priv obj: ~RtioUnixListener,\n+    priv obj: ~RtioUnixListener:Send,\n }\n \n impl UnixListener {\n@@ -124,7 +125,7 @@ impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n /// A value that can accept named pipe connections, returned from `listen()`.\n pub struct UnixAcceptor {\n     /// The internal, opaque runtime Unix acceptor.\n-    priv obj: ~RtioUnixAcceptor,\n+    priv obj: ~RtioUnixAcceptor:Send,\n }\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n@@ -140,7 +141,7 @@ mod tests {\n     use io::*;\n     use io::test::*;\n \n-    pub fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n+    pub fn smalltest(server: proc:Send(UnixStream), client: proc:Send(UnixStream)) {\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n "}, {"sha": "fbf79b194456acdc91de52f65e996376c1fcb140", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -23,7 +23,7 @@ use rt::rtio::{RtioPipe, LocalIo};\n /// A synchronous, in-memory pipe.\n pub struct PipeStream {\n     /// The internal, opaque runtime pipe object.\n-    priv obj: ~RtioPipe,\n+    priv obj: ~RtioPipe:Send,\n }\n \n impl PipeStream {\n@@ -51,7 +51,7 @@ impl PipeStream {\n     }\n \n     #[doc(hidden)]\n-    pub fn new(inner: ~RtioPipe) -> PipeStream {\n+    pub fn new(inner: ~RtioPipe:Send) -> PipeStream {\n         PipeStream { obj: inner }\n     }\n }"}, {"sha": "2da79eba7bc030635fa3d45f7ef1460be5c0d2c4", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -53,7 +53,7 @@ use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n /// assert!(child.wait().success());\n /// ```\n pub struct Process {\n-    priv handle: ~RtioProcess,\n+    priv handle: ~RtioProcess:Send,\n \n     /// Handle to the child's stdin, if the `stdin` field of this process's\n     /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`."}, {"sha": "e52df0425614acde25add32a79dc70ad409b6569", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -32,6 +32,7 @@ use fmt;\n use io::{Reader, Writer, IoResult, IoError, OtherIoError,\n          standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n use libc;\n+use kinds::Send;\n use mem::replace;\n use option::{Option, Some, None};\n use prelude::drop;\n@@ -71,8 +72,8 @@ use slice::ImmutableVector;\n // tl;dr; TTY works on everything but when windows stdout is redirected, in that\n //        case pipe also doesn't work, but magically file does!\n enum StdSource {\n-    TTY(~RtioTTY),\n-    File(~RtioFileStream),\n+    TTY(~RtioTTY:Send),\n+    File(~RtioFileStream:Send),\n }\n \n fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n@@ -145,8 +146,10 @@ pub fn stderr_raw() -> StdWriter {\n     src(libc::STDERR_FILENO, false, |src| StdWriter { inner: src })\n }\n \n-fn reset_helper(w: ~Writer,\n-                f: |&mut Task, ~Writer| -> Option<~Writer>) -> Option<~Writer> {\n+fn reset_helper(w: ~Writer:Send,\n+                f: |&mut Task, ~Writer:Send| -> Option<~Writer:Send>)\n+    -> Option<~Writer:Send>\n+{\n     let mut t = Local::borrow(None::<Task>);\n     // Be sure to flush any pending output from the writer\n     match f(t.get(), w) {\n@@ -168,7 +171,7 @@ fn reset_helper(w: ~Writer,\n ///\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stdout stream.\n-pub fn set_stdout(stdout: ~Writer) -> Option<~Writer> {\n+pub fn set_stdout(stdout: ~Writer:Send) -> Option<~Writer:Send> {\n     reset_helper(stdout, |t, w| replace(&mut t.stdout, Some(w)))\n }\n \n@@ -180,7 +183,7 @@ pub fn set_stdout(stdout: ~Writer) -> Option<~Writer> {\n ///\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stderr stream.\n-pub fn set_stderr(stderr: ~Writer) -> Option<~Writer> {\n+pub fn set_stderr(stderr: ~Writer:Send) -> Option<~Writer:Send> {\n     reset_helper(stderr, |t, w| replace(&mut t.stderr, Some(w)))\n }\n \n@@ -206,7 +209,7 @@ fn with_task_stdout(f: |&mut Writer| -> IoResult<()> ) {\n             Local::put(task);\n \n             if my_stdout.is_none() {\n-                my_stdout = Some(~stdout() as ~Writer);\n+                my_stdout = Some(~stdout() as ~Writer:Send);\n             }\n             let ret = f(*my_stdout.get_mut_ref());\n \n@@ -399,7 +402,7 @@ mod tests {\n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n         spawn(proc() {\n-            set_stdout(~w as ~Writer);\n+            set_stdout(~w);\n             println!(\"hello!\");\n         });\n         assert_eq!(r.read_to_str().unwrap(), ~\"hello!\\n\");\n@@ -411,7 +414,7 @@ mod tests {\n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n         spawn(proc() {\n-            set_stderr(~w as ~Writer);\n+            set_stderr(~w);\n             fail!(\"my special message\");\n         });\n         let s = r.read_to_str().unwrap();"}, {"sha": "6840c418a9b03fc5d296788443bcf1c898e05970", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -18,8 +18,9 @@ and create receivers which will receive notifications after a period of time.\n */\n \n use comm::Receiver;\n-use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n use io::IoResult;\n+use kinds::Send;\n+use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n \n /// A synchronous timer object\n ///\n@@ -62,7 +63,7 @@ use io::IoResult;\n /// # }\n /// ```\n pub struct Timer {\n-    priv obj: ~RtioTimer\n+    priv obj: ~RtioTimer:Send,\n }\n \n /// Sleep the current task for `msecs` milliseconds."}, {"sha": "c555fb58db89a523e477fd5620f5be7b7229ec39", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -41,11 +41,12 @@ local_data::get(key_vector, |opt| assert_eq!(*opt.unwrap(), ~[4]));\n // magic.\n \n use cast;\n-use option::{None, Option, Some};\n-use slice::{ImmutableVector, MutableVector, OwnedVector};\n use iter::{Iterator};\n-use rt::task::{Task, LocalStorage};\n+use kinds::Send;\n use mem::replace;\n+use option::{None, Option, Some};\n+use rt::task::{Task, LocalStorage};\n+use slice::{ImmutableVector, MutableVector, OwnedVector};\n \n /**\n  * Indexes a task-local data slot. This pointer is used for comparison to\n@@ -89,7 +90,7 @@ impl<T: 'static> LocalData for T {}\n //      a proper map.\n #[doc(hidden)]\n pub type Map = ~[Option<(*u8, TLSValue, LoanState)>];\n-type TLSValue = ~LocalData;\n+type TLSValue = ~LocalData:Send;\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n unsafe fn get_local_map() -> &mut Map {\n@@ -328,7 +329,7 @@ pub fn set<T: 'static>(key: Key<T>, data: T) {\n     // transmute here to add the Send bound back on. This doesn't actually\n     // matter because TLS will always own the data (until its moved out) and\n     // we're not actually sending it to other schedulers or anything.\n-    let data: ~LocalData = unsafe { cast::transmute(data) };\n+    let data: ~LocalData:Send = unsafe { cast::transmute(data) };\n     match insertion_position(map, keyval) {\n         Some(i) => { map[i] = Some((keyval, data, NoLoan)); }\n         None => { map.push(Some((keyval, data, NoLoan))); }"}, {"sha": "675250a2710089f8c23d9a7ea088267c4ef670a5", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -686,7 +686,7 @@ fn test_repr() {\n     exact_test(&println, \"fn(&str)\");\n     exact_test(&swap::<int>, \"fn(&mut int, &mut int)\");\n     exact_test(&is_alphabetic, \"fn(char) -> bool\");\n-    exact_test(&(~5 as ~ToStr), \"~to_str::ToStr:Send\");\n+    exact_test(&(~5 as ~ToStr), \"~to_str::ToStr<no-bounds>\");\n \n     struct Foo;\n     exact_test(&(~[Foo, Foo]), \"~[repr::test_repr::Foo, repr::test_repr::Foo]\");"}, {"sha": "a5bfaf190d9066d516d617073a8ff53c617eb0e7", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -14,13 +14,14 @@\n \n use cast;\n use iter::Iterator;\n+use kinds::Send;\n use mem;\n use option::{Some, None};\n use ptr::RawPtr;\n use unstable::sync::Exclusive;\n use slice::OwnedVector;\n \n-type Queue = Exclusive<~[proc()]>;\n+type Queue = Exclusive<~[proc:Send()]>;\n \n // You'll note that these variables are *not* atomic, and this is done on\n // purpose. This module is designed to have init() called *once* in a\n@@ -39,7 +40,7 @@ pub fn init() {\n     }\n }\n \n-pub fn push(f: proc()) {\n+pub fn push(f: proc:Send()) {\n     unsafe {\n         rtassert!(!RUNNING);\n         rtassert!(!QUEUE.is_null());"}, {"sha": "28f11f44054ce11dc40231a139a2f945fa1524b5", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -55,6 +55,7 @@ Several modules in `core` are clients of `rt`:\n #[allow(missing_doc)];\n \n use any::Any;\n+use kinds::Send;\n use option::Option;\n use result::Result;\n use task::TaskOpts;\n@@ -156,7 +157,7 @@ pub trait Runtime {\n \n     // Miscellaneous calls which are very different depending on what context\n     // you're in.\n-    fn spawn_sibling(~self, cur_task: ~Task, opts: TaskOpts, f: proc());\n+    fn spawn_sibling(~self, cur_task: ~Task, opts: TaskOpts, f: proc:Send());\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n     /// The (low, high) edges of the current stack.\n     fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n@@ -195,7 +196,7 @@ pub fn init(argc: int, argv: **u8) {\n ///\n /// It is forbidden for procedures to register more `at_exit` handlers when they\n /// are running, and doing so will lead to a process abort.\n-pub fn at_exit(f: proc()) {\n+pub fn at_exit(f: proc:Send()) {\n     at_exit_imp::push(f);\n }\n "}, {"sha": "5f0f0afd1855932517cce99dc0f40ca3ff226774", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 81, "deletions": 78, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -13,16 +13,17 @@ use cast;\n use comm::{Sender, Receiver};\n use libc::c_int;\n use libc;\n+use kinds::Send;\n use ops::Drop;\n use option::{Option, Some, None};\n use path::Path;\n-use result::{Result, Err};\n-use rt::task::Task;\n+use result::Err;\n use rt::local::Local;\n+use rt::task::Task;\n \n use ai = io::net::addrinfo;\n use io;\n-use io::{IoError, IoResult};\n+use io::IoResult;\n use io::net::ip::{IpAddr, SocketAddr};\n use io::process::{ProcessConfig, ProcessExit};\n use io::signal::Signum;\n@@ -35,9 +36,10 @@ pub trait Callback {\n \n pub trait EventLoop {\n     fn run(&mut self);\n-    fn callback(&mut self, proc());\n-    fn pausable_idle_callback(&mut self, ~Callback) -> ~PausableIdleCallback;\n-    fn remote_callback(&mut self, ~Callback) -> ~RemoteCallback;\n+    fn callback(&mut self, arg: proc:Send());\n+    fn pausable_idle_callback(&mut self,\n+                              ~Callback:Send) -> ~PausableIdleCallback:Send;\n+    fn remote_callback(&mut self, ~Callback:Send) -> ~RemoteCallback:Send;\n \n     /// The asynchronous I/O services. Not all event loops may provide one.\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;\n@@ -143,93 +145,94 @@ impl<'a> LocalIo<'a> {\n \n pub trait IoFactory {\n     // networking\n-    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError>;\n-    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListener, IoError>;\n-    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError>;\n-    fn unix_bind(&mut self, path: &CString) ->\n-        Result<~RtioUnixListener, IoError>;\n-    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError>;\n+    fn tcp_connect(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpStream:Send>;\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener:Send>;\n+    fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket:Send>;\n+    fn unix_bind(&mut self, path: &CString)\n+        -> IoResult<~RtioUnixListener:Send>;\n+    fn unix_connect(&mut self, path: &CString) -> IoResult<~RtioPipe:Send>;\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError>;\n+                          hint: Option<ai::Hint>) -> IoResult<~[ai::Info]>;\n \n     // filesystem operations\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream;\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)\n+        -> ~RtioFileStream:Send;\n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n-        -> Result<~RtioFileStream, IoError>;\n-    fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError>;\n-    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError>;\n+        -> IoResult<~RtioFileStream:Send>;\n+    fn fs_unlink(&mut self, path: &CString) -> IoResult<()>;\n+    fn fs_stat(&mut self, path: &CString) -> IoResult<FileStat>;\n     fn fs_mkdir(&mut self, path: &CString,\n-                mode: FilePermission) -> Result<(), IoError>;\n+                mode: FilePermission) -> IoResult<()>;\n     fn fs_chmod(&mut self, path: &CString,\n-                mode: FilePermission) -> Result<(), IoError>;\n-    fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError>;\n-    fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError>;\n+                mode: FilePermission) -> IoResult<()>;\n+    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()>;\n+    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()>;\n     fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n-        Result<~[Path], IoError>;\n-    fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError>;\n+        IoResult<~[Path]>;\n+    fn fs_lstat(&mut self, path: &CString) -> IoResult<FileStat>;\n     fn fs_chown(&mut self, path: &CString, uid: int, gid: int) ->\n-        Result<(), IoError>;\n-    fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError>;\n-    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError>;\n-    fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError>;\n+        IoResult<()>;\n+    fn fs_readlink(&mut self, path: &CString) -> IoResult<Path>;\n+    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()>;\n+    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()>;\n     fn fs_utime(&mut self, src: &CString, atime: u64, mtime: u64) ->\n-        Result<(), IoError>;\n+        IoResult<()>;\n \n     // misc\n-    fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;\n+    fn timer_init(&mut self) -> IoResult<~RtioTimer:Send>;\n     fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>;\n-    fn kill(&mut self, pid: libc::pid_t, signal: int) -> Result<(), IoError>;\n-    fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError>;\n+            -> IoResult<(~RtioProcess:Send, ~[Option<~RtioPipe:Send>])>;\n+    fn kill(&mut self, pid: libc::pid_t, signal: int) -> IoResult<()>;\n+    fn pipe_open(&mut self, fd: c_int) -> IoResult<~RtioPipe:Send>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> Result<~RtioTTY, IoError>;\n+            -> IoResult<~RtioTTY:Send>;\n     fn signal(&mut self, signal: Signum, channel: Sender<Signum>)\n-        -> Result<~RtioSignal, IoError>;\n+        -> IoResult<~RtioSignal:Send>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n-    fn listen(~self) -> Result<~RtioTcpAcceptor, IoError>;\n+    fn listen(~self) -> IoResult<~RtioTcpAcceptor:Send>;\n }\n \n pub trait RtioTcpAcceptor : RtioSocket {\n-    fn accept(&mut self) -> Result<~RtioTcpStream, IoError>;\n-    fn accept_simultaneously(&mut self) -> Result<(), IoError>;\n-    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;\n+    fn accept(&mut self) -> IoResult<~RtioTcpStream:Send>;\n+    fn accept_simultaneously(&mut self) -> IoResult<()>;\n+    fn dont_accept_simultaneously(&mut self) -> IoResult<()>;\n }\n \n pub trait RtioTcpStream : RtioSocket {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n-    fn peer_name(&mut self) -> Result<SocketAddr, IoError>;\n-    fn control_congestion(&mut self) -> Result<(), IoError>;\n-    fn nodelay(&mut self) -> Result<(), IoError>;\n-    fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError>;\n-    fn letdie(&mut self) -> Result<(), IoError>;\n-    fn clone(&self) -> ~RtioTcpStream;\n-    fn close_write(&mut self) -> Result<(), IoError>;\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n+    fn peer_name(&mut self) -> IoResult<SocketAddr>;\n+    fn control_congestion(&mut self) -> IoResult<()>;\n+    fn nodelay(&mut self) -> IoResult<()>;\n+    fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()>;\n+    fn letdie(&mut self) -> IoResult<()>;\n+    fn clone(&self) -> ~RtioTcpStream:Send;\n+    fn close_write(&mut self) -> IoResult<()>;\n }\n \n pub trait RtioSocket {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError>;\n+    fn socket_name(&mut self) -> IoResult<SocketAddr>;\n }\n \n pub trait RtioUdpSocket : RtioSocket {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError>;\n-    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError>;\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)>;\n+    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()>;\n \n-    fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError>;\n-    fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError>;\n+    fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()>;\n+    fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()>;\n \n-    fn loop_multicast_locally(&mut self) -> Result<(), IoError>;\n-    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError>;\n+    fn loop_multicast_locally(&mut self) -> IoResult<()>;\n+    fn dont_loop_multicast_locally(&mut self) -> IoResult<()>;\n \n-    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError>;\n-    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError>;\n+    fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()>;\n+    fn time_to_live(&mut self, ttl: int) -> IoResult<()>;\n \n-    fn hear_broadcasts(&mut self) -> Result<(), IoError>;\n-    fn ignore_broadcasts(&mut self) -> Result<(), IoError>;\n+    fn hear_broadcasts(&mut self) -> IoResult<()>;\n+    fn ignore_broadcasts(&mut self) -> IoResult<()>;\n \n-    fn clone(&self) -> ~RtioUdpSocket;\n+    fn clone(&self) -> ~RtioUdpSocket:Send;\n }\n \n pub trait RtioTimer {\n@@ -239,42 +242,42 @@ pub trait RtioTimer {\n }\n \n pub trait RtioFileStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError>;\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError>;\n-    fn seek(&mut self, pos: i64, whence: SeekStyle) -> Result<u64, IoError>;\n-    fn tell(&self) -> Result<u64, IoError>;\n-    fn fsync(&mut self) -> Result<(), IoError>;\n-    fn datasync(&mut self) -> Result<(), IoError>;\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError>;\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<int>;\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int>;\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()>;\n+    fn seek(&mut self, pos: i64, whence: SeekStyle) -> IoResult<u64>;\n+    fn tell(&self) -> IoResult<u64>;\n+    fn fsync(&mut self) -> IoResult<()>;\n+    fn datasync(&mut self) -> IoResult<()>;\n+    fn truncate(&mut self, offset: i64) -> IoResult<()>;\n }\n \n pub trait RtioProcess {\n     fn id(&self) -> libc::pid_t;\n-    fn kill(&mut self, signal: int) -> Result<(), IoError>;\n+    fn kill(&mut self, signal: int) -> IoResult<()>;\n     fn wait(&mut self) -> ProcessExit;\n }\n \n pub trait RtioPipe {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n-    fn clone(&self) -> ~RtioPipe;\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n+    fn clone(&self) -> ~RtioPipe:Send;\n }\n \n pub trait RtioUnixListener {\n-    fn listen(~self) -> Result<~RtioUnixAcceptor, IoError>;\n+    fn listen(~self) -> IoResult<~RtioUnixAcceptor:Send>;\n }\n \n pub trait RtioUnixAcceptor {\n-    fn accept(&mut self) -> Result<~RtioPipe, IoError>;\n+    fn accept(&mut self) -> IoResult<~RtioPipe:Send>;\n }\n \n pub trait RtioTTY {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n-    fn set_raw(&mut self, raw: bool) -> Result<(), IoError>;\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError>;\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n+    fn set_raw(&mut self, raw: bool) -> IoResult<()>;\n+    fn get_winsize(&mut self) -> IoResult<(int, int)>;\n     fn isatty(&self) -> bool;\n }\n "}, {"sha": "211c09977d4ac062a5738f35252859bb8808c1a7", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -20,6 +20,7 @@ use clone::Clone;\n use comm::Sender;\n use io::Writer;\n use iter::{Iterator, Take};\n+use kinds::Send;\n use local_data;\n use ops::Drop;\n use option::{Option, Some, None};\n@@ -50,10 +51,10 @@ pub struct Task {\n     destroyed: bool,\n     name: Option<SendStr>,\n \n-    stdout: Option<~Writer>,\n-    stderr: Option<~Writer>,\n+    stdout: Option<~Writer:Send>,\n+    stderr: Option<~Writer:Send>,\n \n-    priv imp: Option<~Runtime>,\n+    priv imp: Option<~Runtime:Send>,\n }\n \n pub struct GarbageCollector;\n@@ -69,7 +70,7 @@ pub enum BlockedTask {\n pub enum DeathAction {\n     /// Action to be done with the exit code. If set, also makes the task wait\n     /// until all its watched children exit before collecting the status.\n-    Execute(proc(TaskResult)),\n+    Execute(proc:Send(TaskResult)),\n     /// A channel to send the result of the task on when the task exits\n     SendMessage(Sender<TaskResult>),\n }\n@@ -195,7 +196,7 @@ impl Task {\n     /// Inserts a runtime object into this task, transferring ownership to the\n     /// task. It is illegal to replace a previous runtime object in this task\n     /// with this argument.\n-    pub fn put_runtime(&mut self, ops: ~Runtime) {\n+    pub fn put_runtime(&mut self, ops: ~Runtime:Send) {\n         assert!(self.imp.is_none());\n         self.imp = Some(ops);\n     }\n@@ -225,7 +226,7 @@ impl Task {\n                 Ok(t) => Some(t),\n                 Err(t) => {\n                     let (_, obj): (uint, uint) = cast::transmute(t);\n-                    let obj: ~Runtime = cast::transmute((vtable, obj));\n+                    let obj: ~Runtime:Send = cast::transmute((vtable, obj));\n                     self.put_runtime(obj);\n                     None\n                 }\n@@ -235,7 +236,7 @@ impl Task {\n \n     /// Spawns a sibling to this task. The newly spawned task is configured with\n     /// the `opts` structure and will run `f` as the body of its code.\n-    pub fn spawn_sibling(mut ~self, opts: TaskOpts, f: proc()) {\n+    pub fn spawn_sibling(mut ~self, opts: TaskOpts, f: proc:Send()) {\n         let ops = self.imp.take_unwrap();\n         ops.spawn_sibling(self, opts, f)\n     }"}, {"sha": "7c4bd89546943c9545b9a3b01604309908a0aee2", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -68,13 +68,13 @@ impl Thread<()> {\n     /// to finish executing. This means that even if `join` is not explicitly\n     /// called, when the `Thread` falls out of scope its destructor will block\n     /// waiting for the OS thread.\n-    pub fn start<T: Send>(main: proc() -> T) -> Thread<T> {\n+    pub fn start<T: Send>(main: proc:Send() -> T) -> Thread<T> {\n         Thread::start_stack(DEFAULT_STACK_SIZE, main)\n     }\n \n     /// Performs the same functionality as `start`, but specifies an explicit\n     /// stack size for the new thread.\n-    pub fn start_stack<T: Send>(stack: uint, main: proc() -> T) -> Thread<T> {\n+    pub fn start_stack<T: Send>(stack: uint, main: proc:Send() -> T) -> Thread<T> {\n \n         // We need the address of the packet to fill in to be stable so when\n         // `main` fills it in it's still valid, so allocate an extra ~ box to do\n@@ -83,7 +83,7 @@ impl Thread<()> {\n         let packet2: *mut Option<T> = unsafe {\n             *cast::transmute::<&~Option<T>, **mut Option<T>>(&packet)\n         };\n-        let main: proc() = proc() unsafe { *packet2 = Some(main()); };\n+        let main = proc() unsafe { *packet2 = Some(main()); };\n         let native = unsafe { imp::create(stack, ~main) };\n \n         Thread {\n@@ -99,13 +99,13 @@ impl Thread<()> {\n     /// This corresponds to creating threads in the 'detached' state on unix\n     /// systems. Note that platforms may not keep the main program alive even if\n     /// there are detached thread still running around.\n-    pub fn spawn(main: proc()) {\n+    pub fn spawn(main: proc:Send()) {\n         Thread::spawn_stack(DEFAULT_STACK_SIZE, main)\n     }\n \n     /// Performs the same functionality as `spawn`, but explicitly specifies a\n     /// stack size for the new thread.\n-    pub fn spawn_stack(stack: uint, main: proc()) {\n+    pub fn spawn_stack(stack: uint, main: proc:Send()) {\n         unsafe {\n             let handle = imp::create(stack, ~main);\n             imp::detach(handle);\n@@ -146,6 +146,7 @@ impl<T: Send> Drop for Thread<T> {\n mod imp {\n     use cast;\n     use cmp;\n+    use kinds::Send;\n     use libc;\n     use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n                                        LPVOID, DWORD, LPDWORD, HANDLE};\n@@ -155,7 +156,7 @@ mod imp {\n     pub type rust_thread = HANDLE;\n     pub type rust_thread_return = DWORD;\n \n-    pub unsafe fn create(stack: uint, p: ~proc()) -> rust_thread {\n+    pub unsafe fn create(stack: uint, p: ~proc:Send()) -> rust_thread {\n         let arg: *mut libc::c_void = cast::transmute(p);\n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n@@ -203,6 +204,7 @@ mod imp {\n mod imp {\n     use cast;\n     use cmp;\n+    use kinds::Send;\n     use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n     use libc;\n     use mem;\n@@ -213,7 +215,7 @@ mod imp {\n     pub type rust_thread = libc::pthread_t;\n     pub type rust_thread_return = *u8;\n \n-    pub unsafe fn create(stack: uint, p: ~proc()) -> rust_thread {\n+    pub unsafe fn create(stack: uint, p: ~proc:Send()) -> rust_thread {\n         let mut native: libc::pthread_t = mem::uninit();\n         let mut attr: libc::pthread_attr_t = mem::uninit();\n         assert_eq!(pthread_attr_init(&mut attr), 0);"}, {"sha": "930e0858da1be621314fda4add39cbcf632c7a3b", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -76,7 +76,7 @@ use uw = rt::libunwind;\n \n pub struct Unwinder {\n     priv unwinding: bool,\n-    priv cause: Option<~Any>\n+    priv cause: Option<~Any:Send>\n }\n \n impl Unwinder {\n@@ -126,7 +126,7 @@ impl Unwinder {\n         }\n     }\n \n-    pub fn begin_unwind(&mut self, cause: ~Any) -> ! {\n+    pub fn begin_unwind(&mut self, cause: ~Any:Send) -> ! {\n         rtdebug!(\"begin_unwind()\");\n \n         self.unwinding = true;\n@@ -372,7 +372,7 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n /// Do this split took the LLVM IR line counts of `fn main() { fail!()\n /// }` from ~1900/3700 (-O/no opts) to 180/590.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n-fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {\n+fn begin_unwind_inner(msg: ~Any:Send, file: &'static str, line: uint) -> ! {\n     let mut task;\n     {\n         let msg_s = match msg.as_ref::<&'static str>() {"}, {"sha": "c158ddf0d8380894e3d4fb401ce7c14b219b166c", "filename": "src/libstd/task.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -55,7 +55,7 @@ use str::{Str, SendStr, IntoMaybeOwned};\n ///\n /// If you wish for this result's delivery to block until all\n /// children tasks complete, recommend using a result future.\n-pub type TaskResult = Result<(), ~Any>;\n+pub type TaskResult = Result<(), ~Any:Send>;\n \n /// Task configuration options\n pub struct TaskOpts {\n@@ -66,9 +66,9 @@ pub struct TaskOpts {\n     /// The size of the stack for the spawned task\n     stack_size: Option<uint>,\n     /// Task-local stdout\n-    stdout: Option<~Writer>,\n+    stdout: Option<~Writer:Send>,\n     /// Task-local stderr\n-    stderr: Option<~Writer>,\n+    stderr: Option<~Writer:Send>,\n }\n \n /**\n@@ -86,7 +86,7 @@ pub struct TaskOpts {\n pub struct TaskBuilder {\n     /// Options to spawn the new task with\n     opts: TaskOpts,\n-    priv gen_body: Option<proc(v: proc()) -> proc()>,\n+    priv gen_body: Option<proc:Send(v: proc:Send()) -> proc:Send()>,\n     priv nopod: Option<marker::NoPod>,\n }\n \n@@ -150,22 +150,14 @@ impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    pub fn with_wrapper(mut self, wrapper: proc(v: proc()) -> proc()) -> TaskBuilder {\n-        let prev_gen_body = self.gen_body.take();\n-        let prev_gen_body = match prev_gen_body {\n-            Some(gen) => gen,\n-            None => {\n-                let f: proc(proc()) -> proc() = proc(body) body;\n-                f\n-            }\n-        };\n-        let next_gen_body = {\n-            let f: proc(proc()) -> proc() = proc(body) {\n-                wrapper(prev_gen_body(body))\n-            };\n-            f\n+    pub fn with_wrapper(mut self,\n+                        wrapper: proc:Send(v: proc:Send()) -> proc:Send())\n+        -> TaskBuilder\n+    {\n+        self.gen_body = match self.gen_body.take() {\n+            Some(prev) => Some(proc(body) { wrapper(prev(body)) }),\n+            None => Some(wrapper)\n         };\n-        self.gen_body = Some(next_gen_body);\n         self\n     }\n \n@@ -176,7 +168,7 @@ impl TaskBuilder {\n      * the provided unique closure. The task has the properties and behavior\n      * specified by the task_builder.\n      */\n-    pub fn spawn(mut self, f: proc()) {\n+    pub fn spawn(mut self, f: proc:Send()) {\n         let gen_body = self.gen_body.take();\n         let f = match gen_body {\n             Some(gen) => gen(f),\n@@ -199,7 +191,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    pub fn try<T:Send>(mut self, f: proc() -> T) -> Result<T, ~Any> {\n+    pub fn try<T:Send>(mut self, f: proc:Send() -> T) -> Result<T, ~Any:Send> {\n         let (tx, rx) = channel();\n \n         let result = self.future_result();\n@@ -241,12 +233,12 @@ impl TaskOpts {\n /// the provided unique closure.\n ///\n /// This function is equivalent to `task().spawn(f)`.\n-pub fn spawn(f: proc()) {\n+pub fn spawn(f: proc:Send()) {\n     let task = task();\n     task.spawn(f)\n }\n \n-pub fn try<T:Send>(f: proc() -> T) -> Result<T, ~Any> {\n+pub fn try<T:Send>(f: proc:Send() -> T) -> Result<T, ~Any:Send> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -346,7 +338,7 @@ fn test_run_basic() {\n fn test_with_wrapper() {\n     let (tx, rx) = channel();\n     task().with_wrapper(proc(body) {\n-        let result: proc() = proc() {\n+        let result: proc:Send() = proc() {\n             body();\n             tx.send(());\n         };\n@@ -432,7 +424,7 @@ fn test_spawn_sched_childs_on_default_sched() {\n }\n \n #[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: |v: proc()|) {\n+fn avoid_copying_the_body(spawnfn: |v: proc:Send()|) {\n     let (tx, rx) = channel::<uint>();\n \n     let x = ~1;\n@@ -478,7 +470,7 @@ fn test_child_doesnt_ref_parent() {\n     // (well, it would if the constant were 8000+ - I lowered it to be more\n     // valgrind-friendly. try this at home, instead..!)\n     static generations: uint = 16;\n-    fn child_no(x: uint) -> proc() {\n+    fn child_no(x: uint) -> proc:Send() {\n         return proc() {\n             if x < generations {\n                 task().spawn(child_no(x+1));\n@@ -524,10 +516,10 @@ fn test_try_fail_message_owned_str() {\n #[test]\n fn test_try_fail_message_any() {\n     match try(proc() {\n-        fail!(~413u16 as ~Any);\n+        fail!(~413u16 as ~Any:Send);\n     }) {\n         Err(e) => {\n-            type T = ~Any;\n+            type T = ~Any:Send;\n             assert!(e.is::<T>());\n             let any = e.move::<T>().unwrap();\n             assert!(any.is::<u16>());"}, {"sha": "720bf011fa019fc274abeca8b99ae91913b148cf", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -28,7 +28,7 @@ for it to terminate.\n The executing thread has no access to a task pointer and will be using\n a normal large stack.\n */\n-pub fn run_in_bare_thread(f: proc()) {\n+pub fn run_in_bare_thread(f: proc:Send()) {\n     use rt::thread::Thread;\n     Thread::start(f).join()\n }"}, {"sha": "8fc3dd3a460ff0d1f4c0b724b0320f1ed18e7d82", "filename": "src/libsync/future.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ffuture.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -34,7 +34,7 @@ pub struct Future<A> {\n }\n \n enum FutureState<A> {\n-    Pending(proc() -> A),\n+    Pending(proc:Send() -> A),\n     Evaluating,\n     Forced(A)\n }\n@@ -90,7 +90,7 @@ impl<A> Future<A> {\n         Future {state: Forced(val)}\n     }\n \n-    pub fn from_fn(f: proc() -> A) -> Future<A> {\n+    pub fn from_fn(f: proc:Send() -> A) -> Future<A> {\n         /*!\n          * Create a future from a function.\n          *\n@@ -117,7 +117,7 @@ impl<A:Send> Future<A> {\n         })\n     }\n \n-    pub fn spawn(blk: proc() -> A) -> Future<A> {\n+    pub fn spawn(blk: proc:Send() -> A) -> Future<A> {\n         /*!\n          * Create a future from a unique closure.\n          *"}, {"sha": "0cb9bf77ac92523e209b6a60cdc420ca1726b097", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -836,7 +836,7 @@ mod tests {\n         let m = Arc::new(Mutex::new());\n         let m2 = m.clone();\n \n-        let result: result::Result<(), ~Any> = task::try(proc() {\n+        let result: result::Result<(), ~Any:Send> = task::try(proc() {\n             let _lock = m2.lock();\n             fail!();\n         });\n@@ -1076,7 +1076,7 @@ mod tests {\n         let x = Arc::new(RWLock::new());\n         let x2 = x.clone();\n \n-        let result: result::Result<(), ~Any> = task::try(proc() {\n+        let result: result::Result<(), ~Any:Send> = task::try(proc() {\n             lock_rwlock_in_mode(&x2, mode1, || {\n                 fail!();\n             })"}, {"sha": "e1764f970c7d98d250a2c5bc5b9fd454b767c65a", "filename": "src/libsync/task_pool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ftask_pool.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -16,7 +16,7 @@\n use std::task;\n \n enum Msg<T> {\n-    Execute(proc(&T)),\n+    Execute(proc:Send(&T)),\n     Quit\n }\n \n@@ -41,15 +41,15 @@ impl<T> TaskPool<T> {\n     /// returns a function which, given the index of the task, should return\n     /// local data to be kept around in that task.\n     pub fn new(n_tasks: uint,\n-               init_fn_factory: || -> proc(uint) -> T)\n+               init_fn_factory: || -> proc:Send(uint) -> T)\n                -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n         let channels = Vec::from_fn(n_tasks, |i| {\n             let (tx, rx) = channel::<Msg<T>>();\n             let init_fn = init_fn_factory();\n \n-            let task_body: proc() = proc() {\n+            let task_body = proc() {\n                 let local_data = init_fn(i);\n                 loop {\n                     match rx.recv() {\n@@ -73,7 +73,7 @@ impl<T> TaskPool<T> {\n \n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n-    pub fn execute(&mut self, f: proc(&T)) {\n+    pub fn execute(&mut self, f: proc:Send(&T)) {\n         self.channels.get(self.next_index).send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }\n@@ -82,8 +82,8 @@ impl<T> TaskPool<T> {\n \n #[test]\n fn test_task_pool() {\n-    let f: || -> proc(uint) -> uint = || {\n-        let g: proc(uint) -> uint = proc(i) i;\n+    let f: || -> proc:Send(uint) -> uint = || {\n+        let g: proc:Send(uint) -> uint = proc(i) i;\n         g\n     };\n     let mut pool = TaskPool::new(4, f);"}, {"sha": "faeb7b4e0f24d0adbcb6bb72c6d8990e70f44f8c", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -79,7 +79,7 @@ impl SpanHandler {\n // others log errors for later reporting.\n pub struct Handler {\n     err_count: Cell<uint>,\n-    emit: RefCell<~Emitter>,\n+    emit: RefCell<~Emitter:Send>,\n }\n \n impl Handler {\n@@ -148,7 +148,7 @@ pub fn default_handler() -> Handler {\n     mk_handler(~EmitterWriter::stderr())\n }\n \n-pub fn mk_handler(e: ~Emitter) -> Handler {\n+pub fn mk_handler(e: ~Emitter:Send) -> Handler {\n     Handler {\n         err_count: Cell::new(0),\n         emit: RefCell::new(e),\n@@ -221,7 +221,7 @@ pub struct EmitterWriter {\n \n enum Destination {\n     Terminal(term::Terminal<io::stdio::StdWriter>),\n-    Raw(~Writer),\n+    Raw(~Writer:Send),\n }\n \n impl EmitterWriter {\n@@ -238,7 +238,7 @@ impl EmitterWriter {\n         }\n     }\n \n-    pub fn new(dst: ~Writer) -> EmitterWriter {\n+    pub fn new(dst: ~Writer:Send) -> EmitterWriter {\n         EmitterWriter { dst: Raw(dst) }\n     }\n }"}, {"sha": "039b118b327f19172eb68ebdad85787b345b773b", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -123,7 +123,7 @@ pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut BenchHarness)),\n     StaticMetricFn(proc(&mut MetricMap)),\n-    DynTestFn(proc()),\n+    DynTestFn(proc:Send()),\n     DynMetricFn(proc(&mut MetricMap)),\n     DynBenchFn(~TDynBenchFn)\n }\n@@ -948,7 +948,7 @@ pub fn run_test(force_ignore: bool,\n     #[allow(deprecated_owned_vector)]\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: Sender<MonitorMsg>,\n-                      testfn: proc()) {\n+                      testfn: proc:Send()) {\n         spawn(proc() {\n             let (tx, rx) = channel();\n             let mut reader = ChanReader::new(rx);\n@@ -958,8 +958,8 @@ pub fn run_test(force_ignore: bool,\n                 DynTestName(ref name) => name.clone().into_maybe_owned(),\n                 StaticTestName(name) => name.into_maybe_owned(),\n             });\n-            task.opts.stdout = Some(~stdout as ~Writer);\n-            task.opts.stderr = Some(~stderr as ~Writer);\n+            task.opts.stdout = Some(~stdout as ~Writer:Send);\n+            task.opts.stderr = Some(~stderr as ~Writer:Send);\n             let result_future = task.future_result();\n             task.spawn(testfn);\n "}, {"sha": "3e5134720276d29733fabc2851fe0ef4ca001b76", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -394,14 +394,14 @@ impl<'a> Prep<'a> {\n     pub fn exec<'a, T:Send +\n         Encodable<json::Encoder<'a>> +\n         Decodable<json::Decoder>>(\n-            &'a self, blk: proc(&mut Exec) -> T) -> T {\n+            &'a self, blk: proc:Send(&mut Exec) -> T) -> T {\n         self.exec_work(blk).unwrap()\n     }\n \n     fn exec_work<'a, T:Send +\n         Encodable<json::Encoder<'a>> +\n         Decodable<json::Decoder>>( // FIXME(#5121)\n-            &'a self, blk: proc(&mut Exec) -> T) -> Work<'a, T> {\n+            &'a self, blk: proc:Send(&mut Exec) -> T) -> Work<'a, T> {\n         let mut bo = Some(blk);\n \n         debug!(\"exec_work: looking up {} and {:?}\", self.fn_name,"}, {"sha": "6dc62932de2c3b84e72b52f4f2ba4bd2c06a0872", "filename": "src/test/auxiliary/macro_crate_outlive_expansion_phase.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -29,7 +29,7 @@ impl Drop for Foo {\n \n #[macro_registrar]\n pub fn registrar(_: |Name, SyntaxExtension|) {\n-    local_data_key!(foo: ~Any);\n-    local_data::set(foo, ~Foo { foo: 10 } as ~Any);\n+    local_data_key!(foo: ~Any:Send);\n+    local_data::set(foo, ~Foo { foo: 10 } as ~Any:Send);\n }\n "}, {"sha": "6a7f01e67679e76c4bf7626a98015afafd4d34c7", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -31,12 +31,12 @@ impl Foo for B\n \n struct A\n {\n-    v: ~Foo,\n+    v: ~Foo:Send,\n }\n \n fn main()\n {\n-    let a = A {v: ~B{v: None} as ~Foo};\n+    let a = A {v: ~B{v: None} as ~Foo:Send};\n     //~^ ERROR cannot pack type `~B`, which does not fulfill `Send`\n     let v = Rc::new(RefCell::new(a));\n     let w = v.clone();"}, {"sha": "5de2b6b4bb5afba17c559e2b47bc8ddfc5e73368", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -14,7 +14,8 @@ fn foo(_x: @uint) {}\n \n fn main() {\n     let x = @3u;\n-    let _: proc() = proc() foo(x); //~ ERROR does not fulfill `Send`\n-    let _: proc() = proc() foo(x); //~ ERROR does not fulfill `Send`\n-    let _: proc() = proc() foo(x); //~ ERROR does not fulfill `Send`\n+    let _: proc:Send() = proc() foo(x); //~ ERROR does not fulfill `Send`\n+    let _: proc:Send() = proc() foo(x); //~ ERROR does not fulfill `Send`\n+    let _: proc:Send() = proc() foo(x); //~ ERROR does not fulfill `Send`\n+    let _: proc() = proc() foo(x);\n }"}, {"sha": "32c23a3efdd36bc3fba1a06bda201b65367462c9", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -12,7 +12,7 @@\n \n trait Foo {}\n \n-fn a(_x: ~Foo) { // should be same as ~Foo:Send\n+fn a(_x: ~Foo:Send) {\n }\n \n fn b(_x: &'static Foo) { // should be same as &'static Foo:'static"}, {"sha": "d812e19e1c85e63be471a760aa2bd56d0d396b7a", "filename": "src/test/run-fail/fail-macro-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:failed at '~Any'\n \n fn main() {\n-    fail!(~413 as ~::std::any::Any);\n+    fail!(~413 as ~::std::any::Any:Send);\n }"}, {"sha": "4a6f37c91b788148ec87f9470d8febfde82df1ab", "filename": "src/test/run-fail/unwind-box-fn-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -18,7 +18,7 @@ fn failfn() {\n \n fn main() {\n     let y = ~0;\n-    let x: @proc() = @(proc() {\n+    let x: @proc:Send() = @(proc() {\n         println!(\"{:?}\", y.clone());\n     });\n     failfn();"}, {"sha": "6c1b2f4653af36977e8268789238e79bfb0d83cb", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -42,7 +42,7 @@ fn main() {\n     let (tx, rx) = channel();\n     let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n     spawn(proc() {\n-        set_logger(~MyWriter(w) as ~Logger);\n+        set_logger(~MyWriter(w) as ~Logger:Send);\n         debug!(\"debug\");\n         info!(\"info\");\n     });"}, {"sha": "4f3db3a5f77f996f4b7140f5fc6c81abb8106763", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -18,7 +18,7 @@ struct Pair {\n pub fn main() {\n     let z = ~Pair { a : 10, b : 12};\n \n-    let f: proc() = proc() {\n+    let f: proc:Send() = proc() {\n         assert_eq!(z.a, 10);\n         assert_eq!(z.b, 12);\n     };"}, {"sha": "d04717e380be5cf50b179ddbcd0b884027d31f23", "filename": "src/test/run-pass/issue-2190-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -12,13 +12,13 @@ use std::task;\n \n static generations: uint = 1024+256+128+49;\n \n-fn spawn(f: proc()) {\n+fn spawn(f: proc:Send()) {\n     let mut t = task::task();\n     t.opts.stack_size = Some(32 * 1024);\n     t.spawn(f);\n }\n \n-fn child_no(x: uint) -> proc() {\n+fn child_no(x: uint) -> proc:Send() {\n     proc() {\n         if x < generations {\n             spawn(child_no(x+1));"}, {"sha": "1f1de9ddb9ba14f03614588b18cbc122b15c7fca", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -11,7 +11,7 @@\n use std::task;\n \n type RingBuffer = Vec<f64> ;\n-type SamplesFn = proc(samples: &RingBuffer);\n+type SamplesFn = proc:Send(samples: &RingBuffer);\n \n enum Msg\n {"}, {"sha": "ac3dd80c383bbbfc33f2049beaba5503d5832462", "filename": "src/test/run-pass/sendfn-spawn-with-fn-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -18,7 +18,7 @@ fn test05_start(f: proc(int)) {\n \n fn test05() {\n     let three = ~3;\n-    let fn_to_send: proc(int) = proc(n) {\n+    let fn_to_send: proc:Send(int) = proc(n) {\n         println!(\"{}\", *three + n); // will copy x into the closure\n         assert_eq!(*three, 3);\n     };"}, {"sha": "e2806421518e14563978f9355814218bbda2ba53", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -36,7 +36,7 @@ fn test_tempdir() {\n \n fn test_rm_tempdir() {\n     let (tx, rx) = channel();\n-    let f: proc() = proc() {\n+    let f: proc:Send() = proc() {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n         tx.send(tmp.path().clone());\n         fail!(\"fail to unwind past `tmp`\");\n@@ -47,7 +47,7 @@ fn test_rm_tempdir() {\n \n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n     let path = tmp.path().clone();\n-    let f: proc() = proc() {\n+    let f: proc:Send() = proc() {\n         let _tmp = tmp;\n         fail!(\"fail to unwind past `tmp`\");\n     };\n@@ -56,7 +56,7 @@ fn test_rm_tempdir() {\n \n     let path;\n     {\n-        let f: proc() -> TempDir = proc() {\n+        let f = proc() {\n             TempDir::new(\"test_rm_tempdir\").unwrap()\n         };\n         let tmp = task::try(f).ok().expect(\"test_rm_tmdir\");"}, {"sha": "6059e5e95ee5ff24ebca322a01ace5e66b01102f", "filename": "src/test/run-pass/trait-bounds-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -26,7 +26,7 @@ fn d(x: ~Foo:Send) {\n }\n \n fn e(x: ~Foo) { // sugar for ~Foo:Owned\n-    b(x);\n+    a(x);\n }\n \n pub fn main() { }"}, {"sha": "7a53df8737cae1dbf2790c7b68b2961bbe39a43d", "filename": "src/test/run-pass/trait-cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -18,7 +18,7 @@ struct Tree(@RefCell<TreeR>);\n struct TreeR {\n     left: Option<Tree>,\n     right: Option<Tree>,\n-    val: ~to_str\n+    val: ~to_str:Send\n }\n \n trait to_str {\n@@ -53,10 +53,10 @@ fn foo<T:to_str>(x: T) -> ~str { x.to_str_() }\n pub fn main() {\n     let t1 = Tree(@RefCell::new(TreeR{left: None,\n                                       right: None,\n-                                      val: ~1 as ~to_str}));\n+                                      val: ~1 as ~to_str:Send}));\n     let t2 = Tree(@RefCell::new(TreeR{left: Some(t1),\n                                       right: Some(t1),\n-                                      val: ~2 as ~to_str}));\n+                                      val: ~2 as ~to_str:Send}));\n     let expected = ~\"[2, some([1, none, none]), some([1, none, none])]\";\n     assert!(t2.to_str_() == expected);\n     assert!(foo(t2) == expected);"}, {"sha": "78fa7520f33fa082902b07a4517fe355a2d9cc49", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -19,12 +19,11 @@ enum maybe_pointy {\n \n struct Pointy {\n     a : maybe_pointy,\n-    d : proc() -> uint,\n+    d : proc:Send() -> uint,\n }\n \n-fn make_uniq_closure<A:Send>(a: A) -> proc() -> uint {\n-    let result: proc() -> uint = proc() &a as *A as uint;\n-    result\n+fn make_uniq_closure<A:Send>(a: A) -> proc:Send() -> uint {\n+    proc() { &a as *A as uint }\n }\n \n fn empty_pointy() -> @RefCell<Pointy> {"}, {"sha": "aa048a239dbf3171a6ed262ff1da7e7ebea3a250", "filename": "src/test/run-pass/uniq-cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb9172d7b512c36f34d34b024640f030d1fde2eb/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc.rs?ref=bb9172d7b512c36f34d34b024640f030d1fde2eb", "patch": "@@ -20,7 +20,7 @@ enum maybe_pointy {\n struct Pointy {\n     a : maybe_pointy,\n     c : ~int,\n-    d : proc()->(),\n+    d : proc:Send()->(),\n }\n \n fn empty_pointy() -> @RefCell<Pointy> {"}]}