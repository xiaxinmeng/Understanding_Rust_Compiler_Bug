{"sha": "b18a22a384001afe1c72b7182406bb44b815e9cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxOGEyMmEzODQwMDFhZmUxYzcyYjcxODI0MDZiYjQ0YjgxNWU5Y2Y=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-06-06T23:30:43Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-06-07T10:32:09Z"}, "message": "Inline and remove `process_predicate`.\n\nBecause it has a single callsite.\n\nThis patch is large but trivial, doing the minimal amount of work\n(mostly `self.` insertions) necessary.", "tree": {"sha": "ac04d5743a9304c700b0342c66a124926d4bf176", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac04d5743a9304c700b0342c66a124926d4bf176"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b18a22a384001afe1c72b7182406bb44b815e9cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b18a22a384001afe1c72b7182406bb44b815e9cf", "html_url": "https://github.com/rust-lang/rust/commit/b18a22a384001afe1c72b7182406bb44b815e9cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b18a22a384001afe1c72b7182406bb44b815e9cf/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdfd9ca08800f7a69fb2a740ac31dbff13b94bce", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdfd9ca08800f7a69fb2a740ac31dbff13b94bce", "html_url": "https://github.com/rust-lang/rust/commit/cdfd9ca08800f7a69fb2a740ac31dbff13b94bce"}], "stats": {"total": 477, "additions": 235, "deletions": 242}, "files": [{"sha": "af24f3166d7221f00909ea095efe23973a2c8581", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 235, "deletions": 242, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/b18a22a384001afe1c72b7182406bb44b815e9cf/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18a22a384001afe1c72b7182406bb44b815e9cf/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=b18a22a384001afe1c72b7182406bb44b815e9cf", "patch": "@@ -262,294 +262,287 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n     type Obligation = PendingPredicateObligation<'tcx>;\n     type Error = FulfillmentErrorCode<'tcx>;\n \n+    /// Processes a predicate obligation and returns either:\n+    /// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n+    /// - `Ok(None)` if we don't have enough info to be sure\n+    /// - `Err` if the predicate does not hold\n     fn process_obligation(&mut self,\n-                          obligation: &mut Self::Obligation)\n+                          pending_obligation: &mut Self::Obligation)\n                           -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n     {\n-        process_predicate(self.selcx, obligation, self.register_region_obligations)\n-    }\n-\n-    fn process_backedge<'c, I>(&mut self, cycle: I,\n-                               _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>)\n-        where I: Clone + Iterator<Item=&'c PendingPredicateObligation<'tcx>>,\n-    {\n-        if self.selcx.coinductive_match(cycle.clone().map(|s| s.obligation.predicate)) {\n-            debug!(\"process_child_obligations: coinductive match\");\n-        } else {\n-            let cycle : Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n-            self.selcx.infcx().report_overflow_error_cycle(&cycle);\n+        // if we were stalled on some unresolved variables, first check\n+        // whether any of them have been resolved; if not, don't bother\n+        // doing more work yet\n+        if !pending_obligation.stalled_on.is_empty() {\n+            if pending_obligation.stalled_on.iter().all(|&ty| {\n+                let resolved_ty = self.selcx.infcx().shallow_resolve(&ty);\n+                resolved_ty == ty // nothing changed here\n+            }) {\n+                debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n+                       self.selcx.infcx()\n+                           .resolve_type_vars_if_possible(&pending_obligation.obligation),\n+                       pending_obligation.stalled_on);\n+                return Ok(None);\n+            }\n+            pending_obligation.stalled_on = vec![];\n         }\n-    }\n-}\n \n-/// Return the set of type variables contained in a trait ref\n-fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-                                       t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n-{\n-    t.skip_binder() // ok b/c this check doesn't care about regions\n-     .input_types()\n-     .map(|t| selcx.infcx().resolve_type_vars_if_possible(&t))\n-     .filter(|t| t.has_infer_types())\n-     .flat_map(|t| t.walk())\n-     .filter(|t| match t.sty { ty::TyInfer(_) => true, _ => false })\n-     .collect()\n-}\n+        let obligation = &mut pending_obligation.obligation;\n \n-/// Processes a predicate obligation and returns either:\n-/// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n-/// - `Ok(None)` if we don't have enough info to be sure\n-/// - `Err` if the predicate does not hold\n-fn process_predicate<'a, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-    register_region_obligations: bool)\n-    -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n-              FulfillmentErrorCode<'tcx>>\n-{\n-    // if we were stalled on some unresolved variables, first check\n-    // whether any of them have been resolved; if not, don't bother\n-    // doing more work yet\n-    if !pending_obligation.stalled_on.is_empty() {\n-        if pending_obligation.stalled_on.iter().all(|&ty| {\n-            let resolved_ty = selcx.infcx().shallow_resolve(&ty);\n-            resolved_ty == ty // nothing changed here\n-        }) {\n-            debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n-                   selcx.infcx().resolve_type_vars_if_possible(&pending_obligation.obligation),\n-                   pending_obligation.stalled_on);\n-            return Ok(None);\n+        if obligation.predicate.has_infer_types() {\n+            obligation.predicate =\n+                self.selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n         }\n-        pending_obligation.stalled_on = vec![];\n-    }\n-\n-    let obligation = &mut pending_obligation.obligation;\n-\n-    if obligation.predicate.has_infer_types() {\n-        obligation.predicate = selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n-    }\n \n-    match obligation.predicate {\n-        ty::Predicate::Trait(ref data) => {\n-            let trait_obligation = obligation.with(data.clone());\n-\n-            if data.is_global() && !data.has_late_bound_regions() {\n-                // no type variables present, can use evaluation for better caching.\n-                // FIXME: consider caching errors too.\n-                if selcx.infcx().predicate_must_hold(&obligation) {\n-                    debug!(\"selecting trait `{:?}` at depth {} evaluated to holds\",\n-                           data, obligation.recursion_depth);\n-                    return Ok(Some(vec![]))\n+        match obligation.predicate {\n+            ty::Predicate::Trait(ref data) => {\n+                let trait_obligation = obligation.with(data.clone());\n+\n+                if data.is_global() && !data.has_late_bound_regions() {\n+                    // no type variables present, can use evaluation for better caching.\n+                    // FIXME: consider caching errors too.\n+                    if self.selcx.infcx().predicate_must_hold(&obligation) {\n+                        debug!(\"selecting trait `{:?}` at depth {} evaluated to holds\",\n+                               data, obligation.recursion_depth);\n+                        return Ok(Some(vec![]))\n+                    }\n                 }\n-            }\n \n-            match selcx.select(&trait_obligation) {\n-                Ok(Some(vtable)) => {\n-                    debug!(\"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n-                           data, obligation.recursion_depth);\n-                    Ok(Some(mk_pending(vtable.nested_obligations())))\n-                }\n-                Ok(None) => {\n-                    debug!(\"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n-                           data, obligation.recursion_depth);\n-\n-                    // This is a bit subtle: for the most part, the\n-                    // only reason we can fail to make progress on\n-                    // trait selection is because we don't have enough\n-                    // information about the types in the trait. One\n-                    // exception is that we sometimes haven't decided\n-                    // what kind of closure a closure is. *But*, in\n-                    // that case, it turns out, the type of the\n-                    // closure will also change, because the closure\n-                    // also includes references to its upvars as part\n-                    // of its type, and those types are resolved at\n-                    // the same time.\n-                    //\n-                    // FIXME(#32286) logic seems false if no upvars\n-                    pending_obligation.stalled_on =\n-                        trait_ref_type_vars(selcx, data.to_poly_trait_ref());\n-\n-                    debug!(\"process_predicate: pending obligation {:?} now stalled on {:?}\",\n-                           selcx.infcx().resolve_type_vars_if_possible(obligation),\n-                           pending_obligation.stalled_on);\n-\n-                    Ok(None)\n-                }\n-                Err(selection_err) => {\n-                    info!(\"selecting trait `{:?}` at depth {} yielded Err\",\n-                          data, obligation.recursion_depth);\n+                match self.selcx.select(&trait_obligation) {\n+                    Ok(Some(vtable)) => {\n+                        debug!(\"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n+                               data, obligation.recursion_depth);\n+                        Ok(Some(mk_pending(vtable.nested_obligations())))\n+                    }\n+                    Ok(None) => {\n+                        debug!(\"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n+                               data, obligation.recursion_depth);\n+\n+                        // This is a bit subtle: for the most part, the\n+                        // only reason we can fail to make progress on\n+                        // trait selection is because we don't have enough\n+                        // information about the types in the trait. One\n+                        // exception is that we sometimes haven't decided\n+                        // what kind of closure a closure is. *But*, in\n+                        // that case, it turns out, the type of the\n+                        // closure will also change, because the closure\n+                        // also includes references to its upvars as part\n+                        // of its type, and those types are resolved at\n+                        // the same time.\n+                        //\n+                        // FIXME(#32286) logic seems false if no upvars\n+                        pending_obligation.stalled_on =\n+                            trait_ref_type_vars(self.selcx, data.to_poly_trait_ref());\n+\n+                        debug!(\"process_predicate: pending obligation {:?} now stalled on {:?}\",\n+                               self.selcx.infcx().resolve_type_vars_if_possible(obligation),\n+                               pending_obligation.stalled_on);\n+\n+                        Ok(None)\n+                    }\n+                    Err(selection_err) => {\n+                        info!(\"selecting trait `{:?}` at depth {} yielded Err\",\n+                              data, obligation.recursion_depth);\n \n-                    Err(CodeSelectionError(selection_err))\n+                        Err(CodeSelectionError(selection_err))\n+                    }\n                 }\n             }\n-        }\n \n-        ty::Predicate::RegionOutlives(ref binder) => {\n-            match selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n-                Ok(()) => Ok(Some(Vec::new())),\n-                Err(_) => Err(CodeSelectionError(Unimplemented)),\n+            ty::Predicate::RegionOutlives(ref binder) => {\n+                match self.selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n+                    Ok(()) => Ok(Some(Vec::new())),\n+                    Err(_) => Err(CodeSelectionError(Unimplemented)),\n+                }\n             }\n-        }\n \n-        ty::Predicate::TypeOutlives(ref binder) => {\n-            // Check if there are higher-ranked regions.\n-            match binder.no_late_bound_regions() {\n-                // If there are, inspect the underlying type further.\n-                None => {\n-                    // Convert from `Binder<OutlivesPredicate<Ty, Region>>` to `Binder<Ty>`.\n-                    let binder = binder.map_bound_ref(|pred| pred.0);\n-\n-                    // Check if the type has any bound regions.\n-                    match binder.no_late_bound_regions() {\n-                        // If so, this obligation is an error (for now). Eventually we should be\n-                        // able to support additional cases here, like `for<'a> &'a str: 'a`.\n-                        None => {\n-                            Err(CodeSelectionError(Unimplemented))\n-                        }\n-                        // Otherwise, we have something of the form\n-                        // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n-                        Some(t_a) => {\n-                            let r_static = selcx.tcx().types.re_static;\n-                            if register_region_obligations {\n-                                selcx.infcx().register_region_obligation(\n-                                    obligation.cause.body_id,\n-                                    RegionObligation {\n-                                        sup_type: t_a,\n-                                        sub_region: r_static,\n-                                        cause: obligation.cause.clone(),\n-                                    });\n+            ty::Predicate::TypeOutlives(ref binder) => {\n+                // Check if there are higher-ranked regions.\n+                match binder.no_late_bound_regions() {\n+                    // If there are, inspect the underlying type further.\n+                    None => {\n+                        // Convert from `Binder<OutlivesPredicate<Ty, Region>>` to `Binder<Ty>`.\n+                        let binder = binder.map_bound_ref(|pred| pred.0);\n+\n+                        // Check if the type has any bound regions.\n+                        match binder.no_late_bound_regions() {\n+                            // If so, this obligation is an error (for now). Eventually we should be\n+                            // able to support additional cases here, like `for<'a> &'a str: 'a`.\n+                            None => {\n+                                Err(CodeSelectionError(Unimplemented))\n+                            }\n+                            // Otherwise, we have something of the form\n+                            // `for<'a> T: 'a where 'a not in T`, which we can treat as\n+                            // `T: 'static`.\n+                            Some(t_a) => {\n+                                let r_static = self.selcx.tcx().types.re_static;\n+                                if self.register_region_obligations {\n+                                    self.selcx.infcx().register_region_obligation(\n+                                        obligation.cause.body_id,\n+                                        RegionObligation {\n+                                            sup_type: t_a,\n+                                            sub_region: r_static,\n+                                            cause: obligation.cause.clone(),\n+                                        });\n+                                }\n+                                Ok(Some(vec![]))\n                             }\n-                            Ok(Some(vec![]))\n                         }\n                     }\n-                }\n-                // If there aren't, register the obligation.\n-                Some(ty::OutlivesPredicate(t_a, r_b)) => {\n-                    if register_region_obligations {\n-                        selcx.infcx().register_region_obligation(\n-                            obligation.cause.body_id,\n-                            RegionObligation {\n-                                sup_type: t_a,\n-                                sub_region: r_b,\n-                                cause: obligation.cause.clone()\n-                            });\n+                    // If there aren't, register the obligation.\n+                    Some(ty::OutlivesPredicate(t_a, r_b)) => {\n+                        if self.register_region_obligations {\n+                            self.selcx.infcx().register_region_obligation(\n+                                obligation.cause.body_id,\n+                                RegionObligation {\n+                                    sup_type: t_a,\n+                                    sub_region: r_b,\n+                                    cause: obligation.cause.clone()\n+                                });\n+                        }\n+                        Ok(Some(vec![]))\n                     }\n-                    Ok(Some(vec![]))\n                 }\n             }\n-        }\n \n-        ty::Predicate::Projection(ref data) => {\n-            let project_obligation = obligation.with(data.clone());\n-            match project::poly_project_and_unify_type(selcx, &project_obligation) {\n-                Ok(None) => {\n-                    let tcx = selcx.tcx();\n-                    pending_obligation.stalled_on =\n-                        trait_ref_type_vars(selcx, data.to_poly_trait_ref(tcx));\n-                    Ok(None)\n+            ty::Predicate::Projection(ref data) => {\n+                let project_obligation = obligation.with(data.clone());\n+                match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n+                    Ok(None) => {\n+                        let tcx = self.selcx.tcx();\n+                        pending_obligation.stalled_on =\n+                            trait_ref_type_vars(self.selcx, data.to_poly_trait_ref(tcx));\n+                        Ok(None)\n+                    }\n+                    Ok(Some(os)) => Ok(Some(mk_pending(os))),\n+                    Err(e) => Err(CodeProjectionError(e))\n                 }\n-                Ok(Some(os)) => Ok(Some(mk_pending(os))),\n-                Err(e) => Err(CodeProjectionError(e))\n             }\n-        }\n \n-        ty::Predicate::ObjectSafe(trait_def_id) => {\n-            if !selcx.tcx().is_object_safe(trait_def_id) {\n-                Err(CodeSelectionError(Unimplemented))\n-            } else {\n-                Ok(Some(Vec::new()))\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                if !self.selcx.tcx().is_object_safe(trait_def_id) {\n+                    Err(CodeSelectionError(Unimplemented))\n+                } else {\n+                    Ok(Some(Vec::new()))\n+                }\n             }\n-        }\n \n-        ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-            match selcx.infcx().closure_kind(closure_def_id, closure_substs) {\n-                Some(closure_kind) => {\n-                    if closure_kind.extends(kind) {\n-                        Ok(Some(vec![]))\n-                    } else {\n-                        Err(CodeSelectionError(Unimplemented))\n+            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                match self.selcx.infcx().closure_kind(closure_def_id, closure_substs) {\n+                    Some(closure_kind) => {\n+                        if closure_kind.extends(kind) {\n+                            Ok(Some(vec![]))\n+                        } else {\n+                            Err(CodeSelectionError(Unimplemented))\n+                        }\n+                    }\n+                    None => {\n+                        Ok(None)\n                     }\n-                }\n-                None => {\n-                    Ok(None)\n                 }\n             }\n-        }\n \n-        ty::Predicate::WellFormed(ty) => {\n-            match ty::wf::obligations(selcx.infcx(),\n-                                      obligation.param_env,\n-                                      obligation.cause.body_id,\n-                                      ty, obligation.cause.span) {\n-                None => {\n-                    pending_obligation.stalled_on = vec![ty];\n-                    Ok(None)\n+            ty::Predicate::WellFormed(ty) => {\n+                match ty::wf::obligations(self.selcx.infcx(),\n+                                          obligation.param_env,\n+                                          obligation.cause.body_id,\n+                                          ty, obligation.cause.span) {\n+                    None => {\n+                        pending_obligation.stalled_on = vec![ty];\n+                        Ok(None)\n+                    }\n+                    Some(os) => Ok(Some(mk_pending(os)))\n                 }\n-                Some(os) => Ok(Some(mk_pending(os)))\n             }\n-        }\n \n-        ty::Predicate::Subtype(ref subtype) => {\n-            match selcx.infcx().subtype_predicate(&obligation.cause,\n-                                                  obligation.param_env,\n-                                                  subtype) {\n-                None => {\n-                    // none means that both are unresolved\n-                    pending_obligation.stalled_on = vec![subtype.skip_binder().a,\n-                                                         subtype.skip_binder().b];\n-                    Ok(None)\n-                }\n-                Some(Ok(ok)) => {\n-                    Ok(Some(mk_pending(ok.obligations)))\n-                }\n-                Some(Err(err)) => {\n-                    let expected_found = ExpectedFound::new(subtype.skip_binder().a_is_expected,\n-                                                            subtype.skip_binder().a,\n-                                                            subtype.skip_binder().b);\n-                    Err(FulfillmentErrorCode::CodeSubtypeError(expected_found, err))\n+            ty::Predicate::Subtype(ref subtype) => {\n+                match self.selcx.infcx().subtype_predicate(&obligation.cause,\n+                                                           obligation.param_env,\n+                                                           subtype) {\n+                    None => {\n+                        // None means that both are unresolved.\n+                        pending_obligation.stalled_on = vec![subtype.skip_binder().a,\n+                                                             subtype.skip_binder().b];\n+                        Ok(None)\n+                    }\n+                    Some(Ok(ok)) => {\n+                        Ok(Some(mk_pending(ok.obligations)))\n+                    }\n+                    Some(Err(err)) => {\n+                        let expected_found = ExpectedFound::new(subtype.skip_binder().a_is_expected,\n+                                                                subtype.skip_binder().a,\n+                                                                subtype.skip_binder().b);\n+                        Err(FulfillmentErrorCode::CodeSubtypeError(expected_found, err))\n+                    }\n                 }\n             }\n-        }\n \n-        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-            match selcx.tcx().lift_to_global(&obligation.param_env) {\n-                None => {\n-                    Ok(None)\n-                }\n-                Some(param_env) => {\n-                    match selcx.tcx().lift_to_global(&substs) {\n-                        Some(substs) => {\n-                            let instance = ty::Instance::resolve(\n-                                selcx.tcx().global_tcx(),\n-                                param_env,\n-                                def_id,\n-                                substs,\n-                            );\n-                            if let Some(instance) = instance {\n-                                let cid = GlobalId {\n-                                    instance,\n-                                    promoted: None,\n-                                };\n-                                match selcx.tcx().at(obligation.cause.span)\n-                                                 .const_eval(param_env.and(cid)) {\n-                                    Ok(_) => Ok(Some(vec![])),\n-                                    Err(err) => Err(CodeSelectionError(ConstEvalFailure(err)))\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                match self.selcx.tcx().lift_to_global(&obligation.param_env) {\n+                    None => {\n+                        Ok(None)\n+                    }\n+                    Some(param_env) => {\n+                        match self.selcx.tcx().lift_to_global(&substs) {\n+                            Some(substs) => {\n+                                let instance = ty::Instance::resolve(\n+                                    self.selcx.tcx().global_tcx(),\n+                                    param_env,\n+                                    def_id,\n+                                    substs,\n+                                );\n+                                if let Some(instance) = instance {\n+                                    let cid = GlobalId {\n+                                        instance,\n+                                        promoted: None,\n+                                    };\n+                                    match self.selcx.tcx().at(obligation.cause.span)\n+                                                          .const_eval(param_env.and(cid)) {\n+                                        Ok(_) => Ok(Some(vec![])),\n+                                        Err(err) => Err(CodeSelectionError(ConstEvalFailure(err)))\n+                                    }\n+                                } else {\n+                                    Err(CodeSelectionError(ConstEvalFailure(ConstEvalErr {\n+                                        span: obligation.cause.span,\n+                                        kind: ErrKind::CouldNotResolve.into(),\n+                                    })))\n                                 }\n-                            } else {\n-                                Err(CodeSelectionError(ConstEvalFailure(ConstEvalErr {\n-                                    span: obligation.cause.span,\n-                                    kind: ErrKind::CouldNotResolve.into(),\n-                                })))\n+                            },\n+                            None => {\n+                                pending_obligation.stalled_on = substs.types().collect();\n+                                Ok(None)\n                             }\n-                        },\n-                        None => {\n-                            pending_obligation.stalled_on = substs.types().collect();\n-                            Ok(None)\n                         }\n                     }\n                 }\n             }\n         }\n     }\n+\n+    fn process_backedge<'c, I>(&mut self, cycle: I,\n+                               _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>)\n+        where I: Clone + Iterator<Item=&'c PendingPredicateObligation<'tcx>>,\n+    {\n+        if self.selcx.coinductive_match(cycle.clone().map(|s| s.obligation.predicate)) {\n+            debug!(\"process_child_obligations: coinductive match\");\n+        } else {\n+            let cycle : Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n+            self.selcx.infcx().report_overflow_error_cycle(&cycle);\n+        }\n+    }\n+}\n+\n+/// Return the set of type variables contained in a trait ref\n+fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                       t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n+{\n+    t.skip_binder() // ok b/c this check doesn't care about regions\n+     .input_types()\n+     .map(|t| selcx.infcx().resolve_type_vars_if_possible(&t))\n+     .filter(|t| t.has_infer_types())\n+     .flat_map(|t| t.walk())\n+     .filter(|t| match t.sty { ty::TyInfer(_) => true, _ => false })\n+     .collect()\n }\n \n fn to_fulfillment_error<'tcx>("}]}