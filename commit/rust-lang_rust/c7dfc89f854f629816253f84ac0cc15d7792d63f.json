{"sha": "c7dfc89f854f629816253f84ac0cc15d7792d63f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZGZjODlmODU0ZjYyOTgxNjI1M2Y4NGFjMGNjMTVkNzc5MmQ2M2Y=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-08-29T01:29:12Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-09-01T02:55:27Z"}, "message": "JsonApiDumper", "tree": {"sha": "8bcf1a6db6afce471300c68bf3129b2e8ec2894c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bcf1a6db6afce471300c68bf3129b2e8ec2894c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7dfc89f854f629816253f84ac0cc15d7792d63f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7dfc89f854f629816253f84ac0cc15d7792d63f", "html_url": "https://github.com/rust-lang/rust/commit/c7dfc89f854f629816253f84ac0cc15d7792d63f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7dfc89f854f629816253f84ac0cc15d7792d63f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbafc5758ba905e57d3f10476deb05a79588cd81", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbafc5758ba905e57d3f10476deb05a79588cd81", "html_url": "https://github.com/rust-lang/rust/commit/cbafc5758ba905e57d3f10476deb05a79588cd81"}], "stats": {"total": 360, "additions": 359, "deletions": 1}, "files": [{"sha": "e92c23d7d7c5ae2191c338f6948458c13fc7e7ad", "filename": "src/librustc_save_analysis/json_api_dumper.rs", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/c7dfc89f854f629816253f84ac0cc15d7792d63f/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dfc89f854f629816253f84ac0cc15d7792d63f/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs?ref=c7dfc89f854f629816253f84ac0cc15d7792d63f", "patch": "@@ -0,0 +1,356 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::Write;\n+\n+use rustc::hir::def_id::DefId;\n+use rustc_serialize::json::as_json;\n+\n+use external_data::*;\n+use data::VariableKind;\n+use dump::Dump;\n+\n+pub struct JsonApiDumper<'b, W: Write + 'b> {\n+    output: &'b mut W,\n+    result: Analysis,\n+}\n+\n+impl<'b, W: Write> JsonApiDumper<'b, W> {\n+    pub fn new(writer: &'b mut W) -> JsonApiDumper<'b, W> {\n+        JsonApiDumper { output: writer, result: Analysis::new() }\n+    }\n+}\n+\n+impl<'b, W: Write> Drop for JsonApiDumper<'b, W> {\n+    fn drop(&mut self) {\n+        if let Err(_) = write!(self.output, \"{}\", as_json(&self.result)) {\n+            error!(\"Error writing output\");\n+        }\n+    }\n+}\n+\n+macro_rules! impl_fn {\n+    ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n+        fn $fn_name(&mut self, data: $data_type) {\n+            if let Some(datum) = From::from(data) {\n+                self.result.$bucket.push(datum);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'b, W: Write + 'b> Dump for JsonApiDumper<'b, W> {\n+    fn crate_prelude(&mut self, data: CratePreludeData) {\n+        self.result.prelude = Some(data)\n+    }\n+\n+    impl_fn!(use_data, UseData, imports);\n+    impl_fn!(use_glob, UseGlobData, imports);\n+\n+    impl_fn!(enum_data, EnumData, defs);\n+    impl_fn!(tuple_variant, TupleVariantData, defs);\n+    impl_fn!(struct_variant, StructVariantData, defs);\n+    impl_fn!(struct_data, StructData, defs);\n+    impl_fn!(trait_data, TraitData, defs);\n+    impl_fn!(function, FunctionData, defs);\n+    impl_fn!(method, MethodData, defs);\n+    impl_fn!(macro_data, MacroData, defs);\n+    impl_fn!(mod_data, ModData, defs);\n+    impl_fn!(typedef, TypeDefData, defs);\n+    impl_fn!(variable, VariableData, defs);\n+}\n+\n+// FIXME methods. The defs have information about possible overriding and the\n+// refs have decl information (e.g., a trait method where we know the required\n+// method, but not the supplied method). In both cases, we are currently\n+// ignoring it.\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Analysis {\n+    prelude: Option<CratePreludeData>,\n+    imports: Vec<Import>,\n+    defs: Vec<Def>,\n+}\n+\n+impl Analysis {\n+    fn new() -> Analysis {\n+        Analysis {\n+            prelude: None,\n+            imports: vec![],\n+            defs: vec![],\n+        }\n+    }\n+}\n+\n+// DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n+// we use our own Id which is the same, but without the newtype.\n+#[derive(Debug, RustcEncodable)]\n+struct Id {\n+    krate: u32,\n+    index: u32,\n+}\n+\n+impl From<DefId> for Id {\n+    fn from(id: DefId) -> Id {\n+        Id {\n+            krate: id.krate,\n+            index: id.index.as_u32(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Import {\n+    kind: ImportKind,\n+    id: Id,\n+    span: SpanData,\n+    name: String,\n+    value: String,\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+enum ImportKind {\n+    Use,\n+    GlobUse,\n+}\n+\n+impl From<UseData> for Option<Import> {\n+    fn from(data: UseData) -> Option<Import> {\n+        Some(Import {\n+            kind: ImportKind::Use,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            value: String::new(),\n+        })\n+    }\n+}\n+impl From<UseGlobData> for Option<Import> {\n+    fn from(data: UseGlobData) -> Option<Import> {\n+        Some(Import {\n+            kind: ImportKind::GlobUse,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: \"*\".to_owned(),\n+            value: data.names.join(\", \"),\n+        })\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Def {\n+    kind: DefKind,\n+    id: Id,\n+    span: SpanData,\n+    name: String,\n+    qualname: String,\n+    value: String,\n+    parent: Option<Id>,\n+    children: Vec<Id>,\n+    decl_id: Option<Id>,\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+enum DefKind {\n+    // value = variant names\n+    Enum,\n+    // value = enum name + variant name + types\n+    Tuple,\n+    // value = [enum name +] name + fields\n+    Struct,\n+    // value = signature\n+    Trait,\n+    // value = type + generics\n+    Function,\n+    // value = type + generics\n+    Method,\n+    // No id, no value.\n+    Macro,\n+    // value = file_name\n+    Mod,\n+    // value = aliased type\n+    Type,\n+    // value = type and init expression (for all variable kinds).\n+    Static,\n+    Const,\n+    Field,\n+}\n+\n+impl From<EnumData> for Option<Def> {\n+    fn from(data: EnumData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Enum,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            parent: None,\n+            children: data.variants.into_iter().map(|id| From::from(id)).collect(),\n+            decl_id: None,\n+        })\n+    }\n+}\n+\n+impl From<TupleVariantData> for Option<Def> {\n+    fn from(data: TupleVariantData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Tuple,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            parent: None,\n+            children: vec![],\n+            decl_id: None,\n+        })\n+    }\n+}\n+impl From<StructVariantData> for Option<Def> {\n+    fn from(data: StructVariantData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Struct,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            parent: None,\n+            children: vec![],\n+            decl_id: None,\n+        })\n+    }\n+}\n+impl From<StructData> for Option<Def> {\n+    fn from(data: StructData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Struct,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            parent: None,\n+            children: data.fields.into_iter().map(|id| From::from(id)).collect(),\n+            decl_id: None,\n+        })\n+    }\n+}\n+impl From<TraitData> for Option<Def> {\n+    fn from(data: TraitData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Trait,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+            parent: None,\n+            decl_id: None,\n+        })\n+    }\n+}\n+impl From<FunctionData> for Option<Def> {\n+    fn from(data: FunctionData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Function,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            children: vec![],\n+            parent: None,\n+            decl_id: None,\n+        })\n+    }\n+}\n+impl From<MethodData> for Option<Def> {\n+    fn from(data: MethodData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Method,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            children: vec![],\n+            parent: None,\n+            decl_id: data.decl_id.map(|id| From::from(id)),\n+        })\n+    }\n+}\n+impl From<MacroData> for Option<Def> {\n+    fn from(data: MacroData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Macro,\n+            id: From::from(null_def_id()),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: String::new(),\n+            children: vec![],\n+            parent: None,\n+            decl_id: None,\n+        })\n+    }\n+}\n+impl From<ModData> for Option<Def> {\n+    fn from(data:ModData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Mod,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.filename,\n+            children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+            parent: None,\n+            decl_id: None,\n+        })\n+    }\n+}\n+impl From<TypeDefData> for Option<Def> {\n+    fn from(data: TypeDefData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Type,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            children: vec![],\n+            parent: None,\n+            decl_id: None,\n+        })\n+    }\n+}\n+impl From<VariableData> for Option<Def> {\n+    fn from(data: VariableData) -> Option<Def> {\n+        Some(Def {\n+            kind: match data.kind {\n+                VariableKind::Static => DefKind::Static,\n+                VariableKind::Const => DefKind::Const,\n+                VariableKind::Local => { return None }\n+                VariableKind::Field => DefKind::Field,\n+            },\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            children: vec![],\n+            parent: None,\n+            decl_id: None,\n+        })\n+    }\n+}"}, {"sha": "5aa8bec3d36c244a96fcb6ac20d0218493b162f2", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dfc89f854f629816253f84ac0cc15d7792d63f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dfc89f854f629816253f84ac0cc15d7792d63f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c7dfc89f854f629816253f84ac0cc15d7792d63f", "patch": "@@ -30,6 +30,7 @@ extern crate serialize as rustc_serialize;\n extern crate syntax_pos;\n \n mod csv_dumper;\n+mod json_api_dumper;\n mod json_dumper;\n mod data;\n mod dump;\n@@ -57,6 +58,7 @@ use syntax::codemap::MacroAttribute;\n use syntax_pos::*;\n \n pub use self::csv_dumper::CsvDumper;\n+pub use self::json_api_dumper::JsonApiDumper;\n pub use self::json_dumper::JsonDumper;\n pub use self::data::*;\n pub use self::dump::Dump;\n@@ -804,7 +806,7 @@ pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     match format {\n         Format::Csv => dump!(CsvDumper::new(output)),\n         Format::Json => dump!(JsonDumper::new(output)),\n-        Format::JsonApi => /* TODO */ dump!(JsonDumper::new(output)),\n+        Format::JsonApi => dump!(JsonApiDumper::new(output)),\n     }\n }\n "}]}