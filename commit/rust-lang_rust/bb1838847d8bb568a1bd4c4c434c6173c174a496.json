{"sha": "bb1838847d8bb568a1bd4c4c434c6173c174a496", "node_id": "C_kwDOAAsO6NoAKGJiMTgzODg0N2Q4YmI1NjhhMWJkNGM0YzQzNGM2MTczYzE3NGE0OTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-04T22:50:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-04T22:50:24Z"}, "message": "Auto merge of #108747 - matthiaskrgr:rollup-wfc7fx4, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #108627 (Properly colorize multi-part suggestions in the same line)\n - #108632 (Omit unchanged options from config.toml in `configure.py`)\n - #108715 (Remove unclosed_delims from parser)\n - #108723 (rustdoc: function signature search with traits in `where` clause)\n - #108724 (field is not used outside the crate)\n - #108734 (rustdoc: Note in a type's layout/size if it is uninhabited)\n - #108736 (Remove `allow(potential_query_instability)` from `ast_passes`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "813b21302e4591e296d30058c221e940d9e1b00e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/813b21302e4591e296d30058c221e940d9e1b00e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb1838847d8bb568a1bd4c4c434c6173c174a496", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb1838847d8bb568a1bd4c4c434c6173c174a496", "html_url": "https://github.com/rust-lang/rust/commit/bb1838847d8bb568a1bd4c4c434c6173c174a496", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb1838847d8bb568a1bd4c4c434c6173c174a496/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f15f0ea73972786e426732c5b92ba9a904b866c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f15f0ea73972786e426732c5b92ba9a904b866c4", "html_url": "https://github.com/rust-lang/rust/commit/f15f0ea73972786e426732c5b92ba9a904b866c4"}, {"sha": "ff95645e2ca66021187e68a11d1055752aa320d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff95645e2ca66021187e68a11d1055752aa320d2", "html_url": "https://github.com/rust-lang/rust/commit/ff95645e2ca66021187e68a11d1055752aa320d2"}], "stats": {"total": 371, "additions": 176, "deletions": 195}, "files": [{"sha": "539c822ea09777ba775dd2ccf46bcadb6de67a2c", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -12,7 +12,7 @@ use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n use rustc_ast::walk_list;\n use rustc_ast::*;\n use rustc_ast_pretty::pprust::{self, State};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_macros::Subdiagnostic;\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{\n@@ -643,7 +643,7 @@ fn validate_generic_param_order(\n     span: Span,\n ) {\n     let mut max_param: Option<ParamKindOrd> = None;\n-    let mut out_of_order = FxHashMap::default();\n+    let mut out_of_order = FxIndexMap::default();\n     let mut param_idents = Vec::with_capacity(generics.len());\n \n     for (idx, param) in generics.iter().enumerate() {"}, {"sha": "6207a32b28de6ce2f5761a3f597c36d433a597a0", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -4,7 +4,6 @@\n //!\n //! The crate also contains other misc AST visitors, e.g. `node_count` and `show_span`.\n \n-#![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(if_let_guard)]\n #![feature(iter_is_partitioned)]"}, {"sha": "1b2e7b7e083b4f7275a22fbaaca320608ef4f648", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -1895,7 +1895,7 @@ impl EmitterWriter {\n                         self.draw_code_line(\n                             &mut buffer,\n                             &mut row_num,\n-                            &Vec::new(),\n+                            &[],\n                             p + line_start,\n                             l,\n                             show_code_change,\n@@ -1919,7 +1919,7 @@ impl EmitterWriter {\n                             self.draw_code_line(\n                                 &mut buffer,\n                                 &mut row_num,\n-                                &Vec::new(),\n+                                &[],\n                                 p + line_start,\n                                 l,\n                                 show_code_change,\n@@ -1936,7 +1936,7 @@ impl EmitterWriter {\n                             self.draw_code_line(\n                                 &mut buffer,\n                                 &mut row_num,\n-                                &Vec::new(),\n+                                &[],\n                                 p + line_start,\n                                 l,\n                                 show_code_change,\n@@ -1951,7 +1951,7 @@ impl EmitterWriter {\n                 self.draw_code_line(\n                     &mut buffer,\n                     &mut row_num,\n-                    highlight_parts,\n+                    &highlight_parts,\n                     line_pos + line_start,\n                     line,\n                     show_code_change,\n@@ -2176,7 +2176,7 @@ impl EmitterWriter {\n         &self,\n         buffer: &mut StyledBuffer,\n         row_num: &mut usize,\n-        highlight_parts: &Vec<SubstitutionHighlight>,\n+        highlight_parts: &[SubstitutionHighlight],\n         line_num: usize,\n         line_to_add: &str,\n         show_code_change: DisplaySuggestion,"}, {"sha": "99af872f07f305d8e32752795f999239d41e4946", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -331,7 +331,7 @@ impl CodeSuggestion {\n                     });\n                     buf.push_str(&part.snippet);\n                     let cur_hi = sm.lookup_char_pos(part.span.hi());\n-                    if prev_hi.line == cur_lo.line && cur_hi.line == cur_lo.line {\n+                    if cur_hi.line == cur_lo.line {\n                         // Account for the difference between the width of the current code and the\n                         // snippet being suggested, so that the *later* suggestions are correctly\n                         // aligned on the screen."}, {"sha": "387843ee69333fc29793cccda632aa85e62164a9", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -94,10 +94,10 @@ pub(crate) type UnificationTable<'a, 'tcx, T> = ut::UnificationTable<\n /// call to `start_snapshot` and `rollback_to`.\n #[derive(Clone)]\n pub struct InferCtxtInner<'tcx> {\n-    /// Cache for projections. This cache is snapshotted along with the infcx.\n+    /// Cache for projections.\n     ///\n-    /// Public so that `traits::project` can use it.\n-    pub projection_cache: traits::ProjectionCacheStorage<'tcx>,\n+    /// This cache is snapshotted along with the infcx.\n+    projection_cache: traits::ProjectionCacheStorage<'tcx>,\n \n     /// We instantiate `UnificationTable` with `bounds<Ty>` because the types\n     /// that might instantiate a general type variable have an order,"}, {"sha": "0a65c37ea7b79332c1c8e3e86da1979ffd452c48", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 113, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -19,7 +19,6 @@ use crate::errors::{\n };\n \n use crate::fluent_generated as fluent;\n-use crate::lexer::UnmatchedDelim;\n use crate::parser;\n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n@@ -220,7 +219,6 @@ impl MultiSugg {\n /// is dropped.\n pub struct SnapshotParser<'a> {\n     parser: Parser<'a>,\n-    unclosed_delims: Vec<UnmatchedDelim>,\n }\n \n impl<'a> Deref for SnapshotParser<'a> {\n@@ -255,27 +253,15 @@ impl<'a> Parser<'a> {\n         &self.sess.span_diagnostic\n     }\n \n-    /// Replace `self` with `snapshot.parser` and extend `unclosed_delims` with `snapshot.unclosed_delims`.\n-    /// This is to avoid losing unclosed delims errors `create_snapshot_for_diagnostic` clears.\n+    /// Replace `self` with `snapshot.parser`.\n     pub(super) fn restore_snapshot(&mut self, snapshot: SnapshotParser<'a>) {\n         *self = snapshot.parser;\n-        self.unclosed_delims.extend(snapshot.unclosed_delims);\n-    }\n-\n-    pub fn unclosed_delims(&self) -> &[UnmatchedDelim] {\n-        &self.unclosed_delims\n     }\n \n     /// Create a snapshot of the `Parser`.\n     pub fn create_snapshot_for_diagnostic(&self) -> SnapshotParser<'a> {\n-        let mut snapshot = self.clone();\n-        let unclosed_delims = self.unclosed_delims.clone();\n-        // Clear `unclosed_delims` in snapshot to avoid\n-        // duplicate errors being emitted when the `Parser`\n-        // is dropped (which may or may not happen, depending\n-        // if the parsing the snapshot is created for is successful)\n-        snapshot.unclosed_delims.clear();\n-        SnapshotParser { parser: snapshot, unclosed_delims }\n+        let snapshot = self.clone();\n+        SnapshotParser { parser: snapshot }\n     }\n \n     pub(super) fn span_to_snippet(&self, span: Span) -> Result<String, SpanSnippetError> {\n@@ -579,21 +565,6 @@ impl<'a> Parser<'a> {\n         } else {\n             label_sp\n         };\n-        match self.recover_closing_delimiter(\n-            &expected\n-                .iter()\n-                .filter_map(|tt| match tt {\n-                    TokenType::Token(t) => Some(t.clone()),\n-                    _ => None,\n-                })\n-                .collect::<Vec<_>>(),\n-            err,\n-        ) {\n-            Err(e) => err = e,\n-            Ok(recovered) => {\n-                return Ok(recovered);\n-            }\n-        }\n \n         if self.check_too_many_raw_str_terminators(&mut err) {\n             if expected.contains(&TokenType::Token(token::Semi)) && self.eat(&token::Semi) {\n@@ -1573,12 +1544,6 @@ impl<'a> Parser<'a> {\n         );\n         let mut err = self.struct_span_err(sp, &msg);\n         let label_exp = format!(\"expected `{token_str}`\");\n-        match self.recover_closing_delimiter(&[t.clone()], err) {\n-            Err(e) => err = e,\n-            Ok(recovered) => {\n-                return Ok(recovered);\n-            }\n-        }\n         let sm = self.sess.source_map();\n         if !sm.is_multiline(prev_sp.until(sp)) {\n             // When the spans are in the same line, it means that the only content\n@@ -1795,81 +1760,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn recover_closing_delimiter(\n-        &mut self,\n-        tokens: &[TokenKind],\n-        mut err: DiagnosticBuilder<'a, ErrorGuaranteed>,\n-    ) -> PResult<'a, bool> {\n-        let mut pos = None;\n-        // We want to use the last closing delim that would apply.\n-        for (i, unmatched) in self.unclosed_delims.iter().enumerate().rev() {\n-            if tokens.contains(&token::CloseDelim(unmatched.expected_delim))\n-                && Some(self.token.span) > unmatched.unclosed_span\n-            {\n-                pos = Some(i);\n-            }\n-        }\n-        match pos {\n-            Some(pos) => {\n-                // Recover and assume that the detected unclosed delimiter was meant for\n-                // this location. Emit the diagnostic and act as if the delimiter was\n-                // present for the parser's sake.\n-\n-                // Don't attempt to recover from this unclosed delimiter more than once.\n-                let unmatched = self.unclosed_delims.remove(pos);\n-                let delim = TokenType::Token(token::CloseDelim(unmatched.expected_delim));\n-                if unmatched.found_delim.is_none() {\n-                    // We encountered `Eof`, set this fact here to avoid complaining about missing\n-                    // `fn main()` when we found place to suggest the closing brace.\n-                    *self.sess.reached_eof.borrow_mut() = true;\n-                }\n-\n-                // We want to suggest the inclusion of the closing delimiter where it makes\n-                // the most sense, which is immediately after the last token:\n-                //\n-                //  {foo(bar {}}\n-                //      ^      ^\n-                //      |      |\n-                //      |      help: `)` may belong here\n-                //      |\n-                //      unclosed delimiter\n-                if let Some(sp) = unmatched.unclosed_span {\n-                    let mut primary_span: Vec<Span> =\n-                        err.span.primary_spans().iter().cloned().collect();\n-                    primary_span.push(sp);\n-                    let mut primary_span: MultiSpan = primary_span.into();\n-                    for span_label in err.span.span_labels() {\n-                        if let Some(label) = span_label.label {\n-                            primary_span.push_span_label(span_label.span, label);\n-                        }\n-                    }\n-                    err.set_span(primary_span);\n-                    err.span_label(sp, \"unclosed delimiter\");\n-                }\n-                // Backticks should be removed to apply suggestions.\n-                let mut delim = delim.to_string();\n-                delim.retain(|c| c != '`');\n-                err.span_suggestion_short(\n-                    self.prev_token.span.shrink_to_hi(),\n-                    &format!(\"`{delim}` may belong here\"),\n-                    delim,\n-                    Applicability::MaybeIncorrect,\n-                );\n-                if unmatched.found_delim.is_none() {\n-                    // Encountered `Eof` when lexing blocks. Do not recover here to avoid knockdown\n-                    // errors which would be emitted elsewhere in the parser and let other error\n-                    // recovery consume the rest of the file.\n-                    Err(err)\n-                } else {\n-                    err.emit();\n-                    self.expected_tokens.clear(); // Reduce the number of errors.\n-                    Ok(true)\n-                }\n-            }\n-            _ => Err(err),\n-        }\n-    }\n-\n     /// Eats tokens until we can be relatively sure we reached the end of the\n     /// statement. This is something of a best-effort heuristic.\n     ///"}, {"sha": "e00eda47c663ee0cc811b370bc8cf8375511c980", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -1394,19 +1394,6 @@ impl<'a> Parser<'a> {\n             self.parse_expr_let()\n         } else if self.eat_keyword(kw::Underscore) {\n             Ok(self.mk_expr(self.prev_token.span, ExprKind::Underscore))\n-        } else if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n-            // Don't complain about bare semicolons after unclosed braces\n-            // recovery in order to keep the error count down. Fixing the\n-            // delimiters will possibly also fix the bare semicolon found in\n-            // expression context. For example, silence the following error:\n-            //\n-            //     error: expected expression, found `;`\n-            //      --> file.rs:2:13\n-            //       |\n-            //     2 |     foo(bar(;\n-            //       |             ^ expected expression\n-            self.bump();\n-            Ok(self.mk_expr_err(self.token.span))\n         } else if self.token.uninterpolated_span().rust_2018() {\n             // `Span::rust_2018()` is somewhat expensive; don't get it repeatedly.\n             if self.check_keyword(kw::Async) {"}, {"sha": "85cc8ca02a9779038658adbf6c71bb77e1d2b360", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -125,16 +125,13 @@ impl<'a> Parser<'a> {\n             return Ok(Some(item.into_inner()));\n         };\n \n-        let mut unclosed_delims = vec![];\n         let item =\n             self.collect_tokens_trailing_token(attrs, force_collect, |this: &mut Self, attrs| {\n                 let item =\n                     this.parse_item_common_(attrs, mac_allowed, attrs_allowed, fn_parse_mode);\n-                unclosed_delims.append(&mut this.unclosed_delims);\n                 Ok((item?, TrailingToken::None))\n             })?;\n \n-        self.unclosed_delims.append(&mut unclosed_delims);\n         Ok(item)\n     }\n \n@@ -1960,21 +1957,12 @@ impl<'a> Parser<'a> {\n         // FIXME: This will make us not emit the help even for declarative\n         // macros within the same crate (that we can fix), which is sad.\n         if !span.from_expansion() {\n-            if self.unclosed_delims.is_empty() {\n-                let DelimSpan { open, close } = args.dspan;\n-                err.multipart_suggestion(\n-                    \"change the delimiters to curly braces\",\n-                    vec![(open, \"{\".to_string()), (close, '}'.to_string())],\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.span_suggestion(\n-                    span,\n-                    \"change the delimiters to curly braces\",\n-                    \" { /* items */ }\",\n-                    Applicability::HasPlaceholders,\n-                );\n-            }\n+            let DelimSpan { open, close } = args.dspan;\n+            err.multipart_suggestion(\n+                \"change the delimiters to curly braces\",\n+                vec![(open, \"{\".to_string()), (close, '}'.to_string())],\n+                Applicability::MaybeIncorrect,\n+            );\n             err.span_suggestion(\n                 span.shrink_to_hi(),\n                 \"add a semicolon\","}, {"sha": "6e9b447fa61a91494311475d54e89d88db88b152", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -146,10 +146,7 @@ pub struct Parser<'a> {\n     /// See the comments in the `parse_path_segment` function for more details.\n     unmatched_angle_bracket_count: u32,\n     max_angle_bracket_count: u32,\n-    /// A list of all unclosed delimiters found by the lexer. If an entry is used for error recovery\n-    /// it gets removed from here. Every entry left at the end gets emitted as an independent\n-    /// error.\n-    pub(super) unclosed_delims: Vec<UnmatchedDelim>,\n+\n     last_unexpected_token_span: Option<Span>,\n     /// Span pointing at the `:` for the last type ascription the parser has seen, and whether it\n     /// looked like it could have been a mistyped path or literal `Option:Some(42)`).\n@@ -168,7 +165,7 @@ pub struct Parser<'a> {\n // This type is used a lot, e.g. it's cloned when matching many declarative macro rules with nonterminals. Make sure\n // it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Parser<'_>, 312);\n+rustc_data_structures::static_assert_size!(Parser<'_>, 288);\n \n /// Stores span information about a closure.\n #[derive(Clone)]\n@@ -215,12 +212,6 @@ struct CaptureState {\n     inner_attr_ranges: FxHashMap<AttrId, ReplaceRange>,\n }\n \n-impl<'a> Drop for Parser<'a> {\n-    fn drop(&mut self) {\n-        emit_unclosed_delims(&mut self.unclosed_delims, &self.sess);\n-    }\n-}\n-\n /// Iterator over a `TokenStream` that produces `Token`s. It's a bit odd that\n /// we (a) lex tokens into a nice tree structure (`TokenStream`), and then (b)\n /// use this type to emit them as a linear sequence. But a linear sequence is\n@@ -478,7 +469,6 @@ impl<'a> Parser<'a> {\n             desugar_doc_comments,\n             unmatched_angle_bracket_count: 0,\n             max_angle_bracket_count: 0,\n-            unclosed_delims: Vec::new(),\n             last_unexpected_token_span: None,\n             last_type_ascription: None,\n             subparser_name,\n@@ -859,7 +849,6 @@ impl<'a> Parser<'a> {\n         let mut recovered = false;\n         let mut trailing = false;\n         let mut v = ThinVec::new();\n-        let unclosed_delims = !self.unclosed_delims.is_empty();\n \n         while !self.expect_any_with_type(kets, expect) {\n             if let token::CloseDelim(..) | token::Eof = self.token.kind {\n@@ -901,7 +890,7 @@ impl<'a> Parser<'a> {\n                                 _ => {\n                                     // Attempt to keep parsing if it was a similar separator.\n                                     if let Some(tokens) = t.similar_tokens() {\n-                                        if tokens.contains(&self.token.kind) && !unclosed_delims {\n+                                        if tokens.contains(&self.token.kind) {\n                                             self.bump();\n                                         }\n                                     }"}, {"sha": "3aaeb09d4c005dd1a59336f4dbce81cc8e0c7759", "filename": "config.toml.example", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -164,6 +164,7 @@ changelog-seen = 2\n # General build configuration options\n # =============================================================================\n [build]\n+\n # The default stage to use for the `check` subcommand\n #check-stage = 0\n "}, {"sha": "c0d382d8a503b109db4a213e4e806b6b1cdb143e", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -488,6 +488,22 @@ def configure_top_level_key(lines, top_level_key, value):\n     else:\n         configure_section(sections[section_key], section_config)\n \n+def write_uncommented(target, f):\n+    block = []\n+    is_comment = True\n+\n+    for line in target:\n+        block.append(line)\n+        if len(line) == 0:\n+            if not is_comment:\n+                for l in block:\n+                    f.write(l + \"\\n\")\n+            block = []\n+            is_comment = True\n+            continue\n+        is_comment = is_comment and line.startswith('#')\n+    return f\n+\n # Now that we've built up our `config.toml`, write it all out in the same\n # order that we read it in.\n p(\"\")\n@@ -496,11 +512,9 @@ def configure_top_level_key(lines, top_level_key, value):\n     for section in section_order:\n         if section == 'target':\n             for target in targets:\n-                for line in targets[target]:\n-                    f.write(line + \"\\n\")\n+                f = write_uncommented(targets[target], f)\n         else:\n-            for line in sections[section]:\n-                f.write(line + \"\\n\")\n+            f = write_uncommented(sections[section], f)\n \n with bootstrap.output('Makefile') as f:\n     contents = os.path.join(rust_dir, 'src', 'bootstrap', 'mk', 'Makefile.in')"}, {"sha": "08796f10d92389afecfa70a390defbb381f007b0", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -1839,6 +1839,12 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n         } else {\n             let size = layout.size.bytes() - tag_size;\n             write!(w, \"{size} byte{pl}\", pl = if size == 1 { \"\" } else { \"s\" },);\n+            if layout.abi.is_uninhabited() {\n+                write!(\n+                    w,\n+                    \" (<a href=\\\"https://doc.rust-lang.org/stable/reference/glossary.html#uninhabited\\\">uninhabited</a>)\"\n+                );\n+            }\n         }\n     }\n "}, {"sha": "e22ac6ec19b008c0a7f8e3d83ea633722529a614", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -7,9 +7,7 @@ use rustc_span::symbol::Symbol;\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n-use crate::clean::types::{\n-    FnRetTy, Function, GenericBound, Generics, ItemId, Type, WherePredicate,\n-};\n+use crate::clean::types::{FnRetTy, Function, Generics, ItemId, Type, WherePredicate};\n use crate::formats::cache::{Cache, OrphanImplItem};\n use crate::formats::item_type::ItemType;\n use crate::html::format::join_with_double_colon;\n@@ -482,29 +480,23 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n     if let Type::Generic(arg_s) = *arg {\n         // First we check if the bounds are in a `where` predicate...\n         if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n-            WherePredicate::BoundPredicate { ty, .. } => ty.def_id(cache) == arg.def_id(cache),\n+            WherePredicate::BoundPredicate { ty: Type::Generic(ty_s), .. } => *ty_s == arg_s,\n             _ => false,\n         }) {\n             let mut ty_generics = Vec::new();\n             let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n             for bound in bounds.iter() {\n-                if let GenericBound::TraitBound(poly_trait, _) = bound {\n-                    for param_def in poly_trait.generic_params.iter() {\n-                        match &param_def.kind {\n-                            clean::GenericParamDefKind::Type { default: Some(ty), .. } => {\n-                                add_generics_and_bounds_as_types(\n-                                    self_,\n-                                    generics,\n-                                    ty,\n-                                    tcx,\n-                                    recurse + 1,\n-                                    &mut ty_generics,\n-                                    cache,\n-                                )\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n+                if let Some(path) = bound.get_trait_path() {\n+                    let ty = Type::Path { path };\n+                    add_generics_and_bounds_as_types(\n+                        self_,\n+                        generics,\n+                        &ty,\n+                        tcx,\n+                        recurse + 1,\n+                        &mut ty_generics,\n+                        cache,\n+                    );\n                 }\n             }\n             insert_ty(res, arg.clone(), ty_generics);"}, {"sha": "dee4819e81a9f43116110074227c0df4e7a5d20f", "filename": "tests/rustdoc-js-std/option-type-signatures.js", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Frustdoc-js-std%2Foption-type-signatures.js", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Frustdoc-js-std%2Foption-type-signatures.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Foption-type-signatures.js?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -0,0 +1,7 @@\n+const QUERY = 'option, fnonce -> option';\n+\n+const EXPECTED = {\n+    'others': [\n+        { 'path': 'std::option::Option', 'name': 'map' },\n+    ],\n+};"}, {"sha": "6cb42a455a36901707485c81eb36eb1ac6369b1e", "filename": "tests/rustdoc-js/where-clause.js", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Frustdoc-js%2Fwhere-clause.js", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Frustdoc-js%2Fwhere-clause.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fwhere-clause.js?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -0,0 +1,19 @@\n+const QUERY = ['trait<nested>', '-> trait<nested>', 't1, t2'];\n+\n+const EXPECTED = [\n+    {\n+        'in_args': [\n+           { 'path': 'where_clause', 'name': 'abracadabra' },\n+        ],\n+    },\n+    {\n+        'others': [\n+            { 'path': 'where_clause', 'name': 'alacazam' },\n+        ],\n+    },\n+    {\n+        'others': [\n+            { 'path': 'where_clause', 'name': 'presto' },\n+        ],\n+    },\n+];"}, {"sha": "808561feee227674592d0c292540247526b663c1", "filename": "tests/rustdoc-js/where-clause.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Frustdoc-js%2Fwhere-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Frustdoc-js%2Fwhere-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fwhere-clause.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -0,0 +1,16 @@\n+pub struct Nested;\n+\n+pub trait Trait<T> {\n+    fn thank_you(x: T);\n+}\n+\n+pub fn abracadabra<X>(_: X) where X: Trait<Nested> {}\n+\n+pub fn alacazam<X>() -> X where X: Trait<Nested> {}\n+\n+pub trait T1 {}\n+pub trait T2<'a, T> {\n+    fn please(_: &'a T);\n+}\n+\n+pub fn presto<A, B>(_: A, _: B) where A: T1, B: for <'b> T2<'b, Nested> {}"}, {"sha": "bd88e73af5cbf12db38b32bb93e44f9eac3d8d3d", "filename": "tests/rustdoc/type-layout.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Frustdoc%2Ftype-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Frustdoc%2Ftype-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Ftype-layout.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -83,3 +83,11 @@ pub enum WithNiche {\n     None,\n     Some(std::num::NonZeroU32),\n }\n+\n+// @hasraw type_layout/enum.Uninhabited.html 'Size: '\n+// @hasraw - '0 bytes (<a href=\"https://doc.rust-lang.org/stable/reference/glossary.html#uninhabited\">uninhabited</a>)'\n+pub enum Uninhabited {}\n+\n+// @hasraw type_layout/struct.Uninhabited2.html 'Size: '\n+// @hasraw - '8 bytes (<a href=\"https://doc.rust-lang.org/stable/reference/glossary.html#uninhabited\">uninhabited</a>)'\n+pub struct Uninhabited2(std::convert::Infallible, u64);"}, {"sha": "77d0322d05fcfedf83230d5ebdab5bddb3b927d6", "filename": "tests/ui/suggestions/multiline-multipart-suggestion.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Fui%2Fsuggestions%2Fmultiline-multipart-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Fui%2Fsuggestions%2Fmultiline-multipart-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fmultiline-multipart-suggestion.rs?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: --error-format=human --color=always\n+// ignore-windows\n+\n+fn short(foo_bar: &Vec<&i32>) -> &i32 { //~ ERROR missing lifetime specifier\n+    &12\n+}\n+\n+fn long( //~ ERROR missing lifetime specifier\n+    foo_bar: &Vec<&i32>,\n+    something_very_long_so_that_the_line_will_wrap_around__________: i32,\n+) -> &i32 {\n+    &12\n+}\n+\n+fn long2( //~ ERROR missing lifetime specifier\n+    foo_bar: &Vec<&i32>) -> &i32 {\n+    &12\n+}\n+fn main() {}"}, {"sha": "045a86b4f541f50a4c71cf239775ad970a950a2f", "filename": "tests/ui/suggestions/multiline-multipart-suggestion.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Fui%2Fsuggestions%2Fmultiline-multipart-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb1838847d8bb568a1bd4c4c434c6173c174a496/tests%2Fui%2Fsuggestions%2Fmultiline-multipart-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fmultiline-multipart-suggestion.stderr?ref=bb1838847d8bb568a1bd4c4c434c6173c174a496", "patch": "@@ -0,0 +1,46 @@\n+\u001b[0m\u001b[1m\u001b[38;5;9merror[E0106]\u001b[0m\u001b[0m\u001b[1m: missing lifetime specifier\u001b[0m\n+\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m$DIR/multiline-multipart-suggestion.rs:4:34\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mfn short(foo_bar: &Vec<&i32>) -> &i32 {\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected named lifetime parameter\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: this function's return type contains a borrowed value, but the signature does not say which one of `foo_bar`'s 2 lifetimes it is borrowed from\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider introducing a named lifetime parameter\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mfn short\u001b[0m\u001b[0m\u001b[38;5;10m<'a>\u001b[0m\u001b[0m(foo_bar: &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mVec<&\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mi32>) -> &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mi32 {\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\n+\n+\u001b[0m\u001b[1m\u001b[38;5;9merror[E0106]\u001b[0m\u001b[0m\u001b[1m: missing lifetime specifier\u001b[0m\n+\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m$DIR/multiline-multipart-suggestion.rs:11:6\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    foo_bar: &Vec<&i32>,\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    something_very_long_so_that_the_line_will_wrap_around__________: i32,\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m) -> &i32 {\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected named lifetime parameter\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: this function's return type contains a borrowed value, but the signature does not say which one of `foo_bar`'s 2 lifetimes it is borrowed from\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider introducing a named lifetime parameter\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0mfn long\u001b[0m\u001b[0m\u001b[38;5;10m<'a>\u001b[0m\u001b[0m(\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m    foo_bar: &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mVec<&\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mi32>,\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    something_very_long_so_that_the_line_will_wrap_around__________: i32,\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m) -> &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mi32 {\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n+\n+\u001b[0m\u001b[1m\u001b[38;5;9merror[E0106]\u001b[0m\u001b[0m\u001b[1m: missing lifetime specifier\u001b[0m\n+\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m$DIR/multiline-multipart-suggestion.rs:16:29\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    foo_bar: &Vec<&i32>) -> &i32 {\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected named lifetime parameter\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: this function's return type contains a borrowed value, but the signature does not say which one of `foo_bar`'s 2 lifetimes it is borrowed from\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider introducing a named lifetime parameter\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0mfn long2\u001b[0m\u001b[0m\u001b[38;5;10m<'a>\u001b[0m\u001b[0m(\n+\u001b[0m\u001b[1m\u001b[38;5;12mLL\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m    foo_bar: &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mVec<&\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mi32>) -> &\u001b[0m\u001b[0m\u001b[38;5;10m'a \u001b[0m\u001b[0mi32 {\u001b[0m\n+\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n+\n+\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 3 previous errors\u001b[0m\n+\n+\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0106`.\u001b[0m"}]}