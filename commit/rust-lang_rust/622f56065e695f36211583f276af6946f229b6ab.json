{"sha": "622f56065e695f36211583f276af6946f229b6ab", "node_id": "C_kwDOAAsO6NoAKDYyMmY1NjA2NWU2OTVmMzYyMTE1ODNmMjc2YWY2OTQ2ZjIyOWI2YWI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-15T21:02:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-15T21:02:58Z"}, "message": "Rollup merge of #105674 - estebank:iterator-chains, r=oli-obk\n\nPoint at method chains on `E0271` errors\n\nFollow up to #105332. Fix #33941. CC #9082.\n\nr? `@oli-obk`", "tree": {"sha": "b961517ef76318620a33f666b338b6ce5a6e2ab0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b961517ef76318620a33f666b338b6ce5a6e2ab0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/622f56065e695f36211583f276af6946f229b6ab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjm4uCCRBK7hj4Ov3rIwAAFbEIAGfPfbXqFlKlQOQQK8bJvcHE\n284q/s3Sg1gdNuH5f2AjclW7p1U/sl3wtXHd7rO2KuQbG3rCvoCy0jV3fSVGBWm4\nJX0JR72/muP6EmQ18SowVbKLSfh8aMw8nn7YLvREL05xHfg5T3AgMdui1lUKf2Gx\ndjvjvmhbMBch97PHw5J4ysUzNnsLsUVhEB1aROvRk4AAf4scvK41bO3NP0XLavdi\n3IDz5ytBRYz3RQn8/2RzSulgYMqKqwAAXUUMMlP6P1oe/LN6nYLEAnZTfdN0jlZe\nJxqDFN4yPu5Y+x+vZEX8rpYSPfphl726wz5aiTKnSvwB0ZBOWKXfzM2Anq3dln8=\n=CxkT\n-----END PGP SIGNATURE-----\n", "payload": "tree b961517ef76318620a33f666b338b6ce5a6e2ab0\nparent 863d1f653a450011a1b32282f7ecf78662bde53c\nparent 2492235c323e012ed49d93391754a59ce715ebc5\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1671138178 +0100\ncommitter GitHub <noreply@github.com> 1671138178 +0100\n\nRollup merge of #105674 - estebank:iterator-chains, r=oli-obk\n\nPoint at method chains on `E0271` errors\n\nFollow up to #105332. Fix #33941. CC #9082.\n\nr? `@oli-obk`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/622f56065e695f36211583f276af6946f229b6ab", "html_url": "https://github.com/rust-lang/rust/commit/622f56065e695f36211583f276af6946f229b6ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/622f56065e695f36211583f276af6946f229b6ab/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "863d1f653a450011a1b32282f7ecf78662bde53c", "url": "https://api.github.com/repos/rust-lang/rust/commits/863d1f653a450011a1b32282f7ecf78662bde53c", "html_url": "https://github.com/rust-lang/rust/commit/863d1f653a450011a1b32282f7ecf78662bde53c"}, {"sha": "2492235c323e012ed49d93391754a59ce715ebc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2492235c323e012ed49d93391754a59ce715ebc5", "html_url": "https://github.com/rust-lang/rust/commit/2492235c323e012ed49d93391754a59ce715ebc5"}], "stats": {"total": 470, "additions": 289, "deletions": 181}, "files": [{"sha": "9cd9480c7a1e1aae056ee2eaa8a35b607b5cbf7f", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKin\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n-use rustc_middle::ty::print::with_crate_prefix;\n+use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n use rustc_middle::ty::{self, DefIdTree, GenericArgKind, Ty, TyCtxt, TypeVisitable};\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -270,7 +270,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let tcx = self.tcx;\n \n                 let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n-                let ty_str = self.ty_to_string(rcvr_ty);\n+                let ty_str = with_forced_trimmed_paths!(self.ty_to_string(rcvr_ty));\n                 let is_method = mode == Mode::MethodCall;\n                 let item_kind = if is_method {\n                     \"method\"\n@@ -563,7 +563,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let term = pred.skip_binder().term;\n \n                                 let obligation = format!(\"{} = {}\", projection_ty, term);\n-                                let quiet = format!(\"{} = {}\", quiet_projection_ty, term);\n+                                let quiet = with_forced_trimmed_paths!(format!(\n+                                    \"{} = {}\",\n+                                    quiet_projection_ty, term\n+                                ));\n \n                                 bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n                                 Some((obligation, projection_ty.self_ty()))\n@@ -573,7 +576,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n                                 let obligation = format!(\"{}: {}\", self_ty, path);\n-                                let quiet = format!(\"_: {}\", path);\n+                                let quiet = with_forced_trimmed_paths!(format!(\"_: {}\", path));\n                                 bound_span_label(self_ty, &obligation, &quiet);\n                                 Some((obligation, self_ty))\n                             }\n@@ -796,7 +799,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 (None, None)\n                             };\n                         let primary_message = primary_message.unwrap_or_else(|| format!(\n-                            \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, but its trait bounds were not satisfied\"\n+                            \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, \\\n+                             but its trait bounds were not satisfied\"\n                         ));\n                         err.set_primary_message(&primary_message);\n                         if let Some(label) = label {"}, {"sha": "a1d53506707c9a2938749623d087c314bad761a6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -16,6 +16,7 @@ use rustc_session::config::TrimmedDefPaths;\n use rustc_session::cstore::{ExternCrate, ExternCrateSource};\n use rustc_session::Limit;\n use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::FileNameDisplayPreference;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n use smallvec::SmallVec;\n@@ -818,11 +819,16 @@ pub trait PrettyPrinter<'tcx>:\n                             p!(\"@\", print_def_path(did.to_def_id(), substs));\n                         } else {\n                             let span = self.tcx().def_span(did);\n+                            let preference = if FORCE_TRIMMED_PATH.with(|flag| flag.get()) {\n+                                FileNameDisplayPreference::Short\n+                            } else {\n+                                FileNameDisplayPreference::Remapped\n+                            };\n                             p!(write(\n                                 \"@{}\",\n                                 // This may end up in stderr diagnostics but it may also be emitted\n                                 // into MIR. Hence we use the remapped path if available\n-                                self.tcx().sess.source_map().span_to_embeddable_string(span)\n+                                self.tcx().sess.source_map().span_to_string(span, preference)\n                             ));\n                         }\n                     } else {"}, {"sha": "2181c090027b535819aec1eb8afeb1851c0f4841", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -259,6 +259,10 @@ impl RealFileName {\n             FileNameDisplayPreference::Remapped => {\n                 self.remapped_path_if_available().to_string_lossy()\n             }\n+            FileNameDisplayPreference::Short => self\n+                .local_path_if_available()\n+                .file_name()\n+                .map_or_else(|| \"\".into(), |f| f.to_string_lossy()),\n         }\n     }\n }\n@@ -302,6 +306,9 @@ pub enum FileNameDisplayPreference {\n     /// Display the path before the application of rewrite rules provided via `--remap-path-prefix`.\n     /// This is appropriate for use in user-facing output (such as diagnostics).\n     Local,\n+    /// Display only the filename, as a way to reduce the verbosity of the output.\n+    /// This is appropriate for use in user-facing output (such as diagnostics).\n+    Short,\n }\n \n pub struct FileNameDisplay<'a> {"}, {"sha": "d9c87ac0ba82bfb6ecb0c9b3991dc6dee752ea44", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -438,20 +438,27 @@ impl SourceMap {\n         }\n     }\n \n-    fn span_to_string(&self, sp: Span, filename_display_pref: FileNameDisplayPreference) -> String {\n+    pub fn span_to_string(\n+        &self,\n+        sp: Span,\n+        filename_display_pref: FileNameDisplayPreference,\n+    ) -> String {\n         if self.files.borrow().source_files.is_empty() || sp.is_dummy() {\n             return \"no-location\".to_string();\n         }\n \n         let lo = self.lookup_char_pos(sp.lo());\n         let hi = self.lookup_char_pos(sp.hi());\n         format!(\n-            \"{}:{}:{}: {}:{}\",\n+            \"{}:{}:{}{}\",\n             lo.file.name.display(filename_display_pref),\n             lo.line,\n             lo.col.to_usize() + 1,\n-            hi.line,\n-            hi.col.to_usize() + 1,\n+            if let FileNameDisplayPreference::Short = filename_display_pref {\n+                String::new()\n+            } else {\n+                format!(\": {}:{}\", hi.line, hi.col.to_usize() + 1)\n+            }\n         )\n     }\n "}, {"sha": "181316427609e58aa9cd6dddc96b1c459453a3b2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -35,7 +35,7 @@ use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n-use rustc_middle::ty::print::{FmtPrinter, Print};\n+use rustc_middle::ty::print::{with_forced_trimmed_paths, FmtPrinter, Print};\n use rustc_middle::ty::{\n     self, SubtypePredicate, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt, TypeFoldable,\n     TypeVisitable,\n@@ -1757,21 +1757,26 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         let trait_def_id = pred.projection_ty.trait_def_id(self.tcx);\n         let self_ty = pred.projection_ty.self_ty();\n \n-        if Some(pred.projection_ty.def_id) == self.tcx.lang_items().fn_once_output() {\n-            Some(format!(\n-                \"expected `{self_ty}` to be a {fn_kind} that returns `{expected_ty}`, but it returns `{normalized_ty}`\",\n-                fn_kind = self_ty.prefix_string(self.tcx)\n-            ))\n-        } else if Some(trait_def_id) == self.tcx.lang_items().future_trait() {\n-            Some(format!(\n-                \"expected `{self_ty}` to be a future that resolves to `{expected_ty}`, but it resolves to `{normalized_ty}`\"\n-            ))\n-        } else if Some(trait_def_id) == self.tcx.get_diagnostic_item(sym::Iterator) {\n-            Some(format!(\n-                \"expected `{self_ty}` to be an iterator that yields `{expected_ty}`, but it yields `{normalized_ty}`\"\n-            ))\n-        } else {\n-            None\n+        with_forced_trimmed_paths! {\n+            if Some(pred.projection_ty.def_id) == self.tcx.lang_items().fn_once_output() {\n+                Some(format!(\n+                    \"expected `{self_ty}` to be a {fn_kind} that returns `{expected_ty}`, but it \\\n+                     returns `{normalized_ty}`\",\n+                    fn_kind = self_ty.prefix_string(self.tcx)\n+                ))\n+            } else if Some(trait_def_id) == self.tcx.lang_items().future_trait() {\n+                Some(format!(\n+                    \"expected `{self_ty}` to be a future that resolves to `{expected_ty}`, but it \\\n+                     resolves to `{normalized_ty}`\"\n+                ))\n+            } else if Some(trait_def_id) == self.tcx.get_diagnostic_item(sym::Iterator) {\n+                Some(format!(\n+                    \"expected `{self_ty}` to be an iterator that yields `{expected_ty}`, but it \\\n+                     yields `{normalized_ty}`\"\n+                ))\n+            } else {\n+                None\n+            }\n         }\n     }\n "}, {"sha": "e77b9da08f51a7040c2df44069861afc815315f4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 120, "deletions": 90, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -352,6 +352,14 @@ pub trait TypeErrCtxtExt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         err: &mut Diagnostic,\n     );\n+    fn probe_assoc_types_at_expr(\n+        &self,\n+        type_diffs: &[TypeError<'tcx>],\n+        span: Span,\n+        prev_ty: Ty<'tcx>,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Vec<Option<(Span, (DefId, Ty<'tcx>))>>;\n }\n \n fn predicate_constraint(generics: &hir::Generics<'_>, pred: ty::Predicate<'_>) -> (Span, String) {\n@@ -3152,23 +3160,37 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = parent_code.deref()\n                 && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n                 && let Some(pred) = predicates.predicates.get(*idx)\n-                && let Ok(trait_pred) = pred.kind().try_map_bound(|pred| match pred {\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n-                    _ => Err(()),\n-                })\n             {\n-                let mut c = CollectAllMismatches {\n-                    infcx: self.infcx,\n-                    param_env,\n-                    errors: vec![],\n-                };\n-                if let Ok(trait_predicate) = predicate.kind().try_map_bound(|pred| match pred {\n+                if let Ok(trait_pred) = pred.kind().try_map_bound(|pred| match pred {\n                     ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n                     _ => Err(()),\n-                }) {\n+                })\n+                    && let Ok(trait_predicate) = predicate.kind().try_map_bound(|pred| match pred {\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n+                        _ => Err(()),\n+                    })\n+                {\n+                    let mut c = CollectAllMismatches {\n+                        infcx: self.infcx,\n+                        param_env,\n+                        errors: vec![],\n+                    };\n                     if let Ok(_) = c.relate(trait_pred, trait_predicate) {\n                         type_diffs = c.errors;\n                     }\n+                } else if let ty::PredicateKind::Clause(\n+                    ty::Clause::Projection(proj)\n+                ) = pred.kind().skip_binder()\n+                    && let ty::PredicateKind::Clause(\n+                        ty::Clause::Projection(projection)\n+                    ) = predicate.kind().skip_binder()\n+                {\n+                    type_diffs = vec![\n+                        Sorts(ty::error::ExpectedFound {\n+                            expected: self.tcx.mk_ty(ty::Alias(ty::Projection, proj.projection_ty)),\n+                            found: projection.term.ty().unwrap(),\n+                        }),\n+                    ];\n                 }\n             }\n             if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n@@ -3221,10 +3243,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         let tcx = self.tcx;\n \n+        let mut print_root_expr = true;\n         let mut assocs = vec![];\n-        // We still want to point at the different methods even if there hasn't\n-        // been a change of assoc type.\n-        let mut call_spans = vec![];\n         let mut expr = expr;\n         let mut prev_ty = self.resolve_vars_if_possible(\n             typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n@@ -3234,63 +3254,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n             //               ^^^^^^ ^^^^^^^^^^^\n             expr = rcvr_expr;\n-            let mut assocs_in_this_method = Vec::with_capacity(type_diffs.len());\n-            call_spans.push(span);\n-\n-            let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n-            for diff in &type_diffs {\n-                let Sorts(expected_found) = diff else { continue; };\n-                let ty::Alias(ty::Projection, proj) = expected_found.expected.kind() else { continue; };\n-\n-                let origin =\n-                    TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n-                let trait_def_id = proj.trait_def_id(self.tcx);\n-                // Make `Self` be equivalent to the type of the call chain\n-                // expression we're looking at now, so that we can tell what\n-                // for example `Iterator::Item` is at this point in the chain.\n-                let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n-                    match param.kind {\n-                        ty::GenericParamDefKind::Type { .. } => {\n-                            if param.index == 0 {\n-                                return prev_ty.into();\n-                            }\n-                        }\n-                        ty::GenericParamDefKind::Lifetime\n-                        | ty::GenericParamDefKind::Const { .. } => {}\n-                    }\n-                    self.var_for_def(span, param)\n-                });\n-                // This will hold the resolved type of the associated type, if the\n-                // current expression implements the trait that associated type is\n-                // in. For example, this would be what `Iterator::Item` is here.\n-                let ty_var = self.infcx.next_ty_var(origin);\n-                // This corresponds to `<ExprTy as Iterator>::Item = _`.\n-                let projection = ty::Binder::dummy(ty::PredicateKind::Clause(\n-                    ty::Clause::Projection(ty::ProjectionPredicate {\n-                        projection_ty: tcx.mk_alias_ty(proj.def_id, substs),\n-                        term: ty_var.into(),\n-                    }),\n-                ));\n-                // Add `<ExprTy as Iterator>::Item = _` obligation.\n-                ocx.register_obligation(Obligation::misc(\n-                    self.tcx,\n-                    span,\n-                    expr.hir_id,\n-                    param_env,\n-                    projection,\n-                ));\n-                if ocx.select_where_possible().is_empty() {\n-                    // `ty_var` now holds the type that `Item` is for `ExprTy`.\n-                    let ty_var = self.resolve_vars_if_possible(ty_var);\n-                    assocs_in_this_method.push(Some((span, (proj.def_id, ty_var))));\n-                } else {\n-                    // `<ExprTy as Iterator>` didn't select, so likely we've\n-                    // reached the end of the iterator chain, like the originating\n-                    // `Vec<_>`.\n-                    // Keep the space consistent for later zipping.\n-                    assocs_in_this_method.push(None);\n-                }\n-            }\n+            let assocs_in_this_method =\n+                self.probe_assoc_types_at_expr(&type_diffs, span, prev_ty, expr.hir_id, param_env);\n             assocs.push(assocs_in_this_method);\n             prev_ty = self.resolve_vars_if_possible(\n                 typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n@@ -3300,17 +3265,32 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n                 && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n                 && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n-                && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n-                && let Some(binding_expr) = local.init\n+                && let Some(parent) = self.tcx.hir().find(parent_hir_id)\n             {\n-                // We've reached the root of the method call chain and it is a\n-                // binding. Get the binding creation and try to continue the chain.\n-                expr = binding_expr;\n+                // We've reached the root of the method call chain...\n+                if let hir::Node::Local(local) = parent\n+                    && let Some(binding_expr) = local.init\n+                {\n+                    // ...and it is a binding. Get the binding creation and continue the chain.\n+                    expr = binding_expr;\n+                }\n+                if let hir::Node::Param(param) = parent {\n+                    // ...and it is a an fn argument.\n+                    let prev_ty = self.resolve_vars_if_possible(\n+                        typeck_results.node_type_opt(param.hir_id).unwrap_or(tcx.ty_error()),\n+                    );\n+                    let assocs_in_this_method = self.probe_assoc_types_at_expr(&type_diffs, param.ty_span, prev_ty, param.hir_id, param_env);\n+                    if assocs_in_this_method.iter().any(|a| a.is_some()) {\n+                        assocs.push(assocs_in_this_method);\n+                        print_root_expr = false;\n+                    }\n+                    break;\n+                }\n             }\n         }\n         // We want the type before deref coercions, otherwise we talk about `&[_]`\n         // instead of `Vec<_>`.\n-        if let Some(ty) = typeck_results.expr_ty_opt(expr) {\n+        if let Some(ty) = typeck_results.expr_ty_opt(expr) && print_root_expr {\n             let ty = with_forced_trimmed_paths!(self.ty_to_string(ty));\n             // Point at the root expression\n             // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n@@ -3324,7 +3304,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let Some(prev_assoc_in_method) = assocs.peek() else {\n                 for entry in assocs_in_method {\n                     let Some((span, (assoc, ty))) = entry else { continue; };\n-                    if type_diffs.iter().any(|diff| {\n+                    if primary_spans.is_empty() || type_diffs.iter().any(|diff| {\n                         let Sorts(expected_found) = diff else { return false; };\n                         self.can_eq(param_env, expected_found.found, ty).is_ok()\n                     }) {\n@@ -3353,7 +3333,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         let ty_str = with_forced_trimmed_paths!(self.ty_to_string(ty));\n \n                         let assoc = with_forced_trimmed_paths!(self.tcx.def_path_str(assoc));\n-                        if ty != *prev_ty {\n+                        if self.can_eq(param_env, ty, *prev_ty).is_err() {\n                             if type_diffs.iter().any(|diff| {\n                                 let Sorts(expected_found) = diff else { return false; };\n                                 self.can_eq(param_env, expected_found.found, ty).is_ok()\n@@ -3380,27 +3360,77 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n         }\n-        for span in call_spans {\n-            if span_labels.iter().find(|(s, _)| *s == span).is_none() {\n-                // Ensure we are showing the entire chain, even if the assoc types\n-                // haven't changed.\n-                span_labels.push((span, String::new()));\n-            }\n-        }\n         if !primary_spans.is_empty() {\n             let mut multi_span: MultiSpan = primary_spans.into();\n             for (span, label) in span_labels {\n                 multi_span.push_span_label(span, label);\n             }\n             err.span_note(\n                 multi_span,\n-                format!(\n-                    \"the method call chain might not have had the expected \\\n-                                     associated types\",\n-                ),\n+                format!(\"the method call chain might not have had the expected associated types\"),\n             );\n         }\n     }\n+\n+    fn probe_assoc_types_at_expr(\n+        &self,\n+        type_diffs: &[TypeError<'tcx>],\n+        span: Span,\n+        prev_ty: Ty<'tcx>,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Vec<Option<(Span, (DefId, Ty<'tcx>))>> {\n+        let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n+        let mut assocs_in_this_method = Vec::with_capacity(type_diffs.len());\n+        for diff in type_diffs {\n+            let Sorts(expected_found) = diff else { continue; };\n+            let ty::Alias(ty::Projection, proj) = expected_found.expected.kind() else { continue; };\n+\n+            let origin = TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n+            let trait_def_id = proj.trait_def_id(self.tcx);\n+            // Make `Self` be equivalent to the type of the call chain\n+            // expression we're looking at now, so that we can tell what\n+            // for example `Iterator::Item` is at this point in the chain.\n+            let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n+                match param.kind {\n+                    ty::GenericParamDefKind::Type { .. } => {\n+                        if param.index == 0 {\n+                            return prev_ty.into();\n+                        }\n+                    }\n+                    ty::GenericParamDefKind::Lifetime | ty::GenericParamDefKind::Const { .. } => {}\n+                }\n+                self.var_for_def(span, param)\n+            });\n+            // This will hold the resolved type of the associated type, if the\n+            // current expression implements the trait that associated type is\n+            // in. For example, this would be what `Iterator::Item` is here.\n+            let ty_var = self.infcx.next_ty_var(origin);\n+            // This corresponds to `<ExprTy as Iterator>::Item = _`.\n+            let projection = ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::Projection(\n+                ty::ProjectionPredicate {\n+                    projection_ty: self.tcx.mk_alias_ty(proj.def_id, substs),\n+                    term: ty_var.into(),\n+                },\n+            )));\n+            // Add `<ExprTy as Iterator>::Item = _` obligation.\n+            ocx.register_obligation(Obligation::misc(\n+                self.tcx, span, body_id, param_env, projection,\n+            ));\n+            if ocx.select_where_possible().is_empty() {\n+                // `ty_var` now holds the type that `Item` is for `ExprTy`.\n+                let ty_var = self.resolve_vars_if_possible(ty_var);\n+                assocs_in_this_method.push(Some((span, (proj.def_id, ty_var))));\n+            } else {\n+                // `<ExprTy as Iterator>` didn't select, so likely we've\n+                // reached the end of the iterator chain, like the originating\n+                // `Vec<_>`.\n+                // Keep the space consistent for later zipping.\n+                assocs_in_this_method.push(None);\n+            }\n+        }\n+        assocs_in_this_method\n+    }\n }\n \n /// Add a hint to add a missing borrow or remove an unnecessary one."}, {"sha": "fed60ccf089d05c85288a7ef3774506f7d2dbd96", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -4,5 +4,5 @@ trait I32Iterator = Iterator<Item = i32>;\n \n fn main() {\n     let _: &dyn I32Iterator<Item = u32> = &vec![42].into_iter();\n-    //~^ ERROR expected `std::vec::IntoIter<u32>` to be an iterator that yields `i32`, but it yields `u32`\n+    //~^ ERROR expected `IntoIter<u32>` to be an iterator that yields `i32`, but it yields `u32`\n }"}, {"sha": "a28a0b74e4accd98c47bbf6f001d9562560f4ff8", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: expected `std::vec::IntoIter<u32>` to be an iterator that yields `i32`, but it yields `u32`\n+error[E0271]: expected `IntoIter<u32>` to be an iterator that yields `i32`, but it yields `u32`\n   --> $DIR/associated-types-overridden-binding-2.rs:6:43\n    |\n LL |     let _: &dyn I32Iterator<Item = u32> = &vec![42].into_iter();"}, {"sha": "3906d64c9462453682f8edf42d47332c5619b14f", "filename": "src/test/ui/confuse-field-and-method/issue-33784.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-33784.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-33784.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-33784.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: no method named `closure` found for reference `&Obj<[closure@$DIR/issue-33784.rs:25:43: 25:45]>` in the current scope\n+error[E0599]: no method named `closure` found for reference `&Obj<[closure@issue-33784.rs:25:43]>` in the current scope\n   --> $DIR/issue-33784.rs:27:7\n    |\n LL |     p.closure();\n@@ -9,7 +9,7 @@ help: to call the function stored in `closure`, surround the field access with p\n LL |     (p.closure)();\n    |     +         +\n \n-error[E0599]: no method named `fn_ptr` found for reference `&&Obj<[closure@$DIR/issue-33784.rs:25:43: 25:45]>` in the current scope\n+error[E0599]: no method named `fn_ptr` found for reference `&&Obj<[closure@issue-33784.rs:25:43]>` in the current scope\n   --> $DIR/issue-33784.rs:29:7\n    |\n LL |     q.fn_ptr();"}, {"sha": "0e580aedeaa921e7fd548624dc075a660864600d", "filename": "src/test/ui/empty/empty-struct-braces-expr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -100,22 +100,22 @@ help: a unit struct with a similar name exists\n LL |     let xe1 = XEmpty2();\n    |               ~~~~~~~\n \n-error[E0599]: no variant or associated item named `Empty3` found for enum `empty_struct::XE` in the current scope\n+error[E0599]: no variant or associated item named `Empty3` found for enum `XE` in the current scope\n   --> $DIR/empty-struct-braces-expr.rs:25:19\n    |\n LL |     let xe3 = XE::Empty3;\n    |                   ^^^^^^\n    |                   |\n-   |                   variant or associated item not found in `empty_struct::XE`\n+   |                   variant or associated item not found in `XE`\n    |                   help: there is a variant with a similar name: `XEmpty3`\n \n-error[E0599]: no variant or associated item named `Empty3` found for enum `empty_struct::XE` in the current scope\n+error[E0599]: no variant or associated item named `Empty3` found for enum `XE` in the current scope\n   --> $DIR/empty-struct-braces-expr.rs:26:19\n    |\n LL |     let xe3 = XE::Empty3();\n    |                   ^^^^^^\n    |                   |\n-   |                   variant or associated item not found in `empty_struct::XE`\n+   |                   variant or associated item not found in `XE`\n    |                   help: there is a variant with a similar name: `XEmpty3`\n \n error[E0599]: no variant named `Empty1` found for enum `empty_struct::XE`"}, {"sha": "463ac7684ecdfea3a73122953e24915249278b66", "filename": "src/test/ui/functions-closures/fn-help-with-err.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -17,11 +17,11 @@ note: `Bar` defines an item `bar`, perhaps you need to implement it\n LL | trait Bar {\n    | ^^^^^^^^^\n \n-error[E0599]: no method named `bar` found for struct `Arc<[closure@$DIR/fn-help-with-err.rs:22:36: 22:38]>` in the current scope\n+error[E0599]: no method named `bar` found for struct `Arc<[closure@fn-help-with-err.rs:22:36]>` in the current scope\n   --> $DIR/fn-help-with-err.rs:23:10\n    |\n LL |     arc2.bar();\n-   |          ^^^ method not found in `Arc<[closure@$DIR/fn-help-with-err.rs:22:36: 22:38]>`\n+   |          ^^^ method not found in `Arc<[closure@fn-help-with-err.rs:22:36]>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `Bar` defines an item `bar`, perhaps you need to implement it"}, {"sha": "0458d2535f2f56ad83eac2b0d3be6ceaaf28c22b", "filename": "src/test/ui/higher-rank-trait-bounds/issue-30786.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-30786.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-30786.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-30786.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: the method `filterx` exists for struct `Map<Repeat, [closure@$DIR/issue-30786.rs:117:27: 117:34]>`, but its trait bounds were not satisfied\n+error[E0599]: the method `filterx` exists for struct `Map<Repeat, [closure@issue-30786.rs:117:27]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:118:22\n    |\n LL | pub struct Map<S, F> {\n@@ -8,7 +8,7 @@ LL | pub struct Map<S, F> {\n    | doesn't satisfy `_: StreamExt`\n ...\n LL |     let filter = map.filterx(|x: &_| true);\n-   |                      ^^^^^^^ method cannot be called due to unsatisfied trait bounds\n+   |                      ^^^^^^^ method cannot be called on `Map<Repeat, [closure@issue-30786.rs:117:27]>` due to unsatisfied trait bounds\n    |\n note: the following trait bounds were not satisfied:\n       `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:117:27: 117:34]>: Stream`\n@@ -19,7 +19,7 @@ note: the following trait bounds were not satisfied:\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n    |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n \n-error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'a> fn(&'a u64) -> &'a u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:129:30: 129:37]>`, but its trait bounds were not satisfied\n+error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'a> fn(&'a u64) -> &'a u64 {identity::<u64>}>, [closure@issue-30786.rs:129:30]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:130:24\n    |\n LL | pub struct Filter<S, F> {"}, {"sha": "fdd192f43137067a274ebe008c03d2641a9fad0b", "filename": "src/test/ui/higher-rank-trait-bounds/issue-62203-hrtb-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -30,7 +30,7 @@ LL |     where\n LL |         F: for<'r> T0<'r, (<Self as Ty<'r>>::V,), O = <B as Ty<'r>>::V>,\n    |                                                   ^^^^^^^^^^^^^^^^^^^^ required by this bound in `T1::m`\n \n-error[E0271]: expected `[closure@$DIR/issue-62203-hrtb-ice.rs:42:16: 42:19]` to be a closure that returns `Unit3`, but it returns `Unit4`\n+error[E0271]: expected `[closure@issue-62203-hrtb-ice.rs:42:16]` to be a closure that returns `Unit3`, but it returns `Unit4`\n   --> $DIR/issue-62203-hrtb-ice.rs:39:9\n    |\n LL |       let v = Unit2.m("}, {"sha": "548c89d0a3871372e87270fd08b5ad3b2e1421a4", "filename": "src/test/ui/impl-trait/no-method-suggested-traits.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -145,11 +145,11 @@ note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n LL |     pub trait Bar {\n    |     ^^^^^^^^^^^^^\n \n-error[E0599]: no method named `method2` found for struct `no_method_suggested_traits::Foo` in the current scope\n+error[E0599]: no method named `method2` found for struct `Foo` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:50:37\n    |\n LL |     no_method_suggested_traits::Foo.method2();\n-   |                                     ^^^^^^^ method not found in `no_method_suggested_traits::Foo`\n+   |                                     ^^^^^^^ method not found in `Foo`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n@@ -158,11 +158,11 @@ note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n LL |     pub trait Bar {\n    |     ^^^^^^^^^^^^^\n \n-error[E0599]: no method named `method2` found for struct `Rc<&mut Box<&no_method_suggested_traits::Foo>>` in the current scope\n+error[E0599]: no method named `method2` found for struct `Rc<&mut Box<&Foo>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:52:71\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Foo)).method2();\n-   |                                                                       ^^^^^^^ method not found in `Rc<&mut Box<&no_method_suggested_traits::Foo>>`\n+   |                                                                       ^^^^^^^ method not found in `Rc<&mut Box<&Foo>>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n@@ -171,11 +171,11 @@ note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n LL |     pub trait Bar {\n    |     ^^^^^^^^^^^^^\n \n-error[E0599]: no method named `method2` found for enum `no_method_suggested_traits::Bar` in the current scope\n+error[E0599]: no method named `method2` found for enum `Bar` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:54:40\n    |\n LL |     no_method_suggested_traits::Bar::X.method2();\n-   |                                        ^^^^^^^ method not found in `no_method_suggested_traits::Bar`\n+   |                                        ^^^^^^^ method not found in `Bar`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n@@ -184,11 +184,11 @@ note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n LL |     pub trait Bar {\n    |     ^^^^^^^^^^^^^\n \n-error[E0599]: no method named `method2` found for struct `Rc<&mut Box<&no_method_suggested_traits::Bar>>` in the current scope\n+error[E0599]: no method named `method2` found for struct `Rc<&mut Box<&Bar>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:56:74\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Bar::X)).method2();\n-   |                                                                          ^^^^^^^ method not found in `Rc<&mut Box<&no_method_suggested_traits::Bar>>`\n+   |                                                                          ^^^^^^^ method not found in `Rc<&mut Box<&Bar>>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `foo::Bar` defines an item `method2`, perhaps you need to implement it\n@@ -255,29 +255,29 @@ error[E0599]: no method named `method3` found for struct `Rc<&mut Box<&usize>>`\n LL |     std::rc::Rc::new(&mut Box::new(&1_usize)).method3();\n    |                                               ^^^^^^^ method not found in `Rc<&mut Box<&usize>>`\n \n-error[E0599]: no method named `method3` found for struct `no_method_suggested_traits::Foo` in the current scope\n+error[E0599]: no method named `method3` found for struct `Foo` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:71:37\n    |\n LL |     no_method_suggested_traits::Foo.method3();\n-   |                                     ^^^^^^^ method not found in `no_method_suggested_traits::Foo`\n+   |                                     ^^^^^^^ method not found in `Foo`\n \n-error[E0599]: no method named `method3` found for struct `Rc<&mut Box<&no_method_suggested_traits::Foo>>` in the current scope\n+error[E0599]: no method named `method3` found for struct `Rc<&mut Box<&Foo>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:72:71\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Foo)).method3();\n-   |                                                                       ^^^^^^^ method not found in `Rc<&mut Box<&no_method_suggested_traits::Foo>>`\n+   |                                                                       ^^^^^^^ method not found in `Rc<&mut Box<&Foo>>`\n \n-error[E0599]: no method named `method3` found for enum `no_method_suggested_traits::Bar` in the current scope\n+error[E0599]: no method named `method3` found for enum `Bar` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:74:40\n    |\n LL |     no_method_suggested_traits::Bar::X.method3();\n-   |                                        ^^^^^^^ method not found in `no_method_suggested_traits::Bar`\n+   |                                        ^^^^^^^ method not found in `Bar`\n \n-error[E0599]: no method named `method3` found for struct `Rc<&mut Box<&no_method_suggested_traits::Bar>>` in the current scope\n+error[E0599]: no method named `method3` found for struct `Rc<&mut Box<&Bar>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:75:74\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Bar::X)).method3();\n-   |                                                                          ^^^^^^^ method not found in `Rc<&mut Box<&no_method_suggested_traits::Bar>>`\n+   |                                                                          ^^^^^^^ method not found in `Rc<&mut Box<&Bar>>`\n \n error: aborting due to 24 previous errors\n "}, {"sha": "7808cbf8aa10840644bb7e85e8c9a81045adb8fc", "filename": "src/test/ui/issues/issue-30123.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,8 +1,8 @@\n-error[E0599]: no function or associated item named `new_undirected` found for struct `issue_30123_aux::Graph<i32, i32>` in the current scope\n+error[E0599]: no function or associated item named `new_undirected` found for struct `Graph<i32, i32>` in the current scope\n   --> $DIR/issue-30123.rs:7:33\n    |\n LL |     let ug = Graph::<i32, i32>::new_undirected();\n-   |                                 ^^^^^^^^^^^^^^ function or associated item not found in `issue_30123_aux::Graph<i32, i32>`\n+   |                                 ^^^^^^^^^^^^^^ function or associated item not found in `Graph<i32, i32>`\n    |\n    = note: the function or associated item was found for\n            - `issue_30123_aux::Graph<N, E, Undirected>`"}, {"sha": "f3be99f9bcb4b3e09efcd9029b355d188c5ba5ec", "filename": "src/test/ui/issues/issue-31173.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,15 +1,27 @@\n-error[E0271]: expected `TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>` to be an iterator that yields `&_`, but it yields `u8`\n+error[E0271]: expected `TakeWhile<&mut IntoIter<u8>, [closure@issue-31173.rs:7:21]>` to be an iterator that yields `&_`, but it yields `u8`\n   --> $DIR/issue-31173.rs:11:10\n    |\n LL |         .cloned()\n    |          ^^^^^^ expected reference, found `u8`\n    |\n    = note: expected reference `&_`\n                    found type `u8`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-31173.rs:3:20\n+   |\n+LL |   pub fn get_tok(it: &mut IntoIter<u8>) {\n+   |                      ^^^^^^^^^^^^^^^^^ `Iterator::Item` is `u8` here\n+...\n+LL |           .take_while(|&x| {\n+   |  __________-\n+LL | |             found_e = true;\n+LL | |             false\n+LL | |         })\n+   | |__________- `Iterator::Item` remains `u8` here\n note: required by a bound in `cloned`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n-error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>`, but its trait bounds were not satisfied\n+error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut IntoIter<u8>, [closure@issue-31173.rs:7:21]>>`, but its trait bounds were not satisfied\n   --> $DIR/issue-31173.rs:12:10\n    |\n LL |         .collect();"}, {"sha": "e3b6dcf55a7448296ea39c39de2c428b40e59ff2", "filename": "src/test/ui/issues/issue-33941.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -3,7 +3,7 @@\n use std::collections::HashMap;\n \n fn main() {\n-    for _ in HashMap::new().iter().cloned() {} //~ ERROR expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n-    //~^ ERROR expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n-    //~| ERROR expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+    for _ in HashMap::new().iter().cloned() {} //~ ERROR expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+    //~^ ERROR expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+    //~| ERROR expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n }"}, {"sha": "668eaabca4c463d450fbe59ed71e04280dd0c1e4", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,15 +1,22 @@\n-error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+error[E0271]: expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n   --> $DIR/issue-33941.rs:6:36\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}\n    |                                    ^^^^^^ expected reference, found tuple\n    |\n    = note: expected reference `&_`\n                   found tuple `(&_, &_)`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-33941.rs:6:29\n+   |\n+LL |     for _ in HashMap::new().iter().cloned() {}\n+   |              -------------- ^^^^^^ `Iterator::Item` is `(&_, &_)` here\n+   |              |\n+   |              this expression has type `HashMap<_, _>`\n note: required by a bound in `cloned`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n-error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+error[E0271]: expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n   --> $DIR/issue-33941.rs:6:14\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}\n@@ -20,7 +27,7 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n    = note: required for `Cloned<std::collections::hash_map::Iter<'_, _, _>>` to implement `Iterator`\n    = note: required for `Cloned<std::collections::hash_map::Iter<'_, _, _>>` to implement `IntoIterator`\n \n-error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+error[E0271]: expected `Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n   --> $DIR/issue-33941.rs:6:14\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}"}, {"sha": "00c375f8d2acfaad1da084e0f1b1e5a43c87b9e3", "filename": "src/test/ui/issues/issue-41880.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fissues%2Fissue-41880.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fissues%2Fissue-41880.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41880.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -5,7 +5,7 @@ LL | pub struct Iterate<T, F> {\n    | ------------------------ method `iter` not found for this struct\n ...\n LL |     println!(\"{:?}\", a.iter().take(10).collect::<Vec<usize>>());\n-   |                        ^^^^ method not found in `Iterate<{integer}, [closure@$DIR/issue-41880.rs:26:24: 26:27]>`\n+   |                        ^^^^ method not found in `Iterate<{integer}, [closure@issue-41880.rs:26:24]>`\n \n error: aborting due to previous error\n "}, {"sha": "ebdf33303c982b311d80fb1b066cf82b52cc6946", "filename": "src/test/ui/iterators/invalid-iterator-chain.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,3 +1,11 @@\n+use std::collections::hash_set::Iter;\n+use std::collections::HashSet;\n+\n+fn iter_to_vec<'b, X>(i: Iter<'b, X>) -> Vec<X> {\n+    let i = i.map(|x| x.clone());\n+    i.collect() //~ ERROR E0277\n+}\n+\n fn main() {\n     let scores = vec![(0, 0)]\n         .iter()\n@@ -38,4 +46,8 @@ fn main() {\n     });\n     let f = e.filter(|_| false);\n     let g: Vec<i32> = f.collect(); //~ ERROR E0277\n+\n+    let mut s = HashSet::new();\n+    s.insert(1u8);\n+    println!(\"{:?}\", iter_to_vec(s.iter()));\n }"}, {"sha": "d76a4bfb7b3ea886c68b8e90b2593fb4e7c477ea", "filename": "src/test/ui/iterators/invalid-iterator-chain.stderr", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,5 +1,23 @@\n+error[E0277]: a value of type `Vec<X>` cannot be built from an iterator over elements of type `&X`\n+  --> $DIR/invalid-iterator-chain.rs:6:7\n+   |\n+LL |     i.collect()\n+   |       ^^^^^^^ value of type `Vec<X>` cannot be built from `std::iter::Iterator<Item=&X>`\n+   |\n+   = help: the trait `FromIterator<&X>` is not implemented for `Vec<X>`\n+   = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:4:26\n+   |\n+LL | fn iter_to_vec<'b, X>(i: Iter<'b, X>) -> Vec<X> {\n+   |                          ^^^^^^^^^^^ `Iterator::Item` is `&X` here\n+LL |     let i = i.map(|x| x.clone());\n+   |               ------------------ `Iterator::Item` remains `&X` here\n+note: required by a bound in `collect`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+\n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n-  --> $DIR/invalid-iterator-chain.rs:7:27\n+  --> $DIR/invalid-iterator-chain.rs:15:27\n    |\n LL |     println!(\"{}\", scores.sum::<i32>());\n    |                           ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n@@ -9,7 +27,7 @@ LL |     println!(\"{}\", scores.sum::<i32>());\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:4:10\n+  --> $DIR/invalid-iterator-chain.rs:12:10\n    |\n LL |       let scores = vec![(0, 0)]\n    |                    ------------ this expression has type `Vec<({integer}, {integer})>`\n@@ -24,7 +42,7 @@ note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n-  --> $DIR/invalid-iterator-chain.rs:18:14\n+  --> $DIR/invalid-iterator-chain.rs:26:14\n    |\n LL |             .sum::<i32>(),\n    |              ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n@@ -34,7 +52,7 @@ LL |             .sum::<i32>(),\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:12:14\n+  --> $DIR/invalid-iterator-chain.rs:20:14\n    |\n LL |         vec![0, 1]\n    |         ---------- this expression has type `Vec<{integer}>`\n@@ -56,7 +74,7 @@ note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `f64`\n-  --> $DIR/invalid-iterator-chain.rs:28:14\n+  --> $DIR/invalid-iterator-chain.rs:36:14\n    |\n LL |             .sum::<i32>(),\n    |              ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=f64>`\n@@ -66,7 +84,7 @@ LL |             .sum::<i32>(),\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:24:14\n+  --> $DIR/invalid-iterator-chain.rs:32:14\n    |\n LL |         vec![0, 1]\n    |         ---------- this expression has type `Vec<{integer}>`\n@@ -84,7 +102,7 @@ note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n-  --> $DIR/invalid-iterator-chain.rs:30:54\n+  --> $DIR/invalid-iterator-chain.rs:38:54\n    |\n LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n    |                                                      ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n@@ -94,7 +112,7 @@ LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:30:38\n+  --> $DIR/invalid-iterator-chain.rs:38:38\n    |\n LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n    |                    ---------- ------ ^^^^^^^^^^^^^^^ `Iterator::Item` changed to `()` here\n@@ -105,7 +123,7 @@ note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `&()`\n-  --> $DIR/invalid-iterator-chain.rs:31:40\n+  --> $DIR/invalid-iterator-chain.rs:39:40\n    |\n LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n    |                                        ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=&()>`\n@@ -115,7 +133,7 @@ LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:31:33\n+  --> $DIR/invalid-iterator-chain.rs:39:33\n    |\n LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n    |                    ------------ ^^^^^^ `Iterator::Item` is `&()` here\n@@ -125,15 +143,15 @@ note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n error[E0277]: a value of type `Vec<i32>` cannot be built from an iterator over elements of type `()`\n-  --> $DIR/invalid-iterator-chain.rs:40:25\n+  --> $DIR/invalid-iterator-chain.rs:48:25\n    |\n LL |     let g: Vec<i32> = f.collect();\n    |                         ^^^^^^^ value of type `Vec<i32>` cannot be built from `std::iter::Iterator<Item=()>`\n    |\n    = help: the trait `FromIterator<()>` is not implemented for `Vec<i32>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:36:15\n+  --> $DIR/invalid-iterator-chain.rs:44:15\n    |\n LL |       let a = vec![0];\n    |               ------- this expression has type `Vec<{integer}>`\n@@ -153,6 +171,6 @@ LL |       let f = e.filter(|_| false);\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "8846efba871b9cd1f845b86b58dfbaa5a0880d1b", "filename": "src/test/ui/methods/method-not-found-generic-arg-elision.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -23,7 +23,7 @@ error[E0599]: no method named `extend` found for struct `Map` in the current sco\n   --> $DIR/method-not-found-generic-arg-elision.rs:87:29\n    |\n LL |     v.iter().map(|x| x * x).extend(std::iter::once(100));\n-   |                             ^^^^^^ method not found in `Map<std::slice::Iter<'_, i32>, [closure@$DIR/method-not-found-generic-arg-elision.rs:87:18: 87:21]>`\n+   |                             ^^^^^^ method not found in `Map<Iter<'_, i32>, [closure@method-not-found-generic-arg-elision.rs:87:18]>`\n \n error[E0599]: no method named `method` found for struct `Wrapper<bool>` in the current scope\n   --> $DIR/method-not-found-generic-arg-elision.rs:90:13"}, {"sha": "72fb0e4d774312780cb81e6e5f8fc1617f0d8113", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -13,7 +13,7 @@ LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n note: required by a bound in `filter`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n \n-error[E0599]: the method `count` exists for struct `Filter<Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:7:39: 7:48]>`, but its trait bounds were not satisfied\n+error[E0599]: the method `count` exists for struct `Filter<Fuse<Once<&str>>, [closure@issue-36053-2.rs:7:39]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-36053-2.rs:7:55\n    |\n LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();"}, {"sha": "a0f790dba15ed21adddebbcb5daf9faa8cd909ef", "filename": "src/test/ui/never_type/fallback-closure-wrap.fallback.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: expected `[closure@$DIR/fallback-closure-wrap.rs:18:40: 18:47]` to be a closure that returns `()`, but it returns `!`\n+error[E0271]: expected `[closure@fallback-closure-wrap.rs:18:40]` to be a closure that returns `()`, but it returns `!`\n   --> $DIR/fallback-closure-wrap.rs:18:31\n    |\n LL |       let error = Closure::wrap(Box::new(move || {"}, {"sha": "6910b77d9bc3fa1874c69f464fba0e1b1444ef3b", "filename": "src/test/ui/suggestions/mut-borrow-needed-by-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -20,11 +20,11 @@ LL |     let fp = BufWriter::new(fp);\n note: required by a bound in `BufWriter`\n   --> $SRC_DIR/std/src/io/buffered/bufwriter.rs:LL:COL\n \n-error[E0599]: the method `write_fmt` exists for struct `BufWriter<&dyn std::io::Write>`, but its trait bounds were not satisfied\n+error[E0599]: the method `write_fmt` exists for struct `BufWriter<&dyn Write>`, but its trait bounds were not satisfied\n   --> $DIR/mut-borrow-needed-by-trait.rs:21:5\n    |\n LL |     writeln!(fp, \"hello world\").unwrap();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method cannot be called on `BufWriter<&dyn std::io::Write>` due to unsatisfied trait bounds\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method cannot be called on `BufWriter<&dyn Write>` due to unsatisfied trait bounds\n   --> $SRC_DIR/std/src/io/buffered/bufwriter.rs:LL:COL\n    |\n    = note: doesn't satisfy `BufWriter<&dyn std::io::Write>: std::io::Write`"}, {"sha": "65340b2a2092ff5cdf345a4c08703603d70c0ee1", "filename": "src/test/ui/traits/assoc-type-in-superbad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.rs?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -10,7 +10,7 @@ pub trait Foo: Iterator<Item = <Self as Foo>::Key> {\n \n impl Foo for IntoIter<i32> {\n     type Key = u32;\n-    //~^ ERROR expected `std::vec::IntoIter<i32>` to be an iterator that yields `u32`, but it yields `i32`\n+    //~^ ERROR expected `IntoIter<i32>` to be an iterator that yields `u32`, but it yields `i32`\n }\n \n fn main() {}"}, {"sha": "7fa1d2c2eed67c8fd85f48d77f1aa019a3d36fb7", "filename": "src/test/ui/traits/assoc-type-in-superbad.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: expected `std::vec::IntoIter<i32>` to be an iterator that yields `u32`, but it yields `i32`\n+error[E0271]: expected `IntoIter<i32>` to be an iterator that yields `u32`, but it yields `i32`\n   --> $DIR/assoc-type-in-superbad.rs:12:16\n    |\n LL |     type Key = u32;"}, {"sha": "4aa5966ff25d4cedac7d9db5a84b39087a0ef0f9", "filename": "src/test/ui/type-alias-impl-trait/issue-57961.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -8,7 +8,7 @@ trait Foo {\n \n impl Foo for () {\n     type Bar = std::vec::IntoIter<u32>;\n-    //~^ ERROR expected `std::vec::IntoIter<u32>` to be an iterator that yields `X`, but it yields `u32`\n+    //~^ ERROR expected `IntoIter<u32>` to be an iterator that yields `X`, but it yields `u32`\n }\n \n fn incoherent() {"}, {"sha": "8d11b48888947d91bce4b7039892a34a8cc72b15", "filename": "src/test/ui/type-alias-impl-trait/issue-57961.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: expected `std::vec::IntoIter<u32>` to be an iterator that yields `X`, but it yields `u32`\n+error[E0271]: expected `IntoIter<u32>` to be an iterator that yields `X`, but it yields `u32`\n   --> $DIR/issue-57961.rs:10:16\n    |\n LL | type X = impl Sized;"}, {"sha": "99ec5178340030d15ca4cac950f747182a9e36cc", "filename": "src/test/ui/unboxed-closures/unboxed-closures-static-call-wrong-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/622f56065e695f36211583f276af6946f229b6ab/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr?ref=622f56065e695f36211583f276af6946f229b6ab", "patch": "@@ -1,8 +1,8 @@\n-error[E0599]: no method named `call` found for closure `[closure@$DIR/unboxed-closures-static-call-wrong-trait.rs:6:26: 6:29]` in the current scope\n+error[E0599]: no method named `call` found for closure `[closure@unboxed-closures-static-call-wrong-trait.rs:6:26]` in the current scope\n   --> $DIR/unboxed-closures-static-call-wrong-trait.rs:7:10\n    |\n LL |     mut_.call((0, ));\n-   |          ^^^^ method not found in `[closure@$DIR/unboxed-closures-static-call-wrong-trait.rs:6:26: 6:29]`\n+   |          ^^^^ method not found in `[closure@unboxed-closures-static-call-wrong-trait.rs:6:26]`\n \n error: aborting due to previous error\n "}]}