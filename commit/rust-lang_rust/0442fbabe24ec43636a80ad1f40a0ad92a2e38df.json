{"sha": "0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "node_id": "C_kwDOAAsO6NoAKDA0NDJmYmFiZTI0ZWM0MzYzNmE4MGFkMWY0MGEwYWQ5MmEyZTM4ZGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-10T06:22:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-10T06:22:01Z"}, "message": "Auto merge of #106607 - compiler-errors:be-more-accurate-abt-method-suggestions, r=oli-obk\n\nConsider return type when giving various method suggestions\n\n1. Fix a bug in method probe where we weren't normalizing `xform_ret_ty` for non-`impl` method candidates. This shouldn't affect happy-path code, since we only use `xform_ret_ty` when probing methods for diagnostics (I think).\n2. Pass the return type expectation down to `lookup_probe`/`probe_for_name` usages in diagnostics. Added a few UI tests to gate against bad suggestions.\n3. Make a `FnCtxt::lookup_probe_for_diagnostic` which properly passes down `IsSuggestion(true)`. Should help suppress other weird notes in some corner cases.", "tree": {"sha": "a494ceba9b45768bd74fce08dfaceccf3bd0c902", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a494ceba9b45768bd74fce08dfaceccf3bd0c902"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "html_url": "https://github.com/rust-lang/rust/commit/0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "deba5ddd0776108c51a69844d0ffe3f96886dd52", "url": "https://api.github.com/repos/rust-lang/rust/commits/deba5ddd0776108c51a69844d0ffe3f96886dd52", "html_url": "https://github.com/rust-lang/rust/commit/deba5ddd0776108c51a69844d0ffe3f96886dd52"}, {"sha": "4f15034b55f6c9e134f7644c4571faa5ddb5facb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f15034b55f6c9e134f7644c4571faa5ddb5facb", "html_url": "https://github.com/rust-lang/rust/commit/4f15034b55f6c9e134f7644c4571faa5ddb5facb"}], "stats": {"total": 436, "additions": 329, "deletions": 107}, "files": [{"sha": "3b664363d232f6d74908d26578fb2fb274636d8e", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -1,4 +1,4 @@\n-use super::method::probe::{IsSuggestion, Mode, ProbeScope};\n+use super::method::probe::ProbeScope;\n use super::method::MethodCallee;\n use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n \n@@ -496,15 +496,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // any strange errors. If it's successful, then we'll do a true\n             // method lookup.\n             let Ok(pick) = self\n-            .probe_for_name(\n-                Mode::MethodCall,\n+            .lookup_probe_for_diagnostic(\n                 segment.ident,\n-                IsSuggestion(true),\n                 callee_ty,\n-                call_expr.hir_id,\n+                call_expr,\n                 // We didn't record the in scope traits during late resolution\n                 // so we need to probe AllTraits unfortunately\n                 ProbeScope::AllTraits,\n+                expected.only_has_type(self),\n             ) else {\n                 return None;\n             };"}, {"sha": "33fc7413a679cd2eadc94cb313fe46cd0db3a025", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -303,11 +303,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Get the evaluated type *after* calling the method call, so that the influence\n                 // of the arguments can be reflected in the receiver type. The receiver\n                 // expression has the type *before* theis analysis is done.\n-                let ty = match self.lookup_probe(\n+                let ty = match self.lookup_probe_for_diagnostic(\n                     segment.ident,\n                     rcvr_ty,\n                     expr,\n                     probe::ProbeScope::TraitsInScope,\n+                    None,\n                 ) {\n                     Ok(pick) => pick.self_ty,\n                     Err(_) => rcvr_ty,\n@@ -557,19 +558,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let Some(self_ty) = self.typeck_results.borrow().expr_ty_adjusted_opt(base) else { return; };\n \n         let Ok(pick) = self\n-            .probe_for_name(\n-                probe::Mode::MethodCall,\n+            .lookup_probe_for_diagnostic(\n                 path.ident,\n-                probe::IsSuggestion(true),\n                 self_ty,\n-                deref.hir_id,\n+                deref,\n                 probe::ProbeScope::TraitsInScope,\n+                None,\n             ) else {\n                 return;\n             };\n         let in_scope_methods = self.probe_for_name_many(\n             probe::Mode::MethodCall,\n             path.ident,\n+            Some(expected),\n             probe::IsSuggestion(true),\n             self_ty,\n             deref.hir_id,\n@@ -581,6 +582,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let all_methods = self.probe_for_name_many(\n             probe::Mode::MethodCall,\n             path.ident,\n+            Some(expected),\n             probe::IsSuggestion(true),\n             self_ty,\n             deref.hir_id,\n@@ -1832,7 +1834,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_for_range_as_method_call(\n         &self,\n         err: &mut Diagnostic,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) {\n@@ -1850,10 +1852,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n         let mut expr = end.expr;\n+        let mut expectation = Some(expected_ty);\n         while let hir::ExprKind::MethodCall(_, rcvr, ..) = expr.kind {\n             // Getting to the root receiver and asserting it is a fn call let's us ignore cases in\n             // `src/test/ui/methods/issues/issue-90315.stderr`.\n             expr = rcvr;\n+            // If we have more than one layer of calls, then the expected ty\n+            // cannot guide the method probe.\n+            expectation = None;\n         }\n         let hir::ExprKind::Call(method_name, _) = expr.kind else { return; };\n         let ty::Adt(adt, _) = checked_ty.kind() else { return; };\n@@ -1869,13 +1875,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = method_name.kind else { return; };\n         let [hir::PathSegment { ident, .. }] = p.segments else { return; };\n         let self_ty = self.typeck_results.borrow().expr_ty(start.expr);\n-        let Ok(_pick) = self.probe_for_name(\n-            probe::Mode::MethodCall,\n+        let Ok(_pick) = self.lookup_probe_for_diagnostic(\n             *ident,\n-            probe::IsSuggestion(true),\n             self_ty,\n-            expr.hir_id,\n+            expr,\n             probe::ProbeScope::AllTraits,\n+            expectation,\n         ) else { return; };\n         let mut sugg = \".\";\n         let mut span = start.expr.span.between(end.expr.span);"}, {"sha": "ba1a5a0cb03e114312a39f3ca23a70404707d781", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Struct(qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            ExprKind::Field(base, field) => self.check_field(expr, &base, field),\n+            ExprKind::Field(base, field) => self.check_field(expr, &base, field, expected),\n             ExprKind::Index(base, idx) => self.check_expr_index(base, idx, expr),\n             ExprKind::Yield(value, ref src) => self.check_expr_yield(value, expr, src),\n             hir::ExprKind::Err => tcx.ty_error(),\n@@ -1244,6 +1244,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         SelfSource::MethodCall(rcvr),\n                         error,\n                         Some((rcvr, args)),\n+                        expected,\n                     ) {\n                         err.emit();\n                     }\n@@ -2186,6 +2187,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n         base: &'tcx hir::Expr<'tcx>,\n         field: Ident,\n+        expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         debug!(\"check_field(expr: {:?}, base: {:?}, field: {:?})\", expr, base, field);\n         let base_ty = self.check_expr(base);\n@@ -2244,12 +2246,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // (#90483) apply adjustments to avoid ExprUseVisitor from\n             // creating erroneous projection.\n             self.apply_adjustments(base, adjustments);\n-            self.ban_private_field_access(expr, base_ty, field, did);\n+            self.ban_private_field_access(expr, base_ty, field, did, expected.only_has_type(self));\n             return self.tcx().ty_error();\n         }\n \n         if field.name == kw::Empty {\n-        } else if self.method_exists(field, base_ty, expr.hir_id, true) {\n+        } else if self.method_exists(\n+            field,\n+            base_ty,\n+            expr.hir_id,\n+            true,\n+            expected.only_has_type(self),\n+        ) {\n             self.ban_take_value_of_method(expr, base_ty, field);\n         } else if !base_ty.is_primitive_ty() {\n             self.ban_nonexisting_field(field, base, expr, base_ty);\n@@ -2423,10 +2431,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn ban_private_field_access(\n         &self,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         expr_t: Ty<'tcx>,\n         field: Ident,\n         base_did: DefId,\n+        return_ty: Option<Ty<'tcx>>,\n     ) {\n         let struct_path = self.tcx().def_path_str(base_did);\n         let kind_name = self.tcx().def_kind(base_did).descr(base_did);\n@@ -2438,7 +2447,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         err.span_label(field.span, \"private field\");\n         // Also check if an accessible method exists, which is often what is meant.\n-        if self.method_exists(field, expr_t, expr.hir_id, false) && !self.expr_in_place(expr.hir_id)\n+        if self.method_exists(field, expr_t, expr.hir_id, false, return_ty)\n+            && !self.expr_in_place(expr.hir_id)\n         {\n             self.suggest_method_call(\n                 &mut err,\n@@ -2452,7 +2462,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn ban_take_value_of_method(&self, expr: &hir::Expr<'_>, expr_t: Ty<'tcx>, field: Ident) {\n+    fn ban_take_value_of_method(&self, expr: &hir::Expr<'tcx>, expr_t: Ty<'tcx>, field: Ident) {\n         let mut err = type_error_struct!(\n             self.tcx().sess,\n             field.span,"}, {"sha": "594a60c70a7984ce54f0606f787274df255012f2", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -820,6 +820,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         SelfSource::QPath(qself),\n                         error,\n                         None,\n+                        Expectation::NoExpectation,\n                     ) {\n                         e.emit();\n                     }"}, {"sha": "91498265259dee557456da28c7d319a86594360f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -1343,6 +1343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let Ok(pick) = self.probe_for_name(\n                     Mode::Path,\n                     Ident::new(capitalized_name, segment.ident.span),\n+                    Some(expected_ty),\n                     IsSuggestion(true),\n                     self_ty,\n                     expr.hir_id,"}, {"sha": "146d5e60c2f388c2bfd7257c66af6b91414ed12f", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 54, "deletions": 26, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -97,10 +97,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_ty: Ty<'tcx>,\n         call_expr_id: hir::HirId,\n         allow_private: bool,\n+        return_type: Option<Ty<'tcx>>,\n     ) -> bool {\n         match self.probe_for_name(\n             probe::Mode::MethodCall,\n             method_name,\n+            return_type,\n             IsSuggestion(false),\n             self_ty,\n             call_expr_id,\n@@ -118,7 +120,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(Ambiguity(..)) => true,\n             Err(PrivateMatch(..)) => allow_private,\n             Err(IllegalSizedBound { .. }) => true,\n-            Err(BadReturnType) => bug!(\"no return type expectations but got BadReturnType\"),\n+            Err(BadReturnType) => false,\n         }\n     }\n \n@@ -130,17 +132,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         msg: &str,\n         method_name: Ident,\n         self_ty: Ty<'tcx>,\n-        call_expr: &hir::Expr<'_>,\n+        call_expr: &hir::Expr<'tcx>,\n         span: Option<Span>,\n     ) {\n         let params = self\n-            .probe_for_name(\n-                probe::Mode::MethodCall,\n+            .lookup_probe_for_diagnostic(\n                 method_name,\n-                IsSuggestion(true),\n                 self_ty,\n-                call_expr.hir_id,\n+                call_expr,\n                 ProbeScope::TraitsInScope,\n+                None,\n             )\n             .map(|pick| {\n                 let sig = self.tcx.fn_sig(pick.item.def_id);\n@@ -221,25 +222,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             // We probe again, taking all traits into account (not only those in scope).\n-            let candidates =\n-                match self.lookup_probe(segment.ident, self_ty, call_expr, ProbeScope::AllTraits) {\n-                    // If we find a different result the caller probably forgot to import a trait.\n-                    Ok(ref new_pick) if pick.differs_from(new_pick) => {\n-                        vec![new_pick.item.container_id(self.tcx)]\n-                    }\n-                    Err(Ambiguity(ref sources)) => sources\n-                        .iter()\n-                        .filter_map(|source| {\n-                            match *source {\n-                                // Note: this cannot come from an inherent impl,\n-                                // because the first probing succeeded.\n-                                CandidateSource::Impl(def) => self.tcx.trait_id_of_impl(def),\n-                                CandidateSource::Trait(_) => None,\n-                            }\n-                        })\n-                        .collect(),\n-                    _ => Vec::new(),\n-                };\n+            let candidates = match self.lookup_probe_for_diagnostic(\n+                segment.ident,\n+                self_ty,\n+                call_expr,\n+                ProbeScope::AllTraits,\n+                None,\n+            ) {\n+                // If we find a different result the caller probably forgot to import a trait.\n+                Ok(ref new_pick) if pick.differs_from(new_pick) => {\n+                    vec![new_pick.item.container_id(self.tcx)]\n+                }\n+                Err(Ambiguity(ref sources)) => sources\n+                    .iter()\n+                    .filter_map(|source| {\n+                        match *source {\n+                            // Note: this cannot come from an inherent impl,\n+                            // because the first probing succeeded.\n+                            CandidateSource::Impl(def) => self.tcx.trait_id_of_impl(def),\n+                            CandidateSource::Trait(_) => None,\n+                        }\n+                    })\n+                    .collect(),\n+                _ => Vec::new(),\n+            };\n \n             return Err(IllegalSizedBound { candidates, needs_mut, bound_span: span, self_expr });\n         }\n@@ -252,12 +258,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         method_name: Ident,\n         self_ty: Ty<'tcx>,\n-        call_expr: &'tcx hir::Expr<'tcx>,\n+        call_expr: &hir::Expr<'_>,\n         scope: ProbeScope,\n     ) -> probe::PickResult<'tcx> {\n         let pick = self.probe_for_name(\n             probe::Mode::MethodCall,\n             method_name,\n+            None,\n             IsSuggestion(false),\n             self_ty,\n             call_expr.hir_id,\n@@ -267,6 +274,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Ok(pick)\n     }\n \n+    pub fn lookup_probe_for_diagnostic(\n+        &self,\n+        method_name: Ident,\n+        self_ty: Ty<'tcx>,\n+        call_expr: &hir::Expr<'_>,\n+        scope: ProbeScope,\n+        return_type: Option<Ty<'tcx>>,\n+    ) -> probe::PickResult<'tcx> {\n+        let pick = self.probe_for_name(\n+            probe::Mode::MethodCall,\n+            method_name,\n+            return_type,\n+            IsSuggestion(true),\n+            self_ty,\n+            call_expr.hir_id,\n+            scope,\n+        )?;\n+        Ok(pick)\n+    }\n+\n     pub(super) fn obligation_for_method(\n         &self,\n         cause: ObligationCause<'tcx>,\n@@ -484,6 +511,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let pick = self.probe_for_name(\n             probe::Mode::Path,\n             method_name,\n+            None,\n             IsSuggestion(false),\n             self_ty,\n             expr_id,"}, {"sha": "02b4d5bb2fbe6a3573e108ad4a680a30a242a66e", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -304,6 +304,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         mode: Mode,\n         item_name: Ident,\n+        return_type: Option<Ty<'tcx>>,\n         is_suggestion: IsSuggestion,\n         self_ty: Ty<'tcx>,\n         scope_expr_id: hir::HirId,\n@@ -313,7 +314,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             item_name.span,\n             mode,\n             Some(item_name),\n-            None,\n+            return_type,\n             is_suggestion,\n             self_ty,\n             scope_expr_id,\n@@ -327,6 +328,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         mode: Mode,\n         item_name: Ident,\n+        return_type: Option<Ty<'tcx>>,\n         is_suggestion: IsSuggestion,\n         self_ty: Ty<'tcx>,\n         scope_expr_id: hir::HirId,\n@@ -336,7 +338,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             item_name.span,\n             mode,\n             Some(item_name),\n-            None,\n+            return_type,\n             is_suggestion,\n             self_ty,\n             scope_expr_id,\n@@ -1540,7 +1542,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     let InferOk {\n                         value: normalized_xform_ret_ty,\n                         obligations: normalization_obligations,\n-                    } = self.fcx.at(&cause, self.param_env).normalize(probe.xform_ret_ty);\n+                    } = self.fcx.at(&cause, self.param_env).normalize(xform_ret_ty);\n                     xform_ret_ty = normalized_xform_ret_ty;\n                     debug!(\"xform_ret_ty after normalization: {:?}\", xform_ret_ty);\n \n@@ -1554,7 +1556,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n                     // Convert the bounds into obligations.\n                     let impl_obligations = traits::predicates_for_generics(\n-                        move |_, _| cause.clone(),\n+                        |_, _| cause.clone(),\n                         self.param_env,\n                         impl_bounds,\n                     );\n@@ -1597,7 +1599,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         ty::Binder::dummy(trait_ref).without_const().to_predicate(self.tcx);\n                     parent_pred = Some(predicate);\n                     let obligation =\n-                        traits::Obligation::new(self.tcx, cause, self.param_env, predicate);\n+                        traits::Obligation::new(self.tcx, cause.clone(), self.param_env, predicate);\n                     if !self.predicate_may_hold(&obligation) {\n                         result = ProbeResult::NoMatch;\n                         if self.probe(|_| {\n@@ -1656,22 +1658,48 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 }\n             }\n \n-            if let ProbeResult::Match = result {\n-                if let (Some(return_ty), Some(xform_ret_ty)) = (self.return_type, xform_ret_ty) {\n-                    let xform_ret_ty = self.resolve_vars_if_possible(xform_ret_ty);\n-                    debug!(\n-                        \"comparing return_ty {:?} with xform ret ty {:?}\",\n-                        return_ty, probe.xform_ret_ty\n-                    );\n-                    if self\n-                        .at(&ObligationCause::dummy(), self.param_env)\n-                        .define_opaque_types(false)\n-                        .sup(return_ty, xform_ret_ty)\n-                        .is_err()\n-                    {\n-                        return ProbeResult::BadReturnType;\n+            if let ProbeResult::Match = result\n+                && let Some(return_ty) = self.return_type\n+                && let Some(mut xform_ret_ty) = xform_ret_ty\n+            {\n+                // `xform_ret_ty` has only been normalized for `InherentImplCandidate`.\n+                // We don't normalize the other candidates for perf/backwards-compat reasons...\n+                // but `self.return_type` is only set on the diagnostic-path, so we\n+                // should be okay doing it here.\n+                if !matches!(probe.kind, InherentImplCandidate(..)) {\n+                    let InferOk {\n+                        value: normalized_xform_ret_ty,\n+                        obligations: normalization_obligations,\n+                    } = self.fcx.at(&cause, self.param_env).normalize(xform_ret_ty);\n+                    xform_ret_ty = normalized_xform_ret_ty;\n+                    debug!(\"xform_ret_ty after normalization: {:?}\", xform_ret_ty);\n+                    // Evaluate those obligations to see if they might possibly hold.\n+                    for o in normalization_obligations {\n+                        let o = self.resolve_vars_if_possible(o);\n+                        if !self.predicate_may_hold(&o) {\n+                            result = ProbeResult::NoMatch;\n+                            possibly_unsatisfied_predicates.push((\n+                                o.predicate,\n+                                None,\n+                                Some(o.cause),\n+                            ));\n+                        }\n                     }\n                 }\n+\n+                debug!(\n+                    \"comparing return_ty {:?} with xform ret ty {:?}\",\n+                    return_ty, xform_ret_ty\n+                );\n+                if let ProbeResult::Match = result\n+                    && self\n+                    .at(&ObligationCause::dummy(), self.param_env)\n+                    .define_opaque_types(false)\n+                    .sup(return_ty, xform_ret_ty)\n+                    .is_err()\n+                {\n+                    result = ProbeResult::BadReturnType;\n+                }\n             }\n \n             result"}, {"sha": "62e80659486a870429503b19c32e3113f2b37a6a", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -2,6 +2,7 @@\n //! found or is otherwise invalid.\n \n use crate::errors;\n+use crate::Expectation;\n use crate::FnCtxt;\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -108,6 +109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         source: SelfSource<'tcx>,\n         error: MethodError<'tcx>,\n         args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n+        expected: Expectation<'tcx>,\n     ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {\n         // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n@@ -131,6 +133,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     args,\n                     sugg_span,\n                     &mut no_match_data,\n+                    expected,\n                 );\n             }\n \n@@ -250,6 +253,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n         sugg_span: Span,\n         no_match_data: &mut NoMatchData<'tcx>,\n+        expected: Expectation<'tcx>,\n     ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {\n         let mode = no_match_data.mode;\n         let tcx = self.tcx;\n@@ -320,7 +324,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n             self.suggest_await_before_method(\n-                &mut err, item_name, rcvr_ty, cal, span,\n+                &mut err, item_name, rcvr_ty, cal, span, expected.only_has_type(self),\n             );\n         }\n         if let Some(span) =\n@@ -366,8 +370,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.suggest_fn_call(&mut err, rcvr_expr, rcvr_ty, |output_ty| {\n                 let call_expr =\n                     self.tcx.hir().expect_expr(self.tcx.hir().parent_id(rcvr_expr.hir_id));\n-                let probe =\n-                    self.lookup_probe(item_name, output_ty, call_expr, ProbeScope::AllTraits);\n+                let probe = self.lookup_probe_for_diagnostic(\n+                    item_name,\n+                    output_ty,\n+                    call_expr,\n+                    ProbeScope::AllTraits,\n+                    expected.only_has_type(self),\n+                );\n                 probe.is_ok()\n             });\n         }\n@@ -898,7 +907,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n         // can't be called due to `typeof(expr): Clone` not holding.\n         if unsatisfied_predicates.is_empty() {\n-            self.suggest_calling_method_on_field(&mut err, source, span, rcvr_ty, item_name);\n+            self.suggest_calling_method_on_field(\n+                &mut err,\n+                source,\n+                span,\n+                rcvr_ty,\n+                item_name,\n+                expected.only_has_type(self),\n+            );\n         }\n \n         self.check_for_inner_self(&mut err, source, rcvr_ty, item_name);\n@@ -922,6 +938,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &unsatisfied_predicates,\n                 &static_candidates,\n                 unsatisfied_bounds,\n+                expected.only_has_type(self),\n             );\n         }\n \n@@ -987,7 +1004,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.check_for_deref_method(&mut err, source, rcvr_ty, item_name);\n+        self.check_for_deref_method(&mut err, source, rcvr_ty, item_name, expected);\n         return Some(err);\n     }\n \n@@ -1374,13 +1391,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let range_ty =\n                         self.tcx.bound_type_of(range_def_id).subst(self.tcx, &[actual.into()]);\n \n-                    let pick = self.probe_for_name(\n-                        Mode::MethodCall,\n+                    let pick = self.lookup_probe_for_diagnostic(\n                         item_name,\n-                        IsSuggestion(true),\n                         range_ty,\n-                        expr.hir_id,\n+                        expr,\n                         ProbeScope::AllTraits,\n+                        None,\n                     );\n                     if pick.is_ok() {\n                         let range_span = parent_expr.span.with_hi(expr.span.hi());\n@@ -1560,11 +1576,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             && let Some(expr) = visitor.result\n             && let Some(self_ty) = self.node_ty_opt(expr.hir_id)\n         {\n-            let probe = self.lookup_probe(\n+            let probe = self.lookup_probe_for_diagnostic(\n                 seg2.ident,\n                 self_ty,\n                 call_expr,\n                 ProbeScope::TraitsInScope,\n+                None,\n             );\n             if probe.is_ok() {\n                 let sm = self.infcx.tcx.sess.source_map();\n@@ -1587,6 +1604,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         actual: Ty<'tcx>,\n         item_name: Ident,\n+        return_type: Option<Ty<'tcx>>,\n     ) {\n         if let SelfSource::MethodCall(expr) = source\n         && let mod_id = self.tcx.parent_module(expr.hir_id).to_def_id()\n@@ -1610,11 +1628,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.check_for_nested_field_satisfying(\n                         span,\n                         &|_, field_ty| {\n-                            self.lookup_probe(\n+                            self.lookup_probe_for_diagnostic(\n                                 item_name,\n                                 field_ty,\n                                 call_expr,\n                                 ProbeScope::TraitsInScope,\n+                                return_type,\n                             )\n                             .map_or(false, |pick| {\n                                 !never_mention_traits\n@@ -1680,9 +1699,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             return None;\n                         }\n \n-                        self.lookup_probe(item_name, field_ty, call_expr, ProbeScope::TraitsInScope)\n-                            .ok()\n-                            .map(|pick| (variant, field, pick))\n+                        self.lookup_probe_for_diagnostic(\n+                            item_name,\n+                            field_ty,\n+                            call_expr,\n+                            ProbeScope::TraitsInScope,\n+                            None,\n+                        )\n+                        .ok()\n+                        .map(|pick| (variant, field, pick))\n                     })\n                     .collect();\n \n@@ -1746,11 +1771,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::AdtKind::Struct | ty::AdtKind::Union => {\n                 let [first] = ***substs else { return; };\n                 let ty::GenericArgKind::Type(ty) = first.unpack() else { return; };\n-                let Ok(pick) = self.lookup_probe(\n+                let Ok(pick) = self.lookup_probe_for_diagnostic(\n                     item_name,\n                     ty,\n                     call_expr,\n                     ProbeScope::TraitsInScope,\n+                    None,\n                 )  else { return; };\n \n                 let name = self.ty_to_value_string(actual);\n@@ -2010,12 +2036,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_source: SelfSource<'tcx>,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n+        expected: Expectation<'tcx>,\n     ) {\n         let SelfSource::QPath(ty) = self_source else { return; };\n         for (deref_ty, _) in self.autoderef(rustc_span::DUMMY_SP, rcvr_ty).skip(1) {\n             if let Ok(pick) = self.probe_for_name(\n                 Mode::Path,\n                 item_name,\n+                expected.only_has_type(self),\n                 IsSuggestion(true),\n                 deref_ty,\n                 ty.hir_id,\n@@ -2080,12 +2108,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         call: &hir::Expr<'_>,\n         span: Span,\n+        return_type: Option<Ty<'tcx>>,\n     ) {\n         let output_ty = match self.get_impl_future_output_ty(ty) {\n             Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n             _ => return,\n         };\n-        let method_exists = self.method_exists(item_name, output_ty, call.hir_id, true);\n+        let method_exists =\n+            self.method_exists(item_name, output_ty, call.hir_id, true, return_type);\n         debug!(\"suggest_await_before_method: is_method_exist={}\", method_exists);\n         if method_exists {\n             err.span_suggestion_verbose(\n@@ -2199,6 +2229,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )],\n         static_candidates: &[CandidateSource],\n         unsatisfied_bounds: bool,\n+        return_type: Option<Ty<'tcx>>,\n     ) {\n         let mut alt_rcvr_sugg = false;\n         if let (SelfSource::MethodCall(rcvr), false) = (source, unsatisfied_bounds) {\n@@ -2221,7 +2252,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (self.tcx.mk_mut_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&mut \"),\n                 (self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&\"),\n             ] {\n-                match self.lookup_probe(item_name, *rcvr_ty, rcvr, ProbeScope::AllTraits) {\n+                match self.lookup_probe_for_diagnostic(\n+                    item_name,\n+                    *rcvr_ty,\n+                    rcvr,\n+                    ProbeScope::AllTraits,\n+                    return_type,\n+                ) {\n                     Ok(pick) => {\n                         // If the method is defined for the receiver we have, it likely wasn't `use`d.\n                         // We point at the method, but we just skip the rest of the check for arbitrary\n@@ -2254,11 +2291,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Rc), \"Rc::new\"),\n                 ] {\n                     if let Some(new_rcvr_t) = *rcvr_ty\n-                        && let Ok(pick) = self.lookup_probe(\n+                        && let Ok(pick) = self.lookup_probe_for_diagnostic(\n                             item_name,\n                             new_rcvr_t,\n                             rcvr,\n                             ProbeScope::AllTraits,\n+                            return_type,\n                         )\n                     {\n                         debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n@@ -2637,11 +2675,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 name: Symbol::intern(&format!(\"{}_else\", method_name.as_str())),\n                 span: method_name.span,\n             };\n-            let probe = self.lookup_probe(\n+            let probe = self.lookup_probe_for_diagnostic(\n                 new_name,\n                 self_ty,\n                 self_expr,\n                 ProbeScope::TraitsInScope,\n+                Some(expected),\n             );\n \n             // check the method arguments number"}, {"sha": "f2f87a908178c19719a06638161c5c4b58207333", "filename": "src/test/ui/async-await/dont-suggest-await-on-method-return-mismatch.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.rs?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -0,0 +1,24 @@\n+// edition:2021\n+\n+// Test that we do not suggest `.await` when it doesn't make sense.\n+\n+struct A;\n+\n+impl A {\n+    fn test(&self) -> i32 {\n+        1\n+    }\n+}\n+\n+async fn foo() -> A {\n+    A\n+}\n+\n+async fn async_main() {\n+    let x: u32 = foo().test();\n+    //~^ ERROR no method named `test` found for opaque type `impl Future<Output = A>` in the current scope\n+}\n+\n+fn main() {\n+    let _ = async_main();\n+}"}, {"sha": "e65d9d0e5d35ff60dc6d0a2b7d8fb252e923416c", "filename": "src/test/ui/async-await/dont-suggest-await-on-method-return-mismatch.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.stderr?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -0,0 +1,9 @@\n+error[E0599]: no method named `test` found for opaque type `impl Future<Output = A>` in the current scope\n+  --> $DIR/dont-suggest-await-on-method-return-mismatch.rs:18:24\n+   |\n+LL |     let x: u32 = foo().test();\n+   |                        ^^^^ method not found in `impl Future<Output = A>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "07b975c44c905ab2c1bd8bad6f3b56c1bf7f1472", "filename": "src/test/ui/methods/field-method-suggestion-using-return-ty.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.rs?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -0,0 +1,18 @@\n+struct Wrapper<T>(T);\n+\n+impl Wrapper<Option<i32>> {\n+    fn inner_mut(&self) -> Option<&mut i32> {\n+        self.as_mut()\n+        //~^ ERROR no method named `as_mut` found for reference `&Wrapper<Option<i32>>` in the current scope\n+        //~| HELP one of the expressions' fields has a method of the same name\n+        //~| HELP items from traits can only be used if\n+    }\n+\n+    fn inner_mut_bad(&self) -> Option<&mut u32> {\n+        self.as_mut()\n+        //~^ ERROR no method named `as_mut` found for reference `&Wrapper<Option<i32>>` in the current scope\n+        //~| HELP items from traits can only be used if\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "51c52a07e10f6d075217b3d9f23ab87f82217027", "filename": "src/test/ui/methods/field-method-suggestion-using-return-ty.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.stderr?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -0,0 +1,27 @@\n+error[E0599]: no method named `as_mut` found for reference `&Wrapper<Option<i32>>` in the current scope\n+  --> $DIR/field-method-suggestion-using-return-ty.rs:5:14\n+   |\n+LL |         self.as_mut()\n+   |              ^^^^^^ method not found in `&Wrapper<Option<i32>>`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+   = note: the following trait defines an item `as_mut`, perhaps you need to implement it:\n+           candidate #1: `AsMut`\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |         self.0.as_mut()\n+   |              ++\n+\n+error[E0599]: no method named `as_mut` found for reference `&Wrapper<Option<i32>>` in the current scope\n+  --> $DIR/field-method-suggestion-using-return-ty.rs:12:14\n+   |\n+LL |         self.as_mut()\n+   |              ^^^^^^ method not found in `&Wrapper<Option<i32>>`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+   = note: the following trait defines an item `as_mut`, perhaps you need to implement it:\n+           candidate #1: `AsMut`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "98ba7856e57e3c9c6babdc2b294fccce8239e18e", "filename": "src/test/ui/privacy/private-field-ty-err.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fprivacy%2Fprivate-field-ty-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fprivacy%2Fprivate-field-ty-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-field-ty-err.stderr?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -3,11 +3,6 @@ error[E0616]: field `len` of struct `Foo` is private\n    |\n LL |     if x.len {\n    |          ^^^ private field\n-   |\n-help: a method `len` also exists, call it with parentheses\n-   |\n-LL |     if x.len() {\n-   |             ++\n \n error: aborting due to previous error\n "}, {"sha": "13601eef6c25b9944cb86969eb5de1c3ded7d407", "filename": "src/test/ui/suggestions/method-access-to-range-literal-typo.fixed", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.fixed?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -0,0 +1,34 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+fn as_ref() -> Option<Vec<u8>> {\n+    None\n+}\n+struct Type {\n+    option: Option<Vec<u8>>\n+}\n+trait Trait {\n+    fn foo(&self) -> &Vec<u8>;\n+}\n+impl Trait for Option<Vec<u8>> {\n+    fn foo(&self) -> &Vec<u8> {\n+        self.as_ref().unwrap()\n+    }\n+}\n+\n+impl Type {\n+    fn method(&self) -> Option<&Vec<u8>> {\n+        self.option.as_ref().map(|x| x)\n+        //~^ ERROR E0308\n+    }\n+    fn method2(&self) -> Option<&u8> {\n+        self.option.foo().get(0)\n+        //~^ ERROR E0425\n+        //~| ERROR E0308\n+    }\n+}\n+\n+fn main() {\n+    let _ = Type { option: None }.method();\n+}"}, {"sha": "fdcd6425d32de88d50f81194f9836631447f68c2", "filename": "src/test/ui/suggestions/method-access-to-range-literal-typo.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.rs?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -1,24 +1,28 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n fn as_ref() -> Option<Vec<u8>> {\n     None\n }\n struct Type {\n     option: Option<Vec<u8>>\n }\n trait Trait {\n-    fn foo(&self) -> Vec<u8>;\n+    fn foo(&self) -> &Vec<u8>;\n }\n impl Trait for Option<Vec<u8>> {\n-    fn foo(&self) -> Vec<u8> {\n-        vec![1, 2, 3]\n+    fn foo(&self) -> &Vec<u8> {\n+        self.as_ref().unwrap()\n     }\n }\n \n impl Type {\n-    fn method(&self) -> Option<Vec<u8>> {\n+    fn method(&self) -> Option<&Vec<u8>> {\n         self.option..as_ref().map(|x| x)\n         //~^ ERROR E0308\n     }\n-    fn method2(&self) -> &u8 {\n+    fn method2(&self) -> Option<&u8> {\n         self.option..foo().get(0)\n         //~^ ERROR E0425\n         //~| ERROR E0308"}, {"sha": "f421408944bb3b3d7656a64f7ccbbe64429395b7", "filename": "src/test/ui/suggestions/method-access-to-range-literal-typo.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0442fbabe24ec43636a80ad1f40a0ad92a2e38df/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.stderr?ref=0442fbabe24ec43636a80ad1f40a0ad92a2e38df", "patch": "@@ -1,5 +1,5 @@\n error[E0425]: cannot find function `foo` in this scope\n-  --> $DIR/method-access-to-range-literal-typo.rs:22:22\n+  --> $DIR/method-access-to-range-literal-typo.rs:26:22\n    |\n LL |         self.option..foo().get(0)\n    |                      ^^^ not found in this scope\n@@ -11,31 +11,31 @@ LL +         self.option.foo().get(0)\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/method-access-to-range-literal-typo.rs:18:9\n+  --> $DIR/method-access-to-range-literal-typo.rs:22:9\n    |\n-LL |     fn method(&self) -> Option<Vec<u8>> {\n-   |                         --------------- expected `Option<Vec<u8>>` because of return type\n+LL |     fn method(&self) -> Option<&Vec<u8>> {\n+   |                         ---------------- expected `Option<&Vec<u8>>` because of return type\n LL |         self.option..as_ref().map(|x| x)\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found struct `Range`\n    |\n-   = note: expected enum `Option<_>`\n-            found struct `std::ops::Range<Option<_>>`\n+   = note: expected enum `Option<&Vec<u8>>`\n+            found struct `std::ops::Range<Option<Vec<u8>>>`\n help: you likely meant to write a method call instead of a range\n    |\n LL -         self.option..as_ref().map(|x| x)\n LL +         self.option.as_ref().map(|x| x)\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/method-access-to-range-literal-typo.rs:22:9\n+  --> $DIR/method-access-to-range-literal-typo.rs:26:9\n    |\n-LL |     fn method2(&self) -> &u8 {\n-   |                          --- expected `&u8` because of return type\n+LL |     fn method2(&self) -> Option<&u8> {\n+   |                          ----------- expected `Option<&u8>` because of return type\n LL |         self.option..foo().get(0)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&u8`, found struct `Range`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found struct `Range`\n    |\n-   = note: expected reference `&u8`\n-                 found struct `std::ops::Range<Option<Vec<u8>>>`\n+   = note: expected enum `Option<&u8>`\n+            found struct `std::ops::Range<Option<Vec<u8>>>`\n help: you likely meant to write a method call instead of a range\n    |\n LL -         self.option..foo().get(0)"}]}