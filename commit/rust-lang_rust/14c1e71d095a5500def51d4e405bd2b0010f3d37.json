{"sha": "14c1e71d095a5500def51d4e405bd2b0010f3d37", "node_id": "C_kwDOAAsO6NoAKDE0YzFlNzFkMDk1YTU1MDBkZWY1MWQ0ZTQwNWJkMmIwMDEwZjNkMzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-03T23:46:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-03T23:46:53Z"}, "message": "Auto merge of #91501 - camelid:rm-tuple-impls-2, r=GuillaumeGomez\n\nrustdoc: Remove Clean impls for tuples\n\nThis PR removes all nine Clean impls on tuples, converting them to\nfunctions instead.\n\nThe fact that these are impls causes several problems:\n\n  1. They are nameless, so it's unclear what they do.\n\n  2. It's hard to find where they're used apart from removing them and\n     seeing what errors occur (this applies to all Clean impls, not just\n     the tuple ones).\n\n  3. Rustc doesn't currently warn when impls are unused, so dead code\n     can accumulate easily (all Clean impls).\n\n  4. Their bodies often use tuple field indexing syntax (e.g., `self.1`)\n     to refer to their \"arguments\", which makes reading the code more\n     difficult.\n\nAs I noted, some of these problems apply to all Clean impls, but even\nthose problems are exacerbated by the tuple impls since they make\ngeneral understanding of the code harder.\n\nConverting the impls to functions solves all four of these problems.\n\nr? `@GuillaumeGomez`", "tree": {"sha": "98f76652ac883a70e693cf427441b69b4a5216e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98f76652ac883a70e693cf427441b69b4a5216e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14c1e71d095a5500def51d4e405bd2b0010f3d37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14c1e71d095a5500def51d4e405bd2b0010f3d37", "html_url": "https://github.com/rust-lang/rust/commit/14c1e71d095a5500def51d4e405bd2b0010f3d37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14c1e71d095a5500def51d4e405bd2b0010f3d37/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "532d2b14c05f9bc20b2d27cbb5f4550d28343a36", "url": "https://api.github.com/repos/rust-lang/rust/commits/532d2b14c05f9bc20b2d27cbb5f4550d28343a36", "html_url": "https://github.com/rust-lang/rust/commit/532d2b14c05f9bc20b2d27cbb5f4550d28343a36"}, {"sha": "e36561dbddd9a91f84a93e2d9956d79d960c44cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e36561dbddd9a91f84a93e2d9956d79d960c44cf", "html_url": "https://github.com/rust-lang/rust/commit/e36561dbddd9a91f84a93e2d9956d79d960c44cf"}], "stats": {"total": 842, "additions": 428, "deletions": 414}, "files": [{"sha": "7b66ff7d4113674a20e8e3da3cef6d2aad27c799", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/14c1e71d095a5500def51d4e405bd2b0010f3d37/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c1e71d095a5500def51d4e405bd2b0010f3d37/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=14c1e71d095a5500def51d4e405bd2b0010f3d37", "patch": "@@ -100,9 +100,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 // Instead, we generate `impl !Send for Foo<T>`, which better\n                 // expresses the fact that `Foo<T>` never implements `Send`,\n                 // regardless of the choice of `T`.\n-                let params = (tcx.generics_of(item_def_id), ty::GenericPredicates::default())\n-                    .clean(self.cx)\n-                    .params;\n+                let raw_generics = clean_ty_generics(\n+                    self.cx,\n+                    tcx.generics_of(item_def_id),\n+                    ty::GenericPredicates::default(),\n+                );\n+                let params = raw_generics.params;\n \n                 Generics { params, where_predicates: Vec::new() }\n             }\n@@ -451,10 +454,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             })\n             .map(|p| p.fold_with(&mut replacer));\n \n-        let mut generic_params =\n-            (tcx.generics_of(item_def_id), tcx.explicit_predicates_of(item_def_id))\n-                .clean(self.cx)\n-                .params;\n+        let raw_generics = clean_ty_generics(\n+            self.cx,\n+            tcx.generics_of(item_def_id),\n+            tcx.explicit_predicates_of(item_def_id),\n+        );\n+        let mut generic_params = raw_generics.params;\n \n         debug!(\"param_env_to_generics({:?}): generic_params={:?}\", item_def_id, generic_params);\n "}, {"sha": "80e3bb5c6624f99f611f09646545cddc9e7703c1", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14c1e71d095a5500def51d4e405bd2b0010f3d37/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c1e71d095a5500def51d4e405bd2b0010f3d37/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=14c1e71d095a5500def51d4e405bd2b0010f3d37", "patch": "@@ -107,11 +107,11 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n                     kind: box ImplItem(Impl {\n                         unsafety: hir::Unsafety::Normal,\n-                        generics: (\n+                        generics: clean_ty_generics(\n+                            self.cx,\n                             self.cx.tcx.generics_of(impl_def_id),\n                             self.cx.tcx.explicit_predicates_of(impl_def_id),\n-                        )\n-                            .clean(self.cx),\n+                        ),\n                         // FIXME(eddyb) compute both `trait_` and `for_` from\n                         // the post-inference `trait_ref`, as it's more accurate.\n                         trait_: Some(trait_ref.clean(self.cx)),"}, {"sha": "39544fa843de8665677c318c2a9e4ec035c9b44c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/14c1e71d095a5500def51d4e405bd2b0010f3d37/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c1e71d095a5500def51d4e405bd2b0010f3d37/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=14c1e71d095a5500def51d4e405bd2b0010f3d37", "patch": "@@ -15,13 +15,12 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n-    self, utils, Attributes, AttributesExt, ImplKind, ItemId, NestedAttributesExt, Type,\n+    self, clean_fn_decl_from_did_and_sig, clean_ty_generics, utils, Attributes, AttributesExt,\n+    Clean, ImplKind, ItemId, NestedAttributesExt, Type, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n \n-use super::{Clean, Visibility};\n-\n type Attrs<'hir> = rustc_middle::ty::Attributes<'hir>;\n \n /// Attempt to inline a definition into this AST.\n@@ -208,7 +207,7 @@ crate fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean::Tra\n         .collect();\n \n     let predicates = cx.tcx.predicates_of(did);\n-    let generics = (cx.tcx.generics_of(did), predicates).clean(cx);\n+    let generics = clean_ty_generics(cx, cx.tcx.generics_of(did), predicates);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n     let is_auto = cx.tcx.trait_is_auto(did);\n@@ -230,7 +229,9 @@ fn build_external_function(cx: &mut DocContext<'_>, did: DefId) -> clean::Functi\n     let predicates = cx.tcx.predicates_of(did);\n     let (generics, decl) = clean::enter_impl_trait(cx, |cx| {\n         // NOTE: generics need to be cleaned before the decl!\n-        ((cx.tcx.generics_of(did), predicates).clean(cx), (did, sig).clean(cx))\n+        let generics = clean_ty_generics(cx, cx.tcx.generics_of(did), predicates);\n+        let decl = clean_fn_decl_from_did_and_sig(cx, did, sig);\n+        (generics, decl)\n     });\n     clean::Function {\n         decl,\n@@ -243,7 +244,7 @@ fn build_enum(cx: &mut DocContext<'_>, did: DefId) -> clean::Enum {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n \n     clean::Enum {\n-        generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n+        generics: clean_ty_generics(cx, cx.tcx.generics_of(did), predicates),\n         variants_stripped: false,\n         variants: cx.tcx.adt_def(did).variants.iter().map(|v| v.clean(cx)).collect(),\n     }\n@@ -255,7 +256,7 @@ fn build_struct(cx: &mut DocContext<'_>, did: DefId) -> clean::Struct {\n \n     clean::Struct {\n         struct_type: variant.ctor_kind,\n-        generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n+        generics: clean_ty_generics(cx, cx.tcx.generics_of(did), predicates),\n         fields: variant.fields.iter().map(|x| x.clean(cx)).collect(),\n         fields_stripped: false,\n     }\n@@ -265,7 +266,7 @@ fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n-    let generics = (cx.tcx.generics_of(did), predicates).clean(cx);\n+    let generics = clean_ty_generics(cx, cx.tcx.generics_of(did), predicates);\n     let fields = variant.fields.iter().map(|x| x.clean(cx)).collect();\n     clean::Union { generics, fields, fields_stripped: false }\n }\n@@ -276,7 +277,7 @@ fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> clean::Typedef {\n \n     clean::Typedef {\n         type_,\n-        generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n+        generics: clean_ty_generics(cx, cx.tcx.generics_of(did), predicates),\n         item_type: None,\n     }\n }\n@@ -440,7 +441,9 @@ crate fn build_impl(\n                     }\n                 })\n                 .collect::<Vec<_>>(),\n-            clean::enter_impl_trait(cx, |cx| (tcx.generics_of(did), predicates).clean(cx)),\n+            clean::enter_impl_trait(cx, |cx| {\n+                clean_ty_generics(cx, tcx.generics_of(did), predicates)\n+            }),\n         ),\n     };\n     let polarity = tcx.impl_polarity(did);"}, {"sha": "f11fa0295c52220c9f7d9546973245dfff3d6d12", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 400, "deletions": 394, "changes": 794, "blob_url": "https://github.com/rust-lang/rust/blob/14c1e71d095a5500def51d4e405bd2b0010f3d37/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c1e71d095a5500def51d4e405bd2b0010f3d37/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=14c1e71d095a5500def51d4e405bd2b0010f3d37", "patch": "@@ -31,6 +31,7 @@ use rustc_typeck::hir_ty_to_ty;\n \n use std::assert_matches::assert_matches;\n use std::collections::hash_map::Entry;\n+use std::collections::BTreeMap;\n use std::default::Default;\n use std::hash::Hash;\n use std::{mem, vec};\n@@ -51,9 +52,17 @@ crate trait Clean<T> {\n impl Clean<Item> for DocModule<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let mut items: Vec<Item> = vec![];\n-        items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n+        items.extend(\n+            self.foreigns\n+                .iter()\n+                .map(|(item, renamed)| clean_maybe_renamed_foreign_item(cx, item, *renamed)),\n+        );\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n-        items.extend(self.items.iter().map(|x| x.clean(cx)).flatten());\n+        items.extend(\n+            self.items\n+                .iter()\n+                .flat_map(|(item, renamed)| clean_maybe_renamed_item(cx, item, *renamed)),\n+        );\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -102,11 +111,9 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n                     _ => bug!(\"clean: parenthesized `GenericBound::LangItemTrait`\"),\n                 };\n \n+                let trait_ = clean_trait_ref_with_bindings(cx, trait_ref, &bindings);\n                 GenericBound::TraitBound(\n-                    PolyTrait {\n-                        trait_: (trait_ref, &bindings[..]).clean(cx),\n-                        generic_params: vec![],\n-                    },\n+                    PolyTrait { trait_, generic_params: vec![] },\n                     hir::TraitBoundModifier::None,\n                 )\n             }\n@@ -117,64 +124,60 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n     }\n }\n \n-impl Clean<Path> for (ty::TraitRef<'_>, &[TypeBinding]) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n-        let (trait_ref, bounds) = *self;\n-        let kind = cx.tcx.def_kind(trait_ref.def_id).into();\n-        if !matches!(kind, ItemType::Trait | ItemType::TraitAlias) {\n-            span_bug!(\n-                cx.tcx.def_span(trait_ref.def_id),\n-                \"`TraitRef` had unexpected kind {:?}\",\n-                kind\n-            );\n-        }\n-        inline::record_extern_fqn(cx, trait_ref.def_id, kind);\n-        let path = external_path(cx, trait_ref.def_id, true, bounds.to_vec(), trait_ref.substs);\n+fn clean_trait_ref_with_bindings(\n+    cx: &mut DocContext<'_>,\n+    trait_ref: ty::TraitRef<'_>,\n+    bindings: &[TypeBinding],\n+) -> Path {\n+    let kind = cx.tcx.def_kind(trait_ref.def_id).into();\n+    if !matches!(kind, ItemType::Trait | ItemType::TraitAlias) {\n+        span_bug!(cx.tcx.def_span(trait_ref.def_id), \"`TraitRef` had unexpected kind {:?}\", kind);\n+    }\n+    inline::record_extern_fqn(cx, trait_ref.def_id, kind);\n+    let path = external_path(cx, trait_ref.def_id, true, bindings.to_vec(), trait_ref.substs);\n \n-        debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n+    debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n \n-        path\n-    }\n+    path\n }\n \n impl Clean<Path> for ty::TraitRef<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n-        (*self, &[][..]).clean(cx)\n+        clean_trait_ref_with_bindings(cx, *self, &[])\n     }\n }\n \n-impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n-        let (poly_trait_ref, bounds) = *self;\n-        let poly_trait_ref = poly_trait_ref.lift_to_tcx(cx.tcx).unwrap();\n-\n-        // collect any late bound regions\n-        let late_bound_regions: Vec<_> = cx\n-            .tcx\n-            .collect_referenced_late_bound_regions(&poly_trait_ref)\n-            .into_iter()\n-            .filter_map(|br| match br {\n-                ty::BrNamed(_, name) => Some(GenericParamDef {\n-                    name,\n-                    kind: GenericParamDefKind::Lifetime { outlives: vec![] },\n-                }),\n-                _ => None,\n-            })\n-            .collect();\n+fn clean_poly_trait_ref_with_bindings(\n+    cx: &mut DocContext<'_>,\n+    poly_trait_ref: ty::PolyTraitRef<'_>,\n+    bindings: &[TypeBinding],\n+) -> GenericBound {\n+    let poly_trait_ref = poly_trait_ref.lift_to_tcx(cx.tcx).unwrap();\n+\n+    // collect any late bound regions\n+    let late_bound_regions: Vec<_> = cx\n+        .tcx\n+        .collect_referenced_late_bound_regions(&poly_trait_ref)\n+        .into_iter()\n+        .filter_map(|br| match br {\n+            ty::BrNamed(_, name) => Some(GenericParamDef {\n+                name,\n+                kind: GenericParamDefKind::Lifetime { outlives: vec![] },\n+            }),\n+            _ => None,\n+        })\n+        .collect();\n \n-        GenericBound::TraitBound(\n-            PolyTrait {\n-                trait_: (poly_trait_ref.skip_binder(), bounds).clean(cx),\n-                generic_params: late_bound_regions,\n-            },\n-            hir::TraitBoundModifier::None,\n-        )\n-    }\n+    let trait_ = clean_trait_ref_with_bindings(cx, poly_trait_ref.skip_binder(), bindings);\n+    GenericBound::TraitBound(\n+        PolyTrait { trait_, generic_params: late_bound_regions },\n+        hir::TraitBoundModifier::None,\n+    )\n }\n \n impl<'tcx> Clean<GenericBound> for ty::PolyTraitRef<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n-        (*self, &[][..]).clean(cx)\n+        clean_poly_trait_ref_with_bindings(cx, *self, &[])\n     }\n }\n \n@@ -528,170 +531,164 @@ impl Clean<Generics> for hir::Generics<'_> {\n     }\n }\n \n-impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Generics {\n-        use self::WherePredicate as WP;\n-        use std::collections::BTreeMap;\n-\n-        let (gens, preds) = *self;\n-\n-        // Don't populate `cx.impl_trait_bounds` before `clean`ning `where` clauses,\n-        // since `Clean for ty::Predicate` would consume them.\n-        let mut impl_trait = BTreeMap::<ImplTraitParam, Vec<GenericBound>>::default();\n-\n-        // Bounds in the type_params and lifetimes fields are repeated in the\n-        // predicates field (see rustc_typeck::collect::ty_generics), so remove\n-        // them.\n-        let stripped_params = gens\n-            .params\n-            .iter()\n-            .filter_map(|param| match param.kind {\n-                ty::GenericParamDefKind::Lifetime => Some(param.clean(cx)),\n-                ty::GenericParamDefKind::Type { synthetic, .. } => {\n-                    if param.name == kw::SelfUpper {\n-                        assert_eq!(param.index, 0);\n-                        return None;\n-                    }\n-                    if synthetic {\n-                        impl_trait.insert(param.index.into(), vec![]);\n-                        return None;\n-                    }\n-                    Some(param.clean(cx))\n+fn clean_ty_generics(\n+    cx: &mut DocContext<'_>,\n+    gens: &ty::Generics,\n+    preds: ty::GenericPredicates<'tcx>,\n+) -> Generics {\n+    // Don't populate `cx.impl_trait_bounds` before `clean`ning `where` clauses,\n+    // since `Clean for ty::Predicate` would consume them.\n+    let mut impl_trait = BTreeMap::<ImplTraitParam, Vec<GenericBound>>::default();\n+\n+    // Bounds in the type_params and lifetimes fields are repeated in the\n+    // predicates field (see rustc_typeck::collect::ty_generics), so remove\n+    // them.\n+    let stripped_params = gens\n+        .params\n+        .iter()\n+        .filter_map(|param| match param.kind {\n+            ty::GenericParamDefKind::Lifetime => Some(param.clean(cx)),\n+            ty::GenericParamDefKind::Type { synthetic, .. } => {\n+                if param.name == kw::SelfUpper {\n+                    assert_eq!(param.index, 0);\n+                    return None;\n                 }\n-                ty::GenericParamDefKind::Const { .. } => Some(param.clean(cx)),\n-            })\n-            .collect::<Vec<GenericParamDef>>();\n+                if synthetic {\n+                    impl_trait.insert(param.index.into(), vec![]);\n+                    return None;\n+                }\n+                Some(param.clean(cx))\n+            }\n+            ty::GenericParamDefKind::Const { .. } => Some(param.clean(cx)),\n+        })\n+        .collect::<Vec<GenericParamDef>>();\n \n-        // param index -> [(DefId of trait, associated type name, type)]\n-        let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, Symbol, Ty<'tcx>)>>::default();\n+    // param index -> [(DefId of trait, associated type name, type)]\n+    let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, Symbol, Ty<'tcx>)>>::default();\n \n-        let where_predicates = preds\n-            .predicates\n-            .iter()\n-            .flat_map(|(p, _)| {\n-                let mut projection = None;\n-                let param_idx = (|| {\n-                    let bound_p = p.kind();\n-                    match bound_p.skip_binder() {\n-                        ty::PredicateKind::Trait(pred) => {\n-                            if let ty::Param(param) = pred.self_ty().kind() {\n-                                return Some(param.index);\n-                            }\n-                        }\n-                        ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n-                            if let ty::Param(param) = ty.kind() {\n-                                return Some(param.index);\n-                            }\n+    let where_predicates = preds\n+        .predicates\n+        .iter()\n+        .flat_map(|(p, _)| {\n+            let mut projection = None;\n+            let param_idx = (|| {\n+                let bound_p = p.kind();\n+                match bound_p.skip_binder() {\n+                    ty::PredicateKind::Trait(pred) => {\n+                        if let ty::Param(param) = pred.self_ty().kind() {\n+                            return Some(param.index);\n                         }\n-                        ty::PredicateKind::Projection(p) => {\n-                            if let ty::Param(param) = p.projection_ty.self_ty().kind() {\n-                                projection = Some(bound_p.rebind(p));\n-                                return Some(param.index);\n-                            }\n+                    }\n+                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+                        if let ty::Param(param) = ty.kind() {\n+                            return Some(param.index);\n                         }\n-                        _ => (),\n                     }\n-\n-                    None\n-                })();\n-\n-                if let Some(param_idx) = param_idx {\n-                    if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n-                        let p = p.clean(cx)?;\n-\n-                        b.extend(\n-                            p.get_bounds()\n-                                .into_iter()\n-                                .flatten()\n-                                .cloned()\n-                                .filter(|b| !b.is_sized_bound(cx)),\n-                        );\n-\n-                        let proj = projection\n-                            .map(|p| (p.skip_binder().projection_ty.clean(cx), p.skip_binder().ty));\n-                        if let Some(((_, trait_did, name), rhs)) =\n-                            proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n-                        {\n-                            impl_trait_proj\n-                                .entry(param_idx)\n-                                .or_default()\n-                                .push((trait_did, name, rhs));\n+                    ty::PredicateKind::Projection(p) => {\n+                        if let ty::Param(param) = p.projection_ty.self_ty().kind() {\n+                            projection = Some(bound_p.rebind(p));\n+                            return Some(param.index);\n                         }\n-\n-                        return None;\n                     }\n+                    _ => (),\n                 }\n \n-                Some(p)\n-            })\n-            .collect::<Vec<_>>();\n-\n-        for (param, mut bounds) in impl_trait {\n-            // Move trait bounds to the front.\n-            bounds.sort_by_key(|b| !matches!(b, GenericBound::TraitBound(..)));\n-\n-            if let crate::core::ImplTraitParam::ParamIndex(idx) = param {\n-                if let Some(proj) = impl_trait_proj.remove(&idx) {\n-                    for (trait_did, name, rhs) in proj {\n-                        let rhs = rhs.clean(cx);\n-                        simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs);\n+                None\n+            })();\n+\n+            if let Some(param_idx) = param_idx {\n+                if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n+                    let p = p.clean(cx)?;\n+\n+                    b.extend(\n+                        p.get_bounds()\n+                            .into_iter()\n+                            .flatten()\n+                            .cloned()\n+                            .filter(|b| !b.is_sized_bound(cx)),\n+                    );\n+\n+                    let proj = projection\n+                        .map(|p| (p.skip_binder().projection_ty.clean(cx), p.skip_binder().ty));\n+                    if let Some(((_, trait_did, name), rhs)) =\n+                        proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n+                    {\n+                        impl_trait_proj.entry(param_idx).or_default().push((trait_did, name, rhs));\n                     }\n+\n+                    return None;\n                 }\n-            } else {\n-                unreachable!();\n             }\n \n-            cx.impl_trait_bounds.insert(param, bounds);\n-        }\n+            Some(p)\n+        })\n+        .collect::<Vec<_>>();\n \n-        // Now that `cx.impl_trait_bounds` is populated, we can process\n-        // remaining predicates which could contain `impl Trait`.\n-        let mut where_predicates =\n-            where_predicates.into_iter().flat_map(|p| p.clean(cx)).collect::<Vec<_>>();\n-\n-        // Type parameters have a Sized bound by default unless removed with\n-        // ?Sized. Scan through the predicates and mark any type parameter with\n-        // a Sized bound, removing the bounds as we find them.\n-        //\n-        // Note that associated types also have a sized bound by default, but we\n-        // don't actually know the set of associated types right here so that's\n-        // handled in cleaning associated types\n-        let mut sized_params = FxHashSet::default();\n-        where_predicates.retain(|pred| match *pred {\n-            WP::BoundPredicate { ty: Generic(ref g), ref bounds, .. } => {\n-                if bounds.iter().any(|b| b.is_sized_bound(cx)) {\n-                    sized_params.insert(*g);\n-                    false\n-                } else {\n-                    true\n+    for (param, mut bounds) in impl_trait {\n+        // Move trait bounds to the front.\n+        bounds.sort_by_key(|b| !matches!(b, GenericBound::TraitBound(..)));\n+\n+        if let crate::core::ImplTraitParam::ParamIndex(idx) = param {\n+            if let Some(proj) = impl_trait_proj.remove(&idx) {\n+                for (trait_did, name, rhs) in proj {\n+                    let rhs = rhs.clean(cx);\n+                    simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs);\n                 }\n             }\n-            _ => true,\n-        });\n+        } else {\n+            unreachable!();\n+        }\n \n-        // Run through the type parameters again and insert a ?Sized\n-        // unbound for any we didn't find to be Sized.\n-        for tp in &stripped_params {\n-            if matches!(tp.kind, types::GenericParamDefKind::Type { .. })\n-                && !sized_params.contains(&tp.name)\n-            {\n-                where_predicates.push(WP::BoundPredicate {\n-                    ty: Type::Generic(tp.name),\n-                    bounds: vec![GenericBound::maybe_sized(cx)],\n-                    bound_params: Vec::new(),\n-                })\n+        cx.impl_trait_bounds.insert(param, bounds);\n+    }\n+\n+    // Now that `cx.impl_trait_bounds` is populated, we can process\n+    // remaining predicates which could contain `impl Trait`.\n+    let mut where_predicates =\n+        where_predicates.into_iter().flat_map(|p| p.clean(cx)).collect::<Vec<_>>();\n+\n+    // Type parameters have a Sized bound by default unless removed with\n+    // ?Sized. Scan through the predicates and mark any type parameter with\n+    // a Sized bound, removing the bounds as we find them.\n+    //\n+    // Note that associated types also have a sized bound by default, but we\n+    // don't actually know the set of associated types right here so that's\n+    // handled in cleaning associated types\n+    let mut sized_params = FxHashSet::default();\n+    where_predicates.retain(|pred| match *pred {\n+        WherePredicate::BoundPredicate { ty: Generic(ref g), ref bounds, .. } => {\n+            if bounds.iter().any(|b| b.is_sized_bound(cx)) {\n+                sized_params.insert(*g);\n+                false\n+            } else {\n+                true\n             }\n         }\n+        _ => true,\n+    });\n \n-        // It would be nice to collect all of the bounds on a type and recombine\n-        // them if possible, to avoid e.g., `where T: Foo, T: Bar, T: Sized, T: 'a`\n-        // and instead see `where T: Foo + Bar + Sized + 'a`\n-\n-        Generics {\n-            params: stripped_params,\n-            where_predicates: simplify::where_clauses(cx, where_predicates),\n+    // Run through the type parameters again and insert a ?Sized\n+    // unbound for any we didn't find to be Sized.\n+    for tp in &stripped_params {\n+        if matches!(tp.kind, types::GenericParamDefKind::Type { .. })\n+            && !sized_params.contains(&tp.name)\n+        {\n+            where_predicates.push(WherePredicate::BoundPredicate {\n+                ty: Type::Generic(tp.name),\n+                bounds: vec![GenericBound::maybe_sized(cx)],\n+                bound_params: Vec::new(),\n+            })\n         }\n     }\n+\n+    // It would be nice to collect all of the bounds on a type and recombine\n+    // them if possible, to avoid e.g., `where T: Foo, T: Bar, T: Sized, T: 'a`\n+    // and instead see `where T: Foo + Bar + Sized + 'a`\n+\n+    Generics {\n+        params: stripped_params,\n+        where_predicates: simplify::where_clauses(cx, where_predicates),\n+    }\n }\n \n fn clean_fn_or_proc_macro(\n@@ -741,7 +738,7 @@ fn clean_fn_or_proc_macro(\n             ProcMacroItem(ProcMacro { kind, helpers })\n         }\n         None => {\n-            let mut func = (sig, generics, body_id).clean(cx);\n+            let mut func = clean_function(cx, sig, generics, body_id);\n             let def_id = item.def_id.to_def_id();\n             func.header.constness =\n                 if cx.tcx.is_const_fn(def_id) && is_unstable_const_fn(cx.tcx, def_id).is_none() {\n@@ -785,54 +782,59 @@ fn clean_fn_decl_legacy_const_generics(func: &mut Function, attrs: &[ast::Attrib\n     }\n }\n \n-impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Function {\n-        let (generics, decl) = enter_impl_trait(cx, |cx| {\n-            // NOTE: generics must be cleaned before args\n-            let generics = self.1.clean(cx);\n-            let args = (self.0.decl.inputs, self.2).clean(cx);\n-            let decl = clean_fn_decl_with_args(cx, self.0.decl, args);\n-            (generics, decl)\n-        });\n-        Function { decl, generics, header: self.0.header }\n-    }\n+fn clean_function(\n+    cx: &mut DocContext<'_>,\n+    sig: &hir::FnSig<'_>,\n+    generics: &hir::Generics<'_>,\n+    body_id: hir::BodyId,\n+) -> Function {\n+    let (generics, decl) = enter_impl_trait(cx, |cx| {\n+        // NOTE: generics must be cleaned before args\n+        let generics = generics.clean(cx);\n+        let args = clean_args_from_types_and_body_id(cx, sig.decl.inputs, body_id);\n+        let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n+        (generics, decl)\n+    });\n+    Function { decl, generics, header: sig.header }\n }\n \n-impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Arguments {\n-        Arguments {\n-            values: self\n-                .0\n-                .iter()\n-                .enumerate()\n-                .map(|(i, ty)| {\n-                    let mut name = self.1.get(i).map_or(kw::Empty, |ident| ident.name);\n-                    if name.is_empty() {\n-                        name = kw::Underscore;\n-                    }\n-                    Argument { name, type_: ty.clean(cx), is_const: false }\n-                })\n-                .collect(),\n-        }\n+fn clean_args_from_types_and_names(\n+    cx: &mut DocContext<'_>,\n+    types: &[hir::Ty<'_>],\n+    names: &[Ident],\n+) -> Arguments {\n+    Arguments {\n+        values: types\n+            .iter()\n+            .enumerate()\n+            .map(|(i, ty)| {\n+                let mut name = names.get(i).map_or(kw::Empty, |ident| ident.name);\n+                if name.is_empty() {\n+                    name = kw::Underscore;\n+                }\n+                Argument { name, type_: ty.clean(cx), is_const: false }\n+            })\n+            .collect(),\n     }\n }\n \n-impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], hir::BodyId) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Arguments {\n-        let body = cx.tcx.hir().body(self.1);\n+fn clean_args_from_types_and_body_id(\n+    cx: &mut DocContext<'_>,\n+    types: &[hir::Ty<'_>],\n+    body_id: hir::BodyId,\n+) -> Arguments {\n+    let body = cx.tcx.hir().body(body_id);\n \n-        Arguments {\n-            values: self\n-                .0\n-                .iter()\n-                .enumerate()\n-                .map(|(i, ty)| Argument {\n-                    name: name_from_pat(body.params[i].pat),\n-                    type_: ty.clean(cx),\n-                    is_const: false,\n-                })\n-                .collect(),\n-        }\n+    Arguments {\n+        values: types\n+            .iter()\n+            .enumerate()\n+            .map(|(i, ty)| Argument {\n+                name: name_from_pat(body.params[i].pat),\n+                type_: ty.clean(cx),\n+                is_const: false,\n+            })\n+            .collect(),\n     }\n }\n \n@@ -844,27 +846,28 @@ fn clean_fn_decl_with_args(\n     FnDecl { inputs: args, output: decl.output.clean(cx), c_variadic: decl.c_variadic }\n }\n \n-impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> FnDecl {\n-        let (did, sig) = *self;\n-        let mut names = if did.is_local() { &[] } else { cx.tcx.fn_arg_names(did) }.iter();\n-\n-        FnDecl {\n-            output: Return(sig.skip_binder().output().clean(cx)),\n-            c_variadic: sig.skip_binder().c_variadic,\n-            inputs: Arguments {\n-                values: sig\n-                    .skip_binder()\n-                    .inputs()\n-                    .iter()\n-                    .map(|t| Argument {\n-                        type_: t.clean(cx),\n-                        name: names.next().map_or(kw::Empty, |i| i.name),\n-                        is_const: false,\n-                    })\n-                    .collect(),\n-            },\n-        }\n+fn clean_fn_decl_from_did_and_sig(\n+    cx: &mut DocContext<'_>,\n+    did: DefId,\n+    sig: ty::PolyFnSig<'_>,\n+) -> FnDecl {\n+    let mut names = if did.is_local() { &[] } else { cx.tcx.fn_arg_names(did) }.iter();\n+\n+    FnDecl {\n+        output: Return(sig.skip_binder().output().clean(cx)),\n+        c_variadic: sig.skip_binder().c_variadic,\n+        inputs: Arguments {\n+            values: sig\n+                .skip_binder()\n+                .inputs()\n+                .iter()\n+                .map(|t| Argument {\n+                    type_: t.clean(cx),\n+                    name: names.next().map_or(kw::Empty, |i| i.name),\n+                    is_const: false,\n+                })\n+                .collect(),\n+        },\n     }\n }\n \n@@ -912,7 +915,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx.tcx, e)))\n                 }\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                    let mut m = (sig, &self.generics, body).clean(cx);\n+                    let mut m = clean_function(cx, sig, &self.generics, body);\n                     if m.header.constness == hir::Constness::Const\n                         && is_unstable_const_fn(cx.tcx, local_did).is_some()\n                     {\n@@ -924,7 +927,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     let (generics, decl) = enter_impl_trait(cx, |cx| {\n                         // NOTE: generics must be cleaned before args\n                         let generics = self.generics.clean(cx);\n-                        let args = (sig.decl.inputs, names).clean(cx);\n+                        let args = clean_args_from_types_and_names(cx, sig.decl.inputs, names);\n                         let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n                         (generics, decl)\n                     });\n@@ -959,7 +962,7 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                     AssocConstItem(ty.clean(cx), Some(print_const_expr(cx.tcx, expr)))\n                 }\n                 hir::ImplItemKind::Fn(ref sig, body) => {\n-                    let mut m = (sig, &self.generics, body).clean(cx);\n+                    let mut m = clean_function(cx, sig, &self.generics, body);\n                     if m.header.constness == hir::Constness::Const\n                         && is_unstable_const_fn(cx.tcx, local_did).is_some()\n                     {\n@@ -1013,11 +1016,13 @@ impl Clean<Item> for ty::AssocItem {\n                 AssocConstItem(ty.clean(cx), default)\n             }\n             ty::AssocKind::Fn => {\n-                let generics =\n-                    (tcx.generics_of(self.def_id), tcx.explicit_predicates_of(self.def_id))\n-                        .clean(cx);\n+                let generics = clean_ty_generics(\n+                    cx,\n+                    tcx.generics_of(self.def_id),\n+                    tcx.explicit_predicates_of(self.def_id),\n+                );\n                 let sig = tcx.fn_sig(self.def_id);\n-                let mut decl = (self.def_id, sig).clean(cx);\n+                let mut decl = clean_fn_decl_from_did_and_sig(cx, self.def_id, sig);\n \n                 if self.fn_has_self_parameter {\n                     let self_ty = match self.container {\n@@ -1086,7 +1091,7 @@ impl Clean<Item> for ty::AssocItem {\n                 if let ty::TraitContainer(_) = self.container {\n                     let bounds = tcx.explicit_item_bounds(self.def_id);\n                     let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n-                    let generics = (tcx.generics_of(self.def_id), predicates).clean(cx);\n+                    let generics = clean_ty_generics(cx, tcx.generics_of(self.def_id), predicates);\n                     let mut bounds = generics\n                         .where_predicates\n                         .iter()\n@@ -1411,10 +1416,11 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let ty = cx.tcx.lift(*self).expect(\"FnPtr lift failed\");\n                 let sig = ty.fn_sig(cx.tcx);\n                 let def_id = DefId::local(CRATE_DEF_INDEX);\n+                let decl = clean_fn_decl_from_did_and_sig(cx, def_id, sig);\n                 BareFunction(box BareFunctionDecl {\n                     unsafety: sig.unsafety(),\n                     generic_params: Vec::new(),\n-                    decl: (def_id, sig).clean(cx),\n+                    decl,\n                     abi: sig.abi(),\n                 })\n             }\n@@ -1520,7 +1526,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             }\n                         }\n \n-                        let bounds: Vec<_> = bounds\n+                        let bindings: Vec<_> = bounds\n                             .iter()\n                             .filter_map(|bound| {\n                                 if let ty::PredicateKind::Projection(proj) =\n@@ -1548,7 +1554,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             })\n                             .collect();\n \n-                        Some((trait_ref, &bounds[..]).clean(cx))\n+                        Some(clean_poly_trait_ref_with_bindings(cx, trait_ref, &bindings))\n                     })\n                     .collect::<Vec<_>>();\n                 bounds.extend(regions);\n@@ -1720,102 +1726,101 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n             // NOTE: generics must be cleaned before args\n             let generic_params = self.generic_params.iter().map(|x| x.clean(cx)).collect();\n-            let args = (self.decl.inputs, self.param_names).clean(cx);\n+            let args = clean_args_from_types_and_names(cx, self.decl.inputs, self.param_names);\n             let decl = clean_fn_decl_with_args(cx, self.decl, args);\n             (generic_params, decl)\n         });\n         BareFunctionDecl { unsafety: self.unsafety, abi: self.abi, decl, generic_params }\n     }\n }\n \n-impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<Item> {\n-        use hir::ItemKind;\n-\n-        let (item, renamed) = self;\n-        let def_id = item.def_id.to_def_id();\n-        let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n-        cx.with_param_env(def_id, |cx| {\n-            let kind = match item.kind {\n-                ItemKind::Static(ty, mutability, body_id) => {\n-                    StaticItem(Static { type_: ty.clean(cx), mutability, expr: Some(body_id) })\n-                }\n-                ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n-                    type_: ty.clean(cx),\n-                    kind: ConstantKind::Local { body: body_id, def_id },\n-                }),\n-                ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n-                    bounds: ty.bounds.iter().map(|x| x.clean(cx)).collect(),\n-                    generics: ty.generics.clean(cx),\n-                }),\n-                ItemKind::TyAlias(hir_ty, ref generics) => {\n-                    let rustdoc_ty = hir_ty.clean(cx);\n-                    let ty = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n-                    TypedefItem(\n-                        Typedef {\n-                            type_: rustdoc_ty,\n-                            generics: generics.clean(cx),\n-                            item_type: Some(ty),\n-                        },\n-                        false,\n-                    )\n-                }\n-                ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n-                    variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n-                    generics: generics.clean(cx),\n-                    variants_stripped: false,\n-                }),\n-                ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n+fn clean_maybe_renamed_item(\n+    cx: &mut DocContext<'_>,\n+    item: &hir::Item<'_>,\n+    renamed: Option<Symbol>,\n+) -> Vec<Item> {\n+    use hir::ItemKind;\n+\n+    let def_id = item.def_id.to_def_id();\n+    let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n+    cx.with_param_env(def_id, |cx| {\n+        let kind = match item.kind {\n+            ItemKind::Static(ty, mutability, body_id) => {\n+                StaticItem(Static { type_: ty.clean(cx), mutability, expr: Some(body_id) })\n+            }\n+            ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n+                type_: ty.clean(cx),\n+                kind: ConstantKind::Local { body: body_id, def_id },\n+            }),\n+            ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n+                bounds: ty.bounds.iter().map(|x| x.clean(cx)).collect(),\n+                generics: ty.generics.clean(cx),\n+            }),\n+            ItemKind::TyAlias(hir_ty, ref generics) => {\n+                let rustdoc_ty = hir_ty.clean(cx);\n+                let ty = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n+                TypedefItem(\n+                    Typedef {\n+                        type_: rustdoc_ty,\n+                        generics: generics.clean(cx),\n+                        item_type: Some(ty),\n+                    },\n+                    false,\n+                )\n+            }\n+            ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n+                variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n+                generics: generics.clean(cx),\n+                variants_stripped: false,\n+            }),\n+            ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n+                generics: generics.clean(cx),\n+                bounds: bounds.iter().map(|x| x.clean(cx)).collect(),\n+            }),\n+            ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n+                generics: generics.clean(cx),\n+                fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n+                fields_stripped: false,\n+            }),\n+            ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n+                struct_type: CtorKind::from_hir(variant_data),\n+                generics: generics.clean(cx),\n+                fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n+                fields_stripped: false,\n+            }),\n+            ItemKind::Impl(ref impl_) => return clean_impl(impl_, item.hir_id(), cx),\n+            // proc macros can have a name set by attributes\n+            ItemKind::Fn(ref sig, ref generics, body_id) => {\n+                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n+            }\n+            ItemKind::Macro(ref macro_def) => {\n+                let ty_vis = cx.tcx.visibility(def_id).clean(cx);\n+                MacroItem(Macro {\n+                    source: display_macro_source(cx, name, macro_def, def_id, ty_vis),\n+                })\n+            }\n+            ItemKind::Trait(is_auto, unsafety, ref generics, bounds, item_ids) => {\n+                let items =\n+                    item_ids.iter().map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx)).collect();\n+                TraitItem(Trait {\n+                    unsafety,\n+                    items,\n                     generics: generics.clean(cx),\n                     bounds: bounds.iter().map(|x| x.clean(cx)).collect(),\n-                }),\n-                ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n-                    generics: generics.clean(cx),\n-                    fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n-                    fields_stripped: false,\n-                }),\n-                ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n-                    struct_type: CtorKind::from_hir(variant_data),\n-                    generics: generics.clean(cx),\n-                    fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n-                    fields_stripped: false,\n-                }),\n-                ItemKind::Impl(ref impl_) => return clean_impl(impl_, item.hir_id(), cx),\n-                // proc macros can have a name set by attributes\n-                ItemKind::Fn(ref sig, ref generics, body_id) => {\n-                    clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n-                }\n-                ItemKind::Macro(ref macro_def) => {\n-                    let ty_vis = cx.tcx.visibility(def_id).clean(cx);\n-                    MacroItem(Macro {\n-                        source: display_macro_source(cx, name, macro_def, def_id, ty_vis),\n-                    })\n-                }\n-                ItemKind::Trait(is_auto, unsafety, ref generics, bounds, item_ids) => {\n-                    let items = item_ids\n-                        .iter()\n-                        .map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx))\n-                        .collect();\n-                    TraitItem(Trait {\n-                        unsafety,\n-                        items,\n-                        generics: generics.clean(cx),\n-                        bounds: bounds.iter().map(|x| x.clean(cx)).collect(),\n-                        is_auto: is_auto.clean(cx),\n-                    })\n-                }\n-                ItemKind::ExternCrate(orig_name) => {\n-                    return clean_extern_crate(item, name, orig_name, cx);\n-                }\n-                ItemKind::Use(path, kind) => {\n-                    return clean_use_statement(item, name, path, kind, cx);\n-                }\n-                _ => unreachable!(\"not yet converted\"),\n-            };\n+                    is_auto: is_auto.clean(cx),\n+                })\n+            }\n+            ItemKind::ExternCrate(orig_name) => {\n+                return clean_extern_crate(item, name, orig_name, cx);\n+            }\n+            ItemKind::Use(path, kind) => {\n+                return clean_use_statement(item, name, path, kind, cx);\n+            }\n+            _ => unreachable!(\"not yet converted\"),\n+        };\n \n-            vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n-        })\n-    }\n+        vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n+    })\n }\n \n impl Clean<Item> for hir::Variant<'_> {\n@@ -2029,50 +2034,51 @@ fn clean_use_statement(\n     vec![Item::from_def_id_and_parts(import.def_id.to_def_id(), None, ImportItem(inner), cx)]\n }\n \n-impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n-        let (item, renamed) = self;\n-        let def_id = item.def_id.to_def_id();\n-        cx.with_param_env(def_id, |cx| {\n-            let kind = match item.kind {\n-                hir::ForeignItemKind::Fn(decl, names, ref generics) => {\n-                    let abi = cx.tcx.hir().get_foreign_abi(item.hir_id());\n-                    let (generics, decl) = enter_impl_trait(cx, |cx| {\n-                        // NOTE: generics must be cleaned before args\n-                        let generics = generics.clean(cx);\n-                        let args = (decl.inputs, names).clean(cx);\n-                        let decl = clean_fn_decl_with_args(cx, decl, args);\n-                        (generics, decl)\n-                    });\n-                    ForeignFunctionItem(Function {\n-                        decl,\n-                        generics,\n-                        header: hir::FnHeader {\n-                            unsafety: if abi == Abi::RustIntrinsic {\n-                                intrinsic_operation_unsafety(item.ident.name)\n-                            } else {\n-                                hir::Unsafety::Unsafe\n-                            },\n-                            abi,\n-                            constness: hir::Constness::NotConst,\n-                            asyncness: hir::IsAsync::NotAsync,\n+fn clean_maybe_renamed_foreign_item(\n+    cx: &mut DocContext<'_>,\n+    item: &hir::ForeignItem<'_>,\n+    renamed: Option<Symbol>,\n+) -> Item {\n+    let def_id = item.def_id.to_def_id();\n+    cx.with_param_env(def_id, |cx| {\n+        let kind = match item.kind {\n+            hir::ForeignItemKind::Fn(decl, names, ref generics) => {\n+                let abi = cx.tcx.hir().get_foreign_abi(item.hir_id());\n+                let (generics, decl) = enter_impl_trait(cx, |cx| {\n+                    // NOTE: generics must be cleaned before args\n+                    let generics = generics.clean(cx);\n+                    let args = clean_args_from_types_and_names(cx, decl.inputs, names);\n+                    let decl = clean_fn_decl_with_args(cx, decl, args);\n+                    (generics, decl)\n+                });\n+                ForeignFunctionItem(Function {\n+                    decl,\n+                    generics,\n+                    header: hir::FnHeader {\n+                        unsafety: if abi == Abi::RustIntrinsic {\n+                            intrinsic_operation_unsafety(item.ident.name)\n+                        } else {\n+                            hir::Unsafety::Unsafe\n                         },\n-                    })\n-                }\n-                hir::ForeignItemKind::Static(ref ty, mutability) => {\n-                    ForeignStaticItem(Static { type_: ty.clean(cx), mutability, expr: None })\n-                }\n-                hir::ForeignItemKind::Type => ForeignTypeItem,\n-            };\n+                        abi,\n+                        constness: hir::Constness::NotConst,\n+                        asyncness: hir::IsAsync::NotAsync,\n+                    },\n+                })\n+            }\n+            hir::ForeignItemKind::Static(ref ty, mutability) => {\n+                ForeignStaticItem(Static { type_: ty.clean(cx), mutability, expr: None })\n+            }\n+            hir::ForeignItemKind::Type => ForeignTypeItem,\n+        };\n \n-            Item::from_hir_id_and_parts(\n-                item.hir_id(),\n-                Some(renamed.unwrap_or(item.ident.name)),\n-                kind,\n-                cx,\n-            )\n-        })\n-    }\n+        Item::from_hir_id_and_parts(\n+            item.hir_id(),\n+            Some(renamed.unwrap_or(item.ident.name)),\n+            kind,\n+            cx,\n+        )\n+    })\n }\n \n impl Clean<TypeBinding> for hir::TypeBinding<'_> {"}]}