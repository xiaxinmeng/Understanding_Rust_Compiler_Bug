{"sha": "1880d783b73387c1baac9e5cb0167d7a0f6e768c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ODBkNzgzYjczMzg3YzFiYWFjOWU1Y2IwMTY3ZDdhMGY2ZTc2OGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-27T01:46:12Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-27T01:46:48Z"}, "message": "libcore: Partially de-export int-template and uint-template", "tree": {"sha": "b1249cf0ff781ae208d45c532706a58abeeddff8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1249cf0ff781ae208d45c532706a58abeeddff8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1880d783b73387c1baac9e5cb0167d7a0f6e768c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1880d783b73387c1baac9e5cb0167d7a0f6e768c", "html_url": "https://github.com/rust-lang/rust/commit/1880d783b73387c1baac9e5cb0167d7a0f6e768c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1880d783b73387c1baac9e5cb0167d7a0f6e768c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52c3cf296b637d66d185c2304f15f65aa55bb484", "url": "https://api.github.com/repos/rust-lang/rust/commits/52c3cf296b637d66d185c2304f15f65aa55bb484", "html_url": "https://github.com/rust-lang/rust/commit/52c3cf296b637d66d185c2304f15f65aa55bb484"}], "stats": {"total": 152, "additions": 82, "deletions": 70}, "files": [{"sha": "d3a41d3d395fb6fc99ae4887c22ff0dd9def8882", "filename": "src/libcore/core.rc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1880d783b73387c1baac9e5cb0167d7a0f6e768c/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1880d783b73387c1baac9e5cb0167d7a0f6e768c/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=1880d783b73387c1baac9e5cb0167d7a0f6e768c", "patch": "@@ -83,6 +83,7 @@ export private;\n // Built-in-type support modules\n \n /// Operations and constants for `int`\n+#[legacy_exports]\n #[path = \"int-template\"]\n mod int {\n     #[legacy_exports];\n@@ -94,6 +95,7 @@ mod int {\n }\n \n /// Operations and constants for `i8`\n+#[legacy_exports]\n #[path = \"int-template\"]\n mod i8 {\n     #[legacy_exports];\n@@ -103,6 +105,7 @@ mod i8 {\n }\n \n /// Operations and constants for `i16`\n+#[legacy_exports]\n #[path = \"int-template\"]\n mod i16 {\n     #[legacy_exports];\n@@ -112,6 +115,7 @@ mod i16 {\n }\n \n /// Operations and constants for `i32`\n+#[legacy_exports]\n #[path = \"int-template\"]\n mod i32 {\n     #[legacy_exports];\n@@ -121,6 +125,7 @@ mod i32 {\n }\n \n /// Operations and constants for `i64`\n+#[legacy_exports]\n #[path = \"int-template\"]\n mod i64 {\n     #[legacy_exports];\n@@ -130,6 +135,7 @@ mod i64 {\n }\n \n /// Operations and constants for `uint`\n+#[legacy_exports]\n #[path = \"uint-template\"]\n mod uint {\n     #[legacy_exports];\n@@ -146,6 +152,7 @@ mod uint {\n }\n \n /// Operations and constants for `u8`\n+#[legacy_exports]\n #[path = \"uint-template\"]\n mod u8 {\n     #[legacy_exports];\n@@ -158,6 +165,7 @@ mod u8 {\n }\n \n /// Operations and constants for `u16`\n+#[legacy_exports]\n #[path = \"uint-template\"]\n mod u16 {\n     #[legacy_exports];\n@@ -167,6 +175,7 @@ mod u16 {\n }\n \n /// Operations and constants for `u32`\n+#[legacy_exports]\n #[path = \"uint-template\"]\n mod u32 {\n     #[legacy_exports];\n@@ -176,6 +185,7 @@ mod u32 {\n }\n \n /// Operations and constants for `u64`\n+#[legacy_exports]\n #[path = \"uint-template\"]\n mod u64 {\n     #[legacy_exports];"}, {"sha": "d24a10be6ce5cc9974e4bbcda158cc200e705936", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1880d783b73387c1baac9e5cb0167d7a0f6e768c/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1880d783b73387c1baac9e5cb0167d7a0f6e768c/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=1880d783b73387c1baac9e5cb0167d7a0f6e768c", "patch": "@@ -19,37 +19,38 @@ export abs;\n export parse_bytes, from_str, to_str, to_str_bytes, str;\n export num, ord, eq, times, timesi;\n export bits, bytes;\n+export str;\n \n-const bits : uint = inst::bits;\n-const bytes : uint = (inst::bits / 8);\n+pub const bits : uint = inst::bits;\n+pub const bytes : uint = (inst::bits / 8);\n \n-const min_value: T = (-1 as T) << (bits - 1);\n-const max_value: T = min_value - 1 as T;\n+pub const min_value: T = (-1 as T) << (bits - 1);\n+pub const max_value: T = min_value - 1 as T;\n \n-pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n-pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n+pub pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n+pub pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n \n-pure fn add(x: T, y: T) -> T { x + y }\n-pure fn sub(x: T, y: T) -> T { x - y }\n-pure fn mul(x: T, y: T) -> T { x * y }\n-pure fn div(x: T, y: T) -> T { x / y }\n-pure fn rem(x: T, y: T) -> T { x % y }\n+pub pure fn add(x: T, y: T) -> T { x + y }\n+pub pure fn sub(x: T, y: T) -> T { x - y }\n+pub pure fn mul(x: T, y: T) -> T { x * y }\n+pub pure fn div(x: T, y: T) -> T { x / y }\n+pub pure fn rem(x: T, y: T) -> T { x % y }\n \n-pure fn lt(x: T, y: T) -> bool { x < y }\n-pure fn le(x: T, y: T) -> bool { x <= y }\n-pure fn eq(x: T, y: T) -> bool { x == y }\n-pure fn ne(x: T, y: T) -> bool { x != y }\n-pure fn ge(x: T, y: T) -> bool { x >= y }\n-pure fn gt(x: T, y: T) -> bool { x > y }\n+pub pure fn lt(x: T, y: T) -> bool { x < y }\n+pub pure fn le(x: T, y: T) -> bool { x <= y }\n+pub pure fn eq(x: T, y: T) -> bool { x == y }\n+pub pure fn ne(x: T, y: T) -> bool { x != y }\n+pub pure fn ge(x: T, y: T) -> bool { x >= y }\n+pub pure fn gt(x: T, y: T) -> bool { x > y }\n \n-pure fn is_positive(x: T) -> bool { x > 0 as T }\n-pure fn is_negative(x: T) -> bool { x < 0 as T }\n-pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n-pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n+pub pure fn is_positive(x: T) -> bool { x > 0 as T }\n+pub pure fn is_negative(x: T) -> bool { x < 0 as T }\n+pub pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n+pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-fn range(lo: T, hi: T, it: fn(T) -> bool) {\n+pub fn range(lo: T, hi: T, it: fn(T) -> bool) {\n     let mut i = lo;\n     while i < hi {\n         if !it(i) { break }\n@@ -58,13 +59,13 @@ fn range(lo: T, hi: T, it: fn(T) -> bool) {\n }\n \n /// Computes the bitwise complement\n-pure fn compl(i: T) -> T {\n+pub pure fn compl(i: T) -> T {\n     -1 as T ^ i\n }\n \n /// Computes the absolute value\n // FIXME: abs should return an unsigned int (#2353)\n-pure fn abs(i: T) -> T {\n+pub pure fn abs(i: T) -> T {\n     if is_negative(i) { -i } else { i }\n }\n \n@@ -137,7 +138,7 @@ impl T: iter::TimesIx {\n  * * buf - A byte buffer\n  * * radix - The base of the number\n  */\n-fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n+pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n     if vec::len(buf) == 0u { return None; }\n     let mut i = vec::len(buf) - 1u;\n     let mut start = 0u;\n@@ -160,22 +161,22 @@ fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n }\n \n /// Parse a string to an int\n-fn from_str(s: &str) -> Option<T> { parse_bytes(str::to_bytes(s), 10u) }\n+pub fn from_str(s: &str) -> Option<T> { parse_bytes(str::to_bytes(s), 10u) }\n \n impl T : FromStr {\n     static fn from_str(s: &str) -> Option<T> { from_str(s) }\n }\n \n /// Convert to a string in a given base\n-fn to_str(n: T, radix: uint) -> ~str {\n+pub fn to_str(n: T, radix: uint) -> ~str {\n     do to_str_bytes(n, radix) |slice| {\n         do vec::as_imm_buf(slice) |p, len| {\n             unsafe { str::raw::from_buf_len(p, len) }\n         }\n     }\n }\n \n-fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n     if n < 0 as T {\n         uint::to_str_bytes(true, -n as uint, radix, f)\n     } else {\n@@ -184,12 +185,12 @@ fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n }\n \n /// Convert to a string\n-fn str(i: T) -> ~str { return to_str(i, 10u); }\n+pub fn str(i: T) -> ~str { return to_str(i, 10u); }\n \n // FIXME: Has alignment issues on windows and 32-bit linux (#2609)\n #[test]\n #[ignore]\n-fn test_from_str() {\n+pub fn test_from_str() {\n     assert from_str(~\"0\") == Some(0 as T);\n     assert from_str(~\"3\") == Some(3 as T);\n     assert from_str(~\"10\") == Some(10 as T);\n@@ -209,7 +210,7 @@ fn test_from_str() {\n // FIXME: Has alignment issues on windows and 32-bit linux (#2609)\n #[test]\n #[ignore]\n-fn test_parse_bytes() {\n+pub fn test_parse_bytes() {\n     use str::to_bytes;\n     assert parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T);\n     assert parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T);\n@@ -234,7 +235,7 @@ fn test_parse_bytes() {\n }\n \n #[test]\n-fn test_to_str() {\n+pub fn test_to_str() {\n     assert (to_str(0 as T, 10u) == ~\"0\");\n     assert (to_str(1 as T, 10u) == ~\"1\");\n     assert (to_str(-1 as T, 10u) == ~\"-1\");\n@@ -243,7 +244,7 @@ fn test_to_str() {\n }\n \n #[test]\n-fn test_interfaces() {\n+pub fn test_interfaces() {\n     fn test<U:num::Num cmp::Eq>(+ten: U) {\n         assert (ten.to_int() == 10);\n \n@@ -262,7 +263,7 @@ fn test_interfaces() {\n }\n \n #[test]\n-fn test_times() {\n+pub fn test_times() {\n     use iter::Times;\n     let ten = 10 as T;\n     let mut accum = 0;\n@@ -273,7 +274,7 @@ fn test_times() {\n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-fn test_times_negative() {\n+pub fn test_times_negative() {\n     use iter::Times;\n     for (-10).times { log(error, ~\"nope!\"); }\n }"}, {"sha": "6757946c33472cd3d03eb0005104233fbd7599a3", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1880d783b73387c1baac9e5cb0167d7a0f6e768c/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1880d783b73387c1baac9e5cb0167d7a0f6e768c/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=1880d783b73387c1baac9e5cb0167d7a0f6e768c", "patch": "@@ -18,37 +18,38 @@ export to_str, to_str_bytes;\n export from_str, from_str_radix, str, parse_bytes;\n export num, ord, eq, times, timesi;\n export bits, bytes;\n+export str;\n \n-const bits : uint = inst::bits;\n-const bytes : uint = (inst::bits / 8);\n+pub const bits : uint = inst::bits;\n+pub const bytes : uint = (inst::bits / 8);\n \n-const min_value: T = 0 as T;\n-const max_value: T = 0 as T - 1 as T;\n+pub const min_value: T = 0 as T;\n+pub const max_value: T = 0 as T - 1 as T;\n \n-pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n-pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n+pub pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n+pub pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n \n-pure fn add(x: T, y: T) -> T { x + y }\n-pure fn sub(x: T, y: T) -> T { x - y }\n-pure fn mul(x: T, y: T) -> T { x * y }\n-pure fn div(x: T, y: T) -> T { x / y }\n-pure fn rem(x: T, y: T) -> T { x % y }\n+pub pure fn add(x: T, y: T) -> T { x + y }\n+pub pure fn sub(x: T, y: T) -> T { x - y }\n+pub pure fn mul(x: T, y: T) -> T { x * y }\n+pub pure fn div(x: T, y: T) -> T { x / y }\n+pub pure fn rem(x: T, y: T) -> T { x % y }\n \n-pure fn lt(x: T, y: T) -> bool { x < y }\n-pure fn le(x: T, y: T) -> bool { x <= y }\n-pure fn eq(x: T, y: T) -> bool { x == y }\n-pure fn ne(x: T, y: T) -> bool { x != y }\n-pure fn ge(x: T, y: T) -> bool { x >= y }\n-pure fn gt(x: T, y: T) -> bool { x > y }\n+pub pure fn lt(x: T, y: T) -> bool { x < y }\n+pub pure fn le(x: T, y: T) -> bool { x <= y }\n+pub pure fn eq(x: T, y: T) -> bool { x == y }\n+pub pure fn ne(x: T, y: T) -> bool { x != y }\n+pub pure fn ge(x: T, y: T) -> bool { x >= y }\n+pub pure fn gt(x: T, y: T) -> bool { x > y }\n \n-pure fn is_positive(x: T) -> bool { x > 0 as T }\n-pure fn is_negative(x: T) -> bool { x < 0 as T }\n-pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n-pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n+pub pure fn is_positive(x: T) -> bool { x > 0 as T }\n+pub pure fn is_negative(x: T) -> bool { x < 0 as T }\n+pub pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n+pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pure fn range(lo: T, hi: T, it: fn(T) -> bool) {\n+pub pure fn range(lo: T, hi: T, it: fn(T) -> bool) {\n     let mut i = lo;\n     while i < hi {\n         if !it(i) { break }\n@@ -57,7 +58,7 @@ pure fn range(lo: T, hi: T, it: fn(T) -> bool) {\n }\n \n /// Computes the bitwise complement\n-pure fn compl(i: T) -> T {\n+pub pure fn compl(i: T) -> T {\n     max_value ^ i\n }\n \n@@ -126,7 +127,7 @@ impl T: iter::TimesIx {\n  *\n  * `buf` must not be empty\n  */\n-fn parse_bytes(buf: &[const u8], radix: uint) -> Option<T> {\n+pub fn parse_bytes(buf: &[const u8], radix: uint) -> Option<T> {\n     if vec::len(buf) == 0u { return None; }\n     let mut i = vec::len(buf) - 1u;\n     let mut power = 1u as T;\n@@ -143,14 +144,14 @@ fn parse_bytes(buf: &[const u8], radix: uint) -> Option<T> {\n }\n \n /// Parse a string to an int\n-fn from_str(s: &str) -> Option<T> { parse_bytes(str::to_bytes(s), 10u) }\n+pub fn from_str(s: &str) -> Option<T> { parse_bytes(str::to_bytes(s), 10u) }\n \n impl T : FromStr {\n     static fn from_str(s: &str) -> Option<T> { from_str(s) }\n }\n \n /// Parse a string as an unsigned integer.\n-fn from_str_radix(buf: &str, radix: u64) -> Option<u64> {\n+pub fn from_str_radix(buf: &str, radix: u64) -> Option<u64> {\n     if str::len(buf) == 0u { return None; }\n     let mut i = str::len(buf) - 1u;\n     let mut power = 1u64, n = 0u64;\n@@ -172,7 +173,7 @@ fn from_str_radix(buf: &str, radix: u64) -> Option<u64> {\n  *\n  * Fails if `radix` < 2 or `radix` > 16\n  */\n-pure fn to_str(num: T, radix: uint) -> ~str {\n+pub pure fn to_str(num: T, radix: uint) -> ~str {\n     do to_str_bytes(false, num, radix) |slice| {\n         do vec::as_imm_buf(slice) |p, len| {\n             unsafe { str::raw::from_buf_len(p, len) }\n@@ -181,7 +182,7 @@ pure fn to_str(num: T, radix: uint) -> ~str {\n }\n \n /// Low-level helper routine for string conversion.\n-pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n+pub pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n                    f: fn(v: &[u8]) -> U) -> U {\n \n     #[inline(always)]\n@@ -246,10 +247,10 @@ pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n }\n \n /// Convert to a string\n-fn str(i: T) -> ~str { return to_str(i, 10u); }\n+pub fn str(i: T) -> ~str { return to_str(i, 10u); }\n \n #[test]\n-fn test_to_str() {\n+pub fn test_to_str() {\n     assert to_str(0 as T, 10u) == ~\"0\";\n     assert to_str(1 as T, 10u) == ~\"1\";\n     assert to_str(2 as T, 10u) == ~\"2\";\n@@ -261,7 +262,7 @@ fn test_to_str() {\n \n #[test]\n #[ignore]\n-fn test_from_str() {\n+pub fn test_from_str() {\n     assert from_str(~\"0\") == Some(0u as T);\n     assert from_str(~\"3\") == Some(3u as T);\n     assert from_str(~\"10\") == Some(10u as T);\n@@ -275,7 +276,7 @@ fn test_from_str() {\n \n #[test]\n #[ignore]\n-fn test_parse_bytes() {\n+pub fn test_parse_bytes() {\n     use str::to_bytes;\n     assert parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T);\n     assert parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T);\n@@ -291,19 +292,19 @@ fn test_parse_bytes() {\n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-fn to_str_radix1() {\n+pub fn to_str_radix1() {\n     uint::to_str(100u, 1u);\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-fn to_str_radix17() {\n+pub fn to_str_radix17() {\n     uint::to_str(100u, 17u);\n }\n \n #[test]\n-fn test_times() {\n+pub fn test_times() {\n     use iter::Times;\n     let ten = 10 as T;\n     let mut accum = 0;"}]}