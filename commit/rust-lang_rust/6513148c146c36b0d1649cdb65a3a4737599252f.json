{"sha": "6513148c146c36b0d1649cdb65a3a4737599252f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MTMxNDhjMTQ2YzM2YjBkMTY0OWNkYjY1YTNhNDczNzU5OTI1MmY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-27T01:52:00Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-07-22T19:25:54Z"}, "message": "Detect when `'static` obligation might come from an `impl`\n\nAddress #71341.", "tree": {"sha": "2867aae2429ee17a604f18ce36d1e7d3549e7a03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2867aae2429ee17a604f18ce36d1e7d3549e7a03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6513148c146c36b0d1649cdb65a3a4737599252f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6513148c146c36b0d1649cdb65a3a4737599252f", "html_url": "https://github.com/rust-lang/rust/commit/6513148c146c36b0d1649cdb65a3a4737599252f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6513148c146c36b0d1649cdb65a3a4737599252f/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e92106d457abd14f82adc29e7f2496861e07916", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e92106d457abd14f82adc29e7f2496861e07916", "html_url": "https://github.com/rust-lang/rust/commit/9e92106d457abd14f82adc29e7f2496861e07916"}], "stats": {"total": 733, "additions": 431, "deletions": 302}, "files": [{"sha": "da776f269d5107ea12daf68eb5e1aa83b271b096", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 270, "deletions": 195, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -2,227 +2,302 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use rustc_errors::{struct_span_err, Applicability, ErrorReported};\n-use rustc_hir::{GenericBound, ItemKind, Lifetime, LifetimeName, TyKind};\n-use rustc_middle::ty::RegionKind;\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::{\n+    GenericBound, Item, ItemKind, Lifetime, LifetimeName, Node, Path, PolyTraitRef, TraitRef,\n+    TyKind,\n+};\n+use rustc_middle::ty::{self, RegionKind, Ty, TypeFoldable, TypeVisitor};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         debug!(\"try_report_static_impl_trait(error={:?})\", self.error);\n-        if let Some(RegionResolutionError::SubSupConflict(\n-            _,\n-            var_origin,\n-            ref sub_origin,\n-            sub_r,\n-            ref sup_origin,\n-            sup_r,\n-        )) = self.error\n-        {\n-            debug!(\n-                \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n-                var_origin, sub_origin, sub_r, sup_origin, sup_r\n-            );\n-            let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n-            debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n-            let fn_returns = self.tcx().return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n-            if fn_returns.is_empty() {\n-                return None;\n+        let tcx = self.tcx();\n+        let (var_origin, sub_origin, sub_r, sup_origin, sup_r) = match self.error.as_ref()? {\n+            RegionResolutionError::SubSupConflict(\n+                _,\n+                var_origin,\n+                sub_origin,\n+                sub_r,\n+                sup_origin,\n+                sup_r,\n+            ) if **sub_r == RegionKind::ReStatic => {\n+                (var_origin, sub_origin, sub_r, sup_origin, sup_r)\n             }\n-            debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n-            if *sub_r == RegionKind::ReStatic {\n-                let sp = var_origin.span();\n-                let return_sp = sub_origin.span();\n-                let param_info = self.find_param_with_region(sup_r, sub_r)?;\n-                let (lifetime_name, lifetime) = if sup_r.has_name() {\n-                    (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n-                } else {\n-                    (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n-                };\n-                let mut err = struct_span_err!(\n-                    self.tcx().sess,\n-                    sp,\n-                    E0759,\n-                    \"cannot infer an appropriate lifetime\"\n-                );\n-                err.span_label(\n-                    param_info.param_ty_span,\n-                    &format!(\"this data with {}...\", lifetime),\n-                );\n-                debug!(\"try_report_static_impl_trait: param_info={:?}\", param_info);\n+            _ => return None,\n+        };\n+        debug!(\n+            \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n+            var_origin, sub_origin, sub_r, sup_origin, sup_r\n+        );\n+        let anon_reg_sup = tcx.is_suitable_region(sup_r)?;\n+        debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n+        let sp = var_origin.span();\n+        let return_sp = sub_origin.span();\n+        let param = self.find_param_with_region(sup_r, sub_r)?;\n+        let (lifetime_name, lifetime) = if sup_r.has_name() {\n+            (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n+        } else {\n+            (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n+        };\n+        let mut err = struct_span_err!(tcx.sess, sp, E0759, \"cannot infer an appropriate lifetime\");\n+        err.span_label(param.param_ty_span, &format!(\"this data with {}...\", lifetime));\n+        debug!(\"try_report_static_impl_trait: param_info={:?}\", param);\n \n-                // We try to make the output have fewer overlapping spans if possible.\n-                if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n-                    && sup_origin.span() != return_sp\n-                {\n-                    // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n+        // We try to make the output have fewer overlapping spans if possible.\n+        if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n+            && sup_origin.span() != return_sp\n+        {\n+            // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n \n-                    // Customize the spans and labels depending on their relative order so\n-                    // that split sentences flow correctly.\n-                    if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n-                        // Avoid the following:\n-                        //\n-                        // error: cannot infer an appropriate lifetime\n-                        //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n-                        //    |\n-                        // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n-                        //    |           ----                      ---------^-\n-                        //\n-                        // and instead show:\n-                        //\n-                        // error: cannot infer an appropriate lifetime\n-                        //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n-                        //    |\n-                        // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n-                        //    |           ----                               ^\n-                        err.span_label(\n-                            sup_origin.span(),\n-                            \"...is captured here, requiring it to live as long as `'static`\",\n-                        );\n-                    } else {\n-                        err.span_label(sup_origin.span(), \"...is captured here...\");\n-                        if return_sp < sup_origin.span() {\n-                            err.span_note(\n-                                return_sp,\n-                                \"...and is required to live as long as `'static` here\",\n-                            );\n-                        } else {\n-                            err.span_label(\n-                                return_sp,\n-                                \"...and is required to live as long as `'static` here\",\n-                            );\n-                        }\n-                    }\n+            // Customize the spans and labels depending on their relative order so\n+            // that split sentences flow correctly.\n+            if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n+                // Avoid the following:\n+                //\n+                // error: cannot infer an appropriate lifetime\n+                //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                //    |\n+                // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                //    |           ----                      ---------^-\n+                //\n+                // and instead show:\n+                //\n+                // error: cannot infer an appropriate lifetime\n+                //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                //    |\n+                // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                //    |           ----                               ^\n+                err.span_label(\n+                    sup_origin.span(),\n+                    \"...is captured here, requiring it to live as long as `'static`\",\n+                );\n+            } else {\n+                err.span_label(sup_origin.span(), \"...is captured here...\");\n+                if return_sp < sup_origin.span() {\n+                    err.span_note(\n+                        return_sp,\n+                        \"...and is required to live as long as `'static` here\",\n+                    );\n                 } else {\n                     err.span_label(\n                         return_sp,\n-                        \"...is captured and required to live as long as `'static` here\",\n+                        \"...and is required to live as long as `'static` here\",\n                     );\n                 }\n+            }\n+        } else {\n+            err.span_label(\n+                return_sp,\n+                \"...is captured and required to live as long as `'static` here\",\n+            );\n+        }\n \n-                // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-                let consider = \"consider changing the\";\n-                let declare = \"to declare that the\";\n-                let arg = match param_info.param.pat.simple_ident() {\n-                    Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n-                    None => \"the argument\".to_string(),\n-                };\n-                let explicit =\n-                    format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n-                let explicit_static =\n-                    format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n-                let captures = format!(\"captures data from {}\", arg);\n-                let add_static_bound =\n-                    \"alternatively, add an explicit `'static` bound to this reference\";\n-                let plus_lt = format!(\" + {}\", lifetime_name);\n-                for fn_return in fn_returns {\n-                    if fn_return.span.desugaring_kind().is_some() {\n-                        // Skip `async` desugaring `impl Future`.\n-                        continue;\n-                    }\n-                    match fn_return.kind {\n-                        TyKind::OpaqueDef(item_id, _) => {\n-                            let item = self.tcx().hir().item(item_id.id);\n-                            let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n-                                opaque\n-                            } else {\n-                                err.emit();\n-                                return Some(ErrorReported);\n-                            };\n+        self.find_impl_on_dyn_trait(&mut err, param.param_ty);\n \n-                            if let Some(span) = opaque\n-                                .bounds\n-                                .iter()\n-                                .filter_map(|arg| match arg {\n-                                    GenericBound::Outlives(Lifetime {\n-                                        name: LifetimeName::Static,\n-                                        span,\n-                                        ..\n-                                    }) => Some(*span),\n-                                    _ => None,\n-                                })\n-                                .next()\n-                            {\n-                                err.span_suggestion_verbose(\n-                                    span,\n-                                    &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n-                                    lifetime_name.clone(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                err.span_suggestion_verbose(\n-                                    param_info.param_ty_span,\n-                                    add_static_bound,\n-                                    param_info.param_ty.to_string(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else if let Some(_) = opaque\n-                                .bounds\n-                                .iter()\n-                                .filter_map(|arg| match arg {\n-                                    GenericBound::Outlives(Lifetime { name, span, .. })\n-                                        if name.ident().to_string() == lifetime_name =>\n-                                    {\n-                                        Some(*span)\n-                                    }\n-                                    _ => None,\n-                                })\n-                                .next()\n+        let fn_returns = tcx.return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n+        debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n+        // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n+        let consider = \"consider changing the\";\n+        let declare = \"to declare that the\";\n+        let arg = match param.param.pat.simple_ident() {\n+            Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+            None => \"the argument\".to_string(),\n+        };\n+        let explicit = format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n+        let explicit_static = format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n+        let captures = format!(\"captures data from {}\", arg);\n+        let add_static_bound = \"alternatively, add an explicit `'static` bound to this reference\";\n+        let plus_lt = format!(\" + {}\", lifetime_name);\n+        for fn_return in fn_returns {\n+            if fn_return.span.desugaring_kind().is_some() {\n+                // Skip `async` desugaring `impl Future`.\n+                continue;\n+            }\n+            match fn_return.kind {\n+                TyKind::OpaqueDef(item_id, _) => {\n+                    let item = tcx.hir().item(item_id.id);\n+                    let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n+                        opaque\n+                    } else {\n+                        err.emit();\n+                        return Some(ErrorReported);\n+                    };\n+\n+                    if let Some(span) = opaque\n+                        .bounds\n+                        .iter()\n+                        .filter_map(|arg| match arg {\n+                            GenericBound::Outlives(Lifetime {\n+                                name: LifetimeName::Static,\n+                                span,\n+                                ..\n+                            }) => Some(*span),\n+                            _ => None,\n+                        })\n+                        .next()\n+                    {\n+                        err.span_suggestion_verbose(\n+                            span,\n+                            &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n+                            lifetime_name.clone(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        err.span_suggestion_verbose(\n+                            param.param_ty_span,\n+                            add_static_bound,\n+                            param.param_ty.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else if let Some(_) = opaque\n+                        .bounds\n+                        .iter()\n+                        .filter_map(|arg| match arg {\n+                            GenericBound::Outlives(Lifetime { name, span, .. })\n+                                if name.ident().to_string() == lifetime_name =>\n                             {\n-                            } else {\n-                                err.span_suggestion_verbose(\n-                                    fn_return.span.shrink_to_hi(),\n-                                    &format!(\n-                                        \"{declare} `impl Trait` {captures}, {explicit}\",\n-                                        declare = declare,\n-                                        captures = captures,\n-                                        explicit = explicit,\n-                                    ),\n-                                    plus_lt.clone(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n+                                Some(*span)\n                             }\n-                        }\n-                        TyKind::TraitObject(_, lt) => match lt.name {\n-                            LifetimeName::ImplicitObjectLifetimeDefault => {\n-                                err.span_suggestion_verbose(\n-                                    fn_return.span.shrink_to_hi(),\n-                                    &format!(\n-                                        \"{declare} trait object {captures}, {explicit}\",\n-                                        declare = declare,\n-                                        captures = captures,\n-                                        explicit = explicit,\n-                                    ),\n-                                    plus_lt.clone(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                            name if name.ident().to_string() != lifetime_name => {\n-                                // With this check we avoid suggesting redundant bounds. This\n-                                // would happen if there are nested impl/dyn traits and only\n-                                // one of them has the bound we'd suggest already there, like\n-                                // in `impl Foo<X = dyn Bar> + '_`.\n-                                err.span_suggestion_verbose(\n-                                    lt.span,\n-                                    &format!(\"{} trait object's {}\", consider, explicit_static),\n-                                    lifetime_name.clone(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n+                            _ => None,\n+                        })\n+                        .next()\n+                    {\n+                    } else {\n+                        err.span_suggestion_verbose(\n+                            fn_return.span.shrink_to_hi(),\n+                            &format!(\n+                                \"{declare} `impl Trait` {captures}, {explicit}\",\n+                                declare = declare,\n+                                captures = captures,\n+                                explicit = explicit,\n+                            ),\n+                            plus_lt.clone(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+                TyKind::TraitObject(_, lt) => match lt.name {\n+                    LifetimeName::ImplicitObjectLifetimeDefault => {\n+                        err.span_suggestion_verbose(\n+                            fn_return.span.shrink_to_hi(),\n+                            &format!(\n+                                \"{declare} trait object {captures}, {explicit}\",\n+                                declare = declare,\n+                                captures = captures,\n+                                explicit = explicit,\n+                            ),\n+                            plus_lt.clone(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    name if name.ident().to_string() != lifetime_name => {\n+                        // With this check we avoid suggesting redundant bounds. This\n+                        // would happen if there are nested impl/dyn traits and only\n+                        // one of them has the bound we'd suggest already there, like\n+                        // in `impl Foo<X = dyn Bar> + '_`.\n+                        err.span_suggestion_verbose(\n+                            lt.span,\n+                            &format!(\"{} trait object's {}\", consider, explicit_static),\n+                            lifetime_name.clone(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        err.span_suggestion_verbose(\n+                            param.param_ty_span,\n+                            add_static_bound,\n+                            param.param_ty.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    _ => {}\n+                },\n+                _ => {}\n+            }\n+        }\n+        err.emit();\n+        Some(ErrorReported)\n+    }\n+\n+    /// When we call a method coming from an `impl Foo for dyn Bar`, `dyn Bar` introduces a default\n+    /// `'static` obligation. Find `impl` blocks that are implemented\n+    fn find_impl_on_dyn_trait(&self, err: &mut DiagnosticBuilder<'_>, ty: Ty<'_>) -> bool {\n+        let tcx = self.tcx();\n+\n+        // Find the trait object types in the argument.\n+        let mut v = TraitObjectVisitor(vec![]);\n+        v.visit_ty(ty);\n+        debug!(\"TraitObjectVisitor {:?}\", v.0);\n+\n+        // Find all the `impl`s in the local scope that can be called on the type parameter.\n+        // FIXME: this doesn't find `impl dyn Trait { /**/ }`.\n+        let impl_self_tys = tcx\n+            .all_traits(LOCAL_CRATE)\n+            .iter()\n+            .flat_map(|trait_did| tcx.hir().trait_impls(*trait_did))\n+            .filter_map(|impl_node| {\n+                let impl_did = tcx.hir().local_def_id(*impl_node);\n+                if let Some(Node::Item(Item { kind: ItemKind::Impl { self_ty, .. }, .. })) =\n+                    tcx.hir().get_if_local(impl_did.to_def_id())\n+                {\n+                    Some(self_ty)\n+                } else {\n+                    None\n+                }\n+            });\n+        let mut suggested = false;\n+        for self_ty in impl_self_tys {\n+            if let TyKind::TraitObject(\n+                poly_trait_refs,\n+                Lifetime { name: LifetimeName::ImplicitObjectLifetimeDefault, .. },\n+            ) = self_ty.kind\n+            {\n+                for p in poly_trait_refs {\n+                    if let PolyTraitRef {\n+                        trait_ref:\n+                            TraitRef { path: Path { res: Res::Def(DefKind::Trait, did), .. }, .. },\n+                        ..\n+                    } = p\n+                    {\n+                        for found_did in &v.0 {\n+                            if did == found_did {\n+                                // We've found an `impl Foo for dyn Bar {}`.\n+                                // FIXME: we should change this so it also works for\n+                                // `impl Foo for Box<dyn Bar> {}`.\n                                 err.span_suggestion_verbose(\n-                                    param_info.param_ty_span,\n-                                    add_static_bound,\n-                                    param_info.param_ty.to_string(),\n+                                    self_ty.span.shrink_to_hi(),\n+                                    \"this `impl` introduces an implicit `'static` requirement, \\\n+                                     consider changing it\",\n+                                    \" + '_\".to_string(),\n                                     Applicability::MaybeIncorrect,\n                                 );\n+                                suggested = true;\n                             }\n-                            _ => {}\n-                        },\n-                        _ => {}\n+                        }\n                     }\n                 }\n                 err.emit();\n                 return Some(ErrorReported);\n             }\n         }\n-        None\n+        suggested\n+    }\n+}\n+\n+/// Collect all the trait objects in a type that could have received an implicit `'static` lifetime.\n+struct TraitObjectVisitor(Vec<DefId>);\n+\n+impl TypeVisitor<'_> for TraitObjectVisitor {\n+    fn visit_ty(&mut self, t: Ty<'_>) -> bool {\n+        match t.kind {\n+            ty::Dynamic(preds, RegionKind::ReStatic) => {\n+                if let Some(def_id) = preds.principal_def_id() {\n+                    self.0.push(def_id);\n+                }\n+                false\n+            }\n+            _ => t.super_visit_with(self),\n+        }\n     }\n }"}, {"sha": "1eeb01ccc846e9d82691725254e58eac7f0830e4", "filename": "src/test/ui/associated-types/cache/project-fn-ret-contravariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -35,7 +35,7 @@ fn baz<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n \n #[cfg(transmute)] // one instantiations: BAD\n fn baz<'a,'b>(x: &'a u32) -> &'static u32 {\n-   bar(foo, x) //[transmute]~ ERROR E0495\n+   bar(foo, x) //[transmute]~ ERROR E0759\n }\n \n #[cfg(krisskross)] // two instantiations, mixing and matching: BAD"}, {"sha": "36812d3c0441e2fa9826605cc797a758c54d7585", "filename": "src/test/ui/associated-types/cache/project-fn-ret-contravariant.transmute.stderr", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.stderr?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -1,26 +1,11 @@\n-error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/project-fn-ret-contravariant.rs:38:8\n    |\n-LL |    bar(foo, x)\n-   |        ^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 37:8...\n-  --> $DIR/project-fn-ret-contravariant.rs:37:8\n-   |\n LL | fn baz<'a,'b>(x: &'a u32) -> &'static u32 {\n-   |        ^^\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/project-fn-ret-contravariant.rs:38:13\n-   |\n-LL |    bar(foo, x)\n-   |             ^\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/project-fn-ret-contravariant.rs:38:4\n-   |\n+   |                  ------- this data with lifetime `'a`...\n LL |    bar(foo, x)\n-   |    ^^^^^^^^^^^\n+   |    ----^^^---- ...is captured and required to live as long as `'static` here\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "08d864f7836d20467ad4292d937f2809f154b089", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -46,7 +46,7 @@ fn baz<'a, 'b>(x: Type<'a>) -> Type<'static> {\n     // Cannot instantiate `foo` with any lifetime other than `'a`,\n     // since it is provided as input.\n \n-    bar(foo, x) //[transmute]~ ERROR E0495\n+    bar(foo, x) //[transmute]~ ERROR E0759\n }\n \n #[cfg(krisskross)] // two instantiations, mixing and matching: BAD"}, {"sha": "9cec0780b3ca83de22b45aee39c5709c3d5572c7", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.transmute.stderr", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -1,30 +1,12 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/project-fn-ret-invariant.rs:49:9\n    |\n-LL |     bar(foo, x)\n-   |         ^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 45:8...\n-  --> $DIR/project-fn-ret-invariant.rs:45:8\n-   |\n LL | fn baz<'a, 'b>(x: Type<'a>) -> Type<'static> {\n-   |        ^^\n-note: ...so that the expression is assignable\n-  --> $DIR/project-fn-ret-invariant.rs:49:14\n-   |\n-LL |     bar(foo, x)\n-   |              ^\n-   = note: expected `Type<'_>`\n-              found `Type<'a>`\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the expression is assignable\n-  --> $DIR/project-fn-ret-invariant.rs:49:5\n-   |\n+   |                   -------- this data with lifetime `'a`...\n+...\n LL |     bar(foo, x)\n-   |     ^^^^^^^^^^^\n-   = note: expected `Type<'static>`\n-              found `Type<'_>`\n+   |     ----^^^---- ...is captured and required to live as long as `'static` here\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "397cb3750c2661ae72b00e409e0da0c4a69c4cc3", "filename": "src/test/ui/impl-header-lifetime-elision/dyn-trait.stderr", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -1,30 +1,17 @@\n-error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/dyn-trait.rs:20:16\n    |\n-LL |     static_val(x);\n-   |                ^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 19:26...\n-  --> $DIR/dyn-trait.rs:19:26\n-   |\n LL | fn with_dyn_debug_static<'a>(x: Box<dyn Debug + 'a>) {\n-   |                          ^^\n-note: ...so that the expression is assignable\n-  --> $DIR/dyn-trait.rs:20:16\n-   |\n+   |                                 ------------------- this data with lifetime `'a`...\n LL |     static_val(x);\n-   |                ^\n-   = note: expected `std::boxed::Box<dyn std::fmt::Debug>`\n-              found `std::boxed::Box<(dyn std::fmt::Debug + 'a)>`\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the types are compatible\n+   |                ^ ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n   --> $DIR/dyn-trait.rs:20:5\n    |\n LL |     static_val(x);\n    |     ^^^^^^^^^^\n-   = note: expected `StaticTrait`\n-              found `StaticTrait`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "f823f69c76f678d7bc106a5f8680d21f54b2007e", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-inherent-1.stderr", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -1,28 +1,11 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/constant-in-expr-inherent-1.rs:8:5\n    |\n-LL |     <Foo<'a>>::C\n-   |     ^^^^^^^^^^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 7:8...\n-  --> $DIR/constant-in-expr-inherent-1.rs:7:8\n-   |\n LL | fn foo<'a>(_: &'a u32) -> &'static u32 {\n-   |        ^^\n-note: ...so that the types are compatible\n-  --> $DIR/constant-in-expr-inherent-1.rs:8:5\n-   |\n-LL |     <Foo<'a>>::C\n-   |     ^^^^^^^^^^^^\n-   = note: expected `Foo<'_>`\n-              found `Foo<'a>`\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/constant-in-expr-inherent-1.rs:8:5\n-   |\n+   |               ------- this data with lifetime `'a`...\n LL |     <Foo<'a>>::C\n-   |     ^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^ ...is captured and required to live as long as `'static` here\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "c15a933379c85b5032d4b4d124af19a1e8b86b4a", "filename": "src/test/ui/regions/regions-addr-of-self.stderr", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.stderr?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -1,29 +1,11 @@\n-error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/regions-addr-of-self.rs:7:37\n    |\n+LL |     pub fn chase_cat(&mut self) {\n+   |                      --------- this data with an anonymous lifetime `'_`...\n LL |         let p: &'static mut usize = &mut self.cats_chased;\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 6:5...\n-  --> $DIR/regions-addr-of-self.rs:6:5\n-   |\n-LL | /     pub fn chase_cat(&mut self) {\n-LL | |         let p: &'static mut usize = &mut self.cats_chased;\n-LL | |         *p += 1;\n-LL | |     }\n-   | |_____^\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/regions-addr-of-self.rs:7:37\n-   |\n-LL |         let p: &'static mut usize = &mut self.cats_chased;\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/regions-addr-of-self.rs:7:37\n-   |\n-LL |         let p: &'static mut usize = &mut self.cats_chased;\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^ ...is captured and required to live as long as `'static` here\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "dd53ee06ff5ee15ebe52677caadb987cb2041be6", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound-without-suggestion.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-without-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-without-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-without-suggestion.rs?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -0,0 +1,14 @@\n+trait OtherTrait<'a> {}\n+impl<'a> OtherTrait<'a> for &'a () {}\n+\n+trait ObjectTrait {}\n+\n+impl dyn ObjectTrait {\n+    fn use_self(&self) -> &() { panic!() }\n+}\n+\n+fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+    val.use_self() //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "4618b540c70ee018162aad71d72c9dcd89d20b37", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound-without-suggestion.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-without-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-without-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-without-suggestion.stderr?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-without-suggestion.rs:11:9\n+   |\n+LL |     val.use_self()\n+   |         ^^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected reference `&(dyn ObjectTrait + 'static)`\n+              found reference `&(dyn ObjectTrait + 'a)`\n+note: the lifetime `'a` as defined on the function body at 10:11...\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-without-suggestion.rs:10:11\n+   |\n+LL | fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+   |           ^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "dfe475d3c0694919d734c14eed8bf51de1d95286", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.fixed", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.fixed?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -0,0 +1,37 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+mod foo {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &();\n+    }\n+\n+    impl MyTrait for dyn ObjectTrait + '_ {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+        val.use_self() //~ ERROR cannot infer an appropriate lifetime\n+    }\n+}\n+\n+mod bar {\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &();\n+    }\n+\n+    impl MyTrait for dyn ObjectTrait + '_ {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> &'a () {\n+        val.use_self() //~ ERROR cannot infer an appropriate lifetime\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "85e6c2993b9b10ab6fad0c62f765f05ae4ee509d", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.rs?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -0,0 +1,37 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+mod foo {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &();\n+    }\n+\n+    impl MyTrait for dyn ObjectTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+        val.use_self() //~ ERROR cannot infer an appropriate lifetime\n+    }\n+}\n+\n+mod bar {\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &();\n+    }\n+\n+    impl MyTrait for dyn ObjectTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> &'a () {\n+        val.use_self() //~ ERROR cannot infer an appropriate lifetime\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6780459adbeac9f89885238e6ecbc8076d081278", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6513148c146c36b0d1649cdb65a3a4737599252f/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr?ref=6513148c146c36b0d1649cdb65a3a4737599252f", "patch": "@@ -0,0 +1,29 @@\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:18:13\n+   |\n+LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+   |                        ------------------- this data with lifetime `'a`...\n+LL |         val.use_self()\n+   |             ^^^^^^^^ ...is captured and required to live as long as `'static` here\n+   |\n+help: this `impl` introduces an implicit `'static` requirement, consider changing it\n+   |\n+LL |     impl MyTrait for dyn ObjectTrait + '_ {\n+   |                                      ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:33:13\n+   |\n+LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> &'a () {\n+   |                        ------------------- this data with lifetime `'a`...\n+LL |         val.use_self()\n+   |             ^^^^^^^^ ...is captured and required to live as long as `'static` here\n+   |\n+help: this `impl` introduces an implicit `'static` requirement, consider changing it\n+   |\n+LL |     impl MyTrait for dyn ObjectTrait + '_ {\n+   |                                      ^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0759`."}]}