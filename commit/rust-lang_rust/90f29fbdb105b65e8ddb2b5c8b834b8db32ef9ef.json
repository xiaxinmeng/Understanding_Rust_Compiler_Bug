{"sha": "90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZjI5ZmJkYjEwNWI2NWU4ZGRiMmI1YzhiODM0YjhkYjMyZWY5ZWY=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-07T17:38:35Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-21T07:45:18Z"}, "message": "Replace SliceExt with inherent [T] methods in libcore", "tree": {"sha": "8ff3cc541de803e5f82194332ff1c48abe8bf210", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ff3cc541de803e5f82194332ff1c48abe8bf210"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "html_url": "https://github.com/rust-lang/rust/commit/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "url": "https://api.github.com/repos/rust-lang/rust/commits/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84", "html_url": "https://github.com/rust-lang/rust/commit/de8ed6a1d6ae3b2f2c7f1035ef3b71abda7a6a84"}], "stats": {"total": 2811, "additions": 1418, "deletions": 1393}, "files": [{"sha": "52011303543a09d60e1b48392dec4ee8ed1369c7", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "patch": "@@ -90,6 +90,7 @@\n #![feature(collections_range)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n+#![cfg_attr(stage0, feature(core_slice_ext))]\n #![feature(custom_attribute)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]"}, {"sha": "4594263c01f23ec38ea72983213392662e303deb", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 5, "deletions": 1391, "changes": 1396, "blob_url": "https://github.com/rust-lang/rust/blob/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "patch": "@@ -101,7 +101,7 @@ use core::cmp::Ordering::{self, Less};\n use core::mem::size_of;\n use core::mem;\n use core::ptr;\n-use core::slice as core_slice;\n+#[cfg(stage0)] use core::slice::SliceExt;\n use core::{u8, u16, u32};\n \n use borrow::{Borrow, BorrowMut, ToOwned};\n@@ -171,1059 +171,12 @@ mod hack {\n     }\n }\n \n-#[lang = \"slice\"]\n+#[cfg_attr(stage0, lang = \"slice\")]\n+#[cfg_attr(not(stage0), lang = \"slice_alloc\")]\n #[cfg(not(test))]\n impl<T> [T] {\n-    /// Returns the number of elements in the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    /// assert_eq!(a.len(), 3);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn len(&self) -> usize {\n-        core_slice::SliceExt::len(self)\n-    }\n-\n-    /// Returns `true` if the slice has a length of 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn is_empty(&self) -> bool {\n-        core_slice::SliceExt::is_empty(self)\n-    }\n-\n-    /// Returns the first element of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(Some(&10), v.first());\n-    ///\n-    /// let w: &[i32] = &[];\n-    /// assert_eq!(None, w.first());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn first(&self) -> Option<&T> {\n-        core_slice::SliceExt::first(self)\n-    }\n-\n-    /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [0, 1, 2];\n-    ///\n-    /// if let Some(first) = x.first_mut() {\n-    ///     *first = 5;\n-    /// }\n-    /// assert_eq!(x, &[5, 1, 2]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn first_mut(&mut self) -> Option<&mut T> {\n-        core_slice::SliceExt::first_mut(self)\n-    }\n-\n-    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &[0, 1, 2];\n-    ///\n-    /// if let Some((first, elements)) = x.split_first() {\n-    ///     assert_eq!(first, &0);\n-    ///     assert_eq!(elements, &[1, 2]);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn split_first(&self) -> Option<(&T, &[T])> {\n-        core_slice::SliceExt::split_first(self)\n-    }\n-\n-    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [0, 1, 2];\n-    ///\n-    /// if let Some((first, elements)) = x.split_first_mut() {\n-    ///     *first = 3;\n-    ///     elements[0] = 4;\n-    ///     elements[1] = 5;\n-    /// }\n-    /// assert_eq!(x, &[3, 4, 5]);\n-    /// ```\n-    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        core_slice::SliceExt::split_first_mut(self)\n-    }\n-\n-    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &[0, 1, 2];\n-    ///\n-    /// if let Some((last, elements)) = x.split_last() {\n-    ///     assert_eq!(last, &2);\n-    ///     assert_eq!(elements, &[0, 1]);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn split_last(&self) -> Option<(&T, &[T])> {\n-        core_slice::SliceExt::split_last(self)\n-\n-    }\n-\n-    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [0, 1, 2];\n-    ///\n-    /// if let Some((last, elements)) = x.split_last_mut() {\n-    ///     *last = 3;\n-    ///     elements[0] = 4;\n-    ///     elements[1] = 5;\n-    /// }\n-    /// assert_eq!(x, &[4, 5, 3]);\n-    /// ```\n-    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n-    #[inline]\n-    pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        core_slice::SliceExt::split_last_mut(self)\n-    }\n-\n-    /// Returns the last element of the slice, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(Some(&30), v.last());\n-    ///\n-    /// let w: &[i32] = &[];\n-    /// assert_eq!(None, w.last());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn last(&self) -> Option<&T> {\n-        core_slice::SliceExt::last(self)\n-    }\n-\n-    /// Returns a mutable pointer to the last item in the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [0, 1, 2];\n-    ///\n-    /// if let Some(last) = x.last_mut() {\n-    ///     *last = 10;\n-    /// }\n-    /// assert_eq!(x, &[0, 1, 10]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn last_mut(&mut self) -> Option<&mut T> {\n-        core_slice::SliceExt::last_mut(self)\n-    }\n-\n-    /// Returns a reference to an element or subslice depending on the type of\n-    /// index.\n-    ///\n-    /// - If given a position, returns a reference to the element at that\n-    ///   position or `None` if out of bounds.\n-    /// - If given a range, returns the subslice corresponding to that range,\n-    ///   or `None` if out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(Some(&40), v.get(1));\n-    /// assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n-    /// assert_eq!(None, v.get(3));\n-    /// assert_eq!(None, v.get(0..4));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n-        where I: SliceIndex<Self>\n-    {\n-        core_slice::SliceExt::get(self, index)\n-    }\n-\n-    /// Returns a mutable reference to an element or subslice depending on the\n-    /// type of index (see [`get`]) or `None` if the index is out of bounds.\n-    ///\n-    /// [`get`]: #method.get\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [0, 1, 2];\n-    ///\n-    /// if let Some(elem) = x.get_mut(1) {\n-    ///     *elem = 42;\n-    /// }\n-    /// assert_eq!(x, &[0, 42, 2]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n-        where I: SliceIndex<Self>\n-    {\n-        core_slice::SliceExt::get_mut(self, index)\n-    }\n-\n-    /// Returns a reference to an element or subslice, without doing bounds\n-    /// checking.\n-    ///\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`get`].\n-    ///\n-    /// [`get`]: #method.get\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &[1, 2, 4];\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(x.get_unchecked(1), &2);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n-        where I: SliceIndex<Self>\n-    {\n-        core_slice::SliceExt::get_unchecked(self, index)\n-    }\n-\n-    /// Returns a mutable reference to an element or subslice, without doing\n-    /// bounds checking.\n-    ///\n-    /// This is generally not recommended, use with caution! For a safe\n-    /// alternative see [`get_mut`].\n-    ///\n-    /// [`get_mut`]: #method.get_mut\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [1, 2, 4];\n-    ///\n-    /// unsafe {\n-    ///     let elem = x.get_unchecked_mut(1);\n-    ///     *elem = 13;\n-    /// }\n-    /// assert_eq!(x, &[1, 13, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n-        where I: SliceIndex<Self>\n-    {\n-        core_slice::SliceExt::get_unchecked_mut(self, index)\n-    }\n-\n-    /// Returns a raw pointer to the slice's buffer.\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the container referenced by this slice may cause its buffer\n-    /// to be reallocated, which would also make any pointers to it invalid.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &[1, 2, 4];\n-    /// let x_ptr = x.as_ptr();\n-    ///\n-    /// unsafe {\n-    ///     for i in 0..x.len() {\n-    ///         assert_eq!(x.get_unchecked(i), &*x_ptr.offset(i as isize));\n-    ///     }\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn as_ptr(&self) -> *const T {\n-        core_slice::SliceExt::as_ptr(self)\n-    }\n-\n-    /// Returns an unsafe mutable pointer to the slice's buffer.\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the container referenced by this slice may cause its buffer\n-    /// to be reallocated, which would also make any pointers to it invalid.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [1, 2, 4];\n-    /// let x_ptr = x.as_mut_ptr();\n-    ///\n-    /// unsafe {\n-    ///     for i in 0..x.len() {\n-    ///         *x_ptr.offset(i as isize) += 2;\n-    ///     }\n-    /// }\n-    /// assert_eq!(x, &[3, 4, 6]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        core_slice::SliceExt::as_mut_ptr(self)\n-    }\n-\n-    /// Swaps two elements in the slice.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `a` or `b` are out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn swap(&mut self, a: usize, b: usize) {\n-        core_slice::SliceExt::swap(self, a, b)\n-    }\n-\n-    /// Reverses the order of elements in the slice, in place.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [1, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3, 2, 1]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn reverse(&mut self) {\n-        core_slice::SliceExt::reverse(self)\n-    }\n-\n-    /// Returns an iterator over the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &[1, 2, 4];\n-    /// let mut iterator = x.iter();\n-    ///\n-    /// assert_eq!(iterator.next(), Some(&1));\n-    /// assert_eq!(iterator.next(), Some(&2));\n-    /// assert_eq!(iterator.next(), Some(&4));\n-    /// assert_eq!(iterator.next(), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn iter(&self) -> Iter<T> {\n-        core_slice::SliceExt::iter(self)\n-    }\n-\n-    /// Returns an iterator that allows modifying each value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = &mut [1, 2, 4];\n-    /// for elem in x.iter_mut() {\n-    ///     *elem += 2;\n-    /// }\n-    /// assert_eq!(x, &[3, 4, 6]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn iter_mut(&mut self) -> IterMut<T> {\n-        core_slice::SliceExt::iter_mut(self)\n-    }\n-\n-    /// Returns an iterator over all contiguous windows of length\n-    /// `size`. The windows overlap. If the slice is shorter than\n-    /// `size`, the iterator returns no values.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let slice = ['r', 'u', 's', 't'];\n-    /// let mut iter = slice.windows(2);\n-    /// assert_eq!(iter.next().unwrap(), &['r', 'u']);\n-    /// assert_eq!(iter.next().unwrap(), &['u', 's']);\n-    /// assert_eq!(iter.next().unwrap(), &['s', 't']);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    ///\n-    /// If the slice is shorter than `size`:\n-    ///\n-    /// ```\n-    /// let slice = ['f', 'o', 'o'];\n-    /// let mut iter = slice.windows(4);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn windows(&self, size: usize) -> Windows<T> {\n-        core_slice::SliceExt::windows(self, size)\n-    }\n-\n-    /// Returns an iterator over `chunk_size` elements of the slice at a\n-    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will\n-    /// not have length `chunk_size`.\n-    ///\n-    /// See [`exact_chunks`] for a variant of this iterator that returns chunks\n-    /// of always exactly `chunk_size` elements.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n-    /// let mut iter = slice.chunks(2);\n-    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n-    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n-    /// assert_eq!(iter.next().unwrap(), &['m']);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    ///\n-    /// [`exact_chunks`]: #method.exact_chunks\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n-        core_slice::SliceExt::chunks(self, chunk_size)\n-    }\n-\n-    /// Returns an iterator over `chunk_size` elements of the slice at a\n-    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last up to `chunk_size-1`\n-    /// elements will be omitted.\n-    ///\n-    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n-    /// can often optimize the resulting code better than in the case of\n-    /// [`chunks`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(exact_chunks)]\n-    ///\n-    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n-    /// let mut iter = slice.exact_chunks(2);\n-    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n-    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    ///\n-    /// [`chunks`]: #method.chunks\n-    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-    #[inline]\n-    pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n-        core_slice::SliceExt::exact_chunks(self, chunk_size)\n-    }\n-\n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will not\n-    /// have length `chunk_size`.\n-    ///\n-    /// See [`exact_chunks_mut`] for a variant of this iterator that returns chunks\n-    /// of always exactly `chunk_size` elements.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = &mut [0, 0, 0, 0, 0];\n-    /// let mut count = 1;\n-    ///\n-    /// for chunk in v.chunks_mut(2) {\n-    ///     for elem in chunk.iter_mut() {\n-    ///         *elem += count;\n-    ///     }\n-    ///     count += 1;\n-    /// }\n-    /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n-    /// ```\n-    ///\n-    /// [`exact_chunks_mut`]: #method.exact_chunks_mut\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n-        core_slice::SliceExt::chunks_mut(self, chunk_size)\n-    }\n-\n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last up to `chunk_size-1`\n-    /// elements will be omitted.\n-    ///\n-    ///\n-    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n-    /// can often optimize the resulting code better than in the case of\n-    /// [`chunks_mut`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(exact_chunks)]\n-    ///\n-    /// let v = &mut [0, 0, 0, 0, 0];\n-    /// let mut count = 1;\n-    ///\n-    /// for chunk in v.exact_chunks_mut(2) {\n-    ///     for elem in chunk.iter_mut() {\n-    ///         *elem += count;\n-    ///     }\n-    ///     count += 1;\n-    /// }\n-    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n-    /// ```\n-    ///\n-    /// [`chunks_mut`]: #method.chunks_mut\n-    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-    #[inline]\n-    pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n-        core_slice::SliceExt::exact_chunks_mut(self, chunk_size)\n-    }\n-\n-    /// Divides one slice into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid > len`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [1, 2, 3, 4, 5, 6];\n-    ///\n-    /// {\n-    ///    let (left, right) = v.split_at(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.split_at(2);\n-    ///     assert!(left == [1, 2]);\n-    ///     assert!(right == [3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.split_at(6);\n-    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n-        core_slice::SliceExt::split_at(self, mid)\n-    }\n-\n-    /// Divides one mutable slice into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `mid > len`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [1, 0, 3, 0, 5, 6];\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1, 0]);\n-    ///     assert!(right == [3, 0, 5, 6]);\n-    ///     left[1] = 2;\n-    ///     right[1] = 4;\n-    /// }\n-    /// assert!(v == [1, 2, 3, 4, 5, 6]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-        core_slice::SliceExt::split_at_mut(self, mid)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`. The matched element is not contained in the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let slice = [10, 40, 33, 20];\n-    /// let mut iter = slice.split(|num| num % 3 == 0);\n-    ///\n-    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n-    /// assert_eq!(iter.next().unwrap(), &[20]);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    ///\n-    /// If the first element is matched, an empty slice will be the first item\n-    /// returned by the iterator. Similarly, if the last element in the slice\n-    /// is matched, an empty slice will be the last item returned by the\n-    /// iterator:\n-    ///\n-    /// ```\n-    /// let slice = [10, 40, 33];\n-    /// let mut iter = slice.split(|num| num % 3 == 0);\n-    ///\n-    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n-    /// assert_eq!(iter.next().unwrap(), &[]);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    ///\n-    /// If two matched elements are directly adjacent, an empty slice will be\n-    /// present between them:\n-    ///\n-    /// ```\n-    /// let slice = [10, 6, 33, 20];\n-    /// let mut iter = slice.split(|num| num % 3 == 0);\n-    ///\n-    /// assert_eq!(iter.next().unwrap(), &[10]);\n-    /// assert_eq!(iter.next().unwrap(), &[]);\n-    /// assert_eq!(iter.next().unwrap(), &[20]);\n-    /// assert!(iter.next().is_none());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split<F>(&self, pred: F) -> Split<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::split(self, pred)\n-    }\n-\n-    /// Returns an iterator over mutable subslices separated by elements that\n-    /// match `pred`. The matched element is not contained in the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [10, 40, 30, 20, 60, 50];\n-    ///\n-    /// for group in v.split_mut(|num| *num % 3 == 0) {\n-    ///     group[0] = 1;\n-    /// }\n-    /// assert_eq!(v, [1, 40, 30, 1, 60, 1]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::split_mut(self, pred)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, starting at the end of the slice and working backwards.\n-    /// The matched element is not contained in the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    ///\n-    /// let slice = [11, 22, 33, 0, 44, 55];\n-    /// let mut iter = slice.rsplit(|num| *num == 0);\n-    ///\n-    /// assert_eq!(iter.next().unwrap(), &[44, 55]);\n-    /// assert_eq!(iter.next().unwrap(), &[11, 22, 33]);\n-    /// assert_eq!(iter.next(), None);\n-    /// ```\n-    ///\n-    /// As with `split()`, if the first or last element is matched, an empty\n-    /// slice will be the first (or last) item returned by the iterator.\n-    ///\n-    /// ```\n-    /// let v = &[0, 1, 1, 2, 3, 5, 8];\n-    /// let mut it = v.rsplit(|n| *n % 2 == 0);\n-    /// assert_eq!(it.next().unwrap(), &[]);\n-    /// assert_eq!(it.next().unwrap(), &[3, 5]);\n-    /// assert_eq!(it.next().unwrap(), &[1, 1]);\n-    /// assert_eq!(it.next().unwrap(), &[]);\n-    /// assert_eq!(it.next(), None);\n-    /// ```\n-    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n-    #[inline]\n-    pub fn rsplit<F>(&self, pred: F) -> RSplit<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::rsplit(self, pred)\n-    }\n-\n-    /// Returns an iterator over mutable subslices separated by elements that\n-    /// match `pred`, starting at the end of the slice and working\n-    /// backwards. The matched element is not contained in the subslices.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [100, 400, 300, 200, 600, 500];\n-    ///\n-    /// let mut count = 0;\n-    /// for group in v.rsplit_mut(|num| *num % 3 == 0) {\n-    ///     count += 1;\n-    ///     group[0] = count;\n-    /// }\n-    /// assert_eq!(v, [3, 400, 300, 2, 600, 1]);\n-    /// ```\n-    ///\n-    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n-    #[inline]\n-    pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::rsplit_mut(self, pred)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to returning at most `n` items. The matched element is\n-    /// not contained in the subslices.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n-    /// `[20, 60, 50]`):\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n-    ///\n-    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::splitn(self, n, pred)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to returning at most `n` items. The matched element is\n-    /// not contained in the subslices.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [10, 40, 30, 20, 60, 50];\n-    ///\n-    /// for group in v.splitn_mut(2, |num| *num % 3 == 0) {\n-    ///     group[0] = 1;\n-    /// }\n-    /// assert_eq!(v, [1, 40, 30, 1, 60, 50]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::splitn_mut(self, n, pred)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to returning at most `n` items. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Print the slice split once, starting from the end, by numbers divisible\n-    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n-    ///\n-    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::rsplitn(self, n, pred)\n-    }\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to returning at most `n` items. This starts at the end of\n-    /// the slice and works backwards. The matched element is not contained in\n-    /// the subslices.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut s = [10, 40, 30, 20, 60, 50];\n-    ///\n-    /// for group in s.rsplitn_mut(2, |num| *num % 3 == 0) {\n-    ///     group[0] = 1;\n-    /// }\n-    /// assert_eq!(s, [1, 40, 30, 20, 60, 1]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<T, F>\n-        where F: FnMut(&T) -> bool\n-    {\n-        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n-    }\n-\n-    /// Returns `true` if the slice contains an element with the given value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.contains(&30));\n-    /// assert!(!v.contains(&50));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains(&self, x: &T) -> bool\n-        where T: PartialEq\n-    {\n-        core_slice::SliceExt::contains(self, x)\n-    }\n-\n-    /// Returns `true` if `needle` is a prefix of the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.starts_with(&[10]));\n-    /// assert!(v.starts_with(&[10, 40]));\n-    /// assert!(!v.starts_with(&[50]));\n-    /// assert!(!v.starts_with(&[10, 50]));\n-    /// ```\n-    ///\n-    /// Always returns `true` if `needle` is an empty slice:\n-    ///\n-    /// ```\n-    /// let v = &[10, 40, 30];\n-    /// assert!(v.starts_with(&[]));\n-    /// let v: &[u8] = &[];\n-    /// assert!(v.starts_with(&[]));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with(&self, needle: &[T]) -> bool\n-        where T: PartialEq\n-    {\n-        core_slice::SliceExt::starts_with(self, needle)\n-    }\n-\n-    /// Returns `true` if `needle` is a suffix of the slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = [10, 40, 30];\n-    /// assert!(v.ends_with(&[30]));\n-    /// assert!(v.ends_with(&[40, 30]));\n-    /// assert!(!v.ends_with(&[50]));\n-    /// assert!(!v.ends_with(&[50, 30]));\n-    /// ```\n-    ///\n-    /// Always returns `true` if `needle` is an empty slice:\n-    ///\n-    /// ```\n-    /// let v = &[10, 40, 30];\n-    /// assert!(v.ends_with(&[]));\n-    /// let v: &[u8] = &[];\n-    /// assert!(v.ends_with(&[]));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with(&self, needle: &[T]) -> bool\n-        where T: PartialEq\n-    {\n-        core_slice::SliceExt::ends_with(self, needle)\n-    }\n-\n-    /// Binary searches this sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Ok` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1, 4]`.\n-    ///\n-    /// ```\n-    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    ///\n-    /// assert_eq!(s.binary_search(&13),  Ok(9));\n-    /// assert_eq!(s.binary_search(&4),   Err(7));\n-    /// assert_eq!(s.binary_search(&100), Err(13));\n-    /// let r = s.binary_search(&1);\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n-        where T: Ord\n-    {\n-        core_slice::SliceExt::binary_search(self, x)\n-    }\n-\n-    /// Binary searches this sorted slice with a comparator function.\n-    ///\n-    /// The comparator function should implement an order consistent\n-    /// with the sort order of the underlying slice, returning an\n-    /// order code that indicates whether its argument is `Less`,\n-    /// `Equal` or `Greater` the desired target.\n-    ///\n-    /// If a matching value is found then returns `Ok`, containing\n-    /// the index for the matched element; if no match is found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1, 4]`.\n-    ///\n-    /// ```\n-    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    ///\n-    /// let seek = 13;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n-    /// let seek = 4;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n-    /// let seek = 100;\n-    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n-    /// let seek = 1;\n-    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n-        where F: FnMut(&'a T) -> Ordering\n-    {\n-        core_slice::SliceExt::binary_search_by(self, f)\n-    }\n-\n-    /// Binary searches this sorted slice with a key extraction function.\n-    ///\n-    /// Assumes that the slice is sorted by the key, for instance with\n-    /// [`sort_by_key`] using the same key extraction function.\n-    ///\n-    /// If a matching value is found then returns `Ok`, containing the\n-    /// index for the matched element; if no match is found then `Err`\n-    /// is returned, containing the index where a matching element could\n-    /// be inserted while maintaining sorted order.\n-    ///\n-    /// [`sort_by_key`]: #method.sort_by_key\n-    ///\n-    /// # Examples\n-    ///\n-    /// Looks up a series of four elements in a slice of pairs sorted by\n-    /// their second elements. The first is found, with a uniquely\n-    /// determined position; the second and third are not found; the\n-    /// fourth could match any position in `[1, 4]`.\n-    ///\n-    /// ```\n-    /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n-    ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n-    ///          (1, 21), (2, 34), (4, 55)];\n-    ///\n-    /// assert_eq!(s.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\n-    /// assert_eq!(s.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\n-    /// assert_eq!(s.binary_search_by_key(&100, |&(a,b)| b), Err(13));\n-    /// let r = s.binary_search_by_key(&1, |&(a,b)| b);\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n-    #[inline]\n-    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n-        where F: FnMut(&'a T) -> B,\n-              B: Ord\n-    {\n-        core_slice::SliceExt::binary_search_by_key(self, b, f)\n-    }\n+    #[cfg(stage0)]\n+    slice_core_methods!();\n \n     /// Sorts the slice.\n     ///\n@@ -1402,345 +355,6 @@ impl<T> [T] {\n         sort_by_key!(usize, self, f)\n     }\n \n-    /// Sorts the slice, but may not preserve the order of equal elements.\n-    ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(n log n)` worst-case.\n-    ///\n-    /// # Current implementation\n-    ///\n-    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n-    /// which combines the fast average case of randomized quicksort with the fast worst case of\n-    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n-    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n-    /// deterministic behavior.\n-    ///\n-    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n-    /// slice consists of several concatenated sorted sequences.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [-5, 4, 1, -3, 2];\n-    ///\n-    /// v.sort_unstable();\n-    /// assert!(v == [-5, -3, 1, 2, 4]);\n-    /// ```\n-    ///\n-    /// [pdqsort]: https://github.com/orlp/pdqsort\n-    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn sort_unstable(&mut self)\n-        where T: Ord\n-    {\n-        core_slice::SliceExt::sort_unstable(self);\n-    }\n-\n-    /// Sorts the slice with a comparator function, but may not preserve the order of equal\n-    /// elements.\n-    ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(n log n)` worst-case.\n-    ///\n-    /// # Current implementation\n-    ///\n-    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n-    /// which combines the fast average case of randomized quicksort with the fast worst case of\n-    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n-    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n-    /// deterministic behavior.\n-    ///\n-    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n-    /// slice consists of several concatenated sorted sequences.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [5, 4, 1, 3, 2];\n-    /// v.sort_unstable_by(|a, b| a.cmp(b));\n-    /// assert!(v == [1, 2, 3, 4, 5]);\n-    ///\n-    /// // reverse sorting\n-    /// v.sort_unstable_by(|a, b| b.cmp(a));\n-    /// assert!(v == [5, 4, 3, 2, 1]);\n-    /// ```\n-    ///\n-    /// [pdqsort]: https://github.com/orlp/pdqsort\n-    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn sort_unstable_by<F>(&mut self, compare: F)\n-        where F: FnMut(&T, &T) -> Ordering\n-    {\n-        core_slice::SliceExt::sort_unstable_by(self, compare);\n-    }\n-\n-    /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n-    /// elements.\n-    ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(m n log(m n))` worst-case, where the key function is `O(m)`.\n-    ///\n-    /// # Current implementation\n-    ///\n-    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n-    /// which combines the fast average case of randomized quicksort with the fast worst case of\n-    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n-    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n-    /// deterministic behavior.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = [-5i32, 4, 1, -3, 2];\n-    ///\n-    /// v.sort_unstable_by_key(|k| k.abs());\n-    /// assert!(v == [1, 2, -3, 4, -5]);\n-    /// ```\n-    ///\n-    /// [pdqsort]: https://github.com/orlp/pdqsort\n-    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n-    #[inline]\n-    pub fn sort_unstable_by_key<K, F>(&mut self, f: F)\n-        where F: FnMut(&T) -> K, K: Ord\n-    {\n-        core_slice::SliceExt::sort_unstable_by_key(self, f);\n-    }\n-\n-    /// Rotates the slice in-place such that the first `mid` elements of the\n-    /// slice move to the end while the last `self.len() - mid` elements move to\n-    /// the front. After calling `rotate_left`, the element previously at index\n-    /// `mid` will become the first element in the slice.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if `mid` is greater than the length of the\n-    /// slice. Note that `mid == self.len()` does _not_ panic and is a no-op\n-    /// rotation.\n-    ///\n-    /// # Complexity\n-    ///\n-    /// Takes linear (in `self.len()`) time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n-    /// a.rotate_left(2);\n-    /// assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n-    /// ```\n-    ///\n-    /// Rotating a subslice:\n-    ///\n-    /// ```\n-    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n-    /// a[1..5].rotate_left(1);\n-    /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n-   /// ```\n-    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n-    pub fn rotate_left(&mut self, mid: usize) {\n-        core_slice::SliceExt::rotate_left(self, mid);\n-    }\n-\n-    /// Rotates the slice in-place such that the first `self.len() - k`\n-    /// elements of the slice move to the end while the last `k` elements move\n-    /// to the front. After calling `rotate_right`, the element previously at\n-    /// index `self.len() - k` will become the first element in the slice.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if `k` is greater than the length of the\n-    /// slice. Note that `k == self.len()` does _not_ panic and is a no-op\n-    /// rotation.\n-    ///\n-    /// # Complexity\n-    ///\n-    /// Takes linear (in `self.len()`) time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n-    /// a.rotate_right(2);\n-    /// assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n-    /// ```\n-    ///\n-    /// Rotate a subslice:\n-    ///\n-    /// ```\n-    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n-    /// a[1..5].rotate_right(1);\n-    /// assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);\n-    /// ```\n-    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n-    pub fn rotate_right(&mut self, k: usize) {\n-        core_slice::SliceExt::rotate_right(self, k);\n-    }\n-\n-    /// Copies the elements from `src` into `self`.\n-    ///\n-    /// The length of `src` must be the same as `self`.\n-    ///\n-    /// If `src` implements `Copy`, it can be more performant to use\n-    /// [`copy_from_slice`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the two slices have different lengths.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Cloning two elements from a slice into another:\n-    ///\n-    /// ```\n-    /// let src = [1, 2, 3, 4];\n-    /// let mut dst = [0, 0];\n-    ///\n-    /// dst.clone_from_slice(&src[2..]);\n-    ///\n-    /// assert_eq!(src, [1, 2, 3, 4]);\n-    /// assert_eq!(dst, [3, 4]);\n-    /// ```\n-    ///\n-    /// Rust enforces that there can only be one mutable reference with no\n-    /// immutable references to a particular piece of data in a particular\n-    /// scope. Because of this, attempting to use `clone_from_slice` on a\n-    /// single slice will result in a compile failure:\n-    ///\n-    /// ```compile_fail\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    ///\n-    /// slice[..2].clone_from_slice(&slice[3..]); // compile fail!\n-    /// ```\n-    ///\n-    /// To work around this, we can use [`split_at_mut`] to create two distinct\n-    /// sub-slices from a slice:\n-    ///\n-    /// ```\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    ///\n-    /// {\n-    ///     let (left, right) = slice.split_at_mut(2);\n-    ///     left.clone_from_slice(&right[1..]);\n-    /// }\n-    ///\n-    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n-    /// ```\n-    ///\n-    /// [`copy_from_slice`]: #method.copy_from_slice\n-    /// [`split_at_mut`]: #method.split_at_mut\n-    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n-    pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n-        core_slice::SliceExt::clone_from_slice(self, src)\n-    }\n-\n-    /// Copies all elements from `src` into `self`, using a memcpy.\n-    ///\n-    /// The length of `src` must be the same as `self`.\n-    ///\n-    /// If `src` does not implement `Copy`, use [`clone_from_slice`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the two slices have different lengths.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Copying two elements from a slice into another:\n-    ///\n-    /// ```\n-    /// let src = [1, 2, 3, 4];\n-    /// let mut dst = [0, 0];\n-    ///\n-    /// dst.copy_from_slice(&src[2..]);\n-    ///\n-    /// assert_eq!(src, [1, 2, 3, 4]);\n-    /// assert_eq!(dst, [3, 4]);\n-    /// ```\n-    ///\n-    /// Rust enforces that there can only be one mutable reference with no\n-    /// immutable references to a particular piece of data in a particular\n-    /// scope. Because of this, attempting to use `copy_from_slice` on a\n-    /// single slice will result in a compile failure:\n-    ///\n-    /// ```compile_fail\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    ///\n-    /// slice[..2].copy_from_slice(&slice[3..]); // compile fail!\n-    /// ```\n-    ///\n-    /// To work around this, we can use [`split_at_mut`] to create two distinct\n-    /// sub-slices from a slice:\n-    ///\n-    /// ```\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    ///\n-    /// {\n-    ///     let (left, right) = slice.split_at_mut(2);\n-    ///     left.copy_from_slice(&right[1..]);\n-    /// }\n-    ///\n-    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n-    /// ```\n-    ///\n-    /// [`clone_from_slice`]: #method.clone_from_slice\n-    /// [`split_at_mut`]: #method.split_at_mut\n-    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n-    pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n-        core_slice::SliceExt::copy_from_slice(self, src)\n-    }\n-\n-    /// Swaps all elements in `self` with those in `other`.\n-    ///\n-    /// The length of `other` must be the same as `self`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the two slices have different lengths.\n-    ///\n-    /// # Example\n-    ///\n-    /// Swapping two elements across slices:\n-    ///\n-    /// ```\n-    /// let mut slice1 = [0, 0];\n-    /// let mut slice2 = [1, 2, 3, 4];\n-    ///\n-    /// slice1.swap_with_slice(&mut slice2[2..]);\n-    ///\n-    /// assert_eq!(slice1, [3, 4]);\n-    /// assert_eq!(slice2, [1, 2, 0, 0]);\n-    /// ```\n-    ///\n-    /// Rust enforces that there can only be one mutable reference to a\n-    /// particular piece of data in a particular scope. Because of this,\n-    /// attempting to use `swap_with_slice` on a single slice will result in\n-    /// a compile failure:\n-    ///\n-    /// ```compile_fail\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    /// slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!\n-    /// ```\n-    ///\n-    /// To work around this, we can use [`split_at_mut`] to create two distinct\n-    /// mutable sub-slices from a slice:\n-    ///\n-    /// ```\n-    /// let mut slice = [1, 2, 3, 4, 5];\n-    ///\n-    /// {\n-    ///     let (left, right) = slice.split_at_mut(2);\n-    ///     left.swap_with_slice(&mut right[1..]);\n-    /// }\n-    ///\n-    /// assert_eq!(slice, [4, 5, 3, 1, 2]);\n-    /// ```\n-    ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n-    #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n-    pub fn swap_with_slice(&mut self, other: &mut [T]) {\n-        core_slice::SliceExt::swap_with_slice(self, other)\n-    }\n-\n     /// Copies `self` into a new `Vec`.\n     ///\n     /// # Examples"}, {"sha": "f4fafe304c05df16b86d4cad93154bcc6b69f914", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "patch": "@@ -229,7 +229,7 @@ macro_rules! test_v512 { ($item:item) => {}; }\n #[allow(unused_macros)]\n macro_rules! vector_impl { ($([$f:ident, $($args:tt)*]),*) => { $($f!($($args)*);)* } }\n #[path = \"../stdsimd/coresimd/mod.rs\"]\n-#[allow(missing_docs, missing_debug_implementations, dead_code)]\n+#[allow(missing_docs, missing_debug_implementations, dead_code, unused_imports)]\n #[unstable(feature = \"stdsimd\", issue = \"48556\")]\n #[cfg(not(stage0))] // allow changes to how stdsimd works in stage0\n mod coresimd;"}, {"sha": "32c1531bdc023b6797cac71306ea4b31b870ff1f", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "patch": "@@ -58,6 +58,7 @@ pub use result::Result::{self, Ok, Err};\n // Re-exported extension traits for primitive types\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n+#[cfg(stage0)]\n pub use slice::SliceExt;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]"}, {"sha": "0a260c663c293ac969e23f904baeebb0cf7a1457", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1404, "deletions": 0, "changes": 1404, "blob_url": "https://github.com/rust-lang/rust/blob/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "patch": "@@ -755,6 +755,1410 @@ impl<T> SliceExt for [T] {\n     }\n }\n \n+// FIXME: remove (inline) this macro and the SliceExt trait\n+// when updating to a bootstrap compiler that has the new lang items.\n+#[cfg_attr(stage0, macro_export)]\n+#[unstable(feature = \"core_slice_ext\", issue = \"32110\")]\n+macro_rules! slice_core_methods { () => {\n+    /// Returns the number of elements in the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        SliceExt::len(self)\n+    }\n+\n+    /// Returns `true` if the slice has a length of 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        SliceExt::is_empty(self)\n+    }\n+\n+    /// Returns the first element of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&10), v.first());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(None, w.first());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn first(&self) -> Option<&T> {\n+        SliceExt::first(self)\n+    }\n+\n+    /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(first) = x.first_mut() {\n+    ///     *first = 5;\n+    /// }\n+    /// assert_eq!(x, &[5, 1, 2]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn first_mut(&mut self) -> Option<&mut T> {\n+        SliceExt::first_mut(self)\n+    }\n+\n+    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[0, 1, 2];\n+    ///\n+    /// if let Some((first, elements)) = x.split_first() {\n+    ///     assert_eq!(first, &0);\n+    ///     assert_eq!(elements, &[1, 2]);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn split_first(&self) -> Option<(&T, &[T])> {\n+        SliceExt::split_first(self)\n+    }\n+\n+    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some((first, elements)) = x.split_first_mut() {\n+    ///     *first = 3;\n+    ///     elements[0] = 4;\n+    ///     elements[1] = 5;\n+    /// }\n+    /// assert_eq!(x, &[3, 4, 5]);\n+    /// ```\n+    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n+        SliceExt::split_first_mut(self)\n+    }\n+\n+    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[0, 1, 2];\n+    ///\n+    /// if let Some((last, elements)) = x.split_last() {\n+    ///     assert_eq!(last, &2);\n+    ///     assert_eq!(elements, &[0, 1]);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn split_last(&self) -> Option<(&T, &[T])> {\n+        SliceExt::split_last(self)\n+\n+    }\n+\n+    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some((last, elements)) = x.split_last_mut() {\n+    ///     *last = 3;\n+    ///     elements[0] = 4;\n+    ///     elements[1] = 5;\n+    /// }\n+    /// assert_eq!(x, &[4, 5, 3]);\n+    /// ```\n+    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[inline]\n+    pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n+        SliceExt::split_last_mut(self)\n+    }\n+\n+    /// Returns the last element of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&30), v.last());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(None, w.last());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn last(&self) -> Option<&T> {\n+        SliceExt::last(self)\n+    }\n+\n+    /// Returns a mutable pointer to the last item in the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(last) = x.last_mut() {\n+    ///     *last = 10;\n+    /// }\n+    /// assert_eq!(x, &[0, 1, 10]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn last_mut(&mut self) -> Option<&mut T> {\n+        SliceExt::last_mut(self)\n+    }\n+\n+    /// Returns a reference to an element or subslice depending on the type of\n+    /// index.\n+    ///\n+    /// - If given a position, returns a reference to the element at that\n+    ///   position or `None` if out of bounds.\n+    /// - If given a range, returns the subslice corresponding to that range,\n+    ///   or `None` if out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&40), v.get(1));\n+    /// assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n+    /// assert_eq!(None, v.get(3));\n+    /// assert_eq!(None, v.get(0..4));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n+        where I: SliceIndex<Self>\n+    {\n+        SliceExt::get(self, index)\n+    }\n+\n+    /// Returns a mutable reference to an element or subslice depending on the\n+    /// type of index (see [`get`]) or `None` if the index is out of bounds.\n+    ///\n+    /// [`get`]: #method.get\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(elem) = x.get_mut(1) {\n+    ///     *elem = 42;\n+    /// }\n+    /// assert_eq!(x, &[0, 42, 2]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n+        where I: SliceIndex<Self>\n+    {\n+        SliceExt::get_mut(self, index)\n+    }\n+\n+    /// Returns a reference to an element or subslice, without doing bounds\n+    /// checking.\n+    ///\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`get`].\n+    ///\n+    /// [`get`]: #method.get\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[1, 2, 4];\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(x.get_unchecked(1), &2);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<Self>\n+    {\n+        SliceExt::get_unchecked(self, index)\n+    }\n+\n+    /// Returns a mutable reference to an element or subslice, without doing\n+    /// bounds checking.\n+    ///\n+    /// This is generally not recommended, use with caution! For a safe\n+    /// alternative see [`get_mut`].\n+    ///\n+    /// [`get_mut`]: #method.get_mut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [1, 2, 4];\n+    ///\n+    /// unsafe {\n+    ///     let elem = x.get_unchecked_mut(1);\n+    ///     *elem = 13;\n+    /// }\n+    /// assert_eq!(x, &[1, 13, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n+        where I: SliceIndex<Self>\n+    {\n+        SliceExt::get_unchecked_mut(self, index)\n+    }\n+\n+    /// Returns a raw pointer to the slice's buffer.\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the container referenced by this slice may cause its buffer\n+    /// to be reallocated, which would also make any pointers to it invalid.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[1, 2, 4];\n+    /// let x_ptr = x.as_ptr();\n+    ///\n+    /// unsafe {\n+    ///     for i in 0..x.len() {\n+    ///         assert_eq!(x.get_unchecked(i), &*x_ptr.offset(i as isize));\n+    ///     }\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const T {\n+        SliceExt::as_ptr(self)\n+    }\n+\n+    /// Returns an unsafe mutable pointer to the slice's buffer.\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the container referenced by this slice may cause its buffer\n+    /// to be reallocated, which would also make any pointers to it invalid.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [1, 2, 4];\n+    /// let x_ptr = x.as_mut_ptr();\n+    ///\n+    /// unsafe {\n+    ///     for i in 0..x.len() {\n+    ///         *x_ptr.offset(i as isize) += 2;\n+    ///     }\n+    /// }\n+    /// assert_eq!(x, &[3, 4, 6]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        SliceExt::as_mut_ptr(self)\n+    }\n+\n+    /// Swaps two elements in the slice.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `a` or `b` are out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn swap(&mut self, a: usize, b: usize) {\n+        SliceExt::swap(self, a, b)\n+    }\n+\n+    /// Reverses the order of elements in the slice, in place.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [1, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3, 2, 1]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn reverse(&mut self) {\n+        SliceExt::reverse(self)\n+    }\n+\n+    /// Returns an iterator over the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[1, 2, 4];\n+    /// let mut iterator = x.iter();\n+    ///\n+    /// assert_eq!(iterator.next(), Some(&1));\n+    /// assert_eq!(iterator.next(), Some(&2));\n+    /// assert_eq!(iterator.next(), Some(&4));\n+    /// assert_eq!(iterator.next(), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn iter(&self) -> Iter<T> {\n+        SliceExt::iter(self)\n+    }\n+\n+    /// Returns an iterator that allows modifying each value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [1, 2, 4];\n+    /// for elem in x.iter_mut() {\n+    ///     *elem += 2;\n+    /// }\n+    /// assert_eq!(x, &[3, 4, 6]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn iter_mut(&mut self) -> IterMut<T> {\n+        SliceExt::iter_mut(self)\n+    }\n+\n+    /// Returns an iterator over all contiguous windows of length\n+    /// `size`. The windows overlap. If the slice is shorter than\n+    /// `size`, the iterator returns no values.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let slice = ['r', 'u', 's', 't'];\n+    /// let mut iter = slice.windows(2);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'u']);\n+    /// assert_eq!(iter.next().unwrap(), &['u', 's']);\n+    /// assert_eq!(iter.next().unwrap(), &['s', 't']);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If the slice is shorter than `size`:\n+    ///\n+    /// ```\n+    /// let slice = ['f', 'o', 'o'];\n+    /// let mut iter = slice.windows(4);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn windows(&self, size: usize) -> Windows<T> {\n+        SliceExt::windows(self, size)\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a\n+    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will\n+    /// not have length `chunk_size`.\n+    ///\n+    /// See [`exact_chunks`] for a variant of this iterator that returns chunks\n+    /// of always exactly `chunk_size` elements.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.chunks(2);\n+    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n+    /// assert_eq!(iter.next().unwrap(), &['m']);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// [`exact_chunks`]: #method.exact_chunks\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n+        SliceExt::chunks(self, chunk_size)\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a\n+    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last up to `chunk_size-1`\n+    /// elements will be omitted.\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n+    /// can often optimize the resulting code better than in the case of\n+    /// [`chunks`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exact_chunks)]\n+    ///\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.exact_chunks(2);\n+    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// [`chunks`]: #method.chunks\n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[inline]\n+    pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n+        SliceExt::exact_chunks(self, chunk_size)\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will not\n+    /// have length `chunk_size`.\n+    ///\n+    /// See [`exact_chunks_mut`] for a variant of this iterator that returns chunks\n+    /// of always exactly `chunk_size` elements.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.chunks_mut(2) {\n+    ///     for elem in chunk.iter_mut() {\n+    ///         *elem += count;\n+    ///     }\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n+    /// ```\n+    ///\n+    /// [`exact_chunks_mut`]: #method.exact_chunks_mut\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n+        SliceExt::chunks_mut(self, chunk_size)\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last up to `chunk_size-1`\n+    /// elements will be omitted.\n+    ///\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n+    /// can often optimize the resulting code better than in the case of\n+    /// [`chunks_mut`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exact_chunks)]\n+    ///\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.exact_chunks_mut(2) {\n+    ///     for elem in chunk.iter_mut() {\n+    ///         *elem += count;\n+    ///     }\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n+    /// ```\n+    ///\n+    /// [`chunks_mut`]: #method.chunks_mut\n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[inline]\n+    pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n+        SliceExt::exact_chunks_mut(self, chunk_size)\n+    }\n+\n+    /// Divides one slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [1, 2, 3, 4, 5, 6];\n+    ///\n+    /// {\n+    ///    let (left, right) = v.split_at(0);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at(2);\n+    ///     assert!(left == [1, 2]);\n+    ///     assert!(right == [3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at(6);\n+    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n+        SliceExt::split_at(self, mid)\n+    }\n+\n+    /// Divides one mutable slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [1, 0, 3, 0, 5, 6];\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(2);\n+    ///     assert!(left == [1, 0]);\n+    ///     assert!(right == [3, 0, 5, 6]);\n+    ///     left[1] = 2;\n+    ///     right[1] = 4;\n+    /// }\n+    /// assert!(v == [1, 2, 3, 4, 5, 6]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+        SliceExt::split_at_mut(self, mid)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`. The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let slice = [10, 40, 33, 20];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If the first element is matched, an empty slice will be the first item\n+    /// returned by the iterator. Similarly, if the last element in the slice\n+    /// is matched, an empty slice will be the last item returned by the\n+    /// iterator:\n+    ///\n+    /// ```\n+    /// let slice = [10, 40, 33];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n+    /// assert_eq!(iter.next().unwrap(), &[]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If two matched elements are directly adjacent, an empty slice will be\n+    /// present between them:\n+    ///\n+    /// ```\n+    /// let slice = [10, 6, 33, 20];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10]);\n+    /// assert_eq!(iter.next().unwrap(), &[]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split<F>(&self, pred: F) -> Split<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::split(self, pred)\n+    }\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`. The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.split_mut(|num| *num % 3 == 0) {\n+    ///     group[0] = 1;\n+    /// }\n+    /// assert_eq!(v, [1, 40, 30, 1, 60, 1]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::split_mut(self, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, starting at the end of the slice and working backwards.\n+    /// The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let slice = [11, 22, 33, 0, 44, 55];\n+    /// let mut iter = slice.rsplit(|num| *num == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[44, 55]);\n+    /// assert_eq!(iter.next().unwrap(), &[11, 22, 33]);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// As with `split()`, if the first or last element is matched, an empty\n+    /// slice will be the first (or last) item returned by the iterator.\n+    ///\n+    /// ```\n+    /// let v = &[0, 1, 1, 2, 3, 5, 8];\n+    /// let mut it = v.rsplit(|n| *n % 2 == 0);\n+    /// assert_eq!(it.next().unwrap(), &[]);\n+    /// assert_eq!(it.next().unwrap(), &[3, 5]);\n+    /// assert_eq!(it.next().unwrap(), &[1, 1]);\n+    /// assert_eq!(it.next().unwrap(), &[]);\n+    /// assert_eq!(it.next(), None);\n+    /// ```\n+    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+    #[inline]\n+    pub fn rsplit<F>(&self, pred: F) -> RSplit<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::rsplit(self, pred)\n+    }\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`, starting at the end of the slice and working\n+    /// backwards. The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [100, 400, 300, 200, 600, 500];\n+    ///\n+    /// let mut count = 0;\n+    /// for group in v.rsplit_mut(|num| *num % 3 == 0) {\n+    ///     count += 1;\n+    ///     group[0] = count;\n+    /// }\n+    /// assert_eq!(v, [3, 400, 300, 2, 600, 1]);\n+    /// ```\n+    ///\n+    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n+    #[inline]\n+    pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::rsplit_mut(self, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to returning at most `n` items. The matched element is\n+    /// not contained in the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n+    /// `[20, 60, 50]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::splitn(self, n, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to returning at most `n` items. The matched element is\n+    /// not contained in the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.splitn_mut(2, |num| *num % 3 == 0) {\n+    ///     group[0] = 1;\n+    /// }\n+    /// assert_eq!(v, [1, 40, 30, 1, 60, 50]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::splitn_mut(self, n, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to returning at most `n` items. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split once, starting from the end, by numbers divisible\n+    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::rsplitn(self, n, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to returning at most `n` items. This starts at the end of\n+    /// the slice and works backwards. The matched element is not contained in\n+    /// the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut s = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in s.rsplitn_mut(2, |num| *num % 3 == 0) {\n+    ///     group[0] = 1;\n+    /// }\n+    /// assert_eq!(s, [1, 40, 30, 20, 60, 1]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SliceExt::rsplitn_mut(self, n, pred)\n+    }\n+\n+    /// Returns `true` if the slice contains an element with the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.contains(&30));\n+    /// assert!(!v.contains(&50));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn contains(&self, x: &T) -> bool\n+        where T: PartialEq\n+    {\n+        SliceExt::contains(self, x)\n+    }\n+\n+    /// Returns `true` if `needle` is a prefix of the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.starts_with(&[10]));\n+    /// assert!(v.starts_with(&[10, 40]));\n+    /// assert!(!v.starts_with(&[50]));\n+    /// assert!(!v.starts_with(&[10, 50]));\n+    /// ```\n+    ///\n+    /// Always returns `true` if `needle` is an empty slice:\n+    ///\n+    /// ```\n+    /// let v = &[10, 40, 30];\n+    /// assert!(v.starts_with(&[]));\n+    /// let v: &[u8] = &[];\n+    /// assert!(v.starts_with(&[]));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn starts_with(&self, needle: &[T]) -> bool\n+        where T: PartialEq\n+    {\n+        SliceExt::starts_with(self, needle)\n+    }\n+\n+    /// Returns `true` if `needle` is a suffix of the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.ends_with(&[30]));\n+    /// assert!(v.ends_with(&[40, 30]));\n+    /// assert!(!v.ends_with(&[50]));\n+    /// assert!(!v.ends_with(&[50, 30]));\n+    /// ```\n+    ///\n+    /// Always returns `true` if `needle` is an empty slice:\n+    ///\n+    /// ```\n+    /// let v = &[10, 40, 30];\n+    /// assert!(v.ends_with(&[]));\n+    /// let v: &[u8] = &[];\n+    /// assert!(v.ends_with(&[]));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn ends_with(&self, needle: &[T]) -> bool\n+        where T: PartialEq\n+    {\n+        SliceExt::ends_with(self, needle)\n+    }\n+\n+    /// Binary searches this sorted slice for a given element.\n+    ///\n+    /// If the value is found then `Ok` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    ///\n+    /// assert_eq!(s.binary_search(&13),  Ok(9));\n+    /// assert_eq!(s.binary_search(&4),   Err(7));\n+    /// assert_eq!(s.binary_search(&100), Err(13));\n+    /// let r = s.binary_search(&1);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n+        where T: Ord\n+    {\n+        SliceExt::binary_search(self, x)\n+    }\n+\n+    /// Binary searches this sorted slice with a comparator function.\n+    ///\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying slice, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` the desired target.\n+    ///\n+    /// If a matching value is found then returns `Ok`, containing\n+    /// the index for the matched element; if no match is found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    ///\n+    /// let seek = 13;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n+    /// let seek = 4;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n+    /// let seek = 100;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n+    /// let seek = 1;\n+    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n+        where F: FnMut(&'a T) -> Ordering\n+    {\n+        SliceExt::binary_search_by(self, f)\n+    }\n+\n+    /// Binary searches this sorted slice with a key extraction function.\n+    ///\n+    /// Assumes that the slice is sorted by the key, for instance with\n+    /// [`sort_by_key`] using the same key extraction function.\n+    ///\n+    /// If a matching value is found then returns `Ok`, containing the\n+    /// index for the matched element; if no match is found then `Err`\n+    /// is returned, containing the index where a matching element could\n+    /// be inserted while maintaining sorted order.\n+    ///\n+    /// [`sort_by_key`]: #method.sort_by_key\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements in a slice of pairs sorted by\n+    /// their second elements. The first is found, with a uniquely\n+    /// determined position; the second and third are not found; the\n+    /// fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n+    ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n+    ///          (1, 21), (2, 34), (4, 55)];\n+    ///\n+    /// assert_eq!(s.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\n+    /// assert_eq!(s.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\n+    /// assert_eq!(s.binary_search_by_key(&100, |&(a,b)| b), Err(13));\n+    /// let r = s.binary_search_by_key(&1, |&(a,b)| b);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n+    #[inline]\n+    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n+        where F: FnMut(&'a T) -> B,\n+              B: Ord\n+    {\n+        SliceExt::binary_search_by_key(self, b, f)\n+    }\n+\n+    /// Sorts the slice, but may not preserve the order of equal elements.\n+    ///\n+    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n+    /// and `O(n log n)` worst-case.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n+    ///\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n+    /// slice consists of several concatenated sorted sequences.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [-5, 4, 1, -3, 2];\n+    ///\n+    /// v.sort_unstable();\n+    /// assert!(v == [-5, -3, 1, 2, 4]);\n+    /// ```\n+    ///\n+    /// [pdqsort]: https://github.com/orlp/pdqsort\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn sort_unstable(&mut self)\n+        where T: Ord\n+    {\n+        SliceExt::sort_unstable(self);\n+    }\n+\n+    /// Sorts the slice with a comparator function, but may not preserve the order of equal\n+    /// elements.\n+    ///\n+    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n+    /// and `O(n log n)` worst-case.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n+    ///\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n+    /// slice consists of several concatenated sorted sequences.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [5, 4, 1, 3, 2];\n+    /// v.sort_unstable_by(|a, b| a.cmp(b));\n+    /// assert!(v == [1, 2, 3, 4, 5]);\n+    ///\n+    /// // reverse sorting\n+    /// v.sort_unstable_by(|a, b| b.cmp(a));\n+    /// assert!(v == [5, 4, 3, 2, 1]);\n+    /// ```\n+    ///\n+    /// [pdqsort]: https://github.com/orlp/pdqsort\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn sort_unstable_by<F>(&mut self, compare: F)\n+        where F: FnMut(&T, &T) -> Ordering\n+    {\n+        SliceExt::sort_unstable_by(self, compare);\n+    }\n+\n+    /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n+    /// elements.\n+    ///\n+    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n+    /// and `O(m n log(m n))` worst-case, where the key function is `O(m)`.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// v.sort_unstable_by_key(|k| k.abs());\n+    /// assert!(v == [1, 2, -3, 4, -5]);\n+    /// ```\n+    ///\n+    /// [pdqsort]: https://github.com/orlp/pdqsort\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n+    #[inline]\n+    pub fn sort_unstable_by_key<K, F>(&mut self, f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n+    {\n+        SliceExt::sort_unstable_by_key(self, f);\n+    }\n+\n+    /// Rotates the slice in-place such that the first `mid` elements of the\n+    /// slice move to the end while the last `self.len() - mid` elements move to\n+    /// the front. After calling `rotate_left`, the element previously at index\n+    /// `mid` will become the first element in the slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if `mid` is greater than the length of the\n+    /// slice. Note that `mid == self.len()` does _not_ panic and is a no-op\n+    /// rotation.\n+    ///\n+    /// # Complexity\n+    ///\n+    /// Takes linear (in `self.len()`) time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a.rotate_left(2);\n+    /// assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n+    /// ```\n+    ///\n+    /// Rotating a subslice:\n+    ///\n+    /// ```\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a[1..5].rotate_left(1);\n+    /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n+   /// ```\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n+    pub fn rotate_left(&mut self, mid: usize) {\n+        SliceExt::rotate_left(self, mid);\n+    }\n+\n+    /// Rotates the slice in-place such that the first `self.len() - k`\n+    /// elements of the slice move to the end while the last `k` elements move\n+    /// to the front. After calling `rotate_right`, the element previously at\n+    /// index `self.len() - k` will become the first element in the slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if `k` is greater than the length of the\n+    /// slice. Note that `k == self.len()` does _not_ panic and is a no-op\n+    /// rotation.\n+    ///\n+    /// # Complexity\n+    ///\n+    /// Takes linear (in `self.len()`) time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a.rotate_right(2);\n+    /// assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n+    /// ```\n+    ///\n+    /// Rotate a subslice:\n+    ///\n+    /// ```\n+    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n+    /// a[1..5].rotate_right(1);\n+    /// assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);\n+    /// ```\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n+    pub fn rotate_right(&mut self, k: usize) {\n+        SliceExt::rotate_right(self, k);\n+    }\n+\n+    /// Copies the elements from `src` into `self`.\n+    ///\n+    /// The length of `src` must be the same as `self`.\n+    ///\n+    /// If `src` implements `Copy`, it can be more performant to use\n+    /// [`copy_from_slice`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the two slices have different lengths.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Cloning two elements from a slice into another:\n+    ///\n+    /// ```\n+    /// let src = [1, 2, 3, 4];\n+    /// let mut dst = [0, 0];\n+    ///\n+    /// dst.clone_from_slice(&src[2..]);\n+    ///\n+    /// assert_eq!(src, [1, 2, 3, 4]);\n+    /// assert_eq!(dst, [3, 4]);\n+    /// ```\n+    ///\n+    /// Rust enforces that there can only be one mutable reference with no\n+    /// immutable references to a particular piece of data in a particular\n+    /// scope. Because of this, attempting to use `clone_from_slice` on a\n+    /// single slice will result in a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// slice[..2].clone_from_slice(&slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// sub-slices from a slice:\n+    ///\n+    /// ```\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.clone_from_slice(&right[1..]);\n+    /// }\n+    ///\n+    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n+    /// ```\n+    ///\n+    /// [`copy_from_slice`]: #method.copy_from_slice\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n+    pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n+        SliceExt::clone_from_slice(self, src)\n+    }\n+\n+    /// Copies all elements from `src` into `self`, using a memcpy.\n+    ///\n+    /// The length of `src` must be the same as `self`.\n+    ///\n+    /// If `src` does not implement `Copy`, use [`clone_from_slice`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the two slices have different lengths.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Copying two elements from a slice into another:\n+    ///\n+    /// ```\n+    /// let src = [1, 2, 3, 4];\n+    /// let mut dst = [0, 0];\n+    ///\n+    /// dst.copy_from_slice(&src[2..]);\n+    ///\n+    /// assert_eq!(src, [1, 2, 3, 4]);\n+    /// assert_eq!(dst, [3, 4]);\n+    /// ```\n+    ///\n+    /// Rust enforces that there can only be one mutable reference with no\n+    /// immutable references to a particular piece of data in a particular\n+    /// scope. Because of this, attempting to use `copy_from_slice` on a\n+    /// single slice will result in a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// slice[..2].copy_from_slice(&slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// sub-slices from a slice:\n+    ///\n+    /// ```\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.copy_from_slice(&right[1..]);\n+    /// }\n+    ///\n+    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n+    /// ```\n+    ///\n+    /// [`clone_from_slice`]: #method.clone_from_slice\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n+    pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n+        SliceExt::copy_from_slice(self, src)\n+    }\n+\n+    /// Swaps all elements in `self` with those in `other`.\n+    ///\n+    /// The length of `other` must be the same as `self`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the two slices have different lengths.\n+    ///\n+    /// # Example\n+    ///\n+    /// Swapping two elements across slices:\n+    ///\n+    /// ```\n+    /// let mut slice1 = [0, 0];\n+    /// let mut slice2 = [1, 2, 3, 4];\n+    ///\n+    /// slice1.swap_with_slice(&mut slice2[2..]);\n+    ///\n+    /// assert_eq!(slice1, [3, 4]);\n+    /// assert_eq!(slice2, [1, 2, 0, 0]);\n+    /// ```\n+    ///\n+    /// Rust enforces that there can only be one mutable reference to a\n+    /// particular piece of data in a particular scope. Because of this,\n+    /// attempting to use `swap_with_slice` on a single slice will result in\n+    /// a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    /// slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// mutable sub-slices from a slice:\n+    ///\n+    /// ```\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.swap_with_slice(&mut right[1..]);\n+    /// }\n+    ///\n+    /// assert_eq!(slice, [4, 5, 3, 1, 2]);\n+    /// ```\n+    ///\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n+    pub fn swap_with_slice(&mut self, other: &mut [T]) {\n+        SliceExt::swap_with_slice(self, other)\n+    }\n+}}\n+\n+#[lang = \"slice\"]\n+#[cfg(not(test))]\n+#[cfg(not(stage0))]\n+impl<T> [T] {\n+    slice_core_methods!();\n+}\n+\n+// FIXME: remove (inline) this macro\n+// when updating to a bootstrap compiler that has the new lang items.\n #[cfg_attr(stage0, macro_export)]\n #[unstable(feature = \"core_slice_ext\", issue = \"32110\")]\n macro_rules! slice_u8_core_methods { () => {"}, {"sha": "237a22925b434a6d63a1e8e181c3e2a0feac27cc", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "patch": "@@ -214,6 +214,7 @@ language_item_table! {\n     StrImplItem,                     \"str\",                     str_impl;\n     SliceImplItem,                   \"slice\",                   slice_impl;\n     SliceU8ImplItem,                 \"slice_u8\",                slice_u8_impl;\n+    SliceAllocImplItem,              \"slice_alloc\",             slice_alloc_impl;\n     SliceU8AllocImplItem,            \"slice_u8_alloc\",          slice_u8_alloc_impl;\n     ConstPtrImplItem,                \"const_ptr\",               const_ptr_impl;\n     MutPtrImplItem,                  \"mut_ptr\",                 mut_ptr_impl;"}, {"sha": "ea4c2c08817caa563859f75d9cffcfbd20613a6b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "patch": "@@ -479,6 +479,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let lang_def_id = lang_items.slice_u8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n \n+                let lang_def_id = lang_items.slice_alloc_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+\n                 let lang_def_id = lang_items.slice_u8_alloc_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }"}, {"sha": "91f9e3e6fbad4934f28424b24a9bfffa848afa02", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             ty::TySlice(_) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.slice_impl(),\n-                                          None,\n+                                          lang_items.slice_alloc_impl(),\n                                           \"slice\",\n                                           \"[T]\",\n                                           item.span);"}, {"sha": "38af4350815aeefb661b32ea271680575c0123e9", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=90f29fbdb105b65e8ddb2b5c8b834b8db32ef9ef", "patch": "@@ -290,6 +290,7 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n         lang_items.str_impl(),\n         lang_items.slice_impl(),\n         lang_items.slice_u8_impl(),\n+        lang_items.slice_alloc_impl(),\n         lang_items.slice_u8_alloc_impl(),\n         lang_items.const_ptr_impl(),\n         lang_items.mut_ptr_impl(),"}]}