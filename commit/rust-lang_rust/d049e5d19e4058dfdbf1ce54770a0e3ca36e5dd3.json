{"sha": "d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNDllNWQxOWU0MDU4ZGZkYmYxY2U1NDc3MGEwZTNjYTM2ZTVkZDM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-11-23T21:03:47Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-11-25T20:57:59Z"}, "message": "avoid type-live-for-region obligations on dummy nodes\n\nType-live-for-region obligations on DUMMY_NODE_ID cause an ICE, and it\nturns out that in the few cases they are needed, these obligations are not\nneeded anyway because they are verified elsewhere.\n\nFixes #46069.", "tree": {"sha": "af0f1fd4f8ef2e34f0cab1e8e90bd8f8f3738b07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af0f1fd4f8ef2e34f0cab1e8e90bd8f8f3738b07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "html_url": "https://github.com/rust-lang/rust/commit/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f47a9eb80bc3474b6e89637269ef1f92cfccb7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f47a9eb80bc3474b6e89637269ef1f92cfccb7f", "html_url": "https://github.com/rust-lang/rust/commit/2f47a9eb80bc3474b6e89637269ef1f92cfccb7f"}], "stats": {"total": 147, "additions": 117, "deletions": 30}, "files": [{"sha": "221d378d621867eabb7b35062cfdae935d2efd8a", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "patch": "@@ -88,6 +88,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         body_id: ast::NodeId,\n         obligation: RegionObligation<'tcx>,\n     ) {\n+        debug!(\"register_region_obligation({:?}, {:?})\", body_id, obligation);\n         self.region_obligations\n             .borrow_mut()\n             .push((body_id, obligation));"}, {"sha": "f56c3853de0ab67966ffc2a6eb8a82f6f40e1e64", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "patch": "@@ -46,6 +46,19 @@ pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n     predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n+    // Should this fulfillment context register type-lives-for-region\n+    // obligations on its parent infcx? In some cases, region\n+    // obligations are either already known to hold (normalization) or\n+    // hopefully verifed elsewhere (type-impls-bound), and therefore\n+    // should not be checked.\n+    //\n+    // Note that if we are normalizing a type that we already\n+    // know is well-formed, there should be no harm setting this\n+    // to true - all the region variables should be determinable\n+    // using the RFC 447 rules, which don't depend on\n+    // type-lives-for-region constraints, and because the type\n+    // is well-formed, the constraints should hold.\n+    register_region_obligations: bool,\n }\n \n #[derive(Clone, Debug)]\n@@ -59,6 +72,14 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n+            register_region_obligations: true\n+        }\n+    }\n+\n+    pub fn new_ignoring_regions() -> FulfillmentContext<'tcx> {\n+        FulfillmentContext {\n+            predicates: ObligationForest::new(),\n+            register_region_obligations: false\n         }\n     }\n \n@@ -191,7 +212,10 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             debug!(\"select: starting another iteration\");\n \n             // Process pending obligations.\n-            let outcome = self.predicates.process_obligations(&mut FulfillProcessor { selcx });\n+            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n+                selcx,\n+                register_region_obligations: self.register_region_obligations\n+            });\n             debug!(\"select: outcome={:?}\", outcome);\n \n             // FIXME: if we kept the original cache key, we could mark projection\n@@ -220,6 +244,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    register_region_obligations: bool\n }\n \n impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n@@ -230,7 +255,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                           obligation: &mut Self::Obligation)\n                           -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n     {\n-        process_predicate(self.selcx, obligation)\n+        process_predicate(self.selcx, obligation, self.register_region_obligations)\n             .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n                 obligation: o,\n                 stalled_on: vec![]\n@@ -269,7 +294,8 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n /// - `Err` if the predicate does not hold\n fn process_predicate<'a, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-    pending_obligation: &mut PendingPredicateObligation<'tcx>)\n+    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n+    register_region_obligations: bool)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n               FulfillmentErrorCode<'tcx>>\n {\n@@ -391,26 +417,30 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                         // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n                         Some(t_a) => {\n                             let r_static = selcx.tcx().types.re_static;\n-                            selcx.infcx().register_region_obligation(\n-                                obligation.cause.body_id,\n-                                RegionObligation {\n-                                    sup_type: t_a,\n-                                    sub_region: r_static,\n-                                    cause: obligation.cause.clone(),\n-                                });\n+                            if register_region_obligations {\n+                                selcx.infcx().register_region_obligation(\n+                                    obligation.cause.body_id,\n+                                    RegionObligation {\n+                                        sup_type: t_a,\n+                                        sub_region: r_static,\n+                                        cause: obligation.cause.clone(),\n+                                    });\n+                            }\n                             Ok(Some(vec![]))\n                         }\n                     }\n                 }\n                 // If there aren't, register the obligation.\n                 Some(ty::OutlivesPredicate(t_a, r_b)) => {\n-                    selcx.infcx().register_region_obligation(\n-                        obligation.cause.body_id,\n-                        RegionObligation {\n-                            sup_type: t_a,\n-                            sub_region: r_b,\n-                            cause: obligation.cause.clone()\n-                        });\n+                    if register_region_obligations {\n+                        selcx.infcx().register_region_obligation(\n+                            obligation.cause.body_id,\n+                            RegionObligation {\n+                                sup_type: t_a,\n+                                sub_region: r_b,\n+                                cause: obligation.cause.clone()\n+                            });\n+                    }\n                     Ok(Some(vec![]))\n                 }\n             }"}, {"sha": "55bd10e922535027da392f33faa07a0a871f7e4f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "patch": "@@ -431,7 +431,7 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         // this function's result remains infallible, we must confirm\n         // that guess. While imperfect, I believe this is sound.\n \n-        let mut fulfill_cx = FulfillmentContext::new();\n+        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n \n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n@@ -583,9 +583,6 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                           -> Result<T, Vec<FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx>\n {\n-    debug!(\"fully_normalize(value={:?})\", value);\n-\n-    let selcx = &mut SelectionContext::new(infcx);\n     // FIXME (@jroesch) ISSUE 26721\n     // I'm not sure if this is a bug or not, needs further investigation.\n     // It appears that by reusing the fulfillment_cx here we incur more\n@@ -599,8 +596,21 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     //\n     // I think we should probably land this refactor and then come\n     // back to this is a follow-up patch.\n-    let mut fulfill_cx = FulfillmentContext::new();\n+    let fulfillcx = FulfillmentContext::new();\n+    fully_normalize_with_fulfillcx(infcx, fulfillcx, cause, param_env, value)\n+}\n \n+pub fn fully_normalize_with_fulfillcx<'a, 'gcx, 'tcx, T>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    mut fulfill_cx: FulfillmentContext<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    value: &T)\n+    -> Result<T, Vec<FulfillmentError<'tcx>>>\n+    where T : TypeFoldable<'tcx>\n+{\n+    debug!(\"fully_normalize_with_fulfillcx(value={:?})\", value);\n+    let selcx = &mut SelectionContext::new(infcx);\n     let Normalized { value: normalized_value, obligations } =\n         project::normalize(selcx, param_env, cause, value);\n     debug!(\"fully_normalize: normalized_value={:?} obligations={:?}\","}, {"sha": "f83e131c32765c57a399663edd76b6213929b6f1", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "patch": "@@ -241,7 +241,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // (which are packed up in penv)\n \n     infcx.save_and_restore_in_snapshot_flag(|infcx| {\n-        let mut fulfill_cx = FulfillmentContext::new();\n+        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n         for oblig in obligations.into_iter() {\n             fulfill_cx.register_predicate_obligation(&infcx, oblig);\n         }"}, {"sha": "e1e2798ecb51c052d61d483b742d4a623ef6f4ae", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "patch": "@@ -10,7 +10,7 @@\n \n use traits;\n use traits::project::Normalized;\n-use ty::{Lift, TyCtxt};\n+use ty::{self, Lift, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::fmt;\n@@ -28,9 +28,16 @@ impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n \n impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Obligation(predicate={:?},depth={})\",\n-               self.predicate,\n-               self.recursion_depth)\n+        if ty::tls::with(|tcx| tcx.sess.verbose()) {\n+            write!(f, \"Obligation(predicate={:?},cause={:?},depth={})\",\n+                   self.predicate,\n+                   self.cause,\n+                   self.recursion_depth)\n+        } else {\n+            write!(f, \"Obligation(predicate={:?},depth={})\",\n+                   self.predicate,\n+                   self.recursion_depth)\n+        }\n     }\n }\n "}, {"sha": "479680cc7fe79c40cc55a4ca17b5f9ff89eed54a", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "patch": "@@ -152,10 +152,17 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n             // associated types and parameters). We need to normalize\n             // associated types here and possibly recursively process.\n             for ty in dtorck_types {\n-                // FIXME -- I think that this may disregard some region obligations\n-                // or something. Do we care? -nmatsakis\n                 let cause = ObligationCause::dummy();\n-                match traits::fully_normalize(self.infcx, cause, self.param_env, &ty) {\n+                // We know that our original `dropped_ty` is well-formed,\n+                // so region obligations resulting from this normalization\n+                // should always hold.\n+                //\n+                // Therefore we ignore them instead of trying to match\n+                // them up with a location.\n+                let fulfillcx = traits::FulfillmentContext::new_ignoring_regions();\n+                match traits::fully_normalize_with_fulfillcx(\n+                    self.infcx, fulfillcx, cause, self.param_env, &ty\n+                ) {\n                     Ok(ty) => match ty.sty {\n                         ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n                             self.add_regular_live_constraint(ty, location);"}, {"sha": "70db20e4a6c9244dbc4514ab20c80e443ca80a77", "filename": "src/test/run-pass/issue-46069.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Ftest%2Frun-pass%2Fissue-46069.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3/src%2Ftest%2Frun-pass%2Fissue-46069.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-46069.rs?ref=d049e5d19e4058dfdbf1ce54770a0e3ca36e5dd3", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter::{Fuse, Cloned};\n+use std::slice::Iter;\n+\n+struct Foo<'a, T: 'a>(&'a T);\n+impl<'a, T: 'a> Copy for Foo<'a, T> {}\n+impl<'a, T: 'a> Clone for Foo<'a, T> {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+fn copy_ex() {\n+    let s = 2;\n+    let k1 = || s;\n+    let upvar = Foo(&k1);\n+    let k = || upvar;\n+    k();\n+}\n+\n+fn main() {\n+    let _f = 0 as *mut <Fuse<Cloned<Iter<u8>>> as Iterator>::Item;\n+\n+    copy_ex();\n+}"}]}