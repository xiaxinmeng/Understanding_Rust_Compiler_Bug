{"sha": "73811917f463d6cf52f04cd226507fdab891d8b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczODExOTE3ZjQ2M2Q2Y2Y1MmYwNGNkMjI2NTA3ZmRhYjg5MWQ4Yjk=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-28T23:39:29Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-29T22:36:16Z"}, "message": "Add the platform intrinsic generator script.\n\nThis python script will consume an appropriately formatted JSON file and\noutput either a Rust file for use in librustc_platform_intrinsics, or an\nextern block for importing the intrinsics in an external library.\n\nThe --help flag has details.", "tree": {"sha": "8eedeff3d869fc83d64914a4eee68cbff0f724bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eedeff3d869fc83d64914a4eee68cbff0f724bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73811917f463d6cf52f04cd226507fdab891d8b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73811917f463d6cf52f04cd226507fdab891d8b9", "html_url": "https://github.com/rust-lang/rust/commit/73811917f463d6cf52f04cd226507fdab891d8b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73811917f463d6cf52f04cd226507fdab891d8b9/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72382d247a008c4e51c2ce1e08b7c2a4ebd5e925", "url": "https://api.github.com/repos/rust-lang/rust/commits/72382d247a008c4e51c2ce1e08b7c2a4ebd5e925", "html_url": "https://github.com/rust-lang/rust/commit/72382d247a008c4e51c2ce1e08b7c2a4ebd5e925"}], "stats": {"total": 482, "additions": 482, "deletions": 0}, "files": [{"sha": "28378021efd0ad5745138fff5f3391589b226afe", "filename": "src/etc/platform-intrinsics/generator.py", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/73811917f463d6cf52f04cd226507fdab891d8b9/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "raw_url": "https://github.com/rust-lang/rust/raw/73811917f463d6cf52f04cd226507fdab891d8b9/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py?ref=73811917f463d6cf52f04cd226507fdab891d8b9", "patch": "@@ -0,0 +1,482 @@\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+from __future__ import division, print_function\n+import json\n+import argparse\n+import sys\n+import re\n+import textwrap\n+\n+SPEC = re.compile(\n+    r'^(?:(?P<id>[iusfIUSF])(?:\\((?P<start>\\d*)-(?P<end>\\d*)\\)|(?P<width>\\d*))' +\n+    r'|(?P<reference>\\d+)(?P<modifiers>[vShdnwus]*)(?P<force_width>x\\d+)?)$'\n+)\n+\n+class IntrinsicSet(object):\n+    def __init__(self, json):\n+        self._platform = json['platform']\n+        self._intrinsic_prefix = json['intrinsic_prefix']\n+        self._llvm_prefix = json['llvm_prefix']\n+        self._intrinsics = json['intrinsics']\n+        self._type_info = json['number_info']\n+        self._widths = json['widths']\n+\n+    def intrinsics(self):\n+        for raw in self._intrinsics:\n+            yield GenericIntrinsic(self,\n+                                   raw['intrinsic'], raw['width'], raw['llvm'],\n+                                   raw['ret'], raw['args'])\n+    def llvm_prefix(self):\n+        return self._llvm_prefix\n+    def intrinsic_prefix(self):\n+        return self._intrinsic_prefix\n+\n+    def width_name(self, bitwidth):\n+        return self._widths[str(bitwidth)]\n+\n+    def number_type_info(self, value):\n+        data = self._type_info[value.__class__.__name__.lower()]\n+        bitwidth = value.bitwidth()\n+        raw_dtype = data['data_type']\n+        try:\n+            dtype = raw_dtype[str(bitwidth)]\n+        except KeyError:\n+            dtype = raw_dtype['pattern'].format(bitwidth = bitwidth)\n+        return PlatformTypeInfo(data['kind'],\n+                                dtype,\n+                                value.llvm_name())\n+\n+class PlatformTypeInfo(object):\n+    def __init__(self, kind, data_type, llvm_name, width = None):\n+        self.kind = kind\n+        self.data_type = data_type\n+        self.llvm_name = llvm_name\n+        if width is not None:\n+            self.width = width\n+    def vectorize(self, length, width):\n+        return PlatformTypeInfo(self.kind, self.data_type,\n+                                'v{}{}'.format(length, self.llvm_name),\n+                                width)\n+\n+class Type(object):\n+    def __init__(self, bitwidth):\n+        self._bitwidth = bitwidth\n+\n+    def bitwidth(self):\n+        return self._bitwidth\n+    def modify(self, spec, width):\n+        raise NotImplementedError()\n+\n+class Number(Type):\n+    def __init__(self, bitwidth):\n+        Type.__init__(self, bitwidth)\n+    def modify(self, spec, width):\n+        if spec == 'w':\n+            return self.__class__(self.bitwidth() * 2)\n+        elif spec == 'n':\n+            return self.__class__(self.bitwidth() // 2)\n+        elif spec == 'v':\n+            return Vector(self, width // self.bitwidth())\n+        else:\n+            raise ValueError('unknown modification spec {}', spec)\n+\n+    def type_info(self, platform_info):\n+        return platform_info.number_type_info(self)\n+\n+class Signed(Number):\n+    def __init__(self, bitwidth):\n+        Number.__init__(self, bitwidth)\n+    def modify(self, spec, width):\n+        if spec == 'u':\n+            return Unsigned(self.bitwidth())\n+        elif spec == 's':\n+            return Signed(self.bitwidth())\n+        else:\n+            return Number.modify(self, spec, width)\n+    def compiler_ctor(self):\n+        return 'i({})'.format(self.bitwidth())\n+    def llvm_name(self):\n+        return 'i{}'.format(self.bitwidth())\n+    def rust_name(self):\n+        return 'i{}'.format(self.bitwidth())\n+\n+class Unsigned(Number):\n+    def __init__(self, bitwidth):\n+        Number.__init__(self, bitwidth)\n+    def modify(self, spec, width):\n+        if spec == 'u':\n+            return Unsigned(self.bitwidth())\n+        elif spec == 's':\n+            return Signed(self.bitwidth())\n+        else:\n+            return Number.modify(self, spec, width)\n+    def compiler_ctor(self):\n+        return 'u({})'.format(self.bitwidth())\n+    def llvm_name(self):\n+        return 'i{}'.format(self.bitwidth())\n+    def rust_name(self):\n+        return 'u{}'.format(self.bitwidth())\n+class Float(Number):\n+    def __init__(self, bitwidth):\n+        assert bitwidth in (32, 64)\n+        Number.__init__(self, bitwidth)\n+    def compiler_ctor(self):\n+        return 'f({})'.format(self.bitwidth())\n+    def llvm_name(self):\n+        return 'f{}'.format(self.bitwidth())\n+    def rust_name(self):\n+        return 'f{}'.format(self.bitwidth())\n+\n+class Vector(Type):\n+    def __init__(self, elem, length):\n+        assert isinstance(elem, Type) and not isinstance(elem, Vector)\n+        Type.__init__(self,\n+                      elem.bitwidth() * length)\n+        self._length = length\n+        self._elem = elem\n+    def modify(self, spec, width):\n+        if spec == 'h':\n+            return Vector(self._elem, self._length // 2)\n+        elif spec == 'd':\n+            return Vector(self._elem, self._length * 2)\n+        elif spec.startswith('x'):\n+            new_bitwidth = int(spec[1:])\n+            return Vector(self._elem, new_bitwidth // self._elem.bitwidth())\n+        else:\n+            return Vector(self._elem.modify(spec, width), self._length)\n+    def compiler_ctor(self):\n+        return 'v({}, {})'.format(self._elem.compiler_ctor(), self._length)\n+    def rust_name(self):\n+        return '{}x{}'.format(self._elem.rust_name(), self._length)\n+    def type_info(self, platform_info):\n+        elem_info = self._elem.type_info(platform_info)\n+        return elem_info.vectorize(self._length,\n+                                   platform_info.width_name(self.bitwidth()))\n+\n+class Aggregate(Type):\n+    def __init__(self, flatten, elems):\n+        self._flatten = flatten\n+        self._elems = elems\n+        Type.__init__(self,\n+                      sum(elem.bitwidth() for elem in elems))\n+    def __repr__(self):\n+        return '<Aggregate {}>'.format(self._elems)\n+    def compiler_ctor(self):\n+        return 'agg({}, vec![{}])'.format('true' if self._flatten else 'false',\n+                                          ', '.join(elem.compiler_ctor() for elem in self._elems))\n+    def rust_name(self):\n+        return '({})'.format(', '.join(elem.rust_name() for elem in self._elems))\n+    def type_info(self, platform_info):\n+        #return PlatformTypeInfo(None, None, self._llvm_name)\n+        return None\n+\n+\n+TYPE_ID_LOOKUP = {'i': [Signed, Unsigned],\n+                  's': [Signed],\n+                  'u': [Unsigned],\n+                  'f': [Float]}\n+\n+class TypeSpec(object):\n+    def __init__(self, spec):\n+        if not isinstance(spec, list):\n+            spec = [spec]\n+\n+        self.spec = spec\n+    def enumerate(self, width):\n+        for spec in self.spec:\n+            match = SPEC.match(spec)\n+            if match:\n+                id = match.group('id')\n+                is_vector = id.islower()\n+                type_ctors = TYPE_ID_LOOKUP[id.lower()]\n+                start = match.group('start')\n+                if start is not None:\n+                    end = match.group('end')\n+                else:\n+                    start = end = match.group('width')\n+                start = int(start)\n+                end = int(end)\n+\n+                bitwidth = start\n+                while bitwidth <= end:\n+                    for ctor in type_ctors:\n+                        scalar = ctor(bitwidth)\n+                        if is_vector:\n+\n+                            yield Vector(scalar, width // bitwidth)\n+                        else:\n+                            yield scalar\n+                    bitwidth *= 2\n+            else:\n+                print('Failed to parse: {}'.format(spec), file=sys.stderr)\n+    def resolve(self, width, zero):\n+        assert len(self.spec) == 1\n+        spec = self.spec[0]\n+        match = SPEC.match(spec)\n+        if match:\n+            id  = match.group('id')\n+            if id is not None:\n+                options = list(self.enumerate(width))\n+                assert len(options) == 1\n+                return options[0]\n+            reference = match.group('reference')\n+            if reference != '0':\n+                raise NotImplementedError('only argument 0 (return value) references are supported')\n+            ret = zero\n+            for x in match.group('modifiers') or []:\n+                ret = ret.modify(x, width)\n+            force = match.group('force_width')\n+            if force is not None:\n+                ret = ret.modify(force, width)\n+            return ret\n+        elif spec.startswith('('):\n+            if spec.endswith(')'):\n+                raise NotImplementedError()\n+            elif spec.endswith(')f'):\n+                true_spec = spec[1:-2]\n+                flatten = True\n+            elems = [TypeSpec(subspec).resolve(width, zero) for subspec in true_spec.split(',')]\n+            return Aggregate(flatten, elems)\n+\n+class GenericIntrinsic(object):\n+    def __init__(self, platform, intrinsic, widths, llvm_name, ret, args):\n+        self._platform = platform\n+        self.intrinsic = intrinsic\n+        self.widths = map(int, widths)\n+        self.llvm_name = llvm_name\n+        self.ret = TypeSpec(ret)\n+        self.args = list(map(TypeSpec, args))\n+\n+    def monomorphise(self):\n+        for width in self.widths:\n+            assert width in (64, 128)\n+            for ret in self.ret.enumerate(width):\n+                args = [arg.resolve(width, ret) for arg in self.args]\n+                yield MonomorphicIntrinsic(self._platform, self.intrinsic, width, self.llvm_name,\n+                                           ret, args)\n+\n+class MonomorphicIntrinsic(object):\n+    def __init__(self, platform, intrinsic, width, llvm_name, ret, args):\n+        self._platform = platform\n+        self._intrinsic = intrinsic\n+        self._width = '' if width == 64 else 'q'\n+        self._llvm_name = llvm_name\n+        self._ret_raw = ret\n+        self._ret = ret.type_info(platform)\n+        self._args_raw = args\n+        self._args = [arg.type_info(platform) for arg in args]\n+    def llvm_name(self):\n+        if self._llvm_name.startswith('!'):\n+            return self._llvm_name[1:].format(self._ret, *self._args)\n+        else:\n+            return self._platform.llvm_prefix() + self._llvm_name.format(self._ret, *self._args)\n+    def intrinsic_suffix(self):\n+        return self._intrinsic.format(self._ret,\n+                                      *self._args,\n+                                      width = self._width)\n+    def intrinsic_name(self):\n+        return self._platform.intrinsic_prefix() + self.intrinsic_suffix()\n+    def compiler_args(self):\n+        return ', '.join(arg.compiler_ctor() for arg in self._args_raw)\n+    def compiler_ret(self):\n+        return self._ret_raw.compiler_ctor()\n+    def compiler_signature(self):\n+        return '({}) -> {}'.format(self.compiler_args(), self.compiler_ret())\n+    def intrinsic_signature(self):\n+        names = 'xyzwabcdef'\n+        return '({}) -> {}'.format(', '.join('{}: {}'.format(name, arg.rust_name())\n+                                             for name, arg in zip(names, self._args_raw)),\n+                                   self._ret.rust_name())\n+\n+def parse_args():\n+    parser = argparse.ArgumentParser(\n+        formatter_class = argparse.RawDescriptionHelpFormatter,\n+        description = 'Render an intrinsic definition JSON to various formats.',\n+        epilog = textwrap.dedent('''\\\n+        An intrinsic definition consists of a map with fields:\n+        - intrinsic: pattern for the name(s) of the vendor's C intrinsic(s)\n+        - llvm: pattern for the name(s) of the internal llvm intrinsic(s)\n+        - width: a vector of vector bit-widths the pattern works with\n+        - ret: type specifier for the return value\n+        - arguments: vector of type specifiers for arguments\n+\n+        The width and types describe a range of possible intrinsics,\n+        and these are fed back into the intrinsic and llvm patterns to\n+        create the appropriate definitions.\n+\n+        ## Type specifier grammar\n+\n+        ```\n+        type := vector | scalar | aggregate | reference\n+\n+        vector := vector_elem width |\n+        vector_elem := 'i' | 'u' | 's' | 'f'\n+\n+        scalar := scalar_type number\n+        scalar_type := 'U' | 'S' | 'F'\n+\n+        aggregate := '(' (type),* ')' 'f'?\n+\n+        reference := number modifiers*\n+        modifiers := 'v' | 'h' | 'd' | 'n' | 'w' | 'u' | 's' |\n+                     'x' number\n+\n+\n+        width = number | '(' number '-' number ')'\n+\n+        number = [0-9]+\n+        ```\n+\n+        ## Vectors\n+\n+        The vector grammar is a pattern describing many possibilities\n+        for arguments/return value. The `vector_elem` describes the\n+        types of elements to use, and the `width` describes the (range\n+        of) widths for those elements, which are then placed into a\n+        vector with the `width` bitwidth. E.g. if an intrinsic has a\n+        `width` that includes 128, and the return value is `i(8-32)`,\n+        then some instantiation of that intrinsic will be `u8x16`,\n+        `u32x4`, `i32x4`, etc.\n+\n+        ### Elements\n+\n+        - i: integer, both signed and unsigned\n+        - u: unsigned integer\n+        - s: signed integer\n+        - f: float\n+\n+        ## Scalars\n+\n+        Similar to vectors, but these describe a single concrete type,\n+        not a range. The number is the bitwidth.\n+\n+        ### Types\n+\n+        - U: unsigned integer\n+        - S: signed integer\n+        - F: float\n+\n+        ## Aggregates\n+\n+        An aggregate is a collection of multiple types; a tuple in\n+        Rust terms, or an unnamed struct in LLVM. The `f` modifiers\n+        forces the tuple to be flattened in the LLVM\n+        intrinsic. E.g. if `llvm.foo` takes `(F32,S32)`:\n+\n+        - no `f` corresponds to `declare ... @llvm.foo({float, i32})`.\n+        - having an `f` corresponds to `declare ... @llvm.foo(float, i32)`.\n+\n+\n+        (Currently aggregates can not contain other aggregates.)\n+\n+        ## References\n+\n+        A reference uses the type of another argument, with possible\n+        modifications. The number refers to the type to use, starting\n+        with 0 == return value, 1 == first argument, 2 == second\n+        argument, etc. (Currently only referencing 0, the return\n+        value, is supported.)\n+\n+        ### Modifiers\n+\n+        - 'v': put a scalar into a vector of the current width (u32 -> u32x4, when width == 128)\n+        - 'h': half the length of the vector (u32x4 -> u32x2)\n+        - 'd': double the length of the vector (u32x2 -> u32x4)\n+        - 'n': narrow the element of the vector (u32x4 -> u16x4)\n+        - 'w': widen the element of the vector (u16x4 -> u32x4)\n+        - 'u': force an integer (vector or scalar) to be unsigned (i32x4 -> u32x4)\n+        - 's': force an integer (vector or scalar) to be signed (u32x4 -> i32x4)\n+        - 'x' number: force the type to be a vector of bitwidth `number`.\n+        '''))\n+    parser.add_argument('--format', choices=FORMATS, required=True,\n+                        help = 'Output format.')\n+    parser.add_argument('-o', '--out', type=argparse.FileType('w'), default=sys.stdout,\n+                        help = 'File to output to (default stdout).')\n+    parser.add_argument('in_', metavar=\"FILE\", type=argparse.FileType('r'),\n+                        help = 'JSON file to load')\n+    return parser.parse_args()\n+\n+\n+class ExternBlock(object):\n+    def __init__(self):\n+        pass\n+    def open(self, platform):\n+        return 'extern \"platform-intrinsic\" {'\n+    def render(self, mono):\n+        return '    fn {}{};'.format(mono.intrinsic_name(),\n+                                     mono.intrinsic_signature())\n+    def close(self):\n+        return '}'\n+\n+class CompilerDefs(object):\n+    def __init__(self):\n+        pass\n+    def open(self, platform):\n+        return '''\\\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// DO NOT EDIT: autogenerated by etc/platform-intrinsics/generator.py\n+// ignore-tidy-linelength\n+\n+use {{Intrinsic, i, u, f, v, agg}};\n+use IntrinsicDef::Named;\n+use rustc::middle::ty;\n+\n+pub fn find<'tcx>(_tcx: &ty::ctxt<'tcx>, name: &str) -> Option<Intrinsic> {{\n+    if !name.starts_with(\"{0}\") {{ return None }}\n+    Some(match &name[\"{0}\".len()..] {{'''.format(platform.intrinsic_prefix())\n+\n+    def render(self, mono):\n+        return '''\\\n+        \"{}\" => Intrinsic {{\n+            inputs: vec![{}],\n+            output: {},\n+            definition: Named(\"{}\")\n+        }},'''.format(mono.intrinsic_suffix(),\n+                      mono.compiler_args(),\n+                      mono.compiler_ret(),\n+                      mono.llvm_name())\n+    def close(self):\n+        return '''\\\n+        _ => return None,\n+    })\n+}'''\n+\n+FORMATS = {\n+    'extern-block': ExternBlock(),\n+    'compiler-defs': CompilerDefs(),\n+}\n+\n+\n+def main():\n+    args = parse_args()\n+    in_ = args.in_\n+    out = args.out\n+    out_format = FORMATS[args.format]\n+\n+    intrinsics = IntrinsicSet(json.load(in_))\n+\n+    print(out_format.open(intrinsics), file=out)\n+    for intr in intrinsics.intrinsics():\n+        for mono in intr.monomorphise():\n+            print(out_format.render(mono), file=out)\n+    print(out_format.close(), file=out)\n+\n+if __name__ == '__main__':\n+    main()"}]}