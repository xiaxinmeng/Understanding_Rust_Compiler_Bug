{"sha": "59b79f71e98fa96ce632d87dfb8cad0d9707bf9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5Yjc5ZjcxZTk4ZmE5NmNlNjMyZDg3ZGZiOGNhZDBkOTcwN2JmOWQ=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-09-19T22:59:06Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-12-07T05:56:51Z"}, "message": "SGX target: implement networking", "tree": {"sha": "c1db97192dd867a240a6647e6051b8a0e2889042", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1db97192dd867a240a6647e6051b8a0e2889042"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59b79f71e98fa96ce632d87dfb8cad0d9707bf9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59b79f71e98fa96ce632d87dfb8cad0d9707bf9d", "html_url": "https://github.com/rust-lang/rust/commit/59b79f71e98fa96ce632d87dfb8cad0d9707bf9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59b79f71e98fa96ce632d87dfb8cad0d9707bf9d/comments", "author": null, "committer": null, "parents": [{"sha": "1a894f135e972c30e79b4d7f836d69dbe49e7ead", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a894f135e972c30e79b4d7f836d69dbe49e7ead", "html_url": "https://github.com/rust-lang/rust/commit/1a894f135e972c30e79b4d7f836d69dbe49e7ead"}], "stats": {"total": 220, "additions": 167, "deletions": 53}, "files": [{"sha": "3614e1293c11219cb4a9cfb1b988cc38d5d0f689", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/59b79f71e98fa96ce632d87dfb8cad0d9707bf9d/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b79f71e98fa96ce632d87dfb8cad0d9707bf9d/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=59b79f71e98fa96ce632d87dfb8cad0d9707bf9d", "patch": "@@ -55,6 +55,61 @@ pub fn close(fd: Fd) {\n     unsafe { raw::close(fd) }\n }\n \n+fn string_from_bytebuffer(buf: &alloc::UserRef<ByteBuffer>, usercall: &str, arg: &str) -> String {\n+    String::from_utf8(copy_user_buffer(buf))\n+        .unwrap_or_else(|_| panic!(\"Usercall {}: expected {} to be valid UTF-8\", usercall, arg))\n+}\n+\n+pub fn bind_stream(addr: &str) -> IoResult<(Fd, String)> {\n+    unsafe {\n+        let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n+        let mut local = alloc::User::<ByteBuffer>::uninitialized();\n+        let fd = raw::bind_stream(\n+            addr_user.as_ptr(),\n+            addr_user.len(),\n+            local.as_raw_mut_ptr()\n+        ).from_sgx_result()?;\n+        let local = string_from_bytebuffer(&local, \"bind_stream\", \"local_addr\");\n+        Ok((fd, local))\n+    }\n+}\n+\n+pub fn accept_stream(fd: Fd) -> IoResult<(Fd, String, String)> {\n+    unsafe {\n+        let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n+        let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n+                                                               // without forcing coercion?\n+        let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n+        let fd = raw::accept_stream(\n+            fd,\n+            local.as_raw_mut_ptr(),\n+            peer.as_raw_mut_ptr()\n+        ).from_sgx_result()?;\n+        let local = string_from_bytebuffer(&local, \"accept_stream\", \"local_addr\");\n+        let peer = string_from_bytebuffer(&peer, \"accept_stream\", \"peer_addr\");\n+        Ok((fd, local, peer))\n+    }\n+}\n+\n+pub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {\n+    unsafe {\n+        let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n+        let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n+        let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n+                                                               // without forcing coercion?\n+        let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n+        let fd = raw::connect_stream(\n+            addr_user.as_ptr(),\n+            addr_user.len(),\n+            local.as_raw_mut_ptr(),\n+            peer.as_raw_mut_ptr()\n+        ).from_sgx_result()?;\n+        let local = string_from_bytebuffer(&local, \"connect_stream\", \"local_addr\");\n+        let peer = string_from_bytebuffer(&peer, \"connect_stream\", \"peer_addr\");\n+        Ok((fd, local, peer))\n+    }\n+}\n+\n pub fn launch_thread() -> IoResult<()> {\n     unsafe { raw::launch_thread().from_sgx_result() }\n }"}, {"sha": "176d230846dc25b0a8d61ba8c9a7162ac99946bf", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 112, "deletions": 53, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/59b79f71e98fa96ce632d87dfb8cad0d9707bf9d/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b79f71e98fa96ce632d87dfb8cad0d9707bf9d/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=59b79f71e98fa96ce632d87dfb8cad0d9707bf9d", "patch": "@@ -10,144 +10,182 @@\n \n use fmt;\n use io;\n-use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n+use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n use time::Duration;\n-use sys::{unsupported, Void};\n+use sys::{unsupported, Void, sgx_ineffective};\n+use sys::fd::FileDesc;\n use convert::TryFrom;\n+use error;\n+use sync::Arc;\n \n-pub struct TcpStream(Void);\n+use super::abi::usercalls;\n+\n+const DEFAULT_FAKE_TTL: u32 = 64;\n+\n+#[derive(Debug, Clone)]\n+struct Socket {\n+    inner: Arc<FileDesc>,\n+    local_addr: String,\n+}\n+\n+impl Socket {\n+    fn new(fd: usercalls::Fd, local_addr: String) -> Socket {\n+        Socket { inner: Arc::new(FileDesc::new(fd)), local_addr }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct TcpStream {\n+    inner: Socket,\n+    peer_addr: String,\n+}\n+\n+fn io_err_to_addr(result: io::Result<&SocketAddr>) -> io::Result<String> {\n+    match result {\n+        Ok(saddr) => Ok(saddr.to_string()),\n+        // need to downcast twice because io::Error::into_inner doesn't return the original\n+        // value if the conversion fails\n+        Err(e) => if e.get_ref().and_then(|e| e.downcast_ref::<NonIpSockAddr>()).is_some() {\n+            Ok(e.into_inner().unwrap().downcast::<NonIpSockAddr>().unwrap().host)\n+        } else {\n+            Err(e)\n+        }\n+    }\n+}\n+\n+fn addr_to_sockaddr(addr: &str) -> io::Result<SocketAddr> {\n+    // unwrap OK: if an iterator is returned, we're guaranteed to get exactly one entry\n+    addr.to_socket_addrs().map(|mut it| it.next().unwrap())\n+}\n \n impl TcpStream {\n-    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n-        unsupported()\n+    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n+        let addr = io_err_to_addr(addr)?;\n+        let (fd, local_addr, peer_addr) = usercalls::connect_stream(&addr)?;\n+        Ok(TcpStream { inner: Socket::new(fd, local_addr), peer_addr })\n     }\n \n-    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n-        unsupported()\n+    pub fn connect_timeout(addr: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n+        Self::connect(Ok(addr)) // FIXME: ignoring timeout\n     }\n \n     pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        match self.0 {}\n+        sgx_ineffective(())\n     }\n \n     pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        match self.0 {}\n+        sgx_ineffective(())\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        match self.0 {}\n+        sgx_ineffective(None)\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        match self.0 {}\n+        sgx_ineffective(None)\n     }\n \n     pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+        Ok(0)\n     }\n \n-    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.inner.read(buf)\n     }\n \n-    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.inner.inner.write(buf)\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        addr_to_sockaddr(&self.peer_addr)\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        addr_to_sockaddr(&self.inner.local_addr)\n     }\n \n     pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n-        match self.0 {}\n+        sgx_ineffective(())\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpStream> {\n-        match self.0 {}\n+        Ok(self.clone())\n     }\n \n     pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        sgx_ineffective(())\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        sgx_ineffective(false)\n     }\n \n     pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        sgx_ineffective(())\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        match self.0 {}\n+        sgx_ineffective(DEFAULT_FAKE_TTL)\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        match self.0 {}\n+        Ok(None)\n     }\n \n     pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        sgx_ineffective(())\n     }\n }\n \n-impl fmt::Debug for TcpStream {\n-    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.0 {}\n-    }\n+#[derive(Debug, Clone)]\n+pub struct TcpListener {\n+    inner: Socket,\n }\n \n-pub struct TcpListener(Void);\n-\n impl TcpListener {\n-    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n-        unsupported()\n+    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n+        let addr = io_err_to_addr(addr)?;\n+        let (fd, local_addr) = usercalls::bind_stream(&addr)?;\n+        Ok(TcpListener { inner: Socket::new(fd, local_addr) })\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        addr_to_sockaddr(&self.inner.local_addr)\n     }\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n-        match self.0 {}\n+        let (fd, local_addr, peer_addr) = usercalls::accept_stream(self.inner.inner.raw())?;\n+        let ret_peer = addr_to_sockaddr(&peer_addr).unwrap_or_else(|_| ([0; 4], 0).into());\n+        Ok((TcpStream { inner: Socket::new(fd, local_addr), peer_addr }, ret_peer))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpListener> {\n-        match self.0 {}\n+        Ok(self.clone())\n     }\n \n     pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        sgx_ineffective(())\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        match self.0 {}\n+        sgx_ineffective(DEFAULT_FAKE_TTL)\n     }\n \n     pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        sgx_ineffective(())\n     }\n \n     pub fn only_v6(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        sgx_ineffective(false)\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        match self.0 {}\n+        Ok(None)\n     }\n \n     pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Debug for TcpListener {\n-    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.0 {}\n+        sgx_ineffective(())\n     }\n }\n \n@@ -285,9 +323,30 @@ impl fmt::Debug for UdpSocket {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct NonIpSockAddr {\n+    host: String\n+}\n+\n+impl error::Error for NonIpSockAddr {\n+    fn description(&self) -> &str {\n+        \"Failed to convert address to SocketAddr\"\n+    }\n+}\n+\n+impl fmt::Display for NonIpSockAddr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Failed to convert address to SocketAddr: {}\", self.host)\n+    }\n+}\n+\n pub struct LookupHost(Void);\n \n impl LookupHost {\n+    fn new(host: String) -> io::Result<LookupHost> {\n+        Err(io::Error::new(io::ErrorKind::Other, NonIpSockAddr { host }))\n+    }\n+\n     pub fn port(&self) -> u16 {\n         match self.0 {}\n     }\n@@ -303,16 +362,16 @@ impl Iterator for LookupHost {\n impl<'a> TryFrom<&'a str> for LookupHost {\n     type Error = io::Error;\n \n-    fn try_from(_v: &'a str) -> io::Result<LookupHost> {\n-        unsupported()\n+    fn try_from(v: &'a str) -> io::Result<LookupHost> {\n+        LookupHost::new(v.to_owned())\n     }\n }\n \n impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n     type Error = io::Error;\n \n-    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n-        unsupported()\n+    fn try_from((host, port): (&'a str, u16)) -> io::Result<LookupHost> {\n+        LookupHost::new(format!(\"{}:{}\", host, port))\n     }\n }\n "}]}