{"sha": "8047512dcab33780276771d398ddaee20ec8e933", "node_id": "C_kwDOAAsO6NoAKDgwNDc1MTJkY2FiMzM3ODAyNzY3NzFkMzk4ZGRhZWUyMGVjOGU5MzM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-10-18T12:18:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-18T12:18:59Z"}, "message": "Revert \"feat: Diagnose some incorrect usages of the question mark operator\"", "tree": {"sha": "84c3954252b82557d1ba23c133fe991afe267057", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84c3954252b82557d1ba23c133fe991afe267057"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8047512dcab33780276771d398ddaee20ec8e933", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjTpmzCRBK7hj4Ov3rIwAAL2YIACSQ3WdcDmhaFCWAdNUzXXn7\nA2iAhf9Lh7kw6hGcKPB5hqrt49IlBvo8C45qg73aw0j/dKQHhhYThORg8ThzZcQY\nWB8fR9aCJkTzSrG4yQwpeR/higEHqfZXqHAkzTQxgzPZ9HW4spD63pmF5OZLhM0Z\nOFD3yZuMmisW6HTfI8tfeuw6MMg6OxLMD5+ecBIIWTlLC/oQopIMM2JK01Tm/noD\ngdu0nrdcvwXbC1QECUifbuORMKCVvUcP7xL2qAdOeaCbegd3Art9kExdpDtEVEBn\n1HwLe3YcFrWxVyuqIPRzgUlS5XKtokNuCHowcAN+r6HZXI7rX16iNWHfLm499GI=\n=SX9A\n-----END PGP SIGNATURE-----\n", "payload": "tree 84c3954252b82557d1ba23c133fe991afe267057\nparent 4d4c05d32b58284949b2b5614e4a56cac3ebd8eb\nauthor Lukas Wirth <lukastw97@gmail.com> 1666095539 +0200\ncommitter GitHub <noreply@github.com> 1666095539 +0200\n\nRevert \"feat: Diagnose some incorrect usages of the question mark operator\"\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8047512dcab33780276771d398ddaee20ec8e933", "html_url": "https://github.com/rust-lang/rust/commit/8047512dcab33780276771d398ddaee20ec8e933", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8047512dcab33780276771d398ddaee20ec8e933/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d4c05d32b58284949b2b5614e4a56cac3ebd8eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d4c05d32b58284949b2b5614e4a56cac3ebd8eb", "html_url": "https://github.com/rust-lang/rust/commit/4d4c05d32b58284949b2b5614e4a56cac3ebd8eb"}], "stats": {"total": 414, "additions": 125, "deletions": 289}, "files": [{"sha": "d7586d129b768b1e639b915df81f51aa4a5c89b5", "filename": "crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=8047512dcab33780276771d398ddaee20ec8e933", "patch": "@@ -259,7 +259,6 @@ macro_rules! __known_path {\n     (core::future::Future) => {};\n     (core::future::IntoFuture) => {};\n     (core::ops::Try) => {};\n-    (core::ops::FromResidual) => {};\n     ($path:path) => {\n         compile_error!(\"Please register your known path in the path module\")\n     };"}, {"sha": "2679a1c3602671c35fcae81ba8f9fdef4eb90042", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=8047512dcab33780276771d398ddaee20ec8e933", "patch": "@@ -279,8 +279,6 @@ pub mod known {\n         RangeToInclusive,\n         RangeTo,\n         Range,\n-        Residual,\n-        FromResidual,\n         Neg,\n         Not,\n         None,"}, {"sha": "31e56dec62593770bb938e2ddaa7dc7f6b39731c", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=8047512dcab33780276771d398ddaee20ec8e933", "patch": "@@ -190,9 +190,7 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n     BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n-    IncorrectTryTarget { expr: ExprId },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n-    DoesNotImplement { expr: ExprId, trait_: TraitId, ty: Ty },\n }\n \n /// A mismatch between an expected and an inferred type.\n@@ -907,6 +905,17 @@ impl<'a> InferenceContext<'a> {\n         self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n+    fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n+        // FIXME resolve via lang_item once try v2 is stable\n+        let path = path![core::ops::Try];\n+        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n+        let trait_data = self.db.trait_data(trait_);\n+        trait_data\n+            // FIXME remove once try v2 is stable\n+            .associated_type_by_name(&name![Ok])\n+            .or_else(|| trait_data.associated_type_by_name(&name![Output]))\n+    }\n+\n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n         let trait_ = self.resolve_lang_item(name![neg])?.as_trait()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])"}, {"sha": "f56108b26c45bdaea3096f4616828c28ba260d12", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 8, "deletions": 91, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=8047512dcab33780276771d398ddaee20ec8e933", "patch": "@@ -19,24 +19,24 @@ use hir_def::{\n     resolver::resolver_for_expr,\n     ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n-use hir_expand::{name, name::Name};\n+use hir_expand::name::Name;\n use stdx::always;\n use syntax::ast::RangeOp;\n \n use crate::{\n     autoderef::{self, Autoderef},\n     consteval,\n-    infer::{coerce::CoerceMany, find_continuable, path, BreakableKind},\n+    infer::{coerce::CoerceMany, find_continuable, BreakableKind},\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n     mapping::{from_chalk, ToChalk},\n     method_resolution::{self, lang_names_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n-    static_lifetime, to_assoc_type_id, to_chalk_trait_id,\n+    static_lifetime, to_chalk_trait_id,\n     utils::{generics, Generics},\n-    AdtId, AliasEq, AliasTy, Binders, CallableDefId, FnPointer, FnSig, FnSubst, Interner,\n-    ProjectionTy, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    AdtId, Binders, CallableDefId, FnPointer, FnSig, FnSubst, Interner, Rawness, Scalar,\n+    Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n use super::{\n@@ -564,29 +564,9 @@ impl<'a> InferenceContext<'a> {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 self.resolve_associated_type(inner_ty, self.resolve_future_future_output())\n             }\n-            &Expr::Try { expr } => {\n-                let inner_ty = self.infer_expr_inner(expr, &Expectation::none());\n-                match self.resolve_try_impl_for(inner_ty.clone()) {\n-                    Some((_, Some((output, residual)))) => {\n-                        if let Some((_trait, false)) =\n-                            self.implements_from_residual(self.return_ty.clone(), residual)\n-                        {\n-                            self.push_diagnostic(InferenceDiagnostic::IncorrectTryTarget {\n-                                expr: tgt_expr,\n-                            });\n-                        }\n-                        output\n-                    }\n-                    Some((trait_, None)) => {\n-                        self.push_diagnostic(InferenceDiagnostic::DoesNotImplement {\n-                            expr,\n-                            trait_,\n-                            ty: inner_ty,\n-                        });\n-                        self.err_ty()\n-                    }\n-                    None => self.err_ty(),\n-                }\n+            Expr::Try { expr } => {\n+                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n+                self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok())\n             }\n             Expr::Cast { expr, type_ref } => {\n                 // FIXME: propagate the \"castable to\" expectation (and find a test case that shows this is necessary)\n@@ -1550,67 +1530,4 @@ impl<'a> InferenceContext<'a> {\n         let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n         (ctx.may_break.then(|| ctx.coerce.complete()), res)\n     }\n-\n-    /// Check whether `ty` implements `FromResidual<r>`\n-    fn implements_from_residual(&mut self, ty: Ty, r: Ty) -> Option<(hir_def::TraitId, bool)> {\n-        let from_residual_trait = self\n-            .resolver\n-            .resolve_known_trait(self.db.upcast(), &(super::path![core::ops::FromResidual]))?;\n-        let r = GenericArgData::Ty(r).intern(Interner);\n-        let b = TyBuilder::trait_ref(self.db, from_residual_trait);\n-        if b.remaining() != 2 {\n-            return Some((from_residual_trait, false));\n-        }\n-        let trait_ref = b.push(ty).push(r).build();\n-        Some((from_residual_trait, self.table.try_obligation(trait_ref.cast(Interner)).is_some()))\n-    }\n-\n-    fn resolve_try_impl_for(&mut self, ty: Ty) -> Option<(hir_def::TraitId, Option<(Ty, Ty)>)> {\n-        let path = path![core::ops::Try];\n-        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n-\n-        let trait_ref = TyBuilder::trait_ref(self.db, trait_).push(ty).build();\n-        let substitution = trait_ref.substitution.clone();\n-        self.push_obligation(trait_ref.clone().cast(Interner));\n-\n-        let trait_data = self.db.trait_data(trait_);\n-        let output = trait_data.associated_type_by_name(&name![Output]);\n-        let residual = trait_data.associated_type_by_name(&name![Residual]);\n-\n-        let output_ty = match output {\n-            Some(output) => {\n-                let output_ty = self.table.new_type_var();\n-                let alias_eq = AliasEq {\n-                    alias: AliasTy::Projection(ProjectionTy {\n-                        associated_ty_id: to_assoc_type_id(output),\n-                        substitution: substitution.clone(),\n-                    }),\n-                    ty: output_ty.clone(),\n-                };\n-                self.push_obligation(alias_eq.cast(Interner));\n-                output_ty\n-            }\n-            None => self.err_ty(),\n-        };\n-        let residual_ty = match residual {\n-            Some(residual) => {\n-                let residual_ty = self.table.new_type_var();\n-                let alias_eq = AliasEq {\n-                    alias: AliasTy::Projection(ProjectionTy {\n-                        associated_ty_id: to_assoc_type_id(residual),\n-                        substitution,\n-                    }),\n-                    ty: residual_ty.clone(),\n-                };\n-                self.push_obligation(alias_eq.cast(Interner));\n-                residual_ty\n-            }\n-            None => self.err_ty(),\n-        };\n-        // FIXME: We are doing the work twice here I think?\n-        Some((\n-            trait_,\n-            self.table.try_obligation(trait_ref.cast(Interner)).map(|_| (output_ty, residual_ty)),\n-        ))\n-    }\n }"}, {"sha": "5998680dcd395390dcee0197baf6c8b6052a8acb", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=8047512dcab33780276771d398ddaee20ec8e933", "patch": "@@ -1111,24 +1111,6 @@ pub fn resolve_indexing_op(\n     }\n     None\n }\n-/// Returns the receiver type for the try branch trait call.\n-pub fn resolve_branch_op(\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n-    ty: Canonical<Ty>,\n-    try_trait: TraitId,\n-) -> Option<ReceiverAdjustments> {\n-    let mut table = InferenceTable::new(db, env.clone());\n-    let ty = table.instantiate_canonical(ty);\n-    let (deref_chain, adj) = autoderef_method_receiver(&mut table, ty);\n-    for (ty, adj) in deref_chain.into_iter().zip(adj) {\n-        let goal = generic_implements_goal(db, env.clone(), try_trait, &ty);\n-        if db.trait_solve(env.krate, goal.cast(Interner)).is_some() {\n-            return Some(adj);\n-        }\n-    }\n-    None\n-}\n \n macro_rules! check_that {\n     ($cond:expr) => {"}, {"sha": "555b6972fb71eecb775979f640b33baa2e3a712e", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 87, "deletions": 5, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=8047512dcab33780276771d398ddaee20ec8e933", "patch": "@@ -162,16 +162,98 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_try() {\n+    check_types(\n+        r#\"\n+//- /main.rs crate:main deps:core\n+fn test() {\n+    let r: Result<i32, u64> = Result::Ok(1);\n+    let v = r?;\n+    v;\n+} //^ i32\n+\n+//- /core.rs crate:core\n+pub mod ops {\n+    pub trait Try {\n+        type Ok;\n+        type Error;\n+    }\n+}\n+\n+pub mod result {\n+    pub enum Result<O, E> {\n+        Ok(O),\n+        Err(E)\n+    }\n+\n+    impl<O, E> crate::ops::Try for Result<O, E> {\n+        type Ok = O;\n+        type Error = E;\n+    }\n+}\n+\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub use crate::{result::*, ops::*};\n+    }\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn infer_try_trait_v2() {\n     check_types(\n         r#\"\n-//- minicore: try\n-fn test() -> core::ops::ControlFlow<u32, f32> {\n-    let r: core::ops::ControlFlow<u32, f32> = core::ops::ControlFlow::Continue(1.0);\n+//- /main.rs crate:main deps:core\n+fn test() {\n+    let r: Result<i32, u64> = Result::Ok(1);\n     let v = r?;\n-      //^ f32\n-    r\n+    v;\n+} //^ i32\n+\n+//- /core.rs crate:core\n+mod ops {\n+    mod try_trait {\n+        pub trait Try: FromResidual {\n+            type Output;\n+            type Residual;\n+        }\n+        pub trait FromResidual<R = <Self as Try>::Residual> {}\n+    }\n+\n+    pub use self::try_trait::FromResidual;\n+    pub use self::try_trait::Try;\n+}\n+\n+mod convert {\n+    pub trait From<T> {}\n+    impl<T> From<T> for T {}\n+}\n+\n+pub mod result {\n+    use crate::convert::From;\n+    use crate::ops::{Try, FromResidual};\n+\n+    pub enum Infallible {}\n+    pub enum Result<O, E> {\n+        Ok(O),\n+        Err(E)\n+    }\n+\n+    impl<O, E> Try for Result<O, E> {\n+        type Output = O;\n+        type Error = Result<Infallible, E>;\n+    }\n+\n+    impl<T, E, F: From<E>> FromResidual<Result<Infallible, E>> for Result<T, F> {}\n+}\n+\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub use crate::result::*;\n+    }\n }\n \"#,\n     );"}, {"sha": "c5dc60f1ec5f962e319af3c48191fe2769984243", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=8047512dcab33780276771d398ddaee20ec8e933", "patch": "@@ -6,7 +6,7 @@\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n-use hir_def::{path::ModPath, TraitId};\n+use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n@@ -33,15 +33,13 @@ diagnostics![\n     BreakOutsideOfLoop,\n     InactiveCode,\n     IncorrectCase,\n-    IncorrectTryExpr,\n     InvalidDeriveTarget,\n     MacroError,\n     MalformedDerive,\n     MismatchedArgCount,\n     MissingFields,\n     MissingMatchArms,\n     MissingUnsafe,\n-    NotImplemented,\n     NoSuchField,\n     ReplaceFilterMapNextWithFindMap,\n     TypeMismatch,\n@@ -155,16 +153,6 @@ pub struct MismatchedArgCount {\n     pub expected: usize,\n     pub found: usize,\n }\n-#[derive(Debug)]\n-pub struct IncorrectTryExpr {\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n-}\n-#[derive(Debug)]\n-pub struct NotImplemented {\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n-    pub trait_: TraitId,\n-    pub ty: Type,\n-}\n \n #[derive(Debug)]\n pub struct MissingMatchArms {"}, {"sha": "f5324208c9a4ef12cf6704f1a9066b11c7378b27", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=8047512dcab33780276771d398ddaee20ec8e933", "patch": "@@ -81,12 +81,11 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, IncorrectTryExpr,\n-        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n-        MissingMatchArms, MissingUnsafe, NoSuchField, NotImplemented,\n-        ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n-        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n-        UnresolvedProcMacro,\n+        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n+        MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n+        MissingUnsafe, NoSuchField, ReplaceFilterMapNextWithFindMap, TypeMismatch,\n+        UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n+        UnresolvedModule, UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1283,45 +1282,30 @@ impl DefWithBody {\n         let infer = db.infer(self.into());\n         let source_map = Lazy::new(|| db.body_with_source_map(self.into()).1);\n         for d in &infer.diagnostics {\n-            match *d {\n+            match d {\n                 hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n-                    let field = source_map.field_syntax(expr);\n+                    let field = source_map.field_syntax(*expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n+                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n                     let expr = source_map\n                         .expr_syntax(expr)\n                         .expect(\"break outside of loop in synthetic syntax\");\n                     acc.push(BreakOutsideOfLoop { expr, is_break }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n-                    match source_map.expr_syntax(call_expr) {\n+                    match source_map.expr_syntax(*call_expr) {\n                         Ok(source_ptr) => acc.push(\n                             MismatchedArgCount {\n                                 call_expr: source_ptr,\n-                                expected: expected,\n-                                found: found,\n+                                expected: *expected,\n+                                found: *found,\n                             }\n                             .into(),\n                         ),\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n-                hir_ty::InferenceDiagnostic::IncorrectTryTarget { expr } => {\n-                    let expr = source_map.expr_syntax(expr).expect(\"try in synthetic syntax\");\n-                    acc.push(IncorrectTryExpr { expr }.into())\n-                }\n-                hir_ty::InferenceDiagnostic::DoesNotImplement { expr, trait_, ref ty } => {\n-                    let expr = source_map.expr_syntax(expr).expect(\"try in synthetic syntax\");\n-                    acc.push(\n-                        NotImplemented {\n-                            expr,\n-                            trait_,\n-                            ty: Type::new(db, DefWithBodyId::from(self), ty.clone()),\n-                        }\n-                        .into(),\n-                    )\n-                }\n             }\n         }\n         for (expr, mismatch) in infer.expr_type_mismatches() {"}, {"sha": "085d8d32598a1301acb9f96512d1f9d7e71a008b", "filename": "crates/ide-diagnostics/src/handlers/incorrect_try_expr.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4d4c05d32b58284949b2b5614e4a56cac3ebd8eb/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4c05d32b58284949b2b5614e4a56cac3ebd8eb/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs?ref=4d4c05d32b58284949b2b5614e4a56cac3ebd8eb", "patch": "@@ -1,37 +0,0 @@\n-use hir::InFile;\n-\n-use crate::{Diagnostic, DiagnosticsContext};\n-\n-// Diagnostic: incorrect-try-target\n-//\n-// This diagnostic is triggered if a question mark operator was used in a context where it is not applicable.\n-pub(crate) fn incorrect_try_expr(\n-    ctx: &DiagnosticsContext<'_>,\n-    d: &hir::IncorrectTryExpr,\n-) -> Diagnostic {\n-    Diagnostic::new(\n-        \"incorrect-try-target\",\n-        format!(\"the return type of the containing function does not implement `FromResidual`\"),\n-        ctx.sema\n-            .diagnostics_display_range(InFile::new(d.expr.file_id, d.expr.value.clone().into()))\n-            .range,\n-    )\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::check_diagnostics;\n-\n-    #[test]\n-    fn try_ops_diag() {\n-        check_diagnostics(\n-            r#\"\n-//- minicore: try\n-fn test() {\n-    core::ops::ControlFlow::<u32, f32>::Continue(1.0)?;\n- // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: the return type of the containing function does not implement `FromResidual`\n-}\n-\"#,\n-        );\n-    }\n-}"}, {"sha": "3bf6a4232298c7884a69c2ccd072f3483ed554c5", "filename": "crates/ide-diagnostics/src/handlers/not_implemented.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4d4c05d32b58284949b2b5614e4a56cac3ebd8eb/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4c05d32b58284949b2b5614e4a56cac3ebd8eb/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs?ref=4d4c05d32b58284949b2b5614e4a56cac3ebd8eb", "patch": "@@ -1,35 +0,0 @@\n-use hir::{db::DefDatabase, HirDisplay};\n-\n-use crate::{Diagnostic, DiagnosticsContext};\n-\n-// Diagnostic: not-implemented\n-//\n-// This diagnostic is triggered if a type doesn't implement a necessary trait.\n-pub(crate) fn not_implemented(ctx: &DiagnosticsContext<'_>, d: &hir::NotImplemented) -> Diagnostic {\n-    Diagnostic::new(\n-        \"not-implemented\",\n-        format!(\n-            \"the trait `{}` is not implemented for `{}`\",\n-            ctx.sema.db.trait_data(d.trait_).name,\n-            d.ty.display(ctx.sema.db)\n-        ),\n-        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n-    )\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::check_diagnostics;\n-\n-    #[test]\n-    fn missing_try_impl() {\n-        check_diagnostics(\n-            r#\"\n-//- minicore: try\n-fn main() {\n-    ()?;\n-} //^^ error: the trait `Try` is not implemented for `()`\n-\"#,\n-        )\n-    }\n-}"}, {"sha": "ae299f0584148937c64b897e7cf658359a5c7069", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=8047512dcab33780276771d398ddaee20ec8e933", "patch": "@@ -29,15 +29,13 @@ mod handlers {\n     pub(crate) mod break_outside_of_loop;\n     pub(crate) mod inactive_code;\n     pub(crate) mod incorrect_case;\n-    pub(crate) mod incorrect_try_expr;\n     pub(crate) mod invalid_derive_target;\n     pub(crate) mod macro_error;\n     pub(crate) mod malformed_derive;\n     pub(crate) mod mismatched_arg_count;\n     pub(crate) mod missing_fields;\n     pub(crate) mod missing_match_arms;\n     pub(crate) mod missing_unsafe;\n-    pub(crate) mod not_implemented;\n     pub(crate) mod no_such_field;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n     pub(crate) mod type_mismatch;\n@@ -227,14 +225,12 @@ pub fn diagnostics(\n         let d = match diag {\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n-            AnyDiagnostic::IncorrectTryExpr(d) => handlers::incorrect_try_expr::incorrect_try_expr(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => handlers::missing_fields::missing_fields(&ctx, &d),\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n-            AnyDiagnostic::NotImplemented(d) => handlers::not_implemented::not_implemented(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n             AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),"}, {"sha": "eb997e6fef83022f726dec8a2ff0e5cbcd6fdc86", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8047512dcab33780276771d398ddaee20ec8e933/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=8047512dcab33780276771d398ddaee20ec8e933", "patch": "@@ -4913,22 +4913,6 @@ fn foo() -> NotResult<(), Short> {\n                 ```\n             \"#]],\n     );\n-    check_hover_range(\n-        r#\"\n-//- minicore: try\n-use core::ops::ControlFlow;\n-fn foo() -> ControlFlow<()> {\n-    $0ControlFlow::Break(())?$0;\n-    ControlFlow::Continue(())\n-}\n-\"#,\n-        expect![[r#\"\n-            ```text\n-            Try Target Type: ControlFlow<(), {unknown}>\n-            Propagated as:          ControlFlow<(), ()>\n-            ```\n-        \"#]],\n-    );\n }\n \n #[test]\n@@ -4944,9 +4928,9 @@ fn foo() -> Option<()> {\n }\n \"#,\n         expect![[r#\"\n-            ```rust\n-            i32\n-            ```\"#]],\n+                ```rust\n+                <Option<i32> as Try>::Output\n+                ```\"#]],\n     );\n }\n "}, {"sha": "69d2e62b2567357541b81ab43bb83ea2ff1ac7f3", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 4, "deletions": 35, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8047512dcab33780276771d398ddaee20ec8e933/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8047512dcab33780276771d398ddaee20ec8e933/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=8047512dcab33780276771d398ddaee20ec8e933", "patch": "@@ -27,7 +27,6 @@\n //!     generator: pin\n //!     hash:\n //!     index: sized\n-//!     infallible:\n //!     iterator: option\n //!     iterators: iterator, fn\n //!     option:\n@@ -37,7 +36,7 @@\n //!     result:\n //!     sized:\n //!     slice:\n-//!     try: infallible\n+//!     try:\n //!     unsize: sized\n \n pub mod marker {\n@@ -151,9 +150,6 @@ pub mod convert {\n         fn as_ref(&self) -> &T;\n     }\n     // endregion:as_ref\n-    // region:infallible\n-    pub enum Infallible {}\n-    // endregion:infallible\n }\n \n pub mod ops {\n@@ -330,7 +326,7 @@ pub mod ops {\n             Continue(C),\n             Break(B),\n         }\n-        pub trait FromResidual<R = <Self as Try>::Residual> {\n+        pub trait FromResidual<R = Self::Residual> {\n             #[lang = \"from_residual\"]\n             fn from_residual(residual: R) -> Self;\n         }\n@@ -346,13 +342,13 @@ pub mod ops {\n \n         impl<B, C> Try for ControlFlow<B, C> {\n             type Output = C;\n-            type Residual = ControlFlow<B, crate::convert::Infallible>;\n+            type Residual = ControlFlow<B, convert::Infallible>;\n             fn from_output(output: Self::Output) -> Self {}\n             fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {}\n         }\n \n         impl<B, C> FromResidual for ControlFlow<B, C> {\n-            fn from_residual(residual: ControlFlow<B, crate::convert::Infallible>) -> Self {}\n+            fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {}\n         }\n     }\n     pub use self::try_::{ControlFlow, FromResidual, Try};\n@@ -473,33 +469,6 @@ pub mod option {\n             }\n         }\n     }\n-    // region:try\n-    impl<T> crate::ops::Try for Option<T> {\n-        type Output = T;\n-        type Residual = Option<crate::convert::Infallible>;\n-\n-        #[inline]\n-        fn from_output(output: Self::Output) -> Self {\n-            Some(output)\n-        }\n-\n-        #[inline]\n-        fn branch(self) -> crate::ops::ControlFlow<Self::Residual, Self::Output> {\n-            match self {\n-                Some(v) => crate::ops::ControlFlow::Continue(v),\n-                None => crate::ops::ControlFlow::Break(None),\n-            }\n-        }\n-    }\n-    impl<T> crate::ops::FromResidual for Option<T> {\n-        #[inline]\n-        fn from_residual(residual: Option<crate::convert::Infallible>) -> Self {\n-            match residual {\n-                None => None,\n-            }\n-        }\n-    }\n-    // endregion:try\n }\n // endregion:option\n "}]}