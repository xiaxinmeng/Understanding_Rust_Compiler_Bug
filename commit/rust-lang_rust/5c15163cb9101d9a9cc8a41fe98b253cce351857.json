{"sha": "5c15163cb9101d9a9cc8a41fe98b253cce351857", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMTUxNjNjYjkxMDFkOWE5Y2M4YTQxZmU5OGIyNTNjY2UzNTE4NTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-29T09:31:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-02T14:38:30Z"}, "message": "prove defaults meet WF requirements, not that they are WF\n\nIf we have\n\n```rust\nstruct Foo<T: Copy = String> { .. }\n```\n\nthe old code would have proven that `String: Copy` was WF -- this,\nincidentally, also proved that `String: Copy`. The new code just\nproves `String: Copy` directly.\n\nCo-authored-by: Tyler Mandry <tmandry@gmail.com>", "tree": {"sha": "9f663c4679c33cfcf7ab88c8a47ecb547da90de5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f663c4679c33cfcf7ab88c8a47ecb547da90de5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c15163cb9101d9a9cc8a41fe98b253cce351857", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c15163cb9101d9a9cc8a41fe98b253cce351857", "html_url": "https://github.com/rust-lang/rust/commit/5c15163cb9101d9a9cc8a41fe98b253cce351857", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c15163cb9101d9a9cc8a41fe98b253cce351857/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eb6969c6a2efba9e59544bc18b4d96a9f2b2504", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb6969c6a2efba9e59544bc18b4d96a9f2b2504", "html_url": "https://github.com/rust-lang/rust/commit/2eb6969c6a2efba9e59544bc18b4d96a9f2b2504"}], "stats": {"total": 78, "additions": 56, "deletions": 22}, "files": [{"sha": "85fdcd417ff9d830266d2fcd89634e0772f9228e", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5c15163cb9101d9a9cc8a41fe98b253cce351857/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c15163cb9101d9a9cc8a41fe98b253cce351857/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=5c15163cb9101d9a9cc8a41fe98b253cce351857", "patch": "@@ -364,15 +364,16 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Checks where clauses and inline bounds that are declared on def_id.\n-fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                                    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                    span: Span,\n-                                    def_id: DefId) {\n+fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+    span: Span,\n+    def_id: DefId,\n+) {\n     use ty::subst::Subst;\n     use rustc::ty::TypeFoldable;\n \n-    let mut predicates = fcx.tcx.predicates_of(def_id);\n-    let mut substituted_predicates = Vec::new();\n+    let predicates = fcx.tcx.predicates_of(def_id);\n \n     let generics = tcx.generics_of(def_id);\n     let is_our_default = |def: &ty::GenericParamDef| {\n@@ -433,7 +434,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n         }\n     });\n     // Now we build the substituted predicates.\n-    for &pred in predicates.predicates.iter() {\n+    let default_obligations = predicates.predicates.iter().flat_map(|&pred| {\n         struct CountParams { params: FxHashSet<u32> }\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n             fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n@@ -455,21 +456,37 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n         let substituted_pred = pred.subst(fcx.tcx, substs);\n         // Don't check non-defaulted params, dependent defaults (including lifetimes)\n         // or preds with multiple params.\n-        if substituted_pred.references_error() || param_count.params.len() > 1\n-            || has_region {\n-            continue;\n-        }\n-        // Avoid duplication of predicates that contain no parameters, for example.\n-        if !predicates.predicates.contains(&substituted_pred) {\n-            substituted_predicates.push(substituted_pred);\n+        if {\n+            substituted_pred.references_error() || param_count.params.len() > 1\n+                || has_region\n+        } {\n+                None\n+        } else if predicates.predicates.contains(&substituted_pred) {\n+            // Avoid duplication of predicates that contain no parameters, for example.\n+            None\n+        } else {\n+            Some(substituted_pred)\n         }\n-    }\n+    }).map(|pred| {\n+        // convert each of those into an obligation. So if you have\n+        // something like `struct Foo<T: Copy = String>`, we would\n+        // take that predicate `T: Copy`, substitute to `String: Copy`\n+        // (actually that happens in the previous `flat_map` call),\n+        // and then try to prove it (in this case, we'll fail).\n+        //\n+        // Note the subtle difference from how we handle `predicates`\n+        // below: there, we are not trying to prove those predicates\n+        // to be *true* but merely *well-formed*.\n+        let pred = fcx.normalize_associated_types_in(span, &pred);\n+        let cause = traits::ObligationCause::new(span, fcx.body_id, traits::ItemObligation(def_id));\n+        traits::Obligation::new(cause, fcx.param_env, pred)\n+    });\n \n-    predicates.predicates.extend(substituted_predicates);\n     let predicates = predicates.instantiate_identity(fcx.tcx);\n     let predicates = fcx.normalize_associated_types_in(span, &predicates);\n \n-    let obligations =\n+    debug!(\"check_where_clauses: predicates={:?}\", predicates.predicates);\n+    let wf_obligations =\n         predicates.predicates\n                     .iter()\n                     .flat_map(|p| ty::wf::predicate_obligations(fcx,\n@@ -478,7 +495,8 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                                                 p,\n                                                                 span));\n \n-    for obligation in obligations {\n+    for obligation in wf_obligations.chain(default_obligations) {\n+        debug!(\"next obligation cause: {:?}\", obligation.cause);\n         fcx.register_predicate(obligation);\n     }\n }"}, {"sha": "f6d7086679a52560d98bc7accb128866ed5ed3ab", "filename": "src/test/ui/type-check-defaults.stderr", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c15163cb9101d9a9cc8a41fe98b253cce351857/src%2Ftest%2Fui%2Ftype-check-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c15163cb9101d9a9cc8a41fe98b253cce351857/src%2Ftest%2Fui%2Ftype-check-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check-defaults.stderr?ref=5c15163cb9101d9a9cc8a41fe98b253cce351857", "patch": "@@ -30,23 +30,35 @@ error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not sa\n LL | struct Bounds<T:Copy=String>(T);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n    |\n-   = note: required by `std::marker::Copy`\n+note: required by `Bounds`\n+  --> $DIR/type-check-defaults.rs:21:1\n+   |\n+LL | struct Bounds<T:Copy=String>(T);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n   --> $DIR/type-check-defaults.rs:24:1\n    |\n LL | struct WhereClause<T=String>(T) where T: Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n    |\n-   = note: required by `std::marker::Copy`\n+note: required by `WhereClause`\n+  --> $DIR/type-check-defaults.rs:24:1\n+   |\n+LL | struct WhereClause<T=String>(T) where T: Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n   --> $DIR/type-check-defaults.rs:27:1\n    |\n LL | trait TraitBound<T:Copy=String> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n    |\n-   = note: required by `std::marker::Copy`\n+note: required by `TraitBound`\n+  --> $DIR/type-check-defaults.rs:27:1\n+   |\n+LL | trait TraitBound<T:Copy=String> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n   --> $DIR/type-check-defaults.rs:31:1\n@@ -68,7 +80,11 @@ LL | trait ProjectionPred<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `i32 + u8`\n    |\n    = help: the trait `std::ops::Add<u8>` is not implemented for `i32`\n-   = note: required by `std::ops::Add`\n+note: required by `ProjectionPred`\n+  --> $DIR/type-check-defaults.rs:34:1\n+   |\n+LL | trait ProjectionPred<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 7 previous errors\n "}]}